# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Dict, List, Mapping, Optional, Tuple, Union
from ... import _utilities, _tables
from . import outputs

__all__ = [
    'AddressSpec',
    'AddressSpecForwarders',
    'AddressSpecMessageTtl',
    'AddressSpecSubscription',
    'AddressStatus',
    'AddressStatusBrokerStatuses',
    'AddressStatusForwarders',
    'AddressStatusMessageTtl',
    'AddressStatusPlanStatus',
    'AddressStatusSubscription',
]

@pulumi.output_type
class AddressSpec(dict):
    def __init__(__self__, *,
                 address: str,
                 plan: str,
                 type: str,
                 forwarders: Optional[List['outputs.AddressSpecForwarders']] = None,
                 message_ttl: Optional['outputs.AddressSpecMessageTtl'] = None,
                 subscription: Optional['outputs.AddressSpecSubscription'] = None,
                 topic: Optional[str] = None):
        """
        :param str address: Messaging address.
        :param str plan: Plan referenced by this address.
        :param str type: Address type for this address.
        :param List['AddressSpecForwardersArgs'] forwarders: Address forwarders for this address.
        :param 'AddressSpecMessageTtlArgs' message_ttl: Further restricts message time-to-live (TTL). Applies to address types queue and topic only. The maximum and minimum values must fall with the minimum/maximum range described by the plan's TTL settings.
        :param 'AddressSpecSubscriptionArgs' subscription: Properties that can be set for subscription type addresses.
        :param str topic: Address of topic that this subscription refers to (only applicable to subscription types).
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "plan", plan)
        pulumi.set(__self__, "type", type)
        if forwarders is not None:
            pulumi.set(__self__, "forwarders", forwarders)
        if message_ttl is not None:
            pulumi.set(__self__, "message_ttl", message_ttl)
        if subscription is not None:
            pulumi.set(__self__, "subscription", subscription)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        Messaging address.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def plan(self) -> str:
        """
        Plan referenced by this address.
        """
        return pulumi.get(self, "plan")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Address type for this address.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def forwarders(self) -> Optional[List['outputs.AddressSpecForwarders']]:
        """
        Address forwarders for this address.
        """
        return pulumi.get(self, "forwarders")

    @property
    @pulumi.getter(name="messageTtl")
    def message_ttl(self) -> Optional['outputs.AddressSpecMessageTtl']:
        """
        Further restricts message time-to-live (TTL). Applies to address types queue and topic only. The maximum and minimum values must fall with the minimum/maximum range described by the plan's TTL settings.
        """
        return pulumi.get(self, "message_ttl")

    @property
    @pulumi.getter
    def subscription(self) -> Optional['outputs.AddressSpecSubscription']:
        """
        Properties that can be set for subscription type addresses.
        """
        return pulumi.get(self, "subscription")

    @property
    @pulumi.getter
    def topic(self) -> Optional[str]:
        """
        Address of topic that this subscription refers to (only applicable to subscription types).
        """
        return pulumi.get(self, "topic")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AddressSpecForwarders(dict):
    def __init__(__self__, *,
                 direction: str,
                 name: str,
                 remote_address: str):
        """
        :param str name: Forwarder name.
        :param str remote_address: Remote address to forward to. Must be prefixed with connector name.
        """
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "remote_address", remote_address)

    @property
    @pulumi.getter
    def direction(self) -> str:
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Forwarder name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="remoteAddress")
    def remote_address(self) -> str:
        """
        Remote address to forward to. Must be prefixed with connector name.
        """
        return pulumi.get(self, "remote_address")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AddressSpecMessageTtl(dict):
    """
    Further restricts message time-to-live (TTL). Applies to address types queue and topic only. The maximum and minimum values must fall with the minimum/maximum range described by the plan's TTL settings.
    """
    def __init__(__self__, *,
                 maximum: Optional[float] = None,
                 minimum: Optional[float] = None):
        """
        Further restricts message time-to-live (TTL). Applies to address types queue and topic only. The maximum and minimum values must fall with the minimum/maximum range described by the plan's TTL settings.
        :param float maximum: Imposes a maximum TTL value (in milliseconds) for messages arriving at the address.  Messages arriving with TTL values greater than this value (or no TTL value) will have their expiration adjusted.
        :param float minimum: Imposes a minimum TTL value (in milliseconds) for messages arriving at the address.  Messages arriving with TTL values less than this value will have their expiration adjusted.
        """
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)

    @property
    @pulumi.getter
    def maximum(self) -> Optional[float]:
        """
        Imposes a maximum TTL value (in milliseconds) for messages arriving at the address.  Messages arriving with TTL values greater than this value (or no TTL value) will have their expiration adjusted.
        """
        return pulumi.get(self, "maximum")

    @property
    @pulumi.getter
    def minimum(self) -> Optional[float]:
        """
        Imposes a minimum TTL value (in milliseconds) for messages arriving at the address.  Messages arriving with TTL values less than this value will have their expiration adjusted.
        """
        return pulumi.get(self, "minimum")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AddressSpecSubscription(dict):
    """
    Properties that can be set for subscription type addresses.
    """
    def __init__(__self__, *,
                 max_consumers: Optional[float] = None):
        """
        Properties that can be set for subscription type addresses.
        :param float max_consumers: Maximum number of concurrent consumers that can be attached to this subscription. If unspecified, 1 consumer is allowed per subscription
        """
        if max_consumers is not None:
            pulumi.set(__self__, "max_consumers", max_consumers)

    @property
    @pulumi.getter(name="maxConsumers")
    def max_consumers(self) -> Optional[float]:
        """
        Maximum number of concurrent consumers that can be attached to this subscription. If unspecified, 1 consumer is allowed per subscription
        """
        return pulumi.get(self, "max_consumers")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AddressStatus(dict):
    def __init__(__self__, *,
                 broker_statuses: Optional[List['outputs.AddressStatusBrokerStatuses']] = None,
                 forwarders: Optional[List['outputs.AddressStatusForwarders']] = None,
                 is_ready: Optional[bool] = None,
                 message_ttl: Optional['outputs.AddressStatusMessageTtl'] = None,
                 messages: Optional[List[str]] = None,
                 phase: Optional[str] = None,
                 plan_status: Optional['outputs.AddressStatusPlanStatus'] = None,
                 subscription: Optional['outputs.AddressStatusSubscription'] = None):
        """
        :param List['AddressStatusBrokerStatusesArgs'] broker_statuses: The status of this address in brokers.
        :param List['AddressStatusForwardersArgs'] forwarders: Forwarder status for this address.
        :param bool is_ready: Whether address is ready to use or not.
        :param 'AddressStatusMessageTtlArgs' message_ttl: Applied message TTL properties.
        :param List[str] messages: Status and error messages for address.
        :param str phase: Phase of address.
        :param 'AddressStatusSubscriptionArgs' subscription: Applied properties for subscription type addresses.
        """
        if broker_statuses is not None:
            pulumi.set(__self__, "broker_statuses", broker_statuses)
        if forwarders is not None:
            pulumi.set(__self__, "forwarders", forwarders)
        if is_ready is not None:
            pulumi.set(__self__, "is_ready", is_ready)
        if message_ttl is not None:
            pulumi.set(__self__, "message_ttl", message_ttl)
        if messages is not None:
            pulumi.set(__self__, "messages", messages)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if plan_status is not None:
            pulumi.set(__self__, "plan_status", plan_status)
        if subscription is not None:
            pulumi.set(__self__, "subscription", subscription)

    @property
    @pulumi.getter(name="brokerStatuses")
    def broker_statuses(self) -> Optional[List['outputs.AddressStatusBrokerStatuses']]:
        """
        The status of this address in brokers.
        """
        return pulumi.get(self, "broker_statuses")

    @property
    @pulumi.getter
    def forwarders(self) -> Optional[List['outputs.AddressStatusForwarders']]:
        """
        Forwarder status for this address.
        """
        return pulumi.get(self, "forwarders")

    @property
    @pulumi.getter(name="isReady")
    def is_ready(self) -> Optional[bool]:
        """
        Whether address is ready to use or not.
        """
        return pulumi.get(self, "is_ready")

    @property
    @pulumi.getter(name="messageTtl")
    def message_ttl(self) -> Optional['outputs.AddressStatusMessageTtl']:
        """
        Applied message TTL properties.
        """
        return pulumi.get(self, "message_ttl")

    @property
    @pulumi.getter
    def messages(self) -> Optional[List[str]]:
        """
        Status and error messages for address.
        """
        return pulumi.get(self, "messages")

    @property
    @pulumi.getter
    def phase(self) -> Optional[str]:
        """
        Phase of address.
        """
        return pulumi.get(self, "phase")

    @property
    @pulumi.getter(name="planStatus")
    def plan_status(self) -> Optional['outputs.AddressStatusPlanStatus']:
        return pulumi.get(self, "plan_status")

    @property
    @pulumi.getter
    def subscription(self) -> Optional['outputs.AddressStatusSubscription']:
        """
        Applied properties for subscription type addresses.
        """
        return pulumi.get(self, "subscription")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AddressStatusBrokerStatuses(dict):
    def __init__(__self__, *,
                 broker_id: Optional[str] = None,
                 cluster_id: Optional[str] = None,
                 state: Optional[str] = None):
        if broker_id is not None:
            pulumi.set(__self__, "broker_id", broker_id)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="brokerId")
    def broker_id(self) -> Optional[str]:
        return pulumi.get(self, "broker_id")

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[str]:
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        return pulumi.get(self, "state")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AddressStatusForwarders(dict):
    def __init__(__self__, *,
                 is_ready: Optional[bool] = None,
                 messages: Optional[List[str]] = None,
                 name: Optional[str] = None):
        if is_ready is not None:
            pulumi.set(__self__, "is_ready", is_ready)
        if messages is not None:
            pulumi.set(__self__, "messages", messages)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="isReady")
    def is_ready(self) -> Optional[bool]:
        return pulumi.get(self, "is_ready")

    @property
    @pulumi.getter
    def messages(self) -> Optional[List[str]]:
        return pulumi.get(self, "messages")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AddressStatusMessageTtl(dict):
    """
    Applied message TTL properties.
    """
    def __init__(__self__, *,
                 maximum: Optional[float] = None,
                 minimum: Optional[float] = None):
        """
        Applied message TTL properties.
        :param float maximum: Maximum TTL value
        :param float minimum: Minimum TTL value
        """
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)

    @property
    @pulumi.getter
    def maximum(self) -> Optional[float]:
        """
        Maximum TTL value
        """
        return pulumi.get(self, "maximum")

    @property
    @pulumi.getter
    def minimum(self) -> Optional[float]:
        """
        Minimum TTL value
        """
        return pulumi.get(self, "minimum")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AddressStatusPlanStatus(dict):
    def __init__(__self__, *,
                 name: str,
                 partitions: float,
                 resources: Mapping[str, Any]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "partitions", partitions)
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def partitions(self) -> float:
        return pulumi.get(self, "partitions")

    @property
    @pulumi.getter
    def resources(self) -> Mapping[str, Any]:
        return pulumi.get(self, "resources")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AddressStatusSubscription(dict):
    """
    Applied properties for subscription type addresses.
    """
    def __init__(__self__, *,
                 max_consumers: Optional[float] = None):
        """
        Applied properties for subscription type addresses.
        :param float max_consumers: Maximum number of concurrent consumers that can be attached to this subscription.
        """
        if max_consumers is not None:
            pulumi.set(__self__, "max_consumers", max_consumers)

    @property
    @pulumi.getter(name="maxConsumers")
    def max_consumers(self) -> Optional[float]:
        """
        Maximum number of concurrent consumers that can be attached to this subscription.
        """
        return pulumi.get(self, "max_consumers")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


