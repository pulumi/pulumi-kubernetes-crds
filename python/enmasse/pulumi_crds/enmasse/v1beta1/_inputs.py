# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Dict, List, Mapping, Optional, Tuple, Union
from ... import _utilities, _tables

__all__ = [
    'AddressSpecArgs',
    'AddressSpecForwardersArgs',
    'AddressSpecMessageTtlArgs',
    'AddressSpecSubscriptionArgs',
    'AddressStatusArgs',
    'AddressStatusBrokerStatusesArgs',
    'AddressStatusForwardersArgs',
    'AddressStatusMessageTtlArgs',
    'AddressStatusPlanStatusArgs',
    'AddressStatusSubscriptionArgs',
]

@pulumi.input_type
class AddressSpecArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[str],
                 plan: pulumi.Input[str],
                 type: pulumi.Input[str],
                 forwarders: Optional[pulumi.Input[List[pulumi.Input['AddressSpecForwardersArgs']]]] = None,
                 message_ttl: Optional[pulumi.Input['AddressSpecMessageTtlArgs']] = None,
                 subscription: Optional[pulumi.Input['AddressSpecSubscriptionArgs']] = None,
                 topic: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address: Messaging address.
        :param pulumi.Input[str] plan: Plan referenced by this address.
        :param pulumi.Input[str] type: Address type for this address.
        :param pulumi.Input[List[pulumi.Input['AddressSpecForwardersArgs']]] forwarders: Address forwarders for this address.
        :param pulumi.Input['AddressSpecMessageTtlArgs'] message_ttl: Further restricts message time-to-live (TTL). Applies to address types queue and topic only. The maximum and minimum values must fall with the minimum/maximum range described by the plan's TTL settings.
        :param pulumi.Input['AddressSpecSubscriptionArgs'] subscription: Properties that can be set for subscription type addresses.
        :param pulumi.Input[str] topic: Address of topic that this subscription refers to (only applicable to subscription types).
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "plan", plan)
        pulumi.set(__self__, "type", type)
        if forwarders is not None:
            pulumi.set(__self__, "forwarders", forwarders)
        if message_ttl is not None:
            pulumi.set(__self__, "message_ttl", message_ttl)
        if subscription is not None:
            pulumi.set(__self__, "subscription", subscription)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)

    @property
    @pulumi.getter
    def address(self) -> pulumi.Input[str]:
        """
        Messaging address.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[str]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def plan(self) -> pulumi.Input[str]:
        """
        Plan referenced by this address.
        """
        return pulumi.get(self, "plan")

    @plan.setter
    def plan(self, value: pulumi.Input[str]):
        pulumi.set(self, "plan", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Address type for this address.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def forwarders(self) -> Optional[pulumi.Input[List[pulumi.Input['AddressSpecForwardersArgs']]]]:
        """
        Address forwarders for this address.
        """
        return pulumi.get(self, "forwarders")

    @forwarders.setter
    def forwarders(self, value: Optional[pulumi.Input[List[pulumi.Input['AddressSpecForwardersArgs']]]]):
        pulumi.set(self, "forwarders", value)

    @property
    @pulumi.getter(name="messageTtl")
    def message_ttl(self) -> Optional[pulumi.Input['AddressSpecMessageTtlArgs']]:
        """
        Further restricts message time-to-live (TTL). Applies to address types queue and topic only. The maximum and minimum values must fall with the minimum/maximum range described by the plan's TTL settings.
        """
        return pulumi.get(self, "message_ttl")

    @message_ttl.setter
    def message_ttl(self, value: Optional[pulumi.Input['AddressSpecMessageTtlArgs']]):
        pulumi.set(self, "message_ttl", value)

    @property
    @pulumi.getter
    def subscription(self) -> Optional[pulumi.Input['AddressSpecSubscriptionArgs']]:
        """
        Properties that can be set for subscription type addresses.
        """
        return pulumi.get(self, "subscription")

    @subscription.setter
    def subscription(self, value: Optional[pulumi.Input['AddressSpecSubscriptionArgs']]):
        pulumi.set(self, "subscription", value)

    @property
    @pulumi.getter
    def topic(self) -> Optional[pulumi.Input[str]]:
        """
        Address of topic that this subscription refers to (only applicable to subscription types).
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topic", value)


@pulumi.input_type
class AddressSpecForwardersArgs:
    def __init__(__self__, *,
                 direction: pulumi.Input[str],
                 name: pulumi.Input[str],
                 remote_address: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Forwarder name.
        :param pulumi.Input[str] remote_address: Remote address to forward to. Must be prefixed with connector name.
        """
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "remote_address", remote_address)

    @property
    @pulumi.getter
    def direction(self) -> pulumi.Input[str]:
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: pulumi.Input[str]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Forwarder name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="remoteAddress")
    def remote_address(self) -> pulumi.Input[str]:
        """
        Remote address to forward to. Must be prefixed with connector name.
        """
        return pulumi.get(self, "remote_address")

    @remote_address.setter
    def remote_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "remote_address", value)


@pulumi.input_type
class AddressSpecMessageTtlArgs:
    def __init__(__self__, *,
                 maximum: Optional[pulumi.Input[float]] = None,
                 minimum: Optional[pulumi.Input[float]] = None):
        """
        Further restricts message time-to-live (TTL). Applies to address types queue and topic only. The maximum and minimum values must fall with the minimum/maximum range described by the plan's TTL settings.
        :param pulumi.Input[float] maximum: Imposes a maximum TTL value (in milliseconds) for messages arriving at the address.  Messages arriving with TTL values greater than this value (or no TTL value) will have their expiration adjusted.
        :param pulumi.Input[float] minimum: Imposes a minimum TTL value (in milliseconds) for messages arriving at the address.  Messages arriving with TTL values less than this value will have their expiration adjusted.
        """
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)

    @property
    @pulumi.getter
    def maximum(self) -> Optional[pulumi.Input[float]]:
        """
        Imposes a maximum TTL value (in milliseconds) for messages arriving at the address.  Messages arriving with TTL values greater than this value (or no TTL value) will have their expiration adjusted.
        """
        return pulumi.get(self, "maximum")

    @maximum.setter
    def maximum(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "maximum", value)

    @property
    @pulumi.getter
    def minimum(self) -> Optional[pulumi.Input[float]]:
        """
        Imposes a minimum TTL value (in milliseconds) for messages arriving at the address.  Messages arriving with TTL values less than this value will have their expiration adjusted.
        """
        return pulumi.get(self, "minimum")

    @minimum.setter
    def minimum(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "minimum", value)


@pulumi.input_type
class AddressSpecSubscriptionArgs:
    def __init__(__self__, *,
                 max_consumers: Optional[pulumi.Input[float]] = None):
        """
        Properties that can be set for subscription type addresses.
        :param pulumi.Input[float] max_consumers: Maximum number of concurrent consumers that can be attached to this subscription. If unspecified, 1 consumer is allowed per subscription
        """
        if max_consumers is not None:
            pulumi.set(__self__, "max_consumers", max_consumers)

    @property
    @pulumi.getter(name="maxConsumers")
    def max_consumers(self) -> Optional[pulumi.Input[float]]:
        """
        Maximum number of concurrent consumers that can be attached to this subscription. If unspecified, 1 consumer is allowed per subscription
        """
        return pulumi.get(self, "max_consumers")

    @max_consumers.setter
    def max_consumers(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_consumers", value)


@pulumi.input_type
class AddressStatusArgs:
    def __init__(__self__, *,
                 broker_statuses: Optional[pulumi.Input[List[pulumi.Input['AddressStatusBrokerStatusesArgs']]]] = None,
                 forwarders: Optional[pulumi.Input[List[pulumi.Input['AddressStatusForwardersArgs']]]] = None,
                 is_ready: Optional[pulumi.Input[bool]] = None,
                 message_ttl: Optional[pulumi.Input['AddressStatusMessageTtlArgs']] = None,
                 messages: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 phase: Optional[pulumi.Input[str]] = None,
                 plan_status: Optional[pulumi.Input['AddressStatusPlanStatusArgs']] = None,
                 subscription: Optional[pulumi.Input['AddressStatusSubscriptionArgs']] = None):
        """
        :param pulumi.Input[List[pulumi.Input['AddressStatusBrokerStatusesArgs']]] broker_statuses: The status of this address in brokers.
        :param pulumi.Input[List[pulumi.Input['AddressStatusForwardersArgs']]] forwarders: Forwarder status for this address.
        :param pulumi.Input[bool] is_ready: Whether address is ready to use or not.
        :param pulumi.Input['AddressStatusMessageTtlArgs'] message_ttl: Applied message TTL properties.
        :param pulumi.Input[List[pulumi.Input[str]]] messages: Status and error messages for address.
        :param pulumi.Input[str] phase: Phase of address.
        :param pulumi.Input['AddressStatusSubscriptionArgs'] subscription: Applied properties for subscription type addresses.
        """
        if broker_statuses is not None:
            pulumi.set(__self__, "broker_statuses", broker_statuses)
        if forwarders is not None:
            pulumi.set(__self__, "forwarders", forwarders)
        if is_ready is not None:
            pulumi.set(__self__, "is_ready", is_ready)
        if message_ttl is not None:
            pulumi.set(__self__, "message_ttl", message_ttl)
        if messages is not None:
            pulumi.set(__self__, "messages", messages)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if plan_status is not None:
            pulumi.set(__self__, "plan_status", plan_status)
        if subscription is not None:
            pulumi.set(__self__, "subscription", subscription)

    @property
    @pulumi.getter(name="brokerStatuses")
    def broker_statuses(self) -> Optional[pulumi.Input[List[pulumi.Input['AddressStatusBrokerStatusesArgs']]]]:
        """
        The status of this address in brokers.
        """
        return pulumi.get(self, "broker_statuses")

    @broker_statuses.setter
    def broker_statuses(self, value: Optional[pulumi.Input[List[pulumi.Input['AddressStatusBrokerStatusesArgs']]]]):
        pulumi.set(self, "broker_statuses", value)

    @property
    @pulumi.getter
    def forwarders(self) -> Optional[pulumi.Input[List[pulumi.Input['AddressStatusForwardersArgs']]]]:
        """
        Forwarder status for this address.
        """
        return pulumi.get(self, "forwarders")

    @forwarders.setter
    def forwarders(self, value: Optional[pulumi.Input[List[pulumi.Input['AddressStatusForwardersArgs']]]]):
        pulumi.set(self, "forwarders", value)

    @property
    @pulumi.getter(name="isReady")
    def is_ready(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether address is ready to use or not.
        """
        return pulumi.get(self, "is_ready")

    @is_ready.setter
    def is_ready(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_ready", value)

    @property
    @pulumi.getter(name="messageTtl")
    def message_ttl(self) -> Optional[pulumi.Input['AddressStatusMessageTtlArgs']]:
        """
        Applied message TTL properties.
        """
        return pulumi.get(self, "message_ttl")

    @message_ttl.setter
    def message_ttl(self, value: Optional[pulumi.Input['AddressStatusMessageTtlArgs']]):
        pulumi.set(self, "message_ttl", value)

    @property
    @pulumi.getter
    def messages(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        Status and error messages for address.
        """
        return pulumi.get(self, "messages")

    @messages.setter
    def messages(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "messages", value)

    @property
    @pulumi.getter
    def phase(self) -> Optional[pulumi.Input[str]]:
        """
        Phase of address.
        """
        return pulumi.get(self, "phase")

    @phase.setter
    def phase(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "phase", value)

    @property
    @pulumi.getter(name="planStatus")
    def plan_status(self) -> Optional[pulumi.Input['AddressStatusPlanStatusArgs']]:
        return pulumi.get(self, "plan_status")

    @plan_status.setter
    def plan_status(self, value: Optional[pulumi.Input['AddressStatusPlanStatusArgs']]):
        pulumi.set(self, "plan_status", value)

    @property
    @pulumi.getter
    def subscription(self) -> Optional[pulumi.Input['AddressStatusSubscriptionArgs']]:
        """
        Applied properties for subscription type addresses.
        """
        return pulumi.get(self, "subscription")

    @subscription.setter
    def subscription(self, value: Optional[pulumi.Input['AddressStatusSubscriptionArgs']]):
        pulumi.set(self, "subscription", value)


@pulumi.input_type
class AddressStatusBrokerStatusesArgs:
    def __init__(__self__, *,
                 broker_id: Optional[pulumi.Input[str]] = None,
                 cluster_id: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        if broker_id is not None:
            pulumi.set(__self__, "broker_id", broker_id)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="brokerId")
    def broker_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "broker_id")

    @broker_id.setter
    def broker_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "broker_id", value)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


@pulumi.input_type
class AddressStatusForwardersArgs:
    def __init__(__self__, *,
                 is_ready: Optional[pulumi.Input[bool]] = None,
                 messages: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        if is_ready is not None:
            pulumi.set(__self__, "is_ready", is_ready)
        if messages is not None:
            pulumi.set(__self__, "messages", messages)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="isReady")
    def is_ready(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_ready")

    @is_ready.setter
    def is_ready(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_ready", value)

    @property
    @pulumi.getter
    def messages(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        return pulumi.get(self, "messages")

    @messages.setter
    def messages(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "messages", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class AddressStatusMessageTtlArgs:
    def __init__(__self__, *,
                 maximum: Optional[pulumi.Input[float]] = None,
                 minimum: Optional[pulumi.Input[float]] = None):
        """
        Applied message TTL properties.
        :param pulumi.Input[float] maximum: Maximum TTL value
        :param pulumi.Input[float] minimum: Minimum TTL value
        """
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)

    @property
    @pulumi.getter
    def maximum(self) -> Optional[pulumi.Input[float]]:
        """
        Maximum TTL value
        """
        return pulumi.get(self, "maximum")

    @maximum.setter
    def maximum(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "maximum", value)

    @property
    @pulumi.getter
    def minimum(self) -> Optional[pulumi.Input[float]]:
        """
        Minimum TTL value
        """
        return pulumi.get(self, "minimum")

    @minimum.setter
    def minimum(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "minimum", value)


@pulumi.input_type
class AddressStatusPlanStatusArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 partitions: pulumi.Input[float],
                 resources: pulumi.Input[Mapping[str, Any]]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "partitions", partitions)
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def partitions(self) -> pulumi.Input[float]:
        return pulumi.get(self, "partitions")

    @partitions.setter
    def partitions(self, value: pulumi.Input[float]):
        pulumi.set(self, "partitions", value)

    @property
    @pulumi.getter
    def resources(self) -> pulumi.Input[Mapping[str, Any]]:
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: pulumi.Input[Mapping[str, Any]]):
        pulumi.set(self, "resources", value)


@pulumi.input_type
class AddressStatusSubscriptionArgs:
    def __init__(__self__, *,
                 max_consumers: Optional[pulumi.Input[float]] = None):
        """
        Applied properties for subscription type addresses.
        :param pulumi.Input[float] max_consumers: Maximum number of concurrent consumers that can be attached to this subscription.
        """
        if max_consumers is not None:
            pulumi.set(__self__, "max_consumers", max_consumers)

    @property
    @pulumi.getter(name="maxConsumers")
    def max_consumers(self) -> Optional[pulumi.Input[float]]:
        """
        Maximum number of concurrent consumers that can be attached to this subscription.
        """
        return pulumi.get(self, "max_consumers")

    @max_consumers.setter
    def max_consumers(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_consumers", value)


