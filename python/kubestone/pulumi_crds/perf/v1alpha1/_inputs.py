# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Dict, List, Mapping, Optional, Tuple, Union
from ... import _utilities, _tables

__all__ = [
    'DrillSpecArgs',
    'DrillSpecImageArgs',
    'DrillSpecPodConfigArgs',
    'DrillSpecPodConfigPodSchedulingArgs',
    'DrillSpecPodConfigPodSchedulingAffinityArgs',
    'DrillSpecPodConfigPodSchedulingAffinityNodeAffinityArgs',
    'DrillSpecPodConfigPodSchedulingAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'DrillSpecPodConfigPodSchedulingAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs',
    'DrillSpecPodConfigPodSchedulingAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs',
    'DrillSpecPodConfigPodSchedulingAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs',
    'DrillSpecPodConfigPodSchedulingAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'DrillSpecPodConfigPodSchedulingAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs',
    'DrillSpecPodConfigPodSchedulingAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs',
    'DrillSpecPodConfigPodSchedulingAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs',
    'DrillSpecPodConfigPodSchedulingAffinityPodAffinityArgs',
    'DrillSpecPodConfigPodSchedulingAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'DrillSpecPodConfigPodSchedulingAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs',
    'DrillSpecPodConfigPodSchedulingAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs',
    'DrillSpecPodConfigPodSchedulingAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs',
    'DrillSpecPodConfigPodSchedulingAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'DrillSpecPodConfigPodSchedulingAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs',
    'DrillSpecPodConfigPodSchedulingAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs',
    'DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityArgs',
    'DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs',
    'DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs',
    'DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs',
    'DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs',
    'DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs',
    'DrillSpecPodConfigPodSchedulingTolerationsArgs',
    'DrillSpecPodConfigResourcesArgs',
    'DrillStatusArgs',
]

@pulumi.input_type
class DrillSpecArgs:
    def __init__(__self__, *,
                 benchmark_file: pulumi.Input[str],
                 benchmarks_volume: pulumi.Input[Mapping[str, pulumi.Input[str]]],
                 image: pulumi.Input['DrillSpecImageArgs'],
                 options: Optional[pulumi.Input[str]] = None,
                 pod_config: Optional[pulumi.Input['DrillSpecPodConfigArgs']] = None):
        """
        DrillSpec defines benchmark run for drill load tester The benchmarkFile, and options is passed to drill as follows: drill [OPTIONS] --benchmark <benchmarkFile>
        :param pulumi.Input[str] benchmark_file: BenchmarkFile is the entry point file (passed to --benchmark) specified to drill.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] benchmarks_volume: BenchmarksVolume holds the content of benchmark files. The key of the map specifies the filename and the value is the content of the file. ConfigMap is created from the map which is mounted as benchmarks directory to the benchmark pod.
        :param pulumi.Input['DrillSpecImageArgs'] image: Image defines the drill docker image used for the benchmark
        :param pulumi.Input[str] options: Options are appended to the options parameter set of drill
        :param pulumi.Input['DrillSpecPodConfigArgs'] pod_config: PodConfig contains the configuration for the benchmark pod, including pod labels and scheduling policies (affinity, toleration, node selector...)
        """
        pulumi.set(__self__, "benchmark_file", benchmark_file)
        pulumi.set(__self__, "benchmarks_volume", benchmarks_volume)
        pulumi.set(__self__, "image", image)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if pod_config is not None:
            pulumi.set(__self__, "pod_config", pod_config)

    @property
    @pulumi.getter(name="benchmarkFile")
    def benchmark_file(self) -> pulumi.Input[str]:
        """
        BenchmarkFile is the entry point file (passed to --benchmark) specified to drill.
        """
        return pulumi.get(self, "benchmark_file")

    @benchmark_file.setter
    def benchmark_file(self, value: pulumi.Input[str]):
        pulumi.set(self, "benchmark_file", value)

    @property
    @pulumi.getter(name="benchmarksVolume")
    def benchmarks_volume(self) -> pulumi.Input[Mapping[str, pulumi.Input[str]]]:
        """
        BenchmarksVolume holds the content of benchmark files. The key of the map specifies the filename and the value is the content of the file. ConfigMap is created from the map which is mounted as benchmarks directory to the benchmark pod.
        """
        return pulumi.get(self, "benchmarks_volume")

    @benchmarks_volume.setter
    def benchmarks_volume(self, value: pulumi.Input[Mapping[str, pulumi.Input[str]]]):
        pulumi.set(self, "benchmarks_volume", value)

    @property
    @pulumi.getter
    def image(self) -> pulumi.Input['DrillSpecImageArgs']:
        """
        Image defines the drill docker image used for the benchmark
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: pulumi.Input['DrillSpecImageArgs']):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter
    def options(self) -> Optional[pulumi.Input[str]]:
        """
        Options are appended to the options parameter set of drill
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "options", value)

    @property
    @pulumi.getter(name="podConfig")
    def pod_config(self) -> Optional[pulumi.Input['DrillSpecPodConfigArgs']]:
        """
        PodConfig contains the configuration for the benchmark pod, including pod labels and scheduling policies (affinity, toleration, node selector...)
        """
        return pulumi.get(self, "pod_config")

    @pod_config.setter
    def pod_config(self, value: Optional[pulumi.Input['DrillSpecPodConfigArgs']]):
        pulumi.set(self, "pod_config", value)


@pulumi.input_type
class DrillSpecImageArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 pull_policy: Optional[pulumi.Input[str]] = None,
                 pull_secret: Optional[pulumi.Input[str]] = None):
        """
        Image defines the drill docker image used for the benchmark
        :param pulumi.Input[str] name: Name is the Docker Image location including the tag
        :param pulumi.Input[str] pull_policy: PullPolicy controls how the docker images are downloaded Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
        :param pulumi.Input[str] pull_secret: PullSecret is an optional list of references to secrets in the same namespace to use for pulling any of the images
        """
        pulumi.set(__self__, "name", name)
        if pull_policy is not None:
            pulumi.set(__self__, "pull_policy", pull_policy)
        if pull_secret is not None:
            pulumi.set(__self__, "pull_secret", pull_secret)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name is the Docker Image location including the tag
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="pullPolicy")
    def pull_policy(self) -> Optional[pulumi.Input[str]]:
        """
        PullPolicy controls how the docker images are downloaded Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
        """
        return pulumi.get(self, "pull_policy")

    @pull_policy.setter
    def pull_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pull_policy", value)

    @property
    @pulumi.getter(name="pullSecret")
    def pull_secret(self) -> Optional[pulumi.Input[str]]:
        """
        PullSecret is an optional list of references to secrets in the same namespace to use for pulling any of the images
        """
        return pulumi.get(self, "pull_secret")

    @pull_secret.setter
    def pull_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pull_secret", value)


@pulumi.input_type
class DrillSpecPodConfigArgs:
    def __init__(__self__, *,
                 pod_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 pod_scheduling: Optional[pulumi.Input['DrillSpecPodConfigPodSchedulingArgs']] = None,
                 resources: Optional[pulumi.Input['DrillSpecPodConfigResourcesArgs']] = None):
        """
        PodConfig contains the configuration for the benchmark pod, including pod labels and scheduling policies (affinity, toleration, node selector...)
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] pod_labels: PodLabels are added to the pod as labels.
        :param pulumi.Input['DrillSpecPodConfigPodSchedulingArgs'] pod_scheduling: PodScheduling contains options to determine which node the pod should be scheduled on
        :param pulumi.Input['DrillSpecPodConfigResourcesArgs'] resources: Resources required by the benchmark pod container More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        if pod_labels is not None:
            pulumi.set(__self__, "pod_labels", pod_labels)
        if pod_scheduling is not None:
            pulumi.set(__self__, "pod_scheduling", pod_scheduling)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter(name="podLabels")
    def pod_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        PodLabels are added to the pod as labels.
        """
        return pulumi.get(self, "pod_labels")

    @pod_labels.setter
    def pod_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "pod_labels", value)

    @property
    @pulumi.getter(name="podScheduling")
    def pod_scheduling(self) -> Optional[pulumi.Input['DrillSpecPodConfigPodSchedulingArgs']]:
        """
        PodScheduling contains options to determine which node the pod should be scheduled on
        """
        return pulumi.get(self, "pod_scheduling")

    @pod_scheduling.setter
    def pod_scheduling(self, value: Optional[pulumi.Input['DrillSpecPodConfigPodSchedulingArgs']]):
        pulumi.set(self, "pod_scheduling", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['DrillSpecPodConfigResourcesArgs']]:
        """
        Resources required by the benchmark pod container More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['DrillSpecPodConfigResourcesArgs']]):
        pulumi.set(self, "resources", value)


@pulumi.input_type
class DrillSpecPodConfigPodSchedulingArgs:
    def __init__(__self__, *,
                 affinity: Optional[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityArgs']] = None,
                 node_name: Optional[pulumi.Input[str]] = None,
                 node_selector: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 tolerations: Optional[pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingTolerationsArgs']]]] = None):
        """
        PodScheduling contains options to determine which node the pod should be scheduled on
        :param pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityArgs'] affinity: Affinity is a group of affinity scheduling rules.
        :param pulumi.Input[str] node_name: NodeName is a request to schedule this pod onto a specific node. If it is non-empty, the scheduler simply schedules this pod onto that node, assuming that it fits resource requirements.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] node_selector: A node selector represents the union of the results of one or more label queries over a set of nodes; that is, it represents the OR of the selectors represented by the node selector terms.
        :param pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingTolerationsArgs']]] tolerations: If specified, the pod's tolerations.
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if node_name is not None:
            pulumi.set(__self__, "node_name", node_name)
        if node_selector is not None:
            pulumi.set(__self__, "node_selector", node_selector)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)

    @property
    @pulumi.getter
    def affinity(self) -> Optional[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityArgs']]:
        """
        Affinity is a group of affinity scheduling rules.
        """
        return pulumi.get(self, "affinity")

    @affinity.setter
    def affinity(self, value: Optional[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityArgs']]):
        pulumi.set(self, "affinity", value)

    @property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> Optional[pulumi.Input[str]]:
        """
        NodeName is a request to schedule this pod onto a specific node. If it is non-empty, the scheduler simply schedules this pod onto that node, assuming that it fits resource requirements.
        """
        return pulumi.get(self, "node_name")

    @node_name.setter
    def node_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_name", value)

    @property
    @pulumi.getter(name="nodeSelector")
    def node_selector(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A node selector represents the union of the results of one or more label queries over a set of nodes; that is, it represents the OR of the selectors represented by the node selector terms.
        """
        return pulumi.get(self, "node_selector")

    @node_selector.setter
    def node_selector(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "node_selector", value)

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingTolerationsArgs']]]]:
        """
        If specified, the pod's tolerations.
        """
        return pulumi.get(self, "tolerations")

    @tolerations.setter
    def tolerations(self, value: Optional[pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingTolerationsArgs']]]]):
        pulumi.set(self, "tolerations", value)


@pulumi.input_type
class DrillSpecPodConfigPodSchedulingAffinityArgs:
    def __init__(__self__, *,
                 node_affinity: Optional[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityNodeAffinityArgs']] = None,
                 pod_affinity: Optional[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAffinityArgs']] = None,
                 pod_anti_affinity: Optional[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityArgs']] = None):
        """
        Affinity is a group of affinity scheduling rules.
        :param pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityNodeAffinityArgs'] node_affinity: Describes node affinity scheduling rules for the pod.
        :param pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAffinityArgs'] pod_affinity: Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
        :param pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityArgs'] pod_anti_affinity: Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
        """
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityNodeAffinityArgs']]:
        """
        Describes node affinity scheduling rules for the pod.
        """
        return pulumi.get(self, "node_affinity")

    @node_affinity.setter
    def node_affinity(self, value: Optional[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityNodeAffinityArgs']]):
        pulumi.set(self, "node_affinity", value)

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAffinityArgs']]:
        """
        Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
        """
        return pulumi.get(self, "pod_affinity")

    @pod_affinity.setter
    def pod_affinity(self, value: Optional[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAffinityArgs']]):
        pulumi.set(self, "pod_affinity", value)

    @property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityArgs']]:
        """
        Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
        """
        return pulumi.get(self, "pod_anti_affinity")

    @pod_anti_affinity.setter
    def pod_anti_affinity(self, value: Optional[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityArgs']]):
        pulumi.set(self, "pod_anti_affinity", value)


@pulumi.input_type
class DrillSpecPodConfigPodSchedulingAffinityNodeAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']] = None):
        """
        Describes node affinity scheduling rules for the pod.
        :param pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]] preferred_during_scheduling_ignored_during_execution: The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
        :param pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs'] required_during_scheduling_ignored_during_execution: If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
        """
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        """
        The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
        """
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]:
        """
        If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
        """
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class DrillSpecPodConfigPodSchedulingAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 preference: pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs'],
                 weight: pulumi.Input[float]):
        """
        An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
        :param pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs'] preference: A node selector term, associated with the corresponding weight.
        :param pulumi.Input[float] weight: Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
        """
        pulumi.set(__self__, "preference", preference)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preference(self) -> pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']:
        """
        A node selector term, associated with the corresponding weight.
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter
    def weight(self) -> pulumi.Input[float]:
        """
        Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: pulumi.Input[float]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class DrillSpecPodConfigPodSchedulingAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]] = None,
                 match_fields: Optional[pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]] = None):
        """
        A node selector term, associated with the corresponding weight.
        :param pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]] match_expressions: A list of node selector requirements by node's labels.
        :param pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]] match_fields: A list of node selector requirements by node's fields.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]]:
        """
        A list of node selector requirements by node's labels.
        """
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]]:
        """
        A list of node selector requirements by node's fields.
        """
        return pulumi.get(self, "match_fields")

    @match_fields.setter
    def match_fields(self, value: Optional[pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]]):
        pulumi.set(self, "match_fields", value)


@pulumi.input_type
class DrillSpecPodConfigPodSchedulingAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 values: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None):
        """
        A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param pulumi.Input[str] key: The label key that the selector applies to.
        :param pulumi.Input[str] operator: Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        :param pulumi.Input[List[pulumi.Input[str]]] values: An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class DrillSpecPodConfigPodSchedulingAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 values: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None):
        """
        A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param pulumi.Input[str] key: The label key that the selector applies to.
        :param pulumi.Input[str] operator: Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        :param pulumi.Input[List[pulumi.Input[str]]] values: An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class DrillSpecPodConfigPodSchedulingAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 node_selector_terms: pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]):
        """
        If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
        :param pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]] node_selector_terms: Required. A list of node selector terms. The terms are ORed.
        """
        pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]:
        """
        Required. A list of node selector terms. The terms are ORed.
        """
        return pulumi.get(self, "node_selector_terms")

    @node_selector_terms.setter
    def node_selector_terms(self, value: pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]):
        pulumi.set(self, "node_selector_terms", value)


@pulumi.input_type
class DrillSpecPodConfigPodSchedulingAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]] = None,
                 match_fields: Optional[pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]] = None):
        """
        A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
        :param pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]] match_expressions: A list of node selector requirements by node's labels.
        :param pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]] match_fields: A list of node selector requirements by node's fields.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]]:
        """
        A list of node selector requirements by node's labels.
        """
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]]:
        """
        A list of node selector requirements by node's fields.
        """
        return pulumi.get(self, "match_fields")

    @match_fields.setter
    def match_fields(self, value: Optional[pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]]):
        pulumi.set(self, "match_fields", value)


@pulumi.input_type
class DrillSpecPodConfigPodSchedulingAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 values: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None):
        """
        A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param pulumi.Input[str] key: The label key that the selector applies to.
        :param pulumi.Input[str] operator: Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        :param pulumi.Input[List[pulumi.Input[str]]] values: An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class DrillSpecPodConfigPodSchedulingAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 values: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None):
        """
        A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param pulumi.Input[str] key: The label key that the selector applies to.
        :param pulumi.Input[str] operator: Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        :param pulumi.Input[List[pulumi.Input[str]]] values: An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class DrillSpecPodConfigPodSchedulingAffinityPodAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None):
        """
        Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
        :param pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]] preferred_during_scheduling_ignored_during_execution: The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
        :param pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]] required_during_scheduling_ignored_during_execution: If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
        """
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        """
        The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
        """
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        """
        If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
        """
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class DrillSpecPodConfigPodSchedulingAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 pod_affinity_term: pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs'],
                 weight: pulumi.Input[float]):
        """
        The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
        :param pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs'] pod_affinity_term: Required. A pod affinity term, associated with the corresponding weight.
        :param pulumi.Input[float] weight: weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
        """
        pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']:
        """
        Required. A pod affinity term, associated with the corresponding weight.
        """
        return pulumi.get(self, "pod_affinity_term")

    @pod_affinity_term.setter
    def pod_affinity_term(self, value: pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']):
        pulumi.set(self, "pod_affinity_term", value)

    @property
    @pulumi.getter
    def weight(self) -> pulumi.Input[float]:
        """
        weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: pulumi.Input[float]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class DrillSpecPodConfigPodSchedulingAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs:
    def __init__(__self__, *,
                 topology_key: pulumi.Input[str],
                 label_selector: Optional[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None):
        """
        Required. A pod affinity term, associated with the corresponding weight.
        :param pulumi.Input[str] topology_key: This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
        :param pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs'] label_selector: A label query over a set of resources, in this case pods.
        :param pulumi.Input[List[pulumi.Input[str]]] namespaces: namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
        """
        pulumi.set(__self__, "topology_key", topology_key)
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> pulumi.Input[str]:
        """
        This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
        """
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "topology_key", value)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]:
        """
        A label query over a set of resources, in this case pods.
        """
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
        """
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)


@pulumi.input_type
class DrillSpecPodConfigPodSchedulingAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        A label query over a set of resources, in this case pods.
        :param pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class DrillSpecPodConfigPodSchedulingAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 values: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param pulumi.Input[str] key: key is the label key that the selector applies to.
        :param pulumi.Input[str] operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param pulumi.Input[List[pulumi.Input[str]]] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class DrillSpecPodConfigPodSchedulingAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 topology_key: pulumi.Input[str],
                 label_selector: Optional[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None):
        """
        Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
        :param pulumi.Input[str] topology_key: This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
        :param pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs'] label_selector: A label query over a set of resources, in this case pods.
        :param pulumi.Input[List[pulumi.Input[str]]] namespaces: namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
        """
        pulumi.set(__self__, "topology_key", topology_key)
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> pulumi.Input[str]:
        """
        This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
        """
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "topology_key", value)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]:
        """
        A label query over a set of resources, in this case pods.
        """
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
        """
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)


@pulumi.input_type
class DrillSpecPodConfigPodSchedulingAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        A label query over a set of resources, in this case pods.
        :param pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class DrillSpecPodConfigPodSchedulingAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 values: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param pulumi.Input[str] key: key is the label key that the selector applies to.
        :param pulumi.Input[str] operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param pulumi.Input[List[pulumi.Input[str]]] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None):
        """
        Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
        :param pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]] preferred_during_scheduling_ignored_during_execution: The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
        :param pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]] required_during_scheduling_ignored_during_execution: If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
        """
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        """
        The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
        """
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        """
        If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
        """
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 pod_affinity_term: pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs'],
                 weight: pulumi.Input[float]):
        """
        The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
        :param pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs'] pod_affinity_term: Required. A pod affinity term, associated with the corresponding weight.
        :param pulumi.Input[float] weight: weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
        """
        pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']:
        """
        Required. A pod affinity term, associated with the corresponding weight.
        """
        return pulumi.get(self, "pod_affinity_term")

    @pod_affinity_term.setter
    def pod_affinity_term(self, value: pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']):
        pulumi.set(self, "pod_affinity_term", value)

    @property
    @pulumi.getter
    def weight(self) -> pulumi.Input[float]:
        """
        weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: pulumi.Input[float]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs:
    def __init__(__self__, *,
                 topology_key: pulumi.Input[str],
                 label_selector: Optional[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None):
        """
        Required. A pod affinity term, associated with the corresponding weight.
        :param pulumi.Input[str] topology_key: This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
        :param pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs'] label_selector: A label query over a set of resources, in this case pods.
        :param pulumi.Input[List[pulumi.Input[str]]] namespaces: namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
        """
        pulumi.set(__self__, "topology_key", topology_key)
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> pulumi.Input[str]:
        """
        This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
        """
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "topology_key", value)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]:
        """
        A label query over a set of resources, in this case pods.
        """
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
        """
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)


@pulumi.input_type
class DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        A label query over a set of resources, in this case pods.
        :param pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 values: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param pulumi.Input[str] key: key is the label key that the selector applies to.
        :param pulumi.Input[str] operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param pulumi.Input[List[pulumi.Input[str]]] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 topology_key: pulumi.Input[str],
                 label_selector: Optional[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None):
        """
        Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
        :param pulumi.Input[str] topology_key: This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
        :param pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs'] label_selector: A label query over a set of resources, in this case pods.
        :param pulumi.Input[List[pulumi.Input[str]]] namespaces: namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
        """
        pulumi.set(__self__, "topology_key", topology_key)
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> pulumi.Input[str]:
        """
        This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
        """
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "topology_key", value)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]:
        """
        A label query over a set of resources, in this case pods.
        """
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
        """
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)


@pulumi.input_type
class DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        A label query over a set of resources, in this case pods.
        :param pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[List[pulumi.Input['DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class DrillSpecPodConfigPodSchedulingAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 values: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param pulumi.Input[str] key: key is the label key that the selector applies to.
        :param pulumi.Input[str] operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param pulumi.Input[List[pulumi.Input[str]]] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class DrillSpecPodConfigPodSchedulingTolerationsArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 toleration_seconds: Optional[pulumi.Input[float]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
        :param pulumi.Input[str] effect: Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
        :param pulumi.Input[str] key: Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
        :param pulumi.Input[str] operator: Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
        :param pulumi.Input[float] toleration_seconds: TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
        :param pulumi.Input[str] value: Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
        """
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if toleration_seconds is not None:
            pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[str]]:
        """
        Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> Optional[pulumi.Input[float]]:
        """
        TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
        """
        return pulumi.get(self, "toleration_seconds")

    @toleration_seconds.setter
    def toleration_seconds(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "toleration_seconds", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class DrillSpecPodConfigResourcesArgs:
    def __init__(__self__, *,
                 limits: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 requests: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        Resources required by the benchmark pod container More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] limits: Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] requests: Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "limits", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "requests", value)


@pulumi.input_type
class DrillStatusArgs:
    def __init__(__self__, *,
                 completed: pulumi.Input[bool],
                 running: pulumi.Input[bool]):
        """
        BenchmarkStatus describes the current state of the benchmark
        :param pulumi.Input[bool] completed: Completed shows the state of completion
        :param pulumi.Input[bool] running: Running shows the state of execution
        """
        pulumi.set(__self__, "completed", completed)
        pulumi.set(__self__, "running", running)

    @property
    @pulumi.getter
    def completed(self) -> pulumi.Input[bool]:
        """
        Completed shows the state of completion
        """
        return pulumi.get(self, "completed")

    @completed.setter
    def completed(self, value: pulumi.Input[bool]):
        pulumi.set(self, "completed", value)

    @property
    @pulumi.getter
    def running(self) -> pulumi.Input[bool]:
        """
        Running shows the state of execution
        """
        return pulumi.get(self, "running")

    @running.setter
    def running(self, value: pulumi.Input[bool]):
        pulumi.set(self, "running", value)


