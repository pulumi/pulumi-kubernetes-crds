// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

import {ObjectMeta} from "../meta/v1";

export namespace redhatcop {
    export namespace v1alpha1 {
        /**
         * GlobalDNSRecordSpec defines the desired state of GlobalDNSRecord
         */
        export interface GlobalDNSRecordSpec {
            /**
             * Enpoints is the list of the cluster endpoitns that need to be considered for this dns record
             */
            endpoints?: pulumi.Input<pulumi.Input<inputs.redhatcop.v1alpha1.GlobalDNSRecordSpecEndpoints>[]>;
            /**
             * GlobalZoneRef represents the global zone that will be used to host this record
             */
            globalZoneRef: pulumi.Input<inputs.redhatcop.v1alpha1.GlobalDNSRecordSpecGlobalZoneRef>;
            /**
             * Probe is the health check used to probe the health of the applications and decide which IPs to return Only HttpAction is supported
             */
            healthCheck?: pulumi.Input<inputs.redhatcop.v1alpha1.GlobalDNSRecordSpecHealthCheck>;
            /**
             * LoadBalancingPolicy describes the policy used to loadbalance the results of the DNS queries.
             */
            loadBalancingPolicy: pulumi.Input<string>;
            /**
             * Name is the fqdn that will be used for this record.
             */
            name: pulumi.Input<string>;
            /**
             * TTL is the TTL for this dns record kubebuilder:default:60
             */
            ttl?: pulumi.Input<number>;
        }

        /**
         * Endpoint represents a traffic ingress point to the cluster. Currently only LoadBalancer service is supported.
         */
        export interface GlobalDNSRecordSpecEndpoints {
            /**
             * CredentialsSecretRef is a reference to a secret containing the credentials to access the cluster a key called "kubeconfig" containing a valid kubeconfig file for connecting to the cluster must exist in this secret.
             */
            clusterCredentialRef: pulumi.Input<inputs.redhatcop.v1alpha1.GlobalDNSRecordSpecEndpointsClusterCredentialRef>;
            /**
             * ClusterName name of the cluster to connect to.
             */
            clusterName: pulumi.Input<string>;
            /**
             * LoadBalancerServiceRef contains a reference to the load balancer service that will receive the traffic, if using a router, put here the service created by the ingress controller.
             */
            loadBalancerServiceRef: pulumi.Input<inputs.redhatcop.v1alpha1.GlobalDNSRecordSpecEndpointsLoadBalancerServiceRef>;
        }

        /**
         * CredentialsSecretRef is a reference to a secret containing the credentials to access the cluster a key called "kubeconfig" containing a valid kubeconfig file for connecting to the cluster must exist in this secret.
         */
        export interface GlobalDNSRecordSpecEndpointsClusterCredentialRef {
            name: pulumi.Input<string>;
            namespace: pulumi.Input<string>;
        }

        /**
         * LoadBalancerServiceRef contains a reference to the load balancer service that will receive the traffic, if using a router, put here the service created by the ingress controller.
         */
        export interface GlobalDNSRecordSpecEndpointsLoadBalancerServiceRef {
            name: pulumi.Input<string>;
            namespace: pulumi.Input<string>;
        }

        /**
         * GlobalZoneRef represents the global zone that will be used to host this record
         */
        export interface GlobalDNSRecordSpecGlobalZoneRef {
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
             */
            name?: pulumi.Input<string>;
        }

        /**
         * Probe is the health check used to probe the health of the applications and decide which IPs to return Only HttpAction is supported
         */
        export interface GlobalDNSRecordSpecHealthCheck {
            /**
             * One and only one of the following should be specified. Exec specifies the action to take.
             */
            exec?: pulumi.Input<inputs.redhatcop.v1alpha1.GlobalDNSRecordSpecHealthCheckExec>;
            /**
             * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
             */
            failureThreshold?: pulumi.Input<number>;
            /**
             * HTTPGet specifies the http request to perform.
             */
            httpGet?: pulumi.Input<inputs.redhatcop.v1alpha1.GlobalDNSRecordSpecHealthCheckHttpGet>;
            /**
             * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
             */
            initialDelaySeconds?: pulumi.Input<number>;
            /**
             * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
             */
            successThreshold?: pulumi.Input<number>;
            /**
             * TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported TODO: implement a realistic TCP lifecycle hook
             */
            tcpSocket?: pulumi.Input<inputs.redhatcop.v1alpha1.GlobalDNSRecordSpecHealthCheckTcpSocket>;
            /**
             * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
             */
            timeoutSeconds?: pulumi.Input<number>;
        }

        /**
         * One and only one of the following should be specified. Exec specifies the action to take.
         */
        export interface GlobalDNSRecordSpecHealthCheckExec {
            /**
             * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
             */
            command?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * HTTPGet specifies the http request to perform.
         */
        export interface GlobalDNSRecordSpecHealthCheckHttpGet {
            /**
             * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
             */
            host?: pulumi.Input<string>;
            /**
             * Custom headers to set in the request. HTTP allows repeated headers.
             */
            httpHeaders?: pulumi.Input<pulumi.Input<inputs.redhatcop.v1alpha1.GlobalDNSRecordSpecHealthCheckHttpGetHttpHeaders>[]>;
            /**
             * Path to access on the HTTP server.
             */
            path?: pulumi.Input<string>;
            /**
             * Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
             */
            port: pulumi.Input<inputs.redhatcop.v1alpha1.GlobalDNSRecordSpecHealthCheckHttpGetPort>;
            /**
             * Scheme to use for connecting to the host. Defaults to HTTP.
             */
            scheme?: pulumi.Input<string>;
        }

        /**
         * HTTPHeader describes a custom header to be used in HTTP probes
         */
        export interface GlobalDNSRecordSpecHealthCheckHttpGetHttpHeaders {
            /**
             * The header field name
             */
            name: pulumi.Input<string>;
            /**
             * The header field value
             */
            value: pulumi.Input<string>;
        }

        export interface GlobalDNSRecordSpecHealthCheckHttpGetPort {
        }

        /**
         * TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported TODO: implement a realistic TCP lifecycle hook
         */
        export interface GlobalDNSRecordSpecHealthCheckTcpSocket {
            /**
             * Optional: Host name to connect to, defaults to the pod IP.
             */
            host?: pulumi.Input<string>;
            /**
             * Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
             */
            port: pulumi.Input<inputs.redhatcop.v1alpha1.GlobalDNSRecordSpecHealthCheckTcpSocketPort>;
        }

        export interface GlobalDNSRecordSpecHealthCheckTcpSocketPort {
        }

        /**
         * GlobalDNSRecordStatus defines the observed state of GlobalDNSRecord
         */
        export interface GlobalDNSRecordStatus {
            /**
             * ReconcileStatus this is the general status of the main reconciler
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.redhatcop.v1alpha1.GlobalDNSRecordStatusConditions>[]>;
            /**
             * EndpointStatuses contains the status of the endpoint as they were looked up during the latest reconcile. We don't fail when an endpoint look up fails, but we need to tarck its status.
             */
            endpointStatuses?: pulumi.Input<{[key: string]: pulumi.Input<pulumi.Input<inputs.redhatcop.v1alpha1.GlobalDNSRecordStatusEndpointStatuses>[]>}>;
            /**
             * MonitoredServiceStatuses contains the reconcile status of each of the monitored services in the remote clusters
             */
            monitoredServiceStatuses?: pulumi.Input<{[key: string]: pulumi.Input<pulumi.Input<inputs.redhatcop.v1alpha1.GlobalDNSRecordStatusMonitoredServiceStatuses>[]>}>;
            /**
             * ProviderStatus contains provider specific status information
             */
            providerStatus?: pulumi.Input<inputs.redhatcop.v1alpha1.GlobalDNSRecordStatusProviderStatus>;
        }

        /**
         * Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
         *  Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
         */
        export interface GlobalDNSRecordStatusConditions {
            lastTransitionTime?: pulumi.Input<string>;
            message?: pulumi.Input<string>;
            /**
             * ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
             */
            reason?: pulumi.Input<string>;
            status: pulumi.Input<string>;
            /**
             * ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
             *  Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
             */
            type: pulumi.Input<string>;
        }

        /**
         * Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
         *  Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
         */
        export interface GlobalDNSRecordStatusEndpointStatuses {
            lastTransitionTime?: pulumi.Input<string>;
            message?: pulumi.Input<string>;
            /**
             * ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
             */
            reason?: pulumi.Input<string>;
            status: pulumi.Input<string>;
            /**
             * ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
             *  Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
             */
            type: pulumi.Input<string>;
        }

        /**
         * Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
         *  Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
         */
        export interface GlobalDNSRecordStatusMonitoredServiceStatuses {
            lastTransitionTime?: pulumi.Input<string>;
            message?: pulumi.Input<string>;
            /**
             * ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
             */
            reason?: pulumi.Input<string>;
            status: pulumi.Input<string>;
            /**
             * ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
             *  Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
             */
            type: pulumi.Input<string>;
        }

        /**
         * ProviderStatus contains provider specific status information
         */
        export interface GlobalDNSRecordStatusProviderStatus {
            route53?: pulumi.Input<inputs.redhatcop.v1alpha1.GlobalDNSRecordStatusProviderStatusRoute53>;
        }

        export interface GlobalDNSRecordStatusProviderStatusRoute53 {
            /**
             * HealthCheckID represents the route53 healthcheck created for this record
             */
            healthCheckID?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * PolicyID represents the route53 routing policy created for this record
             */
            policyID?: pulumi.Input<string>;
            /**
             * PolicyInstanceID represents the ID of the DNSRecord
             */
            policyInstanceID?: pulumi.Input<string>;
        }

        /**
         * GlobalDNSZoneSpec defines the desired state of GlobalDNSZone
         */
        export interface GlobalDNSZoneSpec {
            domain: pulumi.Input<string>;
            /**
             * ProviderConfig configures kind and access to the DNS Zone. Exactly one of its members must be set.
             */
            provider: pulumi.Input<inputs.redhatcop.v1alpha1.GlobalDNSZoneSpecProvider>;
        }

        /**
         * ProviderConfig configures kind and access to the DNS Zone. Exactly one of its members must be set.
         */
        export interface GlobalDNSZoneSpecProvider {
            /**
             * ExternalDNSProviderConfig contains configuration on how configure the external DNS provider
             */
            externalDNS?: pulumi.Input<inputs.redhatcop.v1alpha1.GlobalDNSZoneSpecProviderExternalDNS>;
            /**
             * Route53ProviderConfig contains configuration on how to access the route53 API
             */
            route53?: pulumi.Input<inputs.redhatcop.v1alpha1.GlobalDNSZoneSpecProviderRoute53>;
        }

        /**
         * ExternalDNSProviderConfig contains configuration on how configure the external DNS provider
         */
        export interface GlobalDNSZoneSpecProviderExternalDNS {
            /**
             * Annotations is a map of annotations to be added to the created DNSEndpoint records.
             */
            annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * Route53ProviderConfig contains configuration on how to access the route53 API
         */
        export interface GlobalDNSZoneSpecProviderRoute53 {
            /**
             * CredentialsSecretRef is a reference to a secret containing the credentials to access the AWS API //TODO (content and needed permissions) expected secret keys are "aws_access_key_id" and "aws_secret_access_key"
             */
            credentialsSecretRef: pulumi.Input<inputs.redhatcop.v1alpha1.GlobalDNSZoneSpecProviderRoute53CredentialsSecretRef>;
            /**
             * ZoneID is the AWS route53 zone ID.
             */
            zoneID: pulumi.Input<string>;
        }

        /**
         * CredentialsSecretRef is a reference to a secret containing the credentials to access the AWS API //TODO (content and needed permissions) expected secret keys are "aws_access_key_id" and "aws_secret_access_key"
         */
        export interface GlobalDNSZoneSpecProviderRoute53CredentialsSecretRef {
            name: pulumi.Input<string>;
            namespace: pulumi.Input<string>;
        }

        /**
         * GlobalDNSZoneStatus defines the observed state of GlobalDNSZone
         */
        export interface GlobalDNSZoneStatus {
            /**
             * INSERT ADDITIONAL STATUS FIELD - define observed state of cluster Important: Run "operator-sdk generate k8s" to regenerate code after modifying this file Add custom validation using kubebuilder tags: https://book-v1.book.kubebuilder.io/beyond_basics/generating_crd.html
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.redhatcop.v1alpha1.GlobalDNSZoneStatusConditions>[]>;
        }

        /**
         * Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
         *  Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
         */
        export interface GlobalDNSZoneStatusConditions {
            lastTransitionTime?: pulumi.Input<string>;
            message?: pulumi.Input<string>;
            /**
             * ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
             */
            reason?: pulumi.Input<string>;
            status: pulumi.Input<string>;
            /**
             * ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
             *  Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
             */
            type: pulumi.Input<string>;
        }

        /**
         * GlobalRouteDiscoverySpec defines the desired state of GlobalRouteDiscovery
         */
        export interface GlobalRouteDiscoverySpec {
            /**
             * Cluster is an arrays with the list of clusters in which global routes will be discovered
             */
            clusters?: pulumi.Input<pulumi.Input<inputs.redhatcop.v1alpha1.GlobalRouteDiscoverySpecClusters>[]>;
            /**
             * DefaultLoadBalancingPolicy defines the load balancing policy to be used by default. This can be overridden with a route annotation TODO which? -kubebuilder:default:="Multivalue"
             */
            defaultLoadBalancingPolicy?: pulumi.Input<string>;
            /**
             * Dfeault TTL is the TTL for this dns record -kubebuilder:default:60
             */
            defaultTTL?: pulumi.Input<number>;
            /**
             * GlobalZoneRef represents the global zone that will be used to host this record
             */
            globalZoneRef: pulumi.Input<inputs.redhatcop.v1alpha1.GlobalRouteDiscoverySpecGlobalZoneRef>;
            /**
             * RouteSelector is the selector that selects the global routes, this allows you to define also local routes.
             */
            routeSelector?: pulumi.Input<inputs.redhatcop.v1alpha1.GlobalRouteDiscoverySpecRouteSelector>;
        }

        /**
         * ClusterReference contains the infomation necessary to connect to a cluster
         */
        export interface GlobalRouteDiscoverySpecClusters {
            /**
             * CredentialsSecretRef is a reference to a secret containing the credentials to access the cluster a key called "kubeconfig" containing a valid kubeconfig file for connecting to the cluster must exist in this secret.
             */
            clusterCredentialRef: pulumi.Input<inputs.redhatcop.v1alpha1.GlobalRouteDiscoverySpecClustersClusterCredentialRef>;
            /**
             * ClusterName name of the cluster to connect to.
             */
            clusterName: pulumi.Input<string>;
        }

        /**
         * CredentialsSecretRef is a reference to a secret containing the credentials to access the cluster a key called "kubeconfig" containing a valid kubeconfig file for connecting to the cluster must exist in this secret.
         */
        export interface GlobalRouteDiscoverySpecClustersClusterCredentialRef {
            name: pulumi.Input<string>;
            namespace: pulumi.Input<string>;
        }

        /**
         * GlobalZoneRef represents the global zone that will be used to host this record
         */
        export interface GlobalRouteDiscoverySpecGlobalZoneRef {
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
             */
            name?: pulumi.Input<string>;
        }

        /**
         * RouteSelector is the selector that selects the global routes, this allows you to define also local routes.
         */
        export interface GlobalRouteDiscoverySpecRouteSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.redhatcop.v1alpha1.GlobalRouteDiscoverySpecRouteSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
         */
        export interface GlobalRouteDiscoverySpecRouteSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * GlobalRouteDiscoveryStatus defines the observed state of GlobalRouteDiscovery
         */
        export interface GlobalRouteDiscoveryStatus {
            /**
             * ClusterReferenceStatuses contains the status of the cluster refence connections and their latest reconcile.
             */
            clusterReferenceStatuses?: pulumi.Input<{[key: string]: pulumi.Input<pulumi.Input<inputs.redhatcop.v1alpha1.GlobalRouteDiscoveryStatusClusterReferenceStatuses>[]>}>;
            /**
             * ReconcileStatus this is the general status of the main reconciler
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.redhatcop.v1alpha1.GlobalRouteDiscoveryStatusConditions>[]>;
        }

        /**
         * Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
         *  Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
         */
        export interface GlobalRouteDiscoveryStatusClusterReferenceStatuses {
            lastTransitionTime?: pulumi.Input<string>;
            message?: pulumi.Input<string>;
            /**
             * ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
             */
            reason?: pulumi.Input<string>;
            status: pulumi.Input<string>;
            /**
             * ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
             *  Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
             */
            type: pulumi.Input<string>;
        }

        /**
         * Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
         *  Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
         */
        export interface GlobalRouteDiscoveryStatusConditions {
            lastTransitionTime?: pulumi.Input<string>;
            message?: pulumi.Input<string>;
            /**
             * ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
             */
            reason?: pulumi.Input<string>;
            status: pulumi.Input<string>;
            /**
             * ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
             *  Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
             */
            type: pulumi.Input<string>;
        }
    }
}
