# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from ... import _utilities, _tables
from . import outputs

__all__ = [
    'GlobalDNSRecordSpec',
    'GlobalDNSRecordSpecEndpoints',
    'GlobalDNSRecordSpecEndpointsClusterCredentialRef',
    'GlobalDNSRecordSpecEndpointsLoadBalancerServiceRef',
    'GlobalDNSRecordSpecGlobalZoneRef',
    'GlobalDNSRecordSpecHealthCheck',
    'GlobalDNSRecordSpecHealthCheckExec',
    'GlobalDNSRecordSpecHealthCheckHttpGet',
    'GlobalDNSRecordSpecHealthCheckHttpGetHttpHeaders',
    'GlobalDNSRecordSpecHealthCheckHttpGetPort',
    'GlobalDNSRecordSpecHealthCheckTcpSocket',
    'GlobalDNSRecordSpecHealthCheckTcpSocketPort',
    'GlobalDNSRecordStatus',
    'GlobalDNSRecordStatusConditions',
    'GlobalDNSRecordStatusEndpointStatuses',
    'GlobalDNSRecordStatusMonitoredServiceStatuses',
    'GlobalDNSRecordStatusProviderStatus',
    'GlobalDNSRecordStatusProviderStatusRoute53',
    'GlobalDNSZoneSpec',
    'GlobalDNSZoneSpecProvider',
    'GlobalDNSZoneSpecProviderExternalDNS',
    'GlobalDNSZoneSpecProviderRoute53',
    'GlobalDNSZoneSpecProviderRoute53CredentialsSecretRef',
    'GlobalDNSZoneStatus',
    'GlobalDNSZoneStatusConditions',
    'GlobalRouteDiscoverySpec',
    'GlobalRouteDiscoverySpecClusters',
    'GlobalRouteDiscoverySpecClustersClusterCredentialRef',
    'GlobalRouteDiscoverySpecGlobalZoneRef',
    'GlobalRouteDiscoverySpecRouteSelector',
    'GlobalRouteDiscoverySpecRouteSelectorMatchExpressions',
    'GlobalRouteDiscoveryStatus',
    'GlobalRouteDiscoveryStatusClusterReferenceStatuses',
    'GlobalRouteDiscoveryStatusConditions',
]

@pulumi.output_type
class GlobalDNSRecordSpec(dict):
    """
    GlobalDNSRecordSpec defines the desired state of GlobalDNSRecord
    """
    def __init__(__self__, *,
                 global_zone_ref: 'outputs.GlobalDNSRecordSpecGlobalZoneRef',
                 load_balancing_policy: str,
                 name: str,
                 endpoints: Optional[Sequence['outputs.GlobalDNSRecordSpecEndpoints']] = None,
                 health_check: Optional['outputs.GlobalDNSRecordSpecHealthCheck'] = None,
                 ttl: Optional[int] = None):
        """
        GlobalDNSRecordSpec defines the desired state of GlobalDNSRecord
        :param 'GlobalDNSRecordSpecGlobalZoneRefArgs' global_zone_ref: GlobalZoneRef represents the global zone that will be used to host this record
        :param str load_balancing_policy: LoadBalancingPolicy describes the policy used to loadbalance the results of the DNS queries.
        :param str name: Name is the fqdn that will be used for this record.
        :param Sequence['GlobalDNSRecordSpecEndpointsArgs'] endpoints: Enpoints is the list of the cluster endpoitns that need to be considered for this dns record
        :param 'GlobalDNSRecordSpecHealthCheckArgs' health_check: Probe is the health check used to probe the health of the applications and decide which IPs to return Only HttpAction is supported
        :param int ttl: TTL is the TTL for this dns record kubebuilder:default:60
        """
        pulumi.set(__self__, "global_zone_ref", global_zone_ref)
        pulumi.set(__self__, "load_balancing_policy", load_balancing_policy)
        pulumi.set(__self__, "name", name)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter(name="globalZoneRef")
    def global_zone_ref(self) -> 'outputs.GlobalDNSRecordSpecGlobalZoneRef':
        """
        GlobalZoneRef represents the global zone that will be used to host this record
        """
        return pulumi.get(self, "global_zone_ref")

    @property
    @pulumi.getter(name="loadBalancingPolicy")
    def load_balancing_policy(self) -> str:
        """
        LoadBalancingPolicy describes the policy used to loadbalance the results of the DNS queries.
        """
        return pulumi.get(self, "load_balancing_policy")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name is the fqdn that will be used for this record.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[Sequence['outputs.GlobalDNSRecordSpecEndpoints']]:
        """
        Enpoints is the list of the cluster endpoitns that need to be considered for this dns record
        """
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional['outputs.GlobalDNSRecordSpecHealthCheck']:
        """
        Probe is the health check used to probe the health of the applications and decide which IPs to return Only HttpAction is supported
        """
        return pulumi.get(self, "health_check")

    @property
    @pulumi.getter
    def ttl(self) -> Optional[int]:
        """
        TTL is the TTL for this dns record kubebuilder:default:60
        """
        return pulumi.get(self, "ttl")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GlobalDNSRecordSpecEndpoints(dict):
    """
    Endpoint represents a traffic ingress point to the cluster. Currently only LoadBalancer service is supported.
    """
    def __init__(__self__, *,
                 cluster_credential_ref: 'outputs.GlobalDNSRecordSpecEndpointsClusterCredentialRef',
                 cluster_name: str,
                 load_balancer_service_ref: 'outputs.GlobalDNSRecordSpecEndpointsLoadBalancerServiceRef'):
        """
        Endpoint represents a traffic ingress point to the cluster. Currently only LoadBalancer service is supported.
        :param 'GlobalDNSRecordSpecEndpointsClusterCredentialRefArgs' cluster_credential_ref: CredentialsSecretRef is a reference to a secret containing the credentials to access the cluster a key called "kubeconfig" containing a valid kubeconfig file for connecting to the cluster must exist in this secret.
        :param str cluster_name: ClusterName name of the cluster to connect to.
        :param 'GlobalDNSRecordSpecEndpointsLoadBalancerServiceRefArgs' load_balancer_service_ref: LoadBalancerServiceRef contains a reference to the load balancer service that will receive the traffic, if using a router, put here the service created by the ingress controller.
        """
        pulumi.set(__self__, "cluster_credential_ref", cluster_credential_ref)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "load_balancer_service_ref", load_balancer_service_ref)

    @property
    @pulumi.getter(name="clusterCredentialRef")
    def cluster_credential_ref(self) -> 'outputs.GlobalDNSRecordSpecEndpointsClusterCredentialRef':
        """
        CredentialsSecretRef is a reference to a secret containing the credentials to access the cluster a key called "kubeconfig" containing a valid kubeconfig file for connecting to the cluster must exist in this secret.
        """
        return pulumi.get(self, "cluster_credential_ref")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        """
        ClusterName name of the cluster to connect to.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="loadBalancerServiceRef")
    def load_balancer_service_ref(self) -> 'outputs.GlobalDNSRecordSpecEndpointsLoadBalancerServiceRef':
        """
        LoadBalancerServiceRef contains a reference to the load balancer service that will receive the traffic, if using a router, put here the service created by the ingress controller.
        """
        return pulumi.get(self, "load_balancer_service_ref")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GlobalDNSRecordSpecEndpointsClusterCredentialRef(dict):
    """
    CredentialsSecretRef is a reference to a secret containing the credentials to access the cluster a key called "kubeconfig" containing a valid kubeconfig file for connecting to the cluster must exist in this secret.
    """
    def __init__(__self__, *,
                 name: str,
                 namespace: str):
        """
        CredentialsSecretRef is a reference to a secret containing the credentials to access the cluster a key called "kubeconfig" containing a valid kubeconfig file for connecting to the cluster must exist in this secret.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        return pulumi.get(self, "namespace")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GlobalDNSRecordSpecEndpointsLoadBalancerServiceRef(dict):
    """
    LoadBalancerServiceRef contains a reference to the load balancer service that will receive the traffic, if using a router, put here the service created by the ingress controller.
    """
    def __init__(__self__, *,
                 name: str,
                 namespace: str):
        """
        LoadBalancerServiceRef contains a reference to the load balancer service that will receive the traffic, if using a router, put here the service created by the ingress controller.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        return pulumi.get(self, "namespace")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GlobalDNSRecordSpecGlobalZoneRef(dict):
    """
    GlobalZoneRef represents the global zone that will be used to host this record
    """
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        GlobalZoneRef represents the global zone that will be used to host this record
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GlobalDNSRecordSpecHealthCheck(dict):
    """
    Probe is the health check used to probe the health of the applications and decide which IPs to return Only HttpAction is supported
    """
    def __init__(__self__, *,
                 exec_: Optional['outputs.GlobalDNSRecordSpecHealthCheckExec'] = None,
                 failure_threshold: Optional[int] = None,
                 http_get: Optional['outputs.GlobalDNSRecordSpecHealthCheckHttpGet'] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 tcp_socket: Optional['outputs.GlobalDNSRecordSpecHealthCheckTcpSocket'] = None,
                 timeout_seconds: Optional[int] = None):
        """
        Probe is the health check used to probe the health of the applications and decide which IPs to return Only HttpAction is supported
        :param 'GlobalDNSRecordSpecHealthCheckExecArgs' exec_: One and only one of the following should be specified. Exec specifies the action to take.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param 'GlobalDNSRecordSpecHealthCheckHttpGetArgs' http_get: HTTPGet specifies the http request to perform.
        :param int initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        :param int period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
        :param 'GlobalDNSRecordSpecHealthCheckTcpSocketArgs' tcp_socket: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported TODO: implement a realistic TCP lifecycle hook
        :param int timeout_seconds: Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if tcp_socket is not None:
            pulumi.set(__self__, "tcp_socket", tcp_socket)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.GlobalDNSRecordSpecHealthCheckExec']:
        """
        One and only one of the following should be specified. Exec specifies the action to take.
        """
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.GlobalDNSRecordSpecHealthCheckHttpGet']:
        """
        HTTPGet specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="tcpSocket")
    def tcp_socket(self) -> Optional['outputs.GlobalDNSRecordSpecHealthCheckTcpSocket']:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported TODO: implement a realistic TCP lifecycle hook
        """
        return pulumi.get(self, "tcp_socket")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        """
        return pulumi.get(self, "timeout_seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GlobalDNSRecordSpecHealthCheckExec(dict):
    """
    One and only one of the following should be specified. Exec specifies the action to take.
    """
    def __init__(__self__, *,
                 command: Optional[Sequence[str]] = None):
        """
        One and only one of the following should be specified. Exec specifies the action to take.
        :param Sequence[str] command: Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        if command is not None:
            pulumi.set(__self__, "command", command)

    @property
    @pulumi.getter
    def command(self) -> Optional[Sequence[str]]:
        """
        Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "command")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GlobalDNSRecordSpecHealthCheckHttpGet(dict):
    """
    HTTPGet specifies the http request to perform.
    """
    def __init__(__self__, *,
                 port: 'outputs.GlobalDNSRecordSpecHealthCheckHttpGetPort',
                 host: Optional[str] = None,
                 http_headers: Optional[Sequence['outputs.GlobalDNSRecordSpecHealthCheckHttpGetHttpHeaders']] = None,
                 path: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        HTTPGet specifies the http request to perform.
        :param 'GlobalDNSRecordSpecHealthCheckHttpGetPortArgs' port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        :param str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['GlobalDNSRecordSpecHealthCheckHttpGetHttpHeadersArgs'] http_headers: Custom headers to set in the request. HTTP allows repeated headers.
        :param str path: Path to access on the HTTP server.
        :param str scheme: Scheme to use for connecting to the host. Defaults to HTTP.
        """
        pulumi.set(__self__, "port", port)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def port(self) -> 'outputs.GlobalDNSRecordSpecHealthCheckHttpGetPort':
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.GlobalDNSRecordSpecHealthCheckHttpGetHttpHeaders']]:
        """
        Custom headers to set in the request. HTTP allows repeated headers.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host. Defaults to HTTP.
        """
        return pulumi.get(self, "scheme")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GlobalDNSRecordSpecHealthCheckHttpGetHttpHeaders(dict):
    """
    HTTPHeader describes a custom header to be used in HTTP probes
    """
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        HTTPHeader describes a custom header to be used in HTTP probes
        :param str name: The header field name
        :param str value: The header field value
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The header field value
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GlobalDNSRecordSpecHealthCheckHttpGetPort(dict):
    def __init__(__self__):
        pass

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GlobalDNSRecordSpecHealthCheckTcpSocket(dict):
    """
    TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported TODO: implement a realistic TCP lifecycle hook
    """
    def __init__(__self__, *,
                 port: 'outputs.GlobalDNSRecordSpecHealthCheckTcpSocketPort',
                 host: Optional[str] = None):
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported TODO: implement a realistic TCP lifecycle hook
        :param 'GlobalDNSRecordSpecHealthCheckTcpSocketPortArgs' port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        :param str host: Optional: Host name to connect to, defaults to the pod IP.
        """
        pulumi.set(__self__, "port", port)
        if host is not None:
            pulumi.set(__self__, "host", host)

    @property
    @pulumi.getter
    def port(self) -> 'outputs.GlobalDNSRecordSpecHealthCheckTcpSocketPort':
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Optional: Host name to connect to, defaults to the pod IP.
        """
        return pulumi.get(self, "host")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GlobalDNSRecordSpecHealthCheckTcpSocketPort(dict):
    def __init__(__self__):
        pass

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GlobalDNSRecordStatus(dict):
    """
    GlobalDNSRecordStatus defines the observed state of GlobalDNSRecord
    """
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.GlobalDNSRecordStatusConditions']] = None,
                 endpoint_statuses: Optional[Mapping[str, Sequence['outputs.GlobalDNSRecordStatusEndpointStatuses']]] = None,
                 monitored_service_statuses: Optional[Mapping[str, Sequence['outputs.GlobalDNSRecordStatusMonitoredServiceStatuses']]] = None,
                 provider_status: Optional['outputs.GlobalDNSRecordStatusProviderStatus'] = None):
        """
        GlobalDNSRecordStatus defines the observed state of GlobalDNSRecord
        :param Sequence['GlobalDNSRecordStatusConditionsArgs'] conditions: ReconcileStatus this is the general status of the main reconciler
        :param Mapping[str, Sequence['GlobalDNSRecordStatusEndpointStatusesArgs']] endpoint_statuses: EndpointStatuses contains the status of the endpoint as they were looked up during the latest reconcile. We don't fail when an endpoint look up fails, but we need to tarck its status.
        :param Mapping[str, Sequence['GlobalDNSRecordStatusMonitoredServiceStatusesArgs']] monitored_service_statuses: MonitoredServiceStatuses contains the reconcile status of each of the monitored services in the remote clusters
        :param 'GlobalDNSRecordStatusProviderStatusArgs' provider_status: ProviderStatus contains provider specific status information
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if endpoint_statuses is not None:
            pulumi.set(__self__, "endpoint_statuses", endpoint_statuses)
        if monitored_service_statuses is not None:
            pulumi.set(__self__, "monitored_service_statuses", monitored_service_statuses)
        if provider_status is not None:
            pulumi.set(__self__, "provider_status", provider_status)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.GlobalDNSRecordStatusConditions']]:
        """
        ReconcileStatus this is the general status of the main reconciler
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="endpointStatuses")
    def endpoint_statuses(self) -> Optional[Mapping[str, Sequence['outputs.GlobalDNSRecordStatusEndpointStatuses']]]:
        """
        EndpointStatuses contains the status of the endpoint as they were looked up during the latest reconcile. We don't fail when an endpoint look up fails, but we need to tarck its status.
        """
        return pulumi.get(self, "endpoint_statuses")

    @property
    @pulumi.getter(name="monitoredServiceStatuses")
    def monitored_service_statuses(self) -> Optional[Mapping[str, Sequence['outputs.GlobalDNSRecordStatusMonitoredServiceStatuses']]]:
        """
        MonitoredServiceStatuses contains the reconcile status of each of the monitored services in the remote clusters
        """
        return pulumi.get(self, "monitored_service_statuses")

    @property
    @pulumi.getter(name="providerStatus")
    def provider_status(self) -> Optional['outputs.GlobalDNSRecordStatusProviderStatus']:
        """
        ProviderStatus contains provider specific status information
        """
        return pulumi.get(self, "provider_status")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GlobalDNSRecordStatusConditions(dict):
    """
    Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
     Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
    """
    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None):
        """
        Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
         Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
        :param str type: ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
                Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        :param str reason: ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
         Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        return pulumi.get(self, "reason")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GlobalDNSRecordStatusEndpointStatuses(dict):
    """
    Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
     Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
    """
    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None):
        """
        Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
         Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
        :param str type: ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
                Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        :param str reason: ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
         Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        return pulumi.get(self, "reason")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GlobalDNSRecordStatusMonitoredServiceStatuses(dict):
    """
    Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
     Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
    """
    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None):
        """
        Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
         Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
        :param str type: ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
                Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        :param str reason: ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
         Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        return pulumi.get(self, "reason")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GlobalDNSRecordStatusProviderStatus(dict):
    """
    ProviderStatus contains provider specific status information
    """
    def __init__(__self__, *,
                 route53: Optional['outputs.GlobalDNSRecordStatusProviderStatusRoute53'] = None):
        """
        ProviderStatus contains provider specific status information
        """
        if route53 is not None:
            pulumi.set(__self__, "route53", route53)

    @property
    @pulumi.getter
    def route53(self) -> Optional['outputs.GlobalDNSRecordStatusProviderStatusRoute53']:
        return pulumi.get(self, "route53")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GlobalDNSRecordStatusProviderStatusRoute53(dict):
    def __init__(__self__, *,
                 health_check_id: Optional[Mapping[str, str]] = None,
                 policy_id: Optional[str] = None,
                 policy_instance_id: Optional[str] = None):
        """
        :param Mapping[str, str] health_check_id: HealthCheckID represents the route53 healthcheck created for this record
        :param str policy_id: PolicyID represents the route53 routing policy created for this record
        :param str policy_instance_id: PolicyInstanceID represents the ID of the DNSRecord
        """
        if health_check_id is not None:
            pulumi.set(__self__, "health_check_id", health_check_id)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)
        if policy_instance_id is not None:
            pulumi.set(__self__, "policy_instance_id", policy_instance_id)

    @property
    @pulumi.getter(name="healthCheckID")
    def health_check_id(self) -> Optional[Mapping[str, str]]:
        """
        HealthCheckID represents the route53 healthcheck created for this record
        """
        return pulumi.get(self, "health_check_id")

    @property
    @pulumi.getter(name="policyID")
    def policy_id(self) -> Optional[str]:
        """
        PolicyID represents the route53 routing policy created for this record
        """
        return pulumi.get(self, "policy_id")

    @property
    @pulumi.getter(name="policyInstanceID")
    def policy_instance_id(self) -> Optional[str]:
        """
        PolicyInstanceID represents the ID of the DNSRecord
        """
        return pulumi.get(self, "policy_instance_id")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GlobalDNSZoneSpec(dict):
    """
    GlobalDNSZoneSpec defines the desired state of GlobalDNSZone
    """
    def __init__(__self__, *,
                 domain: str,
                 provider: 'outputs.GlobalDNSZoneSpecProvider'):
        """
        GlobalDNSZoneSpec defines the desired state of GlobalDNSZone
        :param 'GlobalDNSZoneSpecProviderArgs' provider: ProviderConfig configures kind and access to the DNS Zone. Exactly one of its members must be set.
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "provider", provider)

    @property
    @pulumi.getter
    def domain(self) -> str:
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def provider(self) -> 'outputs.GlobalDNSZoneSpecProvider':
        """
        ProviderConfig configures kind and access to the DNS Zone. Exactly one of its members must be set.
        """
        return pulumi.get(self, "provider")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GlobalDNSZoneSpecProvider(dict):
    """
    ProviderConfig configures kind and access to the DNS Zone. Exactly one of its members must be set.
    """
    def __init__(__self__, *,
                 external_dns: Optional['outputs.GlobalDNSZoneSpecProviderExternalDNS'] = None,
                 route53: Optional['outputs.GlobalDNSZoneSpecProviderRoute53'] = None):
        """
        ProviderConfig configures kind and access to the DNS Zone. Exactly one of its members must be set.
        :param 'GlobalDNSZoneSpecProviderExternalDNSArgs' external_dns: ExternalDNSProviderConfig contains configuration on how configure the external DNS provider
        :param 'GlobalDNSZoneSpecProviderRoute53Args' route53: Route53ProviderConfig contains configuration on how to access the route53 API
        """
        if external_dns is not None:
            pulumi.set(__self__, "external_dns", external_dns)
        if route53 is not None:
            pulumi.set(__self__, "route53", route53)

    @property
    @pulumi.getter(name="externalDNS")
    def external_dns(self) -> Optional['outputs.GlobalDNSZoneSpecProviderExternalDNS']:
        """
        ExternalDNSProviderConfig contains configuration on how configure the external DNS provider
        """
        return pulumi.get(self, "external_dns")

    @property
    @pulumi.getter
    def route53(self) -> Optional['outputs.GlobalDNSZoneSpecProviderRoute53']:
        """
        Route53ProviderConfig contains configuration on how to access the route53 API
        """
        return pulumi.get(self, "route53")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GlobalDNSZoneSpecProviderExternalDNS(dict):
    """
    ExternalDNSProviderConfig contains configuration on how configure the external DNS provider
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, str]] = None):
        """
        ExternalDNSProviderConfig contains configuration on how configure the external DNS provider
        :param Mapping[str, str] annotations: Annotations is a map of annotations to be added to the created DNSEndpoint records.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, str]]:
        """
        Annotations is a map of annotations to be added to the created DNSEndpoint records.
        """
        return pulumi.get(self, "annotations")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GlobalDNSZoneSpecProviderRoute53(dict):
    """
    Route53ProviderConfig contains configuration on how to access the route53 API
    """
    def __init__(__self__, *,
                 credentials_secret_ref: 'outputs.GlobalDNSZoneSpecProviderRoute53CredentialsSecretRef',
                 zone_id: str):
        """
        Route53ProviderConfig contains configuration on how to access the route53 API
        :param 'GlobalDNSZoneSpecProviderRoute53CredentialsSecretRefArgs' credentials_secret_ref: CredentialsSecretRef is a reference to a secret containing the credentials to access the AWS API //TODO (content and needed permissions) expected secret keys are "aws_access_key_id" and "aws_secret_access_key"
        :param str zone_id: ZoneID is the AWS route53 zone ID.
        """
        pulumi.set(__self__, "credentials_secret_ref", credentials_secret_ref)
        pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter(name="credentialsSecretRef")
    def credentials_secret_ref(self) -> 'outputs.GlobalDNSZoneSpecProviderRoute53CredentialsSecretRef':
        """
        CredentialsSecretRef is a reference to a secret containing the credentials to access the AWS API //TODO (content and needed permissions) expected secret keys are "aws_access_key_id" and "aws_secret_access_key"
        """
        return pulumi.get(self, "credentials_secret_ref")

    @property
    @pulumi.getter(name="zoneID")
    def zone_id(self) -> str:
        """
        ZoneID is the AWS route53 zone ID.
        """
        return pulumi.get(self, "zone_id")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GlobalDNSZoneSpecProviderRoute53CredentialsSecretRef(dict):
    """
    CredentialsSecretRef is a reference to a secret containing the credentials to access the AWS API //TODO (content and needed permissions) expected secret keys are "aws_access_key_id" and "aws_secret_access_key"
    """
    def __init__(__self__, *,
                 name: str,
                 namespace: str):
        """
        CredentialsSecretRef is a reference to a secret containing the credentials to access the AWS API //TODO (content and needed permissions) expected secret keys are "aws_access_key_id" and "aws_secret_access_key"
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        return pulumi.get(self, "namespace")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GlobalDNSZoneStatus(dict):
    """
    GlobalDNSZoneStatus defines the observed state of GlobalDNSZone
    """
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.GlobalDNSZoneStatusConditions']] = None):
        """
        GlobalDNSZoneStatus defines the observed state of GlobalDNSZone
        :param Sequence['GlobalDNSZoneStatusConditionsArgs'] conditions: INSERT ADDITIONAL STATUS FIELD - define observed state of cluster Important: Run "operator-sdk generate k8s" to regenerate code after modifying this file Add custom validation using kubebuilder tags: https://book-v1.book.kubebuilder.io/beyond_basics/generating_crd.html
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.GlobalDNSZoneStatusConditions']]:
        """
        INSERT ADDITIONAL STATUS FIELD - define observed state of cluster Important: Run "operator-sdk generate k8s" to regenerate code after modifying this file Add custom validation using kubebuilder tags: https://book-v1.book.kubebuilder.io/beyond_basics/generating_crd.html
        """
        return pulumi.get(self, "conditions")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GlobalDNSZoneStatusConditions(dict):
    """
    Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
     Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
    """
    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None):
        """
        Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
         Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
        :param str type: ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
                Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        :param str reason: ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
         Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        return pulumi.get(self, "reason")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GlobalRouteDiscoverySpec(dict):
    """
    GlobalRouteDiscoverySpec defines the desired state of GlobalRouteDiscovery
    """
    def __init__(__self__, *,
                 global_zone_ref: 'outputs.GlobalRouteDiscoverySpecGlobalZoneRef',
                 clusters: Optional[Sequence['outputs.GlobalRouteDiscoverySpecClusters']] = None,
                 default_load_balancing_policy: Optional[str] = None,
                 default_ttl: Optional[int] = None,
                 route_selector: Optional['outputs.GlobalRouteDiscoverySpecRouteSelector'] = None):
        """
        GlobalRouteDiscoverySpec defines the desired state of GlobalRouteDiscovery
        :param 'GlobalRouteDiscoverySpecGlobalZoneRefArgs' global_zone_ref: GlobalZoneRef represents the global zone that will be used to host this record
        :param Sequence['GlobalRouteDiscoverySpecClustersArgs'] clusters: Cluster is an arrays with the list of clusters in which global routes will be discovered
        :param str default_load_balancing_policy: DefaultLoadBalancingPolicy defines the load balancing policy to be used by default. This can be overridden with a route annotation TODO which? -kubebuilder:default:="Multivalue"
        :param int default_ttl: Dfeault TTL is the TTL for this dns record -kubebuilder:default:60
        :param 'GlobalRouteDiscoverySpecRouteSelectorArgs' route_selector: RouteSelector is the selector that selects the global routes, this allows you to define also local routes.
        """
        pulumi.set(__self__, "global_zone_ref", global_zone_ref)
        if clusters is not None:
            pulumi.set(__self__, "clusters", clusters)
        if default_load_balancing_policy is not None:
            pulumi.set(__self__, "default_load_balancing_policy", default_load_balancing_policy)
        if default_ttl is not None:
            pulumi.set(__self__, "default_ttl", default_ttl)
        if route_selector is not None:
            pulumi.set(__self__, "route_selector", route_selector)

    @property
    @pulumi.getter(name="globalZoneRef")
    def global_zone_ref(self) -> 'outputs.GlobalRouteDiscoverySpecGlobalZoneRef':
        """
        GlobalZoneRef represents the global zone that will be used to host this record
        """
        return pulumi.get(self, "global_zone_ref")

    @property
    @pulumi.getter
    def clusters(self) -> Optional[Sequence['outputs.GlobalRouteDiscoverySpecClusters']]:
        """
        Cluster is an arrays with the list of clusters in which global routes will be discovered
        """
        return pulumi.get(self, "clusters")

    @property
    @pulumi.getter(name="defaultLoadBalancingPolicy")
    def default_load_balancing_policy(self) -> Optional[str]:
        """
        DefaultLoadBalancingPolicy defines the load balancing policy to be used by default. This can be overridden with a route annotation TODO which? -kubebuilder:default:="Multivalue"
        """
        return pulumi.get(self, "default_load_balancing_policy")

    @property
    @pulumi.getter(name="defaultTTL")
    def default_ttl(self) -> Optional[int]:
        """
        Dfeault TTL is the TTL for this dns record -kubebuilder:default:60
        """
        return pulumi.get(self, "default_ttl")

    @property
    @pulumi.getter(name="routeSelector")
    def route_selector(self) -> Optional['outputs.GlobalRouteDiscoverySpecRouteSelector']:
        """
        RouteSelector is the selector that selects the global routes, this allows you to define also local routes.
        """
        return pulumi.get(self, "route_selector")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GlobalRouteDiscoverySpecClusters(dict):
    """
    ClusterReference contains the infomation necessary to connect to a cluster
    """
    def __init__(__self__, *,
                 cluster_credential_ref: 'outputs.GlobalRouteDiscoverySpecClustersClusterCredentialRef',
                 cluster_name: str):
        """
        ClusterReference contains the infomation necessary to connect to a cluster
        :param 'GlobalRouteDiscoverySpecClustersClusterCredentialRefArgs' cluster_credential_ref: CredentialsSecretRef is a reference to a secret containing the credentials to access the cluster a key called "kubeconfig" containing a valid kubeconfig file for connecting to the cluster must exist in this secret.
        :param str cluster_name: ClusterName name of the cluster to connect to.
        """
        pulumi.set(__self__, "cluster_credential_ref", cluster_credential_ref)
        pulumi.set(__self__, "cluster_name", cluster_name)

    @property
    @pulumi.getter(name="clusterCredentialRef")
    def cluster_credential_ref(self) -> 'outputs.GlobalRouteDiscoverySpecClustersClusterCredentialRef':
        """
        CredentialsSecretRef is a reference to a secret containing the credentials to access the cluster a key called "kubeconfig" containing a valid kubeconfig file for connecting to the cluster must exist in this secret.
        """
        return pulumi.get(self, "cluster_credential_ref")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        """
        ClusterName name of the cluster to connect to.
        """
        return pulumi.get(self, "cluster_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GlobalRouteDiscoverySpecClustersClusterCredentialRef(dict):
    """
    CredentialsSecretRef is a reference to a secret containing the credentials to access the cluster a key called "kubeconfig" containing a valid kubeconfig file for connecting to the cluster must exist in this secret.
    """
    def __init__(__self__, *,
                 name: str,
                 namespace: str):
        """
        CredentialsSecretRef is a reference to a secret containing the credentials to access the cluster a key called "kubeconfig" containing a valid kubeconfig file for connecting to the cluster must exist in this secret.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        return pulumi.get(self, "namespace")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GlobalRouteDiscoverySpecGlobalZoneRef(dict):
    """
    GlobalZoneRef represents the global zone that will be used to host this record
    """
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        GlobalZoneRef represents the global zone that will be used to host this record
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GlobalRouteDiscoverySpecRouteSelector(dict):
    """
    RouteSelector is the selector that selects the global routes, this allows you to define also local routes.
    """
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.GlobalRouteDiscoverySpecRouteSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        RouteSelector is the selector that selects the global routes, this allows you to define also local routes.
        :param Sequence['GlobalRouteDiscoverySpecRouteSelectorMatchExpressionsArgs'] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.GlobalRouteDiscoverySpecRouteSelectorMatchExpressions']]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GlobalRouteDiscoverySpecRouteSelectorMatchExpressions(dict):
    """
    A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
    """
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Optional[Sequence[str]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param str key: key is the label key that the selector applies to.
        :param str operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param Sequence[str] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GlobalRouteDiscoveryStatus(dict):
    """
    GlobalRouteDiscoveryStatus defines the observed state of GlobalRouteDiscovery
    """
    def __init__(__self__, *,
                 cluster_reference_statuses: Optional[Mapping[str, Sequence['outputs.GlobalRouteDiscoveryStatusClusterReferenceStatuses']]] = None,
                 conditions: Optional[Sequence['outputs.GlobalRouteDiscoveryStatusConditions']] = None):
        """
        GlobalRouteDiscoveryStatus defines the observed state of GlobalRouteDiscovery
        :param Mapping[str, Sequence['GlobalRouteDiscoveryStatusClusterReferenceStatusesArgs']] cluster_reference_statuses: ClusterReferenceStatuses contains the status of the cluster refence connections and their latest reconcile.
        :param Sequence['GlobalRouteDiscoveryStatusConditionsArgs'] conditions: ReconcileStatus this is the general status of the main reconciler
        """
        if cluster_reference_statuses is not None:
            pulumi.set(__self__, "cluster_reference_statuses", cluster_reference_statuses)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter(name="clusterReferenceStatuses")
    def cluster_reference_statuses(self) -> Optional[Mapping[str, Sequence['outputs.GlobalRouteDiscoveryStatusClusterReferenceStatuses']]]:
        """
        ClusterReferenceStatuses contains the status of the cluster refence connections and their latest reconcile.
        """
        return pulumi.get(self, "cluster_reference_statuses")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.GlobalRouteDiscoveryStatusConditions']]:
        """
        ReconcileStatus this is the general status of the main reconciler
        """
        return pulumi.get(self, "conditions")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GlobalRouteDiscoveryStatusClusterReferenceStatuses(dict):
    """
    Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
     Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
    """
    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None):
        """
        Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
         Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
        :param str type: ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
                Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        :param str reason: ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
         Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        return pulumi.get(self, "reason")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GlobalRouteDiscoveryStatusConditions(dict):
    """
    Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
     Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
    """
    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None):
        """
        Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
         Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
        :param str type: ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
                Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        :param str reason: ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
         Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        return pulumi.get(self, "reason")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


