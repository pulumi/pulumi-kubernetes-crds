# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from ... import _utilities, _tables

__all__ = [
    'GlobalDNSRecordSpecArgs',
    'GlobalDNSRecordSpecEndpointsArgs',
    'GlobalDNSRecordSpecEndpointsClusterCredentialRefArgs',
    'GlobalDNSRecordSpecEndpointsLoadBalancerServiceRefArgs',
    'GlobalDNSRecordSpecGlobalZoneRefArgs',
    'GlobalDNSRecordSpecHealthCheckArgs',
    'GlobalDNSRecordSpecHealthCheckExecArgs',
    'GlobalDNSRecordSpecHealthCheckHttpGetArgs',
    'GlobalDNSRecordSpecHealthCheckHttpGetHttpHeadersArgs',
    'GlobalDNSRecordSpecHealthCheckHttpGetPortArgs',
    'GlobalDNSRecordSpecHealthCheckTcpSocketArgs',
    'GlobalDNSRecordSpecHealthCheckTcpSocketPortArgs',
    'GlobalDNSRecordStatusArgs',
    'GlobalDNSRecordStatusConditionsArgs',
    'GlobalDNSRecordStatusEndpointStatusesArgs',
    'GlobalDNSRecordStatusMonitoredServiceStatusesArgs',
    'GlobalDNSRecordStatusProviderStatusArgs',
    'GlobalDNSRecordStatusProviderStatusRoute53Args',
    'GlobalDNSZoneSpecArgs',
    'GlobalDNSZoneSpecProviderArgs',
    'GlobalDNSZoneSpecProviderExternalDNSArgs',
    'GlobalDNSZoneSpecProviderRoute53Args',
    'GlobalDNSZoneSpecProviderRoute53CredentialsSecretRefArgs',
    'GlobalDNSZoneStatusArgs',
    'GlobalDNSZoneStatusConditionsArgs',
    'GlobalRouteDiscoverySpecArgs',
    'GlobalRouteDiscoverySpecClustersArgs',
    'GlobalRouteDiscoverySpecClustersClusterCredentialRefArgs',
    'GlobalRouteDiscoverySpecGlobalZoneRefArgs',
    'GlobalRouteDiscoverySpecRouteSelectorArgs',
    'GlobalRouteDiscoverySpecRouteSelectorMatchExpressionsArgs',
    'GlobalRouteDiscoveryStatusArgs',
    'GlobalRouteDiscoveryStatusClusterReferenceStatusesArgs',
    'GlobalRouteDiscoveryStatusConditionsArgs',
]

@pulumi.input_type
class GlobalDNSRecordSpecArgs:
    def __init__(__self__, *,
                 global_zone_ref: pulumi.Input['GlobalDNSRecordSpecGlobalZoneRefArgs'],
                 load_balancing_policy: pulumi.Input[str],
                 name: pulumi.Input[str],
                 endpoints: Optional[pulumi.Input[Sequence[pulumi.Input['GlobalDNSRecordSpecEndpointsArgs']]]] = None,
                 health_check: Optional[pulumi.Input['GlobalDNSRecordSpecHealthCheckArgs']] = None,
                 ttl: Optional[pulumi.Input[int]] = None):
        """
        GlobalDNSRecordSpec defines the desired state of GlobalDNSRecord
        :param pulumi.Input['GlobalDNSRecordSpecGlobalZoneRefArgs'] global_zone_ref: GlobalZoneRef represents the global zone that will be used to host this record
        :param pulumi.Input[str] load_balancing_policy: LoadBalancingPolicy describes the policy used to loadbalance the results of the DNS queries.
        :param pulumi.Input[str] name: Name is the fqdn that will be used for this record.
        :param pulumi.Input[Sequence[pulumi.Input['GlobalDNSRecordSpecEndpointsArgs']]] endpoints: Enpoints is the list of the cluster endpoitns that need to be considered for this dns record
        :param pulumi.Input['GlobalDNSRecordSpecHealthCheckArgs'] health_check: Probe is the health check used to probe the health of the applications and decide which IPs to return Only HttpAction is supported
        :param pulumi.Input[int] ttl: TTL is the TTL for this dns record kubebuilder:default:60
        """
        pulumi.set(__self__, "global_zone_ref", global_zone_ref)
        pulumi.set(__self__, "load_balancing_policy", load_balancing_policy)
        pulumi.set(__self__, "name", name)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter(name="globalZoneRef")
    def global_zone_ref(self) -> pulumi.Input['GlobalDNSRecordSpecGlobalZoneRefArgs']:
        """
        GlobalZoneRef represents the global zone that will be used to host this record
        """
        return pulumi.get(self, "global_zone_ref")

    @global_zone_ref.setter
    def global_zone_ref(self, value: pulumi.Input['GlobalDNSRecordSpecGlobalZoneRefArgs']):
        pulumi.set(self, "global_zone_ref", value)

    @property
    @pulumi.getter(name="loadBalancingPolicy")
    def load_balancing_policy(self) -> pulumi.Input[str]:
        """
        LoadBalancingPolicy describes the policy used to loadbalance the results of the DNS queries.
        """
        return pulumi.get(self, "load_balancing_policy")

    @load_balancing_policy.setter
    def load_balancing_policy(self, value: pulumi.Input[str]):
        pulumi.set(self, "load_balancing_policy", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name is the fqdn that will be used for this record.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GlobalDNSRecordSpecEndpointsArgs']]]]:
        """
        Enpoints is the list of the cluster endpoitns that need to be considered for this dns record
        """
        return pulumi.get(self, "endpoints")

    @endpoints.setter
    def endpoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GlobalDNSRecordSpecEndpointsArgs']]]]):
        pulumi.set(self, "endpoints", value)

    @property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional[pulumi.Input['GlobalDNSRecordSpecHealthCheckArgs']]:
        """
        Probe is the health check used to probe the health of the applications and decide which IPs to return Only HttpAction is supported
        """
        return pulumi.get(self, "health_check")

    @health_check.setter
    def health_check(self, value: Optional[pulumi.Input['GlobalDNSRecordSpecHealthCheckArgs']]):
        pulumi.set(self, "health_check", value)

    @property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[int]]:
        """
        TTL is the TTL for this dns record kubebuilder:default:60
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ttl", value)


@pulumi.input_type
class GlobalDNSRecordSpecEndpointsArgs:
    def __init__(__self__, *,
                 cluster_credential_ref: pulumi.Input['GlobalDNSRecordSpecEndpointsClusterCredentialRefArgs'],
                 cluster_name: pulumi.Input[str],
                 load_balancer_service_ref: pulumi.Input['GlobalDNSRecordSpecEndpointsLoadBalancerServiceRefArgs']):
        """
        Endpoint represents a traffic ingress point to the cluster. Currently only LoadBalancer service is supported.
        :param pulumi.Input['GlobalDNSRecordSpecEndpointsClusterCredentialRefArgs'] cluster_credential_ref: CredentialsSecretRef is a reference to a secret containing the credentials to access the cluster a key called "kubeconfig" containing a valid kubeconfig file for connecting to the cluster must exist in this secret.
        :param pulumi.Input[str] cluster_name: ClusterName name of the cluster to connect to.
        :param pulumi.Input['GlobalDNSRecordSpecEndpointsLoadBalancerServiceRefArgs'] load_balancer_service_ref: LoadBalancerServiceRef contains a reference to the load balancer service that will receive the traffic, if using a router, put here the service created by the ingress controller.
        """
        pulumi.set(__self__, "cluster_credential_ref", cluster_credential_ref)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "load_balancer_service_ref", load_balancer_service_ref)

    @property
    @pulumi.getter(name="clusterCredentialRef")
    def cluster_credential_ref(self) -> pulumi.Input['GlobalDNSRecordSpecEndpointsClusterCredentialRefArgs']:
        """
        CredentialsSecretRef is a reference to a secret containing the credentials to access the cluster a key called "kubeconfig" containing a valid kubeconfig file for connecting to the cluster must exist in this secret.
        """
        return pulumi.get(self, "cluster_credential_ref")

    @cluster_credential_ref.setter
    def cluster_credential_ref(self, value: pulumi.Input['GlobalDNSRecordSpecEndpointsClusterCredentialRefArgs']):
        pulumi.set(self, "cluster_credential_ref", value)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> pulumi.Input[str]:
        """
        ClusterName name of the cluster to connect to.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="loadBalancerServiceRef")
    def load_balancer_service_ref(self) -> pulumi.Input['GlobalDNSRecordSpecEndpointsLoadBalancerServiceRefArgs']:
        """
        LoadBalancerServiceRef contains a reference to the load balancer service that will receive the traffic, if using a router, put here the service created by the ingress controller.
        """
        return pulumi.get(self, "load_balancer_service_ref")

    @load_balancer_service_ref.setter
    def load_balancer_service_ref(self, value: pulumi.Input['GlobalDNSRecordSpecEndpointsLoadBalancerServiceRefArgs']):
        pulumi.set(self, "load_balancer_service_ref", value)


@pulumi.input_type
class GlobalDNSRecordSpecEndpointsClusterCredentialRefArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 namespace: pulumi.Input[str]):
        """
        CredentialsSecretRef is a reference to a secret containing the credentials to access the cluster a key called "kubeconfig" containing a valid kubeconfig file for connecting to the cluster must exist in this secret.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[str]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace", value)


@pulumi.input_type
class GlobalDNSRecordSpecEndpointsLoadBalancerServiceRefArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 namespace: pulumi.Input[str]):
        """
        LoadBalancerServiceRef contains a reference to the load balancer service that will receive the traffic, if using a router, put here the service created by the ingress controller.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[str]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace", value)


@pulumi.input_type
class GlobalDNSRecordSpecGlobalZoneRefArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        GlobalZoneRef represents the global zone that will be used to host this record
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class GlobalDNSRecordSpecHealthCheckArgs:
    def __init__(__self__, *,
                 exec_: Optional[pulumi.Input['GlobalDNSRecordSpecHealthCheckExecArgs']] = None,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 http_get: Optional[pulumi.Input['GlobalDNSRecordSpecHealthCheckHttpGetArgs']] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 success_threshold: Optional[pulumi.Input[int]] = None,
                 tcp_socket: Optional[pulumi.Input['GlobalDNSRecordSpecHealthCheckTcpSocketArgs']] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        Probe is the health check used to probe the health of the applications and decide which IPs to return Only HttpAction is supported
        :param pulumi.Input['GlobalDNSRecordSpecHealthCheckExecArgs'] exec_: One and only one of the following should be specified. Exec specifies the action to take.
        :param pulumi.Input[int] failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param pulumi.Input['GlobalDNSRecordSpecHealthCheckHttpGetArgs'] http_get: HTTPGet specifies the http request to perform.
        :param pulumi.Input[int] initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        :param pulumi.Input[int] period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param pulumi.Input[int] success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
        :param pulumi.Input['GlobalDNSRecordSpecHealthCheckTcpSocketArgs'] tcp_socket: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported TODO: implement a realistic TCP lifecycle hook
        :param pulumi.Input[int] timeout_seconds: Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        """
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if tcp_socket is not None:
            pulumi.set(__self__, "tcp_socket", tcp_socket)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional[pulumi.Input['GlobalDNSRecordSpecHealthCheckExecArgs']]:
        """
        One and only one of the following should be specified. Exec specifies the action to take.
        """
        return pulumi.get(self, "exec_")

    @exec_.setter
    def exec_(self, value: Optional[pulumi.Input['GlobalDNSRecordSpecHealthCheckExecArgs']]):
        pulumi.set(self, "exec_", value)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional[pulumi.Input['GlobalDNSRecordSpecHealthCheckHttpGetArgs']]:
        """
        HTTPGet specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @http_get.setter
    def http_get(self, value: Optional[pulumi.Input['GlobalDNSRecordSpecHealthCheckHttpGetArgs']]):
        pulumi.set(self, "http_get", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "success_threshold", value)

    @property
    @pulumi.getter(name="tcpSocket")
    def tcp_socket(self) -> Optional[pulumi.Input['GlobalDNSRecordSpecHealthCheckTcpSocketArgs']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported TODO: implement a realistic TCP lifecycle hook
        """
        return pulumi.get(self, "tcp_socket")

    @tcp_socket.setter
    def tcp_socket(self, value: Optional[pulumi.Input['GlobalDNSRecordSpecHealthCheckTcpSocketArgs']]):
        pulumi.set(self, "tcp_socket", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


@pulumi.input_type
class GlobalDNSRecordSpecHealthCheckExecArgs:
    def __init__(__self__, *,
                 command: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        One and only one of the following should be specified. Exec specifies the action to take.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] command: Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        if command is not None:
            pulumi.set(__self__, "command", command)

    @property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        """
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "command", value)


@pulumi.input_type
class GlobalDNSRecordSpecHealthCheckHttpGetArgs:
    def __init__(__self__, *,
                 port: pulumi.Input['GlobalDNSRecordSpecHealthCheckHttpGetPortArgs'],
                 host: Optional[pulumi.Input[str]] = None,
                 http_headers: Optional[pulumi.Input[Sequence[pulumi.Input['GlobalDNSRecordSpecHealthCheckHttpGetHttpHeadersArgs']]]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 scheme: Optional[pulumi.Input[str]] = None):
        """
        HTTPGet specifies the http request to perform.
        :param pulumi.Input['GlobalDNSRecordSpecHealthCheckHttpGetPortArgs'] port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        :param pulumi.Input[str] host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param pulumi.Input[Sequence[pulumi.Input['GlobalDNSRecordSpecHealthCheckHttpGetHttpHeadersArgs']]] http_headers: Custom headers to set in the request. HTTP allows repeated headers.
        :param pulumi.Input[str] path: Path to access on the HTTP server.
        :param pulumi.Input[str] scheme: Scheme to use for connecting to the host. Defaults to HTTP.
        """
        pulumi.set(__self__, "port", port)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input['GlobalDNSRecordSpecHealthCheckHttpGetPortArgs']:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input['GlobalDNSRecordSpecHealthCheckHttpGetPortArgs']):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GlobalDNSRecordSpecHealthCheckHttpGetHttpHeadersArgs']]]]:
        """
        Custom headers to set in the request. HTTP allows repeated headers.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GlobalDNSRecordSpecHealthCheckHttpGetHttpHeadersArgs']]]]):
        pulumi.set(self, "http_headers", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[str]]:
        """
        Scheme to use for connecting to the host. Defaults to HTTP.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scheme", value)


@pulumi.input_type
class GlobalDNSRecordSpecHealthCheckHttpGetHttpHeadersArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        HTTPHeader describes a custom header to be used in HTTP probes
        :param pulumi.Input[str] name: The header field name
        :param pulumi.Input[str] value: The header field value
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class GlobalDNSRecordSpecHealthCheckHttpGetPortArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class GlobalDNSRecordSpecHealthCheckTcpSocketArgs:
    def __init__(__self__, *,
                 port: pulumi.Input['GlobalDNSRecordSpecHealthCheckTcpSocketPortArgs'],
                 host: Optional[pulumi.Input[str]] = None):
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported TODO: implement a realistic TCP lifecycle hook
        :param pulumi.Input['GlobalDNSRecordSpecHealthCheckTcpSocketPortArgs'] port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        :param pulumi.Input[str] host: Optional: Host name to connect to, defaults to the pod IP.
        """
        pulumi.set(__self__, "port", port)
        if host is not None:
            pulumi.set(__self__, "host", host)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input['GlobalDNSRecordSpecHealthCheckTcpSocketPortArgs']:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input['GlobalDNSRecordSpecHealthCheckTcpSocketPortArgs']):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        Optional: Host name to connect to, defaults to the pod IP.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)


@pulumi.input_type
class GlobalDNSRecordSpecHealthCheckTcpSocketPortArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class GlobalDNSRecordStatusArgs:
    def __init__(__self__, *,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['GlobalDNSRecordStatusConditionsArgs']]]] = None,
                 endpoint_statuses: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input['GlobalDNSRecordStatusEndpointStatusesArgs']]]]]] = None,
                 monitored_service_statuses: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input['GlobalDNSRecordStatusMonitoredServiceStatusesArgs']]]]]] = None,
                 provider_status: Optional[pulumi.Input['GlobalDNSRecordStatusProviderStatusArgs']] = None):
        """
        GlobalDNSRecordStatus defines the observed state of GlobalDNSRecord
        :param pulumi.Input[Sequence[pulumi.Input['GlobalDNSRecordStatusConditionsArgs']]] conditions: ReconcileStatus this is the general status of the main reconciler
        :param pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input['GlobalDNSRecordStatusEndpointStatusesArgs']]]]] endpoint_statuses: EndpointStatuses contains the status of the endpoint as they were looked up during the latest reconcile. We don't fail when an endpoint look up fails, but we need to tarck its status.
        :param pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input['GlobalDNSRecordStatusMonitoredServiceStatusesArgs']]]]] monitored_service_statuses: MonitoredServiceStatuses contains the reconcile status of each of the monitored services in the remote clusters
        :param pulumi.Input['GlobalDNSRecordStatusProviderStatusArgs'] provider_status: ProviderStatus contains provider specific status information
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if endpoint_statuses is not None:
            pulumi.set(__self__, "endpoint_statuses", endpoint_statuses)
        if monitored_service_statuses is not None:
            pulumi.set(__self__, "monitored_service_statuses", monitored_service_statuses)
        if provider_status is not None:
            pulumi.set(__self__, "provider_status", provider_status)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GlobalDNSRecordStatusConditionsArgs']]]]:
        """
        ReconcileStatus this is the general status of the main reconciler
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GlobalDNSRecordStatusConditionsArgs']]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="endpointStatuses")
    def endpoint_statuses(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input['GlobalDNSRecordStatusEndpointStatusesArgs']]]]]]:
        """
        EndpointStatuses contains the status of the endpoint as they were looked up during the latest reconcile. We don't fail when an endpoint look up fails, but we need to tarck its status.
        """
        return pulumi.get(self, "endpoint_statuses")

    @endpoint_statuses.setter
    def endpoint_statuses(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input['GlobalDNSRecordStatusEndpointStatusesArgs']]]]]]):
        pulumi.set(self, "endpoint_statuses", value)

    @property
    @pulumi.getter(name="monitoredServiceStatuses")
    def monitored_service_statuses(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input['GlobalDNSRecordStatusMonitoredServiceStatusesArgs']]]]]]:
        """
        MonitoredServiceStatuses contains the reconcile status of each of the monitored services in the remote clusters
        """
        return pulumi.get(self, "monitored_service_statuses")

    @monitored_service_statuses.setter
    def monitored_service_statuses(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input['GlobalDNSRecordStatusMonitoredServiceStatusesArgs']]]]]]):
        pulumi.set(self, "monitored_service_statuses", value)

    @property
    @pulumi.getter(name="providerStatus")
    def provider_status(self) -> Optional[pulumi.Input['GlobalDNSRecordStatusProviderStatusArgs']]:
        """
        ProviderStatus contains provider specific status information
        """
        return pulumi.get(self, "provider_status")

    @provider_status.setter
    def provider_status(self, value: Optional[pulumi.Input['GlobalDNSRecordStatusProviderStatusArgs']]):
        pulumi.set(self, "provider_status", value)


@pulumi.input_type
class GlobalDNSRecordStatusConditionsArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[str],
                 type: pulumi.Input[str],
                 last_transition_time: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None):
        """
        Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
         Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
        :param pulumi.Input[str] type: ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
                Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        :param pulumi.Input[str] reason: ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
         Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)


@pulumi.input_type
class GlobalDNSRecordStatusEndpointStatusesArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[str],
                 type: pulumi.Input[str],
                 last_transition_time: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None):
        """
        Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
         Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
        :param pulumi.Input[str] type: ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
                Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        :param pulumi.Input[str] reason: ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
         Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)


@pulumi.input_type
class GlobalDNSRecordStatusMonitoredServiceStatusesArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[str],
                 type: pulumi.Input[str],
                 last_transition_time: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None):
        """
        Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
         Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
        :param pulumi.Input[str] type: ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
                Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        :param pulumi.Input[str] reason: ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
         Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)


@pulumi.input_type
class GlobalDNSRecordStatusProviderStatusArgs:
    def __init__(__self__, *,
                 route53: Optional[pulumi.Input['GlobalDNSRecordStatusProviderStatusRoute53Args']] = None):
        """
        ProviderStatus contains provider specific status information
        """
        if route53 is not None:
            pulumi.set(__self__, "route53", route53)

    @property
    @pulumi.getter
    def route53(self) -> Optional[pulumi.Input['GlobalDNSRecordStatusProviderStatusRoute53Args']]:
        return pulumi.get(self, "route53")

    @route53.setter
    def route53(self, value: Optional[pulumi.Input['GlobalDNSRecordStatusProviderStatusRoute53Args']]):
        pulumi.set(self, "route53", value)


@pulumi.input_type
class GlobalDNSRecordStatusProviderStatusRoute53Args:
    def __init__(__self__, *,
                 health_check_id: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 policy_id: Optional[pulumi.Input[str]] = None,
                 policy_instance_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] health_check_id: HealthCheckID represents the route53 healthcheck created for this record
        :param pulumi.Input[str] policy_id: PolicyID represents the route53 routing policy created for this record
        :param pulumi.Input[str] policy_instance_id: PolicyInstanceID represents the ID of the DNSRecord
        """
        if health_check_id is not None:
            pulumi.set(__self__, "health_check_id", health_check_id)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)
        if policy_instance_id is not None:
            pulumi.set(__self__, "policy_instance_id", policy_instance_id)

    @property
    @pulumi.getter(name="healthCheckID")
    def health_check_id(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        HealthCheckID represents the route53 healthcheck created for this record
        """
        return pulumi.get(self, "health_check_id")

    @health_check_id.setter
    def health_check_id(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "health_check_id", value)

    @property
    @pulumi.getter(name="policyID")
    def policy_id(self) -> Optional[pulumi.Input[str]]:
        """
        PolicyID represents the route53 routing policy created for this record
        """
        return pulumi.get(self, "policy_id")

    @policy_id.setter
    def policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "policy_id", value)

    @property
    @pulumi.getter(name="policyInstanceID")
    def policy_instance_id(self) -> Optional[pulumi.Input[str]]:
        """
        PolicyInstanceID represents the ID of the DNSRecord
        """
        return pulumi.get(self, "policy_instance_id")

    @policy_instance_id.setter
    def policy_instance_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "policy_instance_id", value)


@pulumi.input_type
class GlobalDNSZoneSpecArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[str],
                 provider: pulumi.Input['GlobalDNSZoneSpecProviderArgs']):
        """
        GlobalDNSZoneSpec defines the desired state of GlobalDNSZone
        :param pulumi.Input['GlobalDNSZoneSpecProviderArgs'] provider: ProviderConfig configures kind and access to the DNS Zone. Exactly one of its members must be set.
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "provider", provider)

    @property
    @pulumi.getter
    def domain(self) -> pulumi.Input[str]:
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter
    def provider(self) -> pulumi.Input['GlobalDNSZoneSpecProviderArgs']:
        """
        ProviderConfig configures kind and access to the DNS Zone. Exactly one of its members must be set.
        """
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: pulumi.Input['GlobalDNSZoneSpecProviderArgs']):
        pulumi.set(self, "provider", value)


@pulumi.input_type
class GlobalDNSZoneSpecProviderArgs:
    def __init__(__self__, *,
                 external_dns: Optional[pulumi.Input['GlobalDNSZoneSpecProviderExternalDNSArgs']] = None,
                 route53: Optional[pulumi.Input['GlobalDNSZoneSpecProviderRoute53Args']] = None):
        """
        ProviderConfig configures kind and access to the DNS Zone. Exactly one of its members must be set.
        :param pulumi.Input['GlobalDNSZoneSpecProviderExternalDNSArgs'] external_dns: ExternalDNSProviderConfig contains configuration on how configure the external DNS provider
        :param pulumi.Input['GlobalDNSZoneSpecProviderRoute53Args'] route53: Route53ProviderConfig contains configuration on how to access the route53 API
        """
        if external_dns is not None:
            pulumi.set(__self__, "external_dns", external_dns)
        if route53 is not None:
            pulumi.set(__self__, "route53", route53)

    @property
    @pulumi.getter(name="externalDNS")
    def external_dns(self) -> Optional[pulumi.Input['GlobalDNSZoneSpecProviderExternalDNSArgs']]:
        """
        ExternalDNSProviderConfig contains configuration on how configure the external DNS provider
        """
        return pulumi.get(self, "external_dns")

    @external_dns.setter
    def external_dns(self, value: Optional[pulumi.Input['GlobalDNSZoneSpecProviderExternalDNSArgs']]):
        pulumi.set(self, "external_dns", value)

    @property
    @pulumi.getter
    def route53(self) -> Optional[pulumi.Input['GlobalDNSZoneSpecProviderRoute53Args']]:
        """
        Route53ProviderConfig contains configuration on how to access the route53 API
        """
        return pulumi.get(self, "route53")

    @route53.setter
    def route53(self, value: Optional[pulumi.Input['GlobalDNSZoneSpecProviderRoute53Args']]):
        pulumi.set(self, "route53", value)


@pulumi.input_type
class GlobalDNSZoneSpecProviderExternalDNSArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        ExternalDNSProviderConfig contains configuration on how configure the external DNS provider
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] annotations: Annotations is a map of annotations to be added to the created DNSEndpoint records.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Annotations is a map of annotations to be added to the created DNSEndpoint records.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "annotations", value)


@pulumi.input_type
class GlobalDNSZoneSpecProviderRoute53Args:
    def __init__(__self__, *,
                 credentials_secret_ref: pulumi.Input['GlobalDNSZoneSpecProviderRoute53CredentialsSecretRefArgs'],
                 zone_id: pulumi.Input[str]):
        """
        Route53ProviderConfig contains configuration on how to access the route53 API
        :param pulumi.Input['GlobalDNSZoneSpecProviderRoute53CredentialsSecretRefArgs'] credentials_secret_ref: CredentialsSecretRef is a reference to a secret containing the credentials to access the AWS API //TODO (content and needed permissions) expected secret keys are "aws_access_key_id" and "aws_secret_access_key"
        :param pulumi.Input[str] zone_id: ZoneID is the AWS route53 zone ID.
        """
        pulumi.set(__self__, "credentials_secret_ref", credentials_secret_ref)
        pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter(name="credentialsSecretRef")
    def credentials_secret_ref(self) -> pulumi.Input['GlobalDNSZoneSpecProviderRoute53CredentialsSecretRefArgs']:
        """
        CredentialsSecretRef is a reference to a secret containing the credentials to access the AWS API //TODO (content and needed permissions) expected secret keys are "aws_access_key_id" and "aws_secret_access_key"
        """
        return pulumi.get(self, "credentials_secret_ref")

    @credentials_secret_ref.setter
    def credentials_secret_ref(self, value: pulumi.Input['GlobalDNSZoneSpecProviderRoute53CredentialsSecretRefArgs']):
        pulumi.set(self, "credentials_secret_ref", value)

    @property
    @pulumi.getter(name="zoneID")
    def zone_id(self) -> pulumi.Input[str]:
        """
        ZoneID is the AWS route53 zone ID.
        """
        return pulumi.get(self, "zone_id")

    @zone_id.setter
    def zone_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "zone_id", value)


@pulumi.input_type
class GlobalDNSZoneSpecProviderRoute53CredentialsSecretRefArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 namespace: pulumi.Input[str]):
        """
        CredentialsSecretRef is a reference to a secret containing the credentials to access the AWS API //TODO (content and needed permissions) expected secret keys are "aws_access_key_id" and "aws_secret_access_key"
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[str]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace", value)


@pulumi.input_type
class GlobalDNSZoneStatusArgs:
    def __init__(__self__, *,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['GlobalDNSZoneStatusConditionsArgs']]]] = None):
        """
        GlobalDNSZoneStatus defines the observed state of GlobalDNSZone
        :param pulumi.Input[Sequence[pulumi.Input['GlobalDNSZoneStatusConditionsArgs']]] conditions: INSERT ADDITIONAL STATUS FIELD - define observed state of cluster Important: Run "operator-sdk generate k8s" to regenerate code after modifying this file Add custom validation using kubebuilder tags: https://book-v1.book.kubebuilder.io/beyond_basics/generating_crd.html
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GlobalDNSZoneStatusConditionsArgs']]]]:
        """
        INSERT ADDITIONAL STATUS FIELD - define observed state of cluster Important: Run "operator-sdk generate k8s" to regenerate code after modifying this file Add custom validation using kubebuilder tags: https://book-v1.book.kubebuilder.io/beyond_basics/generating_crd.html
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GlobalDNSZoneStatusConditionsArgs']]]]):
        pulumi.set(self, "conditions", value)


@pulumi.input_type
class GlobalDNSZoneStatusConditionsArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[str],
                 type: pulumi.Input[str],
                 last_transition_time: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None):
        """
        Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
         Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
        :param pulumi.Input[str] type: ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
                Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        :param pulumi.Input[str] reason: ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
         Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)


@pulumi.input_type
class GlobalRouteDiscoverySpecArgs:
    def __init__(__self__, *,
                 global_zone_ref: pulumi.Input['GlobalRouteDiscoverySpecGlobalZoneRefArgs'],
                 clusters: Optional[pulumi.Input[Sequence[pulumi.Input['GlobalRouteDiscoverySpecClustersArgs']]]] = None,
                 default_load_balancing_policy: Optional[pulumi.Input[str]] = None,
                 default_ttl: Optional[pulumi.Input[int]] = None,
                 route_selector: Optional[pulumi.Input['GlobalRouteDiscoverySpecRouteSelectorArgs']] = None):
        """
        GlobalRouteDiscoverySpec defines the desired state of GlobalRouteDiscovery
        :param pulumi.Input['GlobalRouteDiscoverySpecGlobalZoneRefArgs'] global_zone_ref: GlobalZoneRef represents the global zone that will be used to host this record
        :param pulumi.Input[Sequence[pulumi.Input['GlobalRouteDiscoverySpecClustersArgs']]] clusters: Cluster is an arrays with the list of clusters in which global routes will be discovered
        :param pulumi.Input[str] default_load_balancing_policy: DefaultLoadBalancingPolicy defines the load balancing policy to be used by default. This can be overridden with a route annotation TODO which? -kubebuilder:default:="Multivalue"
        :param pulumi.Input[int] default_ttl: Dfeault TTL is the TTL for this dns record -kubebuilder:default:60
        :param pulumi.Input['GlobalRouteDiscoverySpecRouteSelectorArgs'] route_selector: RouteSelector is the selector that selects the global routes, this allows you to define also local routes.
        """
        pulumi.set(__self__, "global_zone_ref", global_zone_ref)
        if clusters is not None:
            pulumi.set(__self__, "clusters", clusters)
        if default_load_balancing_policy is not None:
            pulumi.set(__self__, "default_load_balancing_policy", default_load_balancing_policy)
        if default_ttl is not None:
            pulumi.set(__self__, "default_ttl", default_ttl)
        if route_selector is not None:
            pulumi.set(__self__, "route_selector", route_selector)

    @property
    @pulumi.getter(name="globalZoneRef")
    def global_zone_ref(self) -> pulumi.Input['GlobalRouteDiscoverySpecGlobalZoneRefArgs']:
        """
        GlobalZoneRef represents the global zone that will be used to host this record
        """
        return pulumi.get(self, "global_zone_ref")

    @global_zone_ref.setter
    def global_zone_ref(self, value: pulumi.Input['GlobalRouteDiscoverySpecGlobalZoneRefArgs']):
        pulumi.set(self, "global_zone_ref", value)

    @property
    @pulumi.getter
    def clusters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GlobalRouteDiscoverySpecClustersArgs']]]]:
        """
        Cluster is an arrays with the list of clusters in which global routes will be discovered
        """
        return pulumi.get(self, "clusters")

    @clusters.setter
    def clusters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GlobalRouteDiscoverySpecClustersArgs']]]]):
        pulumi.set(self, "clusters", value)

    @property
    @pulumi.getter(name="defaultLoadBalancingPolicy")
    def default_load_balancing_policy(self) -> Optional[pulumi.Input[str]]:
        """
        DefaultLoadBalancingPolicy defines the load balancing policy to be used by default. This can be overridden with a route annotation TODO which? -kubebuilder:default:="Multivalue"
        """
        return pulumi.get(self, "default_load_balancing_policy")

    @default_load_balancing_policy.setter
    def default_load_balancing_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_load_balancing_policy", value)

    @property
    @pulumi.getter(name="defaultTTL")
    def default_ttl(self) -> Optional[pulumi.Input[int]]:
        """
        Dfeault TTL is the TTL for this dns record -kubebuilder:default:60
        """
        return pulumi.get(self, "default_ttl")

    @default_ttl.setter
    def default_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "default_ttl", value)

    @property
    @pulumi.getter(name="routeSelector")
    def route_selector(self) -> Optional[pulumi.Input['GlobalRouteDiscoverySpecRouteSelectorArgs']]:
        """
        RouteSelector is the selector that selects the global routes, this allows you to define also local routes.
        """
        return pulumi.get(self, "route_selector")

    @route_selector.setter
    def route_selector(self, value: Optional[pulumi.Input['GlobalRouteDiscoverySpecRouteSelectorArgs']]):
        pulumi.set(self, "route_selector", value)


@pulumi.input_type
class GlobalRouteDiscoverySpecClustersArgs:
    def __init__(__self__, *,
                 cluster_credential_ref: pulumi.Input['GlobalRouteDiscoverySpecClustersClusterCredentialRefArgs'],
                 cluster_name: pulumi.Input[str]):
        """
        ClusterReference contains the infomation necessary to connect to a cluster
        :param pulumi.Input['GlobalRouteDiscoverySpecClustersClusterCredentialRefArgs'] cluster_credential_ref: CredentialsSecretRef is a reference to a secret containing the credentials to access the cluster a key called "kubeconfig" containing a valid kubeconfig file for connecting to the cluster must exist in this secret.
        :param pulumi.Input[str] cluster_name: ClusterName name of the cluster to connect to.
        """
        pulumi.set(__self__, "cluster_credential_ref", cluster_credential_ref)
        pulumi.set(__self__, "cluster_name", cluster_name)

    @property
    @pulumi.getter(name="clusterCredentialRef")
    def cluster_credential_ref(self) -> pulumi.Input['GlobalRouteDiscoverySpecClustersClusterCredentialRefArgs']:
        """
        CredentialsSecretRef is a reference to a secret containing the credentials to access the cluster a key called "kubeconfig" containing a valid kubeconfig file for connecting to the cluster must exist in this secret.
        """
        return pulumi.get(self, "cluster_credential_ref")

    @cluster_credential_ref.setter
    def cluster_credential_ref(self, value: pulumi.Input['GlobalRouteDiscoverySpecClustersClusterCredentialRefArgs']):
        pulumi.set(self, "cluster_credential_ref", value)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> pulumi.Input[str]:
        """
        ClusterName name of the cluster to connect to.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "cluster_name", value)


@pulumi.input_type
class GlobalRouteDiscoverySpecClustersClusterCredentialRefArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 namespace: pulumi.Input[str]):
        """
        CredentialsSecretRef is a reference to a secret containing the credentials to access the cluster a key called "kubeconfig" containing a valid kubeconfig file for connecting to the cluster must exist in this secret.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[str]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace", value)


@pulumi.input_type
class GlobalRouteDiscoverySpecGlobalZoneRefArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        GlobalZoneRef represents the global zone that will be used to host this record
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class GlobalRouteDiscoverySpecRouteSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['GlobalRouteDiscoverySpecRouteSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        RouteSelector is the selector that selects the global routes, this allows you to define also local routes.
        :param pulumi.Input[Sequence[pulumi.Input['GlobalRouteDiscoverySpecRouteSelectorMatchExpressionsArgs']]] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GlobalRouteDiscoverySpecRouteSelectorMatchExpressionsArgs']]]]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GlobalRouteDiscoverySpecRouteSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class GlobalRouteDiscoverySpecRouteSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param pulumi.Input[str] key: key is the label key that the selector applies to.
        :param pulumi.Input[str] operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GlobalRouteDiscoveryStatusArgs:
    def __init__(__self__, *,
                 cluster_reference_statuses: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input['GlobalRouteDiscoveryStatusClusterReferenceStatusesArgs']]]]]] = None,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['GlobalRouteDiscoveryStatusConditionsArgs']]]] = None):
        """
        GlobalRouteDiscoveryStatus defines the observed state of GlobalRouteDiscovery
        :param pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input['GlobalRouteDiscoveryStatusClusterReferenceStatusesArgs']]]]] cluster_reference_statuses: ClusterReferenceStatuses contains the status of the cluster refence connections and their latest reconcile.
        :param pulumi.Input[Sequence[pulumi.Input['GlobalRouteDiscoveryStatusConditionsArgs']]] conditions: ReconcileStatus this is the general status of the main reconciler
        """
        if cluster_reference_statuses is not None:
            pulumi.set(__self__, "cluster_reference_statuses", cluster_reference_statuses)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter(name="clusterReferenceStatuses")
    def cluster_reference_statuses(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input['GlobalRouteDiscoveryStatusClusterReferenceStatusesArgs']]]]]]:
        """
        ClusterReferenceStatuses contains the status of the cluster refence connections and their latest reconcile.
        """
        return pulumi.get(self, "cluster_reference_statuses")

    @cluster_reference_statuses.setter
    def cluster_reference_statuses(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input['GlobalRouteDiscoveryStatusClusterReferenceStatusesArgs']]]]]]):
        pulumi.set(self, "cluster_reference_statuses", value)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GlobalRouteDiscoveryStatusConditionsArgs']]]]:
        """
        ReconcileStatus this is the general status of the main reconciler
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GlobalRouteDiscoveryStatusConditionsArgs']]]]):
        pulumi.set(self, "conditions", value)


@pulumi.input_type
class GlobalRouteDiscoveryStatusClusterReferenceStatusesArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[str],
                 type: pulumi.Input[str],
                 last_transition_time: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None):
        """
        Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
         Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
        :param pulumi.Input[str] type: ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
                Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        :param pulumi.Input[str] reason: ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
         Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)


@pulumi.input_type
class GlobalRouteDiscoveryStatusConditionsArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[str],
                 type: pulumi.Input[str],
                 last_transition_time: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None):
        """
        Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
         Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
        :param pulumi.Input[str] type: ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
                Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        :param pulumi.Input[str] reason: ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
         Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)


