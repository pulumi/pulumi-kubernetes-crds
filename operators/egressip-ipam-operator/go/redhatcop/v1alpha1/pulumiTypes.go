// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package v1alpha1

import (
	"context"
	"reflect"

	metav1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/meta/v1"
	"github.com/pulumi/pulumi/sdk/v2/go/pulumi"
)

// EgressIPAM is the Schema for the egressipams API
type EgressIPAMType struct {
	ApiVersion *string            `pulumi:"apiVersion"`
	Kind       *string            `pulumi:"kind"`
	Metadata   *metav1.ObjectMeta `pulumi:"metadata"`
	// EgressIPAMSpec defines the desired state of EgressIPAM
	Spec *EgressIPAMSpec `pulumi:"spec"`
	// EgressIPAMStatus defines the observed state of EgressIPAM
	Status *EgressIPAMStatus `pulumi:"status"`
}

// EgressIPAMTypeInput is an input type that accepts EgressIPAMTypeArgs and EgressIPAMTypeOutput values.
// You can construct a concrete instance of `EgressIPAMTypeInput` via:
//
//          EgressIPAMTypeArgs{...}
type EgressIPAMTypeInput interface {
	pulumi.Input

	ToEgressIPAMTypeOutput() EgressIPAMTypeOutput
	ToEgressIPAMTypeOutputWithContext(context.Context) EgressIPAMTypeOutput
}

// EgressIPAM is the Schema for the egressipams API
type EgressIPAMTypeArgs struct {
	ApiVersion pulumi.StringPtrInput     `pulumi:"apiVersion"`
	Kind       pulumi.StringPtrInput     `pulumi:"kind"`
	Metadata   metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	// EgressIPAMSpec defines the desired state of EgressIPAM
	Spec EgressIPAMSpecPtrInput `pulumi:"spec"`
	// EgressIPAMStatus defines the observed state of EgressIPAM
	Status EgressIPAMStatusPtrInput `pulumi:"status"`
}

func (EgressIPAMTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*EgressIPAMType)(nil)).Elem()
}

func (i EgressIPAMTypeArgs) ToEgressIPAMTypeOutput() EgressIPAMTypeOutput {
	return i.ToEgressIPAMTypeOutputWithContext(context.Background())
}

func (i EgressIPAMTypeArgs) ToEgressIPAMTypeOutputWithContext(ctx context.Context) EgressIPAMTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EgressIPAMTypeOutput)
}

// EgressIPAM is the Schema for the egressipams API
type EgressIPAMTypeOutput struct{ *pulumi.OutputState }

func (EgressIPAMTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EgressIPAMType)(nil)).Elem()
}

func (o EgressIPAMTypeOutput) ToEgressIPAMTypeOutput() EgressIPAMTypeOutput {
	return o
}

func (o EgressIPAMTypeOutput) ToEgressIPAMTypeOutputWithContext(ctx context.Context) EgressIPAMTypeOutput {
	return o
}

func (o EgressIPAMTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EgressIPAMType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

func (o EgressIPAMTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EgressIPAMType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

func (o EgressIPAMTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v EgressIPAMType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

// EgressIPAMSpec defines the desired state of EgressIPAM
func (o EgressIPAMTypeOutput) Spec() EgressIPAMSpecPtrOutput {
	return o.ApplyT(func(v EgressIPAMType) *EgressIPAMSpec { return v.Spec }).(EgressIPAMSpecPtrOutput)
}

// EgressIPAMStatus defines the observed state of EgressIPAM
func (o EgressIPAMTypeOutput) Status() EgressIPAMStatusPtrOutput {
	return o.ApplyT(func(v EgressIPAMType) *EgressIPAMStatus { return v.Status }).(EgressIPAMStatusPtrOutput)
}

type EgressIPAMMetadata struct {
}

// EgressIPAMMetadataInput is an input type that accepts EgressIPAMMetadataArgs and EgressIPAMMetadataOutput values.
// You can construct a concrete instance of `EgressIPAMMetadataInput` via:
//
//          EgressIPAMMetadataArgs{...}
type EgressIPAMMetadataInput interface {
	pulumi.Input

	ToEgressIPAMMetadataOutput() EgressIPAMMetadataOutput
	ToEgressIPAMMetadataOutputWithContext(context.Context) EgressIPAMMetadataOutput
}

type EgressIPAMMetadataArgs struct {
}

func (EgressIPAMMetadataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*EgressIPAMMetadata)(nil)).Elem()
}

func (i EgressIPAMMetadataArgs) ToEgressIPAMMetadataOutput() EgressIPAMMetadataOutput {
	return i.ToEgressIPAMMetadataOutputWithContext(context.Background())
}

func (i EgressIPAMMetadataArgs) ToEgressIPAMMetadataOutputWithContext(ctx context.Context) EgressIPAMMetadataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EgressIPAMMetadataOutput)
}

type EgressIPAMMetadataOutput struct{ *pulumi.OutputState }

func (EgressIPAMMetadataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EgressIPAMMetadata)(nil)).Elem()
}

func (o EgressIPAMMetadataOutput) ToEgressIPAMMetadataOutput() EgressIPAMMetadataOutput {
	return o
}

func (o EgressIPAMMetadataOutput) ToEgressIPAMMetadataOutputWithContext(ctx context.Context) EgressIPAMMetadataOutput {
	return o
}

// EgressIPAMSpec defines the desired state of EgressIPAM
type EgressIPAMSpec struct {
	// CIDRAssignments is a set of CIDRs. Namespaces will receive one available IP from each of this CIDRs.
	CidrAssignments []EgressIPAMSpecCidrAssignments `pulumi:"cidrAssignments"`
	// NodeSelector is a selector that allows to subset which nodes will be managed by this EgressIPAM
	NodeSelector *EgressIPAMSpecNodeSelector `pulumi:"nodeSelector"`
	// TopologyLabel is the label that needs to identified nodes that will carry egressIPs in the CIDRAssignments. Each label value should map to a CIDR in the CIDRAssignments.
	TopologyLabel string `pulumi:"topologyLabel"`
}

// EgressIPAMSpecInput is an input type that accepts EgressIPAMSpecArgs and EgressIPAMSpecOutput values.
// You can construct a concrete instance of `EgressIPAMSpecInput` via:
//
//          EgressIPAMSpecArgs{...}
type EgressIPAMSpecInput interface {
	pulumi.Input

	ToEgressIPAMSpecOutput() EgressIPAMSpecOutput
	ToEgressIPAMSpecOutputWithContext(context.Context) EgressIPAMSpecOutput
}

// EgressIPAMSpec defines the desired state of EgressIPAM
type EgressIPAMSpecArgs struct {
	// CIDRAssignments is a set of CIDRs. Namespaces will receive one available IP from each of this CIDRs.
	CidrAssignments EgressIPAMSpecCidrAssignmentsArrayInput `pulumi:"cidrAssignments"`
	// NodeSelector is a selector that allows to subset which nodes will be managed by this EgressIPAM
	NodeSelector EgressIPAMSpecNodeSelectorPtrInput `pulumi:"nodeSelector"`
	// TopologyLabel is the label that needs to identified nodes that will carry egressIPs in the CIDRAssignments. Each label value should map to a CIDR in the CIDRAssignments.
	TopologyLabel pulumi.StringInput `pulumi:"topologyLabel"`
}

func (EgressIPAMSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*EgressIPAMSpec)(nil)).Elem()
}

func (i EgressIPAMSpecArgs) ToEgressIPAMSpecOutput() EgressIPAMSpecOutput {
	return i.ToEgressIPAMSpecOutputWithContext(context.Background())
}

func (i EgressIPAMSpecArgs) ToEgressIPAMSpecOutputWithContext(ctx context.Context) EgressIPAMSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EgressIPAMSpecOutput)
}

func (i EgressIPAMSpecArgs) ToEgressIPAMSpecPtrOutput() EgressIPAMSpecPtrOutput {
	return i.ToEgressIPAMSpecPtrOutputWithContext(context.Background())
}

func (i EgressIPAMSpecArgs) ToEgressIPAMSpecPtrOutputWithContext(ctx context.Context) EgressIPAMSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EgressIPAMSpecOutput).ToEgressIPAMSpecPtrOutputWithContext(ctx)
}

// EgressIPAMSpecPtrInput is an input type that accepts EgressIPAMSpecArgs, EgressIPAMSpecPtr and EgressIPAMSpecPtrOutput values.
// You can construct a concrete instance of `EgressIPAMSpecPtrInput` via:
//
//          EgressIPAMSpecArgs{...}
//
//  or:
//
//          nil
type EgressIPAMSpecPtrInput interface {
	pulumi.Input

	ToEgressIPAMSpecPtrOutput() EgressIPAMSpecPtrOutput
	ToEgressIPAMSpecPtrOutputWithContext(context.Context) EgressIPAMSpecPtrOutput
}

type egressIPAMSpecPtrType EgressIPAMSpecArgs

func EgressIPAMSpecPtr(v *EgressIPAMSpecArgs) EgressIPAMSpecPtrInput {
	return (*egressIPAMSpecPtrType)(v)
}

func (*egressIPAMSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**EgressIPAMSpec)(nil)).Elem()
}

func (i *egressIPAMSpecPtrType) ToEgressIPAMSpecPtrOutput() EgressIPAMSpecPtrOutput {
	return i.ToEgressIPAMSpecPtrOutputWithContext(context.Background())
}

func (i *egressIPAMSpecPtrType) ToEgressIPAMSpecPtrOutputWithContext(ctx context.Context) EgressIPAMSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EgressIPAMSpecPtrOutput)
}

// EgressIPAMSpec defines the desired state of EgressIPAM
type EgressIPAMSpecOutput struct{ *pulumi.OutputState }

func (EgressIPAMSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EgressIPAMSpec)(nil)).Elem()
}

func (o EgressIPAMSpecOutput) ToEgressIPAMSpecOutput() EgressIPAMSpecOutput {
	return o
}

func (o EgressIPAMSpecOutput) ToEgressIPAMSpecOutputWithContext(ctx context.Context) EgressIPAMSpecOutput {
	return o
}

func (o EgressIPAMSpecOutput) ToEgressIPAMSpecPtrOutput() EgressIPAMSpecPtrOutput {
	return o.ToEgressIPAMSpecPtrOutputWithContext(context.Background())
}

func (o EgressIPAMSpecOutput) ToEgressIPAMSpecPtrOutputWithContext(ctx context.Context) EgressIPAMSpecPtrOutput {
	return o.ApplyT(func(v EgressIPAMSpec) *EgressIPAMSpec {
		return &v
	}).(EgressIPAMSpecPtrOutput)
}

// CIDRAssignments is a set of CIDRs. Namespaces will receive one available IP from each of this CIDRs.
func (o EgressIPAMSpecOutput) CidrAssignments() EgressIPAMSpecCidrAssignmentsArrayOutput {
	return o.ApplyT(func(v EgressIPAMSpec) []EgressIPAMSpecCidrAssignments { return v.CidrAssignments }).(EgressIPAMSpecCidrAssignmentsArrayOutput)
}

// NodeSelector is a selector that allows to subset which nodes will be managed by this EgressIPAM
func (o EgressIPAMSpecOutput) NodeSelector() EgressIPAMSpecNodeSelectorPtrOutput {
	return o.ApplyT(func(v EgressIPAMSpec) *EgressIPAMSpecNodeSelector { return v.NodeSelector }).(EgressIPAMSpecNodeSelectorPtrOutput)
}

// TopologyLabel is the label that needs to identified nodes that will carry egressIPs in the CIDRAssignments. Each label value should map to a CIDR in the CIDRAssignments.
func (o EgressIPAMSpecOutput) TopologyLabel() pulumi.StringOutput {
	return o.ApplyT(func(v EgressIPAMSpec) string { return v.TopologyLabel }).(pulumi.StringOutput)
}

type EgressIPAMSpecPtrOutput struct{ *pulumi.OutputState }

func (EgressIPAMSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**EgressIPAMSpec)(nil)).Elem()
}

func (o EgressIPAMSpecPtrOutput) ToEgressIPAMSpecPtrOutput() EgressIPAMSpecPtrOutput {
	return o
}

func (o EgressIPAMSpecPtrOutput) ToEgressIPAMSpecPtrOutputWithContext(ctx context.Context) EgressIPAMSpecPtrOutput {
	return o
}

func (o EgressIPAMSpecPtrOutput) Elem() EgressIPAMSpecOutput {
	return o.ApplyT(func(v *EgressIPAMSpec) EgressIPAMSpec { return *v }).(EgressIPAMSpecOutput)
}

// CIDRAssignments is a set of CIDRs. Namespaces will receive one available IP from each of this CIDRs.
func (o EgressIPAMSpecPtrOutput) CidrAssignments() EgressIPAMSpecCidrAssignmentsArrayOutput {
	return o.ApplyT(func(v *EgressIPAMSpec) []EgressIPAMSpecCidrAssignments {
		if v == nil {
			return nil
		}
		return v.CidrAssignments
	}).(EgressIPAMSpecCidrAssignmentsArrayOutput)
}

// NodeSelector is a selector that allows to subset which nodes will be managed by this EgressIPAM
func (o EgressIPAMSpecPtrOutput) NodeSelector() EgressIPAMSpecNodeSelectorPtrOutput {
	return o.ApplyT(func(v *EgressIPAMSpec) *EgressIPAMSpecNodeSelector {
		if v == nil {
			return nil
		}
		return v.NodeSelector
	}).(EgressIPAMSpecNodeSelectorPtrOutput)
}

// TopologyLabel is the label that needs to identified nodes that will carry egressIPs in the CIDRAssignments. Each label value should map to a CIDR in the CIDRAssignments.
func (o EgressIPAMSpecPtrOutput) TopologyLabel() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *EgressIPAMSpec) *string {
		if v == nil {
			return nil
		}
		return &v.TopologyLabel
	}).(pulumi.StringPtrOutput)
}

type EgressIPAMSpecCidrAssignments struct {
	// kubebuilder:validation:Pattern=^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(/(3[0-2]|2[0-9]|1[0-9]|[0-9]))?$ CIDR a CIDR. IPs in this CIDR will be added to the nodes selected by the topology label and value. These IPs must be routable when attached to the selected nodes
	CIDR string `pulumi:"CIDR"`
	// LabelValue the label value, which together with the TopologyLabel select the nodes that will carry the IPs from this CIDR
	LabelValue string `pulumi:"labelValue"`
	// This does not work kubebuilder:validation:Pattern=`^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$` ReservedIPs a set of IPs in the CIDR that are reserved for other purposes and cannot be assigned.
	ReservedIPs []string `pulumi:"reservedIPs"`
}

// EgressIPAMSpecCidrAssignmentsInput is an input type that accepts EgressIPAMSpecCidrAssignmentsArgs and EgressIPAMSpecCidrAssignmentsOutput values.
// You can construct a concrete instance of `EgressIPAMSpecCidrAssignmentsInput` via:
//
//          EgressIPAMSpecCidrAssignmentsArgs{...}
type EgressIPAMSpecCidrAssignmentsInput interface {
	pulumi.Input

	ToEgressIPAMSpecCidrAssignmentsOutput() EgressIPAMSpecCidrAssignmentsOutput
	ToEgressIPAMSpecCidrAssignmentsOutputWithContext(context.Context) EgressIPAMSpecCidrAssignmentsOutput
}

type EgressIPAMSpecCidrAssignmentsArgs struct {
	// kubebuilder:validation:Pattern=^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(/(3[0-2]|2[0-9]|1[0-9]|[0-9]))?$ CIDR a CIDR. IPs in this CIDR will be added to the nodes selected by the topology label and value. These IPs must be routable when attached to the selected nodes
	CIDR pulumi.StringInput `pulumi:"CIDR"`
	// LabelValue the label value, which together with the TopologyLabel select the nodes that will carry the IPs from this CIDR
	LabelValue pulumi.StringInput `pulumi:"labelValue"`
	// This does not work kubebuilder:validation:Pattern=`^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$` ReservedIPs a set of IPs in the CIDR that are reserved for other purposes and cannot be assigned.
	ReservedIPs pulumi.StringArrayInput `pulumi:"reservedIPs"`
}

func (EgressIPAMSpecCidrAssignmentsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*EgressIPAMSpecCidrAssignments)(nil)).Elem()
}

func (i EgressIPAMSpecCidrAssignmentsArgs) ToEgressIPAMSpecCidrAssignmentsOutput() EgressIPAMSpecCidrAssignmentsOutput {
	return i.ToEgressIPAMSpecCidrAssignmentsOutputWithContext(context.Background())
}

func (i EgressIPAMSpecCidrAssignmentsArgs) ToEgressIPAMSpecCidrAssignmentsOutputWithContext(ctx context.Context) EgressIPAMSpecCidrAssignmentsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EgressIPAMSpecCidrAssignmentsOutput)
}

// EgressIPAMSpecCidrAssignmentsArrayInput is an input type that accepts EgressIPAMSpecCidrAssignmentsArray and EgressIPAMSpecCidrAssignmentsArrayOutput values.
// You can construct a concrete instance of `EgressIPAMSpecCidrAssignmentsArrayInput` via:
//
//          EgressIPAMSpecCidrAssignmentsArray{ EgressIPAMSpecCidrAssignmentsArgs{...} }
type EgressIPAMSpecCidrAssignmentsArrayInput interface {
	pulumi.Input

	ToEgressIPAMSpecCidrAssignmentsArrayOutput() EgressIPAMSpecCidrAssignmentsArrayOutput
	ToEgressIPAMSpecCidrAssignmentsArrayOutputWithContext(context.Context) EgressIPAMSpecCidrAssignmentsArrayOutput
}

type EgressIPAMSpecCidrAssignmentsArray []EgressIPAMSpecCidrAssignmentsInput

func (EgressIPAMSpecCidrAssignmentsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]EgressIPAMSpecCidrAssignments)(nil)).Elem()
}

func (i EgressIPAMSpecCidrAssignmentsArray) ToEgressIPAMSpecCidrAssignmentsArrayOutput() EgressIPAMSpecCidrAssignmentsArrayOutput {
	return i.ToEgressIPAMSpecCidrAssignmentsArrayOutputWithContext(context.Background())
}

func (i EgressIPAMSpecCidrAssignmentsArray) ToEgressIPAMSpecCidrAssignmentsArrayOutputWithContext(ctx context.Context) EgressIPAMSpecCidrAssignmentsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EgressIPAMSpecCidrAssignmentsArrayOutput)
}

type EgressIPAMSpecCidrAssignmentsOutput struct{ *pulumi.OutputState }

func (EgressIPAMSpecCidrAssignmentsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EgressIPAMSpecCidrAssignments)(nil)).Elem()
}

func (o EgressIPAMSpecCidrAssignmentsOutput) ToEgressIPAMSpecCidrAssignmentsOutput() EgressIPAMSpecCidrAssignmentsOutput {
	return o
}

func (o EgressIPAMSpecCidrAssignmentsOutput) ToEgressIPAMSpecCidrAssignmentsOutputWithContext(ctx context.Context) EgressIPAMSpecCidrAssignmentsOutput {
	return o
}

// kubebuilder:validation:Pattern=^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(/(3[0-2]|2[0-9]|1[0-9]|[0-9]))?$ CIDR a CIDR. IPs in this CIDR will be added to the nodes selected by the topology label and value. These IPs must be routable when attached to the selected nodes
func (o EgressIPAMSpecCidrAssignmentsOutput) CIDR() pulumi.StringOutput {
	return o.ApplyT(func(v EgressIPAMSpecCidrAssignments) string { return v.CIDR }).(pulumi.StringOutput)
}

// LabelValue the label value, which together with the TopologyLabel select the nodes that will carry the IPs from this CIDR
func (o EgressIPAMSpecCidrAssignmentsOutput) LabelValue() pulumi.StringOutput {
	return o.ApplyT(func(v EgressIPAMSpecCidrAssignments) string { return v.LabelValue }).(pulumi.StringOutput)
}

// This does not work kubebuilder:validation:Pattern=`^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$` ReservedIPs a set of IPs in the CIDR that are reserved for other purposes and cannot be assigned.
func (o EgressIPAMSpecCidrAssignmentsOutput) ReservedIPs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v EgressIPAMSpecCidrAssignments) []string { return v.ReservedIPs }).(pulumi.StringArrayOutput)
}

type EgressIPAMSpecCidrAssignmentsArrayOutput struct{ *pulumi.OutputState }

func (EgressIPAMSpecCidrAssignmentsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]EgressIPAMSpecCidrAssignments)(nil)).Elem()
}

func (o EgressIPAMSpecCidrAssignmentsArrayOutput) ToEgressIPAMSpecCidrAssignmentsArrayOutput() EgressIPAMSpecCidrAssignmentsArrayOutput {
	return o
}

func (o EgressIPAMSpecCidrAssignmentsArrayOutput) ToEgressIPAMSpecCidrAssignmentsArrayOutputWithContext(ctx context.Context) EgressIPAMSpecCidrAssignmentsArrayOutput {
	return o
}

func (o EgressIPAMSpecCidrAssignmentsArrayOutput) Index(i pulumi.IntInput) EgressIPAMSpecCidrAssignmentsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) EgressIPAMSpecCidrAssignments {
		return vs[0].([]EgressIPAMSpecCidrAssignments)[vs[1].(int)]
	}).(EgressIPAMSpecCidrAssignmentsOutput)
}

// NodeSelector is a selector that allows to subset which nodes will be managed by this EgressIPAM
type EgressIPAMSpecNodeSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []EgressIPAMSpecNodeSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// EgressIPAMSpecNodeSelectorInput is an input type that accepts EgressIPAMSpecNodeSelectorArgs and EgressIPAMSpecNodeSelectorOutput values.
// You can construct a concrete instance of `EgressIPAMSpecNodeSelectorInput` via:
//
//          EgressIPAMSpecNodeSelectorArgs{...}
type EgressIPAMSpecNodeSelectorInput interface {
	pulumi.Input

	ToEgressIPAMSpecNodeSelectorOutput() EgressIPAMSpecNodeSelectorOutput
	ToEgressIPAMSpecNodeSelectorOutputWithContext(context.Context) EgressIPAMSpecNodeSelectorOutput
}

// NodeSelector is a selector that allows to subset which nodes will be managed by this EgressIPAM
type EgressIPAMSpecNodeSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions EgressIPAMSpecNodeSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (EgressIPAMSpecNodeSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*EgressIPAMSpecNodeSelector)(nil)).Elem()
}

func (i EgressIPAMSpecNodeSelectorArgs) ToEgressIPAMSpecNodeSelectorOutput() EgressIPAMSpecNodeSelectorOutput {
	return i.ToEgressIPAMSpecNodeSelectorOutputWithContext(context.Background())
}

func (i EgressIPAMSpecNodeSelectorArgs) ToEgressIPAMSpecNodeSelectorOutputWithContext(ctx context.Context) EgressIPAMSpecNodeSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EgressIPAMSpecNodeSelectorOutput)
}

func (i EgressIPAMSpecNodeSelectorArgs) ToEgressIPAMSpecNodeSelectorPtrOutput() EgressIPAMSpecNodeSelectorPtrOutput {
	return i.ToEgressIPAMSpecNodeSelectorPtrOutputWithContext(context.Background())
}

func (i EgressIPAMSpecNodeSelectorArgs) ToEgressIPAMSpecNodeSelectorPtrOutputWithContext(ctx context.Context) EgressIPAMSpecNodeSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EgressIPAMSpecNodeSelectorOutput).ToEgressIPAMSpecNodeSelectorPtrOutputWithContext(ctx)
}

// EgressIPAMSpecNodeSelectorPtrInput is an input type that accepts EgressIPAMSpecNodeSelectorArgs, EgressIPAMSpecNodeSelectorPtr and EgressIPAMSpecNodeSelectorPtrOutput values.
// You can construct a concrete instance of `EgressIPAMSpecNodeSelectorPtrInput` via:
//
//          EgressIPAMSpecNodeSelectorArgs{...}
//
//  or:
//
//          nil
type EgressIPAMSpecNodeSelectorPtrInput interface {
	pulumi.Input

	ToEgressIPAMSpecNodeSelectorPtrOutput() EgressIPAMSpecNodeSelectorPtrOutput
	ToEgressIPAMSpecNodeSelectorPtrOutputWithContext(context.Context) EgressIPAMSpecNodeSelectorPtrOutput
}

type egressIPAMSpecNodeSelectorPtrType EgressIPAMSpecNodeSelectorArgs

func EgressIPAMSpecNodeSelectorPtr(v *EgressIPAMSpecNodeSelectorArgs) EgressIPAMSpecNodeSelectorPtrInput {
	return (*egressIPAMSpecNodeSelectorPtrType)(v)
}

func (*egressIPAMSpecNodeSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**EgressIPAMSpecNodeSelector)(nil)).Elem()
}

func (i *egressIPAMSpecNodeSelectorPtrType) ToEgressIPAMSpecNodeSelectorPtrOutput() EgressIPAMSpecNodeSelectorPtrOutput {
	return i.ToEgressIPAMSpecNodeSelectorPtrOutputWithContext(context.Background())
}

func (i *egressIPAMSpecNodeSelectorPtrType) ToEgressIPAMSpecNodeSelectorPtrOutputWithContext(ctx context.Context) EgressIPAMSpecNodeSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EgressIPAMSpecNodeSelectorPtrOutput)
}

// NodeSelector is a selector that allows to subset which nodes will be managed by this EgressIPAM
type EgressIPAMSpecNodeSelectorOutput struct{ *pulumi.OutputState }

func (EgressIPAMSpecNodeSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EgressIPAMSpecNodeSelector)(nil)).Elem()
}

func (o EgressIPAMSpecNodeSelectorOutput) ToEgressIPAMSpecNodeSelectorOutput() EgressIPAMSpecNodeSelectorOutput {
	return o
}

func (o EgressIPAMSpecNodeSelectorOutput) ToEgressIPAMSpecNodeSelectorOutputWithContext(ctx context.Context) EgressIPAMSpecNodeSelectorOutput {
	return o
}

func (o EgressIPAMSpecNodeSelectorOutput) ToEgressIPAMSpecNodeSelectorPtrOutput() EgressIPAMSpecNodeSelectorPtrOutput {
	return o.ToEgressIPAMSpecNodeSelectorPtrOutputWithContext(context.Background())
}

func (o EgressIPAMSpecNodeSelectorOutput) ToEgressIPAMSpecNodeSelectorPtrOutputWithContext(ctx context.Context) EgressIPAMSpecNodeSelectorPtrOutput {
	return o.ApplyT(func(v EgressIPAMSpecNodeSelector) *EgressIPAMSpecNodeSelector {
		return &v
	}).(EgressIPAMSpecNodeSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o EgressIPAMSpecNodeSelectorOutput) MatchExpressions() EgressIPAMSpecNodeSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v EgressIPAMSpecNodeSelector) []EgressIPAMSpecNodeSelectorMatchExpressions {
		return v.MatchExpressions
	}).(EgressIPAMSpecNodeSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o EgressIPAMSpecNodeSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v EgressIPAMSpecNodeSelector) map[string]string { return v.MatchLabels }).(pulumi.StringMapOutput)
}

type EgressIPAMSpecNodeSelectorPtrOutput struct{ *pulumi.OutputState }

func (EgressIPAMSpecNodeSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**EgressIPAMSpecNodeSelector)(nil)).Elem()
}

func (o EgressIPAMSpecNodeSelectorPtrOutput) ToEgressIPAMSpecNodeSelectorPtrOutput() EgressIPAMSpecNodeSelectorPtrOutput {
	return o
}

func (o EgressIPAMSpecNodeSelectorPtrOutput) ToEgressIPAMSpecNodeSelectorPtrOutputWithContext(ctx context.Context) EgressIPAMSpecNodeSelectorPtrOutput {
	return o
}

func (o EgressIPAMSpecNodeSelectorPtrOutput) Elem() EgressIPAMSpecNodeSelectorOutput {
	return o.ApplyT(func(v *EgressIPAMSpecNodeSelector) EgressIPAMSpecNodeSelector { return *v }).(EgressIPAMSpecNodeSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o EgressIPAMSpecNodeSelectorPtrOutput) MatchExpressions() EgressIPAMSpecNodeSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *EgressIPAMSpecNodeSelector) []EgressIPAMSpecNodeSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(EgressIPAMSpecNodeSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o EgressIPAMSpecNodeSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *EgressIPAMSpecNodeSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type EgressIPAMSpecNodeSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// EgressIPAMSpecNodeSelectorMatchExpressionsInput is an input type that accepts EgressIPAMSpecNodeSelectorMatchExpressionsArgs and EgressIPAMSpecNodeSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `EgressIPAMSpecNodeSelectorMatchExpressionsInput` via:
//
//          EgressIPAMSpecNodeSelectorMatchExpressionsArgs{...}
type EgressIPAMSpecNodeSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToEgressIPAMSpecNodeSelectorMatchExpressionsOutput() EgressIPAMSpecNodeSelectorMatchExpressionsOutput
	ToEgressIPAMSpecNodeSelectorMatchExpressionsOutputWithContext(context.Context) EgressIPAMSpecNodeSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type EgressIPAMSpecNodeSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (EgressIPAMSpecNodeSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*EgressIPAMSpecNodeSelectorMatchExpressions)(nil)).Elem()
}

func (i EgressIPAMSpecNodeSelectorMatchExpressionsArgs) ToEgressIPAMSpecNodeSelectorMatchExpressionsOutput() EgressIPAMSpecNodeSelectorMatchExpressionsOutput {
	return i.ToEgressIPAMSpecNodeSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i EgressIPAMSpecNodeSelectorMatchExpressionsArgs) ToEgressIPAMSpecNodeSelectorMatchExpressionsOutputWithContext(ctx context.Context) EgressIPAMSpecNodeSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EgressIPAMSpecNodeSelectorMatchExpressionsOutput)
}

// EgressIPAMSpecNodeSelectorMatchExpressionsArrayInput is an input type that accepts EgressIPAMSpecNodeSelectorMatchExpressionsArray and EgressIPAMSpecNodeSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `EgressIPAMSpecNodeSelectorMatchExpressionsArrayInput` via:
//
//          EgressIPAMSpecNodeSelectorMatchExpressionsArray{ EgressIPAMSpecNodeSelectorMatchExpressionsArgs{...} }
type EgressIPAMSpecNodeSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToEgressIPAMSpecNodeSelectorMatchExpressionsArrayOutput() EgressIPAMSpecNodeSelectorMatchExpressionsArrayOutput
	ToEgressIPAMSpecNodeSelectorMatchExpressionsArrayOutputWithContext(context.Context) EgressIPAMSpecNodeSelectorMatchExpressionsArrayOutput
}

type EgressIPAMSpecNodeSelectorMatchExpressionsArray []EgressIPAMSpecNodeSelectorMatchExpressionsInput

func (EgressIPAMSpecNodeSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]EgressIPAMSpecNodeSelectorMatchExpressions)(nil)).Elem()
}

func (i EgressIPAMSpecNodeSelectorMatchExpressionsArray) ToEgressIPAMSpecNodeSelectorMatchExpressionsArrayOutput() EgressIPAMSpecNodeSelectorMatchExpressionsArrayOutput {
	return i.ToEgressIPAMSpecNodeSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i EgressIPAMSpecNodeSelectorMatchExpressionsArray) ToEgressIPAMSpecNodeSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) EgressIPAMSpecNodeSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EgressIPAMSpecNodeSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type EgressIPAMSpecNodeSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (EgressIPAMSpecNodeSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EgressIPAMSpecNodeSelectorMatchExpressions)(nil)).Elem()
}

func (o EgressIPAMSpecNodeSelectorMatchExpressionsOutput) ToEgressIPAMSpecNodeSelectorMatchExpressionsOutput() EgressIPAMSpecNodeSelectorMatchExpressionsOutput {
	return o
}

func (o EgressIPAMSpecNodeSelectorMatchExpressionsOutput) ToEgressIPAMSpecNodeSelectorMatchExpressionsOutputWithContext(ctx context.Context) EgressIPAMSpecNodeSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o EgressIPAMSpecNodeSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v EgressIPAMSpecNodeSelectorMatchExpressions) string { return v.Key }).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
func (o EgressIPAMSpecNodeSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v EgressIPAMSpecNodeSelectorMatchExpressions) string { return v.Operator }).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
func (o EgressIPAMSpecNodeSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v EgressIPAMSpecNodeSelectorMatchExpressions) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type EgressIPAMSpecNodeSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (EgressIPAMSpecNodeSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]EgressIPAMSpecNodeSelectorMatchExpressions)(nil)).Elem()
}

func (o EgressIPAMSpecNodeSelectorMatchExpressionsArrayOutput) ToEgressIPAMSpecNodeSelectorMatchExpressionsArrayOutput() EgressIPAMSpecNodeSelectorMatchExpressionsArrayOutput {
	return o
}

func (o EgressIPAMSpecNodeSelectorMatchExpressionsArrayOutput) ToEgressIPAMSpecNodeSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) EgressIPAMSpecNodeSelectorMatchExpressionsArrayOutput {
	return o
}

func (o EgressIPAMSpecNodeSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) EgressIPAMSpecNodeSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) EgressIPAMSpecNodeSelectorMatchExpressions {
		return vs[0].([]EgressIPAMSpecNodeSelectorMatchExpressions)[vs[1].(int)]
	}).(EgressIPAMSpecNodeSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type EgressIPAMSpecNodeSelectorMatchLabels struct {
}

// EgressIPAMSpecNodeSelectorMatchLabelsInput is an input type that accepts EgressIPAMSpecNodeSelectorMatchLabelsArgs and EgressIPAMSpecNodeSelectorMatchLabelsOutput values.
// You can construct a concrete instance of `EgressIPAMSpecNodeSelectorMatchLabelsInput` via:
//
//          EgressIPAMSpecNodeSelectorMatchLabelsArgs{...}
type EgressIPAMSpecNodeSelectorMatchLabelsInput interface {
	pulumi.Input

	ToEgressIPAMSpecNodeSelectorMatchLabelsOutput() EgressIPAMSpecNodeSelectorMatchLabelsOutput
	ToEgressIPAMSpecNodeSelectorMatchLabelsOutputWithContext(context.Context) EgressIPAMSpecNodeSelectorMatchLabelsOutput
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type EgressIPAMSpecNodeSelectorMatchLabelsArgs struct {
}

func (EgressIPAMSpecNodeSelectorMatchLabelsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*EgressIPAMSpecNodeSelectorMatchLabels)(nil)).Elem()
}

func (i EgressIPAMSpecNodeSelectorMatchLabelsArgs) ToEgressIPAMSpecNodeSelectorMatchLabelsOutput() EgressIPAMSpecNodeSelectorMatchLabelsOutput {
	return i.ToEgressIPAMSpecNodeSelectorMatchLabelsOutputWithContext(context.Background())
}

func (i EgressIPAMSpecNodeSelectorMatchLabelsArgs) ToEgressIPAMSpecNodeSelectorMatchLabelsOutputWithContext(ctx context.Context) EgressIPAMSpecNodeSelectorMatchLabelsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EgressIPAMSpecNodeSelectorMatchLabelsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type EgressIPAMSpecNodeSelectorMatchLabelsOutput struct{ *pulumi.OutputState }

func (EgressIPAMSpecNodeSelectorMatchLabelsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EgressIPAMSpecNodeSelectorMatchLabels)(nil)).Elem()
}

func (o EgressIPAMSpecNodeSelectorMatchLabelsOutput) ToEgressIPAMSpecNodeSelectorMatchLabelsOutput() EgressIPAMSpecNodeSelectorMatchLabelsOutput {
	return o
}

func (o EgressIPAMSpecNodeSelectorMatchLabelsOutput) ToEgressIPAMSpecNodeSelectorMatchLabelsOutputWithContext(ctx context.Context) EgressIPAMSpecNodeSelectorMatchLabelsOutput {
	return o
}

// EgressIPAMStatus defines the observed state of EgressIPAM
type EgressIPAMStatus struct {
	LastUpdate *string `pulumi:"lastUpdate"`
	Reason     *string `pulumi:"reason"`
	Status     *string `pulumi:"status"`
}

// EgressIPAMStatusInput is an input type that accepts EgressIPAMStatusArgs and EgressIPAMStatusOutput values.
// You can construct a concrete instance of `EgressIPAMStatusInput` via:
//
//          EgressIPAMStatusArgs{...}
type EgressIPAMStatusInput interface {
	pulumi.Input

	ToEgressIPAMStatusOutput() EgressIPAMStatusOutput
	ToEgressIPAMStatusOutputWithContext(context.Context) EgressIPAMStatusOutput
}

// EgressIPAMStatus defines the observed state of EgressIPAM
type EgressIPAMStatusArgs struct {
	LastUpdate pulumi.StringPtrInput `pulumi:"lastUpdate"`
	Reason     pulumi.StringPtrInput `pulumi:"reason"`
	Status     pulumi.StringPtrInput `pulumi:"status"`
}

func (EgressIPAMStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*EgressIPAMStatus)(nil)).Elem()
}

func (i EgressIPAMStatusArgs) ToEgressIPAMStatusOutput() EgressIPAMStatusOutput {
	return i.ToEgressIPAMStatusOutputWithContext(context.Background())
}

func (i EgressIPAMStatusArgs) ToEgressIPAMStatusOutputWithContext(ctx context.Context) EgressIPAMStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EgressIPAMStatusOutput)
}

func (i EgressIPAMStatusArgs) ToEgressIPAMStatusPtrOutput() EgressIPAMStatusPtrOutput {
	return i.ToEgressIPAMStatusPtrOutputWithContext(context.Background())
}

func (i EgressIPAMStatusArgs) ToEgressIPAMStatusPtrOutputWithContext(ctx context.Context) EgressIPAMStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EgressIPAMStatusOutput).ToEgressIPAMStatusPtrOutputWithContext(ctx)
}

// EgressIPAMStatusPtrInput is an input type that accepts EgressIPAMStatusArgs, EgressIPAMStatusPtr and EgressIPAMStatusPtrOutput values.
// You can construct a concrete instance of `EgressIPAMStatusPtrInput` via:
//
//          EgressIPAMStatusArgs{...}
//
//  or:
//
//          nil
type EgressIPAMStatusPtrInput interface {
	pulumi.Input

	ToEgressIPAMStatusPtrOutput() EgressIPAMStatusPtrOutput
	ToEgressIPAMStatusPtrOutputWithContext(context.Context) EgressIPAMStatusPtrOutput
}

type egressIPAMStatusPtrType EgressIPAMStatusArgs

func EgressIPAMStatusPtr(v *EgressIPAMStatusArgs) EgressIPAMStatusPtrInput {
	return (*egressIPAMStatusPtrType)(v)
}

func (*egressIPAMStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**EgressIPAMStatus)(nil)).Elem()
}

func (i *egressIPAMStatusPtrType) ToEgressIPAMStatusPtrOutput() EgressIPAMStatusPtrOutput {
	return i.ToEgressIPAMStatusPtrOutputWithContext(context.Background())
}

func (i *egressIPAMStatusPtrType) ToEgressIPAMStatusPtrOutputWithContext(ctx context.Context) EgressIPAMStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EgressIPAMStatusPtrOutput)
}

// EgressIPAMStatus defines the observed state of EgressIPAM
type EgressIPAMStatusOutput struct{ *pulumi.OutputState }

func (EgressIPAMStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*EgressIPAMStatus)(nil)).Elem()
}

func (o EgressIPAMStatusOutput) ToEgressIPAMStatusOutput() EgressIPAMStatusOutput {
	return o
}

func (o EgressIPAMStatusOutput) ToEgressIPAMStatusOutputWithContext(ctx context.Context) EgressIPAMStatusOutput {
	return o
}

func (o EgressIPAMStatusOutput) ToEgressIPAMStatusPtrOutput() EgressIPAMStatusPtrOutput {
	return o.ToEgressIPAMStatusPtrOutputWithContext(context.Background())
}

func (o EgressIPAMStatusOutput) ToEgressIPAMStatusPtrOutputWithContext(ctx context.Context) EgressIPAMStatusPtrOutput {
	return o.ApplyT(func(v EgressIPAMStatus) *EgressIPAMStatus {
		return &v
	}).(EgressIPAMStatusPtrOutput)
}
func (o EgressIPAMStatusOutput) LastUpdate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EgressIPAMStatus) *string { return v.LastUpdate }).(pulumi.StringPtrOutput)
}

func (o EgressIPAMStatusOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EgressIPAMStatus) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

func (o EgressIPAMStatusOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v EgressIPAMStatus) *string { return v.Status }).(pulumi.StringPtrOutput)
}

type EgressIPAMStatusPtrOutput struct{ *pulumi.OutputState }

func (EgressIPAMStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**EgressIPAMStatus)(nil)).Elem()
}

func (o EgressIPAMStatusPtrOutput) ToEgressIPAMStatusPtrOutput() EgressIPAMStatusPtrOutput {
	return o
}

func (o EgressIPAMStatusPtrOutput) ToEgressIPAMStatusPtrOutputWithContext(ctx context.Context) EgressIPAMStatusPtrOutput {
	return o
}

func (o EgressIPAMStatusPtrOutput) Elem() EgressIPAMStatusOutput {
	return o.ApplyT(func(v *EgressIPAMStatus) EgressIPAMStatus { return *v }).(EgressIPAMStatusOutput)
}

func (o EgressIPAMStatusPtrOutput) LastUpdate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *EgressIPAMStatus) *string {
		if v == nil {
			return nil
		}
		return v.LastUpdate
	}).(pulumi.StringPtrOutput)
}

func (o EgressIPAMStatusPtrOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *EgressIPAMStatus) *string {
		if v == nil {
			return nil
		}
		return v.Reason
	}).(pulumi.StringPtrOutput)
}

func (o EgressIPAMStatusPtrOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *EgressIPAMStatus) *string {
		if v == nil {
			return nil
		}
		return v.Status
	}).(pulumi.StringPtrOutput)
}

func init() {
	pulumi.RegisterOutputType(EgressIPAMTypeOutput{})
	pulumi.RegisterOutputType(EgressIPAMMetadataOutput{})
	pulumi.RegisterOutputType(EgressIPAMSpecOutput{})
	pulumi.RegisterOutputType(EgressIPAMSpecPtrOutput{})
	pulumi.RegisterOutputType(EgressIPAMSpecCidrAssignmentsOutput{})
	pulumi.RegisterOutputType(EgressIPAMSpecCidrAssignmentsArrayOutput{})
	pulumi.RegisterOutputType(EgressIPAMSpecNodeSelectorOutput{})
	pulumi.RegisterOutputType(EgressIPAMSpecNodeSelectorPtrOutput{})
	pulumi.RegisterOutputType(EgressIPAMSpecNodeSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(EgressIPAMSpecNodeSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(EgressIPAMSpecNodeSelectorMatchLabelsOutput{})
	pulumi.RegisterOutputType(EgressIPAMStatusOutput{})
	pulumi.RegisterOutputType(EgressIPAMStatusPtrOutput{})
}
