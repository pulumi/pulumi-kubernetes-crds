# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from ... import _utilities, _tables

__all__ = [
    'EgressIPAMSpecArgs',
    'EgressIPAMSpecCidrAssignmentsArgs',
    'EgressIPAMSpecNodeSelectorArgs',
    'EgressIPAMSpecNodeSelectorMatchExpressionsArgs',
    'EgressIPAMStatusArgs',
]

@pulumi.input_type
class EgressIPAMSpecArgs:
    def __init__(__self__, *,
                 topology_label: pulumi.Input[str],
                 cidr_assignments: Optional[pulumi.Input[Sequence[pulumi.Input['EgressIPAMSpecCidrAssignmentsArgs']]]] = None,
                 node_selector: Optional[pulumi.Input['EgressIPAMSpecNodeSelectorArgs']] = None):
        """
        EgressIPAMSpec defines the desired state of EgressIPAM
        :param pulumi.Input[str] topology_label: TopologyLabel is the label that needs to identified nodes that will carry egressIPs in the CIDRAssignments. Each label value should map to a CIDR in the CIDRAssignments.
        :param pulumi.Input[Sequence[pulumi.Input['EgressIPAMSpecCidrAssignmentsArgs']]] cidr_assignments: CIDRAssignments is a set of CIDRs. Namespaces will receive one available IP from each of this CIDRs.
        :param pulumi.Input['EgressIPAMSpecNodeSelectorArgs'] node_selector: NodeSelector is a selector that allows to subset which nodes will be managed by this EgressIPAM
        """
        pulumi.set(__self__, "topology_label", topology_label)
        if cidr_assignments is not None:
            pulumi.set(__self__, "cidr_assignments", cidr_assignments)
        if node_selector is not None:
            pulumi.set(__self__, "node_selector", node_selector)

    @property
    @pulumi.getter(name="topologyLabel")
    def topology_label(self) -> pulumi.Input[str]:
        """
        TopologyLabel is the label that needs to identified nodes that will carry egressIPs in the CIDRAssignments. Each label value should map to a CIDR in the CIDRAssignments.
        """
        return pulumi.get(self, "topology_label")

    @topology_label.setter
    def topology_label(self, value: pulumi.Input[str]):
        pulumi.set(self, "topology_label", value)

    @property
    @pulumi.getter(name="cidrAssignments")
    def cidr_assignments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EgressIPAMSpecCidrAssignmentsArgs']]]]:
        """
        CIDRAssignments is a set of CIDRs. Namespaces will receive one available IP from each of this CIDRs.
        """
        return pulumi.get(self, "cidr_assignments")

    @cidr_assignments.setter
    def cidr_assignments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EgressIPAMSpecCidrAssignmentsArgs']]]]):
        pulumi.set(self, "cidr_assignments", value)

    @property
    @pulumi.getter(name="nodeSelector")
    def node_selector(self) -> Optional[pulumi.Input['EgressIPAMSpecNodeSelectorArgs']]:
        """
        NodeSelector is a selector that allows to subset which nodes will be managed by this EgressIPAM
        """
        return pulumi.get(self, "node_selector")

    @node_selector.setter
    def node_selector(self, value: Optional[pulumi.Input['EgressIPAMSpecNodeSelectorArgs']]):
        pulumi.set(self, "node_selector", value)


@pulumi.input_type
class EgressIPAMSpecCidrAssignmentsArgs:
    def __init__(__self__, *,
                 cidr: pulumi.Input[str],
                 label_value: pulumi.Input[str],
                 reserved_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] cidr: kubebuilder:validation:Pattern=^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(/(3[0-2]|2[0-9]|1[0-9]|[0-9]))?$ CIDR a CIDR. IPs in this CIDR will be added to the nodes selected by the topology label and value. These IPs must be routable when attached to the selected nodes
        :param pulumi.Input[str] label_value: LabelValue the label value, which together with the TopologyLabel select the nodes that will carry the IPs from this CIDR
        :param pulumi.Input[Sequence[pulumi.Input[str]]] reserved_ips: This does not work kubebuilder:validation:Pattern=`^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$` ReservedIPs a set of IPs in the CIDR that are reserved for other purposes and cannot be assigned.
        """
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "label_value", label_value)
        if reserved_ips is not None:
            pulumi.set(__self__, "reserved_ips", reserved_ips)

    @property
    @pulumi.getter(name="CIDR")
    def cidr(self) -> pulumi.Input[str]:
        """
        kubebuilder:validation:Pattern=^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(/(3[0-2]|2[0-9]|1[0-9]|[0-9]))?$ CIDR a CIDR. IPs in this CIDR will be added to the nodes selected by the topology label and value. These IPs must be routable when attached to the selected nodes
        """
        return pulumi.get(self, "cidr")

    @cidr.setter
    def cidr(self, value: pulumi.Input[str]):
        pulumi.set(self, "cidr", value)

    @property
    @pulumi.getter(name="labelValue")
    def label_value(self) -> pulumi.Input[str]:
        """
        LabelValue the label value, which together with the TopologyLabel select the nodes that will carry the IPs from this CIDR
        """
        return pulumi.get(self, "label_value")

    @label_value.setter
    def label_value(self, value: pulumi.Input[str]):
        pulumi.set(self, "label_value", value)

    @property
    @pulumi.getter(name="reservedIPs")
    def reserved_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        This does not work kubebuilder:validation:Pattern=`^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$` ReservedIPs a set of IPs in the CIDR that are reserved for other purposes and cannot be assigned.
        """
        return pulumi.get(self, "reserved_ips")

    @reserved_ips.setter
    def reserved_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "reserved_ips", value)


@pulumi.input_type
class EgressIPAMSpecNodeSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['EgressIPAMSpecNodeSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        NodeSelector is a selector that allows to subset which nodes will be managed by this EgressIPAM
        :param pulumi.Input[Sequence[pulumi.Input['EgressIPAMSpecNodeSelectorMatchExpressionsArgs']]] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EgressIPAMSpecNodeSelectorMatchExpressionsArgs']]]]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EgressIPAMSpecNodeSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class EgressIPAMSpecNodeSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param pulumi.Input[str] key: key is the label key that the selector applies to.
        :param pulumi.Input[str] operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class EgressIPAMStatusArgs:
    def __init__(__self__, *,
                 last_update: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None):
        """
        EgressIPAMStatus defines the observed state of EgressIPAM
        """
        if last_update is not None:
            pulumi.set(__self__, "last_update", last_update)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="lastUpdate")
    def last_update(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "last_update")

    @last_update.setter
    def last_update(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_update", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


