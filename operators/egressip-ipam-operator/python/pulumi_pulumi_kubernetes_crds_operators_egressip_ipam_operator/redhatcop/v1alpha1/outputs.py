# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from ... import _utilities, _tables
from . import outputs

__all__ = [
    'EgressIPAMSpec',
    'EgressIPAMSpecCidrAssignments',
    'EgressIPAMSpecNodeSelector',
    'EgressIPAMSpecNodeSelectorMatchExpressions',
    'EgressIPAMStatus',
]

@pulumi.output_type
class EgressIPAMSpec(dict):
    """
    EgressIPAMSpec defines the desired state of EgressIPAM
    """
    def __init__(__self__, *,
                 topology_label: str,
                 cidr_assignments: Optional[Sequence['outputs.EgressIPAMSpecCidrAssignments']] = None,
                 node_selector: Optional['outputs.EgressIPAMSpecNodeSelector'] = None):
        """
        EgressIPAMSpec defines the desired state of EgressIPAM
        :param str topology_label: TopologyLabel is the label that needs to identified nodes that will carry egressIPs in the CIDRAssignments. Each label value should map to a CIDR in the CIDRAssignments.
        :param Sequence['EgressIPAMSpecCidrAssignmentsArgs'] cidr_assignments: CIDRAssignments is a set of CIDRs. Namespaces will receive one available IP from each of this CIDRs.
        :param 'EgressIPAMSpecNodeSelectorArgs' node_selector: NodeSelector is a selector that allows to subset which nodes will be managed by this EgressIPAM
        """
        pulumi.set(__self__, "topology_label", topology_label)
        if cidr_assignments is not None:
            pulumi.set(__self__, "cidr_assignments", cidr_assignments)
        if node_selector is not None:
            pulumi.set(__self__, "node_selector", node_selector)

    @property
    @pulumi.getter(name="topologyLabel")
    def topology_label(self) -> str:
        """
        TopologyLabel is the label that needs to identified nodes that will carry egressIPs in the CIDRAssignments. Each label value should map to a CIDR in the CIDRAssignments.
        """
        return pulumi.get(self, "topology_label")

    @property
    @pulumi.getter(name="cidrAssignments")
    def cidr_assignments(self) -> Optional[Sequence['outputs.EgressIPAMSpecCidrAssignments']]:
        """
        CIDRAssignments is a set of CIDRs. Namespaces will receive one available IP from each of this CIDRs.
        """
        return pulumi.get(self, "cidr_assignments")

    @property
    @pulumi.getter(name="nodeSelector")
    def node_selector(self) -> Optional['outputs.EgressIPAMSpecNodeSelector']:
        """
        NodeSelector is a selector that allows to subset which nodes will be managed by this EgressIPAM
        """
        return pulumi.get(self, "node_selector")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class EgressIPAMSpecCidrAssignments(dict):
    def __init__(__self__, *,
                 cidr: str,
                 label_value: str,
                 reserved_ips: Optional[Sequence[str]] = None):
        """
        :param str cidr: kubebuilder:validation:Pattern=^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(/(3[0-2]|2[0-9]|1[0-9]|[0-9]))?$ CIDR a CIDR. IPs in this CIDR will be added to the nodes selected by the topology label and value. These IPs must be routable when attached to the selected nodes
        :param str label_value: LabelValue the label value, which together with the TopologyLabel select the nodes that will carry the IPs from this CIDR
        :param Sequence[str] reserved_ips: This does not work kubebuilder:validation:Pattern=`^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$` ReservedIPs a set of IPs in the CIDR that are reserved for other purposes and cannot be assigned.
        """
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "label_value", label_value)
        if reserved_ips is not None:
            pulumi.set(__self__, "reserved_ips", reserved_ips)

    @property
    @pulumi.getter(name="CIDR")
    def cidr(self) -> str:
        """
        kubebuilder:validation:Pattern=^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(/(3[0-2]|2[0-9]|1[0-9]|[0-9]))?$ CIDR a CIDR. IPs in this CIDR will be added to the nodes selected by the topology label and value. These IPs must be routable when attached to the selected nodes
        """
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter(name="labelValue")
    def label_value(self) -> str:
        """
        LabelValue the label value, which together with the TopologyLabel select the nodes that will carry the IPs from this CIDR
        """
        return pulumi.get(self, "label_value")

    @property
    @pulumi.getter(name="reservedIPs")
    def reserved_ips(self) -> Optional[Sequence[str]]:
        """
        This does not work kubebuilder:validation:Pattern=`^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$` ReservedIPs a set of IPs in the CIDR that are reserved for other purposes and cannot be assigned.
        """
        return pulumi.get(self, "reserved_ips")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class EgressIPAMSpecNodeSelector(dict):
    """
    NodeSelector is a selector that allows to subset which nodes will be managed by this EgressIPAM
    """
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.EgressIPAMSpecNodeSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        NodeSelector is a selector that allows to subset which nodes will be managed by this EgressIPAM
        :param Sequence['EgressIPAMSpecNodeSelectorMatchExpressionsArgs'] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.EgressIPAMSpecNodeSelectorMatchExpressions']]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class EgressIPAMSpecNodeSelectorMatchExpressions(dict):
    """
    A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
    """
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Optional[Sequence[str]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param str key: key is the label key that the selector applies to.
        :param str operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param Sequence[str] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class EgressIPAMStatus(dict):
    """
    EgressIPAMStatus defines the observed state of EgressIPAM
    """
    def __init__(__self__, *,
                 last_update: Optional[str] = None,
                 reason: Optional[str] = None,
                 status: Optional[str] = None):
        """
        EgressIPAMStatus defines the observed state of EgressIPAM
        """
        if last_update is not None:
            pulumi.set(__self__, "last_update", last_update)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="lastUpdate")
    def last_update(self) -> Optional[str]:
        return pulumi.get(self, "last_update")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        return pulumi.get(self, "status")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


