# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from ... import _utilities, _tables
from . import outputs

__all__ = [
    'ApicurioRegistrySpec',
    'ApicurioRegistrySpecConfiguration',
    'ApicurioRegistrySpecConfigurationDataSource',
    'ApicurioRegistrySpecConfigurationInfinispan',
    'ApicurioRegistrySpecConfigurationKafka',
    'ApicurioRegistrySpecConfigurationStreams',
    'ApicurioRegistrySpecConfigurationStreamsSecurity',
    'ApicurioRegistrySpecConfigurationStreamsSecurityScram',
    'ApicurioRegistrySpecConfigurationStreamsSecurityTls',
    'ApicurioRegistrySpecConfigurationUi',
    'ApicurioRegistrySpecDeployment',
    'ApicurioRegistrySpecDeploymentAffinity',
    'ApicurioRegistrySpecDeploymentAffinityNodeAffinity',
    'ApicurioRegistrySpecDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'ApicurioRegistrySpecDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference',
    'ApicurioRegistrySpecDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions',
    'ApicurioRegistrySpecDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields',
    'ApicurioRegistrySpecDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'ApicurioRegistrySpecDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms',
    'ApicurioRegistrySpecDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions',
    'ApicurioRegistrySpecDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields',
    'ApicurioRegistrySpecDeploymentAffinityPodAffinity',
    'ApicurioRegistrySpecDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'ApicurioRegistrySpecDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'ApicurioRegistrySpecDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'ApicurioRegistrySpecDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions',
    'ApicurioRegistrySpecDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'ApicurioRegistrySpecDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'ApicurioRegistrySpecDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions',
    'ApicurioRegistrySpecDeploymentAffinityPodAntiAffinity',
    'ApicurioRegistrySpecDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'ApicurioRegistrySpecDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'ApicurioRegistrySpecDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'ApicurioRegistrySpecDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions',
    'ApicurioRegistrySpecDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'ApicurioRegistrySpecDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'ApicurioRegistrySpecDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions',
    'ApicurioRegistrySpecDeploymentTolerations',
    'ApicurioRegistrySpecImage',
    'ApicurioRegistryStatus',
]

@pulumi.output_type
class ApicurioRegistrySpec(dict):
    """
    ApicurioRegistrySpec defines the desired state of ApicurioRegistry
    """
    def __init__(__self__, *,
                 configuration: Optional['outputs.ApicurioRegistrySpecConfiguration'] = None,
                 deployment: Optional['outputs.ApicurioRegistrySpecDeployment'] = None,
                 image: Optional['outputs.ApicurioRegistrySpecImage'] = None):
        """
        ApicurioRegistrySpec defines the desired state of ApicurioRegistry
        """
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if deployment is not None:
            pulumi.set(__self__, "deployment", deployment)
        if image is not None:
            pulumi.set(__self__, "image", image)

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.ApicurioRegistrySpecConfiguration']:
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter
    def deployment(self) -> Optional['outputs.ApicurioRegistrySpecDeployment']:
        return pulumi.get(self, "deployment")

    @property
    @pulumi.getter
    def image(self) -> Optional['outputs.ApicurioRegistrySpecImage']:
        return pulumi.get(self, "image")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ApicurioRegistrySpecConfiguration(dict):
    def __init__(__self__, *,
                 data_source: Optional['outputs.ApicurioRegistrySpecConfigurationDataSource'] = None,
                 infinispan: Optional['outputs.ApicurioRegistrySpecConfigurationInfinispan'] = None,
                 kafka: Optional['outputs.ApicurioRegistrySpecConfigurationKafka'] = None,
                 log_level: Optional[str] = None,
                 persistence: Optional[str] = None,
                 streams: Optional['outputs.ApicurioRegistrySpecConfigurationStreams'] = None,
                 ui: Optional['outputs.ApicurioRegistrySpecConfigurationUi'] = None):
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)
        if infinispan is not None:
            pulumi.set(__self__, "infinispan", infinispan)
        if kafka is not None:
            pulumi.set(__self__, "kafka", kafka)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)
        if persistence is not None:
            pulumi.set(__self__, "persistence", persistence)
        if streams is not None:
            pulumi.set(__self__, "streams", streams)
        if ui is not None:
            pulumi.set(__self__, "ui", ui)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional['outputs.ApicurioRegistrySpecConfigurationDataSource']:
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def infinispan(self) -> Optional['outputs.ApicurioRegistrySpecConfigurationInfinispan']:
        return pulumi.get(self, "infinispan")

    @property
    @pulumi.getter
    def kafka(self) -> Optional['outputs.ApicurioRegistrySpecConfigurationKafka']:
        return pulumi.get(self, "kafka")

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[str]:
        return pulumi.get(self, "log_level")

    @property
    @pulumi.getter
    def persistence(self) -> Optional[str]:
        return pulumi.get(self, "persistence")

    @property
    @pulumi.getter
    def streams(self) -> Optional['outputs.ApicurioRegistrySpecConfigurationStreams']:
        return pulumi.get(self, "streams")

    @property
    @pulumi.getter
    def ui(self) -> Optional['outputs.ApicurioRegistrySpecConfigurationUi']:
        return pulumi.get(self, "ui")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ApicurioRegistrySpecConfigurationDataSource(dict):
    def __init__(__self__, *,
                 password: Optional[str] = None,
                 url: Optional[str] = None,
                 user_name: Optional[str] = None):
        if password is not None:
            pulumi.set(__self__, "password", password)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[str]:
        return pulumi.get(self, "user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ApicurioRegistrySpecConfigurationInfinispan(dict):
    def __init__(__self__, *,
                 cluster_name: Optional[str] = None):
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[str]:
        return pulumi.get(self, "cluster_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ApicurioRegistrySpecConfigurationKafka(dict):
    def __init__(__self__, *,
                 bootstrap_servers: Optional[str] = None):
        if bootstrap_servers is not None:
            pulumi.set(__self__, "bootstrap_servers", bootstrap_servers)

    @property
    @pulumi.getter(name="bootstrapServers")
    def bootstrap_servers(self) -> Optional[str]:
        return pulumi.get(self, "bootstrap_servers")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ApicurioRegistrySpecConfigurationStreams(dict):
    def __init__(__self__, *,
                 application_id: Optional[str] = None,
                 application_server_port: Optional[str] = None,
                 bootstrap_servers: Optional[str] = None,
                 security: Optional['outputs.ApicurioRegistrySpecConfigurationStreamsSecurity'] = None):
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if application_server_port is not None:
            pulumi.set(__self__, "application_server_port", application_server_port)
        if bootstrap_servers is not None:
            pulumi.set(__self__, "bootstrap_servers", bootstrap_servers)
        if security is not None:
            pulumi.set(__self__, "security", security)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[str]:
        return pulumi.get(self, "application_id")

    @property
    @pulumi.getter(name="applicationServerPort")
    def application_server_port(self) -> Optional[str]:
        return pulumi.get(self, "application_server_port")

    @property
    @pulumi.getter(name="bootstrapServers")
    def bootstrap_servers(self) -> Optional[str]:
        return pulumi.get(self, "bootstrap_servers")

    @property
    @pulumi.getter
    def security(self) -> Optional['outputs.ApicurioRegistrySpecConfigurationStreamsSecurity']:
        return pulumi.get(self, "security")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ApicurioRegistrySpecConfigurationStreamsSecurity(dict):
    def __init__(__self__, *,
                 scram: Optional['outputs.ApicurioRegistrySpecConfigurationStreamsSecurityScram'] = None,
                 tls: Optional['outputs.ApicurioRegistrySpecConfigurationStreamsSecurityTls'] = None):
        if scram is not None:
            pulumi.set(__self__, "scram", scram)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter
    def scram(self) -> Optional['outputs.ApicurioRegistrySpecConfigurationStreamsSecurityScram']:
        return pulumi.get(self, "scram")

    @property
    @pulumi.getter
    def tls(self) -> Optional['outputs.ApicurioRegistrySpecConfigurationStreamsSecurityTls']:
        return pulumi.get(self, "tls")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ApicurioRegistrySpecConfigurationStreamsSecurityScram(dict):
    def __init__(__self__, *,
                 mechanism: Optional[str] = None,
                 password_secret_name: Optional[str] = None,
                 truststore_secret_name: Optional[str] = None,
                 user: Optional[str] = None):
        if mechanism is not None:
            pulumi.set(__self__, "mechanism", mechanism)
        if password_secret_name is not None:
            pulumi.set(__self__, "password_secret_name", password_secret_name)
        if truststore_secret_name is not None:
            pulumi.set(__self__, "truststore_secret_name", truststore_secret_name)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def mechanism(self) -> Optional[str]:
        return pulumi.get(self, "mechanism")

    @property
    @pulumi.getter(name="passwordSecretName")
    def password_secret_name(self) -> Optional[str]:
        return pulumi.get(self, "password_secret_name")

    @property
    @pulumi.getter(name="truststoreSecretName")
    def truststore_secret_name(self) -> Optional[str]:
        return pulumi.get(self, "truststore_secret_name")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        return pulumi.get(self, "user")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ApicurioRegistrySpecConfigurationStreamsSecurityTls(dict):
    def __init__(__self__, *,
                 keystore_secret_name: Optional[str] = None,
                 truststore_secret_name: Optional[str] = None):
        if keystore_secret_name is not None:
            pulumi.set(__self__, "keystore_secret_name", keystore_secret_name)
        if truststore_secret_name is not None:
            pulumi.set(__self__, "truststore_secret_name", truststore_secret_name)

    @property
    @pulumi.getter(name="keystoreSecretName")
    def keystore_secret_name(self) -> Optional[str]:
        return pulumi.get(self, "keystore_secret_name")

    @property
    @pulumi.getter(name="truststoreSecretName")
    def truststore_secret_name(self) -> Optional[str]:
        return pulumi.get(self, "truststore_secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ApicurioRegistrySpecConfigurationUi(dict):
    def __init__(__self__, *,
                 read_only: Optional[bool] = None):
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        return pulumi.get(self, "read_only")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ApicurioRegistrySpecDeployment(dict):
    def __init__(__self__, *,
                 affinity: Optional['outputs.ApicurioRegistrySpecDeploymentAffinity'] = None,
                 host: Optional[str] = None,
                 replicas: Optional[int] = None,
                 tolerations: Optional[Sequence['outputs.ApicurioRegistrySpecDeploymentTolerations']] = None):
        """
        :param 'ApicurioRegistrySpecDeploymentAffinityArgs' affinity: Affinity is a group of affinity scheduling rules.
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)

    @property
    @pulumi.getter
    def affinity(self) -> Optional['outputs.ApicurioRegistrySpecDeploymentAffinity']:
        """
        Affinity is a group of affinity scheduling rules.
        """
        return pulumi.get(self, "affinity")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def replicas(self) -> Optional[int]:
        return pulumi.get(self, "replicas")

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[Sequence['outputs.ApicurioRegistrySpecDeploymentTolerations']]:
        return pulumi.get(self, "tolerations")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ApicurioRegistrySpecDeploymentAffinity(dict):
    """
    Affinity is a group of affinity scheduling rules.
    """
    def __init__(__self__, *,
                 node_affinity: Optional['outputs.ApicurioRegistrySpecDeploymentAffinityNodeAffinity'] = None,
                 pod_affinity: Optional['outputs.ApicurioRegistrySpecDeploymentAffinityPodAffinity'] = None,
                 pod_anti_affinity: Optional['outputs.ApicurioRegistrySpecDeploymentAffinityPodAntiAffinity'] = None):
        """
        Affinity is a group of affinity scheduling rules.
        :param 'ApicurioRegistrySpecDeploymentAffinityNodeAffinityArgs' node_affinity: Describes node affinity scheduling rules for the pod.
        :param 'ApicurioRegistrySpecDeploymentAffinityPodAffinityArgs' pod_affinity: Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
        :param 'ApicurioRegistrySpecDeploymentAffinityPodAntiAffinityArgs' pod_anti_affinity: Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
        """
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional['outputs.ApicurioRegistrySpecDeploymentAffinityNodeAffinity']:
        """
        Describes node affinity scheduling rules for the pod.
        """
        return pulumi.get(self, "node_affinity")

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional['outputs.ApicurioRegistrySpecDeploymentAffinityPodAffinity']:
        """
        Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
        """
        return pulumi.get(self, "pod_affinity")

    @property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional['outputs.ApicurioRegistrySpecDeploymentAffinityPodAntiAffinity']:
        """
        Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
        """
        return pulumi.get(self, "pod_anti_affinity")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ApicurioRegistrySpecDeploymentAffinityNodeAffinity(dict):
    """
    Describes node affinity scheduling rules for the pod.
    """
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.ApicurioRegistrySpecDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional['outputs.ApicurioRegistrySpecDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution'] = None):
        """
        Describes node affinity scheduling rules for the pod.
        :param Sequence['ApicurioRegistrySpecDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs'] preferred_during_scheduling_ignored_during_execution: The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
        :param 'ApicurioRegistrySpecDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs' required_during_scheduling_ignored_during_execution: If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
        """
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.ApicurioRegistrySpecDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        """
        The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
        """
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional['outputs.ApicurioRegistrySpecDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution']:
        """
        If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
        """
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ApicurioRegistrySpecDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    """
    An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
    """
    def __init__(__self__, *,
                 preference: 'outputs.ApicurioRegistrySpecDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference',
                 weight: int):
        """
        An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
        :param 'ApicurioRegistrySpecDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs' preference: A node selector term, associated with the corresponding weight.
        :param int weight: Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
        """
        pulumi.set(__self__, "preference", preference)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preference(self) -> 'outputs.ApicurioRegistrySpecDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference':
        """
        A node selector term, associated with the corresponding weight.
        """
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
        """
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ApicurioRegistrySpecDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(dict):
    """
    A node selector term, associated with the corresponding weight.
    """
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.ApicurioRegistrySpecDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions']] = None,
                 match_fields: Optional[Sequence['outputs.ApicurioRegistrySpecDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields']] = None):
        """
        A node selector term, associated with the corresponding weight.
        :param Sequence['ApicurioRegistrySpecDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs'] match_expressions: A list of node selector requirements by node's labels.
        :param Sequence['ApicurioRegistrySpecDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs'] match_fields: A list of node selector requirements by node's fields.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.ApicurioRegistrySpecDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions']]:
        """
        A list of node selector requirements by node's labels.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.ApicurioRegistrySpecDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields']]:
        """
        A list of node selector requirements by node's fields.
        """
        return pulumi.get(self, "match_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ApicurioRegistrySpecDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(dict):
    """
    A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
    """
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Optional[Sequence[str]] = None):
        """
        A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param str key: The label key that the selector applies to.
        :param str operator: Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        :param Sequence[str] values: An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ApicurioRegistrySpecDeploymentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(dict):
    """
    A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
    """
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Optional[Sequence[str]] = None):
        """
        A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param str key: The label key that the selector applies to.
        :param str operator: Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        :param Sequence[str] values: An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ApicurioRegistrySpecDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    """
    If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
    """
    def __init__(__self__, *,
                 node_selector_terms: Sequence['outputs.ApicurioRegistrySpecDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms']):
        """
        If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
        :param Sequence['ApicurioRegistrySpecDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs'] node_selector_terms: Required. A list of node selector terms. The terms are ORed.
        """
        pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> Sequence['outputs.ApicurioRegistrySpecDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms']:
        """
        Required. A list of node selector terms. The terms are ORed.
        """
        return pulumi.get(self, "node_selector_terms")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ApicurioRegistrySpecDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(dict):
    """
    A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
    """
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.ApicurioRegistrySpecDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions']] = None,
                 match_fields: Optional[Sequence['outputs.ApicurioRegistrySpecDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields']] = None):
        """
        A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
        :param Sequence['ApicurioRegistrySpecDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs'] match_expressions: A list of node selector requirements by node's labels.
        :param Sequence['ApicurioRegistrySpecDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs'] match_fields: A list of node selector requirements by node's fields.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.ApicurioRegistrySpecDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions']]:
        """
        A list of node selector requirements by node's labels.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.ApicurioRegistrySpecDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields']]:
        """
        A list of node selector requirements by node's fields.
        """
        return pulumi.get(self, "match_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ApicurioRegistrySpecDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(dict):
    """
    A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
    """
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Optional[Sequence[str]] = None):
        """
        A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param str key: The label key that the selector applies to.
        :param str operator: Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        :param Sequence[str] values: An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ApicurioRegistrySpecDeploymentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(dict):
    """
    A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
    """
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Optional[Sequence[str]] = None):
        """
        A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param str key: The label key that the selector applies to.
        :param str operator: Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        :param Sequence[str] values: An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ApicurioRegistrySpecDeploymentAffinityPodAffinity(dict):
    """
    Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
    """
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.ApicurioRegistrySpecDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.ApicurioRegistrySpecDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        """
        Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
        :param Sequence['ApicurioRegistrySpecDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs'] preferred_during_scheduling_ignored_during_execution: The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
        :param Sequence['ApicurioRegistrySpecDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs'] required_during_scheduling_ignored_during_execution: If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
        """
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.ApicurioRegistrySpecDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        """
        The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
        """
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.ApicurioRegistrySpecDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        """
        If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
        """
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ApicurioRegistrySpecDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    """
    The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
    """
    def __init__(__self__, *,
                 pod_affinity_term: 'outputs.ApicurioRegistrySpecDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
                 weight: int):
        """
        The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
        :param 'ApicurioRegistrySpecDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs' pod_affinity_term: Required. A pod affinity term, associated with the corresponding weight.
        :param int weight: weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
        """
        pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> 'outputs.ApicurioRegistrySpecDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm':
        """
        Required. A pod affinity term, associated with the corresponding weight.
        """
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
        """
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ApicurioRegistrySpecDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    """
    Required. A pod affinity term, associated with the corresponding weight.
    """
    def __init__(__self__, *,
                 topology_key: str,
                 label_selector: Optional['outputs.ApicurioRegistrySpecDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None):
        """
        Required. A pod affinity term, associated with the corresponding weight.
        :param str topology_key: This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
        :param 'ApicurioRegistrySpecDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs' label_selector: A label query over a set of resources, in this case pods.
        :param Sequence[str] namespaces: namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
        """
        pulumi.set(__self__, "topology_key", topology_key)
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> str:
        """
        This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
        """
        return pulumi.get(self, "topology_key")

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.ApicurioRegistrySpecDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']:
        """
        A label query over a set of resources, in this case pods.
        """
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        """
        namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
        """
        return pulumi.get(self, "namespaces")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ApicurioRegistrySpecDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    """
    A label query over a set of resources, in this case pods.
    """
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.ApicurioRegistrySpecDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        A label query over a set of resources, in this case pods.
        :param Sequence['ApicurioRegistrySpecDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs'] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.ApicurioRegistrySpecDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ApicurioRegistrySpecDeploymentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(dict):
    """
    A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
    """
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Optional[Sequence[str]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param str key: key is the label key that the selector applies to.
        :param str operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param Sequence[str] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ApicurioRegistrySpecDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    """
    Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
    """
    def __init__(__self__, *,
                 topology_key: str,
                 label_selector: Optional['outputs.ApicurioRegistrySpecDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None):
        """
        Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
        :param str topology_key: This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
        :param 'ApicurioRegistrySpecDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs' label_selector: A label query over a set of resources, in this case pods.
        :param Sequence[str] namespaces: namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
        """
        pulumi.set(__self__, "topology_key", topology_key)
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> str:
        """
        This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
        """
        return pulumi.get(self, "topology_key")

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.ApicurioRegistrySpecDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']:
        """
        A label query over a set of resources, in this case pods.
        """
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        """
        namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
        """
        return pulumi.get(self, "namespaces")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ApicurioRegistrySpecDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    """
    A label query over a set of resources, in this case pods.
    """
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.ApicurioRegistrySpecDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        A label query over a set of resources, in this case pods.
        :param Sequence['ApicurioRegistrySpecDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs'] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.ApicurioRegistrySpecDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ApicurioRegistrySpecDeploymentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(dict):
    """
    A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
    """
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Optional[Sequence[str]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param str key: key is the label key that the selector applies to.
        :param str operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param Sequence[str] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ApicurioRegistrySpecDeploymentAffinityPodAntiAffinity(dict):
    """
    Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
    """
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.ApicurioRegistrySpecDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.ApicurioRegistrySpecDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        """
        Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
        :param Sequence['ApicurioRegistrySpecDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs'] preferred_during_scheduling_ignored_during_execution: The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
        :param Sequence['ApicurioRegistrySpecDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs'] required_during_scheduling_ignored_during_execution: If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
        """
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.ApicurioRegistrySpecDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        """
        The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
        """
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.ApicurioRegistrySpecDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        """
        If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
        """
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ApicurioRegistrySpecDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    """
    The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
    """
    def __init__(__self__, *,
                 pod_affinity_term: 'outputs.ApicurioRegistrySpecDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
                 weight: int):
        """
        The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
        :param 'ApicurioRegistrySpecDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs' pod_affinity_term: Required. A pod affinity term, associated with the corresponding weight.
        :param int weight: weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
        """
        pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> 'outputs.ApicurioRegistrySpecDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm':
        """
        Required. A pod affinity term, associated with the corresponding weight.
        """
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
        """
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ApicurioRegistrySpecDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    """
    Required. A pod affinity term, associated with the corresponding weight.
    """
    def __init__(__self__, *,
                 topology_key: str,
                 label_selector: Optional['outputs.ApicurioRegistrySpecDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None):
        """
        Required. A pod affinity term, associated with the corresponding weight.
        :param str topology_key: This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
        :param 'ApicurioRegistrySpecDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs' label_selector: A label query over a set of resources, in this case pods.
        :param Sequence[str] namespaces: namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
        """
        pulumi.set(__self__, "topology_key", topology_key)
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> str:
        """
        This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
        """
        return pulumi.get(self, "topology_key")

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.ApicurioRegistrySpecDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']:
        """
        A label query over a set of resources, in this case pods.
        """
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        """
        namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
        """
        return pulumi.get(self, "namespaces")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ApicurioRegistrySpecDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    """
    A label query over a set of resources, in this case pods.
    """
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.ApicurioRegistrySpecDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        A label query over a set of resources, in this case pods.
        :param Sequence['ApicurioRegistrySpecDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs'] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.ApicurioRegistrySpecDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ApicurioRegistrySpecDeploymentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(dict):
    """
    A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
    """
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Optional[Sequence[str]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param str key: key is the label key that the selector applies to.
        :param str operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param Sequence[str] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ApicurioRegistrySpecDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    """
    Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
    """
    def __init__(__self__, *,
                 topology_key: str,
                 label_selector: Optional['outputs.ApicurioRegistrySpecDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None):
        """
        Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
        :param str topology_key: This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
        :param 'ApicurioRegistrySpecDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs' label_selector: A label query over a set of resources, in this case pods.
        :param Sequence[str] namespaces: namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
        """
        pulumi.set(__self__, "topology_key", topology_key)
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> str:
        """
        This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
        """
        return pulumi.get(self, "topology_key")

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.ApicurioRegistrySpecDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']:
        """
        A label query over a set of resources, in this case pods.
        """
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        """
        namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
        """
        return pulumi.get(self, "namespaces")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ApicurioRegistrySpecDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    """
    A label query over a set of resources, in this case pods.
    """
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.ApicurioRegistrySpecDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        A label query over a set of resources, in this case pods.
        :param Sequence['ApicurioRegistrySpecDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs'] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.ApicurioRegistrySpecDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ApicurioRegistrySpecDeploymentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(dict):
    """
    A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
    """
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Optional[Sequence[str]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param str key: key is the label key that the selector applies to.
        :param str operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param Sequence[str] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ApicurioRegistrySpecDeploymentTolerations(dict):
    """
    The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
    """
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 toleration_seconds: Optional[int] = None,
                 value: Optional[str] = None):
        """
        The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
        :param str effect: Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
        :param str key: Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
        :param str operator: Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
        :param int toleration_seconds: TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
        :param str value: Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
        """
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if toleration_seconds is not None:
            pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        """
        Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> Optional[int]:
        """
        TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
        """
        return pulumi.get(self, "toleration_seconds")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ApicurioRegistrySpecImage(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Registry string `json:"registry,omitempty"` Version  string `json:"version,omitempty"` Override string `json:"override,omitempty"`
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Registry string `json:"registry,omitempty"` Version  string `json:"version,omitempty"` Override string `json:"override,omitempty"`
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ApicurioRegistryStatus(dict):
    """
    ApicurioRegistryStatus defines the observed state of ApicurioRegistry
    """
    def __init__(__self__, *,
                 deployment_name: Optional[str] = None,
                 host: Optional[str] = None,
                 image: Optional[str] = None,
                 ingress_name: Optional[str] = None,
                 replica_count: Optional[int] = None,
                 service_name: Optional[str] = None):
        """
        ApicurioRegistryStatus defines the observed state of ApicurioRegistry
        """
        if deployment_name is not None:
            pulumi.set(__self__, "deployment_name", deployment_name)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if ingress_name is not None:
            pulumi.set(__self__, "ingress_name", ingress_name)
        if replica_count is not None:
            pulumi.set(__self__, "replica_count", replica_count)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter(name="deploymentName")
    def deployment_name(self) -> Optional[str]:
        return pulumi.get(self, "deployment_name")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="ingressName")
    def ingress_name(self) -> Optional[str]:
        return pulumi.get(self, "ingress_name")

    @property
    @pulumi.getter(name="replicaCount")
    def replica_count(self) -> Optional[int]:
        return pulumi.get(self, "replica_count")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[str]:
        return pulumi.get(self, "service_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


