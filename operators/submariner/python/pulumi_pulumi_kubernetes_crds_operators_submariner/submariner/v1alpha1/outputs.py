# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from ... import _utilities, _tables
from . import outputs

__all__ = [
    'SubmarinerSpec',
    'SubmarinerSpecConnectionHealthCheck',
    'SubmarinerStatus',
    'SubmarinerStatusEngineDaemonSetStatus',
    'SubmarinerStatusEngineDaemonSetStatusNonReadyContainerStates',
    'SubmarinerStatusEngineDaemonSetStatusNonReadyContainerStatesRunning',
    'SubmarinerStatusEngineDaemonSetStatusNonReadyContainerStatesTerminated',
    'SubmarinerStatusEngineDaemonSetStatusNonReadyContainerStatesWaiting',
    'SubmarinerStatusEngineDaemonSetStatusStatus',
    'SubmarinerStatusEngineDaemonSetStatusStatusConditions',
    'SubmarinerStatusGateways',
    'SubmarinerStatusGatewaysConnections',
    'SubmarinerStatusGatewaysConnectionsEndpoint',
    'SubmarinerStatusGatewaysConnectionsLatencyRTT',
    'SubmarinerStatusGatewaysLocalEndpoint',
    'SubmarinerStatusGlobalnetDaemonSetStatus',
    'SubmarinerStatusGlobalnetDaemonSetStatusNonReadyContainerStates',
    'SubmarinerStatusGlobalnetDaemonSetStatusNonReadyContainerStatesRunning',
    'SubmarinerStatusGlobalnetDaemonSetStatusNonReadyContainerStatesTerminated',
    'SubmarinerStatusGlobalnetDaemonSetStatusNonReadyContainerStatesWaiting',
    'SubmarinerStatusGlobalnetDaemonSetStatusStatus',
    'SubmarinerStatusGlobalnetDaemonSetStatusStatusConditions',
    'SubmarinerStatusRouteAgentDaemonSetStatus',
    'SubmarinerStatusRouteAgentDaemonSetStatusNonReadyContainerStates',
    'SubmarinerStatusRouteAgentDaemonSetStatusNonReadyContainerStatesRunning',
    'SubmarinerStatusRouteAgentDaemonSetStatusNonReadyContainerStatesTerminated',
    'SubmarinerStatusRouteAgentDaemonSetStatusNonReadyContainerStatesWaiting',
    'SubmarinerStatusRouteAgentDaemonSetStatusStatus',
    'SubmarinerStatusRouteAgentDaemonSetStatusStatusConditions',
]

@pulumi.output_type
class SubmarinerSpec(dict):
    """
    SubmarinerSpec defines the desired state of Submariner
    """
    def __init__(__self__, *,
                 broker: str,
                 broker_k8s_api_server: str,
                 broker_k8s_api_server_token: str,
                 broker_k8s_ca: str,
                 broker_k8s_remote_namespace: str,
                 ce_ip_sec_debug: bool,
                 ce_ip_sec_psk: str,
                 cluster_cidr: str,
                 cluster_id: str,
                 debug: bool,
                 namespace: str,
                 nat_enabled: bool,
                 service_cidr: str,
                 cable_driver: Optional[str] = None,
                 ce_ip_sec_ike_port: Optional[int] = None,
                 ce_ip_sec_natt_port: Optional[int] = None,
                 color_codes: Optional[str] = None,
                 connection_health_check: Optional['outputs.SubmarinerSpecConnectionHealthCheck'] = None,
                 custom_domains: Optional[Sequence[str]] = None,
                 global_cidr: Optional[str] = None,
                 image_overrides: Optional[Mapping[str, str]] = None,
                 repository: Optional[str] = None,
                 service_discovery_enabled: Optional[bool] = None,
                 version: Optional[str] = None):
        """
        SubmarinerSpec defines the desired state of Submariner
        """
        pulumi.set(__self__, "broker", broker)
        pulumi.set(__self__, "broker_k8s_api_server", broker_k8s_api_server)
        pulumi.set(__self__, "broker_k8s_api_server_token", broker_k8s_api_server_token)
        pulumi.set(__self__, "broker_k8s_ca", broker_k8s_ca)
        pulumi.set(__self__, "broker_k8s_remote_namespace", broker_k8s_remote_namespace)
        pulumi.set(__self__, "ce_ip_sec_debug", ce_ip_sec_debug)
        pulumi.set(__self__, "ce_ip_sec_psk", ce_ip_sec_psk)
        pulumi.set(__self__, "cluster_cidr", cluster_cidr)
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "debug", debug)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "nat_enabled", nat_enabled)
        pulumi.set(__self__, "service_cidr", service_cidr)
        if cable_driver is not None:
            pulumi.set(__self__, "cable_driver", cable_driver)
        if ce_ip_sec_ike_port is not None:
            pulumi.set(__self__, "ce_ip_sec_ike_port", ce_ip_sec_ike_port)
        if ce_ip_sec_natt_port is not None:
            pulumi.set(__self__, "ce_ip_sec_natt_port", ce_ip_sec_natt_port)
        if color_codes is not None:
            pulumi.set(__self__, "color_codes", color_codes)
        if connection_health_check is not None:
            pulumi.set(__self__, "connection_health_check", connection_health_check)
        if custom_domains is not None:
            pulumi.set(__self__, "custom_domains", custom_domains)
        if global_cidr is not None:
            pulumi.set(__self__, "global_cidr", global_cidr)
        if image_overrides is not None:
            pulumi.set(__self__, "image_overrides", image_overrides)
        if repository is not None:
            pulumi.set(__self__, "repository", repository)
        if service_discovery_enabled is not None:
            pulumi.set(__self__, "service_discovery_enabled", service_discovery_enabled)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def broker(self) -> str:
        return pulumi.get(self, "broker")

    @property
    @pulumi.getter(name="brokerK8sApiServer")
    def broker_k8s_api_server(self) -> str:
        return pulumi.get(self, "broker_k8s_api_server")

    @property
    @pulumi.getter(name="brokerK8sApiServerToken")
    def broker_k8s_api_server_token(self) -> str:
        return pulumi.get(self, "broker_k8s_api_server_token")

    @property
    @pulumi.getter(name="brokerK8sCA")
    def broker_k8s_ca(self) -> str:
        return pulumi.get(self, "broker_k8s_ca")

    @property
    @pulumi.getter(name="brokerK8sRemoteNamespace")
    def broker_k8s_remote_namespace(self) -> str:
        return pulumi.get(self, "broker_k8s_remote_namespace")

    @property
    @pulumi.getter(name="ceIPSecDebug")
    def ce_ip_sec_debug(self) -> bool:
        return pulumi.get(self, "ce_ip_sec_debug")

    @property
    @pulumi.getter(name="ceIPSecPSK")
    def ce_ip_sec_psk(self) -> str:
        return pulumi.get(self, "ce_ip_sec_psk")

    @property
    @pulumi.getter(name="clusterCIDR")
    def cluster_cidr(self) -> str:
        return pulumi.get(self, "cluster_cidr")

    @property
    @pulumi.getter(name="clusterID")
    def cluster_id(self) -> str:
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter
    def debug(self) -> bool:
        return pulumi.get(self, "debug")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="natEnabled")
    def nat_enabled(self) -> bool:
        return pulumi.get(self, "nat_enabled")

    @property
    @pulumi.getter(name="serviceCIDR")
    def service_cidr(self) -> str:
        return pulumi.get(self, "service_cidr")

    @property
    @pulumi.getter(name="cableDriver")
    def cable_driver(self) -> Optional[str]:
        return pulumi.get(self, "cable_driver")

    @property
    @pulumi.getter(name="ceIPSecIKEPort")
    def ce_ip_sec_ike_port(self) -> Optional[int]:
        return pulumi.get(self, "ce_ip_sec_ike_port")

    @property
    @pulumi.getter(name="ceIPSecNATTPort")
    def ce_ip_sec_natt_port(self) -> Optional[int]:
        return pulumi.get(self, "ce_ip_sec_natt_port")

    @property
    @pulumi.getter(name="colorCodes")
    def color_codes(self) -> Optional[str]:
        return pulumi.get(self, "color_codes")

    @property
    @pulumi.getter(name="connectionHealthCheck")
    def connection_health_check(self) -> Optional['outputs.SubmarinerSpecConnectionHealthCheck']:
        return pulumi.get(self, "connection_health_check")

    @property
    @pulumi.getter(name="customDomains")
    def custom_domains(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "custom_domains")

    @property
    @pulumi.getter(name="globalCIDR")
    def global_cidr(self) -> Optional[str]:
        return pulumi.get(self, "global_cidr")

    @property
    @pulumi.getter(name="imageOverrides")
    def image_overrides(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "image_overrides")

    @property
    @pulumi.getter
    def repository(self) -> Optional[str]:
        return pulumi.get(self, "repository")

    @property
    @pulumi.getter(name="serviceDiscoveryEnabled")
    def service_discovery_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "service_discovery_enabled")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        return pulumi.get(self, "version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubmarinerSpecConnectionHealthCheck(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 interval_seconds: Optional[int] = None,
                 max_packet_loss_count: Optional[int] = None):
        """
        :param int interval_seconds: The interval at which health check pings are sent.
        :param int max_packet_loss_count: The maximum number of packets lost at which the health checker will mark the connection as down.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if interval_seconds is not None:
            pulumi.set(__self__, "interval_seconds", interval_seconds)
        if max_packet_loss_count is not None:
            pulumi.set(__self__, "max_packet_loss_count", max_packet_loss_count)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="intervalSeconds")
    def interval_seconds(self) -> Optional[int]:
        """
        The interval at which health check pings are sent.
        """
        return pulumi.get(self, "interval_seconds")

    @property
    @pulumi.getter(name="maxPacketLossCount")
    def max_packet_loss_count(self) -> Optional[int]:
        """
        The maximum number of packets lost at which the health checker will mark the connection as down.
        """
        return pulumi.get(self, "max_packet_loss_count")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubmarinerStatus(dict):
    """
    SubmarinerStatus defines the observed state of Submariner
    """
    def __init__(__self__, *,
                 cluster_id: str,
                 nat_enabled: bool,
                 cluster_cidr: Optional[str] = None,
                 color_codes: Optional[str] = None,
                 engine_daemon_set_status: Optional['outputs.SubmarinerStatusEngineDaemonSetStatus'] = None,
                 gateways: Optional[Sequence['outputs.SubmarinerStatusGateways']] = None,
                 global_cidr: Optional[str] = None,
                 globalnet_daemon_set_status: Optional['outputs.SubmarinerStatusGlobalnetDaemonSetStatus'] = None,
                 network_plugin: Optional[str] = None,
                 route_agent_daemon_set_status: Optional['outputs.SubmarinerStatusRouteAgentDaemonSetStatus'] = None,
                 service_cidr: Optional[str] = None):
        """
        SubmarinerStatus defines the observed state of Submariner
        """
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "nat_enabled", nat_enabled)
        if cluster_cidr is not None:
            pulumi.set(__self__, "cluster_cidr", cluster_cidr)
        if color_codes is not None:
            pulumi.set(__self__, "color_codes", color_codes)
        if engine_daemon_set_status is not None:
            pulumi.set(__self__, "engine_daemon_set_status", engine_daemon_set_status)
        if gateways is not None:
            pulumi.set(__self__, "gateways", gateways)
        if global_cidr is not None:
            pulumi.set(__self__, "global_cidr", global_cidr)
        if globalnet_daemon_set_status is not None:
            pulumi.set(__self__, "globalnet_daemon_set_status", globalnet_daemon_set_status)
        if network_plugin is not None:
            pulumi.set(__self__, "network_plugin", network_plugin)
        if route_agent_daemon_set_status is not None:
            pulumi.set(__self__, "route_agent_daemon_set_status", route_agent_daemon_set_status)
        if service_cidr is not None:
            pulumi.set(__self__, "service_cidr", service_cidr)

    @property
    @pulumi.getter(name="clusterID")
    def cluster_id(self) -> str:
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="natEnabled")
    def nat_enabled(self) -> bool:
        return pulumi.get(self, "nat_enabled")

    @property
    @pulumi.getter(name="clusterCIDR")
    def cluster_cidr(self) -> Optional[str]:
        return pulumi.get(self, "cluster_cidr")

    @property
    @pulumi.getter(name="colorCodes")
    def color_codes(self) -> Optional[str]:
        return pulumi.get(self, "color_codes")

    @property
    @pulumi.getter(name="engineDaemonSetStatus")
    def engine_daemon_set_status(self) -> Optional['outputs.SubmarinerStatusEngineDaemonSetStatus']:
        return pulumi.get(self, "engine_daemon_set_status")

    @property
    @pulumi.getter
    def gateways(self) -> Optional[Sequence['outputs.SubmarinerStatusGateways']]:
        return pulumi.get(self, "gateways")

    @property
    @pulumi.getter(name="globalCIDR")
    def global_cidr(self) -> Optional[str]:
        return pulumi.get(self, "global_cidr")

    @property
    @pulumi.getter(name="globalnetDaemonSetStatus")
    def globalnet_daemon_set_status(self) -> Optional['outputs.SubmarinerStatusGlobalnetDaemonSetStatus']:
        return pulumi.get(self, "globalnet_daemon_set_status")

    @property
    @pulumi.getter(name="networkPlugin")
    def network_plugin(self) -> Optional[str]:
        return pulumi.get(self, "network_plugin")

    @property
    @pulumi.getter(name="routeAgentDaemonSetStatus")
    def route_agent_daemon_set_status(self) -> Optional['outputs.SubmarinerStatusRouteAgentDaemonSetStatus']:
        return pulumi.get(self, "route_agent_daemon_set_status")

    @property
    @pulumi.getter(name="serviceCIDR")
    def service_cidr(self) -> Optional[str]:
        return pulumi.get(self, "service_cidr")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubmarinerStatusEngineDaemonSetStatus(dict):
    def __init__(__self__, *,
                 mismatched_container_images: bool,
                 last_resource_version: Optional[str] = None,
                 non_ready_container_states: Optional[Sequence['outputs.SubmarinerStatusEngineDaemonSetStatusNonReadyContainerStates']] = None,
                 status: Optional['outputs.SubmarinerStatusEngineDaemonSetStatusStatus'] = None):
        """
        :param 'SubmarinerStatusEngineDaemonSetStatusStatusArgs' status: DaemonSetStatus represents the current status of a daemon set.
        """
        pulumi.set(__self__, "mismatched_container_images", mismatched_container_images)
        if last_resource_version is not None:
            pulumi.set(__self__, "last_resource_version", last_resource_version)
        if non_ready_container_states is not None:
            pulumi.set(__self__, "non_ready_container_states", non_ready_container_states)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="mismatchedContainerImages")
    def mismatched_container_images(self) -> bool:
        return pulumi.get(self, "mismatched_container_images")

    @property
    @pulumi.getter(name="lastResourceVersion")
    def last_resource_version(self) -> Optional[str]:
        return pulumi.get(self, "last_resource_version")

    @property
    @pulumi.getter(name="nonReadyContainerStates")
    def non_ready_container_states(self) -> Optional[Sequence['outputs.SubmarinerStatusEngineDaemonSetStatusNonReadyContainerStates']]:
        return pulumi.get(self, "non_ready_container_states")

    @property
    @pulumi.getter
    def status(self) -> Optional['outputs.SubmarinerStatusEngineDaemonSetStatusStatus']:
        """
        DaemonSetStatus represents the current status of a daemon set.
        """
        return pulumi.get(self, "status")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubmarinerStatusEngineDaemonSetStatusNonReadyContainerStates(dict):
    """
    ContainerState holds a possible state of container. Only one of its members may be specified. If none of them is specified, the default one is ContainerStateWaiting.
    """
    def __init__(__self__, *,
                 running: Optional['outputs.SubmarinerStatusEngineDaemonSetStatusNonReadyContainerStatesRunning'] = None,
                 terminated: Optional['outputs.SubmarinerStatusEngineDaemonSetStatusNonReadyContainerStatesTerminated'] = None,
                 waiting: Optional['outputs.SubmarinerStatusEngineDaemonSetStatusNonReadyContainerStatesWaiting'] = None):
        """
        ContainerState holds a possible state of container. Only one of its members may be specified. If none of them is specified, the default one is ContainerStateWaiting.
        :param 'SubmarinerStatusEngineDaemonSetStatusNonReadyContainerStatesRunningArgs' running: Details about a running container
        :param 'SubmarinerStatusEngineDaemonSetStatusNonReadyContainerStatesTerminatedArgs' terminated: Details about a terminated container
        :param 'SubmarinerStatusEngineDaemonSetStatusNonReadyContainerStatesWaitingArgs' waiting: Details about a waiting container
        """
        if running is not None:
            pulumi.set(__self__, "running", running)
        if terminated is not None:
            pulumi.set(__self__, "terminated", terminated)
        if waiting is not None:
            pulumi.set(__self__, "waiting", waiting)

    @property
    @pulumi.getter
    def running(self) -> Optional['outputs.SubmarinerStatusEngineDaemonSetStatusNonReadyContainerStatesRunning']:
        """
        Details about a running container
        """
        return pulumi.get(self, "running")

    @property
    @pulumi.getter
    def terminated(self) -> Optional['outputs.SubmarinerStatusEngineDaemonSetStatusNonReadyContainerStatesTerminated']:
        """
        Details about a terminated container
        """
        return pulumi.get(self, "terminated")

    @property
    @pulumi.getter
    def waiting(self) -> Optional['outputs.SubmarinerStatusEngineDaemonSetStatusNonReadyContainerStatesWaiting']:
        """
        Details about a waiting container
        """
        return pulumi.get(self, "waiting")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubmarinerStatusEngineDaemonSetStatusNonReadyContainerStatesRunning(dict):
    """
    Details about a running container
    """
    def __init__(__self__, *,
                 started_at: Optional[str] = None):
        """
        Details about a running container
        :param str started_at: Time at which the container was last (re-)started
        """
        if started_at is not None:
            pulumi.set(__self__, "started_at", started_at)

    @property
    @pulumi.getter(name="startedAt")
    def started_at(self) -> Optional[str]:
        """
        Time at which the container was last (re-)started
        """
        return pulumi.get(self, "started_at")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubmarinerStatusEngineDaemonSetStatusNonReadyContainerStatesTerminated(dict):
    """
    Details about a terminated container
    """
    def __init__(__self__, *,
                 exit_code: int,
                 container_id: Optional[str] = None,
                 finished_at: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None,
                 signal: Optional[int] = None,
                 started_at: Optional[str] = None):
        """
        Details about a terminated container
        :param int exit_code: Exit status from the last termination of the container
        :param str container_id: Container's ID in the format 'docker://<container_id>'
        :param str finished_at: Time at which the container last terminated
        :param str message: Message regarding the last termination of the container
        :param str reason: (brief) reason from the last termination of the container
        :param int signal: Signal from the last termination of the container
        :param str started_at: Time at which previous execution of the container started
        """
        pulumi.set(__self__, "exit_code", exit_code)
        if container_id is not None:
            pulumi.set(__self__, "container_id", container_id)
        if finished_at is not None:
            pulumi.set(__self__, "finished_at", finished_at)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if signal is not None:
            pulumi.set(__self__, "signal", signal)
        if started_at is not None:
            pulumi.set(__self__, "started_at", started_at)

    @property
    @pulumi.getter(name="exitCode")
    def exit_code(self) -> int:
        """
        Exit status from the last termination of the container
        """
        return pulumi.get(self, "exit_code")

    @property
    @pulumi.getter(name="containerID")
    def container_id(self) -> Optional[str]:
        """
        Container's ID in the format 'docker://<container_id>'
        """
        return pulumi.get(self, "container_id")

    @property
    @pulumi.getter(name="finishedAt")
    def finished_at(self) -> Optional[str]:
        """
        Time at which the container last terminated
        """
        return pulumi.get(self, "finished_at")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Message regarding the last termination of the container
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        (brief) reason from the last termination of the container
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def signal(self) -> Optional[int]:
        """
        Signal from the last termination of the container
        """
        return pulumi.get(self, "signal")

    @property
    @pulumi.getter(name="startedAt")
    def started_at(self) -> Optional[str]:
        """
        Time at which previous execution of the container started
        """
        return pulumi.get(self, "started_at")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubmarinerStatusEngineDaemonSetStatusNonReadyContainerStatesWaiting(dict):
    """
    Details about a waiting container
    """
    def __init__(__self__, *,
                 message: Optional[str] = None,
                 reason: Optional[str] = None):
        """
        Details about a waiting container
        :param str message: Message regarding why the container is not yet running.
        :param str reason: (brief) reason the container is not yet running.
        """
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Message regarding why the container is not yet running.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        (brief) reason the container is not yet running.
        """
        return pulumi.get(self, "reason")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubmarinerStatusEngineDaemonSetStatusStatus(dict):
    """
    DaemonSetStatus represents the current status of a daemon set.
    """
    def __init__(__self__, *,
                 current_number_scheduled: int,
                 desired_number_scheduled: int,
                 number_misscheduled: int,
                 number_ready: int,
                 collision_count: Optional[int] = None,
                 conditions: Optional[Sequence['outputs.SubmarinerStatusEngineDaemonSetStatusStatusConditions']] = None,
                 number_available: Optional[int] = None,
                 number_unavailable: Optional[int] = None,
                 observed_generation: Optional[int] = None,
                 updated_number_scheduled: Optional[int] = None):
        """
        DaemonSetStatus represents the current status of a daemon set.
        :param int current_number_scheduled: The number of nodes that are running at least 1 daemon pod and are supposed to run the daemon pod. More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        :param int desired_number_scheduled: The total number of nodes that should be running the daemon pod (including nodes correctly running the daemon pod). More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        :param int number_misscheduled: The number of nodes that are running the daemon pod, but are not supposed to run the daemon pod. More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        :param int number_ready: The number of nodes that should be running the daemon pod and have one or more of the daemon pod running and ready.
        :param int collision_count: Count of hash collisions for the DaemonSet. The DaemonSet controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ControllerRevision.
        :param Sequence['SubmarinerStatusEngineDaemonSetStatusStatusConditionsArgs'] conditions: Represents the latest available observations of a DaemonSet's current state.
        :param int number_available: The number of nodes that should be running the daemon pod and have one or more of the daemon pod running and available (ready for at least spec.minReadySeconds)
        :param int number_unavailable: The number of nodes that should be running the daemon pod and have none of the daemon pod running and available (ready for at least spec.minReadySeconds)
        :param int observed_generation: The most recent generation observed by the daemon set controller.
        :param int updated_number_scheduled: The total number of nodes that are running updated daemon pod
        """
        pulumi.set(__self__, "current_number_scheduled", current_number_scheduled)
        pulumi.set(__self__, "desired_number_scheduled", desired_number_scheduled)
        pulumi.set(__self__, "number_misscheduled", number_misscheduled)
        pulumi.set(__self__, "number_ready", number_ready)
        if collision_count is not None:
            pulumi.set(__self__, "collision_count", collision_count)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if number_available is not None:
            pulumi.set(__self__, "number_available", number_available)
        if number_unavailable is not None:
            pulumi.set(__self__, "number_unavailable", number_unavailable)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if updated_number_scheduled is not None:
            pulumi.set(__self__, "updated_number_scheduled", updated_number_scheduled)

    @property
    @pulumi.getter(name="currentNumberScheduled")
    def current_number_scheduled(self) -> int:
        """
        The number of nodes that are running at least 1 daemon pod and are supposed to run the daemon pod. More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        """
        return pulumi.get(self, "current_number_scheduled")

    @property
    @pulumi.getter(name="desiredNumberScheduled")
    def desired_number_scheduled(self) -> int:
        """
        The total number of nodes that should be running the daemon pod (including nodes correctly running the daemon pod). More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        """
        return pulumi.get(self, "desired_number_scheduled")

    @property
    @pulumi.getter(name="numberMisscheduled")
    def number_misscheduled(self) -> int:
        """
        The number of nodes that are running the daemon pod, but are not supposed to run the daemon pod. More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        """
        return pulumi.get(self, "number_misscheduled")

    @property
    @pulumi.getter(name="numberReady")
    def number_ready(self) -> int:
        """
        The number of nodes that should be running the daemon pod and have one or more of the daemon pod running and ready.
        """
        return pulumi.get(self, "number_ready")

    @property
    @pulumi.getter(name="collisionCount")
    def collision_count(self) -> Optional[int]:
        """
        Count of hash collisions for the DaemonSet. The DaemonSet controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ControllerRevision.
        """
        return pulumi.get(self, "collision_count")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.SubmarinerStatusEngineDaemonSetStatusStatusConditions']]:
        """
        Represents the latest available observations of a DaemonSet's current state.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="numberAvailable")
    def number_available(self) -> Optional[int]:
        """
        The number of nodes that should be running the daemon pod and have one or more of the daemon pod running and available (ready for at least spec.minReadySeconds)
        """
        return pulumi.get(self, "number_available")

    @property
    @pulumi.getter(name="numberUnavailable")
    def number_unavailable(self) -> Optional[int]:
        """
        The number of nodes that should be running the daemon pod and have none of the daemon pod running and available (ready for at least spec.minReadySeconds)
        """
        return pulumi.get(self, "number_unavailable")

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[int]:
        """
        The most recent generation observed by the daemon set controller.
        """
        return pulumi.get(self, "observed_generation")

    @property
    @pulumi.getter(name="updatedNumberScheduled")
    def updated_number_scheduled(self) -> Optional[int]:
        """
        The total number of nodes that are running updated daemon pod
        """
        return pulumi.get(self, "updated_number_scheduled")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubmarinerStatusEngineDaemonSetStatusStatusConditions(dict):
    """
    DaemonSetCondition describes the state of a DaemonSet at a certain point.
    """
    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None):
        """
        DaemonSetCondition describes the state of a DaemonSet at a certain point.
        :param str status: Status of the condition, one of True, False, Unknown.
        :param str type: Type of DaemonSet condition.
        :param str last_transition_time: Last time the condition transitioned from one status to another.
        :param str message: A human readable message indicating details about the transition.
        :param str reason: The reason for the condition's last transition.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of DaemonSet condition.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        Last time the condition transitioned from one status to another.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        A human readable message indicating details about the transition.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        The reason for the condition's last transition.
        """
        return pulumi.get(self, "reason")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubmarinerStatusGateways(dict):
    def __init__(__self__, *,
                 connections: Sequence['outputs.SubmarinerStatusGatewaysConnections'],
                 ha_status: str,
                 local_endpoint: 'outputs.SubmarinerStatusGatewaysLocalEndpoint',
                 status_failure: str,
                 version: str):
        pulumi.set(__self__, "connections", connections)
        pulumi.set(__self__, "ha_status", ha_status)
        pulumi.set(__self__, "local_endpoint", local_endpoint)
        pulumi.set(__self__, "status_failure", status_failure)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def connections(self) -> Sequence['outputs.SubmarinerStatusGatewaysConnections']:
        return pulumi.get(self, "connections")

    @property
    @pulumi.getter(name="haStatus")
    def ha_status(self) -> str:
        return pulumi.get(self, "ha_status")

    @property
    @pulumi.getter(name="localEndpoint")
    def local_endpoint(self) -> 'outputs.SubmarinerStatusGatewaysLocalEndpoint':
        return pulumi.get(self, "local_endpoint")

    @property
    @pulumi.getter(name="statusFailure")
    def status_failure(self) -> str:
        return pulumi.get(self, "status_failure")

    @property
    @pulumi.getter
    def version(self) -> str:
        return pulumi.get(self, "version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubmarinerStatusGatewaysConnections(dict):
    def __init__(__self__, *,
                 endpoint: 'outputs.SubmarinerStatusGatewaysConnectionsEndpoint',
                 status: str,
                 status_message: str,
                 latency_rtt: Optional['outputs.SubmarinerStatusGatewaysConnectionsLatencyRTT'] = None):
        """
        :param 'SubmarinerStatusGatewaysConnectionsLatencyRTTArgs' latency_rtt: LatencySpec describes the round trip time information for a packet between the gateway pods of two clusters.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "status_message", status_message)
        if latency_rtt is not None:
            pulumi.set(__self__, "latency_rtt", latency_rtt)

    @property
    @pulumi.getter
    def endpoint(self) -> 'outputs.SubmarinerStatusGatewaysConnectionsEndpoint':
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> str:
        return pulumi.get(self, "status_message")

    @property
    @pulumi.getter(name="latencyRTT")
    def latency_rtt(self) -> Optional['outputs.SubmarinerStatusGatewaysConnectionsLatencyRTT']:
        """
        LatencySpec describes the round trip time information for a packet between the gateway pods of two clusters.
        """
        return pulumi.get(self, "latency_rtt")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubmarinerStatusGatewaysConnectionsEndpoint(dict):
    def __init__(__self__, *,
                 backend: str,
                 cable_name: str,
                 cluster_id: str,
                 hostname: str,
                 nat_enabled: bool,
                 private_ip: str,
                 public_ip: str,
                 subnets: Sequence[str],
                 backend_config: Optional[Mapping[str, str]] = None,
                 health_check_ip: Optional[str] = None):
        pulumi.set(__self__, "backend", backend)
        pulumi.set(__self__, "cable_name", cable_name)
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "nat_enabled", nat_enabled)
        pulumi.set(__self__, "private_ip", private_ip)
        pulumi.set(__self__, "public_ip", public_ip)
        pulumi.set(__self__, "subnets", subnets)
        if backend_config is not None:
            pulumi.set(__self__, "backend_config", backend_config)
        if health_check_ip is not None:
            pulumi.set(__self__, "health_check_ip", health_check_ip)

    @property
    @pulumi.getter
    def backend(self) -> str:
        return pulumi.get(self, "backend")

    @property
    @pulumi.getter
    def cable_name(self) -> str:
        return pulumi.get(self, "cable_name")

    @property
    @pulumi.getter
    def cluster_id(self) -> str:
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def nat_enabled(self) -> bool:
        return pulumi.get(self, "nat_enabled")

    @property
    @pulumi.getter
    def private_ip(self) -> str:
        return pulumi.get(self, "private_ip")

    @property
    @pulumi.getter
    def public_ip(self) -> str:
        return pulumi.get(self, "public_ip")

    @property
    @pulumi.getter
    def subnets(self) -> Sequence[str]:
        return pulumi.get(self, "subnets")

    @property
    @pulumi.getter
    def backend_config(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "backend_config")

    @property
    @pulumi.getter(name="healthCheckIP")
    def health_check_ip(self) -> Optional[str]:
        return pulumi.get(self, "health_check_ip")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubmarinerStatusGatewaysConnectionsLatencyRTT(dict):
    """
    LatencySpec describes the round trip time information for a packet between the gateway pods of two clusters.
    """
    def __init__(__self__, *,
                 average: Optional[str] = None,
                 last: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 std_dev: Optional[str] = None):
        """
        LatencySpec describes the round trip time information for a packet between the gateway pods of two clusters.
        """
        if average is not None:
            pulumi.set(__self__, "average", average)
        if last is not None:
            pulumi.set(__self__, "last", last)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if std_dev is not None:
            pulumi.set(__self__, "std_dev", std_dev)

    @property
    @pulumi.getter
    def average(self) -> Optional[str]:
        return pulumi.get(self, "average")

    @property
    @pulumi.getter
    def last(self) -> Optional[str]:
        return pulumi.get(self, "last")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        return pulumi.get(self, "min")

    @property
    @pulumi.getter(name="stdDev")
    def std_dev(self) -> Optional[str]:
        return pulumi.get(self, "std_dev")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubmarinerStatusGatewaysLocalEndpoint(dict):
    def __init__(__self__, *,
                 backend: str,
                 cable_name: str,
                 cluster_id: str,
                 hostname: str,
                 nat_enabled: bool,
                 private_ip: str,
                 public_ip: str,
                 subnets: Sequence[str],
                 backend_config: Optional[Mapping[str, str]] = None,
                 health_check_ip: Optional[str] = None):
        pulumi.set(__self__, "backend", backend)
        pulumi.set(__self__, "cable_name", cable_name)
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "nat_enabled", nat_enabled)
        pulumi.set(__self__, "private_ip", private_ip)
        pulumi.set(__self__, "public_ip", public_ip)
        pulumi.set(__self__, "subnets", subnets)
        if backend_config is not None:
            pulumi.set(__self__, "backend_config", backend_config)
        if health_check_ip is not None:
            pulumi.set(__self__, "health_check_ip", health_check_ip)

    @property
    @pulumi.getter
    def backend(self) -> str:
        return pulumi.get(self, "backend")

    @property
    @pulumi.getter
    def cable_name(self) -> str:
        return pulumi.get(self, "cable_name")

    @property
    @pulumi.getter
    def cluster_id(self) -> str:
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def nat_enabled(self) -> bool:
        return pulumi.get(self, "nat_enabled")

    @property
    @pulumi.getter
    def private_ip(self) -> str:
        return pulumi.get(self, "private_ip")

    @property
    @pulumi.getter
    def public_ip(self) -> str:
        return pulumi.get(self, "public_ip")

    @property
    @pulumi.getter
    def subnets(self) -> Sequence[str]:
        return pulumi.get(self, "subnets")

    @property
    @pulumi.getter
    def backend_config(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "backend_config")

    @property
    @pulumi.getter(name="healthCheckIP")
    def health_check_ip(self) -> Optional[str]:
        return pulumi.get(self, "health_check_ip")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubmarinerStatusGlobalnetDaemonSetStatus(dict):
    def __init__(__self__, *,
                 mismatched_container_images: bool,
                 last_resource_version: Optional[str] = None,
                 non_ready_container_states: Optional[Sequence['outputs.SubmarinerStatusGlobalnetDaemonSetStatusNonReadyContainerStates']] = None,
                 status: Optional['outputs.SubmarinerStatusGlobalnetDaemonSetStatusStatus'] = None):
        """
        :param 'SubmarinerStatusGlobalnetDaemonSetStatusStatusArgs' status: DaemonSetStatus represents the current status of a daemon set.
        """
        pulumi.set(__self__, "mismatched_container_images", mismatched_container_images)
        if last_resource_version is not None:
            pulumi.set(__self__, "last_resource_version", last_resource_version)
        if non_ready_container_states is not None:
            pulumi.set(__self__, "non_ready_container_states", non_ready_container_states)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="mismatchedContainerImages")
    def mismatched_container_images(self) -> bool:
        return pulumi.get(self, "mismatched_container_images")

    @property
    @pulumi.getter(name="lastResourceVersion")
    def last_resource_version(self) -> Optional[str]:
        return pulumi.get(self, "last_resource_version")

    @property
    @pulumi.getter(name="nonReadyContainerStates")
    def non_ready_container_states(self) -> Optional[Sequence['outputs.SubmarinerStatusGlobalnetDaemonSetStatusNonReadyContainerStates']]:
        return pulumi.get(self, "non_ready_container_states")

    @property
    @pulumi.getter
    def status(self) -> Optional['outputs.SubmarinerStatusGlobalnetDaemonSetStatusStatus']:
        """
        DaemonSetStatus represents the current status of a daemon set.
        """
        return pulumi.get(self, "status")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubmarinerStatusGlobalnetDaemonSetStatusNonReadyContainerStates(dict):
    """
    ContainerState holds a possible state of container. Only one of its members may be specified. If none of them is specified, the default one is ContainerStateWaiting.
    """
    def __init__(__self__, *,
                 running: Optional['outputs.SubmarinerStatusGlobalnetDaemonSetStatusNonReadyContainerStatesRunning'] = None,
                 terminated: Optional['outputs.SubmarinerStatusGlobalnetDaemonSetStatusNonReadyContainerStatesTerminated'] = None,
                 waiting: Optional['outputs.SubmarinerStatusGlobalnetDaemonSetStatusNonReadyContainerStatesWaiting'] = None):
        """
        ContainerState holds a possible state of container. Only one of its members may be specified. If none of them is specified, the default one is ContainerStateWaiting.
        :param 'SubmarinerStatusGlobalnetDaemonSetStatusNonReadyContainerStatesRunningArgs' running: Details about a running container
        :param 'SubmarinerStatusGlobalnetDaemonSetStatusNonReadyContainerStatesTerminatedArgs' terminated: Details about a terminated container
        :param 'SubmarinerStatusGlobalnetDaemonSetStatusNonReadyContainerStatesWaitingArgs' waiting: Details about a waiting container
        """
        if running is not None:
            pulumi.set(__self__, "running", running)
        if terminated is not None:
            pulumi.set(__self__, "terminated", terminated)
        if waiting is not None:
            pulumi.set(__self__, "waiting", waiting)

    @property
    @pulumi.getter
    def running(self) -> Optional['outputs.SubmarinerStatusGlobalnetDaemonSetStatusNonReadyContainerStatesRunning']:
        """
        Details about a running container
        """
        return pulumi.get(self, "running")

    @property
    @pulumi.getter
    def terminated(self) -> Optional['outputs.SubmarinerStatusGlobalnetDaemonSetStatusNonReadyContainerStatesTerminated']:
        """
        Details about a terminated container
        """
        return pulumi.get(self, "terminated")

    @property
    @pulumi.getter
    def waiting(self) -> Optional['outputs.SubmarinerStatusGlobalnetDaemonSetStatusNonReadyContainerStatesWaiting']:
        """
        Details about a waiting container
        """
        return pulumi.get(self, "waiting")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubmarinerStatusGlobalnetDaemonSetStatusNonReadyContainerStatesRunning(dict):
    """
    Details about a running container
    """
    def __init__(__self__, *,
                 started_at: Optional[str] = None):
        """
        Details about a running container
        :param str started_at: Time at which the container was last (re-)started
        """
        if started_at is not None:
            pulumi.set(__self__, "started_at", started_at)

    @property
    @pulumi.getter(name="startedAt")
    def started_at(self) -> Optional[str]:
        """
        Time at which the container was last (re-)started
        """
        return pulumi.get(self, "started_at")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubmarinerStatusGlobalnetDaemonSetStatusNonReadyContainerStatesTerminated(dict):
    """
    Details about a terminated container
    """
    def __init__(__self__, *,
                 exit_code: int,
                 container_id: Optional[str] = None,
                 finished_at: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None,
                 signal: Optional[int] = None,
                 started_at: Optional[str] = None):
        """
        Details about a terminated container
        :param int exit_code: Exit status from the last termination of the container
        :param str container_id: Container's ID in the format 'docker://<container_id>'
        :param str finished_at: Time at which the container last terminated
        :param str message: Message regarding the last termination of the container
        :param str reason: (brief) reason from the last termination of the container
        :param int signal: Signal from the last termination of the container
        :param str started_at: Time at which previous execution of the container started
        """
        pulumi.set(__self__, "exit_code", exit_code)
        if container_id is not None:
            pulumi.set(__self__, "container_id", container_id)
        if finished_at is not None:
            pulumi.set(__self__, "finished_at", finished_at)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if signal is not None:
            pulumi.set(__self__, "signal", signal)
        if started_at is not None:
            pulumi.set(__self__, "started_at", started_at)

    @property
    @pulumi.getter(name="exitCode")
    def exit_code(self) -> int:
        """
        Exit status from the last termination of the container
        """
        return pulumi.get(self, "exit_code")

    @property
    @pulumi.getter(name="containerID")
    def container_id(self) -> Optional[str]:
        """
        Container's ID in the format 'docker://<container_id>'
        """
        return pulumi.get(self, "container_id")

    @property
    @pulumi.getter(name="finishedAt")
    def finished_at(self) -> Optional[str]:
        """
        Time at which the container last terminated
        """
        return pulumi.get(self, "finished_at")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Message regarding the last termination of the container
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        (brief) reason from the last termination of the container
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def signal(self) -> Optional[int]:
        """
        Signal from the last termination of the container
        """
        return pulumi.get(self, "signal")

    @property
    @pulumi.getter(name="startedAt")
    def started_at(self) -> Optional[str]:
        """
        Time at which previous execution of the container started
        """
        return pulumi.get(self, "started_at")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubmarinerStatusGlobalnetDaemonSetStatusNonReadyContainerStatesWaiting(dict):
    """
    Details about a waiting container
    """
    def __init__(__self__, *,
                 message: Optional[str] = None,
                 reason: Optional[str] = None):
        """
        Details about a waiting container
        :param str message: Message regarding why the container is not yet running.
        :param str reason: (brief) reason the container is not yet running.
        """
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Message regarding why the container is not yet running.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        (brief) reason the container is not yet running.
        """
        return pulumi.get(self, "reason")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubmarinerStatusGlobalnetDaemonSetStatusStatus(dict):
    """
    DaemonSetStatus represents the current status of a daemon set.
    """
    def __init__(__self__, *,
                 current_number_scheduled: int,
                 desired_number_scheduled: int,
                 number_misscheduled: int,
                 number_ready: int,
                 collision_count: Optional[int] = None,
                 conditions: Optional[Sequence['outputs.SubmarinerStatusGlobalnetDaemonSetStatusStatusConditions']] = None,
                 number_available: Optional[int] = None,
                 number_unavailable: Optional[int] = None,
                 observed_generation: Optional[int] = None,
                 updated_number_scheduled: Optional[int] = None):
        """
        DaemonSetStatus represents the current status of a daemon set.
        :param int current_number_scheduled: The number of nodes that are running at least 1 daemon pod and are supposed to run the daemon pod. More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        :param int desired_number_scheduled: The total number of nodes that should be running the daemon pod (including nodes correctly running the daemon pod). More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        :param int number_misscheduled: The number of nodes that are running the daemon pod, but are not supposed to run the daemon pod. More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        :param int number_ready: The number of nodes that should be running the daemon pod and have one or more of the daemon pod running and ready.
        :param int collision_count: Count of hash collisions for the DaemonSet. The DaemonSet controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ControllerRevision.
        :param Sequence['SubmarinerStatusGlobalnetDaemonSetStatusStatusConditionsArgs'] conditions: Represents the latest available observations of a DaemonSet's current state.
        :param int number_available: The number of nodes that should be running the daemon pod and have one or more of the daemon pod running and available (ready for at least spec.minReadySeconds)
        :param int number_unavailable: The number of nodes that should be running the daemon pod and have none of the daemon pod running and available (ready for at least spec.minReadySeconds)
        :param int observed_generation: The most recent generation observed by the daemon set controller.
        :param int updated_number_scheduled: The total number of nodes that are running updated daemon pod
        """
        pulumi.set(__self__, "current_number_scheduled", current_number_scheduled)
        pulumi.set(__self__, "desired_number_scheduled", desired_number_scheduled)
        pulumi.set(__self__, "number_misscheduled", number_misscheduled)
        pulumi.set(__self__, "number_ready", number_ready)
        if collision_count is not None:
            pulumi.set(__self__, "collision_count", collision_count)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if number_available is not None:
            pulumi.set(__self__, "number_available", number_available)
        if number_unavailable is not None:
            pulumi.set(__self__, "number_unavailable", number_unavailable)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if updated_number_scheduled is not None:
            pulumi.set(__self__, "updated_number_scheduled", updated_number_scheduled)

    @property
    @pulumi.getter(name="currentNumberScheduled")
    def current_number_scheduled(self) -> int:
        """
        The number of nodes that are running at least 1 daemon pod and are supposed to run the daemon pod. More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        """
        return pulumi.get(self, "current_number_scheduled")

    @property
    @pulumi.getter(name="desiredNumberScheduled")
    def desired_number_scheduled(self) -> int:
        """
        The total number of nodes that should be running the daemon pod (including nodes correctly running the daemon pod). More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        """
        return pulumi.get(self, "desired_number_scheduled")

    @property
    @pulumi.getter(name="numberMisscheduled")
    def number_misscheduled(self) -> int:
        """
        The number of nodes that are running the daemon pod, but are not supposed to run the daemon pod. More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        """
        return pulumi.get(self, "number_misscheduled")

    @property
    @pulumi.getter(name="numberReady")
    def number_ready(self) -> int:
        """
        The number of nodes that should be running the daemon pod and have one or more of the daemon pod running and ready.
        """
        return pulumi.get(self, "number_ready")

    @property
    @pulumi.getter(name="collisionCount")
    def collision_count(self) -> Optional[int]:
        """
        Count of hash collisions for the DaemonSet. The DaemonSet controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ControllerRevision.
        """
        return pulumi.get(self, "collision_count")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.SubmarinerStatusGlobalnetDaemonSetStatusStatusConditions']]:
        """
        Represents the latest available observations of a DaemonSet's current state.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="numberAvailable")
    def number_available(self) -> Optional[int]:
        """
        The number of nodes that should be running the daemon pod and have one or more of the daemon pod running and available (ready for at least spec.minReadySeconds)
        """
        return pulumi.get(self, "number_available")

    @property
    @pulumi.getter(name="numberUnavailable")
    def number_unavailable(self) -> Optional[int]:
        """
        The number of nodes that should be running the daemon pod and have none of the daemon pod running and available (ready for at least spec.minReadySeconds)
        """
        return pulumi.get(self, "number_unavailable")

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[int]:
        """
        The most recent generation observed by the daemon set controller.
        """
        return pulumi.get(self, "observed_generation")

    @property
    @pulumi.getter(name="updatedNumberScheduled")
    def updated_number_scheduled(self) -> Optional[int]:
        """
        The total number of nodes that are running updated daemon pod
        """
        return pulumi.get(self, "updated_number_scheduled")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubmarinerStatusGlobalnetDaemonSetStatusStatusConditions(dict):
    """
    DaemonSetCondition describes the state of a DaemonSet at a certain point.
    """
    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None):
        """
        DaemonSetCondition describes the state of a DaemonSet at a certain point.
        :param str status: Status of the condition, one of True, False, Unknown.
        :param str type: Type of DaemonSet condition.
        :param str last_transition_time: Last time the condition transitioned from one status to another.
        :param str message: A human readable message indicating details about the transition.
        :param str reason: The reason for the condition's last transition.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of DaemonSet condition.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        Last time the condition transitioned from one status to another.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        A human readable message indicating details about the transition.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        The reason for the condition's last transition.
        """
        return pulumi.get(self, "reason")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubmarinerStatusRouteAgentDaemonSetStatus(dict):
    def __init__(__self__, *,
                 mismatched_container_images: bool,
                 last_resource_version: Optional[str] = None,
                 non_ready_container_states: Optional[Sequence['outputs.SubmarinerStatusRouteAgentDaemonSetStatusNonReadyContainerStates']] = None,
                 status: Optional['outputs.SubmarinerStatusRouteAgentDaemonSetStatusStatus'] = None):
        """
        :param 'SubmarinerStatusRouteAgentDaemonSetStatusStatusArgs' status: DaemonSetStatus represents the current status of a daemon set.
        """
        pulumi.set(__self__, "mismatched_container_images", mismatched_container_images)
        if last_resource_version is not None:
            pulumi.set(__self__, "last_resource_version", last_resource_version)
        if non_ready_container_states is not None:
            pulumi.set(__self__, "non_ready_container_states", non_ready_container_states)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="mismatchedContainerImages")
    def mismatched_container_images(self) -> bool:
        return pulumi.get(self, "mismatched_container_images")

    @property
    @pulumi.getter(name="lastResourceVersion")
    def last_resource_version(self) -> Optional[str]:
        return pulumi.get(self, "last_resource_version")

    @property
    @pulumi.getter(name="nonReadyContainerStates")
    def non_ready_container_states(self) -> Optional[Sequence['outputs.SubmarinerStatusRouteAgentDaemonSetStatusNonReadyContainerStates']]:
        return pulumi.get(self, "non_ready_container_states")

    @property
    @pulumi.getter
    def status(self) -> Optional['outputs.SubmarinerStatusRouteAgentDaemonSetStatusStatus']:
        """
        DaemonSetStatus represents the current status of a daemon set.
        """
        return pulumi.get(self, "status")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubmarinerStatusRouteAgentDaemonSetStatusNonReadyContainerStates(dict):
    """
    ContainerState holds a possible state of container. Only one of its members may be specified. If none of them is specified, the default one is ContainerStateWaiting.
    """
    def __init__(__self__, *,
                 running: Optional['outputs.SubmarinerStatusRouteAgentDaemonSetStatusNonReadyContainerStatesRunning'] = None,
                 terminated: Optional['outputs.SubmarinerStatusRouteAgentDaemonSetStatusNonReadyContainerStatesTerminated'] = None,
                 waiting: Optional['outputs.SubmarinerStatusRouteAgentDaemonSetStatusNonReadyContainerStatesWaiting'] = None):
        """
        ContainerState holds a possible state of container. Only one of its members may be specified. If none of them is specified, the default one is ContainerStateWaiting.
        :param 'SubmarinerStatusRouteAgentDaemonSetStatusNonReadyContainerStatesRunningArgs' running: Details about a running container
        :param 'SubmarinerStatusRouteAgentDaemonSetStatusNonReadyContainerStatesTerminatedArgs' terminated: Details about a terminated container
        :param 'SubmarinerStatusRouteAgentDaemonSetStatusNonReadyContainerStatesWaitingArgs' waiting: Details about a waiting container
        """
        if running is not None:
            pulumi.set(__self__, "running", running)
        if terminated is not None:
            pulumi.set(__self__, "terminated", terminated)
        if waiting is not None:
            pulumi.set(__self__, "waiting", waiting)

    @property
    @pulumi.getter
    def running(self) -> Optional['outputs.SubmarinerStatusRouteAgentDaemonSetStatusNonReadyContainerStatesRunning']:
        """
        Details about a running container
        """
        return pulumi.get(self, "running")

    @property
    @pulumi.getter
    def terminated(self) -> Optional['outputs.SubmarinerStatusRouteAgentDaemonSetStatusNonReadyContainerStatesTerminated']:
        """
        Details about a terminated container
        """
        return pulumi.get(self, "terminated")

    @property
    @pulumi.getter
    def waiting(self) -> Optional['outputs.SubmarinerStatusRouteAgentDaemonSetStatusNonReadyContainerStatesWaiting']:
        """
        Details about a waiting container
        """
        return pulumi.get(self, "waiting")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubmarinerStatusRouteAgentDaemonSetStatusNonReadyContainerStatesRunning(dict):
    """
    Details about a running container
    """
    def __init__(__self__, *,
                 started_at: Optional[str] = None):
        """
        Details about a running container
        :param str started_at: Time at which the container was last (re-)started
        """
        if started_at is not None:
            pulumi.set(__self__, "started_at", started_at)

    @property
    @pulumi.getter(name="startedAt")
    def started_at(self) -> Optional[str]:
        """
        Time at which the container was last (re-)started
        """
        return pulumi.get(self, "started_at")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubmarinerStatusRouteAgentDaemonSetStatusNonReadyContainerStatesTerminated(dict):
    """
    Details about a terminated container
    """
    def __init__(__self__, *,
                 exit_code: int,
                 container_id: Optional[str] = None,
                 finished_at: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None,
                 signal: Optional[int] = None,
                 started_at: Optional[str] = None):
        """
        Details about a terminated container
        :param int exit_code: Exit status from the last termination of the container
        :param str container_id: Container's ID in the format 'docker://<container_id>'
        :param str finished_at: Time at which the container last terminated
        :param str message: Message regarding the last termination of the container
        :param str reason: (brief) reason from the last termination of the container
        :param int signal: Signal from the last termination of the container
        :param str started_at: Time at which previous execution of the container started
        """
        pulumi.set(__self__, "exit_code", exit_code)
        if container_id is not None:
            pulumi.set(__self__, "container_id", container_id)
        if finished_at is not None:
            pulumi.set(__self__, "finished_at", finished_at)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if signal is not None:
            pulumi.set(__self__, "signal", signal)
        if started_at is not None:
            pulumi.set(__self__, "started_at", started_at)

    @property
    @pulumi.getter(name="exitCode")
    def exit_code(self) -> int:
        """
        Exit status from the last termination of the container
        """
        return pulumi.get(self, "exit_code")

    @property
    @pulumi.getter(name="containerID")
    def container_id(self) -> Optional[str]:
        """
        Container's ID in the format 'docker://<container_id>'
        """
        return pulumi.get(self, "container_id")

    @property
    @pulumi.getter(name="finishedAt")
    def finished_at(self) -> Optional[str]:
        """
        Time at which the container last terminated
        """
        return pulumi.get(self, "finished_at")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Message regarding the last termination of the container
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        (brief) reason from the last termination of the container
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def signal(self) -> Optional[int]:
        """
        Signal from the last termination of the container
        """
        return pulumi.get(self, "signal")

    @property
    @pulumi.getter(name="startedAt")
    def started_at(self) -> Optional[str]:
        """
        Time at which previous execution of the container started
        """
        return pulumi.get(self, "started_at")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubmarinerStatusRouteAgentDaemonSetStatusNonReadyContainerStatesWaiting(dict):
    """
    Details about a waiting container
    """
    def __init__(__self__, *,
                 message: Optional[str] = None,
                 reason: Optional[str] = None):
        """
        Details about a waiting container
        :param str message: Message regarding why the container is not yet running.
        :param str reason: (brief) reason the container is not yet running.
        """
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Message regarding why the container is not yet running.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        (brief) reason the container is not yet running.
        """
        return pulumi.get(self, "reason")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubmarinerStatusRouteAgentDaemonSetStatusStatus(dict):
    """
    DaemonSetStatus represents the current status of a daemon set.
    """
    def __init__(__self__, *,
                 current_number_scheduled: int,
                 desired_number_scheduled: int,
                 number_misscheduled: int,
                 number_ready: int,
                 collision_count: Optional[int] = None,
                 conditions: Optional[Sequence['outputs.SubmarinerStatusRouteAgentDaemonSetStatusStatusConditions']] = None,
                 number_available: Optional[int] = None,
                 number_unavailable: Optional[int] = None,
                 observed_generation: Optional[int] = None,
                 updated_number_scheduled: Optional[int] = None):
        """
        DaemonSetStatus represents the current status of a daemon set.
        :param int current_number_scheduled: The number of nodes that are running at least 1 daemon pod and are supposed to run the daemon pod. More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        :param int desired_number_scheduled: The total number of nodes that should be running the daemon pod (including nodes correctly running the daemon pod). More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        :param int number_misscheduled: The number of nodes that are running the daemon pod, but are not supposed to run the daemon pod. More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        :param int number_ready: The number of nodes that should be running the daemon pod and have one or more of the daemon pod running and ready.
        :param int collision_count: Count of hash collisions for the DaemonSet. The DaemonSet controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ControllerRevision.
        :param Sequence['SubmarinerStatusRouteAgentDaemonSetStatusStatusConditionsArgs'] conditions: Represents the latest available observations of a DaemonSet's current state.
        :param int number_available: The number of nodes that should be running the daemon pod and have one or more of the daemon pod running and available (ready for at least spec.minReadySeconds)
        :param int number_unavailable: The number of nodes that should be running the daemon pod and have none of the daemon pod running and available (ready for at least spec.minReadySeconds)
        :param int observed_generation: The most recent generation observed by the daemon set controller.
        :param int updated_number_scheduled: The total number of nodes that are running updated daemon pod
        """
        pulumi.set(__self__, "current_number_scheduled", current_number_scheduled)
        pulumi.set(__self__, "desired_number_scheduled", desired_number_scheduled)
        pulumi.set(__self__, "number_misscheduled", number_misscheduled)
        pulumi.set(__self__, "number_ready", number_ready)
        if collision_count is not None:
            pulumi.set(__self__, "collision_count", collision_count)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if number_available is not None:
            pulumi.set(__self__, "number_available", number_available)
        if number_unavailable is not None:
            pulumi.set(__self__, "number_unavailable", number_unavailable)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if updated_number_scheduled is not None:
            pulumi.set(__self__, "updated_number_scheduled", updated_number_scheduled)

    @property
    @pulumi.getter(name="currentNumberScheduled")
    def current_number_scheduled(self) -> int:
        """
        The number of nodes that are running at least 1 daemon pod and are supposed to run the daemon pod. More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        """
        return pulumi.get(self, "current_number_scheduled")

    @property
    @pulumi.getter(name="desiredNumberScheduled")
    def desired_number_scheduled(self) -> int:
        """
        The total number of nodes that should be running the daemon pod (including nodes correctly running the daemon pod). More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        """
        return pulumi.get(self, "desired_number_scheduled")

    @property
    @pulumi.getter(name="numberMisscheduled")
    def number_misscheduled(self) -> int:
        """
        The number of nodes that are running the daemon pod, but are not supposed to run the daemon pod. More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
        """
        return pulumi.get(self, "number_misscheduled")

    @property
    @pulumi.getter(name="numberReady")
    def number_ready(self) -> int:
        """
        The number of nodes that should be running the daemon pod and have one or more of the daemon pod running and ready.
        """
        return pulumi.get(self, "number_ready")

    @property
    @pulumi.getter(name="collisionCount")
    def collision_count(self) -> Optional[int]:
        """
        Count of hash collisions for the DaemonSet. The DaemonSet controller uses this field as a collision avoidance mechanism when it needs to create the name for the newest ControllerRevision.
        """
        return pulumi.get(self, "collision_count")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.SubmarinerStatusRouteAgentDaemonSetStatusStatusConditions']]:
        """
        Represents the latest available observations of a DaemonSet's current state.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="numberAvailable")
    def number_available(self) -> Optional[int]:
        """
        The number of nodes that should be running the daemon pod and have one or more of the daemon pod running and available (ready for at least spec.minReadySeconds)
        """
        return pulumi.get(self, "number_available")

    @property
    @pulumi.getter(name="numberUnavailable")
    def number_unavailable(self) -> Optional[int]:
        """
        The number of nodes that should be running the daemon pod and have none of the daemon pod running and available (ready for at least spec.minReadySeconds)
        """
        return pulumi.get(self, "number_unavailable")

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[int]:
        """
        The most recent generation observed by the daemon set controller.
        """
        return pulumi.get(self, "observed_generation")

    @property
    @pulumi.getter(name="updatedNumberScheduled")
    def updated_number_scheduled(self) -> Optional[int]:
        """
        The total number of nodes that are running updated daemon pod
        """
        return pulumi.get(self, "updated_number_scheduled")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubmarinerStatusRouteAgentDaemonSetStatusStatusConditions(dict):
    """
    DaemonSetCondition describes the state of a DaemonSet at a certain point.
    """
    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None):
        """
        DaemonSetCondition describes the state of a DaemonSet at a certain point.
        :param str status: Status of the condition, one of True, False, Unknown.
        :param str type: Type of DaemonSet condition.
        :param str last_transition_time: Last time the condition transitioned from one status to another.
        :param str message: A human readable message indicating details about the transition.
        :param str reason: The reason for the condition's last transition.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of DaemonSet condition.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        Last time the condition transitioned from one status to another.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        A human readable message indicating details about the transition.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        The reason for the condition's last transition.
        """
        return pulumi.get(self, "reason")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


