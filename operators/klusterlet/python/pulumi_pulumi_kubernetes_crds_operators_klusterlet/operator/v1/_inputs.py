# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from ... import _utilities, _tables

__all__ = [
    'KlusterletSpecArgs',
    'KlusterletSpecExternalServerURLsArgs',
    'KlusterletStatusArgs',
    'KlusterletStatusConditionsArgs',
    'KlusterletStatusGenerationsArgs',
    'KlusterletStatusRelatedResourcesArgs',
]

@pulumi.input_type
class KlusterletSpecArgs:
    def __init__(__self__, *,
                 cluster_name: Optional[pulumi.Input[str]] = None,
                 external_server_urls: Optional[pulumi.Input[Sequence[pulumi.Input['KlusterletSpecExternalServerURLsArgs']]]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 registration_image_pull_spec: Optional[pulumi.Input[str]] = None,
                 work_image_pull_spec: Optional[pulumi.Input[str]] = None):
        """
        Spec represents the desired deployment configuration of Klusterlet agent.
        :param pulumi.Input[str] cluster_name: ClusterName is the name of the managed cluster to be created on hub. The Klusterlet agent generates a random name if it is not set, or discovers the appropriate cluster name on openshift.
        :param pulumi.Input[Sequence[pulumi.Input['KlusterletSpecExternalServerURLsArgs']]] external_server_urls: ExternalServerURLs represents the a list of apiserver urls and ca bundles that is accessible externally If it is set empty, managed cluster has no externally accessible url that hub cluster can visit.
        :param pulumi.Input[str] namespace: Namespace is the namespace to deploy the agent. The namespace must have a prefix of "open-cluster-management-", and if it is not set, the namespace of "open-cluster-management-agent" is used to deploy agent.
        :param pulumi.Input[str] registration_image_pull_spec: RegistrationImagePullSpec represents the desired image configuration of registration agent.
        :param pulumi.Input[str] work_image_pull_spec: WorkImagePullSpec represents the desired image configuration of work agent.
        """
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if external_server_urls is not None:
            pulumi.set(__self__, "external_server_urls", external_server_urls)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if registration_image_pull_spec is not None:
            pulumi.set(__self__, "registration_image_pull_spec", registration_image_pull_spec)
        if work_image_pull_spec is not None:
            pulumi.set(__self__, "work_image_pull_spec", work_image_pull_spec)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[pulumi.Input[str]]:
        """
        ClusterName is the name of the managed cluster to be created on hub. The Klusterlet agent generates a random name if it is not set, or discovers the appropriate cluster name on openshift.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="externalServerURLs")
    def external_server_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KlusterletSpecExternalServerURLsArgs']]]]:
        """
        ExternalServerURLs represents the a list of apiserver urls and ca bundles that is accessible externally If it is set empty, managed cluster has no externally accessible url that hub cluster can visit.
        """
        return pulumi.get(self, "external_server_urls")

    @external_server_urls.setter
    def external_server_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KlusterletSpecExternalServerURLsArgs']]]]):
        pulumi.set(self, "external_server_urls", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace is the namespace to deploy the agent. The namespace must have a prefix of "open-cluster-management-", and if it is not set, the namespace of "open-cluster-management-agent" is used to deploy agent.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="registrationImagePullSpec")
    def registration_image_pull_spec(self) -> Optional[pulumi.Input[str]]:
        """
        RegistrationImagePullSpec represents the desired image configuration of registration agent.
        """
        return pulumi.get(self, "registration_image_pull_spec")

    @registration_image_pull_spec.setter
    def registration_image_pull_spec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "registration_image_pull_spec", value)

    @property
    @pulumi.getter(name="workImagePullSpec")
    def work_image_pull_spec(self) -> Optional[pulumi.Input[str]]:
        """
        WorkImagePullSpec represents the desired image configuration of work agent.
        """
        return pulumi.get(self, "work_image_pull_spec")

    @work_image_pull_spec.setter
    def work_image_pull_spec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "work_image_pull_spec", value)


@pulumi.input_type
class KlusterletSpecExternalServerURLsArgs:
    def __init__(__self__, *,
                 ca_bundle: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        ServerURL represents the apiserver url and ca bundle that is accessible externally
        :param pulumi.Input[str] ca_bundle: CABundle is the ca bundle to connect to apiserver of the managed cluster. System certs are used if it is not set.
        :param pulumi.Input[str] url: URL is the url of apiserver endpoint of the managed cluster.
        """
        if ca_bundle is not None:
            pulumi.set(__self__, "ca_bundle", ca_bundle)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="caBundle")
    def ca_bundle(self) -> Optional[pulumi.Input[str]]:
        """
        CABundle is the ca bundle to connect to apiserver of the managed cluster. System certs are used if it is not set.
        """
        return pulumi.get(self, "ca_bundle")

    @ca_bundle.setter
    def ca_bundle(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_bundle", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        URL is the url of apiserver endpoint of the managed cluster.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class KlusterletStatusArgs:
    def __init__(__self__, *,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['KlusterletStatusConditionsArgs']]]] = None,
                 generations: Optional[pulumi.Input[Sequence[pulumi.Input['KlusterletStatusGenerationsArgs']]]] = None,
                 observed_generation: Optional[pulumi.Input[int]] = None,
                 related_resources: Optional[pulumi.Input[Sequence[pulumi.Input['KlusterletStatusRelatedResourcesArgs']]]] = None):
        """
        Status represents the current status of Klusterlet agent.
        :param pulumi.Input[Sequence[pulumi.Input['KlusterletStatusConditionsArgs']]] conditions: Conditions contain the different condition statuses for this Klusterlet. Valid condition types are: Applied: components have been applied in the managed cluster. Available: components in the managed cluster are available and ready to serve. Progressing: components in the managed cluster are in a transitioning state. Degraded: components in the managed cluster do not match the desired configuration and only provide degraded service.
        :param pulumi.Input[Sequence[pulumi.Input['KlusterletStatusGenerationsArgs']]] generations: Generations are used to determine when an item needs to be reconciled or has changed in a way that needs a reaction.
        :param pulumi.Input[int] observed_generation: ObservedGeneration is the last generation change you've dealt with
        :param pulumi.Input[Sequence[pulumi.Input['KlusterletStatusRelatedResourcesArgs']]] related_resources: RelatedResources are used to track the resources that are related to this Klusterlet
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if generations is not None:
            pulumi.set(__self__, "generations", generations)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if related_resources is not None:
            pulumi.set(__self__, "related_resources", related_resources)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KlusterletStatusConditionsArgs']]]]:
        """
        Conditions contain the different condition statuses for this Klusterlet. Valid condition types are: Applied: components have been applied in the managed cluster. Available: components in the managed cluster are available and ready to serve. Progressing: components in the managed cluster are in a transitioning state. Degraded: components in the managed cluster do not match the desired configuration and only provide degraded service.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KlusterletStatusConditionsArgs']]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter
    def generations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KlusterletStatusGenerationsArgs']]]]:
        """
        Generations are used to determine when an item needs to be reconciled or has changed in a way that needs a reaction.
        """
        return pulumi.get(self, "generations")

    @generations.setter
    def generations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KlusterletStatusGenerationsArgs']]]]):
        pulumi.set(self, "generations", value)

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[pulumi.Input[int]]:
        """
        ObservedGeneration is the last generation change you've dealt with
        """
        return pulumi.get(self, "observed_generation")

    @observed_generation.setter
    def observed_generation(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "observed_generation", value)

    @property
    @pulumi.getter(name="relatedResources")
    def related_resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KlusterletStatusRelatedResourcesArgs']]]]:
        """
        RelatedResources are used to track the resources that are related to this Klusterlet
        """
        return pulumi.get(self, "related_resources")

    @related_resources.setter
    def related_resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KlusterletStatusRelatedResourcesArgs']]]]):
        pulumi.set(self, "related_resources", value)


@pulumi.input_type
class KlusterletStatusConditionsArgs:
    def __init__(__self__, *,
                 last_transition_time: pulumi.Input[str],
                 message: pulumi.Input[str],
                 reason: pulumi.Input[str],
                 status: pulumi.Input[str],
                 type: pulumi.Input[str],
                 observed_generation: Optional[pulumi.Input[int]] = None):
        """
        Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, type FooStatus struct{     // Represents the observations of a foo's current state.     // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"     // +patchMergeKey=type     // +patchStrategy=merge     // +listType=map     // +listMapKey=type     Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"` 
             // other fields }
        :param pulumi.Input[str] last_transition_time: lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
        :param pulumi.Input[str] message: message is a human readable message indicating details about the transition. This may be an empty string.
        :param pulumi.Input[str] reason: reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
        :param pulumi.Input[str] status: status of the condition, one of True, False, Unknown.
        :param pulumi.Input[str] type: type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
        :param pulumi.Input[int] observed_generation: observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
        """
        pulumi.set(__self__, "last_transition_time", last_transition_time)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "reason", reason)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> pulumi.Input[str]:
        """
        lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
        """
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def message(self) -> pulumi.Input[str]:
        """
        message is a human readable message indicating details about the transition. This may be an empty string.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: pulumi.Input[str]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def reason(self) -> pulumi.Input[str]:
        """
        reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: pulumi.Input[str]):
        pulumi.set(self, "reason", value)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        """
        status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[pulumi.Input[int]]:
        """
        observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
        """
        return pulumi.get(self, "observed_generation")

    @observed_generation.setter
    def observed_generation(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "observed_generation", value)


@pulumi.input_type
class KlusterletStatusGenerationsArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[str]] = None,
                 last_generation: Optional[pulumi.Input[int]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 resource: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        GenerationStatus keeps track of the generation for a given resource so that decisions about forced updates can be made. the definition matches the GenerationStatus defined in github.com/openshift/api/v1
        :param pulumi.Input[str] group: group is the group of the thing you're tracking
        :param pulumi.Input[int] last_generation: lastGeneration is the last generation of the thing that controller applies
        :param pulumi.Input[str] name: name is the name of the thing you're tracking
        :param pulumi.Input[str] namespace: namespace is where the thing you're tracking is
        :param pulumi.Input[str] resource: resource is the resource type of the thing you're tracking
        :param pulumi.Input[str] version: version is the version of the thing you're tracking
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if last_generation is not None:
            pulumi.set(__self__, "last_generation", last_generation)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        group is the group of the thing you're tracking
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter(name="lastGeneration")
    def last_generation(self) -> Optional[pulumi.Input[int]]:
        """
        lastGeneration is the last generation of the thing that controller applies
        """
        return pulumi.get(self, "last_generation")

    @last_generation.setter
    def last_generation(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "last_generation", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        name is the name of the thing you're tracking
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        namespace is where the thing you're tracking is
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def resource(self) -> Optional[pulumi.Input[str]]:
        """
        resource is the resource type of the thing you're tracking
        """
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        version is the version of the thing you're tracking
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class KlusterletStatusRelatedResourcesArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 resource: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        RelatedResourceMeta represents the resource that is managed by an operator
        :param pulumi.Input[str] group: group is the group of the thing you're tracking
        :param pulumi.Input[str] name: name is the name of the thing you're tracking
        :param pulumi.Input[str] namespace: namespace is where the thing you're tracking is
        :param pulumi.Input[str] resource: resource is the resource type of the thing you're tracking
        :param pulumi.Input[str] version: version is the version of the thing you're tracking
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        group is the group of the thing you're tracking
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        name is the name of the thing you're tracking
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        namespace is where the thing you're tracking is
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def resource(self) -> Optional[pulumi.Input[str]]:
        """
        resource is the resource type of the thing you're tracking
        """
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        version is the version of the thing you're tracking
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


