# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from ... import _utilities, _tables

__all__ = [
    'ResourceLockerSpecArgs',
    'ResourceLockerSpecPatchesArgs',
    'ResourceLockerSpecPatchesSourceObjectRefsArgs',
    'ResourceLockerSpecPatchesTargetObjectRefArgs',
    'ResourceLockerSpecResourcesArgs',
    'ResourceLockerSpecServiceAccountRefArgs',
    'ResourceLockerStatusArgs',
    'ResourceLockerStatusConditionsArgs',
    'ResourceLockerStatusLockedPatchStatusesArgs',
    'ResourceLockerStatusLockedResourceStatusesArgs',
]

@pulumi.input_type
class ResourceLockerSpecArgs:
    def __init__(__self__, *,
                 patches: Optional[pulumi.Input[Sequence[pulumi.Input['ResourceLockerSpecPatchesArgs']]]] = None,
                 resources: Optional[pulumi.Input[Sequence[pulumi.Input['ResourceLockerSpecResourcesArgs']]]] = None,
                 service_account_ref: Optional[pulumi.Input['ResourceLockerSpecServiceAccountRefArgs']] = None):
        """
        ResourceLockerSpec defines the desired state of ResourceLocker
        :param pulumi.Input[Sequence[pulumi.Input['ResourceLockerSpecPatchesArgs']]] patches: Patches is a list of patches that should be enforced at runtime.
        :param pulumi.Input[Sequence[pulumi.Input['ResourceLockerSpecResourcesArgs']]] resources: Resources is a list of resource manifests that should be locked into the specified configuration
        :param pulumi.Input['ResourceLockerSpecServiceAccountRefArgs'] service_account_ref: ServiceAccountRef is the service account to be used to run the controllers associated with this configuration kubebuilder:default:="{Name: &#34;default&#34;}"
        """
        if patches is not None:
            pulumi.set(__self__, "patches", patches)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if service_account_ref is not None:
            pulumi.set(__self__, "service_account_ref", service_account_ref)

    @property
    @pulumi.getter
    def patches(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ResourceLockerSpecPatchesArgs']]]]:
        """
        Patches is a list of patches that should be enforced at runtime.
        """
        return pulumi.get(self, "patches")

    @patches.setter
    def patches(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ResourceLockerSpecPatchesArgs']]]]):
        pulumi.set(self, "patches", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ResourceLockerSpecResourcesArgs']]]]:
        """
        Resources is a list of resource manifests that should be locked into the specified configuration
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ResourceLockerSpecResourcesArgs']]]]):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter(name="serviceAccountRef")
    def service_account_ref(self) -> Optional[pulumi.Input['ResourceLockerSpecServiceAccountRefArgs']]:
        """
        ServiceAccountRef is the service account to be used to run the controllers associated with this configuration kubebuilder:default:="{Name: &#34;default&#34;}"
        """
        return pulumi.get(self, "service_account_ref")

    @service_account_ref.setter
    def service_account_ref(self, value: Optional[pulumi.Input['ResourceLockerSpecServiceAccountRefArgs']]):
        pulumi.set(self, "service_account_ref", value)


@pulumi.input_type
class ResourceLockerSpecPatchesArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 patch_template: pulumi.Input[str],
                 target_object_ref: pulumi.Input['ResourceLockerSpecPatchesTargetObjectRefArgs'],
                 patch_type: Optional[pulumi.Input[str]] = None,
                 source_object_refs: Optional[pulumi.Input[Sequence[pulumi.Input['ResourceLockerSpecPatchesSourceObjectRefsArgs']]]] = None):
        """
        Patch describe a patch to be enforced at runtime
        :param pulumi.Input[str] id: ID represent a unique identifier for the patch in the array of patches oc this CR
        :param pulumi.Input[str] patch_template: PatchTemplate is a go template that will be resolved using the SourceObjectRefs as parameters. The result must be a valid patch based on the patch type and the target object.
        :param pulumi.Input['ResourceLockerSpecPatchesTargetObjectRefArgs'] target_object_ref: TargetObjectRef is a reference to the object to which the patch should be applied.
        :param pulumi.Input[str] patch_type: PatchType is the type of patch to be applied, one of "application/json-patch+json"'"application/merge-patch+json","application/strategic-merge-patch+json","application/apply-patch+yaml" kubebuilder:default:="application/strategic-merge-patch+json"
        :param pulumi.Input[Sequence[pulumi.Input['ResourceLockerSpecPatchesSourceObjectRefsArgs']]] source_object_refs: SourceObject refs is an array of references to source objects that will be used as input for the template processing
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "patch_template", patch_template)
        pulumi.set(__self__, "target_object_ref", target_object_ref)
        if patch_type is not None:
            pulumi.set(__self__, "patch_type", patch_type)
        if source_object_refs is not None:
            pulumi.set(__self__, "source_object_refs", source_object_refs)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        ID represent a unique identifier for the patch in the array of patches oc this CR
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="patchTemplate")
    def patch_template(self) -> pulumi.Input[str]:
        """
        PatchTemplate is a go template that will be resolved using the SourceObjectRefs as parameters. The result must be a valid patch based on the patch type and the target object.
        """
        return pulumi.get(self, "patch_template")

    @patch_template.setter
    def patch_template(self, value: pulumi.Input[str]):
        pulumi.set(self, "patch_template", value)

    @property
    @pulumi.getter(name="targetObjectRef")
    def target_object_ref(self) -> pulumi.Input['ResourceLockerSpecPatchesTargetObjectRefArgs']:
        """
        TargetObjectRef is a reference to the object to which the patch should be applied.
        """
        return pulumi.get(self, "target_object_ref")

    @target_object_ref.setter
    def target_object_ref(self, value: pulumi.Input['ResourceLockerSpecPatchesTargetObjectRefArgs']):
        pulumi.set(self, "target_object_ref", value)

    @property
    @pulumi.getter(name="patchType")
    def patch_type(self) -> Optional[pulumi.Input[str]]:
        """
        PatchType is the type of patch to be applied, one of "application/json-patch+json"'"application/merge-patch+json","application/strategic-merge-patch+json","application/apply-patch+yaml" kubebuilder:default:="application/strategic-merge-patch+json"
        """
        return pulumi.get(self, "patch_type")

    @patch_type.setter
    def patch_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "patch_type", value)

    @property
    @pulumi.getter(name="sourceObjectRefs")
    def source_object_refs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ResourceLockerSpecPatchesSourceObjectRefsArgs']]]]:
        """
        SourceObject refs is an array of references to source objects that will be used as input for the template processing
        """
        return pulumi.get(self, "source_object_refs")

    @source_object_refs.setter
    def source_object_refs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ResourceLockerSpecPatchesSourceObjectRefsArgs']]]]):
        pulumi.set(self, "source_object_refs", value)


@pulumi.input_type
class ResourceLockerSpecPatchesSourceObjectRefsArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 field_path: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 resource_version: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        ObjectReference contains enough information to let you inspect or modify the referred object. --- New uses of this type are discouraged because of difficulty describing its usage when embedded in APIs.  1. Ignored fields.  It includes many fields which are not generally honored.  For instance, ResourceVersion and FieldPath are both very rarely valid in actual usage.  2. Invalid usage help.  It is impossible to add specific help for individual usage.  In most embedded usages, there are particular     restrictions like, "must refer only to types A and B" or "UID not honored" or "name must be restricted".     Those cannot be well described when embedded.  3. Inconsistent validation.  Because the usages are different, the validation rules are different by usage, which makes it hard for users to predict what will happen.  4. The fields are both imprecise and overly precise.  Kind is not a precise mapping to a URL. This can produce ambiguity     during interpretation and require a REST mapping.  In most cases, the dependency is on the group,resource tuple     and the version of the actual struct is irrelevant.  5. We cannot easily change it.  Because this type is embedded in many locations, updates to this type     will affect numerous schemas.  Don't make new APIs embed an underspecified API type they do not control. Instead of using this type, create a locally provided and used type that is well-focused on your reference. For example, ServiceReferences for admission registration: https://github.com/kubernetes/api/blob/release-1.17/admissionregistration/v1/types.go#L533 .
        :param pulumi.Input[str] api_version: API version of the referent.
        :param pulumi.Input[str] field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param pulumi.Input[str] kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param pulumi.Input[str] namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param pulumi.Input[str] resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param pulumi.Input[str] uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[pulumi.Input[str]]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_path", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @resource_version.setter
    def resource_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_version", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class ResourceLockerSpecPatchesTargetObjectRefArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 field_path: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 resource_version: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        TargetObjectRef is a reference to the object to which the patch should be applied.
        :param pulumi.Input[str] api_version: API version of the referent.
        :param pulumi.Input[str] field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param pulumi.Input[str] kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param pulumi.Input[str] namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param pulumi.Input[str] resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param pulumi.Input[str] uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[pulumi.Input[str]]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_path", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @resource_version.setter
    def resource_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_version", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class ResourceLockerSpecResourcesArgs:
    def __init__(__self__, *,
                 object: pulumi.Input[Mapping[str, Any]],
                 excluded_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Resource represent a resource to be enforced
        """
        pulumi.set(__self__, "object", object)
        if excluded_paths is not None:
            pulumi.set(__self__, "excluded_paths", excluded_paths)

    @property
    @pulumi.getter
    def object(self) -> pulumi.Input[Mapping[str, Any]]:
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: pulumi.Input[Mapping[str, Any]]):
        pulumi.set(self, "object", value)

    @property
    @pulumi.getter(name="excludedPaths")
    def excluded_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_paths")

    @excluded_paths.setter
    def excluded_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_paths", value)


@pulumi.input_type
class ResourceLockerSpecServiceAccountRefArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        ServiceAccountRef is the service account to be used to run the controllers associated with this configuration kubebuilder:default:="{Name: &#34;default&#34;}"
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class ResourceLockerStatusArgs:
    def __init__(__self__, *,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['ResourceLockerStatusConditionsArgs']]]] = None,
                 locked_patch_statuses: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input['ResourceLockerStatusLockedPatchStatusesArgs']]]]]] = None,
                 locked_resource_statuses: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input['ResourceLockerStatusLockedResourceStatusesArgs']]]]]] = None):
        """
        ResourceLockerStatus defines the observed state of ResourceLocker
        :param pulumi.Input[Sequence[pulumi.Input['ResourceLockerStatusConditionsArgs']]] conditions: ReconcileStatus this is the general status of the main reconciler
        :param pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input['ResourceLockerStatusLockedPatchStatusesArgs']]]]] locked_patch_statuses: LockedResourceStatuses contains the reconcile status for each of the managed resources
        :param pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input['ResourceLockerStatusLockedResourceStatusesArgs']]]]] locked_resource_statuses: LockedResourceStatuses contains the reconcile status for each of the managed resources
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if locked_patch_statuses is not None:
            pulumi.set(__self__, "locked_patch_statuses", locked_patch_statuses)
        if locked_resource_statuses is not None:
            pulumi.set(__self__, "locked_resource_statuses", locked_resource_statuses)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ResourceLockerStatusConditionsArgs']]]]:
        """
        ReconcileStatus this is the general status of the main reconciler
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ResourceLockerStatusConditionsArgs']]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="lockedPatchStatuses")
    def locked_patch_statuses(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input['ResourceLockerStatusLockedPatchStatusesArgs']]]]]]:
        """
        LockedResourceStatuses contains the reconcile status for each of the managed resources
        """
        return pulumi.get(self, "locked_patch_statuses")

    @locked_patch_statuses.setter
    def locked_patch_statuses(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input['ResourceLockerStatusLockedPatchStatusesArgs']]]]]]):
        pulumi.set(self, "locked_patch_statuses", value)

    @property
    @pulumi.getter(name="lockedResourceStatuses")
    def locked_resource_statuses(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input['ResourceLockerStatusLockedResourceStatusesArgs']]]]]]:
        """
        LockedResourceStatuses contains the reconcile status for each of the managed resources
        """
        return pulumi.get(self, "locked_resource_statuses")

    @locked_resource_statuses.setter
    def locked_resource_statuses(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input['ResourceLockerStatusLockedResourceStatusesArgs']]]]]]):
        pulumi.set(self, "locked_resource_statuses", value)


@pulumi.input_type
class ResourceLockerStatusConditionsArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[str],
                 type: pulumi.Input[str],
                 last_transition_time: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None):
        """
        Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
         Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
        :param pulumi.Input[str] type: ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
                Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        :param pulumi.Input[str] reason: ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
         Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)


@pulumi.input_type
class ResourceLockerStatusLockedPatchStatusesArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[str],
                 type: pulumi.Input[str],
                 last_transition_time: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None):
        """
        Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
         Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
        :param pulumi.Input[str] type: ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
                Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        :param pulumi.Input[str] reason: ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
         Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)


@pulumi.input_type
class ResourceLockerStatusLockedResourceStatusesArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[str],
                 type: pulumi.Input[str],
                 last_transition_time: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None):
        """
        Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
         Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
        :param pulumi.Input[str] type: ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
                Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        :param pulumi.Input[str] reason: ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
         Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)


