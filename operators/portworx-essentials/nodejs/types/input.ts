// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

import {ObjectMeta} from "../meta/v1";

export namespace core {
    export namespace v1alpha1 {
        /**
         * The desired behavior of the storage cluster.
         */
        export interface StorageClusterSpec {
            /**
             * Contains spec of autopilot component for storage driver.
             */
            autopilot?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecAutopilot>;
            /**
             * Details of storage used in cloud environment.
             */
            cloudStorage?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecCloudStorage>;
            /**
             * Custom container image registry server that will be used instead of index.docker.io to download Docker images. This may include the repository as well. (Example: myregistry.net:5443 or myregistry.com/myrepository)
             */
            customImageRegistry?: pulumi.Input<string>;
            /**
             * Delete strategy to uninstall and wipe the storage cluster.
             */
            deleteStrategy?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecDeleteStrategy>;
            /**
             * List of environment variables used by the driver. This is an array of Kubernetes EnvVar where the value can be given directly or from a source like field, config map or secret.
             */
            env?: pulumi.Input<pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecEnv>[]>;
            /**
             * This is a map of feature names to string values.
             */
            featureGates?: pulumi.Input<{[key: string]: any}>;
            /**
             * Docker image of the storage driver.
             */
            image?: pulumi.Input<string>;
            /**
             * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always.
             */
            imagePullPolicy?: pulumi.Input<string>;
            /**
             * Image pull secret is a reference to secret in the same namespace as the StorageCluster. It is used for pulling all images used by the StorageCluster.
             */
            imagePullSecret?: pulumi.Input<string>;
            /**
             * Details of KVDB that the storage driver will use.
             */
            kvdb?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecKvdb>;
            /**
             * Contains monitoring configuration for the storage cluster.
             */
            monitoring?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecMonitoring>;
            /**
             * Contains network information that is needed by the storage driver.
             */
            network?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecNetwork>;
            /**
             * Node level configurations that will override the configuration at cluster level. These configurations can be for individual nodes or can be grouped to override configuration of multiple nodes based on label selectors.
             */
            nodes?: pulumi.Input<pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecNodes>[]>;
            /**
             * Describes placement configuration for the storage cluster pods.
             */
            placement?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecPlacement>;
            /**
             * The number of old history to retain to allow rollback. This is a pointer to distinguish between an explicit zero and not specified. Defaults to 10.
             */
            revisionHistoryLimit?: pulumi.Input<number>;
            /**
             * This is map of any runtime options that need to be sent to the storage driver. The value is a string.
             */
            runtimeOptions?: pulumi.Input<{[key: string]: any}>;
            /**
             * Secrets provider is the name of secret provider that driver will connect to.
             */
            secretsProvider?: pulumi.Input<string>;
            /**
             * Start port is the starting port in the range of ports used by the cluster.
             */
            startPort?: pulumi.Input<number>;
            /**
             * Details of the storage used by the storage driver.
             */
            storage?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecStorage>;
            /**
             * Contains STORK related spec.
             */
            stork?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecStork>;
            /**
             * An update strategy to replace existing StorageCluster pods with new pods.
             */
            updateStrategy?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecUpdateStrategy>;
            /**
             * Contains spec of a user interface for the storage driver.
             */
            userInterface?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecUserInterface>;
            /**
             * Version of the storage driver. This field is read-only.
             */
            version?: pulumi.Input<string>;
        }

        /**
         * Contains spec of autopilot component for storage driver.
         */
        export interface StorageClusterSpecAutopilot {
            /**
             * It is a map of arguments provided to autopilot. Example: log-level: debug
             */
            args?: pulumi.Input<{[key: string]: any}>;
            /**
             * Flag indicating whether autopilot needs to be enabled.
             */
            enabled?: pulumi.Input<boolean>;
            /**
             * List of environment variables used by autopilot. This is an array of Kubernetes EnvVar where the value can be given directly or from a source like field, config map or secret.
             */
            env?: pulumi.Input<pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecAutopilotEnv>[]>;
            /**
             * Docker image of the autopilot container.
             */
            image?: pulumi.Input<string>;
            /**
             * Flag indicating if the autopilot image needs to be locked to the given image. If the image is not locked, it can be updated by the storage driver during upgrades.
             */
            lockImage?: pulumi.Input<boolean>;
            /**
             * List of input data providers to autopilot.
             */
            providers?: pulumi.Input<pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecAutopilotProviders>[]>;
        }

        export interface StorageClusterSpecAutopilotEnv {
            name?: pulumi.Input<string>;
            value?: pulumi.Input<string>;
            valueFrom?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecAutopilotEnvValueFrom>;
        }

        export interface StorageClusterSpecAutopilotEnvValueFrom {
            configMapKeyRef?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecAutopilotEnvValueFromConfigMapKeyRef>;
            fieldRef?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecAutopilotEnvValueFromFieldRef>;
            resourceFieldRef?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecAutopilotEnvValueFromResourceFieldRef>;
            secretKeyRef?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecAutopilotEnvValueFromSecretKeyRef>;
        }

        export interface StorageClusterSpecAutopilotEnvValueFromConfigMapKeyRef {
            key?: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface StorageClusterSpecAutopilotEnvValueFromFieldRef {
            apiVersion?: pulumi.Input<string>;
            fieldPath?: pulumi.Input<string>;
        }

        export interface StorageClusterSpecAutopilotEnvValueFromResourceFieldRef {
            containerName?: pulumi.Input<string>;
            divisor?: pulumi.Input<string>;
            resource?: pulumi.Input<string>;
        }

        export interface StorageClusterSpecAutopilotEnvValueFromSecretKeyRef {
            key?: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface StorageClusterSpecAutopilotProviders {
            /**
             * Unique name of the data provider.
             */
            name?: pulumi.Input<string>;
            /**
             * Map of key-value params for the provider.
             */
            params?: pulumi.Input<{[key: string]: any}>;
            /**
             * Type of the data provider. For instance - prometheus
             */
            type?: pulumi.Input<string>;
        }

        /**
         * Details of storage used in cloud environment.
         */
        export interface StorageClusterSpecCloudStorage {
            /**
             * List of cluster wide storage types and their capacities. A single capacity spec identifies a storage pool with a set of minimum requested IOPS and size. Based on the cloud provider, the total storage capacity will get divided amongst the nodes. The nodes bearing storage themselves will get uniformly distributed across all the zones.
             */
            capacitySpecs?: pulumi.Input<pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecCloudStorageCapacitySpecs>[]>;
            /**
             * List of storage device specs. A cloud storage device will be created for every spec in the list. The specs will be applied to all nodes in the cluster up to spec.cloudStorage.maxStorageNodes or spec.cloudStorage.maxStorageNodesPerZone. This will be ignored if spec.cloudStorage.capacitySpecs is present.
             */
            deviceSpecs?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Device spec for the journal device.
             */
            journalDeviceSpec?: pulumi.Input<string>;
            /**
             * Device spec for internal KVDB device.
             */
            kvdbDeviceSpec?: pulumi.Input<string>;
            /**
             * Maximum nodes that will have storage in the cluster.
             */
            maxStorageNodes?: pulumi.Input<number>;
            /**
             * Maximum nodes in every zone that will have storage in the cluster.
             */
            maxStorageNodesPerZone?: pulumi.Input<number>;
            /**
             * Device spec for the metadata device. This device will be used to store system metadata by the driver.
             */
            systemMetadataDeviceSpec?: pulumi.Input<string>;
        }

        export interface StorageClusterSpecCloudStorageCapacitySpecs {
            /**
             * Maximum capacity for this storage cluster. The total capacity of devices created by this capacity spec should not be greater than this number for the entire cluster.
             */
            maxCapacityInGiB?: pulumi.Input<number>;
            /**
             * Minimum capacity for this storage cluster. The total capacity of devices created by this capacity spec should not be less than this number for the entire cluster.
             */
            minCapacityInGiB?: pulumi.Input<number>;
            /**
             * Minimum IOPS expected from the cloud drive.
             */
            minIOPS?: pulumi.Input<number>;
            /**
             * Additional options required to provision the drive in cloud.
             */
            options?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Delete strategy to uninstall and wipe the storage cluster.
         */
        export interface StorageClusterSpecDeleteStrategy {
            /**
             * Type of storage cluster delete. Can be Uninstall or UninstallAndWipe. There is no default delete strategy. When no delete strategy only objects managed by the StorageCluster controller and owned by the StorageCluster object are deleted. The storage driver will be left in a state where it will not be managed by any object. Uninstall strategy ensures that the cluster is completely uninstalled even from the storage driver perspective. UninstallAndWipe strategy ensures that the cluster is completely uninstalled as well as the storage devices and metadata are wiped for reuse. This may result in data loss.
             */
            type?: pulumi.Input<string>;
        }

        export interface StorageClusterSpecEnv {
            name?: pulumi.Input<string>;
            value?: pulumi.Input<string>;
            valueFrom?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecEnvValueFrom>;
        }

        export interface StorageClusterSpecEnvValueFrom {
            configMapKeyRef?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecEnvValueFromConfigMapKeyRef>;
            fieldRef?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecEnvValueFromFieldRef>;
            resourceFieldRef?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecEnvValueFromResourceFieldRef>;
            secretKeyRef?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecEnvValueFromSecretKeyRef>;
        }

        export interface StorageClusterSpecEnvValueFromConfigMapKeyRef {
            key?: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface StorageClusterSpecEnvValueFromFieldRef {
            apiVersion?: pulumi.Input<string>;
            fieldPath?: pulumi.Input<string>;
        }

        export interface StorageClusterSpecEnvValueFromResourceFieldRef {
            containerName?: pulumi.Input<string>;
            divisor?: pulumi.Input<string>;
            resource?: pulumi.Input<string>;
        }

        export interface StorageClusterSpecEnvValueFromSecretKeyRef {
            key?: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        /**
         * Details of KVDB that the storage driver will use.
         */
        export interface StorageClusterSpecKvdb {
            /**
             * Authentication secret is the name of Kubernetes secret containing information to authenticate with the external KVDB. It could have the username/password for basic auth, certificate information or an ACL token.
             */
            authSecret?: pulumi.Input<string>;
            /**
             * If using external KVDB, this is the list of KVDB endpoints.
             */
            endpoints?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Flag indicating whether to use internal KVDB or an external KVDB.
             */
            internal?: pulumi.Input<boolean>;
        }

        /**
         * Contains monitoring configuration for the storage cluster.
         */
        export interface StorageClusterSpecMonitoring {
            /**
             * If this flag is enabled it will expose the storage cluster metrics to external monitoring solutions like Prometheus. DEPRECATED - use prometheus.exportMetrics instead
             */
            enableMetrics?: pulumi.Input<boolean>;
            /**
             * Contains configuration of Prometheus to monitor the storage cluster.
             */
            prometheus?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecMonitoringPrometheus>;
        }

        /**
         * Contains configuration of Prometheus to monitor the storage cluster.
         */
        export interface StorageClusterSpecMonitoringPrometheus {
            /**
             * Flag indicating whether Prometheus stack needs to be enabled and deployed by the Storage operator.
             */
            enabled?: pulumi.Input<boolean>;
            /**
             * If this flag is enabled it will expose the storage cluster metrics to Prometheus.
             */
            exportMetrics?: pulumi.Input<boolean>;
            /**
             * Specifies the remote write endpoint for Prometheus.
             */
            remoteWriteEndpoint?: pulumi.Input<string>;
        }

        /**
         * Contains network information that is needed by the storage driver.
         */
        export interface StorageClusterSpecNetwork {
            /**
             * Name of the network interface used by the storage driver for data traffic.
             */
            dataInterface?: pulumi.Input<string>;
            /**
             * Name of the network interface used by the storage driver for management traffic.
             */
            mgmtInterface?: pulumi.Input<string>;
        }

        export interface StorageClusterSpecNodes {
            /**
             * List of environment variables used by the driver. This is an array of Kubernetes EnvVar where the value can be given directly or from a source like field, config map or secret. Environment variables specified here at the node level will be merged with the ones present in cluster configuration and sent to the nodes. If there is duplicate, the node level value will take precedence.
             */
            env?: pulumi.Input<pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecNodesEnv>[]>;
            /**
             * Contains network information that is needed by the storage driver.
             */
            network?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecNodesNetwork>;
            /**
             * This is map of any runtime options that need to be sent to the storage driver. The value is a string. If runtime options are present here at node level, they will override the ones from cluster configuration.
             */
            runtimeOptions?: pulumi.Input<{[key: string]: any}>;
            /**
             * Configuration in this node block is applied to nodes based on this selector. Use either nodeName of labelSelector, not both. If nodeName is used, labelSelector will be ignored.
             */
            selector?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecNodesSelector>;
            /**
             * Details of the storage used by the storage driver.
             */
            storage?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecNodesStorage>;
        }

        export interface StorageClusterSpecNodesEnv {
            name?: pulumi.Input<string>;
            value?: pulumi.Input<string>;
            valueFrom?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecNodesEnvValueFrom>;
        }

        export interface StorageClusterSpecNodesEnvValueFrom {
            configMapKeyRef?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecNodesEnvValueFromConfigMapKeyRef>;
            fieldRef?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecNodesEnvValueFromFieldRef>;
            resourceFieldRef?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecNodesEnvValueFromResourceFieldRef>;
            secretKeyRef?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecNodesEnvValueFromSecretKeyRef>;
        }

        export interface StorageClusterSpecNodesEnvValueFromConfigMapKeyRef {
            key?: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface StorageClusterSpecNodesEnvValueFromFieldRef {
            apiVersion?: pulumi.Input<string>;
            fieldPath?: pulumi.Input<string>;
        }

        export interface StorageClusterSpecNodesEnvValueFromResourceFieldRef {
            containerName?: pulumi.Input<string>;
            divisor?: pulumi.Input<string>;
            resource?: pulumi.Input<string>;
        }

        export interface StorageClusterSpecNodesEnvValueFromSecretKeyRef {
            key?: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        /**
         * Contains network information that is needed by the storage driver.
         */
        export interface StorageClusterSpecNodesNetwork {
            /**
             * Name of the network interface used by the storage driver for data traffic.
             */
            dataInterface?: pulumi.Input<string>;
            /**
             * Name of the network interface used by the storage driver for management traffic.
             */
            mgmtInterface?: pulumi.Input<string>;
        }

        /**
         * Configuration in this node block is applied to nodes based on this selector. Use either nodeName of labelSelector, not both. If nodeName is used, labelSelector will be ignored.
         */
        export interface StorageClusterSpecNodesSelector {
            /**
             * It is a label query over all the nodes. The result of matchLabels and matchExpressions is ANDed. An empty label selector matches all nodes. A null label selector matches no objects.
             */
            labelSelector?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecNodesSelectorLabelSelector>;
            /**
             * Name of the Kubernetes node that is to be selected. If present then the labelSelector is ignored even if the node with the given name is absent and the labelSelector matches another node.
             */
            nodeName?: pulumi.Input<string>;
        }

        /**
         * It is a label query over all the nodes. The result of matchLabels and matchExpressions is ANDed. An empty label selector matches all nodes. A null label selector matches no objects.
         */
        export interface StorageClusterSpecNodesSelectorLabelSelector {
            /**
             * It is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecNodesSelectorLabelSelectorMatchExpressions>[]>;
            /**
             * It is a map of key-value pairs. A single key-value in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface StorageClusterSpecNodesSelectorLabelSelectorMatchExpressions {
            /**
             * It is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * It represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * It is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Details of the storage used by the storage driver.
         */
        export interface StorageClusterSpecNodesStorage {
            /**
             * List of devices to be used by the storage driver.
             */
            devices?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Flag indicating to use the devices even if there is file system present on it. Note that the devices may be wiped before using.
             */
            forceUseDisks?: pulumi.Input<boolean>;
            /**
             * Device used for journaling.
             */
            journalDevice?: pulumi.Input<string>;
            /**
             * Device used for internal KVDB.
             */
            kvdbDevice?: pulumi.Input<string>;
            /**
             * Device that will be used to store system metadata by the driver.
             */
            systemMetadataDevice?: pulumi.Input<string>;
            /**
             * Use all available, unformatted, unpartitioned devices. This will be ignored if spec.storage.devices is not empty.
             */
            useAll?: pulumi.Input<boolean>;
            /**
             * Use all available unformatted devices. This will be ignored if spec.storage.devices is not empty.
             */
            useAllWithPartitions?: pulumi.Input<boolean>;
        }

        /**
         * Describes placement configuration for the storage cluster pods.
         */
        export interface StorageClusterSpecPlacement {
            /**
             * Describes node affinity scheduling rules for the storage cluster pods. This is exactly the same object as Kubernetes node affinity for pods.
             */
            nodeAffinity?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecPlacementNodeAffinity>;
            /**
             * Tolerations for all the pods deployed by the StorageCluster controller. The pod with this toleration attached will tolerate any taint that matches the triple <key,value,effect> using the matching operator <operator>.
             */
            tolerations?: pulumi.Input<pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecPlacementTolerations>[]>;
        }

        /**
         * Describes node affinity scheduling rules for the storage cluster pods. This is exactly the same object as Kubernetes node affinity for pods.
         */
        export interface StorageClusterSpecPlacementNodeAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>;
        }

        export interface StorageClusterSpecPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference>;
            weight: pulumi.Input<number>;
        }

        export interface StorageClusterSpecPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>[]>;
        }

        export interface StorageClusterSpecPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface StorageClusterSpecPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface StorageClusterSpecPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            nodeSelectorTerms: pulumi.Input<pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>[]>;
        }

        export interface StorageClusterSpecPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>[]>;
        }

        export interface StorageClusterSpecPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface StorageClusterSpecPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface StorageClusterSpecPlacementTolerations {
            /**
             * Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
             */
            effect?: pulumi.Input<string>;
            /**
             * Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
             */
            key?: pulumi.Input<string>;
            /**
             * Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
             */
            operator?: pulumi.Input<string>;
            /**
             * TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
             */
            tolerationSeconds?: pulumi.Input<number>;
            /**
             * Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * Details of the storage used by the storage driver.
         */
        export interface StorageClusterSpecStorage {
            /**
             * List of devices to be used by the storage driver.
             */
            devices?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Flag indicating to use the devices even if there is file system present on it. Note that the devices may be wiped before using.
             */
            forceUseDisks?: pulumi.Input<boolean>;
            /**
             * Device used for journaling.
             */
            journalDevice?: pulumi.Input<string>;
            /**
             * Device used for internal KVDB.
             */
            kvdbDevice?: pulumi.Input<string>;
            /**
             * Device that will be used to store system metadata by the driver.
             */
            systemMetadataDevice?: pulumi.Input<string>;
            /**
             * Use all available, unformatted, unpartitioned devices. This will be ignored if spec.storage.devices is not empty.
             */
            useAll?: pulumi.Input<boolean>;
            /**
             * Use all available unformatted devices. This will be ignored if spec.storage.devices is not empty.
             */
            useAllWithPartitions?: pulumi.Input<boolean>;
        }

        /**
         * Contains STORK related spec.
         */
        export interface StorageClusterSpecStork {
            /**
             * It is map of arguments given to STORK. Example: driver: pxd
             */
            args?: pulumi.Input<{[key: string]: any}>;
            /**
             * Flag indicating whether STORK needs to be enabled.
             */
            enabled?: pulumi.Input<boolean>;
            /**
             * List of environment variables used by STORK. This is an array of Kubernetes EnvVar where the value can be given directly or from a source like field, config map or secret.
             */
            env?: pulumi.Input<pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecStorkEnv>[]>;
            /**
             * Docker image of the STORK container.
             */
            image?: pulumi.Input<string>;
            /**
             * Flag indicating if the STORK image needs to be locked to the given image. If the image is not locked, it can be updated by the storage driver during upgrades.
             */
            lockImage?: pulumi.Input<boolean>;
        }

        export interface StorageClusterSpecStorkEnv {
            name?: pulumi.Input<string>;
            value?: pulumi.Input<string>;
            valueFrom?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecStorkEnvValueFrom>;
        }

        export interface StorageClusterSpecStorkEnvValueFrom {
            configMapKeyRef?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecStorkEnvValueFromConfigMapKeyRef>;
            fieldRef?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecStorkEnvValueFromFieldRef>;
            resourceFieldRef?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecStorkEnvValueFromResourceFieldRef>;
            secretKeyRef?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecStorkEnvValueFromSecretKeyRef>;
        }

        export interface StorageClusterSpecStorkEnvValueFromConfigMapKeyRef {
            key?: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface StorageClusterSpecStorkEnvValueFromFieldRef {
            apiVersion?: pulumi.Input<string>;
            fieldPath?: pulumi.Input<string>;
        }

        export interface StorageClusterSpecStorkEnvValueFromResourceFieldRef {
            containerName?: pulumi.Input<string>;
            divisor?: pulumi.Input<string>;
            resource?: pulumi.Input<string>;
        }

        export interface StorageClusterSpecStorkEnvValueFromSecretKeyRef {
            key?: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        /**
         * An update strategy to replace existing StorageCluster pods with new pods.
         */
        export interface StorageClusterSpecUpdateStrategy {
            /**
             * Spec to control the desired behavior of storage cluster rolling update.
             */
            rollingUpdate?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecUpdateStrategyRollingUpdate>;
            /**
             * Type of storage cluster update. Can be RollingUpdate or OnDelete. Default is RollingUpdate.
             */
            type?: pulumi.Input<string>;
        }

        /**
         * Spec to control the desired behavior of storage cluster rolling update.
         */
        export interface StorageClusterSpecUpdateStrategyRollingUpdate {
            /**
             * The maximum number of StorageCluster pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of total number of StorageCluster pods at the start of the update (ex: 10%). Absolute number is calculated from percentage by rounding up. This cannot be 0. Default value is 1. Example: when this is set to 30%, at most 30% of the total number of nodes that should be running the storage pod can have their pods stopped for an update at any given time. The update starts by stopping at most 30% of those StorageCluster pods and then brings up new StorageCluster pods in their place. Once the new pods are available, it then proceeds onto other StorageCluster pods, thus ensuring that at least 70% of original number of StorageCluster pods are available at all times during the update.
             */
            maxUnavailable?: pulumi.Input<number | string>;
        }

        /**
         * Contains spec of a user interface for the storage driver.
         */
        export interface StorageClusterSpecUserInterface {
            /**
             * Flag indicating whether the user interface needs to be enabled.
             */
            enabled?: pulumi.Input<boolean>;
            /**
             * List of environment variables used by the UI components. This is an array of Kubernetes EnvVar where the value can be given directly or from a source like field, config map or secret.
             */
            env?: pulumi.Input<pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecUserInterfaceEnv>[]>;
            /**
             * Docker image of the user interface container.
             */
            image?: pulumi.Input<string>;
            /**
             * Flag indicating if the user interface image needs to be locked to the given image. If the image is not locked, it can be updated by the storage driver during upgrades.
             */
            lockImage?: pulumi.Input<boolean>;
        }

        export interface StorageClusterSpecUserInterfaceEnv {
            name?: pulumi.Input<string>;
            value?: pulumi.Input<string>;
            valueFrom?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecUserInterfaceEnvValueFrom>;
        }

        export interface StorageClusterSpecUserInterfaceEnvValueFrom {
            configMapKeyRef?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecUserInterfaceEnvValueFromConfigMapKeyRef>;
            fieldRef?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecUserInterfaceEnvValueFromFieldRef>;
            resourceFieldRef?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecUserInterfaceEnvValueFromResourceFieldRef>;
            secretKeyRef?: pulumi.Input<inputs.core.v1alpha1.StorageClusterSpecUserInterfaceEnvValueFromSecretKeyRef>;
        }

        export interface StorageClusterSpecUserInterfaceEnvValueFromConfigMapKeyRef {
            key?: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface StorageClusterSpecUserInterfaceEnvValueFromFieldRef {
            apiVersion?: pulumi.Input<string>;
            fieldPath?: pulumi.Input<string>;
        }

        export interface StorageClusterSpecUserInterfaceEnvValueFromResourceFieldRef {
            containerName?: pulumi.Input<string>;
            divisor?: pulumi.Input<string>;
            resource?: pulumi.Input<string>;
        }

        export interface StorageClusterSpecUserInterfaceEnvValueFromSecretKeyRef {
            key?: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        /**
         * Most recently observed status of the storage cluster. This data may not be up to date.
         */
        export interface StorageClusterStatus {
            /**
             * Name of the storage cluster.
             */
            clusterName?: pulumi.Input<string>;
            /**
             * Unique ID of the storage cluster.
             */
            clusterUid?: pulumi.Input<string>;
            /**
             * Count of hash collisions for the StorageCluster. The StorageCluster controller uses this field as a collision avoidance mechanism when it needs to create the name of the newest ControllerRevision.
             */
            collisionCount?: pulumi.Input<number>;
            /**
             * Contains details for the current condition of this cluster.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.core.v1alpha1.StorageClusterStatusConditions>[]>;
            /**
             * Phase of the StorageCluster is a simple, high-level summary of where the StorageCluster is in its lifecycle. The condition array contains more detailed information about the state of the cluster.
             */
            phase?: pulumi.Input<string>;
            /**
             * Contains details of storage in the cluster.
             */
            storage?: pulumi.Input<inputs.core.v1alpha1.StorageClusterStatusStorage>;
        }

        export interface StorageClusterStatusConditions {
            /**
             * Reason is human readable message indicating details about the current state of the cluster.
             */
            reason?: pulumi.Input<string>;
            /**
             * Status of the condition.
             */
            status?: pulumi.Input<string>;
            /**
             * Type of the condition.
             */
            type?: pulumi.Input<string>;
        }

        /**
         * Contains details of storage in the cluster.
         */
        export interface StorageClusterStatusStorage {
            /**
             * The number of storage nodes per zone in the cluster.
             */
            storageNodesPerZone?: pulumi.Input<number>;
        }

        /**
         * The desired behavior of the storage node. Currently changing the spec does not affect the actual storage node in the cluster. Eventually spec in StorageNode will override the spec from StorageCluster so that configuration can be overridden at node level.
         */
        export interface StorageNodeSpec {
            /**
             * Details of storage on the node for cloud environments.
             */
            cloudStorage?: pulumi.Input<inputs.core.v1alpha1.StorageNodeSpecCloudStorage>;
            /**
             * Version of the storage driver on the node.
             */
            version?: pulumi.Input<string>;
        }

        /**
         * Details of storage on the node for cloud environments.
         */
        export interface StorageNodeSpecCloudStorage {
            /**
             * List of cloud drive configs for the storage node.
             */
            driveConfigs?: pulumi.Input<pulumi.Input<inputs.core.v1alpha1.StorageNodeSpecCloudStorageDriveConfigs>[]>;
        }

        export interface StorageNodeSpecCloudStorageDriveConfigs {
            /**
             * IOPS required from the cloud drive.
             */
            iops?: pulumi.Input<number>;
            /**
             * Additional options for the cloud drive.
             */
            options?: pulumi.Input<{[key: string]: any}>;
            /**
             * Size of cloud drive in GiB.
             */
            sizeInGiB?: pulumi.Input<number>;
            /**
             * Type of cloud drive.
             */
            type?: pulumi.Input<string>;
        }

        /**
         * Most recently observed status of the storage node. The data may not be up to date.
         */
        export interface StorageNodeStatus {
            /**
             * Contains details for the current condition of this storage node.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.core.v1alpha1.StorageNodeStatusConditions>[]>;
            /**
             * Contains topology information for the storage node.
             */
            geography?: pulumi.Input<inputs.core.v1alpha1.StorageNodeStatusGeography>;
            network?: pulumi.Input<inputs.core.v1alpha1.StorageNodeStatusNetwork>;
            /**
             * Unique ID of the storage node.
             */
            nodeUid?: pulumi.Input<string>;
            /**
             * Phase of the StorageNode is a simple, high-level summary of where the StorageNode is in its lifecycle. The condition array contains more detailed information about the state of the node.
             */
            phase?: pulumi.Input<string>;
        }

        export interface StorageNodeStatusConditions {
            /**
             * Reason is the human readable message indicating details about the current state of the cluster.
             */
            reason?: pulumi.Input<string>;
            /**
             * Status of the condition.
             */
            status?: pulumi.Input<string>;
            /**
             * Type of the condition.
             */
            type?: pulumi.Input<string>;
        }

        /**
         * Contains topology information for the storage node.
         */
        export interface StorageNodeStatusGeography {
            /**
             * Rack on which the storage node is placed.
             */
            rack?: pulumi.Input<string>;
            /**
             * Region in which the storage node is placed.
             */
            region?: pulumi.Input<string>;
            /**
             * Zone in which the storage node is placed.
             */
            zone?: pulumi.Input<string>;
        }

        export interface StorageNodeStatusNetwork {
            /**
             * IP address used by the storage driver for data traffic.
             */
            dataIP?: pulumi.Input<string>;
            /**
             * IP address used by the storage driver for management traffic.
             */
            mgmtIP?: pulumi.Input<string>;
        }
    }
}
