# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from ... import _utilities, _tables
from . import outputs

__all__ = [
    'StorageClusterSpec',
    'StorageClusterSpecAutopilot',
    'StorageClusterSpecAutopilotEnv',
    'StorageClusterSpecAutopilotEnvValueFrom',
    'StorageClusterSpecAutopilotEnvValueFromConfigMapKeyRef',
    'StorageClusterSpecAutopilotEnvValueFromFieldRef',
    'StorageClusterSpecAutopilotEnvValueFromResourceFieldRef',
    'StorageClusterSpecAutopilotEnvValueFromSecretKeyRef',
    'StorageClusterSpecAutopilotProviders',
    'StorageClusterSpecCloudStorage',
    'StorageClusterSpecCloudStorageCapacitySpecs',
    'StorageClusterSpecDeleteStrategy',
    'StorageClusterSpecEnv',
    'StorageClusterSpecEnvValueFrom',
    'StorageClusterSpecEnvValueFromConfigMapKeyRef',
    'StorageClusterSpecEnvValueFromFieldRef',
    'StorageClusterSpecEnvValueFromResourceFieldRef',
    'StorageClusterSpecEnvValueFromSecretKeyRef',
    'StorageClusterSpecKvdb',
    'StorageClusterSpecMonitoring',
    'StorageClusterSpecMonitoringPrometheus',
    'StorageClusterSpecNetwork',
    'StorageClusterSpecNodes',
    'StorageClusterSpecNodesEnv',
    'StorageClusterSpecNodesEnvValueFrom',
    'StorageClusterSpecNodesEnvValueFromConfigMapKeyRef',
    'StorageClusterSpecNodesEnvValueFromFieldRef',
    'StorageClusterSpecNodesEnvValueFromResourceFieldRef',
    'StorageClusterSpecNodesEnvValueFromSecretKeyRef',
    'StorageClusterSpecNodesNetwork',
    'StorageClusterSpecNodesSelector',
    'StorageClusterSpecNodesSelectorLabelSelector',
    'StorageClusterSpecNodesSelectorLabelSelectorMatchExpressions',
    'StorageClusterSpecNodesStorage',
    'StorageClusterSpecPlacement',
    'StorageClusterSpecPlacementNodeAffinity',
    'StorageClusterSpecPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'StorageClusterSpecPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference',
    'StorageClusterSpecPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions',
    'StorageClusterSpecPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields',
    'StorageClusterSpecPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'StorageClusterSpecPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms',
    'StorageClusterSpecPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions',
    'StorageClusterSpecPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields',
    'StorageClusterSpecPlacementTolerations',
    'StorageClusterSpecStorage',
    'StorageClusterSpecStork',
    'StorageClusterSpecStorkEnv',
    'StorageClusterSpecStorkEnvValueFrom',
    'StorageClusterSpecStorkEnvValueFromConfigMapKeyRef',
    'StorageClusterSpecStorkEnvValueFromFieldRef',
    'StorageClusterSpecStorkEnvValueFromResourceFieldRef',
    'StorageClusterSpecStorkEnvValueFromSecretKeyRef',
    'StorageClusterSpecUpdateStrategy',
    'StorageClusterSpecUpdateStrategyRollingUpdate',
    'StorageClusterSpecUserInterface',
    'StorageClusterSpecUserInterfaceEnv',
    'StorageClusterSpecUserInterfaceEnvValueFrom',
    'StorageClusterSpecUserInterfaceEnvValueFromConfigMapKeyRef',
    'StorageClusterSpecUserInterfaceEnvValueFromFieldRef',
    'StorageClusterSpecUserInterfaceEnvValueFromResourceFieldRef',
    'StorageClusterSpecUserInterfaceEnvValueFromSecretKeyRef',
    'StorageClusterStatus',
    'StorageClusterStatusConditions',
    'StorageClusterStatusStorage',
    'StorageNodeSpec',
    'StorageNodeSpecCloudStorage',
    'StorageNodeSpecCloudStorageDriveConfigs',
    'StorageNodeStatus',
    'StorageNodeStatusConditions',
    'StorageNodeStatusGeography',
    'StorageNodeStatusNetwork',
]

@pulumi.output_type
class StorageClusterSpec(dict):
    """
    The desired behavior of the storage cluster.
    """
    def __init__(__self__, *,
                 autopilot: Optional['outputs.StorageClusterSpecAutopilot'] = None,
                 cloud_storage: Optional['outputs.StorageClusterSpecCloudStorage'] = None,
                 custom_image_registry: Optional[str] = None,
                 delete_strategy: Optional['outputs.StorageClusterSpecDeleteStrategy'] = None,
                 env: Optional[Sequence['outputs.StorageClusterSpecEnv']] = None,
                 feature_gates: Optional[Mapping[str, Any]] = None,
                 image: Optional[str] = None,
                 image_pull_policy: Optional[str] = None,
                 image_pull_secret: Optional[str] = None,
                 kvdb: Optional['outputs.StorageClusterSpecKvdb'] = None,
                 monitoring: Optional['outputs.StorageClusterSpecMonitoring'] = None,
                 network: Optional['outputs.StorageClusterSpecNetwork'] = None,
                 nodes: Optional[Sequence['outputs.StorageClusterSpecNodes']] = None,
                 placement: Optional['outputs.StorageClusterSpecPlacement'] = None,
                 revision_history_limit: Optional[int] = None,
                 runtime_options: Optional[Mapping[str, Any]] = None,
                 secrets_provider: Optional[str] = None,
                 start_port: Optional[int] = None,
                 storage: Optional['outputs.StorageClusterSpecStorage'] = None,
                 stork: Optional['outputs.StorageClusterSpecStork'] = None,
                 update_strategy: Optional['outputs.StorageClusterSpecUpdateStrategy'] = None,
                 user_interface: Optional['outputs.StorageClusterSpecUserInterface'] = None,
                 version: Optional[str] = None):
        """
        The desired behavior of the storage cluster.
        :param 'StorageClusterSpecAutopilotArgs' autopilot: Contains spec of autopilot component for storage driver.
        :param 'StorageClusterSpecCloudStorageArgs' cloud_storage: Details of storage used in cloud environment.
        :param str custom_image_registry: Custom container image registry server that will be used instead of index.docker.io to download Docker images. This may include the repository as well. (Example: myregistry.net:5443 or myregistry.com/myrepository)
        :param 'StorageClusterSpecDeleteStrategyArgs' delete_strategy: Delete strategy to uninstall and wipe the storage cluster.
        :param Sequence['StorageClusterSpecEnvArgs'] env: List of environment variables used by the driver. This is an array of Kubernetes EnvVar where the value can be given directly or from a source like field, config map or secret.
        :param Mapping[str, Any] feature_gates: This is a map of feature names to string values.
        :param str image: Docker image of the storage driver.
        :param str image_pull_policy: Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always.
        :param str image_pull_secret: Image pull secret is a reference to secret in the same namespace as the StorageCluster. It is used for pulling all images used by the StorageCluster.
        :param 'StorageClusterSpecKvdbArgs' kvdb: Details of KVDB that the storage driver will use.
        :param 'StorageClusterSpecMonitoringArgs' monitoring: Contains monitoring configuration for the storage cluster.
        :param 'StorageClusterSpecNetworkArgs' network: Contains network information that is needed by the storage driver.
        :param Sequence['StorageClusterSpecNodesArgs'] nodes: Node level configurations that will override the configuration at cluster level. These configurations can be for individual nodes or can be grouped to override configuration of multiple nodes based on label selectors.
        :param 'StorageClusterSpecPlacementArgs' placement: Describes placement configuration for the storage cluster pods.
        :param int revision_history_limit: The number of old history to retain to allow rollback. This is a pointer to distinguish between an explicit zero and not specified. Defaults to 10.
        :param Mapping[str, Any] runtime_options: This is map of any runtime options that need to be sent to the storage driver. The value is a string.
        :param str secrets_provider: Secrets provider is the name of secret provider that driver will connect to.
        :param int start_port: Start port is the starting port in the range of ports used by the cluster.
        :param 'StorageClusterSpecStorageArgs' storage: Details of the storage used by the storage driver.
        :param 'StorageClusterSpecStorkArgs' stork: Contains STORK related spec.
        :param 'StorageClusterSpecUpdateStrategyArgs' update_strategy: An update strategy to replace existing StorageCluster pods with new pods.
        :param 'StorageClusterSpecUserInterfaceArgs' user_interface: Contains spec of a user interface for the storage driver.
        :param str version: Version of the storage driver. This field is read-only.
        """
        if autopilot is not None:
            pulumi.set(__self__, "autopilot", autopilot)
        if cloud_storage is not None:
            pulumi.set(__self__, "cloud_storage", cloud_storage)
        if custom_image_registry is not None:
            pulumi.set(__self__, "custom_image_registry", custom_image_registry)
        if delete_strategy is not None:
            pulumi.set(__self__, "delete_strategy", delete_strategy)
        if env is not None:
            pulumi.set(__self__, "env", env)
        if feature_gates is not None:
            pulumi.set(__self__, "feature_gates", feature_gates)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if image_pull_policy is not None:
            pulumi.set(__self__, "image_pull_policy", image_pull_policy)
        if image_pull_secret is not None:
            pulumi.set(__self__, "image_pull_secret", image_pull_secret)
        if kvdb is not None:
            pulumi.set(__self__, "kvdb", kvdb)
        if monitoring is not None:
            pulumi.set(__self__, "monitoring", monitoring)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if nodes is not None:
            pulumi.set(__self__, "nodes", nodes)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if revision_history_limit is not None:
            pulumi.set(__self__, "revision_history_limit", revision_history_limit)
        if runtime_options is not None:
            pulumi.set(__self__, "runtime_options", runtime_options)
        if secrets_provider is not None:
            pulumi.set(__self__, "secrets_provider", secrets_provider)
        if start_port is not None:
            pulumi.set(__self__, "start_port", start_port)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)
        if stork is not None:
            pulumi.set(__self__, "stork", stork)
        if update_strategy is not None:
            pulumi.set(__self__, "update_strategy", update_strategy)
        if user_interface is not None:
            pulumi.set(__self__, "user_interface", user_interface)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def autopilot(self) -> Optional['outputs.StorageClusterSpecAutopilot']:
        """
        Contains spec of autopilot component for storage driver.
        """
        return pulumi.get(self, "autopilot")

    @property
    @pulumi.getter(name="cloudStorage")
    def cloud_storage(self) -> Optional['outputs.StorageClusterSpecCloudStorage']:
        """
        Details of storage used in cloud environment.
        """
        return pulumi.get(self, "cloud_storage")

    @property
    @pulumi.getter(name="customImageRegistry")
    def custom_image_registry(self) -> Optional[str]:
        """
        Custom container image registry server that will be used instead of index.docker.io to download Docker images. This may include the repository as well. (Example: myregistry.net:5443 or myregistry.com/myrepository)
        """
        return pulumi.get(self, "custom_image_registry")

    @property
    @pulumi.getter(name="deleteStrategy")
    def delete_strategy(self) -> Optional['outputs.StorageClusterSpecDeleteStrategy']:
        """
        Delete strategy to uninstall and wipe the storage cluster.
        """
        return pulumi.get(self, "delete_strategy")

    @property
    @pulumi.getter
    def env(self) -> Optional[Sequence['outputs.StorageClusterSpecEnv']]:
        """
        List of environment variables used by the driver. This is an array of Kubernetes EnvVar where the value can be given directly or from a source like field, config map or secret.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter(name="featureGates")
    def feature_gates(self) -> Optional[Mapping[str, Any]]:
        """
        This is a map of feature names to string values.
        """
        return pulumi.get(self, "feature_gates")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        Docker image of the storage driver.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="imagePullPolicy")
    def image_pull_policy(self) -> Optional[str]:
        """
        Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always.
        """
        return pulumi.get(self, "image_pull_policy")

    @property
    @pulumi.getter(name="imagePullSecret")
    def image_pull_secret(self) -> Optional[str]:
        """
        Image pull secret is a reference to secret in the same namespace as the StorageCluster. It is used for pulling all images used by the StorageCluster.
        """
        return pulumi.get(self, "image_pull_secret")

    @property
    @pulumi.getter
    def kvdb(self) -> Optional['outputs.StorageClusterSpecKvdb']:
        """
        Details of KVDB that the storage driver will use.
        """
        return pulumi.get(self, "kvdb")

    @property
    @pulumi.getter
    def monitoring(self) -> Optional['outputs.StorageClusterSpecMonitoring']:
        """
        Contains monitoring configuration for the storage cluster.
        """
        return pulumi.get(self, "monitoring")

    @property
    @pulumi.getter
    def network(self) -> Optional['outputs.StorageClusterSpecNetwork']:
        """
        Contains network information that is needed by the storage driver.
        """
        return pulumi.get(self, "network")

    @property
    @pulumi.getter
    def nodes(self) -> Optional[Sequence['outputs.StorageClusterSpecNodes']]:
        """
        Node level configurations that will override the configuration at cluster level. These configurations can be for individual nodes or can be grouped to override configuration of multiple nodes based on label selectors.
        """
        return pulumi.get(self, "nodes")

    @property
    @pulumi.getter
    def placement(self) -> Optional['outputs.StorageClusterSpecPlacement']:
        """
        Describes placement configuration for the storage cluster pods.
        """
        return pulumi.get(self, "placement")

    @property
    @pulumi.getter(name="revisionHistoryLimit")
    def revision_history_limit(self) -> Optional[int]:
        """
        The number of old history to retain to allow rollback. This is a pointer to distinguish between an explicit zero and not specified. Defaults to 10.
        """
        return pulumi.get(self, "revision_history_limit")

    @property
    @pulumi.getter(name="runtimeOptions")
    def runtime_options(self) -> Optional[Mapping[str, Any]]:
        """
        This is map of any runtime options that need to be sent to the storage driver. The value is a string.
        """
        return pulumi.get(self, "runtime_options")

    @property
    @pulumi.getter(name="secretsProvider")
    def secrets_provider(self) -> Optional[str]:
        """
        Secrets provider is the name of secret provider that driver will connect to.
        """
        return pulumi.get(self, "secrets_provider")

    @property
    @pulumi.getter(name="startPort")
    def start_port(self) -> Optional[int]:
        """
        Start port is the starting port in the range of ports used by the cluster.
        """
        return pulumi.get(self, "start_port")

    @property
    @pulumi.getter
    def storage(self) -> Optional['outputs.StorageClusterSpecStorage']:
        """
        Details of the storage used by the storage driver.
        """
        return pulumi.get(self, "storage")

    @property
    @pulumi.getter
    def stork(self) -> Optional['outputs.StorageClusterSpecStork']:
        """
        Contains STORK related spec.
        """
        return pulumi.get(self, "stork")

    @property
    @pulumi.getter(name="updateStrategy")
    def update_strategy(self) -> Optional['outputs.StorageClusterSpecUpdateStrategy']:
        """
        An update strategy to replace existing StorageCluster pods with new pods.
        """
        return pulumi.get(self, "update_strategy")

    @property
    @pulumi.getter(name="userInterface")
    def user_interface(self) -> Optional['outputs.StorageClusterSpecUserInterface']:
        """
        Contains spec of a user interface for the storage driver.
        """
        return pulumi.get(self, "user_interface")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Version of the storage driver. This field is read-only.
        """
        return pulumi.get(self, "version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecAutopilot(dict):
    """
    Contains spec of autopilot component for storage driver.
    """
    def __init__(__self__, *,
                 args: Optional[Mapping[str, Any]] = None,
                 enabled: Optional[bool] = None,
                 env: Optional[Sequence['outputs.StorageClusterSpecAutopilotEnv']] = None,
                 image: Optional[str] = None,
                 lock_image: Optional[bool] = None,
                 providers: Optional[Sequence['outputs.StorageClusterSpecAutopilotProviders']] = None):
        """
        Contains spec of autopilot component for storage driver.
        :param Mapping[str, Any] args: It is a map of arguments provided to autopilot. Example: log-level: debug
        :param bool enabled: Flag indicating whether autopilot needs to be enabled.
        :param Sequence['StorageClusterSpecAutopilotEnvArgs'] env: List of environment variables used by autopilot. This is an array of Kubernetes EnvVar where the value can be given directly or from a source like field, config map or secret.
        :param str image: Docker image of the autopilot container.
        :param bool lock_image: Flag indicating if the autopilot image needs to be locked to the given image. If the image is not locked, it can be updated by the storage driver during upgrades.
        :param Sequence['StorageClusterSpecAutopilotProvidersArgs'] providers: List of input data providers to autopilot.
        """
        if args is not None:
            pulumi.set(__self__, "args", args)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if env is not None:
            pulumi.set(__self__, "env", env)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if lock_image is not None:
            pulumi.set(__self__, "lock_image", lock_image)
        if providers is not None:
            pulumi.set(__self__, "providers", providers)

    @property
    @pulumi.getter
    def args(self) -> Optional[Mapping[str, Any]]:
        """
        It is a map of arguments provided to autopilot. Example: log-level: debug
        """
        return pulumi.get(self, "args")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Flag indicating whether autopilot needs to be enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def env(self) -> Optional[Sequence['outputs.StorageClusterSpecAutopilotEnv']]:
        """
        List of environment variables used by autopilot. This is an array of Kubernetes EnvVar where the value can be given directly or from a source like field, config map or secret.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        Docker image of the autopilot container.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="lockImage")
    def lock_image(self) -> Optional[bool]:
        """
        Flag indicating if the autopilot image needs to be locked to the given image. If the image is not locked, it can be updated by the storage driver during upgrades.
        """
        return pulumi.get(self, "lock_image")

    @property
    @pulumi.getter
    def providers(self) -> Optional[Sequence['outputs.StorageClusterSpecAutopilotProviders']]:
        """
        List of input data providers to autopilot.
        """
        return pulumi.get(self, "providers")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecAutopilotEnv(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None,
                 value_from: Optional['outputs.StorageClusterSpecAutopilotEnvValueFrom'] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_from is not None:
            pulumi.set(__self__, "value_from", value_from)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueFrom")
    def value_from(self) -> Optional['outputs.StorageClusterSpecAutopilotEnvValueFrom']:
        return pulumi.get(self, "value_from")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecAutopilotEnvValueFrom(dict):
    def __init__(__self__, *,
                 config_map_key_ref: Optional['outputs.StorageClusterSpecAutopilotEnvValueFromConfigMapKeyRef'] = None,
                 field_ref: Optional['outputs.StorageClusterSpecAutopilotEnvValueFromFieldRef'] = None,
                 resource_field_ref: Optional['outputs.StorageClusterSpecAutopilotEnvValueFromResourceFieldRef'] = None,
                 secret_key_ref: Optional['outputs.StorageClusterSpecAutopilotEnvValueFromSecretKeyRef'] = None):
        if config_map_key_ref is not None:
            pulumi.set(__self__, "config_map_key_ref", config_map_key_ref)
        if field_ref is not None:
            pulumi.set(__self__, "field_ref", field_ref)
        if resource_field_ref is not None:
            pulumi.set(__self__, "resource_field_ref", resource_field_ref)
        if secret_key_ref is not None:
            pulumi.set(__self__, "secret_key_ref", secret_key_ref)

    @property
    @pulumi.getter(name="configMapKeyRef")
    def config_map_key_ref(self) -> Optional['outputs.StorageClusterSpecAutopilotEnvValueFromConfigMapKeyRef']:
        return pulumi.get(self, "config_map_key_ref")

    @property
    @pulumi.getter(name="fieldRef")
    def field_ref(self) -> Optional['outputs.StorageClusterSpecAutopilotEnvValueFromFieldRef']:
        return pulumi.get(self, "field_ref")

    @property
    @pulumi.getter(name="resourceFieldRef")
    def resource_field_ref(self) -> Optional['outputs.StorageClusterSpecAutopilotEnvValueFromResourceFieldRef']:
        return pulumi.get(self, "resource_field_ref")

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> Optional['outputs.StorageClusterSpecAutopilotEnvValueFromSecretKeyRef']:
        return pulumi.get(self, "secret_key_ref")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecAutopilotEnvValueFromConfigMapKeyRef(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        return pulumi.get(self, "optional")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecAutopilotEnvValueFromFieldRef(dict):
    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None):
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        return pulumi.get(self, "field_path")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecAutopilotEnvValueFromResourceFieldRef(dict):
    def __init__(__self__, *,
                 container_name: Optional[str] = None,
                 divisor: Optional[str] = None,
                 resource: Optional[str] = None):
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if divisor is not None:
            pulumi.set(__self__, "divisor", divisor)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[str]:
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def divisor(self) -> Optional[str]:
        return pulumi.get(self, "divisor")

    @property
    @pulumi.getter
    def resource(self) -> Optional[str]:
        return pulumi.get(self, "resource")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecAutopilotEnvValueFromSecretKeyRef(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        return pulumi.get(self, "optional")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecAutopilotProviders(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 params: Optional[Mapping[str, Any]] = None,
                 type: Optional[str] = None):
        """
        :param str name: Unique name of the data provider.
        :param Mapping[str, Any] params: Map of key-value params for the provider.
        :param str type: Type of the data provider. For instance - prometheus
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if params is not None:
            pulumi.set(__self__, "params", params)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique name of the data provider.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def params(self) -> Optional[Mapping[str, Any]]:
        """
        Map of key-value params for the provider.
        """
        return pulumi.get(self, "params")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the data provider. For instance - prometheus
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecCloudStorage(dict):
    """
    Details of storage used in cloud environment.
    """
    def __init__(__self__, *,
                 capacity_specs: Optional[Sequence['outputs.StorageClusterSpecCloudStorageCapacitySpecs']] = None,
                 device_specs: Optional[Sequence[str]] = None,
                 journal_device_spec: Optional[str] = None,
                 kvdb_device_spec: Optional[str] = None,
                 max_storage_nodes: Optional[int] = None,
                 max_storage_nodes_per_zone: Optional[int] = None,
                 system_metadata_device_spec: Optional[str] = None):
        """
        Details of storage used in cloud environment.
        :param Sequence['StorageClusterSpecCloudStorageCapacitySpecsArgs'] capacity_specs: List of cluster wide storage types and their capacities. A single capacity spec identifies a storage pool with a set of minimum requested IOPS and size. Based on the cloud provider, the total storage capacity will get divided amongst the nodes. The nodes bearing storage themselves will get uniformly distributed across all the zones.
        :param Sequence[str] device_specs: List of storage device specs. A cloud storage device will be created for every spec in the list. The specs will be applied to all nodes in the cluster up to spec.cloudStorage.maxStorageNodes or spec.cloudStorage.maxStorageNodesPerZone. This will be ignored if spec.cloudStorage.capacitySpecs is present.
        :param str journal_device_spec: Device spec for the journal device.
        :param str kvdb_device_spec: Device spec for internal KVDB device.
        :param int max_storage_nodes: Maximum nodes that will have storage in the cluster.
        :param int max_storage_nodes_per_zone: Maximum nodes in every zone that will have storage in the cluster.
        :param str system_metadata_device_spec: Device spec for the metadata device. This device will be used to store system metadata by the driver.
        """
        if capacity_specs is not None:
            pulumi.set(__self__, "capacity_specs", capacity_specs)
        if device_specs is not None:
            pulumi.set(__self__, "device_specs", device_specs)
        if journal_device_spec is not None:
            pulumi.set(__self__, "journal_device_spec", journal_device_spec)
        if kvdb_device_spec is not None:
            pulumi.set(__self__, "kvdb_device_spec", kvdb_device_spec)
        if max_storage_nodes is not None:
            pulumi.set(__self__, "max_storage_nodes", max_storage_nodes)
        if max_storage_nodes_per_zone is not None:
            pulumi.set(__self__, "max_storage_nodes_per_zone", max_storage_nodes_per_zone)
        if system_metadata_device_spec is not None:
            pulumi.set(__self__, "system_metadata_device_spec", system_metadata_device_spec)

    @property
    @pulumi.getter(name="capacitySpecs")
    def capacity_specs(self) -> Optional[Sequence['outputs.StorageClusterSpecCloudStorageCapacitySpecs']]:
        """
        List of cluster wide storage types and their capacities. A single capacity spec identifies a storage pool with a set of minimum requested IOPS and size. Based on the cloud provider, the total storage capacity will get divided amongst the nodes. The nodes bearing storage themselves will get uniformly distributed across all the zones.
        """
        return pulumi.get(self, "capacity_specs")

    @property
    @pulumi.getter(name="deviceSpecs")
    def device_specs(self) -> Optional[Sequence[str]]:
        """
        List of storage device specs. A cloud storage device will be created for every spec in the list. The specs will be applied to all nodes in the cluster up to spec.cloudStorage.maxStorageNodes or spec.cloudStorage.maxStorageNodesPerZone. This will be ignored if spec.cloudStorage.capacitySpecs is present.
        """
        return pulumi.get(self, "device_specs")

    @property
    @pulumi.getter(name="journalDeviceSpec")
    def journal_device_spec(self) -> Optional[str]:
        """
        Device spec for the journal device.
        """
        return pulumi.get(self, "journal_device_spec")

    @property
    @pulumi.getter(name="kvdbDeviceSpec")
    def kvdb_device_spec(self) -> Optional[str]:
        """
        Device spec for internal KVDB device.
        """
        return pulumi.get(self, "kvdb_device_spec")

    @property
    @pulumi.getter(name="maxStorageNodes")
    def max_storage_nodes(self) -> Optional[int]:
        """
        Maximum nodes that will have storage in the cluster.
        """
        return pulumi.get(self, "max_storage_nodes")

    @property
    @pulumi.getter(name="maxStorageNodesPerZone")
    def max_storage_nodes_per_zone(self) -> Optional[int]:
        """
        Maximum nodes in every zone that will have storage in the cluster.
        """
        return pulumi.get(self, "max_storage_nodes_per_zone")

    @property
    @pulumi.getter(name="systemMetadataDeviceSpec")
    def system_metadata_device_spec(self) -> Optional[str]:
        """
        Device spec for the metadata device. This device will be used to store system metadata by the driver.
        """
        return pulumi.get(self, "system_metadata_device_spec")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecCloudStorageCapacitySpecs(dict):
    def __init__(__self__, *,
                 max_capacity_in_gi_b: Optional[int] = None,
                 min_capacity_in_gi_b: Optional[int] = None,
                 min_iops: Optional[int] = None,
                 options: Optional[Mapping[str, Any]] = None):
        """
        :param int max_capacity_in_gi_b: Maximum capacity for this storage cluster. The total capacity of devices created by this capacity spec should not be greater than this number for the entire cluster.
        :param int min_capacity_in_gi_b: Minimum capacity for this storage cluster. The total capacity of devices created by this capacity spec should not be less than this number for the entire cluster.
        :param int min_iops: Minimum IOPS expected from the cloud drive.
        :param Mapping[str, Any] options: Additional options required to provision the drive in cloud.
        """
        if max_capacity_in_gi_b is not None:
            pulumi.set(__self__, "max_capacity_in_gi_b", max_capacity_in_gi_b)
        if min_capacity_in_gi_b is not None:
            pulumi.set(__self__, "min_capacity_in_gi_b", min_capacity_in_gi_b)
        if min_iops is not None:
            pulumi.set(__self__, "min_iops", min_iops)
        if options is not None:
            pulumi.set(__self__, "options", options)

    @property
    @pulumi.getter(name="maxCapacityInGiB")
    def max_capacity_in_gi_b(self) -> Optional[int]:
        """
        Maximum capacity for this storage cluster. The total capacity of devices created by this capacity spec should not be greater than this number for the entire cluster.
        """
        return pulumi.get(self, "max_capacity_in_gi_b")

    @property
    @pulumi.getter(name="minCapacityInGiB")
    def min_capacity_in_gi_b(self) -> Optional[int]:
        """
        Minimum capacity for this storage cluster. The total capacity of devices created by this capacity spec should not be less than this number for the entire cluster.
        """
        return pulumi.get(self, "min_capacity_in_gi_b")

    @property
    @pulumi.getter(name="minIOPS")
    def min_iops(self) -> Optional[int]:
        """
        Minimum IOPS expected from the cloud drive.
        """
        return pulumi.get(self, "min_iops")

    @property
    @pulumi.getter
    def options(self) -> Optional[Mapping[str, Any]]:
        """
        Additional options required to provision the drive in cloud.
        """
        return pulumi.get(self, "options")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecDeleteStrategy(dict):
    """
    Delete strategy to uninstall and wipe the storage cluster.
    """
    def __init__(__self__, *,
                 type: Optional[str] = None):
        """
        Delete strategy to uninstall and wipe the storage cluster.
        :param str type: Type of storage cluster delete. Can be Uninstall or UninstallAndWipe. There is no default delete strategy. When no delete strategy only objects managed by the StorageCluster controller and owned by the StorageCluster object are deleted. The storage driver will be left in a state where it will not be managed by any object. Uninstall strategy ensures that the cluster is completely uninstalled even from the storage driver perspective. UninstallAndWipe strategy ensures that the cluster is completely uninstalled as well as the storage devices and metadata are wiped for reuse. This may result in data loss.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of storage cluster delete. Can be Uninstall or UninstallAndWipe. There is no default delete strategy. When no delete strategy only objects managed by the StorageCluster controller and owned by the StorageCluster object are deleted. The storage driver will be left in a state where it will not be managed by any object. Uninstall strategy ensures that the cluster is completely uninstalled even from the storage driver perspective. UninstallAndWipe strategy ensures that the cluster is completely uninstalled as well as the storage devices and metadata are wiped for reuse. This may result in data loss.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecEnv(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None,
                 value_from: Optional['outputs.StorageClusterSpecEnvValueFrom'] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_from is not None:
            pulumi.set(__self__, "value_from", value_from)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueFrom")
    def value_from(self) -> Optional['outputs.StorageClusterSpecEnvValueFrom']:
        return pulumi.get(self, "value_from")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecEnvValueFrom(dict):
    def __init__(__self__, *,
                 config_map_key_ref: Optional['outputs.StorageClusterSpecEnvValueFromConfigMapKeyRef'] = None,
                 field_ref: Optional['outputs.StorageClusterSpecEnvValueFromFieldRef'] = None,
                 resource_field_ref: Optional['outputs.StorageClusterSpecEnvValueFromResourceFieldRef'] = None,
                 secret_key_ref: Optional['outputs.StorageClusterSpecEnvValueFromSecretKeyRef'] = None):
        if config_map_key_ref is not None:
            pulumi.set(__self__, "config_map_key_ref", config_map_key_ref)
        if field_ref is not None:
            pulumi.set(__self__, "field_ref", field_ref)
        if resource_field_ref is not None:
            pulumi.set(__self__, "resource_field_ref", resource_field_ref)
        if secret_key_ref is not None:
            pulumi.set(__self__, "secret_key_ref", secret_key_ref)

    @property
    @pulumi.getter(name="configMapKeyRef")
    def config_map_key_ref(self) -> Optional['outputs.StorageClusterSpecEnvValueFromConfigMapKeyRef']:
        return pulumi.get(self, "config_map_key_ref")

    @property
    @pulumi.getter(name="fieldRef")
    def field_ref(self) -> Optional['outputs.StorageClusterSpecEnvValueFromFieldRef']:
        return pulumi.get(self, "field_ref")

    @property
    @pulumi.getter(name="resourceFieldRef")
    def resource_field_ref(self) -> Optional['outputs.StorageClusterSpecEnvValueFromResourceFieldRef']:
        return pulumi.get(self, "resource_field_ref")

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> Optional['outputs.StorageClusterSpecEnvValueFromSecretKeyRef']:
        return pulumi.get(self, "secret_key_ref")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecEnvValueFromConfigMapKeyRef(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        return pulumi.get(self, "optional")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecEnvValueFromFieldRef(dict):
    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None):
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        return pulumi.get(self, "field_path")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecEnvValueFromResourceFieldRef(dict):
    def __init__(__self__, *,
                 container_name: Optional[str] = None,
                 divisor: Optional[str] = None,
                 resource: Optional[str] = None):
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if divisor is not None:
            pulumi.set(__self__, "divisor", divisor)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[str]:
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def divisor(self) -> Optional[str]:
        return pulumi.get(self, "divisor")

    @property
    @pulumi.getter
    def resource(self) -> Optional[str]:
        return pulumi.get(self, "resource")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecEnvValueFromSecretKeyRef(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        return pulumi.get(self, "optional")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecKvdb(dict):
    """
    Details of KVDB that the storage driver will use.
    """
    def __init__(__self__, *,
                 auth_secret: Optional[str] = None,
                 endpoints: Optional[Sequence[str]] = None,
                 internal: Optional[bool] = None):
        """
        Details of KVDB that the storage driver will use.
        :param str auth_secret: Authentication secret is the name of Kubernetes secret containing information to authenticate with the external KVDB. It could have the username/password for basic auth, certificate information or an ACL token.
        :param Sequence[str] endpoints: If using external KVDB, this is the list of KVDB endpoints.
        :param bool internal: Flag indicating whether to use internal KVDB or an external KVDB.
        """
        if auth_secret is not None:
            pulumi.set(__self__, "auth_secret", auth_secret)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if internal is not None:
            pulumi.set(__self__, "internal", internal)

    @property
    @pulumi.getter(name="authSecret")
    def auth_secret(self) -> Optional[str]:
        """
        Authentication secret is the name of Kubernetes secret containing information to authenticate with the external KVDB. It could have the username/password for basic auth, certificate information or an ACL token.
        """
        return pulumi.get(self, "auth_secret")

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[Sequence[str]]:
        """
        If using external KVDB, this is the list of KVDB endpoints.
        """
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter
    def internal(self) -> Optional[bool]:
        """
        Flag indicating whether to use internal KVDB or an external KVDB.
        """
        return pulumi.get(self, "internal")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecMonitoring(dict):
    """
    Contains monitoring configuration for the storage cluster.
    """
    def __init__(__self__, *,
                 enable_metrics: Optional[bool] = None,
                 prometheus: Optional['outputs.StorageClusterSpecMonitoringPrometheus'] = None):
        """
        Contains monitoring configuration for the storage cluster.
        :param bool enable_metrics: If this flag is enabled it will expose the storage cluster metrics to external monitoring solutions like Prometheus. DEPRECATED - use prometheus.exportMetrics instead
        :param 'StorageClusterSpecMonitoringPrometheusArgs' prometheus: Contains configuration of Prometheus to monitor the storage cluster.
        """
        if enable_metrics is not None:
            pulumi.set(__self__, "enable_metrics", enable_metrics)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter(name="enableMetrics")
    def enable_metrics(self) -> Optional[bool]:
        """
        If this flag is enabled it will expose the storage cluster metrics to external monitoring solutions like Prometheus. DEPRECATED - use prometheus.exportMetrics instead
        """
        return pulumi.get(self, "enable_metrics")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional['outputs.StorageClusterSpecMonitoringPrometheus']:
        """
        Contains configuration of Prometheus to monitor the storage cluster.
        """
        return pulumi.get(self, "prometheus")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecMonitoringPrometheus(dict):
    """
    Contains configuration of Prometheus to monitor the storage cluster.
    """
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 export_metrics: Optional[bool] = None,
                 remote_write_endpoint: Optional[str] = None):
        """
        Contains configuration of Prometheus to monitor the storage cluster.
        :param bool enabled: Flag indicating whether Prometheus stack needs to be enabled and deployed by the Storage operator.
        :param bool export_metrics: If this flag is enabled it will expose the storage cluster metrics to Prometheus.
        :param str remote_write_endpoint: Specifies the remote write endpoint for Prometheus.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if export_metrics is not None:
            pulumi.set(__self__, "export_metrics", export_metrics)
        if remote_write_endpoint is not None:
            pulumi.set(__self__, "remote_write_endpoint", remote_write_endpoint)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Flag indicating whether Prometheus stack needs to be enabled and deployed by the Storage operator.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="exportMetrics")
    def export_metrics(self) -> Optional[bool]:
        """
        If this flag is enabled it will expose the storage cluster metrics to Prometheus.
        """
        return pulumi.get(self, "export_metrics")

    @property
    @pulumi.getter(name="remoteWriteEndpoint")
    def remote_write_endpoint(self) -> Optional[str]:
        """
        Specifies the remote write endpoint for Prometheus.
        """
        return pulumi.get(self, "remote_write_endpoint")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecNetwork(dict):
    """
    Contains network information that is needed by the storage driver.
    """
    def __init__(__self__, *,
                 data_interface: Optional[str] = None,
                 mgmt_interface: Optional[str] = None):
        """
        Contains network information that is needed by the storage driver.
        :param str data_interface: Name of the network interface used by the storage driver for data traffic.
        :param str mgmt_interface: Name of the network interface used by the storage driver for management traffic.
        """
        if data_interface is not None:
            pulumi.set(__self__, "data_interface", data_interface)
        if mgmt_interface is not None:
            pulumi.set(__self__, "mgmt_interface", mgmt_interface)

    @property
    @pulumi.getter(name="dataInterface")
    def data_interface(self) -> Optional[str]:
        """
        Name of the network interface used by the storage driver for data traffic.
        """
        return pulumi.get(self, "data_interface")

    @property
    @pulumi.getter(name="mgmtInterface")
    def mgmt_interface(self) -> Optional[str]:
        """
        Name of the network interface used by the storage driver for management traffic.
        """
        return pulumi.get(self, "mgmt_interface")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecNodes(dict):
    def __init__(__self__, *,
                 env: Optional[Sequence['outputs.StorageClusterSpecNodesEnv']] = None,
                 network: Optional['outputs.StorageClusterSpecNodesNetwork'] = None,
                 runtime_options: Optional[Mapping[str, Any]] = None,
                 selector: Optional['outputs.StorageClusterSpecNodesSelector'] = None,
                 storage: Optional['outputs.StorageClusterSpecNodesStorage'] = None):
        """
        :param Sequence['StorageClusterSpecNodesEnvArgs'] env: List of environment variables used by the driver. This is an array of Kubernetes EnvVar where the value can be given directly or from a source like field, config map or secret. Environment variables specified here at the node level will be merged with the ones present in cluster configuration and sent to the nodes. If there is duplicate, the node level value will take precedence.
        :param 'StorageClusterSpecNodesNetworkArgs' network: Contains network information that is needed by the storage driver.
        :param Mapping[str, Any] runtime_options: This is map of any runtime options that need to be sent to the storage driver. The value is a string. If runtime options are present here at node level, they will override the ones from cluster configuration.
        :param 'StorageClusterSpecNodesSelectorArgs' selector: Configuration in this node block is applied to nodes based on this selector. Use either nodeName of labelSelector, not both. If nodeName is used, labelSelector will be ignored.
        :param 'StorageClusterSpecNodesStorageArgs' storage: Details of the storage used by the storage driver.
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if runtime_options is not None:
            pulumi.set(__self__, "runtime_options", runtime_options)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def env(self) -> Optional[Sequence['outputs.StorageClusterSpecNodesEnv']]:
        """
        List of environment variables used by the driver. This is an array of Kubernetes EnvVar where the value can be given directly or from a source like field, config map or secret. Environment variables specified here at the node level will be merged with the ones present in cluster configuration and sent to the nodes. If there is duplicate, the node level value will take precedence.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def network(self) -> Optional['outputs.StorageClusterSpecNodesNetwork']:
        """
        Contains network information that is needed by the storage driver.
        """
        return pulumi.get(self, "network")

    @property
    @pulumi.getter(name="runtimeOptions")
    def runtime_options(self) -> Optional[Mapping[str, Any]]:
        """
        This is map of any runtime options that need to be sent to the storage driver. The value is a string. If runtime options are present here at node level, they will override the ones from cluster configuration.
        """
        return pulumi.get(self, "runtime_options")

    @property
    @pulumi.getter
    def selector(self) -> Optional['outputs.StorageClusterSpecNodesSelector']:
        """
        Configuration in this node block is applied to nodes based on this selector. Use either nodeName of labelSelector, not both. If nodeName is used, labelSelector will be ignored.
        """
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter
    def storage(self) -> Optional['outputs.StorageClusterSpecNodesStorage']:
        """
        Details of the storage used by the storage driver.
        """
        return pulumi.get(self, "storage")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecNodesEnv(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None,
                 value_from: Optional['outputs.StorageClusterSpecNodesEnvValueFrom'] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_from is not None:
            pulumi.set(__self__, "value_from", value_from)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueFrom")
    def value_from(self) -> Optional['outputs.StorageClusterSpecNodesEnvValueFrom']:
        return pulumi.get(self, "value_from")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecNodesEnvValueFrom(dict):
    def __init__(__self__, *,
                 config_map_key_ref: Optional['outputs.StorageClusterSpecNodesEnvValueFromConfigMapKeyRef'] = None,
                 field_ref: Optional['outputs.StorageClusterSpecNodesEnvValueFromFieldRef'] = None,
                 resource_field_ref: Optional['outputs.StorageClusterSpecNodesEnvValueFromResourceFieldRef'] = None,
                 secret_key_ref: Optional['outputs.StorageClusterSpecNodesEnvValueFromSecretKeyRef'] = None):
        if config_map_key_ref is not None:
            pulumi.set(__self__, "config_map_key_ref", config_map_key_ref)
        if field_ref is not None:
            pulumi.set(__self__, "field_ref", field_ref)
        if resource_field_ref is not None:
            pulumi.set(__self__, "resource_field_ref", resource_field_ref)
        if secret_key_ref is not None:
            pulumi.set(__self__, "secret_key_ref", secret_key_ref)

    @property
    @pulumi.getter(name="configMapKeyRef")
    def config_map_key_ref(self) -> Optional['outputs.StorageClusterSpecNodesEnvValueFromConfigMapKeyRef']:
        return pulumi.get(self, "config_map_key_ref")

    @property
    @pulumi.getter(name="fieldRef")
    def field_ref(self) -> Optional['outputs.StorageClusterSpecNodesEnvValueFromFieldRef']:
        return pulumi.get(self, "field_ref")

    @property
    @pulumi.getter(name="resourceFieldRef")
    def resource_field_ref(self) -> Optional['outputs.StorageClusterSpecNodesEnvValueFromResourceFieldRef']:
        return pulumi.get(self, "resource_field_ref")

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> Optional['outputs.StorageClusterSpecNodesEnvValueFromSecretKeyRef']:
        return pulumi.get(self, "secret_key_ref")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecNodesEnvValueFromConfigMapKeyRef(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        return pulumi.get(self, "optional")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecNodesEnvValueFromFieldRef(dict):
    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None):
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        return pulumi.get(self, "field_path")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecNodesEnvValueFromResourceFieldRef(dict):
    def __init__(__self__, *,
                 container_name: Optional[str] = None,
                 divisor: Optional[str] = None,
                 resource: Optional[str] = None):
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if divisor is not None:
            pulumi.set(__self__, "divisor", divisor)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[str]:
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def divisor(self) -> Optional[str]:
        return pulumi.get(self, "divisor")

    @property
    @pulumi.getter
    def resource(self) -> Optional[str]:
        return pulumi.get(self, "resource")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecNodesEnvValueFromSecretKeyRef(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        return pulumi.get(self, "optional")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecNodesNetwork(dict):
    """
    Contains network information that is needed by the storage driver.
    """
    def __init__(__self__, *,
                 data_interface: Optional[str] = None,
                 mgmt_interface: Optional[str] = None):
        """
        Contains network information that is needed by the storage driver.
        :param str data_interface: Name of the network interface used by the storage driver for data traffic.
        :param str mgmt_interface: Name of the network interface used by the storage driver for management traffic.
        """
        if data_interface is not None:
            pulumi.set(__self__, "data_interface", data_interface)
        if mgmt_interface is not None:
            pulumi.set(__self__, "mgmt_interface", mgmt_interface)

    @property
    @pulumi.getter(name="dataInterface")
    def data_interface(self) -> Optional[str]:
        """
        Name of the network interface used by the storage driver for data traffic.
        """
        return pulumi.get(self, "data_interface")

    @property
    @pulumi.getter(name="mgmtInterface")
    def mgmt_interface(self) -> Optional[str]:
        """
        Name of the network interface used by the storage driver for management traffic.
        """
        return pulumi.get(self, "mgmt_interface")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecNodesSelector(dict):
    """
    Configuration in this node block is applied to nodes based on this selector. Use either nodeName of labelSelector, not both. If nodeName is used, labelSelector will be ignored.
    """
    def __init__(__self__, *,
                 label_selector: Optional['outputs.StorageClusterSpecNodesSelectorLabelSelector'] = None,
                 node_name: Optional[str] = None):
        """
        Configuration in this node block is applied to nodes based on this selector. Use either nodeName of labelSelector, not both. If nodeName is used, labelSelector will be ignored.
        :param 'StorageClusterSpecNodesSelectorLabelSelectorArgs' label_selector: It is a label query over all the nodes. The result of matchLabels and matchExpressions is ANDed. An empty label selector matches all nodes. A null label selector matches no objects.
        :param str node_name: Name of the Kubernetes node that is to be selected. If present then the labelSelector is ignored even if the node with the given name is absent and the labelSelector matches another node.
        """
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if node_name is not None:
            pulumi.set(__self__, "node_name", node_name)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.StorageClusterSpecNodesSelectorLabelSelector']:
        """
        It is a label query over all the nodes. The result of matchLabels and matchExpressions is ANDed. An empty label selector matches all nodes. A null label selector matches no objects.
        """
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> Optional[str]:
        """
        Name of the Kubernetes node that is to be selected. If present then the labelSelector is ignored even if the node with the given name is absent and the labelSelector matches another node.
        """
        return pulumi.get(self, "node_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecNodesSelectorLabelSelector(dict):
    """
    It is a label query over all the nodes. The result of matchLabels and matchExpressions is ANDed. An empty label selector matches all nodes. A null label selector matches no objects.
    """
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.StorageClusterSpecNodesSelectorLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        """
        It is a label query over all the nodes. The result of matchLabels and matchExpressions is ANDed. An empty label selector matches all nodes. A null label selector matches no objects.
        :param Sequence['StorageClusterSpecNodesSelectorLabelSelectorMatchExpressionsArgs'] match_expressions: It is a list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, Any] match_labels: It is a map of key-value pairs. A single key-value in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.StorageClusterSpecNodesSelectorLabelSelectorMatchExpressions']]:
        """
        It is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        """
        It is a map of key-value pairs. A single key-value in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecNodesSelectorLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str key: It is the label key that the selector applies to.
        :param str operator: It represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param Sequence[str] values: It is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        It is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        It represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        It is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty.
        """
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecNodesStorage(dict):
    """
    Details of the storage used by the storage driver.
    """
    def __init__(__self__, *,
                 devices: Optional[Sequence[str]] = None,
                 force_use_disks: Optional[bool] = None,
                 journal_device: Optional[str] = None,
                 kvdb_device: Optional[str] = None,
                 system_metadata_device: Optional[str] = None,
                 use_all: Optional[bool] = None,
                 use_all_with_partitions: Optional[bool] = None):
        """
        Details of the storage used by the storage driver.
        :param Sequence[str] devices: List of devices to be used by the storage driver.
        :param bool force_use_disks: Flag indicating to use the devices even if there is file system present on it. Note that the devices may be wiped before using.
        :param str journal_device: Device used for journaling.
        :param str kvdb_device: Device used for internal KVDB.
        :param str system_metadata_device: Device that will be used to store system metadata by the driver.
        :param bool use_all: Use all available, unformatted, unpartitioned devices. This will be ignored if spec.storage.devices is not empty.
        :param bool use_all_with_partitions: Use all available unformatted devices. This will be ignored if spec.storage.devices is not empty.
        """
        if devices is not None:
            pulumi.set(__self__, "devices", devices)
        if force_use_disks is not None:
            pulumi.set(__self__, "force_use_disks", force_use_disks)
        if journal_device is not None:
            pulumi.set(__self__, "journal_device", journal_device)
        if kvdb_device is not None:
            pulumi.set(__self__, "kvdb_device", kvdb_device)
        if system_metadata_device is not None:
            pulumi.set(__self__, "system_metadata_device", system_metadata_device)
        if use_all is not None:
            pulumi.set(__self__, "use_all", use_all)
        if use_all_with_partitions is not None:
            pulumi.set(__self__, "use_all_with_partitions", use_all_with_partitions)

    @property
    @pulumi.getter
    def devices(self) -> Optional[Sequence[str]]:
        """
        List of devices to be used by the storage driver.
        """
        return pulumi.get(self, "devices")

    @property
    @pulumi.getter(name="forceUseDisks")
    def force_use_disks(self) -> Optional[bool]:
        """
        Flag indicating to use the devices even if there is file system present on it. Note that the devices may be wiped before using.
        """
        return pulumi.get(self, "force_use_disks")

    @property
    @pulumi.getter(name="journalDevice")
    def journal_device(self) -> Optional[str]:
        """
        Device used for journaling.
        """
        return pulumi.get(self, "journal_device")

    @property
    @pulumi.getter(name="kvdbDevice")
    def kvdb_device(self) -> Optional[str]:
        """
        Device used for internal KVDB.
        """
        return pulumi.get(self, "kvdb_device")

    @property
    @pulumi.getter(name="systemMetadataDevice")
    def system_metadata_device(self) -> Optional[str]:
        """
        Device that will be used to store system metadata by the driver.
        """
        return pulumi.get(self, "system_metadata_device")

    @property
    @pulumi.getter(name="useAll")
    def use_all(self) -> Optional[bool]:
        """
        Use all available, unformatted, unpartitioned devices. This will be ignored if spec.storage.devices is not empty.
        """
        return pulumi.get(self, "use_all")

    @property
    @pulumi.getter(name="useAllWithPartitions")
    def use_all_with_partitions(self) -> Optional[bool]:
        """
        Use all available unformatted devices. This will be ignored if spec.storage.devices is not empty.
        """
        return pulumi.get(self, "use_all_with_partitions")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecPlacement(dict):
    """
    Describes placement configuration for the storage cluster pods.
    """
    def __init__(__self__, *,
                 node_affinity: Optional['outputs.StorageClusterSpecPlacementNodeAffinity'] = None,
                 tolerations: Optional[Sequence['outputs.StorageClusterSpecPlacementTolerations']] = None):
        """
        Describes placement configuration for the storage cluster pods.
        :param 'StorageClusterSpecPlacementNodeAffinityArgs' node_affinity: Describes node affinity scheduling rules for the storage cluster pods. This is exactly the same object as Kubernetes node affinity for pods.
        :param Sequence['StorageClusterSpecPlacementTolerationsArgs'] tolerations: Tolerations for all the pods deployed by the StorageCluster controller. The pod with this toleration attached will tolerate any taint that matches the triple <key,value,effect> using the matching operator <operator>.
        """
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional['outputs.StorageClusterSpecPlacementNodeAffinity']:
        """
        Describes node affinity scheduling rules for the storage cluster pods. This is exactly the same object as Kubernetes node affinity for pods.
        """
        return pulumi.get(self, "node_affinity")

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[Sequence['outputs.StorageClusterSpecPlacementTolerations']]:
        """
        Tolerations for all the pods deployed by the StorageCluster controller. The pod with this toleration attached will tolerate any taint that matches the triple <key,value,effect> using the matching operator <operator>.
        """
        return pulumi.get(self, "tolerations")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecPlacementNodeAffinity(dict):
    """
    Describes node affinity scheduling rules for the storage cluster pods. This is exactly the same object as Kubernetes node affinity for pods.
    """
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.StorageClusterSpecPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional['outputs.StorageClusterSpecPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution'] = None):
        """
        Describes node affinity scheduling rules for the storage cluster pods. This is exactly the same object as Kubernetes node affinity for pods.
        """
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.StorageClusterSpecPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional['outputs.StorageClusterSpecPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution']:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 preference: 'outputs.StorageClusterSpecPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference',
                 weight: int):
        pulumi.set(__self__, "preference", preference)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preference(self) -> 'outputs.StorageClusterSpecPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference':
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter
    def weight(self) -> int:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.StorageClusterSpecPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions']] = None,
                 match_fields: Optional[Sequence['outputs.StorageClusterSpecPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields']] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.StorageClusterSpecPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.StorageClusterSpecPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields']]:
        return pulumi.get(self, "match_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(dict):
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecPlacementNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(dict):
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 node_selector_terms: Sequence['outputs.StorageClusterSpecPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms']):
        pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> Sequence['outputs.StorageClusterSpecPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms']:
        return pulumi.get(self, "node_selector_terms")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.StorageClusterSpecPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions']] = None,
                 match_fields: Optional[Sequence['outputs.StorageClusterSpecPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields']] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.StorageClusterSpecPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.StorageClusterSpecPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields']]:
        return pulumi.get(self, "match_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(dict):
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecPlacementNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(dict):
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecPlacementTolerations(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 toleration_seconds: Optional[int] = None,
                 value: Optional[str] = None):
        """
        :param str effect: Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
        :param str key: Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
        :param str operator: Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
        :param int toleration_seconds: TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
        :param str value: Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
        """
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if toleration_seconds is not None:
            pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        """
        Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> Optional[int]:
        """
        TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
        """
        return pulumi.get(self, "toleration_seconds")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecStorage(dict):
    """
    Details of the storage used by the storage driver.
    """
    def __init__(__self__, *,
                 devices: Optional[Sequence[str]] = None,
                 force_use_disks: Optional[bool] = None,
                 journal_device: Optional[str] = None,
                 kvdb_device: Optional[str] = None,
                 system_metadata_device: Optional[str] = None,
                 use_all: Optional[bool] = None,
                 use_all_with_partitions: Optional[bool] = None):
        """
        Details of the storage used by the storage driver.
        :param Sequence[str] devices: List of devices to be used by the storage driver.
        :param bool force_use_disks: Flag indicating to use the devices even if there is file system present on it. Note that the devices may be wiped before using.
        :param str journal_device: Device used for journaling.
        :param str kvdb_device: Device used for internal KVDB.
        :param str system_metadata_device: Device that will be used to store system metadata by the driver.
        :param bool use_all: Use all available, unformatted, unpartitioned devices. This will be ignored if spec.storage.devices is not empty.
        :param bool use_all_with_partitions: Use all available unformatted devices. This will be ignored if spec.storage.devices is not empty.
        """
        if devices is not None:
            pulumi.set(__self__, "devices", devices)
        if force_use_disks is not None:
            pulumi.set(__self__, "force_use_disks", force_use_disks)
        if journal_device is not None:
            pulumi.set(__self__, "journal_device", journal_device)
        if kvdb_device is not None:
            pulumi.set(__self__, "kvdb_device", kvdb_device)
        if system_metadata_device is not None:
            pulumi.set(__self__, "system_metadata_device", system_metadata_device)
        if use_all is not None:
            pulumi.set(__self__, "use_all", use_all)
        if use_all_with_partitions is not None:
            pulumi.set(__self__, "use_all_with_partitions", use_all_with_partitions)

    @property
    @pulumi.getter
    def devices(self) -> Optional[Sequence[str]]:
        """
        List of devices to be used by the storage driver.
        """
        return pulumi.get(self, "devices")

    @property
    @pulumi.getter(name="forceUseDisks")
    def force_use_disks(self) -> Optional[bool]:
        """
        Flag indicating to use the devices even if there is file system present on it. Note that the devices may be wiped before using.
        """
        return pulumi.get(self, "force_use_disks")

    @property
    @pulumi.getter(name="journalDevice")
    def journal_device(self) -> Optional[str]:
        """
        Device used for journaling.
        """
        return pulumi.get(self, "journal_device")

    @property
    @pulumi.getter(name="kvdbDevice")
    def kvdb_device(self) -> Optional[str]:
        """
        Device used for internal KVDB.
        """
        return pulumi.get(self, "kvdb_device")

    @property
    @pulumi.getter(name="systemMetadataDevice")
    def system_metadata_device(self) -> Optional[str]:
        """
        Device that will be used to store system metadata by the driver.
        """
        return pulumi.get(self, "system_metadata_device")

    @property
    @pulumi.getter(name="useAll")
    def use_all(self) -> Optional[bool]:
        """
        Use all available, unformatted, unpartitioned devices. This will be ignored if spec.storage.devices is not empty.
        """
        return pulumi.get(self, "use_all")

    @property
    @pulumi.getter(name="useAllWithPartitions")
    def use_all_with_partitions(self) -> Optional[bool]:
        """
        Use all available unformatted devices. This will be ignored if spec.storage.devices is not empty.
        """
        return pulumi.get(self, "use_all_with_partitions")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecStork(dict):
    """
    Contains STORK related spec.
    """
    def __init__(__self__, *,
                 args: Optional[Mapping[str, Any]] = None,
                 enabled: Optional[bool] = None,
                 env: Optional[Sequence['outputs.StorageClusterSpecStorkEnv']] = None,
                 image: Optional[str] = None,
                 lock_image: Optional[bool] = None):
        """
        Contains STORK related spec.
        :param Mapping[str, Any] args: It is map of arguments given to STORK. Example: driver: pxd
        :param bool enabled: Flag indicating whether STORK needs to be enabled.
        :param Sequence['StorageClusterSpecStorkEnvArgs'] env: List of environment variables used by STORK. This is an array of Kubernetes EnvVar where the value can be given directly or from a source like field, config map or secret.
        :param str image: Docker image of the STORK container.
        :param bool lock_image: Flag indicating if the STORK image needs to be locked to the given image. If the image is not locked, it can be updated by the storage driver during upgrades.
        """
        if args is not None:
            pulumi.set(__self__, "args", args)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if env is not None:
            pulumi.set(__self__, "env", env)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if lock_image is not None:
            pulumi.set(__self__, "lock_image", lock_image)

    @property
    @pulumi.getter
    def args(self) -> Optional[Mapping[str, Any]]:
        """
        It is map of arguments given to STORK. Example: driver: pxd
        """
        return pulumi.get(self, "args")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Flag indicating whether STORK needs to be enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def env(self) -> Optional[Sequence['outputs.StorageClusterSpecStorkEnv']]:
        """
        List of environment variables used by STORK. This is an array of Kubernetes EnvVar where the value can be given directly or from a source like field, config map or secret.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        Docker image of the STORK container.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="lockImage")
    def lock_image(self) -> Optional[bool]:
        """
        Flag indicating if the STORK image needs to be locked to the given image. If the image is not locked, it can be updated by the storage driver during upgrades.
        """
        return pulumi.get(self, "lock_image")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecStorkEnv(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None,
                 value_from: Optional['outputs.StorageClusterSpecStorkEnvValueFrom'] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_from is not None:
            pulumi.set(__self__, "value_from", value_from)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueFrom")
    def value_from(self) -> Optional['outputs.StorageClusterSpecStorkEnvValueFrom']:
        return pulumi.get(self, "value_from")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecStorkEnvValueFrom(dict):
    def __init__(__self__, *,
                 config_map_key_ref: Optional['outputs.StorageClusterSpecStorkEnvValueFromConfigMapKeyRef'] = None,
                 field_ref: Optional['outputs.StorageClusterSpecStorkEnvValueFromFieldRef'] = None,
                 resource_field_ref: Optional['outputs.StorageClusterSpecStorkEnvValueFromResourceFieldRef'] = None,
                 secret_key_ref: Optional['outputs.StorageClusterSpecStorkEnvValueFromSecretKeyRef'] = None):
        if config_map_key_ref is not None:
            pulumi.set(__self__, "config_map_key_ref", config_map_key_ref)
        if field_ref is not None:
            pulumi.set(__self__, "field_ref", field_ref)
        if resource_field_ref is not None:
            pulumi.set(__self__, "resource_field_ref", resource_field_ref)
        if secret_key_ref is not None:
            pulumi.set(__self__, "secret_key_ref", secret_key_ref)

    @property
    @pulumi.getter(name="configMapKeyRef")
    def config_map_key_ref(self) -> Optional['outputs.StorageClusterSpecStorkEnvValueFromConfigMapKeyRef']:
        return pulumi.get(self, "config_map_key_ref")

    @property
    @pulumi.getter(name="fieldRef")
    def field_ref(self) -> Optional['outputs.StorageClusterSpecStorkEnvValueFromFieldRef']:
        return pulumi.get(self, "field_ref")

    @property
    @pulumi.getter(name="resourceFieldRef")
    def resource_field_ref(self) -> Optional['outputs.StorageClusterSpecStorkEnvValueFromResourceFieldRef']:
        return pulumi.get(self, "resource_field_ref")

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> Optional['outputs.StorageClusterSpecStorkEnvValueFromSecretKeyRef']:
        return pulumi.get(self, "secret_key_ref")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecStorkEnvValueFromConfigMapKeyRef(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        return pulumi.get(self, "optional")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecStorkEnvValueFromFieldRef(dict):
    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None):
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        return pulumi.get(self, "field_path")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecStorkEnvValueFromResourceFieldRef(dict):
    def __init__(__self__, *,
                 container_name: Optional[str] = None,
                 divisor: Optional[str] = None,
                 resource: Optional[str] = None):
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if divisor is not None:
            pulumi.set(__self__, "divisor", divisor)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[str]:
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def divisor(self) -> Optional[str]:
        return pulumi.get(self, "divisor")

    @property
    @pulumi.getter
    def resource(self) -> Optional[str]:
        return pulumi.get(self, "resource")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecStorkEnvValueFromSecretKeyRef(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        return pulumi.get(self, "optional")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecUpdateStrategy(dict):
    """
    An update strategy to replace existing StorageCluster pods with new pods.
    """
    def __init__(__self__, *,
                 rolling_update: Optional['outputs.StorageClusterSpecUpdateStrategyRollingUpdate'] = None,
                 type: Optional[str] = None):
        """
        An update strategy to replace existing StorageCluster pods with new pods.
        :param 'StorageClusterSpecUpdateStrategyRollingUpdateArgs' rolling_update: Spec to control the desired behavior of storage cluster rolling update.
        :param str type: Type of storage cluster update. Can be RollingUpdate or OnDelete. Default is RollingUpdate.
        """
        if rolling_update is not None:
            pulumi.set(__self__, "rolling_update", rolling_update)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="rollingUpdate")
    def rolling_update(self) -> Optional['outputs.StorageClusterSpecUpdateStrategyRollingUpdate']:
        """
        Spec to control the desired behavior of storage cluster rolling update.
        """
        return pulumi.get(self, "rolling_update")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of storage cluster update. Can be RollingUpdate or OnDelete. Default is RollingUpdate.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecUpdateStrategyRollingUpdate(dict):
    """
    Spec to control the desired behavior of storage cluster rolling update.
    """
    def __init__(__self__, *,
                 max_unavailable: Optional[Any] = None):
        """
        Spec to control the desired behavior of storage cluster rolling update.
        :param Union[int, str] max_unavailable: The maximum number of StorageCluster pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of total number of StorageCluster pods at the start of the update (ex: 10%). Absolute number is calculated from percentage by rounding up. This cannot be 0. Default value is 1. Example: when this is set to 30%, at most 30% of the total number of nodes that should be running the storage pod can have their pods stopped for an update at any given time. The update starts by stopping at most 30% of those StorageCluster pods and then brings up new StorageCluster pods in their place. Once the new pods are available, it then proceeds onto other StorageCluster pods, thus ensuring that at least 70% of original number of StorageCluster pods are available at all times during the update.
        """
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[Any]:
        """
        The maximum number of StorageCluster pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of total number of StorageCluster pods at the start of the update (ex: 10%). Absolute number is calculated from percentage by rounding up. This cannot be 0. Default value is 1. Example: when this is set to 30%, at most 30% of the total number of nodes that should be running the storage pod can have their pods stopped for an update at any given time. The update starts by stopping at most 30% of those StorageCluster pods and then brings up new StorageCluster pods in their place. Once the new pods are available, it then proceeds onto other StorageCluster pods, thus ensuring that at least 70% of original number of StorageCluster pods are available at all times during the update.
        """
        return pulumi.get(self, "max_unavailable")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecUserInterface(dict):
    """
    Contains spec of a user interface for the storage driver.
    """
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 env: Optional[Sequence['outputs.StorageClusterSpecUserInterfaceEnv']] = None,
                 image: Optional[str] = None,
                 lock_image: Optional[bool] = None):
        """
        Contains spec of a user interface for the storage driver.
        :param bool enabled: Flag indicating whether the user interface needs to be enabled.
        :param Sequence['StorageClusterSpecUserInterfaceEnvArgs'] env: List of environment variables used by the UI components. This is an array of Kubernetes EnvVar where the value can be given directly or from a source like field, config map or secret.
        :param str image: Docker image of the user interface container.
        :param bool lock_image: Flag indicating if the user interface image needs to be locked to the given image. If the image is not locked, it can be updated by the storage driver during upgrades.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if env is not None:
            pulumi.set(__self__, "env", env)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if lock_image is not None:
            pulumi.set(__self__, "lock_image", lock_image)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Flag indicating whether the user interface needs to be enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def env(self) -> Optional[Sequence['outputs.StorageClusterSpecUserInterfaceEnv']]:
        """
        List of environment variables used by the UI components. This is an array of Kubernetes EnvVar where the value can be given directly or from a source like field, config map or secret.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        Docker image of the user interface container.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="lockImage")
    def lock_image(self) -> Optional[bool]:
        """
        Flag indicating if the user interface image needs to be locked to the given image. If the image is not locked, it can be updated by the storage driver during upgrades.
        """
        return pulumi.get(self, "lock_image")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecUserInterfaceEnv(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None,
                 value_from: Optional['outputs.StorageClusterSpecUserInterfaceEnvValueFrom'] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_from is not None:
            pulumi.set(__self__, "value_from", value_from)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueFrom")
    def value_from(self) -> Optional['outputs.StorageClusterSpecUserInterfaceEnvValueFrom']:
        return pulumi.get(self, "value_from")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecUserInterfaceEnvValueFrom(dict):
    def __init__(__self__, *,
                 config_map_key_ref: Optional['outputs.StorageClusterSpecUserInterfaceEnvValueFromConfigMapKeyRef'] = None,
                 field_ref: Optional['outputs.StorageClusterSpecUserInterfaceEnvValueFromFieldRef'] = None,
                 resource_field_ref: Optional['outputs.StorageClusterSpecUserInterfaceEnvValueFromResourceFieldRef'] = None,
                 secret_key_ref: Optional['outputs.StorageClusterSpecUserInterfaceEnvValueFromSecretKeyRef'] = None):
        if config_map_key_ref is not None:
            pulumi.set(__self__, "config_map_key_ref", config_map_key_ref)
        if field_ref is not None:
            pulumi.set(__self__, "field_ref", field_ref)
        if resource_field_ref is not None:
            pulumi.set(__self__, "resource_field_ref", resource_field_ref)
        if secret_key_ref is not None:
            pulumi.set(__self__, "secret_key_ref", secret_key_ref)

    @property
    @pulumi.getter(name="configMapKeyRef")
    def config_map_key_ref(self) -> Optional['outputs.StorageClusterSpecUserInterfaceEnvValueFromConfigMapKeyRef']:
        return pulumi.get(self, "config_map_key_ref")

    @property
    @pulumi.getter(name="fieldRef")
    def field_ref(self) -> Optional['outputs.StorageClusterSpecUserInterfaceEnvValueFromFieldRef']:
        return pulumi.get(self, "field_ref")

    @property
    @pulumi.getter(name="resourceFieldRef")
    def resource_field_ref(self) -> Optional['outputs.StorageClusterSpecUserInterfaceEnvValueFromResourceFieldRef']:
        return pulumi.get(self, "resource_field_ref")

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> Optional['outputs.StorageClusterSpecUserInterfaceEnvValueFromSecretKeyRef']:
        return pulumi.get(self, "secret_key_ref")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecUserInterfaceEnvValueFromConfigMapKeyRef(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        return pulumi.get(self, "optional")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecUserInterfaceEnvValueFromFieldRef(dict):
    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None):
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        return pulumi.get(self, "field_path")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecUserInterfaceEnvValueFromResourceFieldRef(dict):
    def __init__(__self__, *,
                 container_name: Optional[str] = None,
                 divisor: Optional[str] = None,
                 resource: Optional[str] = None):
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if divisor is not None:
            pulumi.set(__self__, "divisor", divisor)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[str]:
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def divisor(self) -> Optional[str]:
        return pulumi.get(self, "divisor")

    @property
    @pulumi.getter
    def resource(self) -> Optional[str]:
        return pulumi.get(self, "resource")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterSpecUserInterfaceEnvValueFromSecretKeyRef(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        return pulumi.get(self, "optional")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterStatus(dict):
    """
    Most recently observed status of the storage cluster. This data may not be up to date.
    """
    def __init__(__self__, *,
                 cluster_name: Optional[str] = None,
                 cluster_uid: Optional[str] = None,
                 collision_count: Optional[int] = None,
                 conditions: Optional[Sequence['outputs.StorageClusterStatusConditions']] = None,
                 phase: Optional[str] = None,
                 storage: Optional['outputs.StorageClusterStatusStorage'] = None):
        """
        Most recently observed status of the storage cluster. This data may not be up to date.
        :param str cluster_name: Name of the storage cluster.
        :param str cluster_uid: Unique ID of the storage cluster.
        :param int collision_count: Count of hash collisions for the StorageCluster. The StorageCluster controller uses this field as a collision avoidance mechanism when it needs to create the name of the newest ControllerRevision.
        :param Sequence['StorageClusterStatusConditionsArgs'] conditions: Contains details for the current condition of this cluster.
        :param str phase: Phase of the StorageCluster is a simple, high-level summary of where the StorageCluster is in its lifecycle. The condition array contains more detailed information about the state of the cluster.
        :param 'StorageClusterStatusStorageArgs' storage: Contains details of storage in the cluster.
        """
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if cluster_uid is not None:
            pulumi.set(__self__, "cluster_uid", cluster_uid)
        if collision_count is not None:
            pulumi.set(__self__, "collision_count", collision_count)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[str]:
        """
        Name of the storage cluster.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="clusterUid")
    def cluster_uid(self) -> Optional[str]:
        """
        Unique ID of the storage cluster.
        """
        return pulumi.get(self, "cluster_uid")

    @property
    @pulumi.getter(name="collisionCount")
    def collision_count(self) -> Optional[int]:
        """
        Count of hash collisions for the StorageCluster. The StorageCluster controller uses this field as a collision avoidance mechanism when it needs to create the name of the newest ControllerRevision.
        """
        return pulumi.get(self, "collision_count")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.StorageClusterStatusConditions']]:
        """
        Contains details for the current condition of this cluster.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def phase(self) -> Optional[str]:
        """
        Phase of the StorageCluster is a simple, high-level summary of where the StorageCluster is in its lifecycle. The condition array contains more detailed information about the state of the cluster.
        """
        return pulumi.get(self, "phase")

    @property
    @pulumi.getter
    def storage(self) -> Optional['outputs.StorageClusterStatusStorage']:
        """
        Contains details of storage in the cluster.
        """
        return pulumi.get(self, "storage")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterStatusConditions(dict):
    def __init__(__self__, *,
                 reason: Optional[str] = None,
                 status: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str reason: Reason is human readable message indicating details about the current state of the cluster.
        :param str status: Status of the condition.
        :param str type: Type of the condition.
        """
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        Reason is human readable message indicating details about the current state of the cluster.
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Status of the condition.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the condition.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageClusterStatusStorage(dict):
    """
    Contains details of storage in the cluster.
    """
    def __init__(__self__, *,
                 storage_nodes_per_zone: Optional[int] = None):
        """
        Contains details of storage in the cluster.
        :param int storage_nodes_per_zone: The number of storage nodes per zone in the cluster.
        """
        if storage_nodes_per_zone is not None:
            pulumi.set(__self__, "storage_nodes_per_zone", storage_nodes_per_zone)

    @property
    @pulumi.getter(name="storageNodesPerZone")
    def storage_nodes_per_zone(self) -> Optional[int]:
        """
        The number of storage nodes per zone in the cluster.
        """
        return pulumi.get(self, "storage_nodes_per_zone")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageNodeSpec(dict):
    """
    The desired behavior of the storage node. Currently changing the spec does not affect the actual storage node in the cluster. Eventually spec in StorageNode will override the spec from StorageCluster so that configuration can be overridden at node level.
    """
    def __init__(__self__, *,
                 cloud_storage: Optional['outputs.StorageNodeSpecCloudStorage'] = None,
                 version: Optional[str] = None):
        """
        The desired behavior of the storage node. Currently changing the spec does not affect the actual storage node in the cluster. Eventually spec in StorageNode will override the spec from StorageCluster so that configuration can be overridden at node level.
        :param 'StorageNodeSpecCloudStorageArgs' cloud_storage: Details of storage on the node for cloud environments.
        :param str version: Version of the storage driver on the node.
        """
        if cloud_storage is not None:
            pulumi.set(__self__, "cloud_storage", cloud_storage)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="cloudStorage")
    def cloud_storage(self) -> Optional['outputs.StorageNodeSpecCloudStorage']:
        """
        Details of storage on the node for cloud environments.
        """
        return pulumi.get(self, "cloud_storage")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Version of the storage driver on the node.
        """
        return pulumi.get(self, "version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageNodeSpecCloudStorage(dict):
    """
    Details of storage on the node for cloud environments.
    """
    def __init__(__self__, *,
                 drive_configs: Optional[Sequence['outputs.StorageNodeSpecCloudStorageDriveConfigs']] = None):
        """
        Details of storage on the node for cloud environments.
        :param Sequence['StorageNodeSpecCloudStorageDriveConfigsArgs'] drive_configs: List of cloud drive configs for the storage node.
        """
        if drive_configs is not None:
            pulumi.set(__self__, "drive_configs", drive_configs)

    @property
    @pulumi.getter(name="driveConfigs")
    def drive_configs(self) -> Optional[Sequence['outputs.StorageNodeSpecCloudStorageDriveConfigs']]:
        """
        List of cloud drive configs for the storage node.
        """
        return pulumi.get(self, "drive_configs")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageNodeSpecCloudStorageDriveConfigs(dict):
    def __init__(__self__, *,
                 iops: Optional[int] = None,
                 options: Optional[Mapping[str, Any]] = None,
                 size_in_gi_b: Optional[int] = None,
                 type: Optional[str] = None):
        """
        :param int iops: IOPS required from the cloud drive.
        :param Mapping[str, Any] options: Additional options for the cloud drive.
        :param int size_in_gi_b: Size of cloud drive in GiB.
        :param str type: Type of cloud drive.
        """
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if size_in_gi_b is not None:
            pulumi.set(__self__, "size_in_gi_b", size_in_gi_b)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        """
        IOPS required from the cloud drive.
        """
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter
    def options(self) -> Optional[Mapping[str, Any]]:
        """
        Additional options for the cloud drive.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter(name="sizeInGiB")
    def size_in_gi_b(self) -> Optional[int]:
        """
        Size of cloud drive in GiB.
        """
        return pulumi.get(self, "size_in_gi_b")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of cloud drive.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageNodeStatus(dict):
    """
    Most recently observed status of the storage node. The data may not be up to date.
    """
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.StorageNodeStatusConditions']] = None,
                 geography: Optional['outputs.StorageNodeStatusGeography'] = None,
                 network: Optional['outputs.StorageNodeStatusNetwork'] = None,
                 node_uid: Optional[str] = None,
                 phase: Optional[str] = None):
        """
        Most recently observed status of the storage node. The data may not be up to date.
        :param Sequence['StorageNodeStatusConditionsArgs'] conditions: Contains details for the current condition of this storage node.
        :param 'StorageNodeStatusGeographyArgs' geography: Contains topology information for the storage node.
        :param str node_uid: Unique ID of the storage node.
        :param str phase: Phase of the StorageNode is a simple, high-level summary of where the StorageNode is in its lifecycle. The condition array contains more detailed information about the state of the node.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if geography is not None:
            pulumi.set(__self__, "geography", geography)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if node_uid is not None:
            pulumi.set(__self__, "node_uid", node_uid)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.StorageNodeStatusConditions']]:
        """
        Contains details for the current condition of this storage node.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def geography(self) -> Optional['outputs.StorageNodeStatusGeography']:
        """
        Contains topology information for the storage node.
        """
        return pulumi.get(self, "geography")

    @property
    @pulumi.getter
    def network(self) -> Optional['outputs.StorageNodeStatusNetwork']:
        return pulumi.get(self, "network")

    @property
    @pulumi.getter(name="nodeUid")
    def node_uid(self) -> Optional[str]:
        """
        Unique ID of the storage node.
        """
        return pulumi.get(self, "node_uid")

    @property
    @pulumi.getter
    def phase(self) -> Optional[str]:
        """
        Phase of the StorageNode is a simple, high-level summary of where the StorageNode is in its lifecycle. The condition array contains more detailed information about the state of the node.
        """
        return pulumi.get(self, "phase")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageNodeStatusConditions(dict):
    def __init__(__self__, *,
                 reason: Optional[str] = None,
                 status: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str reason: Reason is the human readable message indicating details about the current state of the cluster.
        :param str status: Status of the condition.
        :param str type: Type of the condition.
        """
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        Reason is the human readable message indicating details about the current state of the cluster.
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Status of the condition.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the condition.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageNodeStatusGeography(dict):
    """
    Contains topology information for the storage node.
    """
    def __init__(__self__, *,
                 rack: Optional[str] = None,
                 region: Optional[str] = None,
                 zone: Optional[str] = None):
        """
        Contains topology information for the storage node.
        :param str rack: Rack on which the storage node is placed.
        :param str region: Region in which the storage node is placed.
        :param str zone: Zone in which the storage node is placed.
        """
        if rack is not None:
            pulumi.set(__self__, "rack", rack)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter
    def rack(self) -> Optional[str]:
        """
        Rack on which the storage node is placed.
        """
        return pulumi.get(self, "rack")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Region in which the storage node is placed.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def zone(self) -> Optional[str]:
        """
        Zone in which the storage node is placed.
        """
        return pulumi.get(self, "zone")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class StorageNodeStatusNetwork(dict):
    def __init__(__self__, *,
                 data_ip: Optional[str] = None,
                 mgmt_ip: Optional[str] = None):
        """
        :param str data_ip: IP address used by the storage driver for data traffic.
        :param str mgmt_ip: IP address used by the storage driver for management traffic.
        """
        if data_ip is not None:
            pulumi.set(__self__, "data_ip", data_ip)
        if mgmt_ip is not None:
            pulumi.set(__self__, "mgmt_ip", mgmt_ip)

    @property
    @pulumi.getter(name="dataIP")
    def data_ip(self) -> Optional[str]:
        """
        IP address used by the storage driver for data traffic.
        """
        return pulumi.get(self, "data_ip")

    @property
    @pulumi.getter(name="mgmtIP")
    def mgmt_ip(self) -> Optional[str]:
        """
        IP address used by the storage driver for management traffic.
        """
        return pulumi.get(self, "mgmt_ip")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


