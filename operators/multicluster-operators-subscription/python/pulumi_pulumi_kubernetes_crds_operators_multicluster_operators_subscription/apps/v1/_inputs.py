# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from ... import _utilities, _tables

__all__ = [
    'ChannelSpecArgs',
    'ChannelSpecConfigMapRefArgs',
    'ChannelSpecGatesArgs',
    'ChannelSpecGatesLabelSelectorArgs',
    'ChannelSpecGatesLabelSelectorMatchExpressionsArgs',
    'ChannelSpecSecretRefArgs',
    'DeployableSpecArgs',
    'DeployableSpecDependenciesArgs',
    'DeployableSpecOverridesArgs',
    'DeployableSpecPlacementArgs',
    'DeployableSpecPlacementClusterSelectorArgs',
    'DeployableSpecPlacementClusterSelectorMatchExpressionsArgs',
    'DeployableSpecPlacementClustersArgs',
    'DeployableSpecPlacementPlacementRefArgs',
    'DeployableStatusArgs',
    'HelmReleaseRepoArgs',
    'HelmReleaseRepoConfigMapRefArgs',
    'HelmReleaseRepoSecretRefArgs',
    'HelmReleaseRepoSourceArgs',
    'HelmReleaseRepoSourceGithubArgs',
    'HelmReleaseRepoSourceHelmRepoArgs',
    'HelmReleaseStatusArgs',
    'HelmReleaseStatusConditionsArgs',
    'HelmReleaseStatusDeployedReleaseArgs',
    'PlacementRuleSpecArgs',
    'PlacementRuleSpecClusterConditionsArgs',
    'PlacementRuleSpecClusterSelectorArgs',
    'PlacementRuleSpecClusterSelectorMatchExpressionsArgs',
    'PlacementRuleSpecClustersArgs',
    'PlacementRuleSpecPoliciesArgs',
    'PlacementRuleSpecResourceHintArgs',
    'PlacementRuleStatusArgs',
    'PlacementRuleStatusDecisionsArgs',
    'SubscriptionSpecArgs',
    'SubscriptionSpecHooksecretrefArgs',
    'SubscriptionSpecOverridesArgs',
    'SubscriptionSpecPackageFilterArgs',
    'SubscriptionSpecPackageFilterFilterRefArgs',
    'SubscriptionSpecPackageFilterLabelSelectorArgs',
    'SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArgs',
    'SubscriptionSpecPackageOverridesArgs',
    'SubscriptionSpecPlacementArgs',
    'SubscriptionSpecPlacementClusterSelectorArgs',
    'SubscriptionSpecPlacementClusterSelectorMatchExpressionsArgs',
    'SubscriptionSpecPlacementClustersArgs',
    'SubscriptionSpecPlacementPlacementRefArgs',
    'SubscriptionSpecTimewindowArgs',
    'SubscriptionSpecTimewindowHoursArgs',
    'SubscriptionStatusArgs',
    'SubscriptionStatusAnsiblejobsArgs',
    'SubscriptionStatusStatusesArgs',
    'SubscriptionStatusStatusesPackagesArgs',
]

@pulumi.input_type
class ChannelSpecArgs:
    def __init__(__self__, *,
                 pathname: pulumi.Input[str],
                 type: pulumi.Input[str],
                 config_map_ref: Optional[pulumi.Input['ChannelSpecConfigMapRefArgs']] = None,
                 gates: Optional[pulumi.Input['ChannelSpecGatesArgs']] = None,
                 insecure_skip_verify: Optional[pulumi.Input[bool]] = None,
                 secret_ref: Optional[pulumi.Input['ChannelSpecSecretRefArgs']] = None,
                 source_namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        ChannelSpec defines the desired state of Channel
        :param pulumi.Input[str] pathname: For a `namespace` channel, pathname is the name of the namespace; For a `helmrepo` or `github` channel, pathname is the remote URL for the channel contents; For a `objectbucket` channel, pathname is the URL and name of the bucket.
        :param pulumi.Input[str] type: ChannelType defines types of channel
        :param pulumi.Input['ChannelSpecConfigMapRefArgs'] config_map_ref: Reference to a ConfigMap which contains additional settings for accessing the channel. For example, the `insecureSkipVerify` option for accessing HTTPS endpoints can be set in the ConfigMap to indicate a insecure connection.
        :param pulumi.Input['ChannelSpecGatesArgs'] gates: Criteria for promoting a Deployable from the sourceNamespaces to Channel.
        :param pulumi.Input[bool] insecure_skip_verify: Skip server TLS certificate verification for Git or Helm channel.
        :param pulumi.Input['ChannelSpecSecretRefArgs'] secret_ref: For a `github` channel or a `helmrepo` channel on github, this can be used to reference a Secret which contains the credentials for authentication, i.e. `user` and `accessToken`. For a `objectbucket` channel, this can be used to reference a Secret which contains the AWS credentials, i.e. `AccessKeyID` and `SecretAccessKey`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] source_namespaces: A list of namespace names from which Deployables can be promoted.
        """
        pulumi.set(__self__, "pathname", pathname)
        pulumi.set(__self__, "type", type)
        if config_map_ref is not None:
            pulumi.set(__self__, "config_map_ref", config_map_ref)
        if gates is not None:
            pulumi.set(__self__, "gates", gates)
        if insecure_skip_verify is not None:
            pulumi.set(__self__, "insecure_skip_verify", insecure_skip_verify)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)
        if source_namespaces is not None:
            pulumi.set(__self__, "source_namespaces", source_namespaces)

    @property
    @pulumi.getter
    def pathname(self) -> pulumi.Input[str]:
        """
        For a `namespace` channel, pathname is the name of the namespace; For a `helmrepo` or `github` channel, pathname is the remote URL for the channel contents; For a `objectbucket` channel, pathname is the URL and name of the bucket.
        """
        return pulumi.get(self, "pathname")

    @pathname.setter
    def pathname(self, value: pulumi.Input[str]):
        pulumi.set(self, "pathname", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        ChannelType defines types of channel
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="configMapRef")
    def config_map_ref(self) -> Optional[pulumi.Input['ChannelSpecConfigMapRefArgs']]:
        """
        Reference to a ConfigMap which contains additional settings for accessing the channel. For example, the `insecureSkipVerify` option for accessing HTTPS endpoints can be set in the ConfigMap to indicate a insecure connection.
        """
        return pulumi.get(self, "config_map_ref")

    @config_map_ref.setter
    def config_map_ref(self, value: Optional[pulumi.Input['ChannelSpecConfigMapRefArgs']]):
        pulumi.set(self, "config_map_ref", value)

    @property
    @pulumi.getter
    def gates(self) -> Optional[pulumi.Input['ChannelSpecGatesArgs']]:
        """
        Criteria for promoting a Deployable from the sourceNamespaces to Channel.
        """
        return pulumi.get(self, "gates")

    @gates.setter
    def gates(self, value: Optional[pulumi.Input['ChannelSpecGatesArgs']]):
        pulumi.set(self, "gates", value)

    @property
    @pulumi.getter(name="insecureSkipVerify")
    def insecure_skip_verify(self) -> Optional[pulumi.Input[bool]]:
        """
        Skip server TLS certificate verification for Git or Helm channel.
        """
        return pulumi.get(self, "insecure_skip_verify")

    @insecure_skip_verify.setter
    def insecure_skip_verify(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "insecure_skip_verify", value)

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional[pulumi.Input['ChannelSpecSecretRefArgs']]:
        """
        For a `github` channel or a `helmrepo` channel on github, this can be used to reference a Secret which contains the credentials for authentication, i.e. `user` and `accessToken`. For a `objectbucket` channel, this can be used to reference a Secret which contains the AWS credentials, i.e. `AccessKeyID` and `SecretAccessKey`.
        """
        return pulumi.get(self, "secret_ref")

    @secret_ref.setter
    def secret_ref(self, value: Optional[pulumi.Input['ChannelSpecSecretRefArgs']]):
        pulumi.set(self, "secret_ref", value)

    @property
    @pulumi.getter(name="sourceNamespaces")
    def source_namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of namespace names from which Deployables can be promoted.
        """
        return pulumi.get(self, "source_namespaces")

    @source_namespaces.setter
    def source_namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "source_namespaces", value)


@pulumi.input_type
class ChannelSpecConfigMapRefArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 field_path: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 resource_version: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        Reference to a ConfigMap which contains additional settings for accessing the channel. For example, the `insecureSkipVerify` option for accessing HTTPS endpoints can be set in the ConfigMap to indicate a insecure connection.
        :param pulumi.Input[str] api_version: API version of the referent.
        :param pulumi.Input[str] field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param pulumi.Input[str] kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param pulumi.Input[str] namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param pulumi.Input[str] resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param pulumi.Input[str] uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[pulumi.Input[str]]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_path", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @resource_version.setter
    def resource_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_version", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class ChannelSpecGatesArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 label_selector: Optional[pulumi.Input['ChannelSpecGatesLabelSelectorArgs']] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        Criteria for promoting a Deployable from the sourceNamespaces to Channel.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] annotations: The annotations which must present on a Deployable for it to be eligible for promotion.
        :param pulumi.Input['ChannelSpecGatesLabelSelectorArgs'] label_selector: A label selector for selecting the Deployables.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The annotations which must present on a Deployable for it to be eligible for promotion.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['ChannelSpecGatesLabelSelectorArgs']]:
        """
        A label selector for selecting the Deployables.
        """
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['ChannelSpecGatesLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class ChannelSpecGatesLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelSpecGatesLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        A label selector for selecting the Deployables.
        :param pulumi.Input[Sequence[pulumi.Input['ChannelSpecGatesLabelSelectorMatchExpressionsArgs']]] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ChannelSpecGatesLabelSelectorMatchExpressionsArgs']]]]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ChannelSpecGatesLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class ChannelSpecGatesLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param pulumi.Input[str] key: key is the label key that the selector applies to.
        :param pulumi.Input[str] operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class ChannelSpecSecretRefArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 field_path: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 resource_version: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        For a `github` channel or a `helmrepo` channel on github, this can be used to reference a Secret which contains the credentials for authentication, i.e. `user` and `accessToken`. For a `objectbucket` channel, this can be used to reference a Secret which contains the AWS credentials, i.e. `AccessKeyID` and `SecretAccessKey`.
        :param pulumi.Input[str] api_version: API version of the referent.
        :param pulumi.Input[str] field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param pulumi.Input[str] kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param pulumi.Input[str] namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param pulumi.Input[str] resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param pulumi.Input[str] uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[pulumi.Input[str]]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_path", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @resource_version.setter
    def resource_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_version", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class DeployableSpecArgs:
    def __init__(__self__, *,
                 template: pulumi.Input[Mapping[str, Any]],
                 channels: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 dependencies: Optional[pulumi.Input[Sequence[pulumi.Input['DeployableSpecDependenciesArgs']]]] = None,
                 overrides: Optional[pulumi.Input[Sequence[pulumi.Input['DeployableSpecOverridesArgs']]]] = None,
                 placement: Optional[pulumi.Input['DeployableSpecPlacementArgs']] = None):
        """
        DeployableSpec defines the desired state of Deployable
        :param pulumi.Input['DeployableSpecPlacementArgs'] placement: Placement field to be referenced in specs, align with Fedv2, add placementref
        """
        pulumi.set(__self__, "template", template)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if dependencies is not None:
            pulumi.set(__self__, "dependencies", dependencies)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)

    @property
    @pulumi.getter
    def template(self) -> pulumi.Input[Mapping[str, Any]]:
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: pulumi.Input[Mapping[str, Any]]):
        pulumi.set(self, "template", value)

    @property
    @pulumi.getter
    def channels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "channels")

    @channels.setter
    def channels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "channels", value)

    @property
    @pulumi.getter
    def dependencies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeployableSpecDependenciesArgs']]]]:
        return pulumi.get(self, "dependencies")

    @dependencies.setter
    def dependencies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeployableSpecDependenciesArgs']]]]):
        pulumi.set(self, "dependencies", value)

    @property
    @pulumi.getter
    def overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeployableSpecOverridesArgs']]]]:
        return pulumi.get(self, "overrides")

    @overrides.setter
    def overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeployableSpecOverridesArgs']]]]):
        pulumi.set(self, "overrides", value)

    @property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input['DeployableSpecPlacementArgs']]:
        """
        Placement field to be referenced in specs, align with Fedv2, add placementref
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input['DeployableSpecPlacementArgs']]):
        pulumi.set(self, "placement", value)


@pulumi.input_type
class DeployableSpecDependenciesArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 api_version: Optional[pulumi.Input[str]] = None,
                 field_path: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 resource_version: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        Dependency of Deployable Properties field is the flexiblity for different Kind
        :param pulumi.Input[str] api_version: API version of the referent.
        :param pulumi.Input[str] field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param pulumi.Input[str] kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param pulumi.Input[str] namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param pulumi.Input[str] resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
        :param pulumi.Input[str] uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[pulumi.Input[str]]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_path", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @resource_version.setter
    def resource_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_version", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class DeployableSpecOverridesArgs:
    def __init__(__self__, *,
                 cluster_name: pulumi.Input[str],
                 cluster_overrides: pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]):
        """
        Overrides field in deployable
        """
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "cluster_overrides", cluster_overrides)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="clusterOverrides")
    def cluster_overrides(self) -> pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]:
        return pulumi.get(self, "cluster_overrides")

    @cluster_overrides.setter
    def cluster_overrides(self, value: pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]):
        pulumi.set(self, "cluster_overrides", value)


@pulumi.input_type
class DeployableSpecPlacementArgs:
    def __init__(__self__, *,
                 cluster_selector: Optional[pulumi.Input['DeployableSpecPlacementClusterSelectorArgs']] = None,
                 clusters: Optional[pulumi.Input[Sequence[pulumi.Input['DeployableSpecPlacementClustersArgs']]]] = None,
                 local: Optional[pulumi.Input[bool]] = None,
                 placement_ref: Optional[pulumi.Input['DeployableSpecPlacementPlacementRefArgs']] = None):
        """
        Placement field to be referenced in specs, align with Fedv2, add placementref
        :param pulumi.Input['DeployableSpecPlacementClusterSelectorArgs'] cluster_selector: A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
        :param pulumi.Input['DeployableSpecPlacementPlacementRefArgs'] placement_ref: ObjectReference contains enough information to let you inspect or modify the referred object.
        """
        if cluster_selector is not None:
            pulumi.set(__self__, "cluster_selector", cluster_selector)
        if clusters is not None:
            pulumi.set(__self__, "clusters", clusters)
        if local is not None:
            pulumi.set(__self__, "local", local)
        if placement_ref is not None:
            pulumi.set(__self__, "placement_ref", placement_ref)

    @property
    @pulumi.getter(name="clusterSelector")
    def cluster_selector(self) -> Optional[pulumi.Input['DeployableSpecPlacementClusterSelectorArgs']]:
        """
        A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
        """
        return pulumi.get(self, "cluster_selector")

    @cluster_selector.setter
    def cluster_selector(self, value: Optional[pulumi.Input['DeployableSpecPlacementClusterSelectorArgs']]):
        pulumi.set(self, "cluster_selector", value)

    @property
    @pulumi.getter
    def clusters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeployableSpecPlacementClustersArgs']]]]:
        return pulumi.get(self, "clusters")

    @clusters.setter
    def clusters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeployableSpecPlacementClustersArgs']]]]):
        pulumi.set(self, "clusters", value)

    @property
    @pulumi.getter
    def local(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "local")

    @local.setter
    def local(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "local", value)

    @property
    @pulumi.getter(name="placementRef")
    def placement_ref(self) -> Optional[pulumi.Input['DeployableSpecPlacementPlacementRefArgs']]:
        """
        ObjectReference contains enough information to let you inspect or modify the referred object.
        """
        return pulumi.get(self, "placement_ref")

    @placement_ref.setter
    def placement_ref(self, value: Optional[pulumi.Input['DeployableSpecPlacementPlacementRefArgs']]):
        pulumi.set(self, "placement_ref", value)


@pulumi.input_type
class DeployableSpecPlacementClusterSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['DeployableSpecPlacementClusterSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
        :param pulumi.Input[Sequence[pulumi.Input['DeployableSpecPlacementClusterSelectorMatchExpressionsArgs']]] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeployableSpecPlacementClusterSelectorMatchExpressionsArgs']]]]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeployableSpecPlacementClusterSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class DeployableSpecPlacementClusterSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param pulumi.Input[str] key: key is the label key that the selector applies to.
        :param pulumi.Input[str] operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class DeployableSpecPlacementClustersArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        GenericClusterReference - in alignment with kubefed
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class DeployableSpecPlacementPlacementRefArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 field_path: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 resource_version: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        ObjectReference contains enough information to let you inspect or modify the referred object.
        :param pulumi.Input[str] api_version: API version of the referent.
        :param pulumi.Input[str] field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param pulumi.Input[str] kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param pulumi.Input[str] namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param pulumi.Input[str] resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
        :param pulumi.Input[str] uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[pulumi.Input[str]]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_path", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @resource_version.setter
    def resource_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_version", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class DeployableStatusArgs:
    def __init__(__self__, *,
                 target_clusters: Optional[Any] = None):
        """
        DeployableStatus defines the observed state of Deployable
        """
        if target_clusters is not None:
            pulumi.set(__self__, "target_clusters", target_clusters)

    @property
    @pulumi.getter(name="targetClusters")
    def target_clusters(self) -> Optional[Any]:
        return pulumi.get(self, "target_clusters")

    @target_clusters.setter
    def target_clusters(self, value: Optional[Any]):
        pulumi.set(self, "target_clusters", value)


@pulumi.input_type
class HelmReleaseRepoArgs:
    def __init__(__self__, *,
                 chart_name: Optional[pulumi.Input[str]] = None,
                 config_map_ref: Optional[pulumi.Input['HelmReleaseRepoConfigMapRefArgs']] = None,
                 insecure_skip_verify: Optional[pulumi.Input[bool]] = None,
                 secret_ref: Optional[pulumi.Input['HelmReleaseRepoSecretRefArgs']] = None,
                 source: Optional[pulumi.Input['HelmReleaseRepoSourceArgs']] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        HelmReleaseRepo defines the repository of HelmRelease
        :param pulumi.Input[str] chart_name: ChartName is the name of the chart within the repo
        :param pulumi.Input['HelmReleaseRepoConfigMapRefArgs'] config_map_ref: Configuration parameters to access the helm-repo defined in the CatalogSource
        :param pulumi.Input[bool] insecure_skip_verify: Used to skip repo server's TLS certificate verification
        :param pulumi.Input['HelmReleaseRepoSecretRefArgs'] secret_ref: Secret to use to access the helm-repo defined in the CatalogSource.
        :param pulumi.Input['HelmReleaseRepoSourceArgs'] source: INSERT ADDITIONAL SPEC FIELDS - desired state of cluster Important: Run "operator-sdk generate k8s" to regenerate code after modifying this file Add custom validation using kubebuilder tags: https://book-v1.book.kubebuilder.io/beyond_basics/generating_crd.html Source holds the url toward the helm-chart
        :param pulumi.Input[str] version: Version is the chart version
        """
        if chart_name is not None:
            pulumi.set(__self__, "chart_name", chart_name)
        if config_map_ref is not None:
            pulumi.set(__self__, "config_map_ref", config_map_ref)
        if insecure_skip_verify is not None:
            pulumi.set(__self__, "insecure_skip_verify", insecure_skip_verify)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="chartName")
    def chart_name(self) -> Optional[pulumi.Input[str]]:
        """
        ChartName is the name of the chart within the repo
        """
        return pulumi.get(self, "chart_name")

    @chart_name.setter
    def chart_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "chart_name", value)

    @property
    @pulumi.getter(name="configMapRef")
    def config_map_ref(self) -> Optional[pulumi.Input['HelmReleaseRepoConfigMapRefArgs']]:
        """
        Configuration parameters to access the helm-repo defined in the CatalogSource
        """
        return pulumi.get(self, "config_map_ref")

    @config_map_ref.setter
    def config_map_ref(self, value: Optional[pulumi.Input['HelmReleaseRepoConfigMapRefArgs']]):
        pulumi.set(self, "config_map_ref", value)

    @property
    @pulumi.getter(name="insecureSkipVerify")
    def insecure_skip_verify(self) -> Optional[pulumi.Input[bool]]:
        """
        Used to skip repo server's TLS certificate verification
        """
        return pulumi.get(self, "insecure_skip_verify")

    @insecure_skip_verify.setter
    def insecure_skip_verify(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "insecure_skip_verify", value)

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional[pulumi.Input['HelmReleaseRepoSecretRefArgs']]:
        """
        Secret to use to access the helm-repo defined in the CatalogSource.
        """
        return pulumi.get(self, "secret_ref")

    @secret_ref.setter
    def secret_ref(self, value: Optional[pulumi.Input['HelmReleaseRepoSecretRefArgs']]):
        pulumi.set(self, "secret_ref", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input['HelmReleaseRepoSourceArgs']]:
        """
        INSERT ADDITIONAL SPEC FIELDS - desired state of cluster Important: Run "operator-sdk generate k8s" to regenerate code after modifying this file Add custom validation using kubebuilder tags: https://book-v1.book.kubebuilder.io/beyond_basics/generating_crd.html Source holds the url toward the helm-chart
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input['HelmReleaseRepoSourceArgs']]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version is the chart version
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class HelmReleaseRepoConfigMapRefArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 field_path: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 resource_version: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        Configuration parameters to access the helm-repo defined in the CatalogSource
        :param pulumi.Input[str] api_version: API version of the referent.
        :param pulumi.Input[str] field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param pulumi.Input[str] kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param pulumi.Input[str] namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param pulumi.Input[str] resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
        :param pulumi.Input[str] uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[pulumi.Input[str]]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_path", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @resource_version.setter
    def resource_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_version", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class HelmReleaseRepoSecretRefArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 field_path: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 resource_version: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        Secret to use to access the helm-repo defined in the CatalogSource.
        :param pulumi.Input[str] api_version: API version of the referent.
        :param pulumi.Input[str] field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param pulumi.Input[str] kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param pulumi.Input[str] namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param pulumi.Input[str] resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
        :param pulumi.Input[str] uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[pulumi.Input[str]]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_path", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @resource_version.setter
    def resource_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_version", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class HelmReleaseRepoSourceArgs:
    def __init__(__self__, *,
                 github: Optional[pulumi.Input['HelmReleaseRepoSourceGithubArgs']] = None,
                 helm_repo: Optional[pulumi.Input['HelmReleaseRepoSourceHelmRepoArgs']] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        INSERT ADDITIONAL SPEC FIELDS - desired state of cluster Important: Run "operator-sdk generate k8s" to regenerate code after modifying this file Add custom validation using kubebuilder tags: https://book-v1.book.kubebuilder.io/beyond_basics/generating_crd.html Source holds the url toward the helm-chart
        :param pulumi.Input['HelmReleaseRepoSourceGithubArgs'] github: GitHub provides the parameters to access the helm-chart located in a github repo
        :param pulumi.Input['HelmReleaseRepoSourceHelmRepoArgs'] helm_repo: HelmRepo provides the urls to retrieve the helm-chart
        :param pulumi.Input[str] type: SourceTypeEnum types of sources
        """
        if github is not None:
            pulumi.set(__self__, "github", github)
        if helm_repo is not None:
            pulumi.set(__self__, "helm_repo", helm_repo)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def github(self) -> Optional[pulumi.Input['HelmReleaseRepoSourceGithubArgs']]:
        """
        GitHub provides the parameters to access the helm-chart located in a github repo
        """
        return pulumi.get(self, "github")

    @github.setter
    def github(self, value: Optional[pulumi.Input['HelmReleaseRepoSourceGithubArgs']]):
        pulumi.set(self, "github", value)

    @property
    @pulumi.getter(name="helmRepo")
    def helm_repo(self) -> Optional[pulumi.Input['HelmReleaseRepoSourceHelmRepoArgs']]:
        """
        HelmRepo provides the urls to retrieve the helm-chart
        """
        return pulumi.get(self, "helm_repo")

    @helm_repo.setter
    def helm_repo(self, value: Optional[pulumi.Input['HelmReleaseRepoSourceHelmRepoArgs']]):
        pulumi.set(self, "helm_repo", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        SourceTypeEnum types of sources
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class HelmReleaseRepoSourceGithubArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[str]] = None,
                 chart_path: Optional[pulumi.Input[str]] = None,
                 urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        GitHub provides the parameters to access the helm-chart located in a github repo
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if chart_path is not None:
            pulumi.set(__self__, "chart_path", chart_path)
        if urls is not None:
            pulumi.set(__self__, "urls", urls)

    @property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "branch", value)

    @property
    @pulumi.getter(name="chartPath")
    def chart_path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "chart_path")

    @chart_path.setter
    def chart_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "chart_path", value)

    @property
    @pulumi.getter
    def urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "urls")

    @urls.setter
    def urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "urls", value)


@pulumi.input_type
class HelmReleaseRepoSourceHelmRepoArgs:
    def __init__(__self__, *,
                 urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        HelmRepo provides the urls to retrieve the helm-chart
        """
        if urls is not None:
            pulumi.set(__self__, "urls", urls)

    @property
    @pulumi.getter
    def urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "urls")

    @urls.setter
    def urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "urls", value)


@pulumi.input_type
class HelmReleaseStatusArgs:
    def __init__(__self__, *,
                 conditions: pulumi.Input[Sequence[pulumi.Input['HelmReleaseStatusConditionsArgs']]],
                 deployed_release: Optional[pulumi.Input['HelmReleaseStatusDeployedReleaseArgs']] = None):
        pulumi.set(__self__, "conditions", conditions)
        if deployed_release is not None:
            pulumi.set(__self__, "deployed_release", deployed_release)

    @property
    @pulumi.getter
    def conditions(self) -> pulumi.Input[Sequence[pulumi.Input['HelmReleaseStatusConditionsArgs']]]:
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: pulumi.Input[Sequence[pulumi.Input['HelmReleaseStatusConditionsArgs']]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="deployedRelease")
    def deployed_release(self) -> Optional[pulumi.Input['HelmReleaseStatusDeployedReleaseArgs']]:
        return pulumi.get(self, "deployed_release")

    @deployed_release.setter
    def deployed_release(self, value: Optional[pulumi.Input['HelmReleaseStatusDeployedReleaseArgs']]):
        pulumi.set(self, "deployed_release", value)


@pulumi.input_type
class HelmReleaseStatusConditionsArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[str],
                 type: pulumi.Input[str],
                 last_transition_time: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)


@pulumi.input_type
class HelmReleaseStatusDeployedReleaseArgs:
    def __init__(__self__, *,
                 manifest: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        if manifest is not None:
            pulumi.set(__self__, "manifest", manifest)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def manifest(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "manifest")

    @manifest.setter
    def manifest(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "manifest", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class PlacementRuleSpecArgs:
    def __init__(__self__, *,
                 cluster_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['PlacementRuleSpecClusterConditionsArgs']]]] = None,
                 cluster_replicas: Optional[pulumi.Input[int]] = None,
                 cluster_selector: Optional[pulumi.Input['PlacementRuleSpecClusterSelectorArgs']] = None,
                 clusters: Optional[pulumi.Input[Sequence[pulumi.Input['PlacementRuleSpecClustersArgs']]]] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input['PlacementRuleSpecPoliciesArgs']]]] = None,
                 resource_hint: Optional[pulumi.Input['PlacementRuleSpecResourceHintArgs']] = None,
                 scheduler_name: Optional[pulumi.Input[str]] = None):
        """
        PlacementRuleSpec defines the desired state of PlacementRule
        :param pulumi.Input[int] cluster_replicas: number of replicas Application wants to
        :param pulumi.Input['PlacementRuleSpecClusterSelectorArgs'] cluster_selector: A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
        :param pulumi.Input[Sequence[pulumi.Input['PlacementRuleSpecPoliciesArgs']]] policies: Set Policy Filters
        :param pulumi.Input['PlacementRuleSpecResourceHintArgs'] resource_hint: Select Resource
        :param pulumi.Input[str] scheduler_name: INSERT ADDITIONAL SPEC FIELDS - desired state of cluster Important: Run "make" to regenerate code after modifying this file schedulerName, default to use mcm controller
        """
        if cluster_conditions is not None:
            pulumi.set(__self__, "cluster_conditions", cluster_conditions)
        if cluster_replicas is not None:
            pulumi.set(__self__, "cluster_replicas", cluster_replicas)
        if cluster_selector is not None:
            pulumi.set(__self__, "cluster_selector", cluster_selector)
        if clusters is not None:
            pulumi.set(__self__, "clusters", clusters)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if resource_hint is not None:
            pulumi.set(__self__, "resource_hint", resource_hint)
        if scheduler_name is not None:
            pulumi.set(__self__, "scheduler_name", scheduler_name)

    @property
    @pulumi.getter(name="clusterConditions")
    def cluster_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlacementRuleSpecClusterConditionsArgs']]]]:
        return pulumi.get(self, "cluster_conditions")

    @cluster_conditions.setter
    def cluster_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlacementRuleSpecClusterConditionsArgs']]]]):
        pulumi.set(self, "cluster_conditions", value)

    @property
    @pulumi.getter(name="clusterReplicas")
    def cluster_replicas(self) -> Optional[pulumi.Input[int]]:
        """
        number of replicas Application wants to
        """
        return pulumi.get(self, "cluster_replicas")

    @cluster_replicas.setter
    def cluster_replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cluster_replicas", value)

    @property
    @pulumi.getter(name="clusterSelector")
    def cluster_selector(self) -> Optional[pulumi.Input['PlacementRuleSpecClusterSelectorArgs']]:
        """
        A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
        """
        return pulumi.get(self, "cluster_selector")

    @cluster_selector.setter
    def cluster_selector(self, value: Optional[pulumi.Input['PlacementRuleSpecClusterSelectorArgs']]):
        pulumi.set(self, "cluster_selector", value)

    @property
    @pulumi.getter
    def clusters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlacementRuleSpecClustersArgs']]]]:
        return pulumi.get(self, "clusters")

    @clusters.setter
    def clusters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlacementRuleSpecClustersArgs']]]]):
        pulumi.set(self, "clusters", value)

    @property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlacementRuleSpecPoliciesArgs']]]]:
        """
        Set Policy Filters
        """
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlacementRuleSpecPoliciesArgs']]]]):
        pulumi.set(self, "policies", value)

    @property
    @pulumi.getter(name="resourceHint")
    def resource_hint(self) -> Optional[pulumi.Input['PlacementRuleSpecResourceHintArgs']]:
        """
        Select Resource
        """
        return pulumi.get(self, "resource_hint")

    @resource_hint.setter
    def resource_hint(self, value: Optional[pulumi.Input['PlacementRuleSpecResourceHintArgs']]):
        pulumi.set(self, "resource_hint", value)

    @property
    @pulumi.getter(name="schedulerName")
    def scheduler_name(self) -> Optional[pulumi.Input[str]]:
        """
        INSERT ADDITIONAL SPEC FIELDS - desired state of cluster Important: Run "make" to regenerate code after modifying this file schedulerName, default to use mcm controller
        """
        return pulumi.get(self, "scheduler_name")

    @scheduler_name.setter
    def scheduler_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scheduler_name", value)


@pulumi.input_type
class PlacementRuleSpecClusterConditionsArgs:
    def __init__(__self__, *,
                 status: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        ClusterConditionFilter defines filter to filter cluster condition
        """
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class PlacementRuleSpecClusterSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['PlacementRuleSpecClusterSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
        :param pulumi.Input[Sequence[pulumi.Input['PlacementRuleSpecClusterSelectorMatchExpressionsArgs']]] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlacementRuleSpecClusterSelectorMatchExpressionsArgs']]]]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlacementRuleSpecClusterSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class PlacementRuleSpecClusterSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param pulumi.Input[str] key: key is the label key that the selector applies to.
        :param pulumi.Input[str] operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class PlacementRuleSpecClustersArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        GenericClusterReference - in alignment with kubefed
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class PlacementRuleSpecPoliciesArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 field_path: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 resource_version: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        ObjectReference contains enough information to let you inspect or modify the referred object. --- New uses of this type are discouraged because of difficulty describing its usage when embedded in APIs.  1. Ignored fields.  It includes many fields which are not generally honored.  For instance, ResourceVersion and FieldPath are both very rarely valid in actual usage.  2. Invalid usage help.  It is impossible to add specific help for individual usage.  In most embedded usages, there are particular     restrictions like, "must refer only to types A and B" or "UID not honored" or "name must be restricted".     Those cannot be well described when embedded.  3. Inconsistent validation.  Because the usages are different, the validation rules are different by usage, which makes it hard for users to predict what will happen.  4. The fields are both imprecise and overly precise.  Kind is not a precise mapping to a URL. This can produce ambiguity     during interpretation and require a REST mapping.  In most cases, the dependency is on the group,resource tuple     and the version of the actual struct is irrelevant.  5. We cannot easily change it.  Because this type is embedded in many locations, updates to this type     will affect numerous schemas.  Don't make new APIs embed an underspecified API type they do not control. Instead of using this type, create a locally provided and used type that is well-focused on your reference. For example, ServiceReferences for admission registration: https://github.com/kubernetes/api/blob/release-1.17/admissionregistration/v1/types.go#L533 .
        :param pulumi.Input[str] api_version: API version of the referent.
        :param pulumi.Input[str] field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param pulumi.Input[str] kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param pulumi.Input[str] namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param pulumi.Input[str] resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param pulumi.Input[str] uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[pulumi.Input[str]]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_path", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @resource_version.setter
    def resource_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_version", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class PlacementRuleSpecResourceHintArgs:
    def __init__(__self__, *,
                 order: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        Select Resource
        :param pulumi.Input[str] order: SelectionOrder is the type for Nodes
        :param pulumi.Input[str] type: ResourceType defines types can be sorted
        """
        if order is not None:
            pulumi.set(__self__, "order", order)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[str]]:
        """
        SelectionOrder is the type for Nodes
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        ResourceType defines types can be sorted
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class PlacementRuleStatusArgs:
    def __init__(__self__, *,
                 decisions: Optional[pulumi.Input[Sequence[pulumi.Input['PlacementRuleStatusDecisionsArgs']]]] = None):
        """
        PlacementRuleStatus defines the observed state of PlacementRule
        :param pulumi.Input[Sequence[pulumi.Input['PlacementRuleStatusDecisionsArgs']]] decisions: INSERT ADDITIONAL STATUS FIELD - define observed state of cluster Important: Run "make" to regenerate code after modifying this file
        """
        if decisions is not None:
            pulumi.set(__self__, "decisions", decisions)

    @property
    @pulumi.getter
    def decisions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlacementRuleStatusDecisionsArgs']]]]:
        """
        INSERT ADDITIONAL STATUS FIELD - define observed state of cluster Important: Run "make" to regenerate code after modifying this file
        """
        return pulumi.get(self, "decisions")

    @decisions.setter
    def decisions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlacementRuleStatusDecisionsArgs']]]]):
        pulumi.set(self, "decisions", value)


@pulumi.input_type
class PlacementRuleStatusDecisionsArgs:
    def __init__(__self__, *,
                 cluster_name: Optional[pulumi.Input[str]] = None,
                 cluster_namespace: Optional[pulumi.Input[str]] = None):
        """
        PlacementDecision defines the decision made by controller
        """
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if cluster_namespace is not None:
            pulumi.set(__self__, "cluster_namespace", cluster_namespace)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="clusterNamespace")
    def cluster_namespace(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cluster_namespace")

    @cluster_namespace.setter
    def cluster_namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_namespace", value)


@pulumi.input_type
class SubscriptionSpecArgs:
    def __init__(__self__, *,
                 channel: pulumi.Input[str],
                 hooksecretref: Optional[pulumi.Input['SubscriptionSpecHooksecretrefArgs']] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 overrides: Optional[pulumi.Input[Sequence[pulumi.Input['SubscriptionSpecOverridesArgs']]]] = None,
                 package_filter: Optional[pulumi.Input['SubscriptionSpecPackageFilterArgs']] = None,
                 package_overrides: Optional[pulumi.Input[Sequence[pulumi.Input['SubscriptionSpecPackageOverridesArgs']]]] = None,
                 placement: Optional[pulumi.Input['SubscriptionSpecPlacementArgs']] = None,
                 timewindow: Optional[pulumi.Input['SubscriptionSpecTimewindowArgs']] = None):
        """
        SubscriptionSpec defines the desired state of Subscription
        :param pulumi.Input['SubscriptionSpecHooksecretrefArgs'] hooksecretref: ObjectReference contains enough information to let you inspect or modify the referred object. --- New uses of this type are discouraged because of difficulty describing its usage when embedded in APIs.  1. Ignored fields.  It includes many fields which are not generally honored.  For instance, ResourceVersion and FieldPath are both very rarely valid in actual usage.  2. Invalid usage help.  It is impossible to add specific help for individual usage.  In most embedded usages, there are particular     restrictions like, "must refer only to types A and B" or "UID not honored" or "name must be restricted".     Those cannot be well described when embedded.  3. Inconsistent validation.  Because the usages are different, the validation rules are different by usage, which makes it hard for users to predict what will happen.  4. The fields are both imprecise and overly precise.  Kind is not a precise mapping to a URL. This can produce ambiguity     during interpretation and require a REST mapping.  In most cases, the dependency is on the group,resource tuple     and the version of the actual struct is irrelevant.  5. We cannot easily change it.  Because this type is embedded in many locations, updates to this type     will affect numerous schemas.  Don't make new APIs embed an underspecified API type they do not control. Instead of using this type, create a locally provided and used type that is well-focused on your reference. For example, ServiceReferences for admission registration: https://github.com/kubernetes/api/blob/release-1.17/admissionregistration/v1/types.go#L533 .
        :param pulumi.Input[str] name: To specify 1 package in channel
        :param pulumi.Input[Sequence[pulumi.Input['SubscriptionSpecOverridesArgs']]] overrides: for hub use only to specify the overrides when apply to clusters
        :param pulumi.Input['SubscriptionSpecPackageFilterArgs'] package_filter: To specify more than 1 package in channel
        :param pulumi.Input[Sequence[pulumi.Input['SubscriptionSpecPackageOverridesArgs']]] package_overrides: To provide flexibility to override package in channel with local input
        :param pulumi.Input['SubscriptionSpecPlacementArgs'] placement: For hub use only, to specify which clusters to go to
        :param pulumi.Input['SubscriptionSpecTimewindowArgs'] timewindow: help user control when the subscription will take affect
        """
        pulumi.set(__self__, "channel", channel)
        if hooksecretref is not None:
            pulumi.set(__self__, "hooksecretref", hooksecretref)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)
        if package_filter is not None:
            pulumi.set(__self__, "package_filter", package_filter)
        if package_overrides is not None:
            pulumi.set(__self__, "package_overrides", package_overrides)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if timewindow is not None:
            pulumi.set(__self__, "timewindow", timewindow)

    @property
    @pulumi.getter
    def channel(self) -> pulumi.Input[str]:
        return pulumi.get(self, "channel")

    @channel.setter
    def channel(self, value: pulumi.Input[str]):
        pulumi.set(self, "channel", value)

    @property
    @pulumi.getter
    def hooksecretref(self) -> Optional[pulumi.Input['SubscriptionSpecHooksecretrefArgs']]:
        """
        ObjectReference contains enough information to let you inspect or modify the referred object. --- New uses of this type are discouraged because of difficulty describing its usage when embedded in APIs.  1. Ignored fields.  It includes many fields which are not generally honored.  For instance, ResourceVersion and FieldPath are both very rarely valid in actual usage.  2. Invalid usage help.  It is impossible to add specific help for individual usage.  In most embedded usages, there are particular     restrictions like, "must refer only to types A and B" or "UID not honored" or "name must be restricted".     Those cannot be well described when embedded.  3. Inconsistent validation.  Because the usages are different, the validation rules are different by usage, which makes it hard for users to predict what will happen.  4. The fields are both imprecise and overly precise.  Kind is not a precise mapping to a URL. This can produce ambiguity     during interpretation and require a REST mapping.  In most cases, the dependency is on the group,resource tuple     and the version of the actual struct is irrelevant.  5. We cannot easily change it.  Because this type is embedded in many locations, updates to this type     will affect numerous schemas.  Don't make new APIs embed an underspecified API type they do not control. Instead of using this type, create a locally provided and used type that is well-focused on your reference. For example, ServiceReferences for admission registration: https://github.com/kubernetes/api/blob/release-1.17/admissionregistration/v1/types.go#L533 .
        """
        return pulumi.get(self, "hooksecretref")

    @hooksecretref.setter
    def hooksecretref(self, value: Optional[pulumi.Input['SubscriptionSpecHooksecretrefArgs']]):
        pulumi.set(self, "hooksecretref", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        To specify 1 package in channel
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubscriptionSpecOverridesArgs']]]]:
        """
        for hub use only to specify the overrides when apply to clusters
        """
        return pulumi.get(self, "overrides")

    @overrides.setter
    def overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubscriptionSpecOverridesArgs']]]]):
        pulumi.set(self, "overrides", value)

    @property
    @pulumi.getter(name="packageFilter")
    def package_filter(self) -> Optional[pulumi.Input['SubscriptionSpecPackageFilterArgs']]:
        """
        To specify more than 1 package in channel
        """
        return pulumi.get(self, "package_filter")

    @package_filter.setter
    def package_filter(self, value: Optional[pulumi.Input['SubscriptionSpecPackageFilterArgs']]):
        pulumi.set(self, "package_filter", value)

    @property
    @pulumi.getter(name="packageOverrides")
    def package_overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubscriptionSpecPackageOverridesArgs']]]]:
        """
        To provide flexibility to override package in channel with local input
        """
        return pulumi.get(self, "package_overrides")

    @package_overrides.setter
    def package_overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubscriptionSpecPackageOverridesArgs']]]]):
        pulumi.set(self, "package_overrides", value)

    @property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input['SubscriptionSpecPlacementArgs']]:
        """
        For hub use only, to specify which clusters to go to
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input['SubscriptionSpecPlacementArgs']]):
        pulumi.set(self, "placement", value)

    @property
    @pulumi.getter
    def timewindow(self) -> Optional[pulumi.Input['SubscriptionSpecTimewindowArgs']]:
        """
        help user control when the subscription will take affect
        """
        return pulumi.get(self, "timewindow")

    @timewindow.setter
    def timewindow(self, value: Optional[pulumi.Input['SubscriptionSpecTimewindowArgs']]):
        pulumi.set(self, "timewindow", value)


@pulumi.input_type
class SubscriptionSpecHooksecretrefArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 field_path: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 resource_version: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        ObjectReference contains enough information to let you inspect or modify the referred object. --- New uses of this type are discouraged because of difficulty describing its usage when embedded in APIs.  1. Ignored fields.  It includes many fields which are not generally honored.  For instance, ResourceVersion and FieldPath are both very rarely valid in actual usage.  2. Invalid usage help.  It is impossible to add specific help for individual usage.  In most embedded usages, there are particular     restrictions like, "must refer only to types A and B" or "UID not honored" or "name must be restricted".     Those cannot be well described when embedded.  3. Inconsistent validation.  Because the usages are different, the validation rules are different by usage, which makes it hard for users to predict what will happen.  4. The fields are both imprecise and overly precise.  Kind is not a precise mapping to a URL. This can produce ambiguity     during interpretation and require a REST mapping.  In most cases, the dependency is on the group,resource tuple     and the version of the actual struct is irrelevant.  5. We cannot easily change it.  Because this type is embedded in many locations, updates to this type     will affect numerous schemas.  Don't make new APIs embed an underspecified API type they do not control. Instead of using this type, create a locally provided and used type that is well-focused on your reference. For example, ServiceReferences for admission registration: https://github.com/kubernetes/api/blob/release-1.17/admissionregistration/v1/types.go#L533 .
        :param pulumi.Input[str] api_version: API version of the referent.
        :param pulumi.Input[str] field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param pulumi.Input[str] kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param pulumi.Input[str] namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param pulumi.Input[str] resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param pulumi.Input[str] uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[pulumi.Input[str]]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_path", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @resource_version.setter
    def resource_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_version", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class SubscriptionSpecOverridesArgs:
    def __init__(__self__, *,
                 cluster_name: pulumi.Input[str],
                 cluster_overrides: pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]):
        """
        Overrides field in deployable
        """
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "cluster_overrides", cluster_overrides)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="clusterOverrides")
    def cluster_overrides(self) -> pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]:
        return pulumi.get(self, "cluster_overrides")

    @cluster_overrides.setter
    def cluster_overrides(self, value: pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]):
        pulumi.set(self, "cluster_overrides", value)


@pulumi.input_type
class SubscriptionSpecPackageFilterArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 filter_ref: Optional[pulumi.Input['SubscriptionSpecPackageFilterFilterRefArgs']] = None,
                 label_selector: Optional[pulumi.Input['SubscriptionSpecPackageFilterLabelSelectorArgs']] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        To specify more than 1 package in channel
        :param pulumi.Input['SubscriptionSpecPackageFilterFilterRefArgs'] filter_ref: LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
        :param pulumi.Input['SubscriptionSpecPackageFilterLabelSelectorArgs'] label_selector: A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if filter_ref is not None:
            pulumi.set(__self__, "filter_ref", filter_ref)
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="filterRef")
    def filter_ref(self) -> Optional[pulumi.Input['SubscriptionSpecPackageFilterFilterRefArgs']]:
        """
        LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
        """
        return pulumi.get(self, "filter_ref")

    @filter_ref.setter
    def filter_ref(self, value: Optional[pulumi.Input['SubscriptionSpecPackageFilterFilterRefArgs']]):
        pulumi.set(self, "filter_ref", value)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['SubscriptionSpecPackageFilterLabelSelectorArgs']]:
        """
        A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
        """
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['SubscriptionSpecPackageFilterLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class SubscriptionSpecPackageFilterFilterRefArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class SubscriptionSpecPackageFilterLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
        :param pulumi.Input[Sequence[pulumi.Input['SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArgs']]] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArgs']]]]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param pulumi.Input[str] key: key is the label key that the selector applies to.
        :param pulumi.Input[str] operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class SubscriptionSpecPackageOverridesArgs:
    def __init__(__self__, *,
                 package_name: pulumi.Input[str],
                 package_alias: Optional[pulumi.Input[str]] = None,
                 package_overrides: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]] = None):
        """
        Overrides field in deployable
        """
        pulumi.set(__self__, "package_name", package_name)
        if package_alias is not None:
            pulumi.set(__self__, "package_alias", package_alias)
        if package_overrides is not None:
            pulumi.set(__self__, "package_overrides", package_overrides)

    @property
    @pulumi.getter(name="packageName")
    def package_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "package_name")

    @package_name.setter
    def package_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "package_name", value)

    @property
    @pulumi.getter(name="packageAlias")
    def package_alias(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "package_alias")

    @package_alias.setter
    def package_alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "package_alias", value)

    @property
    @pulumi.getter(name="packageOverrides")
    def package_overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]]:
        return pulumi.get(self, "package_overrides")

    @package_overrides.setter
    def package_overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]]):
        pulumi.set(self, "package_overrides", value)


@pulumi.input_type
class SubscriptionSpecPlacementArgs:
    def __init__(__self__, *,
                 cluster_selector: Optional[pulumi.Input['SubscriptionSpecPlacementClusterSelectorArgs']] = None,
                 clusters: Optional[pulumi.Input[Sequence[pulumi.Input['SubscriptionSpecPlacementClustersArgs']]]] = None,
                 local: Optional[pulumi.Input[bool]] = None,
                 placement_ref: Optional[pulumi.Input['SubscriptionSpecPlacementPlacementRefArgs']] = None):
        """
        For hub use only, to specify which clusters to go to
        :param pulumi.Input['SubscriptionSpecPlacementClusterSelectorArgs'] cluster_selector: A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
        :param pulumi.Input['SubscriptionSpecPlacementPlacementRefArgs'] placement_ref: ObjectReference contains enough information to let you inspect or modify the referred object.
        """
        if cluster_selector is not None:
            pulumi.set(__self__, "cluster_selector", cluster_selector)
        if clusters is not None:
            pulumi.set(__self__, "clusters", clusters)
        if local is not None:
            pulumi.set(__self__, "local", local)
        if placement_ref is not None:
            pulumi.set(__self__, "placement_ref", placement_ref)

    @property
    @pulumi.getter(name="clusterSelector")
    def cluster_selector(self) -> Optional[pulumi.Input['SubscriptionSpecPlacementClusterSelectorArgs']]:
        """
        A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
        """
        return pulumi.get(self, "cluster_selector")

    @cluster_selector.setter
    def cluster_selector(self, value: Optional[pulumi.Input['SubscriptionSpecPlacementClusterSelectorArgs']]):
        pulumi.set(self, "cluster_selector", value)

    @property
    @pulumi.getter
    def clusters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubscriptionSpecPlacementClustersArgs']]]]:
        return pulumi.get(self, "clusters")

    @clusters.setter
    def clusters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubscriptionSpecPlacementClustersArgs']]]]):
        pulumi.set(self, "clusters", value)

    @property
    @pulumi.getter
    def local(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "local")

    @local.setter
    def local(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "local", value)

    @property
    @pulumi.getter(name="placementRef")
    def placement_ref(self) -> Optional[pulumi.Input['SubscriptionSpecPlacementPlacementRefArgs']]:
        """
        ObjectReference contains enough information to let you inspect or modify the referred object.
        """
        return pulumi.get(self, "placement_ref")

    @placement_ref.setter
    def placement_ref(self, value: Optional[pulumi.Input['SubscriptionSpecPlacementPlacementRefArgs']]):
        pulumi.set(self, "placement_ref", value)


@pulumi.input_type
class SubscriptionSpecPlacementClusterSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['SubscriptionSpecPlacementClusterSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
        :param pulumi.Input[Sequence[pulumi.Input['SubscriptionSpecPlacementClusterSelectorMatchExpressionsArgs']]] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubscriptionSpecPlacementClusterSelectorMatchExpressionsArgs']]]]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubscriptionSpecPlacementClusterSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class SubscriptionSpecPlacementClusterSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param pulumi.Input[str] key: key is the label key that the selector applies to.
        :param pulumi.Input[str] operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class SubscriptionSpecPlacementClustersArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        GenericClusterReference - in alignment with kubefed
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class SubscriptionSpecPlacementPlacementRefArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 field_path: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 resource_version: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        ObjectReference contains enough information to let you inspect or modify the referred object.
        :param pulumi.Input[str] api_version: API version of the referent.
        :param pulumi.Input[str] field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param pulumi.Input[str] kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param pulumi.Input[str] namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param pulumi.Input[str] resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
        :param pulumi.Input[str] uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[pulumi.Input[str]]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_path", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @resource_version.setter
    def resource_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_version", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class SubscriptionSpecTimewindowArgs:
    def __init__(__self__, *,
                 daysofweek: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 hours: Optional[pulumi.Input[Sequence[pulumi.Input['SubscriptionSpecTimewindowHoursArgs']]]] = None,
                 location: Optional[pulumi.Input[str]] = None,
                 windowtype: Optional[pulumi.Input[str]] = None):
        """
        help user control when the subscription will take affect
        :param pulumi.Input[Sequence[pulumi.Input[str]]] daysofweek: weekdays defined the day of the week for this time window https://golang.org/pkg/time/#Weekday
        :param pulumi.Input[str] location: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
        :param pulumi.Input[str] windowtype: active time window or not, if timewindow is active, then deploy will only applies during these windows Note, if you want to generation crd with operator-sdk v0.10.0, then the following line should be: <+kubebuilder:validation:Enum=active,blocked,Active,Blocked>
        """
        if daysofweek is not None:
            pulumi.set(__self__, "daysofweek", daysofweek)
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if windowtype is not None:
            pulumi.set(__self__, "windowtype", windowtype)

    @property
    @pulumi.getter
    def daysofweek(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        weekdays defined the day of the week for this time window https://golang.org/pkg/time/#Weekday
        """
        return pulumi.get(self, "daysofweek")

    @daysofweek.setter
    def daysofweek(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "daysofweek", value)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubscriptionSpecTimewindowHoursArgs']]]]:
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubscriptionSpecTimewindowHoursArgs']]]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        """
        https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def windowtype(self) -> Optional[pulumi.Input[str]]:
        """
        active time window or not, if timewindow is active, then deploy will only applies during these windows Note, if you want to generation crd with operator-sdk v0.10.0, then the following line should be: <+kubebuilder:validation:Enum=active,blocked,Active,Blocked>
        """
        return pulumi.get(self, "windowtype")

    @windowtype.setter
    def windowtype(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "windowtype", value)


@pulumi.input_type
class SubscriptionSpecTimewindowHoursArgs:
    def __init__(__self__, *,
                 end: Optional[pulumi.Input[str]] = None,
                 start: Optional[pulumi.Input[str]] = None):
        """
        HourRange time format for each time will be Kitchen format, defined at https://golang.org/pkg/time/#pkg-constants
        """
        if end is not None:
            pulumi.set(__self__, "end", end)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def start(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start", value)


@pulumi.input_type
class SubscriptionStatusArgs:
    def __init__(__self__, *,
                 ansiblejobs: Optional[pulumi.Input['SubscriptionStatusAnsiblejobsArgs']] = None,
                 last_update_time: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 phase: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None,
                 statuses: Optional[pulumi.Input[Mapping[str, pulumi.Input['SubscriptionStatusStatusesArgs']]]] = None):
        """
        SubscriptionStatus defines the observed state of Subscription Examples - status of a subscription on hub Status: 	phase: Propagated 	statuses: 	  washdc: 		packages: 		  nginx: 			phase: Subscribed 		  mongodb: 			phase: Failed 			Reason: "not authorized" 			Message: "user xxx does not have permission to start pod" 			resourceStatus: {}    toronto: 		packages: 		  nginx: 			phase: Subscribed 		  mongodb: 			phase: Subscribed Status of a subscription on managed cluster will only have 1 cluster in the map.
        :param pulumi.Input[str] phase: INSERT ADDITIONAL STATUS FIELD - define observed state of cluster Important: Run "make" to regenerate code after modifying this file
        :param pulumi.Input[Mapping[str, pulumi.Input['SubscriptionStatusStatusesArgs']]] statuses: For endpoint, it is the status of subscription, key is packagename, For hub, it aggregates all status, key is cluster name
        """
        if ansiblejobs is not None:
            pulumi.set(__self__, "ansiblejobs", ansiblejobs)
        if last_update_time is not None:
            pulumi.set(__self__, "last_update_time", last_update_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if statuses is not None:
            pulumi.set(__self__, "statuses", statuses)

    @property
    @pulumi.getter
    def ansiblejobs(self) -> Optional[pulumi.Input['SubscriptionStatusAnsiblejobsArgs']]:
        return pulumi.get(self, "ansiblejobs")

    @ansiblejobs.setter
    def ansiblejobs(self, value: Optional[pulumi.Input['SubscriptionStatusAnsiblejobsArgs']]):
        pulumi.set(self, "ansiblejobs", value)

    @property
    @pulumi.getter(name="lastUpdateTime")
    def last_update_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "last_update_time")

    @last_update_time.setter
    def last_update_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_update_time", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def phase(self) -> Optional[pulumi.Input[str]]:
        """
        INSERT ADDITIONAL STATUS FIELD - define observed state of cluster Important: Run "make" to regenerate code after modifying this file
        """
        return pulumi.get(self, "phase")

    @phase.setter
    def phase(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "phase", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)

    @property
    @pulumi.getter
    def statuses(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['SubscriptionStatusStatusesArgs']]]]:
        """
        For endpoint, it is the status of subscription, key is packagename, For hub, it aggregates all status, key is cluster name
        """
        return pulumi.get(self, "statuses")

    @statuses.setter
    def statuses(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['SubscriptionStatusStatusesArgs']]]]):
        pulumi.set(self, "statuses", value)


@pulumi.input_type
class SubscriptionStatusAnsiblejobsArgs:
    def __init__(__self__, *,
                 lastposthookjob: Optional[pulumi.Input[str]] = None,
                 lastprehookjob: Optional[pulumi.Input[str]] = None,
                 posthookjobshistory: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 prehookjobshistory: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if lastposthookjob is not None:
            pulumi.set(__self__, "lastposthookjob", lastposthookjob)
        if lastprehookjob is not None:
            pulumi.set(__self__, "lastprehookjob", lastprehookjob)
        if posthookjobshistory is not None:
            pulumi.set(__self__, "posthookjobshistory", posthookjobshistory)
        if prehookjobshistory is not None:
            pulumi.set(__self__, "prehookjobshistory", prehookjobshistory)

    @property
    @pulumi.getter
    def lastposthookjob(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "lastposthookjob")

    @lastposthookjob.setter
    def lastposthookjob(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lastposthookjob", value)

    @property
    @pulumi.getter
    def lastprehookjob(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "lastprehookjob")

    @lastprehookjob.setter
    def lastprehookjob(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lastprehookjob", value)

    @property
    @pulumi.getter
    def posthookjobshistory(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "posthookjobshistory")

    @posthookjobshistory.setter
    def posthookjobshistory(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "posthookjobshistory", value)

    @property
    @pulumi.getter
    def prehookjobshistory(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "prehookjobshistory")

    @prehookjobshistory.setter
    def prehookjobshistory(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "prehookjobshistory", value)


@pulumi.input_type
class SubscriptionStatusStatusesArgs:
    def __init__(__self__, *,
                 packages: Optional[pulumi.Input[Mapping[str, pulumi.Input['SubscriptionStatusStatusesPackagesArgs']]]] = None):
        """
        SubscriptionPerClusterStatus defines status for subscription in each cluster, key is package name
        """
        if packages is not None:
            pulumi.set(__self__, "packages", packages)

    @property
    @pulumi.getter
    def packages(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['SubscriptionStatusStatusesPackagesArgs']]]]:
        return pulumi.get(self, "packages")

    @packages.setter
    def packages(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['SubscriptionStatusStatusesPackagesArgs']]]]):
        pulumi.set(self, "packages", value)


@pulumi.input_type
class SubscriptionStatusStatusesPackagesArgs:
    def __init__(__self__, *,
                 last_update_time: pulumi.Input[str],
                 message: Optional[pulumi.Input[str]] = None,
                 phase: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None,
                 resource_status: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        SubscriptionUnitStatus defines status of a unit (subscription or package)
        :param pulumi.Input[str] phase: Phase are Propagated if it is in hub or Subscribed if it is in endpoint
        """
        pulumi.set(__self__, "last_update_time", last_update_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if resource_status is not None:
            pulumi.set(__self__, "resource_status", resource_status)

    @property
    @pulumi.getter(name="lastUpdateTime")
    def last_update_time(self) -> pulumi.Input[str]:
        return pulumi.get(self, "last_update_time")

    @last_update_time.setter
    def last_update_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "last_update_time", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def phase(self) -> Optional[pulumi.Input[str]]:
        """
        Phase are Propagated if it is in hub or Subscribed if it is in endpoint
        """
        return pulumi.get(self, "phase")

    @phase.setter
    def phase(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "phase", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)

    @property
    @pulumi.getter(name="resourceStatus")
    def resource_status(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "resource_status")

    @resource_status.setter
    def resource_status(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "resource_status", value)


