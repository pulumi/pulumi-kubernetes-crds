# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from ... import _utilities, _tables
from . import outputs

__all__ = [
    'ChannelSpec',
    'ChannelSpecConfigMapRef',
    'ChannelSpecGates',
    'ChannelSpecGatesLabelSelector',
    'ChannelSpecGatesLabelSelectorMatchExpressions',
    'ChannelSpecSecretRef',
    'DeployableSpec',
    'DeployableSpecDependencies',
    'DeployableSpecOverrides',
    'DeployableSpecPlacement',
    'DeployableSpecPlacementClusterSelector',
    'DeployableSpecPlacementClusterSelectorMatchExpressions',
    'DeployableSpecPlacementClusters',
    'DeployableSpecPlacementPlacementRef',
    'DeployableStatus',
    'HelmReleaseRepo',
    'HelmReleaseRepoConfigMapRef',
    'HelmReleaseRepoSecretRef',
    'HelmReleaseRepoSource',
    'HelmReleaseRepoSourceGithub',
    'HelmReleaseRepoSourceHelmRepo',
    'HelmReleaseStatus',
    'HelmReleaseStatusConditions',
    'HelmReleaseStatusDeployedRelease',
    'PlacementRuleSpec',
    'PlacementRuleSpecClusterConditions',
    'PlacementRuleSpecClusterSelector',
    'PlacementRuleSpecClusterSelectorMatchExpressions',
    'PlacementRuleSpecClusters',
    'PlacementRuleSpecPolicies',
    'PlacementRuleSpecResourceHint',
    'PlacementRuleStatus',
    'PlacementRuleStatusDecisions',
    'SubscriptionSpec',
    'SubscriptionSpecOverrides',
    'SubscriptionSpecPackageFilter',
    'SubscriptionSpecPackageFilterFilterRef',
    'SubscriptionSpecPackageFilterLabelSelector',
    'SubscriptionSpecPackageFilterLabelSelectorMatchExpressions',
    'SubscriptionSpecPackageOverrides',
    'SubscriptionSpecPlacement',
    'SubscriptionSpecPlacementClusterSelector',
    'SubscriptionSpecPlacementClusterSelectorMatchExpressions',
    'SubscriptionSpecPlacementClusters',
    'SubscriptionSpecPlacementPlacementRef',
    'SubscriptionSpecTimewindow',
    'SubscriptionSpecTimewindowHours',
    'SubscriptionStatus',
]

@pulumi.output_type
class ChannelSpec(dict):
    """
    ChannelSpec defines the desired state of Channel
    """
    def __init__(__self__, *,
                 pathname: str,
                 type: str,
                 config_map_ref: Optional['outputs.ChannelSpecConfigMapRef'] = None,
                 gates: Optional['outputs.ChannelSpecGates'] = None,
                 secret_ref: Optional['outputs.ChannelSpecSecretRef'] = None,
                 source_namespaces: Optional[Sequence[str]] = None):
        """
        ChannelSpec defines the desired state of Channel
        :param str pathname: For a `namespace` channel, pathname is the name of the namespace; For a `helmrepo` or `github` channel, pathname is the remote URL for the channel contents; For a `objectbucket` channel, pathname is the URL and name of the bucket.
        :param str type: ChannelType defines types of channel
        :param 'ChannelSpecConfigMapRefArgs' config_map_ref: Reference to a ConfigMap which contains additional settings for accessing the channel. For example, the `insecureSkipVerify` option for accessing HTTPS endpoints can be set in the ConfigMap to indicate a insecure connection.
        :param 'ChannelSpecGatesArgs' gates: Criteria for promoting a Deployable from the sourceNamespaces to Channel.
        :param 'ChannelSpecSecretRefArgs' secret_ref: For a `github` channel or a `helmrepo` channel on github, this can be used to reference a Secret which contains the credentials for authentication, i.e. `user` and `accessToken`. For a `objectbucket` channel, this can be used to reference a Secret which contains the AWS credentials, i.e. `AccessKeyID` and `SecretAccessKey`.
        :param Sequence[str] source_namespaces: A list of namespace names from which Deployables can be promoted.
        """
        pulumi.set(__self__, "pathname", pathname)
        pulumi.set(__self__, "type", type)
        if config_map_ref is not None:
            pulumi.set(__self__, "config_map_ref", config_map_ref)
        if gates is not None:
            pulumi.set(__self__, "gates", gates)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)
        if source_namespaces is not None:
            pulumi.set(__self__, "source_namespaces", source_namespaces)

    @property
    @pulumi.getter
    def pathname(self) -> str:
        """
        For a `namespace` channel, pathname is the name of the namespace; For a `helmrepo` or `github` channel, pathname is the remote URL for the channel contents; For a `objectbucket` channel, pathname is the URL and name of the bucket.
        """
        return pulumi.get(self, "pathname")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        ChannelType defines types of channel
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="configMapRef")
    def config_map_ref(self) -> Optional['outputs.ChannelSpecConfigMapRef']:
        """
        Reference to a ConfigMap which contains additional settings for accessing the channel. For example, the `insecureSkipVerify` option for accessing HTTPS endpoints can be set in the ConfigMap to indicate a insecure connection.
        """
        return pulumi.get(self, "config_map_ref")

    @property
    @pulumi.getter
    def gates(self) -> Optional['outputs.ChannelSpecGates']:
        """
        Criteria for promoting a Deployable from the sourceNamespaces to Channel.
        """
        return pulumi.get(self, "gates")

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional['outputs.ChannelSpecSecretRef']:
        """
        For a `github` channel or a `helmrepo` channel on github, this can be used to reference a Secret which contains the credentials for authentication, i.e. `user` and `accessToken`. For a `objectbucket` channel, this can be used to reference a Secret which contains the AWS credentials, i.e. `AccessKeyID` and `SecretAccessKey`.
        """
        return pulumi.get(self, "secret_ref")

    @property
    @pulumi.getter(name="sourceNamespaces")
    def source_namespaces(self) -> Optional[Sequence[str]]:
        """
        A list of namespace names from which Deployables can be promoted.
        """
        return pulumi.get(self, "source_namespaces")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ChannelSpecConfigMapRef(dict):
    """
    Reference to a ConfigMap which contains additional settings for accessing the channel. For example, the `insecureSkipVerify` option for accessing HTTPS endpoints can be set in the ConfigMap to indicate a insecure connection.
    """
    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 resource_version: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        Reference to a ConfigMap which contains additional settings for accessing the channel. For example, the `insecureSkipVerify` option for accessing HTTPS endpoints can be set in the ConfigMap to indicate a insecure connection.
        :param str api_version: API version of the referent.
        :param str field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param str kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param str resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param str uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[str]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ChannelSpecGates(dict):
    """
    Criteria for promoting a Deployable from the sourceNamespaces to Channel.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, str]] = None,
                 label_selector: Optional['outputs.ChannelSpecGatesLabelSelector'] = None,
                 name: Optional[str] = None):
        """
        Criteria for promoting a Deployable from the sourceNamespaces to Channel.
        :param Mapping[str, str] annotations: The annotations which must present on a Deployable for it to be eligible for promotion.
        :param 'ChannelSpecGatesLabelSelectorArgs' label_selector: A label selector for selecting the Deployables.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, str]]:
        """
        The annotations which must present on a Deployable for it to be eligible for promotion.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.ChannelSpecGatesLabelSelector']:
        """
        A label selector for selecting the Deployables.
        """
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ChannelSpecGatesLabelSelector(dict):
    """
    A label selector for selecting the Deployables.
    """
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.ChannelSpecGatesLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        A label selector for selecting the Deployables.
        :param Sequence['ChannelSpecGatesLabelSelectorMatchExpressionsArgs'] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.ChannelSpecGatesLabelSelectorMatchExpressions']]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ChannelSpecGatesLabelSelectorMatchExpressions(dict):
    """
    A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
    """
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Optional[Sequence[str]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param str key: key is the label key that the selector applies to.
        :param str operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param Sequence[str] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ChannelSpecSecretRef(dict):
    """
    For a `github` channel or a `helmrepo` channel on github, this can be used to reference a Secret which contains the credentials for authentication, i.e. `user` and `accessToken`. For a `objectbucket` channel, this can be used to reference a Secret which contains the AWS credentials, i.e. `AccessKeyID` and `SecretAccessKey`.
    """
    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 resource_version: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        For a `github` channel or a `helmrepo` channel on github, this can be used to reference a Secret which contains the credentials for authentication, i.e. `user` and `accessToken`. For a `objectbucket` channel, this can be used to reference a Secret which contains the AWS credentials, i.e. `AccessKeyID` and `SecretAccessKey`.
        :param str api_version: API version of the referent.
        :param str field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param str kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param str resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param str uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[str]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DeployableSpec(dict):
    """
    DeployableSpec defines the desired state of Deployable
    """
    def __init__(__self__, *,
                 template: Mapping[str, Any],
                 channels: Optional[Sequence[str]] = None,
                 dependencies: Optional[Sequence['outputs.DeployableSpecDependencies']] = None,
                 overrides: Optional[Sequence['outputs.DeployableSpecOverrides']] = None,
                 placement: Optional['outputs.DeployableSpecPlacement'] = None):
        """
        DeployableSpec defines the desired state of Deployable
        :param 'DeployableSpecPlacementArgs' placement: Placement field to be referenced in specs, align with Fedv2, add placementref
        """
        pulumi.set(__self__, "template", template)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if dependencies is not None:
            pulumi.set(__self__, "dependencies", dependencies)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)

    @property
    @pulumi.getter
    def template(self) -> Mapping[str, Any]:
        return pulumi.get(self, "template")

    @property
    @pulumi.getter
    def channels(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "channels")

    @property
    @pulumi.getter
    def dependencies(self) -> Optional[Sequence['outputs.DeployableSpecDependencies']]:
        return pulumi.get(self, "dependencies")

    @property
    @pulumi.getter
    def overrides(self) -> Optional[Sequence['outputs.DeployableSpecOverrides']]:
        return pulumi.get(self, "overrides")

    @property
    @pulumi.getter
    def placement(self) -> Optional['outputs.DeployableSpecPlacement']:
        """
        Placement field to be referenced in specs, align with Fedv2, add placementref
        """
        return pulumi.get(self, "placement")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DeployableSpecDependencies(dict):
    """
    Dependency of Deployable Properties field is the flexiblity for different Kind
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, str]] = None,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None,
                 kind: Optional[str] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 resource_version: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        Dependency of Deployable Properties field is the flexiblity for different Kind
        :param str api_version: API version of the referent.
        :param str field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param str kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param str resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
        :param str uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[str]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DeployableSpecOverrides(dict):
    """
    Overrides field in deployable
    """
    def __init__(__self__, *,
                 cluster_name: str,
                 cluster_overrides: Sequence[Mapping[str, Any]]):
        """
        Overrides field in deployable
        """
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "cluster_overrides", cluster_overrides)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="clusterOverrides")
    def cluster_overrides(self) -> Sequence[Mapping[str, Any]]:
        return pulumi.get(self, "cluster_overrides")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DeployableSpecPlacement(dict):
    """
    Placement field to be referenced in specs, align with Fedv2, add placementref
    """
    def __init__(__self__, *,
                 cluster_selector: Optional['outputs.DeployableSpecPlacementClusterSelector'] = None,
                 clusters: Optional[Sequence['outputs.DeployableSpecPlacementClusters']] = None,
                 local: Optional[bool] = None,
                 placement_ref: Optional['outputs.DeployableSpecPlacementPlacementRef'] = None):
        """
        Placement field to be referenced in specs, align with Fedv2, add placementref
        :param 'DeployableSpecPlacementClusterSelectorArgs' cluster_selector: A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
        :param 'DeployableSpecPlacementPlacementRefArgs' placement_ref: ObjectReference contains enough information to let you inspect or modify the referred object.
        """
        if cluster_selector is not None:
            pulumi.set(__self__, "cluster_selector", cluster_selector)
        if clusters is not None:
            pulumi.set(__self__, "clusters", clusters)
        if local is not None:
            pulumi.set(__self__, "local", local)
        if placement_ref is not None:
            pulumi.set(__self__, "placement_ref", placement_ref)

    @property
    @pulumi.getter(name="clusterSelector")
    def cluster_selector(self) -> Optional['outputs.DeployableSpecPlacementClusterSelector']:
        """
        A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
        """
        return pulumi.get(self, "cluster_selector")

    @property
    @pulumi.getter
    def clusters(self) -> Optional[Sequence['outputs.DeployableSpecPlacementClusters']]:
        return pulumi.get(self, "clusters")

    @property
    @pulumi.getter
    def local(self) -> Optional[bool]:
        return pulumi.get(self, "local")

    @property
    @pulumi.getter(name="placementRef")
    def placement_ref(self) -> Optional['outputs.DeployableSpecPlacementPlacementRef']:
        """
        ObjectReference contains enough information to let you inspect or modify the referred object.
        """
        return pulumi.get(self, "placement_ref")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DeployableSpecPlacementClusterSelector(dict):
    """
    A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
    """
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.DeployableSpecPlacementClusterSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
        :param Sequence['DeployableSpecPlacementClusterSelectorMatchExpressionsArgs'] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.DeployableSpecPlacementClusterSelectorMatchExpressions']]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DeployableSpecPlacementClusterSelectorMatchExpressions(dict):
    """
    A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
    """
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Optional[Sequence[str]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param str key: key is the label key that the selector applies to.
        :param str operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param Sequence[str] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DeployableSpecPlacementClusters(dict):
    """
    GenericClusterReference - in alignment with kubefed
    """
    def __init__(__self__, *,
                 name: str):
        """
        GenericClusterReference - in alignment with kubefed
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DeployableSpecPlacementPlacementRef(dict):
    """
    ObjectReference contains enough information to let you inspect or modify the referred object.
    """
    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 resource_version: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        ObjectReference contains enough information to let you inspect or modify the referred object.
        :param str api_version: API version of the referent.
        :param str field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param str kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param str resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
        :param str uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[str]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DeployableStatus(dict):
    """
    DeployableStatus defines the observed state of Deployable
    """
    def __init__(__self__, *,
                 target_clusters: Optional[Any] = None):
        """
        DeployableStatus defines the observed state of Deployable
        """
        if target_clusters is not None:
            pulumi.set(__self__, "target_clusters", target_clusters)

    @property
    @pulumi.getter(name="targetClusters")
    def target_clusters(self) -> Optional[Any]:
        return pulumi.get(self, "target_clusters")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HelmReleaseRepo(dict):
    """
    HelmReleaseRepo defines the repository of HelmRelease
    """
    def __init__(__self__, *,
                 chart_name: Optional[str] = None,
                 config_map_ref: Optional['outputs.HelmReleaseRepoConfigMapRef'] = None,
                 secret_ref: Optional['outputs.HelmReleaseRepoSecretRef'] = None,
                 source: Optional['outputs.HelmReleaseRepoSource'] = None,
                 version: Optional[str] = None):
        """
        HelmReleaseRepo defines the repository of HelmRelease
        :param str chart_name: ChartName is the name of the chart within the repo
        :param 'HelmReleaseRepoConfigMapRefArgs' config_map_ref: Configuration parameters to access the helm-repo defined in the CatalogSource
        :param 'HelmReleaseRepoSecretRefArgs' secret_ref: Secret to use to access the helm-repo defined in the CatalogSource.
        :param 'HelmReleaseRepoSourceArgs' source: INSERT ADDITIONAL SPEC FIELDS - desired state of cluster Important: Run "operator-sdk generate k8s" to regenerate code after modifying this file Add custom validation using kubebuilder tags: https://book-v1.book.kubebuilder.io/beyond_basics/generating_crd.html Source holds the url toward the helm-chart
        :param str version: Version is the chart version
        """
        if chart_name is not None:
            pulumi.set(__self__, "chart_name", chart_name)
        if config_map_ref is not None:
            pulumi.set(__self__, "config_map_ref", config_map_ref)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="chartName")
    def chart_name(self) -> Optional[str]:
        """
        ChartName is the name of the chart within the repo
        """
        return pulumi.get(self, "chart_name")

    @property
    @pulumi.getter(name="configMapRef")
    def config_map_ref(self) -> Optional['outputs.HelmReleaseRepoConfigMapRef']:
        """
        Configuration parameters to access the helm-repo defined in the CatalogSource
        """
        return pulumi.get(self, "config_map_ref")

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional['outputs.HelmReleaseRepoSecretRef']:
        """
        Secret to use to access the helm-repo defined in the CatalogSource.
        """
        return pulumi.get(self, "secret_ref")

    @property
    @pulumi.getter
    def source(self) -> Optional['outputs.HelmReleaseRepoSource']:
        """
        INSERT ADDITIONAL SPEC FIELDS - desired state of cluster Important: Run "operator-sdk generate k8s" to regenerate code after modifying this file Add custom validation using kubebuilder tags: https://book-v1.book.kubebuilder.io/beyond_basics/generating_crd.html Source holds the url toward the helm-chart
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Version is the chart version
        """
        return pulumi.get(self, "version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HelmReleaseRepoConfigMapRef(dict):
    """
    Configuration parameters to access the helm-repo defined in the CatalogSource
    """
    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 resource_version: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        Configuration parameters to access the helm-repo defined in the CatalogSource
        :param str api_version: API version of the referent.
        :param str field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param str kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param str resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
        :param str uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[str]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HelmReleaseRepoSecretRef(dict):
    """
    Secret to use to access the helm-repo defined in the CatalogSource.
    """
    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 resource_version: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        Secret to use to access the helm-repo defined in the CatalogSource.
        :param str api_version: API version of the referent.
        :param str field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param str kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param str resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
        :param str uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[str]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HelmReleaseRepoSource(dict):
    """
    INSERT ADDITIONAL SPEC FIELDS - desired state of cluster Important: Run "operator-sdk generate k8s" to regenerate code after modifying this file Add custom validation using kubebuilder tags: https://book-v1.book.kubebuilder.io/beyond_basics/generating_crd.html Source holds the url toward the helm-chart
    """
    def __init__(__self__, *,
                 github: Optional['outputs.HelmReleaseRepoSourceGithub'] = None,
                 helm_repo: Optional['outputs.HelmReleaseRepoSourceHelmRepo'] = None,
                 type: Optional[str] = None):
        """
        INSERT ADDITIONAL SPEC FIELDS - desired state of cluster Important: Run "operator-sdk generate k8s" to regenerate code after modifying this file Add custom validation using kubebuilder tags: https://book-v1.book.kubebuilder.io/beyond_basics/generating_crd.html Source holds the url toward the helm-chart
        :param 'HelmReleaseRepoSourceGithubArgs' github: GitHub provides the parameters to access the helm-chart located in a github repo
        :param 'HelmReleaseRepoSourceHelmRepoArgs' helm_repo: HelmRepo provides the urls to retrieve the helm-chart
        :param str type: SourceTypeEnum types of sources
        """
        if github is not None:
            pulumi.set(__self__, "github", github)
        if helm_repo is not None:
            pulumi.set(__self__, "helm_repo", helm_repo)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def github(self) -> Optional['outputs.HelmReleaseRepoSourceGithub']:
        """
        GitHub provides the parameters to access the helm-chart located in a github repo
        """
        return pulumi.get(self, "github")

    @property
    @pulumi.getter(name="helmRepo")
    def helm_repo(self) -> Optional['outputs.HelmReleaseRepoSourceHelmRepo']:
        """
        HelmRepo provides the urls to retrieve the helm-chart
        """
        return pulumi.get(self, "helm_repo")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        SourceTypeEnum types of sources
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HelmReleaseRepoSourceGithub(dict):
    """
    GitHub provides the parameters to access the helm-chart located in a github repo
    """
    def __init__(__self__, *,
                 branch: Optional[str] = None,
                 chart_path: Optional[str] = None,
                 urls: Optional[Sequence[str]] = None):
        """
        GitHub provides the parameters to access the helm-chart located in a github repo
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if chart_path is not None:
            pulumi.set(__self__, "chart_path", chart_path)
        if urls is not None:
            pulumi.set(__self__, "urls", urls)

    @property
    @pulumi.getter
    def branch(self) -> Optional[str]:
        return pulumi.get(self, "branch")

    @property
    @pulumi.getter(name="chartPath")
    def chart_path(self) -> Optional[str]:
        return pulumi.get(self, "chart_path")

    @property
    @pulumi.getter
    def urls(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "urls")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HelmReleaseRepoSourceHelmRepo(dict):
    """
    HelmRepo provides the urls to retrieve the helm-chart
    """
    def __init__(__self__, *,
                 urls: Optional[Sequence[str]] = None):
        """
        HelmRepo provides the urls to retrieve the helm-chart
        """
        if urls is not None:
            pulumi.set(__self__, "urls", urls)

    @property
    @pulumi.getter
    def urls(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "urls")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HelmReleaseStatus(dict):
    def __init__(__self__, *,
                 conditions: Sequence['outputs.HelmReleaseStatusConditions'],
                 deployed_release: Optional['outputs.HelmReleaseStatusDeployedRelease'] = None):
        pulumi.set(__self__, "conditions", conditions)
        if deployed_release is not None:
            pulumi.set(__self__, "deployed_release", deployed_release)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.HelmReleaseStatusConditions']:
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="deployedRelease")
    def deployed_release(self) -> Optional['outputs.HelmReleaseStatusDeployedRelease']:
        return pulumi.get(self, "deployed_release")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HelmReleaseStatusConditions(dict):
    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None):
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        return pulumi.get(self, "reason")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HelmReleaseStatusDeployedRelease(dict):
    def __init__(__self__, *,
                 manifest: Optional[str] = None,
                 name: Optional[str] = None):
        if manifest is not None:
            pulumi.set(__self__, "manifest", manifest)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def manifest(self) -> Optional[str]:
        return pulumi.get(self, "manifest")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PlacementRuleSpec(dict):
    """
    PlacementRuleSpec defines the desired state of PlacementRule
    """
    def __init__(__self__, *,
                 cluster_conditions: Optional[Sequence['outputs.PlacementRuleSpecClusterConditions']] = None,
                 cluster_replicas: Optional[int] = None,
                 cluster_selector: Optional['outputs.PlacementRuleSpecClusterSelector'] = None,
                 clusters: Optional[Sequence['outputs.PlacementRuleSpecClusters']] = None,
                 policies: Optional[Sequence['outputs.PlacementRuleSpecPolicies']] = None,
                 resource_hint: Optional['outputs.PlacementRuleSpecResourceHint'] = None,
                 scheduler_name: Optional[str] = None):
        """
        PlacementRuleSpec defines the desired state of PlacementRule
        :param int cluster_replicas: number of replicas Application wants to
        :param 'PlacementRuleSpecClusterSelectorArgs' cluster_selector: A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
        :param Sequence['PlacementRuleSpecPoliciesArgs'] policies: Set Policy Filters
        :param 'PlacementRuleSpecResourceHintArgs' resource_hint: Select Resource
        :param str scheduler_name: INSERT ADDITIONAL SPEC FIELDS - desired state of cluster Important: Run "make" to regenerate code after modifying this file schedulerName, default to use mcm controller
        """
        if cluster_conditions is not None:
            pulumi.set(__self__, "cluster_conditions", cluster_conditions)
        if cluster_replicas is not None:
            pulumi.set(__self__, "cluster_replicas", cluster_replicas)
        if cluster_selector is not None:
            pulumi.set(__self__, "cluster_selector", cluster_selector)
        if clusters is not None:
            pulumi.set(__self__, "clusters", clusters)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if resource_hint is not None:
            pulumi.set(__self__, "resource_hint", resource_hint)
        if scheduler_name is not None:
            pulumi.set(__self__, "scheduler_name", scheduler_name)

    @property
    @pulumi.getter(name="clusterConditions")
    def cluster_conditions(self) -> Optional[Sequence['outputs.PlacementRuleSpecClusterConditions']]:
        return pulumi.get(self, "cluster_conditions")

    @property
    @pulumi.getter(name="clusterReplicas")
    def cluster_replicas(self) -> Optional[int]:
        """
        number of replicas Application wants to
        """
        return pulumi.get(self, "cluster_replicas")

    @property
    @pulumi.getter(name="clusterSelector")
    def cluster_selector(self) -> Optional['outputs.PlacementRuleSpecClusterSelector']:
        """
        A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
        """
        return pulumi.get(self, "cluster_selector")

    @property
    @pulumi.getter
    def clusters(self) -> Optional[Sequence['outputs.PlacementRuleSpecClusters']]:
        return pulumi.get(self, "clusters")

    @property
    @pulumi.getter
    def policies(self) -> Optional[Sequence['outputs.PlacementRuleSpecPolicies']]:
        """
        Set Policy Filters
        """
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter(name="resourceHint")
    def resource_hint(self) -> Optional['outputs.PlacementRuleSpecResourceHint']:
        """
        Select Resource
        """
        return pulumi.get(self, "resource_hint")

    @property
    @pulumi.getter(name="schedulerName")
    def scheduler_name(self) -> Optional[str]:
        """
        INSERT ADDITIONAL SPEC FIELDS - desired state of cluster Important: Run "make" to regenerate code after modifying this file schedulerName, default to use mcm controller
        """
        return pulumi.get(self, "scheduler_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PlacementRuleSpecClusterConditions(dict):
    """
    ClusterConditionFilter defines filter to filter cluster condition
    """
    def __init__(__self__, *,
                 status: Optional[str] = None,
                 type: Optional[str] = None):
        """
        ClusterConditionFilter defines filter to filter cluster condition
        """
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PlacementRuleSpecClusterSelector(dict):
    """
    A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
    """
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.PlacementRuleSpecClusterSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
        :param Sequence['PlacementRuleSpecClusterSelectorMatchExpressionsArgs'] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.PlacementRuleSpecClusterSelectorMatchExpressions']]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PlacementRuleSpecClusterSelectorMatchExpressions(dict):
    """
    A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
    """
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Optional[Sequence[str]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param str key: key is the label key that the selector applies to.
        :param str operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param Sequence[str] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PlacementRuleSpecClusters(dict):
    """
    GenericClusterReference - in alignment with kubefed
    """
    def __init__(__self__, *,
                 name: str):
        """
        GenericClusterReference - in alignment with kubefed
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PlacementRuleSpecPolicies(dict):
    """
    ObjectReference contains enough information to let you inspect or modify the referred object. --- New uses of this type are discouraged because of difficulty describing its usage when embedded in APIs.  1. Ignored fields.  It includes many fields which are not generally honored.  For instance, ResourceVersion and FieldPath are both very rarely valid in actual usage.  2. Invalid usage help.  It is impossible to add specific help for individual usage.  In most embedded usages, there are particular     restrictions like, "must refer only to types A and B" or "UID not honored" or "name must be restricted".     Those cannot be well described when embedded.  3. Inconsistent validation.  Because the usages are different, the validation rules are different by usage, which makes it hard for users to predict what will happen.  4. The fields are both imprecise and overly precise.  Kind is not a precise mapping to a URL. This can produce ambiguity     during interpretation and require a REST mapping.  In most cases, the dependency is on the group,resource tuple     and the version of the actual struct is irrelevant.  5. We cannot easily change it.  Because this type is embedded in many locations, updates to this type     will affect numerous schemas.  Don't make new APIs embed an underspecified API type they do not control. Instead of using this type, create a locally provided and used type that is well-focused on your reference. For example, ServiceReferences for admission registration: https://github.com/kubernetes/api/blob/release-1.17/admissionregistration/v1/types.go#L533 .
    """
    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 resource_version: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        ObjectReference contains enough information to let you inspect or modify the referred object. --- New uses of this type are discouraged because of difficulty describing its usage when embedded in APIs.  1. Ignored fields.  It includes many fields which are not generally honored.  For instance, ResourceVersion and FieldPath are both very rarely valid in actual usage.  2. Invalid usage help.  It is impossible to add specific help for individual usage.  In most embedded usages, there are particular     restrictions like, "must refer only to types A and B" or "UID not honored" or "name must be restricted".     Those cannot be well described when embedded.  3. Inconsistent validation.  Because the usages are different, the validation rules are different by usage, which makes it hard for users to predict what will happen.  4. The fields are both imprecise and overly precise.  Kind is not a precise mapping to a URL. This can produce ambiguity     during interpretation and require a REST mapping.  In most cases, the dependency is on the group,resource tuple     and the version of the actual struct is irrelevant.  5. We cannot easily change it.  Because this type is embedded in many locations, updates to this type     will affect numerous schemas.  Don't make new APIs embed an underspecified API type they do not control. Instead of using this type, create a locally provided and used type that is well-focused on your reference. For example, ServiceReferences for admission registration: https://github.com/kubernetes/api/blob/release-1.17/admissionregistration/v1/types.go#L533 .
        :param str api_version: API version of the referent.
        :param str field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param str kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param str resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param str uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[str]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PlacementRuleSpecResourceHint(dict):
    """
    Select Resource
    """
    def __init__(__self__, *,
                 order: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Select Resource
        :param str order: SelectionOrder is the type for Nodes
        :param str type: ResourceType defines types can be sorted
        """
        if order is not None:
            pulumi.set(__self__, "order", order)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        SelectionOrder is the type for Nodes
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        ResourceType defines types can be sorted
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PlacementRuleStatus(dict):
    """
    PlacementRuleStatus defines the observed state of PlacementRule
    """
    def __init__(__self__, *,
                 decisions: Optional[Sequence['outputs.PlacementRuleStatusDecisions']] = None):
        """
        PlacementRuleStatus defines the observed state of PlacementRule
        :param Sequence['PlacementRuleStatusDecisionsArgs'] decisions: INSERT ADDITIONAL STATUS FIELD - define observed state of cluster Important: Run "make" to regenerate code after modifying this file
        """
        if decisions is not None:
            pulumi.set(__self__, "decisions", decisions)

    @property
    @pulumi.getter
    def decisions(self) -> Optional[Sequence['outputs.PlacementRuleStatusDecisions']]:
        """
        INSERT ADDITIONAL STATUS FIELD - define observed state of cluster Important: Run "make" to regenerate code after modifying this file
        """
        return pulumi.get(self, "decisions")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PlacementRuleStatusDecisions(dict):
    """
    PlacementDecision defines the decision made by controller
    """
    def __init__(__self__, *,
                 cluster_name: Optional[str] = None,
                 cluster_namespace: Optional[str] = None):
        """
        PlacementDecision defines the decision made by controller
        """
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if cluster_namespace is not None:
            pulumi.set(__self__, "cluster_namespace", cluster_namespace)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[str]:
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="clusterNamespace")
    def cluster_namespace(self) -> Optional[str]:
        return pulumi.get(self, "cluster_namespace")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubscriptionSpec(dict):
    """
    SubscriptionSpec defines the desired state of Subscription
    """
    def __init__(__self__, *,
                 channel: str,
                 name: Optional[str] = None,
                 overrides: Optional[Sequence['outputs.SubscriptionSpecOverrides']] = None,
                 package_filter: Optional['outputs.SubscriptionSpecPackageFilter'] = None,
                 package_overrides: Optional[Sequence['outputs.SubscriptionSpecPackageOverrides']] = None,
                 placement: Optional['outputs.SubscriptionSpecPlacement'] = None,
                 timewindow: Optional['outputs.SubscriptionSpecTimewindow'] = None):
        """
        SubscriptionSpec defines the desired state of Subscription
        :param str name: To specify 1 package in channel
        :param Sequence['SubscriptionSpecOverridesArgs'] overrides: for hub use only to specify the overrides when apply to clusters
        :param 'SubscriptionSpecPackageFilterArgs' package_filter: To specify more than 1 package in channel
        :param Sequence['SubscriptionSpecPackageOverridesArgs'] package_overrides: To provide flexibility to override package in channel with local input
        :param 'SubscriptionSpecPlacementArgs' placement: For hub use only, to specify which clusters to go to
        :param 'SubscriptionSpecTimewindowArgs' timewindow: help user control when the subscription will take affect
        """
        pulumi.set(__self__, "channel", channel)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)
        if package_filter is not None:
            pulumi.set(__self__, "package_filter", package_filter)
        if package_overrides is not None:
            pulumi.set(__self__, "package_overrides", package_overrides)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if timewindow is not None:
            pulumi.set(__self__, "timewindow", timewindow)

    @property
    @pulumi.getter
    def channel(self) -> str:
        return pulumi.get(self, "channel")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        To specify 1 package in channel
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def overrides(self) -> Optional[Sequence['outputs.SubscriptionSpecOverrides']]:
        """
        for hub use only to specify the overrides when apply to clusters
        """
        return pulumi.get(self, "overrides")

    @property
    @pulumi.getter(name="packageFilter")
    def package_filter(self) -> Optional['outputs.SubscriptionSpecPackageFilter']:
        """
        To specify more than 1 package in channel
        """
        return pulumi.get(self, "package_filter")

    @property
    @pulumi.getter(name="packageOverrides")
    def package_overrides(self) -> Optional[Sequence['outputs.SubscriptionSpecPackageOverrides']]:
        """
        To provide flexibility to override package in channel with local input
        """
        return pulumi.get(self, "package_overrides")

    @property
    @pulumi.getter
    def placement(self) -> Optional['outputs.SubscriptionSpecPlacement']:
        """
        For hub use only, to specify which clusters to go to
        """
        return pulumi.get(self, "placement")

    @property
    @pulumi.getter
    def timewindow(self) -> Optional['outputs.SubscriptionSpecTimewindow']:
        """
        help user control when the subscription will take affect
        """
        return pulumi.get(self, "timewindow")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubscriptionSpecOverrides(dict):
    """
    Overrides field in deployable
    """
    def __init__(__self__, *,
                 cluster_name: str,
                 cluster_overrides: Sequence[Mapping[str, Any]]):
        """
        Overrides field in deployable
        """
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "cluster_overrides", cluster_overrides)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="clusterOverrides")
    def cluster_overrides(self) -> Sequence[Mapping[str, Any]]:
        return pulumi.get(self, "cluster_overrides")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubscriptionSpecPackageFilter(dict):
    """
    To specify more than 1 package in channel
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, str]] = None,
                 filter_ref: Optional['outputs.SubscriptionSpecPackageFilterFilterRef'] = None,
                 label_selector: Optional['outputs.SubscriptionSpecPackageFilterLabelSelector'] = None,
                 version: Optional[str] = None):
        """
        To specify more than 1 package in channel
        :param 'SubscriptionSpecPackageFilterFilterRefArgs' filter_ref: LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
        :param 'SubscriptionSpecPackageFilterLabelSelectorArgs' label_selector: A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if filter_ref is not None:
            pulumi.set(__self__, "filter_ref", filter_ref)
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="filterRef")
    def filter_ref(self) -> Optional['outputs.SubscriptionSpecPackageFilterFilterRef']:
        """
        LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
        """
        return pulumi.get(self, "filter_ref")

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.SubscriptionSpecPackageFilterLabelSelector']:
        """
        A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
        """
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        return pulumi.get(self, "version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubscriptionSpecPackageFilterFilterRef(dict):
    """
    LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubscriptionSpecPackageFilterLabelSelector(dict):
    """
    A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
    """
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.SubscriptionSpecPackageFilterLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
        :param Sequence['SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArgs'] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.SubscriptionSpecPackageFilterLabelSelectorMatchExpressions']]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubscriptionSpecPackageFilterLabelSelectorMatchExpressions(dict):
    """
    A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
    """
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Optional[Sequence[str]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param str key: key is the label key that the selector applies to.
        :param str operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param Sequence[str] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubscriptionSpecPackageOverrides(dict):
    """
    Overrides field in deployable
    """
    def __init__(__self__, *,
                 package_name: str,
                 package_alias: Optional[str] = None,
                 package_overrides: Optional[Sequence[Mapping[str, Any]]] = None):
        """
        Overrides field in deployable
        """
        pulumi.set(__self__, "package_name", package_name)
        if package_alias is not None:
            pulumi.set(__self__, "package_alias", package_alias)
        if package_overrides is not None:
            pulumi.set(__self__, "package_overrides", package_overrides)

    @property
    @pulumi.getter(name="packageName")
    def package_name(self) -> str:
        return pulumi.get(self, "package_name")

    @property
    @pulumi.getter(name="packageAlias")
    def package_alias(self) -> Optional[str]:
        return pulumi.get(self, "package_alias")

    @property
    @pulumi.getter(name="packageOverrides")
    def package_overrides(self) -> Optional[Sequence[Mapping[str, Any]]]:
        return pulumi.get(self, "package_overrides")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubscriptionSpecPlacement(dict):
    """
    For hub use only, to specify which clusters to go to
    """
    def __init__(__self__, *,
                 cluster_selector: Optional['outputs.SubscriptionSpecPlacementClusterSelector'] = None,
                 clusters: Optional[Sequence['outputs.SubscriptionSpecPlacementClusters']] = None,
                 local: Optional[bool] = None,
                 placement_ref: Optional['outputs.SubscriptionSpecPlacementPlacementRef'] = None):
        """
        For hub use only, to specify which clusters to go to
        :param 'SubscriptionSpecPlacementClusterSelectorArgs' cluster_selector: A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
        :param 'SubscriptionSpecPlacementPlacementRefArgs' placement_ref: ObjectReference contains enough information to let you inspect or modify the referred object.
        """
        if cluster_selector is not None:
            pulumi.set(__self__, "cluster_selector", cluster_selector)
        if clusters is not None:
            pulumi.set(__self__, "clusters", clusters)
        if local is not None:
            pulumi.set(__self__, "local", local)
        if placement_ref is not None:
            pulumi.set(__self__, "placement_ref", placement_ref)

    @property
    @pulumi.getter(name="clusterSelector")
    def cluster_selector(self) -> Optional['outputs.SubscriptionSpecPlacementClusterSelector']:
        """
        A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
        """
        return pulumi.get(self, "cluster_selector")

    @property
    @pulumi.getter
    def clusters(self) -> Optional[Sequence['outputs.SubscriptionSpecPlacementClusters']]:
        return pulumi.get(self, "clusters")

    @property
    @pulumi.getter
    def local(self) -> Optional[bool]:
        return pulumi.get(self, "local")

    @property
    @pulumi.getter(name="placementRef")
    def placement_ref(self) -> Optional['outputs.SubscriptionSpecPlacementPlacementRef']:
        """
        ObjectReference contains enough information to let you inspect or modify the referred object.
        """
        return pulumi.get(self, "placement_ref")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubscriptionSpecPlacementClusterSelector(dict):
    """
    A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
    """
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.SubscriptionSpecPlacementClusterSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
        :param Sequence['SubscriptionSpecPlacementClusterSelectorMatchExpressionsArgs'] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.SubscriptionSpecPlacementClusterSelectorMatchExpressions']]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubscriptionSpecPlacementClusterSelectorMatchExpressions(dict):
    """
    A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
    """
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Optional[Sequence[str]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param str key: key is the label key that the selector applies to.
        :param str operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param Sequence[str] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubscriptionSpecPlacementClusters(dict):
    """
    GenericClusterReference - in alignment with kubefed
    """
    def __init__(__self__, *,
                 name: str):
        """
        GenericClusterReference - in alignment with kubefed
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubscriptionSpecPlacementPlacementRef(dict):
    """
    ObjectReference contains enough information to let you inspect or modify the referred object.
    """
    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 resource_version: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        ObjectReference contains enough information to let you inspect or modify the referred object.
        :param str api_version: API version of the referent.
        :param str field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param str kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param str resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
        :param str uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[str]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubscriptionSpecTimewindow(dict):
    """
    help user control when the subscription will take affect
    """
    def __init__(__self__, *,
                 daysofweek: Optional[Sequence[str]] = None,
                 hours: Optional[Sequence['outputs.SubscriptionSpecTimewindowHours']] = None,
                 location: Optional[str] = None,
                 windowtype: Optional[str] = None):
        """
        help user control when the subscription will take affect
        :param Sequence[str] daysofweek: Defines the day of the week for the subscription timewindow window https://golang.org/pkg/time/#Weekday
        :param str location: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
        :param str windowtype: active time window or not, if timewindow is active, then deploy will only applies during these windows Note, if you want to generation crd with operator-sdk v0.10.0, then the following line should be: <+kubebuilder:validation:Enum=active,blocked,Active,Blocked>
        """
        if daysofweek is not None:
            pulumi.set(__self__, "daysofweek", daysofweek)
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if windowtype is not None:
            pulumi.set(__self__, "windowtype", windowtype)

    @property
    @pulumi.getter
    def daysofweek(self) -> Optional[Sequence[str]]:
        """
        Defines the day of the week for the subscription timewindow window https://golang.org/pkg/time/#Weekday
        """
        return pulumi.get(self, "daysofweek")

    @property
    @pulumi.getter
    def hours(self) -> Optional[Sequence['outputs.SubscriptionSpecTimewindowHours']]:
        return pulumi.get(self, "hours")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def windowtype(self) -> Optional[str]:
        """
        active time window or not, if timewindow is active, then deploy will only applies during these windows Note, if you want to generation crd with operator-sdk v0.10.0, then the following line should be: <+kubebuilder:validation:Enum=active,blocked,Active,Blocked>
        """
        return pulumi.get(self, "windowtype")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubscriptionSpecTimewindowHours(dict):
    """
    HourRange time format for each time will be Kitchen format, defined at https://golang.org/pkg/time/#pkg-constants
    """
    def __init__(__self__, *,
                 end: Optional[str] = None,
                 start: Optional[str] = None):
        """
        HourRange time format for each time will be Kitchen format, defined at https://golang.org/pkg/time/#pkg-constants
        """
        if end is not None:
            pulumi.set(__self__, "end", end)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> Optional[str]:
        return pulumi.get(self, "end")

    @property
    @pulumi.getter
    def start(self) -> Optional[str]:
        return pulumi.get(self, "start")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class SubscriptionStatus(dict):
    """
    SubscriptionStatus defines the observed state of Subscription Examples - status of a subscription on hub Status: 	phase: Propagated 	statuses: 	  washdc: 		packages: 		  nginx: 			phase: Subscribed 		  mongodb: 			phase: Failed 			Reason: "not authorized" 			Message: "user xxx does not have permission to start pod" 			resourceStatus: {}    toronto: 		packages: 		  nginx: 			phase: Subscribed 		  mongodb: 			phase: Subscribed Status of a subscription on managed cluster will only have 1 cluster in the map.
    """
    def __init__(__self__, *,
                 last_update_time: Optional[str] = None,
                 message: Optional[str] = None,
                 phase: Optional[str] = None,
                 reason: Optional[str] = None,
                 statuses: Optional[Any] = None):
        """
        SubscriptionStatus defines the observed state of Subscription Examples - status of a subscription on hub Status: 	phase: Propagated 	statuses: 	  washdc: 		packages: 		  nginx: 			phase: Subscribed 		  mongodb: 			phase: Failed 			Reason: "not authorized" 			Message: "user xxx does not have permission to start pod" 			resourceStatus: {}    toronto: 		packages: 		  nginx: 			phase: Subscribed 		  mongodb: 			phase: Subscribed Status of a subscription on managed cluster will only have 1 cluster in the map.
        :param str phase: INSERT ADDITIONAL STATUS FIELD - define observed state of cluster Important: Run "make" to regenerate code after modifying this file
        :param Any statuses: For endpoint, it is the status of subscription, key is packagename, For hub, it aggregates all status, key is cluster name
        """
        if last_update_time is not None:
            pulumi.set(__self__, "last_update_time", last_update_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if statuses is not None:
            pulumi.set(__self__, "statuses", statuses)

    @property
    @pulumi.getter(name="lastUpdateTime")
    def last_update_time(self) -> Optional[str]:
        return pulumi.get(self, "last_update_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def phase(self) -> Optional[str]:
        """
        INSERT ADDITIONAL STATUS FIELD - define observed state of cluster Important: Run "make" to regenerate code after modifying this file
        """
        return pulumi.get(self, "phase")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def statuses(self) -> Optional[Any]:
        """
        For endpoint, it is the status of subscription, key is packagename, For hub, it aggregates all status, key is cluster name
        """
        return pulumi.get(self, "statuses")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


