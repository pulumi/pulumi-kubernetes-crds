// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package v1

import (
	"context"
	"reflect"

	metav1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/meta/v1"
	"github.com/pulumi/pulumi/sdk/v2/go/pulumi"
)

// Channel is the Schema for the channels API
type ChannelType struct {
	ApiVersion *string            `pulumi:"apiVersion"`
	Kind       *string            `pulumi:"kind"`
	Metadata   *metav1.ObjectMeta `pulumi:"metadata"`
	// ChannelSpec defines the desired state of Channel
	Spec *ChannelSpec `pulumi:"spec"`
	// The most recent observed status of the Channel.
	Status map[string]interface{} `pulumi:"status"`
}

// ChannelTypeInput is an input type that accepts ChannelTypeArgs and ChannelTypeOutput values.
// You can construct a concrete instance of `ChannelTypeInput` via:
//
//          ChannelTypeArgs{...}
type ChannelTypeInput interface {
	pulumi.Input

	ToChannelTypeOutput() ChannelTypeOutput
	ToChannelTypeOutputWithContext(context.Context) ChannelTypeOutput
}

// Channel is the Schema for the channels API
type ChannelTypeArgs struct {
	ApiVersion pulumi.StringPtrInput     `pulumi:"apiVersion"`
	Kind       pulumi.StringPtrInput     `pulumi:"kind"`
	Metadata   metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	// ChannelSpec defines the desired state of Channel
	Spec ChannelSpecPtrInput `pulumi:"spec"`
	// The most recent observed status of the Channel.
	Status pulumi.MapInput `pulumi:"status"`
}

func (ChannelTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChannelType)(nil)).Elem()
}

func (i ChannelTypeArgs) ToChannelTypeOutput() ChannelTypeOutput {
	return i.ToChannelTypeOutputWithContext(context.Background())
}

func (i ChannelTypeArgs) ToChannelTypeOutputWithContext(ctx context.Context) ChannelTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChannelTypeOutput)
}

// Channel is the Schema for the channels API
type ChannelTypeOutput struct{ *pulumi.OutputState }

func (ChannelTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChannelType)(nil)).Elem()
}

func (o ChannelTypeOutput) ToChannelTypeOutput() ChannelTypeOutput {
	return o
}

func (o ChannelTypeOutput) ToChannelTypeOutputWithContext(ctx context.Context) ChannelTypeOutput {
	return o
}

func (o ChannelTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChannelType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

func (o ChannelTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChannelType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

func (o ChannelTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v ChannelType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

// ChannelSpec defines the desired state of Channel
func (o ChannelTypeOutput) Spec() ChannelSpecPtrOutput {
	return o.ApplyT(func(v ChannelType) *ChannelSpec { return v.Spec }).(ChannelSpecPtrOutput)
}

// The most recent observed status of the Channel.
func (o ChannelTypeOutput) Status() pulumi.MapOutput {
	return o.ApplyT(func(v ChannelType) map[string]interface{} { return v.Status }).(pulumi.MapOutput)
}

type ChannelMetadata struct {
}

// ChannelMetadataInput is an input type that accepts ChannelMetadataArgs and ChannelMetadataOutput values.
// You can construct a concrete instance of `ChannelMetadataInput` via:
//
//          ChannelMetadataArgs{...}
type ChannelMetadataInput interface {
	pulumi.Input

	ToChannelMetadataOutput() ChannelMetadataOutput
	ToChannelMetadataOutputWithContext(context.Context) ChannelMetadataOutput
}

type ChannelMetadataArgs struct {
}

func (ChannelMetadataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChannelMetadata)(nil)).Elem()
}

func (i ChannelMetadataArgs) ToChannelMetadataOutput() ChannelMetadataOutput {
	return i.ToChannelMetadataOutputWithContext(context.Background())
}

func (i ChannelMetadataArgs) ToChannelMetadataOutputWithContext(ctx context.Context) ChannelMetadataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChannelMetadataOutput)
}

type ChannelMetadataOutput struct{ *pulumi.OutputState }

func (ChannelMetadataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChannelMetadata)(nil)).Elem()
}

func (o ChannelMetadataOutput) ToChannelMetadataOutput() ChannelMetadataOutput {
	return o
}

func (o ChannelMetadataOutput) ToChannelMetadataOutputWithContext(ctx context.Context) ChannelMetadataOutput {
	return o
}

// ChannelSpec defines the desired state of Channel
type ChannelSpec struct {
	// Reference to a ConfigMap which contains additional settings for accessing the channel. For example, the `insecureSkipVerify` option for accessing HTTPS endpoints can be set in the ConfigMap to indicate a insecure connection.
	ConfigMapRef *ChannelSpecConfigMapRef `pulumi:"configMapRef"`
	// Criteria for promoting a Deployable from the sourceNamespaces to Channel.
	Gates *ChannelSpecGates `pulumi:"gates"`
	// Skip server TLS certificate verification for Git or Helm channel.
	InsecureSkipVerify *bool `pulumi:"insecureSkipVerify"`
	// For a `namespace` channel, pathname is the name of the namespace; For a `helmrepo` or `github` channel, pathname is the remote URL for the channel contents; For a `objectbucket` channel, pathname is the URL and name of the bucket.
	Pathname string `pulumi:"pathname"`
	// For a `github` channel or a `helmrepo` channel on github, this can be used to reference a Secret which contains the credentials for authentication, i.e. `user` and `accessToken`. For a `objectbucket` channel, this can be used to reference a Secret which contains the AWS credentials, i.e. `AccessKeyID` and `SecretAccessKey`.
	SecretRef *ChannelSpecSecretRef `pulumi:"secretRef"`
	// A list of namespace names from which Deployables can be promoted.
	SourceNamespaces []string `pulumi:"sourceNamespaces"`
	// ChannelType defines types of channel
	Type string `pulumi:"type"`
}

// ChannelSpecInput is an input type that accepts ChannelSpecArgs and ChannelSpecOutput values.
// You can construct a concrete instance of `ChannelSpecInput` via:
//
//          ChannelSpecArgs{...}
type ChannelSpecInput interface {
	pulumi.Input

	ToChannelSpecOutput() ChannelSpecOutput
	ToChannelSpecOutputWithContext(context.Context) ChannelSpecOutput
}

// ChannelSpec defines the desired state of Channel
type ChannelSpecArgs struct {
	// Reference to a ConfigMap which contains additional settings for accessing the channel. For example, the `insecureSkipVerify` option for accessing HTTPS endpoints can be set in the ConfigMap to indicate a insecure connection.
	ConfigMapRef ChannelSpecConfigMapRefPtrInput `pulumi:"configMapRef"`
	// Criteria for promoting a Deployable from the sourceNamespaces to Channel.
	Gates ChannelSpecGatesPtrInput `pulumi:"gates"`
	// Skip server TLS certificate verification for Git or Helm channel.
	InsecureSkipVerify pulumi.BoolPtrInput `pulumi:"insecureSkipVerify"`
	// For a `namespace` channel, pathname is the name of the namespace; For a `helmrepo` or `github` channel, pathname is the remote URL for the channel contents; For a `objectbucket` channel, pathname is the URL and name of the bucket.
	Pathname pulumi.StringInput `pulumi:"pathname"`
	// For a `github` channel or a `helmrepo` channel on github, this can be used to reference a Secret which contains the credentials for authentication, i.e. `user` and `accessToken`. For a `objectbucket` channel, this can be used to reference a Secret which contains the AWS credentials, i.e. `AccessKeyID` and `SecretAccessKey`.
	SecretRef ChannelSpecSecretRefPtrInput `pulumi:"secretRef"`
	// A list of namespace names from which Deployables can be promoted.
	SourceNamespaces pulumi.StringArrayInput `pulumi:"sourceNamespaces"`
	// ChannelType defines types of channel
	Type pulumi.StringInput `pulumi:"type"`
}

func (ChannelSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChannelSpec)(nil)).Elem()
}

func (i ChannelSpecArgs) ToChannelSpecOutput() ChannelSpecOutput {
	return i.ToChannelSpecOutputWithContext(context.Background())
}

func (i ChannelSpecArgs) ToChannelSpecOutputWithContext(ctx context.Context) ChannelSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChannelSpecOutput)
}

func (i ChannelSpecArgs) ToChannelSpecPtrOutput() ChannelSpecPtrOutput {
	return i.ToChannelSpecPtrOutputWithContext(context.Background())
}

func (i ChannelSpecArgs) ToChannelSpecPtrOutputWithContext(ctx context.Context) ChannelSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChannelSpecOutput).ToChannelSpecPtrOutputWithContext(ctx)
}

// ChannelSpecPtrInput is an input type that accepts ChannelSpecArgs, ChannelSpecPtr and ChannelSpecPtrOutput values.
// You can construct a concrete instance of `ChannelSpecPtrInput` via:
//
//          ChannelSpecArgs{...}
//
//  or:
//
//          nil
type ChannelSpecPtrInput interface {
	pulumi.Input

	ToChannelSpecPtrOutput() ChannelSpecPtrOutput
	ToChannelSpecPtrOutputWithContext(context.Context) ChannelSpecPtrOutput
}

type channelSpecPtrType ChannelSpecArgs

func ChannelSpecPtr(v *ChannelSpecArgs) ChannelSpecPtrInput {
	return (*channelSpecPtrType)(v)
}

func (*channelSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChannelSpec)(nil)).Elem()
}

func (i *channelSpecPtrType) ToChannelSpecPtrOutput() ChannelSpecPtrOutput {
	return i.ToChannelSpecPtrOutputWithContext(context.Background())
}

func (i *channelSpecPtrType) ToChannelSpecPtrOutputWithContext(ctx context.Context) ChannelSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChannelSpecPtrOutput)
}

// ChannelSpec defines the desired state of Channel
type ChannelSpecOutput struct{ *pulumi.OutputState }

func (ChannelSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChannelSpec)(nil)).Elem()
}

func (o ChannelSpecOutput) ToChannelSpecOutput() ChannelSpecOutput {
	return o
}

func (o ChannelSpecOutput) ToChannelSpecOutputWithContext(ctx context.Context) ChannelSpecOutput {
	return o
}

func (o ChannelSpecOutput) ToChannelSpecPtrOutput() ChannelSpecPtrOutput {
	return o.ToChannelSpecPtrOutputWithContext(context.Background())
}

func (o ChannelSpecOutput) ToChannelSpecPtrOutputWithContext(ctx context.Context) ChannelSpecPtrOutput {
	return o.ApplyT(func(v ChannelSpec) *ChannelSpec {
		return &v
	}).(ChannelSpecPtrOutput)
}

// Reference to a ConfigMap which contains additional settings for accessing the channel. For example, the `insecureSkipVerify` option for accessing HTTPS endpoints can be set in the ConfigMap to indicate a insecure connection.
func (o ChannelSpecOutput) ConfigMapRef() ChannelSpecConfigMapRefPtrOutput {
	return o.ApplyT(func(v ChannelSpec) *ChannelSpecConfigMapRef { return v.ConfigMapRef }).(ChannelSpecConfigMapRefPtrOutput)
}

// Criteria for promoting a Deployable from the sourceNamespaces to Channel.
func (o ChannelSpecOutput) Gates() ChannelSpecGatesPtrOutput {
	return o.ApplyT(func(v ChannelSpec) *ChannelSpecGates { return v.Gates }).(ChannelSpecGatesPtrOutput)
}

// Skip server TLS certificate verification for Git or Helm channel.
func (o ChannelSpecOutput) InsecureSkipVerify() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ChannelSpec) *bool { return v.InsecureSkipVerify }).(pulumi.BoolPtrOutput)
}

// For a `namespace` channel, pathname is the name of the namespace; For a `helmrepo` or `github` channel, pathname is the remote URL for the channel contents; For a `objectbucket` channel, pathname is the URL and name of the bucket.
func (o ChannelSpecOutput) Pathname() pulumi.StringOutput {
	return o.ApplyT(func(v ChannelSpec) string { return v.Pathname }).(pulumi.StringOutput)
}

// For a `github` channel or a `helmrepo` channel on github, this can be used to reference a Secret which contains the credentials for authentication, i.e. `user` and `accessToken`. For a `objectbucket` channel, this can be used to reference a Secret which contains the AWS credentials, i.e. `AccessKeyID` and `SecretAccessKey`.
func (o ChannelSpecOutput) SecretRef() ChannelSpecSecretRefPtrOutput {
	return o.ApplyT(func(v ChannelSpec) *ChannelSpecSecretRef { return v.SecretRef }).(ChannelSpecSecretRefPtrOutput)
}

// A list of namespace names from which Deployables can be promoted.
func (o ChannelSpecOutput) SourceNamespaces() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChannelSpec) []string { return v.SourceNamespaces }).(pulumi.StringArrayOutput)
}

// ChannelType defines types of channel
func (o ChannelSpecOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ChannelSpec) string { return v.Type }).(pulumi.StringOutput)
}

type ChannelSpecPtrOutput struct{ *pulumi.OutputState }

func (ChannelSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChannelSpec)(nil)).Elem()
}

func (o ChannelSpecPtrOutput) ToChannelSpecPtrOutput() ChannelSpecPtrOutput {
	return o
}

func (o ChannelSpecPtrOutput) ToChannelSpecPtrOutputWithContext(ctx context.Context) ChannelSpecPtrOutput {
	return o
}

func (o ChannelSpecPtrOutput) Elem() ChannelSpecOutput {
	return o.ApplyT(func(v *ChannelSpec) ChannelSpec { return *v }).(ChannelSpecOutput)
}

// Reference to a ConfigMap which contains additional settings for accessing the channel. For example, the `insecureSkipVerify` option for accessing HTTPS endpoints can be set in the ConfigMap to indicate a insecure connection.
func (o ChannelSpecPtrOutput) ConfigMapRef() ChannelSpecConfigMapRefPtrOutput {
	return o.ApplyT(func(v *ChannelSpec) *ChannelSpecConfigMapRef {
		if v == nil {
			return nil
		}
		return v.ConfigMapRef
	}).(ChannelSpecConfigMapRefPtrOutput)
}

// Criteria for promoting a Deployable from the sourceNamespaces to Channel.
func (o ChannelSpecPtrOutput) Gates() ChannelSpecGatesPtrOutput {
	return o.ApplyT(func(v *ChannelSpec) *ChannelSpecGates {
		if v == nil {
			return nil
		}
		return v.Gates
	}).(ChannelSpecGatesPtrOutput)
}

// Skip server TLS certificate verification for Git or Helm channel.
func (o ChannelSpecPtrOutput) InsecureSkipVerify() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ChannelSpec) *bool {
		if v == nil {
			return nil
		}
		return v.InsecureSkipVerify
	}).(pulumi.BoolPtrOutput)
}

// For a `namespace` channel, pathname is the name of the namespace; For a `helmrepo` or `github` channel, pathname is the remote URL for the channel contents; For a `objectbucket` channel, pathname is the URL and name of the bucket.
func (o ChannelSpecPtrOutput) Pathname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChannelSpec) *string {
		if v == nil {
			return nil
		}
		return &v.Pathname
	}).(pulumi.StringPtrOutput)
}

// For a `github` channel or a `helmrepo` channel on github, this can be used to reference a Secret which contains the credentials for authentication, i.e. `user` and `accessToken`. For a `objectbucket` channel, this can be used to reference a Secret which contains the AWS credentials, i.e. `AccessKeyID` and `SecretAccessKey`.
func (o ChannelSpecPtrOutput) SecretRef() ChannelSpecSecretRefPtrOutput {
	return o.ApplyT(func(v *ChannelSpec) *ChannelSpecSecretRef {
		if v == nil {
			return nil
		}
		return v.SecretRef
	}).(ChannelSpecSecretRefPtrOutput)
}

// A list of namespace names from which Deployables can be promoted.
func (o ChannelSpecPtrOutput) SourceNamespaces() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ChannelSpec) []string {
		if v == nil {
			return nil
		}
		return v.SourceNamespaces
	}).(pulumi.StringArrayOutput)
}

// ChannelType defines types of channel
func (o ChannelSpecPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChannelSpec) *string {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(pulumi.StringPtrOutput)
}

// Reference to a ConfigMap which contains additional settings for accessing the channel. For example, the `insecureSkipVerify` option for accessing HTTPS endpoints can be set in the ConfigMap to indicate a insecure connection.
type ChannelSpecConfigMapRef struct {
	// API version of the referent.
	ApiVersion *string `pulumi:"apiVersion"`
	// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
	FieldPath *string `pulumi:"fieldPath"`
	// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name *string `pulumi:"name"`
	// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
	Namespace *string `pulumi:"namespace"`
	// Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
	ResourceVersion *string `pulumi:"resourceVersion"`
	// UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
	Uid *string `pulumi:"uid"`
}

// ChannelSpecConfigMapRefInput is an input type that accepts ChannelSpecConfigMapRefArgs and ChannelSpecConfigMapRefOutput values.
// You can construct a concrete instance of `ChannelSpecConfigMapRefInput` via:
//
//          ChannelSpecConfigMapRefArgs{...}
type ChannelSpecConfigMapRefInput interface {
	pulumi.Input

	ToChannelSpecConfigMapRefOutput() ChannelSpecConfigMapRefOutput
	ToChannelSpecConfigMapRefOutputWithContext(context.Context) ChannelSpecConfigMapRefOutput
}

// Reference to a ConfigMap which contains additional settings for accessing the channel. For example, the `insecureSkipVerify` option for accessing HTTPS endpoints can be set in the ConfigMap to indicate a insecure connection.
type ChannelSpecConfigMapRefArgs struct {
	// API version of the referent.
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
	FieldPath pulumi.StringPtrInput `pulumi:"fieldPath"`
	// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
	ResourceVersion pulumi.StringPtrInput `pulumi:"resourceVersion"`
	// UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
	Uid pulumi.StringPtrInput `pulumi:"uid"`
}

func (ChannelSpecConfigMapRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChannelSpecConfigMapRef)(nil)).Elem()
}

func (i ChannelSpecConfigMapRefArgs) ToChannelSpecConfigMapRefOutput() ChannelSpecConfigMapRefOutput {
	return i.ToChannelSpecConfigMapRefOutputWithContext(context.Background())
}

func (i ChannelSpecConfigMapRefArgs) ToChannelSpecConfigMapRefOutputWithContext(ctx context.Context) ChannelSpecConfigMapRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChannelSpecConfigMapRefOutput)
}

func (i ChannelSpecConfigMapRefArgs) ToChannelSpecConfigMapRefPtrOutput() ChannelSpecConfigMapRefPtrOutput {
	return i.ToChannelSpecConfigMapRefPtrOutputWithContext(context.Background())
}

func (i ChannelSpecConfigMapRefArgs) ToChannelSpecConfigMapRefPtrOutputWithContext(ctx context.Context) ChannelSpecConfigMapRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChannelSpecConfigMapRefOutput).ToChannelSpecConfigMapRefPtrOutputWithContext(ctx)
}

// ChannelSpecConfigMapRefPtrInput is an input type that accepts ChannelSpecConfigMapRefArgs, ChannelSpecConfigMapRefPtr and ChannelSpecConfigMapRefPtrOutput values.
// You can construct a concrete instance of `ChannelSpecConfigMapRefPtrInput` via:
//
//          ChannelSpecConfigMapRefArgs{...}
//
//  or:
//
//          nil
type ChannelSpecConfigMapRefPtrInput interface {
	pulumi.Input

	ToChannelSpecConfigMapRefPtrOutput() ChannelSpecConfigMapRefPtrOutput
	ToChannelSpecConfigMapRefPtrOutputWithContext(context.Context) ChannelSpecConfigMapRefPtrOutput
}

type channelSpecConfigMapRefPtrType ChannelSpecConfigMapRefArgs

func ChannelSpecConfigMapRefPtr(v *ChannelSpecConfigMapRefArgs) ChannelSpecConfigMapRefPtrInput {
	return (*channelSpecConfigMapRefPtrType)(v)
}

func (*channelSpecConfigMapRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChannelSpecConfigMapRef)(nil)).Elem()
}

func (i *channelSpecConfigMapRefPtrType) ToChannelSpecConfigMapRefPtrOutput() ChannelSpecConfigMapRefPtrOutput {
	return i.ToChannelSpecConfigMapRefPtrOutputWithContext(context.Background())
}

func (i *channelSpecConfigMapRefPtrType) ToChannelSpecConfigMapRefPtrOutputWithContext(ctx context.Context) ChannelSpecConfigMapRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChannelSpecConfigMapRefPtrOutput)
}

// Reference to a ConfigMap which contains additional settings for accessing the channel. For example, the `insecureSkipVerify` option for accessing HTTPS endpoints can be set in the ConfigMap to indicate a insecure connection.
type ChannelSpecConfigMapRefOutput struct{ *pulumi.OutputState }

func (ChannelSpecConfigMapRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChannelSpecConfigMapRef)(nil)).Elem()
}

func (o ChannelSpecConfigMapRefOutput) ToChannelSpecConfigMapRefOutput() ChannelSpecConfigMapRefOutput {
	return o
}

func (o ChannelSpecConfigMapRefOutput) ToChannelSpecConfigMapRefOutputWithContext(ctx context.Context) ChannelSpecConfigMapRefOutput {
	return o
}

func (o ChannelSpecConfigMapRefOutput) ToChannelSpecConfigMapRefPtrOutput() ChannelSpecConfigMapRefPtrOutput {
	return o.ToChannelSpecConfigMapRefPtrOutputWithContext(context.Background())
}

func (o ChannelSpecConfigMapRefOutput) ToChannelSpecConfigMapRefPtrOutputWithContext(ctx context.Context) ChannelSpecConfigMapRefPtrOutput {
	return o.ApplyT(func(v ChannelSpecConfigMapRef) *ChannelSpecConfigMapRef {
		return &v
	}).(ChannelSpecConfigMapRefPtrOutput)
}

// API version of the referent.
func (o ChannelSpecConfigMapRefOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChannelSpecConfigMapRef) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
func (o ChannelSpecConfigMapRefOutput) FieldPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChannelSpecConfigMapRef) *string { return v.FieldPath }).(pulumi.StringPtrOutput)
}

// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ChannelSpecConfigMapRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChannelSpecConfigMapRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChannelSpecConfigMapRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChannelSpecConfigMapRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
func (o ChannelSpecConfigMapRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChannelSpecConfigMapRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
func (o ChannelSpecConfigMapRefOutput) ResourceVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChannelSpecConfigMapRef) *string { return v.ResourceVersion }).(pulumi.StringPtrOutput)
}

// UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
func (o ChannelSpecConfigMapRefOutput) Uid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChannelSpecConfigMapRef) *string { return v.Uid }).(pulumi.StringPtrOutput)
}

type ChannelSpecConfigMapRefPtrOutput struct{ *pulumi.OutputState }

func (ChannelSpecConfigMapRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChannelSpecConfigMapRef)(nil)).Elem()
}

func (o ChannelSpecConfigMapRefPtrOutput) ToChannelSpecConfigMapRefPtrOutput() ChannelSpecConfigMapRefPtrOutput {
	return o
}

func (o ChannelSpecConfigMapRefPtrOutput) ToChannelSpecConfigMapRefPtrOutputWithContext(ctx context.Context) ChannelSpecConfigMapRefPtrOutput {
	return o
}

func (o ChannelSpecConfigMapRefPtrOutput) Elem() ChannelSpecConfigMapRefOutput {
	return o.ApplyT(func(v *ChannelSpecConfigMapRef) ChannelSpecConfigMapRef { return *v }).(ChannelSpecConfigMapRefOutput)
}

// API version of the referent.
func (o ChannelSpecConfigMapRefPtrOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChannelSpecConfigMapRef) *string {
		if v == nil {
			return nil
		}
		return v.ApiVersion
	}).(pulumi.StringPtrOutput)
}

// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
func (o ChannelSpecConfigMapRefPtrOutput) FieldPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChannelSpecConfigMapRef) *string {
		if v == nil {
			return nil
		}
		return v.FieldPath
	}).(pulumi.StringPtrOutput)
}

// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ChannelSpecConfigMapRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChannelSpecConfigMapRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChannelSpecConfigMapRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChannelSpecConfigMapRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
func (o ChannelSpecConfigMapRefPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChannelSpecConfigMapRef) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
func (o ChannelSpecConfigMapRefPtrOutput) ResourceVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChannelSpecConfigMapRef) *string {
		if v == nil {
			return nil
		}
		return v.ResourceVersion
	}).(pulumi.StringPtrOutput)
}

// UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
func (o ChannelSpecConfigMapRefPtrOutput) Uid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChannelSpecConfigMapRef) *string {
		if v == nil {
			return nil
		}
		return v.Uid
	}).(pulumi.StringPtrOutput)
}

// Criteria for promoting a Deployable from the sourceNamespaces to Channel.
type ChannelSpecGates struct {
	// The annotations which must present on a Deployable for it to be eligible for promotion.
	Annotations map[string]string `pulumi:"annotations"`
	// A label selector for selecting the Deployables.
	LabelSelector *ChannelSpecGatesLabelSelector `pulumi:"labelSelector"`
	Name          *string                        `pulumi:"name"`
}

// ChannelSpecGatesInput is an input type that accepts ChannelSpecGatesArgs and ChannelSpecGatesOutput values.
// You can construct a concrete instance of `ChannelSpecGatesInput` via:
//
//          ChannelSpecGatesArgs{...}
type ChannelSpecGatesInput interface {
	pulumi.Input

	ToChannelSpecGatesOutput() ChannelSpecGatesOutput
	ToChannelSpecGatesOutputWithContext(context.Context) ChannelSpecGatesOutput
}

// Criteria for promoting a Deployable from the sourceNamespaces to Channel.
type ChannelSpecGatesArgs struct {
	// The annotations which must present on a Deployable for it to be eligible for promotion.
	Annotations pulumi.StringMapInput `pulumi:"annotations"`
	// A label selector for selecting the Deployables.
	LabelSelector ChannelSpecGatesLabelSelectorPtrInput `pulumi:"labelSelector"`
	Name          pulumi.StringPtrInput                 `pulumi:"name"`
}

func (ChannelSpecGatesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChannelSpecGates)(nil)).Elem()
}

func (i ChannelSpecGatesArgs) ToChannelSpecGatesOutput() ChannelSpecGatesOutput {
	return i.ToChannelSpecGatesOutputWithContext(context.Background())
}

func (i ChannelSpecGatesArgs) ToChannelSpecGatesOutputWithContext(ctx context.Context) ChannelSpecGatesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChannelSpecGatesOutput)
}

func (i ChannelSpecGatesArgs) ToChannelSpecGatesPtrOutput() ChannelSpecGatesPtrOutput {
	return i.ToChannelSpecGatesPtrOutputWithContext(context.Background())
}

func (i ChannelSpecGatesArgs) ToChannelSpecGatesPtrOutputWithContext(ctx context.Context) ChannelSpecGatesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChannelSpecGatesOutput).ToChannelSpecGatesPtrOutputWithContext(ctx)
}

// ChannelSpecGatesPtrInput is an input type that accepts ChannelSpecGatesArgs, ChannelSpecGatesPtr and ChannelSpecGatesPtrOutput values.
// You can construct a concrete instance of `ChannelSpecGatesPtrInput` via:
//
//          ChannelSpecGatesArgs{...}
//
//  or:
//
//          nil
type ChannelSpecGatesPtrInput interface {
	pulumi.Input

	ToChannelSpecGatesPtrOutput() ChannelSpecGatesPtrOutput
	ToChannelSpecGatesPtrOutputWithContext(context.Context) ChannelSpecGatesPtrOutput
}

type channelSpecGatesPtrType ChannelSpecGatesArgs

func ChannelSpecGatesPtr(v *ChannelSpecGatesArgs) ChannelSpecGatesPtrInput {
	return (*channelSpecGatesPtrType)(v)
}

func (*channelSpecGatesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChannelSpecGates)(nil)).Elem()
}

func (i *channelSpecGatesPtrType) ToChannelSpecGatesPtrOutput() ChannelSpecGatesPtrOutput {
	return i.ToChannelSpecGatesPtrOutputWithContext(context.Background())
}

func (i *channelSpecGatesPtrType) ToChannelSpecGatesPtrOutputWithContext(ctx context.Context) ChannelSpecGatesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChannelSpecGatesPtrOutput)
}

// Criteria for promoting a Deployable from the sourceNamespaces to Channel.
type ChannelSpecGatesOutput struct{ *pulumi.OutputState }

func (ChannelSpecGatesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChannelSpecGates)(nil)).Elem()
}

func (o ChannelSpecGatesOutput) ToChannelSpecGatesOutput() ChannelSpecGatesOutput {
	return o
}

func (o ChannelSpecGatesOutput) ToChannelSpecGatesOutputWithContext(ctx context.Context) ChannelSpecGatesOutput {
	return o
}

func (o ChannelSpecGatesOutput) ToChannelSpecGatesPtrOutput() ChannelSpecGatesPtrOutput {
	return o.ToChannelSpecGatesPtrOutputWithContext(context.Background())
}

func (o ChannelSpecGatesOutput) ToChannelSpecGatesPtrOutputWithContext(ctx context.Context) ChannelSpecGatesPtrOutput {
	return o.ApplyT(func(v ChannelSpecGates) *ChannelSpecGates {
		return &v
	}).(ChannelSpecGatesPtrOutput)
}

// The annotations which must present on a Deployable for it to be eligible for promotion.
func (o ChannelSpecGatesOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChannelSpecGates) map[string]string { return v.Annotations }).(pulumi.StringMapOutput)
}

// A label selector for selecting the Deployables.
func (o ChannelSpecGatesOutput) LabelSelector() ChannelSpecGatesLabelSelectorPtrOutput {
	return o.ApplyT(func(v ChannelSpecGates) *ChannelSpecGatesLabelSelector { return v.LabelSelector }).(ChannelSpecGatesLabelSelectorPtrOutput)
}

func (o ChannelSpecGatesOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChannelSpecGates) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ChannelSpecGatesPtrOutput struct{ *pulumi.OutputState }

func (ChannelSpecGatesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChannelSpecGates)(nil)).Elem()
}

func (o ChannelSpecGatesPtrOutput) ToChannelSpecGatesPtrOutput() ChannelSpecGatesPtrOutput {
	return o
}

func (o ChannelSpecGatesPtrOutput) ToChannelSpecGatesPtrOutputWithContext(ctx context.Context) ChannelSpecGatesPtrOutput {
	return o
}

func (o ChannelSpecGatesPtrOutput) Elem() ChannelSpecGatesOutput {
	return o.ApplyT(func(v *ChannelSpecGates) ChannelSpecGates { return *v }).(ChannelSpecGatesOutput)
}

// The annotations which must present on a Deployable for it to be eligible for promotion.
func (o ChannelSpecGatesPtrOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChannelSpecGates) map[string]string {
		if v == nil {
			return nil
		}
		return v.Annotations
	}).(pulumi.StringMapOutput)
}

// A label selector for selecting the Deployables.
func (o ChannelSpecGatesPtrOutput) LabelSelector() ChannelSpecGatesLabelSelectorPtrOutput {
	return o.ApplyT(func(v *ChannelSpecGates) *ChannelSpecGatesLabelSelector {
		if v == nil {
			return nil
		}
		return v.LabelSelector
	}).(ChannelSpecGatesLabelSelectorPtrOutput)
}

func (o ChannelSpecGatesPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChannelSpecGates) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// The annotations which must present on a Deployable for it to be eligible for promotion.
type ChannelSpecGatesAnnotations struct {
}

// ChannelSpecGatesAnnotationsInput is an input type that accepts ChannelSpecGatesAnnotationsArgs and ChannelSpecGatesAnnotationsOutput values.
// You can construct a concrete instance of `ChannelSpecGatesAnnotationsInput` via:
//
//          ChannelSpecGatesAnnotationsArgs{...}
type ChannelSpecGatesAnnotationsInput interface {
	pulumi.Input

	ToChannelSpecGatesAnnotationsOutput() ChannelSpecGatesAnnotationsOutput
	ToChannelSpecGatesAnnotationsOutputWithContext(context.Context) ChannelSpecGatesAnnotationsOutput
}

// The annotations which must present on a Deployable for it to be eligible for promotion.
type ChannelSpecGatesAnnotationsArgs struct {
}

func (ChannelSpecGatesAnnotationsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChannelSpecGatesAnnotations)(nil)).Elem()
}

func (i ChannelSpecGatesAnnotationsArgs) ToChannelSpecGatesAnnotationsOutput() ChannelSpecGatesAnnotationsOutput {
	return i.ToChannelSpecGatesAnnotationsOutputWithContext(context.Background())
}

func (i ChannelSpecGatesAnnotationsArgs) ToChannelSpecGatesAnnotationsOutputWithContext(ctx context.Context) ChannelSpecGatesAnnotationsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChannelSpecGatesAnnotationsOutput)
}

// The annotations which must present on a Deployable for it to be eligible for promotion.
type ChannelSpecGatesAnnotationsOutput struct{ *pulumi.OutputState }

func (ChannelSpecGatesAnnotationsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChannelSpecGatesAnnotations)(nil)).Elem()
}

func (o ChannelSpecGatesAnnotationsOutput) ToChannelSpecGatesAnnotationsOutput() ChannelSpecGatesAnnotationsOutput {
	return o
}

func (o ChannelSpecGatesAnnotationsOutput) ToChannelSpecGatesAnnotationsOutputWithContext(ctx context.Context) ChannelSpecGatesAnnotationsOutput {
	return o
}

// A label selector for selecting the Deployables.
type ChannelSpecGatesLabelSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChannelSpecGatesLabelSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChannelSpecGatesLabelSelectorInput is an input type that accepts ChannelSpecGatesLabelSelectorArgs and ChannelSpecGatesLabelSelectorOutput values.
// You can construct a concrete instance of `ChannelSpecGatesLabelSelectorInput` via:
//
//          ChannelSpecGatesLabelSelectorArgs{...}
type ChannelSpecGatesLabelSelectorInput interface {
	pulumi.Input

	ToChannelSpecGatesLabelSelectorOutput() ChannelSpecGatesLabelSelectorOutput
	ToChannelSpecGatesLabelSelectorOutputWithContext(context.Context) ChannelSpecGatesLabelSelectorOutput
}

// A label selector for selecting the Deployables.
type ChannelSpecGatesLabelSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChannelSpecGatesLabelSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChannelSpecGatesLabelSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChannelSpecGatesLabelSelector)(nil)).Elem()
}

func (i ChannelSpecGatesLabelSelectorArgs) ToChannelSpecGatesLabelSelectorOutput() ChannelSpecGatesLabelSelectorOutput {
	return i.ToChannelSpecGatesLabelSelectorOutputWithContext(context.Background())
}

func (i ChannelSpecGatesLabelSelectorArgs) ToChannelSpecGatesLabelSelectorOutputWithContext(ctx context.Context) ChannelSpecGatesLabelSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChannelSpecGatesLabelSelectorOutput)
}

func (i ChannelSpecGatesLabelSelectorArgs) ToChannelSpecGatesLabelSelectorPtrOutput() ChannelSpecGatesLabelSelectorPtrOutput {
	return i.ToChannelSpecGatesLabelSelectorPtrOutputWithContext(context.Background())
}

func (i ChannelSpecGatesLabelSelectorArgs) ToChannelSpecGatesLabelSelectorPtrOutputWithContext(ctx context.Context) ChannelSpecGatesLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChannelSpecGatesLabelSelectorOutput).ToChannelSpecGatesLabelSelectorPtrOutputWithContext(ctx)
}

// ChannelSpecGatesLabelSelectorPtrInput is an input type that accepts ChannelSpecGatesLabelSelectorArgs, ChannelSpecGatesLabelSelectorPtr and ChannelSpecGatesLabelSelectorPtrOutput values.
// You can construct a concrete instance of `ChannelSpecGatesLabelSelectorPtrInput` via:
//
//          ChannelSpecGatesLabelSelectorArgs{...}
//
//  or:
//
//          nil
type ChannelSpecGatesLabelSelectorPtrInput interface {
	pulumi.Input

	ToChannelSpecGatesLabelSelectorPtrOutput() ChannelSpecGatesLabelSelectorPtrOutput
	ToChannelSpecGatesLabelSelectorPtrOutputWithContext(context.Context) ChannelSpecGatesLabelSelectorPtrOutput
}

type channelSpecGatesLabelSelectorPtrType ChannelSpecGatesLabelSelectorArgs

func ChannelSpecGatesLabelSelectorPtr(v *ChannelSpecGatesLabelSelectorArgs) ChannelSpecGatesLabelSelectorPtrInput {
	return (*channelSpecGatesLabelSelectorPtrType)(v)
}

func (*channelSpecGatesLabelSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChannelSpecGatesLabelSelector)(nil)).Elem()
}

func (i *channelSpecGatesLabelSelectorPtrType) ToChannelSpecGatesLabelSelectorPtrOutput() ChannelSpecGatesLabelSelectorPtrOutput {
	return i.ToChannelSpecGatesLabelSelectorPtrOutputWithContext(context.Background())
}

func (i *channelSpecGatesLabelSelectorPtrType) ToChannelSpecGatesLabelSelectorPtrOutputWithContext(ctx context.Context) ChannelSpecGatesLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChannelSpecGatesLabelSelectorPtrOutput)
}

// A label selector for selecting the Deployables.
type ChannelSpecGatesLabelSelectorOutput struct{ *pulumi.OutputState }

func (ChannelSpecGatesLabelSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChannelSpecGatesLabelSelector)(nil)).Elem()
}

func (o ChannelSpecGatesLabelSelectorOutput) ToChannelSpecGatesLabelSelectorOutput() ChannelSpecGatesLabelSelectorOutput {
	return o
}

func (o ChannelSpecGatesLabelSelectorOutput) ToChannelSpecGatesLabelSelectorOutputWithContext(ctx context.Context) ChannelSpecGatesLabelSelectorOutput {
	return o
}

func (o ChannelSpecGatesLabelSelectorOutput) ToChannelSpecGatesLabelSelectorPtrOutput() ChannelSpecGatesLabelSelectorPtrOutput {
	return o.ToChannelSpecGatesLabelSelectorPtrOutputWithContext(context.Background())
}

func (o ChannelSpecGatesLabelSelectorOutput) ToChannelSpecGatesLabelSelectorPtrOutputWithContext(ctx context.Context) ChannelSpecGatesLabelSelectorPtrOutput {
	return o.ApplyT(func(v ChannelSpecGatesLabelSelector) *ChannelSpecGatesLabelSelector {
		return &v
	}).(ChannelSpecGatesLabelSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChannelSpecGatesLabelSelectorOutput) MatchExpressions() ChannelSpecGatesLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChannelSpecGatesLabelSelector) []ChannelSpecGatesLabelSelectorMatchExpressions {
		return v.MatchExpressions
	}).(ChannelSpecGatesLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChannelSpecGatesLabelSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChannelSpecGatesLabelSelector) map[string]string { return v.MatchLabels }).(pulumi.StringMapOutput)
}

type ChannelSpecGatesLabelSelectorPtrOutput struct{ *pulumi.OutputState }

func (ChannelSpecGatesLabelSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChannelSpecGatesLabelSelector)(nil)).Elem()
}

func (o ChannelSpecGatesLabelSelectorPtrOutput) ToChannelSpecGatesLabelSelectorPtrOutput() ChannelSpecGatesLabelSelectorPtrOutput {
	return o
}

func (o ChannelSpecGatesLabelSelectorPtrOutput) ToChannelSpecGatesLabelSelectorPtrOutputWithContext(ctx context.Context) ChannelSpecGatesLabelSelectorPtrOutput {
	return o
}

func (o ChannelSpecGatesLabelSelectorPtrOutput) Elem() ChannelSpecGatesLabelSelectorOutput {
	return o.ApplyT(func(v *ChannelSpecGatesLabelSelector) ChannelSpecGatesLabelSelector { return *v }).(ChannelSpecGatesLabelSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChannelSpecGatesLabelSelectorPtrOutput) MatchExpressions() ChannelSpecGatesLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *ChannelSpecGatesLabelSelector) []ChannelSpecGatesLabelSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChannelSpecGatesLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChannelSpecGatesLabelSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChannelSpecGatesLabelSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type ChannelSpecGatesLabelSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// ChannelSpecGatesLabelSelectorMatchExpressionsInput is an input type that accepts ChannelSpecGatesLabelSelectorMatchExpressionsArgs and ChannelSpecGatesLabelSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `ChannelSpecGatesLabelSelectorMatchExpressionsInput` via:
//
//          ChannelSpecGatesLabelSelectorMatchExpressionsArgs{...}
type ChannelSpecGatesLabelSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToChannelSpecGatesLabelSelectorMatchExpressionsOutput() ChannelSpecGatesLabelSelectorMatchExpressionsOutput
	ToChannelSpecGatesLabelSelectorMatchExpressionsOutputWithContext(context.Context) ChannelSpecGatesLabelSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type ChannelSpecGatesLabelSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChannelSpecGatesLabelSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChannelSpecGatesLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i ChannelSpecGatesLabelSelectorMatchExpressionsArgs) ToChannelSpecGatesLabelSelectorMatchExpressionsOutput() ChannelSpecGatesLabelSelectorMatchExpressionsOutput {
	return i.ToChannelSpecGatesLabelSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i ChannelSpecGatesLabelSelectorMatchExpressionsArgs) ToChannelSpecGatesLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChannelSpecGatesLabelSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChannelSpecGatesLabelSelectorMatchExpressionsOutput)
}

// ChannelSpecGatesLabelSelectorMatchExpressionsArrayInput is an input type that accepts ChannelSpecGatesLabelSelectorMatchExpressionsArray and ChannelSpecGatesLabelSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChannelSpecGatesLabelSelectorMatchExpressionsArrayInput` via:
//
//          ChannelSpecGatesLabelSelectorMatchExpressionsArray{ ChannelSpecGatesLabelSelectorMatchExpressionsArgs{...} }
type ChannelSpecGatesLabelSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChannelSpecGatesLabelSelectorMatchExpressionsArrayOutput() ChannelSpecGatesLabelSelectorMatchExpressionsArrayOutput
	ToChannelSpecGatesLabelSelectorMatchExpressionsArrayOutputWithContext(context.Context) ChannelSpecGatesLabelSelectorMatchExpressionsArrayOutput
}

type ChannelSpecGatesLabelSelectorMatchExpressionsArray []ChannelSpecGatesLabelSelectorMatchExpressionsInput

func (ChannelSpecGatesLabelSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChannelSpecGatesLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i ChannelSpecGatesLabelSelectorMatchExpressionsArray) ToChannelSpecGatesLabelSelectorMatchExpressionsArrayOutput() ChannelSpecGatesLabelSelectorMatchExpressionsArrayOutput {
	return i.ToChannelSpecGatesLabelSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChannelSpecGatesLabelSelectorMatchExpressionsArray) ToChannelSpecGatesLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChannelSpecGatesLabelSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChannelSpecGatesLabelSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type ChannelSpecGatesLabelSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChannelSpecGatesLabelSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChannelSpecGatesLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o ChannelSpecGatesLabelSelectorMatchExpressionsOutput) ToChannelSpecGatesLabelSelectorMatchExpressionsOutput() ChannelSpecGatesLabelSelectorMatchExpressionsOutput {
	return o
}

func (o ChannelSpecGatesLabelSelectorMatchExpressionsOutput) ToChannelSpecGatesLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChannelSpecGatesLabelSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChannelSpecGatesLabelSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChannelSpecGatesLabelSelectorMatchExpressions) string { return v.Key }).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChannelSpecGatesLabelSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChannelSpecGatesLabelSelectorMatchExpressions) string { return v.Operator }).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
func (o ChannelSpecGatesLabelSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChannelSpecGatesLabelSelectorMatchExpressions) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type ChannelSpecGatesLabelSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChannelSpecGatesLabelSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChannelSpecGatesLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o ChannelSpecGatesLabelSelectorMatchExpressionsArrayOutput) ToChannelSpecGatesLabelSelectorMatchExpressionsArrayOutput() ChannelSpecGatesLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChannelSpecGatesLabelSelectorMatchExpressionsArrayOutput) ToChannelSpecGatesLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChannelSpecGatesLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChannelSpecGatesLabelSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChannelSpecGatesLabelSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChannelSpecGatesLabelSelectorMatchExpressions {
		return vs[0].([]ChannelSpecGatesLabelSelectorMatchExpressions)[vs[1].(int)]
	}).(ChannelSpecGatesLabelSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type ChannelSpecGatesLabelSelectorMatchLabels struct {
}

// ChannelSpecGatesLabelSelectorMatchLabelsInput is an input type that accepts ChannelSpecGatesLabelSelectorMatchLabelsArgs and ChannelSpecGatesLabelSelectorMatchLabelsOutput values.
// You can construct a concrete instance of `ChannelSpecGatesLabelSelectorMatchLabelsInput` via:
//
//          ChannelSpecGatesLabelSelectorMatchLabelsArgs{...}
type ChannelSpecGatesLabelSelectorMatchLabelsInput interface {
	pulumi.Input

	ToChannelSpecGatesLabelSelectorMatchLabelsOutput() ChannelSpecGatesLabelSelectorMatchLabelsOutput
	ToChannelSpecGatesLabelSelectorMatchLabelsOutputWithContext(context.Context) ChannelSpecGatesLabelSelectorMatchLabelsOutput
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type ChannelSpecGatesLabelSelectorMatchLabelsArgs struct {
}

func (ChannelSpecGatesLabelSelectorMatchLabelsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChannelSpecGatesLabelSelectorMatchLabels)(nil)).Elem()
}

func (i ChannelSpecGatesLabelSelectorMatchLabelsArgs) ToChannelSpecGatesLabelSelectorMatchLabelsOutput() ChannelSpecGatesLabelSelectorMatchLabelsOutput {
	return i.ToChannelSpecGatesLabelSelectorMatchLabelsOutputWithContext(context.Background())
}

func (i ChannelSpecGatesLabelSelectorMatchLabelsArgs) ToChannelSpecGatesLabelSelectorMatchLabelsOutputWithContext(ctx context.Context) ChannelSpecGatesLabelSelectorMatchLabelsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChannelSpecGatesLabelSelectorMatchLabelsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type ChannelSpecGatesLabelSelectorMatchLabelsOutput struct{ *pulumi.OutputState }

func (ChannelSpecGatesLabelSelectorMatchLabelsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChannelSpecGatesLabelSelectorMatchLabels)(nil)).Elem()
}

func (o ChannelSpecGatesLabelSelectorMatchLabelsOutput) ToChannelSpecGatesLabelSelectorMatchLabelsOutput() ChannelSpecGatesLabelSelectorMatchLabelsOutput {
	return o
}

func (o ChannelSpecGatesLabelSelectorMatchLabelsOutput) ToChannelSpecGatesLabelSelectorMatchLabelsOutputWithContext(ctx context.Context) ChannelSpecGatesLabelSelectorMatchLabelsOutput {
	return o
}

// For a `github` channel or a `helmrepo` channel on github, this can be used to reference a Secret which contains the credentials for authentication, i.e. `user` and `accessToken`. For a `objectbucket` channel, this can be used to reference a Secret which contains the AWS credentials, i.e. `AccessKeyID` and `SecretAccessKey`.
type ChannelSpecSecretRef struct {
	// API version of the referent.
	ApiVersion *string `pulumi:"apiVersion"`
	// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
	FieldPath *string `pulumi:"fieldPath"`
	// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name *string `pulumi:"name"`
	// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
	Namespace *string `pulumi:"namespace"`
	// Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
	ResourceVersion *string `pulumi:"resourceVersion"`
	// UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
	Uid *string `pulumi:"uid"`
}

// ChannelSpecSecretRefInput is an input type that accepts ChannelSpecSecretRefArgs and ChannelSpecSecretRefOutput values.
// You can construct a concrete instance of `ChannelSpecSecretRefInput` via:
//
//          ChannelSpecSecretRefArgs{...}
type ChannelSpecSecretRefInput interface {
	pulumi.Input

	ToChannelSpecSecretRefOutput() ChannelSpecSecretRefOutput
	ToChannelSpecSecretRefOutputWithContext(context.Context) ChannelSpecSecretRefOutput
}

// For a `github` channel or a `helmrepo` channel on github, this can be used to reference a Secret which contains the credentials for authentication, i.e. `user` and `accessToken`. For a `objectbucket` channel, this can be used to reference a Secret which contains the AWS credentials, i.e. `AccessKeyID` and `SecretAccessKey`.
type ChannelSpecSecretRefArgs struct {
	// API version of the referent.
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
	FieldPath pulumi.StringPtrInput `pulumi:"fieldPath"`
	// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
	ResourceVersion pulumi.StringPtrInput `pulumi:"resourceVersion"`
	// UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
	Uid pulumi.StringPtrInput `pulumi:"uid"`
}

func (ChannelSpecSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChannelSpecSecretRef)(nil)).Elem()
}

func (i ChannelSpecSecretRefArgs) ToChannelSpecSecretRefOutput() ChannelSpecSecretRefOutput {
	return i.ToChannelSpecSecretRefOutputWithContext(context.Background())
}

func (i ChannelSpecSecretRefArgs) ToChannelSpecSecretRefOutputWithContext(ctx context.Context) ChannelSpecSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChannelSpecSecretRefOutput)
}

func (i ChannelSpecSecretRefArgs) ToChannelSpecSecretRefPtrOutput() ChannelSpecSecretRefPtrOutput {
	return i.ToChannelSpecSecretRefPtrOutputWithContext(context.Background())
}

func (i ChannelSpecSecretRefArgs) ToChannelSpecSecretRefPtrOutputWithContext(ctx context.Context) ChannelSpecSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChannelSpecSecretRefOutput).ToChannelSpecSecretRefPtrOutputWithContext(ctx)
}

// ChannelSpecSecretRefPtrInput is an input type that accepts ChannelSpecSecretRefArgs, ChannelSpecSecretRefPtr and ChannelSpecSecretRefPtrOutput values.
// You can construct a concrete instance of `ChannelSpecSecretRefPtrInput` via:
//
//          ChannelSpecSecretRefArgs{...}
//
//  or:
//
//          nil
type ChannelSpecSecretRefPtrInput interface {
	pulumi.Input

	ToChannelSpecSecretRefPtrOutput() ChannelSpecSecretRefPtrOutput
	ToChannelSpecSecretRefPtrOutputWithContext(context.Context) ChannelSpecSecretRefPtrOutput
}

type channelSpecSecretRefPtrType ChannelSpecSecretRefArgs

func ChannelSpecSecretRefPtr(v *ChannelSpecSecretRefArgs) ChannelSpecSecretRefPtrInput {
	return (*channelSpecSecretRefPtrType)(v)
}

func (*channelSpecSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChannelSpecSecretRef)(nil)).Elem()
}

func (i *channelSpecSecretRefPtrType) ToChannelSpecSecretRefPtrOutput() ChannelSpecSecretRefPtrOutput {
	return i.ToChannelSpecSecretRefPtrOutputWithContext(context.Background())
}

func (i *channelSpecSecretRefPtrType) ToChannelSpecSecretRefPtrOutputWithContext(ctx context.Context) ChannelSpecSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChannelSpecSecretRefPtrOutput)
}

// For a `github` channel or a `helmrepo` channel on github, this can be used to reference a Secret which contains the credentials for authentication, i.e. `user` and `accessToken`. For a `objectbucket` channel, this can be used to reference a Secret which contains the AWS credentials, i.e. `AccessKeyID` and `SecretAccessKey`.
type ChannelSpecSecretRefOutput struct{ *pulumi.OutputState }

func (ChannelSpecSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChannelSpecSecretRef)(nil)).Elem()
}

func (o ChannelSpecSecretRefOutput) ToChannelSpecSecretRefOutput() ChannelSpecSecretRefOutput {
	return o
}

func (o ChannelSpecSecretRefOutput) ToChannelSpecSecretRefOutputWithContext(ctx context.Context) ChannelSpecSecretRefOutput {
	return o
}

func (o ChannelSpecSecretRefOutput) ToChannelSpecSecretRefPtrOutput() ChannelSpecSecretRefPtrOutput {
	return o.ToChannelSpecSecretRefPtrOutputWithContext(context.Background())
}

func (o ChannelSpecSecretRefOutput) ToChannelSpecSecretRefPtrOutputWithContext(ctx context.Context) ChannelSpecSecretRefPtrOutput {
	return o.ApplyT(func(v ChannelSpecSecretRef) *ChannelSpecSecretRef {
		return &v
	}).(ChannelSpecSecretRefPtrOutput)
}

// API version of the referent.
func (o ChannelSpecSecretRefOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChannelSpecSecretRef) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
func (o ChannelSpecSecretRefOutput) FieldPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChannelSpecSecretRef) *string { return v.FieldPath }).(pulumi.StringPtrOutput)
}

// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ChannelSpecSecretRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChannelSpecSecretRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChannelSpecSecretRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChannelSpecSecretRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
func (o ChannelSpecSecretRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChannelSpecSecretRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
func (o ChannelSpecSecretRefOutput) ResourceVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChannelSpecSecretRef) *string { return v.ResourceVersion }).(pulumi.StringPtrOutput)
}

// UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
func (o ChannelSpecSecretRefOutput) Uid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChannelSpecSecretRef) *string { return v.Uid }).(pulumi.StringPtrOutput)
}

type ChannelSpecSecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChannelSpecSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChannelSpecSecretRef)(nil)).Elem()
}

func (o ChannelSpecSecretRefPtrOutput) ToChannelSpecSecretRefPtrOutput() ChannelSpecSecretRefPtrOutput {
	return o
}

func (o ChannelSpecSecretRefPtrOutput) ToChannelSpecSecretRefPtrOutputWithContext(ctx context.Context) ChannelSpecSecretRefPtrOutput {
	return o
}

func (o ChannelSpecSecretRefPtrOutput) Elem() ChannelSpecSecretRefOutput {
	return o.ApplyT(func(v *ChannelSpecSecretRef) ChannelSpecSecretRef { return *v }).(ChannelSpecSecretRefOutput)
}

// API version of the referent.
func (o ChannelSpecSecretRefPtrOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChannelSpecSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.ApiVersion
	}).(pulumi.StringPtrOutput)
}

// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
func (o ChannelSpecSecretRefPtrOutput) FieldPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChannelSpecSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.FieldPath
	}).(pulumi.StringPtrOutput)
}

// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o ChannelSpecSecretRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChannelSpecSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChannelSpecSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChannelSpecSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
func (o ChannelSpecSecretRefPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChannelSpecSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
func (o ChannelSpecSecretRefPtrOutput) ResourceVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChannelSpecSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.ResourceVersion
	}).(pulumi.StringPtrOutput)
}

// UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
func (o ChannelSpecSecretRefPtrOutput) Uid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChannelSpecSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Uid
	}).(pulumi.StringPtrOutput)
}

// The most recent observed status of the Channel.
type ChannelStatus struct {
}

// ChannelStatusInput is an input type that accepts ChannelStatusArgs and ChannelStatusOutput values.
// You can construct a concrete instance of `ChannelStatusInput` via:
//
//          ChannelStatusArgs{...}
type ChannelStatusInput interface {
	pulumi.Input

	ToChannelStatusOutput() ChannelStatusOutput
	ToChannelStatusOutputWithContext(context.Context) ChannelStatusOutput
}

// The most recent observed status of the Channel.
type ChannelStatusArgs struct {
}

func (ChannelStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChannelStatus)(nil)).Elem()
}

func (i ChannelStatusArgs) ToChannelStatusOutput() ChannelStatusOutput {
	return i.ToChannelStatusOutputWithContext(context.Background())
}

func (i ChannelStatusArgs) ToChannelStatusOutputWithContext(ctx context.Context) ChannelStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChannelStatusOutput)
}

// The most recent observed status of the Channel.
type ChannelStatusOutput struct{ *pulumi.OutputState }

func (ChannelStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChannelStatus)(nil)).Elem()
}

func (o ChannelStatusOutput) ToChannelStatusOutput() ChannelStatusOutput {
	return o
}

func (o ChannelStatusOutput) ToChannelStatusOutputWithContext(ctx context.Context) ChannelStatusOutput {
	return o
}

// Deployable is the Schema for the deployables API
type DeployableType struct {
	ApiVersion *string            `pulumi:"apiVersion"`
	Kind       *string            `pulumi:"kind"`
	Metadata   *metav1.ObjectMeta `pulumi:"metadata"`
	// DeployableSpec defines the desired state of Deployable
	Spec *DeployableSpec `pulumi:"spec"`
	// DeployableStatus defines the observed state of Deployable
	Status *DeployableStatus `pulumi:"status"`
}

// DeployableTypeInput is an input type that accepts DeployableTypeArgs and DeployableTypeOutput values.
// You can construct a concrete instance of `DeployableTypeInput` via:
//
//          DeployableTypeArgs{...}
type DeployableTypeInput interface {
	pulumi.Input

	ToDeployableTypeOutput() DeployableTypeOutput
	ToDeployableTypeOutputWithContext(context.Context) DeployableTypeOutput
}

// Deployable is the Schema for the deployables API
type DeployableTypeArgs struct {
	ApiVersion pulumi.StringPtrInput     `pulumi:"apiVersion"`
	Kind       pulumi.StringPtrInput     `pulumi:"kind"`
	Metadata   metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	// DeployableSpec defines the desired state of Deployable
	Spec DeployableSpecPtrInput `pulumi:"spec"`
	// DeployableStatus defines the observed state of Deployable
	Status DeployableStatusPtrInput `pulumi:"status"`
}

func (DeployableTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeployableType)(nil)).Elem()
}

func (i DeployableTypeArgs) ToDeployableTypeOutput() DeployableTypeOutput {
	return i.ToDeployableTypeOutputWithContext(context.Background())
}

func (i DeployableTypeArgs) ToDeployableTypeOutputWithContext(ctx context.Context) DeployableTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeployableTypeOutput)
}

// Deployable is the Schema for the deployables API
type DeployableTypeOutput struct{ *pulumi.OutputState }

func (DeployableTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeployableType)(nil)).Elem()
}

func (o DeployableTypeOutput) ToDeployableTypeOutput() DeployableTypeOutput {
	return o
}

func (o DeployableTypeOutput) ToDeployableTypeOutputWithContext(ctx context.Context) DeployableTypeOutput {
	return o
}

func (o DeployableTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeployableType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

func (o DeployableTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeployableType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

func (o DeployableTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v DeployableType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

// DeployableSpec defines the desired state of Deployable
func (o DeployableTypeOutput) Spec() DeployableSpecPtrOutput {
	return o.ApplyT(func(v DeployableType) *DeployableSpec { return v.Spec }).(DeployableSpecPtrOutput)
}

// DeployableStatus defines the observed state of Deployable
func (o DeployableTypeOutput) Status() DeployableStatusPtrOutput {
	return o.ApplyT(func(v DeployableType) *DeployableStatus { return v.Status }).(DeployableStatusPtrOutput)
}

type DeployableMetadata struct {
}

// DeployableMetadataInput is an input type that accepts DeployableMetadataArgs and DeployableMetadataOutput values.
// You can construct a concrete instance of `DeployableMetadataInput` via:
//
//          DeployableMetadataArgs{...}
type DeployableMetadataInput interface {
	pulumi.Input

	ToDeployableMetadataOutput() DeployableMetadataOutput
	ToDeployableMetadataOutputWithContext(context.Context) DeployableMetadataOutput
}

type DeployableMetadataArgs struct {
}

func (DeployableMetadataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeployableMetadata)(nil)).Elem()
}

func (i DeployableMetadataArgs) ToDeployableMetadataOutput() DeployableMetadataOutput {
	return i.ToDeployableMetadataOutputWithContext(context.Background())
}

func (i DeployableMetadataArgs) ToDeployableMetadataOutputWithContext(ctx context.Context) DeployableMetadataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeployableMetadataOutput)
}

type DeployableMetadataOutput struct{ *pulumi.OutputState }

func (DeployableMetadataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeployableMetadata)(nil)).Elem()
}

func (o DeployableMetadataOutput) ToDeployableMetadataOutput() DeployableMetadataOutput {
	return o
}

func (o DeployableMetadataOutput) ToDeployableMetadataOutputWithContext(ctx context.Context) DeployableMetadataOutput {
	return o
}

// DeployableSpec defines the desired state of Deployable
type DeployableSpec struct {
	Channels     []string                     `pulumi:"channels"`
	Dependencies []DeployableSpecDependencies `pulumi:"dependencies"`
	Overrides    []DeployableSpecOverrides    `pulumi:"overrides"`
	// Placement field to be referenced in specs, align with Fedv2, add placementref
	Placement *DeployableSpecPlacement `pulumi:"placement"`
	Template  map[string]interface{}   `pulumi:"template"`
}

// DeployableSpecInput is an input type that accepts DeployableSpecArgs and DeployableSpecOutput values.
// You can construct a concrete instance of `DeployableSpecInput` via:
//
//          DeployableSpecArgs{...}
type DeployableSpecInput interface {
	pulumi.Input

	ToDeployableSpecOutput() DeployableSpecOutput
	ToDeployableSpecOutputWithContext(context.Context) DeployableSpecOutput
}

// DeployableSpec defines the desired state of Deployable
type DeployableSpecArgs struct {
	Channels     pulumi.StringArrayInput              `pulumi:"channels"`
	Dependencies DeployableSpecDependenciesArrayInput `pulumi:"dependencies"`
	Overrides    DeployableSpecOverridesArrayInput    `pulumi:"overrides"`
	// Placement field to be referenced in specs, align with Fedv2, add placementref
	Placement DeployableSpecPlacementPtrInput `pulumi:"placement"`
	Template  pulumi.MapInput                 `pulumi:"template"`
}

func (DeployableSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeployableSpec)(nil)).Elem()
}

func (i DeployableSpecArgs) ToDeployableSpecOutput() DeployableSpecOutput {
	return i.ToDeployableSpecOutputWithContext(context.Background())
}

func (i DeployableSpecArgs) ToDeployableSpecOutputWithContext(ctx context.Context) DeployableSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeployableSpecOutput)
}

func (i DeployableSpecArgs) ToDeployableSpecPtrOutput() DeployableSpecPtrOutput {
	return i.ToDeployableSpecPtrOutputWithContext(context.Background())
}

func (i DeployableSpecArgs) ToDeployableSpecPtrOutputWithContext(ctx context.Context) DeployableSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeployableSpecOutput).ToDeployableSpecPtrOutputWithContext(ctx)
}

// DeployableSpecPtrInput is an input type that accepts DeployableSpecArgs, DeployableSpecPtr and DeployableSpecPtrOutput values.
// You can construct a concrete instance of `DeployableSpecPtrInput` via:
//
//          DeployableSpecArgs{...}
//
//  or:
//
//          nil
type DeployableSpecPtrInput interface {
	pulumi.Input

	ToDeployableSpecPtrOutput() DeployableSpecPtrOutput
	ToDeployableSpecPtrOutputWithContext(context.Context) DeployableSpecPtrOutput
}

type deployableSpecPtrType DeployableSpecArgs

func DeployableSpecPtr(v *DeployableSpecArgs) DeployableSpecPtrInput {
	return (*deployableSpecPtrType)(v)
}

func (*deployableSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DeployableSpec)(nil)).Elem()
}

func (i *deployableSpecPtrType) ToDeployableSpecPtrOutput() DeployableSpecPtrOutput {
	return i.ToDeployableSpecPtrOutputWithContext(context.Background())
}

func (i *deployableSpecPtrType) ToDeployableSpecPtrOutputWithContext(ctx context.Context) DeployableSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeployableSpecPtrOutput)
}

// DeployableSpec defines the desired state of Deployable
type DeployableSpecOutput struct{ *pulumi.OutputState }

func (DeployableSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeployableSpec)(nil)).Elem()
}

func (o DeployableSpecOutput) ToDeployableSpecOutput() DeployableSpecOutput {
	return o
}

func (o DeployableSpecOutput) ToDeployableSpecOutputWithContext(ctx context.Context) DeployableSpecOutput {
	return o
}

func (o DeployableSpecOutput) ToDeployableSpecPtrOutput() DeployableSpecPtrOutput {
	return o.ToDeployableSpecPtrOutputWithContext(context.Background())
}

func (o DeployableSpecOutput) ToDeployableSpecPtrOutputWithContext(ctx context.Context) DeployableSpecPtrOutput {
	return o.ApplyT(func(v DeployableSpec) *DeployableSpec {
		return &v
	}).(DeployableSpecPtrOutput)
}
func (o DeployableSpecOutput) Channels() pulumi.StringArrayOutput {
	return o.ApplyT(func(v DeployableSpec) []string { return v.Channels }).(pulumi.StringArrayOutput)
}

func (o DeployableSpecOutput) Dependencies() DeployableSpecDependenciesArrayOutput {
	return o.ApplyT(func(v DeployableSpec) []DeployableSpecDependencies { return v.Dependencies }).(DeployableSpecDependenciesArrayOutput)
}

func (o DeployableSpecOutput) Overrides() DeployableSpecOverridesArrayOutput {
	return o.ApplyT(func(v DeployableSpec) []DeployableSpecOverrides { return v.Overrides }).(DeployableSpecOverridesArrayOutput)
}

// Placement field to be referenced in specs, align with Fedv2, add placementref
func (o DeployableSpecOutput) Placement() DeployableSpecPlacementPtrOutput {
	return o.ApplyT(func(v DeployableSpec) *DeployableSpecPlacement { return v.Placement }).(DeployableSpecPlacementPtrOutput)
}

func (o DeployableSpecOutput) Template() pulumi.MapOutput {
	return o.ApplyT(func(v DeployableSpec) map[string]interface{} { return v.Template }).(pulumi.MapOutput)
}

type DeployableSpecPtrOutput struct{ *pulumi.OutputState }

func (DeployableSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DeployableSpec)(nil)).Elem()
}

func (o DeployableSpecPtrOutput) ToDeployableSpecPtrOutput() DeployableSpecPtrOutput {
	return o
}

func (o DeployableSpecPtrOutput) ToDeployableSpecPtrOutputWithContext(ctx context.Context) DeployableSpecPtrOutput {
	return o
}

func (o DeployableSpecPtrOutput) Elem() DeployableSpecOutput {
	return o.ApplyT(func(v *DeployableSpec) DeployableSpec { return *v }).(DeployableSpecOutput)
}

func (o DeployableSpecPtrOutput) Channels() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *DeployableSpec) []string {
		if v == nil {
			return nil
		}
		return v.Channels
	}).(pulumi.StringArrayOutput)
}

func (o DeployableSpecPtrOutput) Dependencies() DeployableSpecDependenciesArrayOutput {
	return o.ApplyT(func(v *DeployableSpec) []DeployableSpecDependencies {
		if v == nil {
			return nil
		}
		return v.Dependencies
	}).(DeployableSpecDependenciesArrayOutput)
}

func (o DeployableSpecPtrOutput) Overrides() DeployableSpecOverridesArrayOutput {
	return o.ApplyT(func(v *DeployableSpec) []DeployableSpecOverrides {
		if v == nil {
			return nil
		}
		return v.Overrides
	}).(DeployableSpecOverridesArrayOutput)
}

// Placement field to be referenced in specs, align with Fedv2, add placementref
func (o DeployableSpecPtrOutput) Placement() DeployableSpecPlacementPtrOutput {
	return o.ApplyT(func(v *DeployableSpec) *DeployableSpecPlacement {
		if v == nil {
			return nil
		}
		return v.Placement
	}).(DeployableSpecPlacementPtrOutput)
}

func (o DeployableSpecPtrOutput) Template() pulumi.MapOutput {
	return o.ApplyT(func(v *DeployableSpec) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.Template
	}).(pulumi.MapOutput)
}

// Dependency of Deployable Properties field is the flexiblity for different Kind
type DeployableSpecDependencies struct {
	Annotations map[string]string `pulumi:"annotations"`
	// API version of the referent.
	ApiVersion *string `pulumi:"apiVersion"`
	// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
	FieldPath *string `pulumi:"fieldPath"`
	// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
	Kind   *string           `pulumi:"kind"`
	Labels map[string]string `pulumi:"labels"`
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name *string `pulumi:"name"`
	// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
	Namespace *string `pulumi:"namespace"`
	// Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
	ResourceVersion *string `pulumi:"resourceVersion"`
	// UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
	Uid *string `pulumi:"uid"`
}

// DeployableSpecDependenciesInput is an input type that accepts DeployableSpecDependenciesArgs and DeployableSpecDependenciesOutput values.
// You can construct a concrete instance of `DeployableSpecDependenciesInput` via:
//
//          DeployableSpecDependenciesArgs{...}
type DeployableSpecDependenciesInput interface {
	pulumi.Input

	ToDeployableSpecDependenciesOutput() DeployableSpecDependenciesOutput
	ToDeployableSpecDependenciesOutputWithContext(context.Context) DeployableSpecDependenciesOutput
}

// Dependency of Deployable Properties field is the flexiblity for different Kind
type DeployableSpecDependenciesArgs struct {
	Annotations pulumi.StringMapInput `pulumi:"annotations"`
	// API version of the referent.
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
	FieldPath pulumi.StringPtrInput `pulumi:"fieldPath"`
	// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
	Kind   pulumi.StringPtrInput `pulumi:"kind"`
	Labels pulumi.StringMapInput `pulumi:"labels"`
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
	ResourceVersion pulumi.StringPtrInput `pulumi:"resourceVersion"`
	// UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
	Uid pulumi.StringPtrInput `pulumi:"uid"`
}

func (DeployableSpecDependenciesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeployableSpecDependencies)(nil)).Elem()
}

func (i DeployableSpecDependenciesArgs) ToDeployableSpecDependenciesOutput() DeployableSpecDependenciesOutput {
	return i.ToDeployableSpecDependenciesOutputWithContext(context.Background())
}

func (i DeployableSpecDependenciesArgs) ToDeployableSpecDependenciesOutputWithContext(ctx context.Context) DeployableSpecDependenciesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeployableSpecDependenciesOutput)
}

// DeployableSpecDependenciesArrayInput is an input type that accepts DeployableSpecDependenciesArray and DeployableSpecDependenciesArrayOutput values.
// You can construct a concrete instance of `DeployableSpecDependenciesArrayInput` via:
//
//          DeployableSpecDependenciesArray{ DeployableSpecDependenciesArgs{...} }
type DeployableSpecDependenciesArrayInput interface {
	pulumi.Input

	ToDeployableSpecDependenciesArrayOutput() DeployableSpecDependenciesArrayOutput
	ToDeployableSpecDependenciesArrayOutputWithContext(context.Context) DeployableSpecDependenciesArrayOutput
}

type DeployableSpecDependenciesArray []DeployableSpecDependenciesInput

func (DeployableSpecDependenciesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeployableSpecDependencies)(nil)).Elem()
}

func (i DeployableSpecDependenciesArray) ToDeployableSpecDependenciesArrayOutput() DeployableSpecDependenciesArrayOutput {
	return i.ToDeployableSpecDependenciesArrayOutputWithContext(context.Background())
}

func (i DeployableSpecDependenciesArray) ToDeployableSpecDependenciesArrayOutputWithContext(ctx context.Context) DeployableSpecDependenciesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeployableSpecDependenciesArrayOutput)
}

// Dependency of Deployable Properties field is the flexiblity for different Kind
type DeployableSpecDependenciesOutput struct{ *pulumi.OutputState }

func (DeployableSpecDependenciesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeployableSpecDependencies)(nil)).Elem()
}

func (o DeployableSpecDependenciesOutput) ToDeployableSpecDependenciesOutput() DeployableSpecDependenciesOutput {
	return o
}

func (o DeployableSpecDependenciesOutput) ToDeployableSpecDependenciesOutputWithContext(ctx context.Context) DeployableSpecDependenciesOutput {
	return o
}

func (o DeployableSpecDependenciesOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v DeployableSpecDependencies) map[string]string { return v.Annotations }).(pulumi.StringMapOutput)
}

// API version of the referent.
func (o DeployableSpecDependenciesOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeployableSpecDependencies) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
func (o DeployableSpecDependenciesOutput) FieldPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeployableSpecDependencies) *string { return v.FieldPath }).(pulumi.StringPtrOutput)
}

// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
func (o DeployableSpecDependenciesOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeployableSpecDependencies) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

func (o DeployableSpecDependenciesOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v DeployableSpecDependencies) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o DeployableSpecDependenciesOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeployableSpecDependencies) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
func (o DeployableSpecDependenciesOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeployableSpecDependencies) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
func (o DeployableSpecDependenciesOutput) ResourceVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeployableSpecDependencies) *string { return v.ResourceVersion }).(pulumi.StringPtrOutput)
}

// UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
func (o DeployableSpecDependenciesOutput) Uid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeployableSpecDependencies) *string { return v.Uid }).(pulumi.StringPtrOutput)
}

type DeployableSpecDependenciesArrayOutput struct{ *pulumi.OutputState }

func (DeployableSpecDependenciesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeployableSpecDependencies)(nil)).Elem()
}

func (o DeployableSpecDependenciesArrayOutput) ToDeployableSpecDependenciesArrayOutput() DeployableSpecDependenciesArrayOutput {
	return o
}

func (o DeployableSpecDependenciesArrayOutput) ToDeployableSpecDependenciesArrayOutputWithContext(ctx context.Context) DeployableSpecDependenciesArrayOutput {
	return o
}

func (o DeployableSpecDependenciesArrayOutput) Index(i pulumi.IntInput) DeployableSpecDependenciesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeployableSpecDependencies {
		return vs[0].([]DeployableSpecDependencies)[vs[1].(int)]
	}).(DeployableSpecDependenciesOutput)
}

type DeployableSpecDependenciesAnnotations struct {
}

// DeployableSpecDependenciesAnnotationsInput is an input type that accepts DeployableSpecDependenciesAnnotationsArgs and DeployableSpecDependenciesAnnotationsOutput values.
// You can construct a concrete instance of `DeployableSpecDependenciesAnnotationsInput` via:
//
//          DeployableSpecDependenciesAnnotationsArgs{...}
type DeployableSpecDependenciesAnnotationsInput interface {
	pulumi.Input

	ToDeployableSpecDependenciesAnnotationsOutput() DeployableSpecDependenciesAnnotationsOutput
	ToDeployableSpecDependenciesAnnotationsOutputWithContext(context.Context) DeployableSpecDependenciesAnnotationsOutput
}

type DeployableSpecDependenciesAnnotationsArgs struct {
}

func (DeployableSpecDependenciesAnnotationsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeployableSpecDependenciesAnnotations)(nil)).Elem()
}

func (i DeployableSpecDependenciesAnnotationsArgs) ToDeployableSpecDependenciesAnnotationsOutput() DeployableSpecDependenciesAnnotationsOutput {
	return i.ToDeployableSpecDependenciesAnnotationsOutputWithContext(context.Background())
}

func (i DeployableSpecDependenciesAnnotationsArgs) ToDeployableSpecDependenciesAnnotationsOutputWithContext(ctx context.Context) DeployableSpecDependenciesAnnotationsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeployableSpecDependenciesAnnotationsOutput)
}

type DeployableSpecDependenciesAnnotationsOutput struct{ *pulumi.OutputState }

func (DeployableSpecDependenciesAnnotationsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeployableSpecDependenciesAnnotations)(nil)).Elem()
}

func (o DeployableSpecDependenciesAnnotationsOutput) ToDeployableSpecDependenciesAnnotationsOutput() DeployableSpecDependenciesAnnotationsOutput {
	return o
}

func (o DeployableSpecDependenciesAnnotationsOutput) ToDeployableSpecDependenciesAnnotationsOutputWithContext(ctx context.Context) DeployableSpecDependenciesAnnotationsOutput {
	return o
}

type DeployableSpecDependenciesLabels struct {
}

// DeployableSpecDependenciesLabelsInput is an input type that accepts DeployableSpecDependenciesLabelsArgs and DeployableSpecDependenciesLabelsOutput values.
// You can construct a concrete instance of `DeployableSpecDependenciesLabelsInput` via:
//
//          DeployableSpecDependenciesLabelsArgs{...}
type DeployableSpecDependenciesLabelsInput interface {
	pulumi.Input

	ToDeployableSpecDependenciesLabelsOutput() DeployableSpecDependenciesLabelsOutput
	ToDeployableSpecDependenciesLabelsOutputWithContext(context.Context) DeployableSpecDependenciesLabelsOutput
}

type DeployableSpecDependenciesLabelsArgs struct {
}

func (DeployableSpecDependenciesLabelsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeployableSpecDependenciesLabels)(nil)).Elem()
}

func (i DeployableSpecDependenciesLabelsArgs) ToDeployableSpecDependenciesLabelsOutput() DeployableSpecDependenciesLabelsOutput {
	return i.ToDeployableSpecDependenciesLabelsOutputWithContext(context.Background())
}

func (i DeployableSpecDependenciesLabelsArgs) ToDeployableSpecDependenciesLabelsOutputWithContext(ctx context.Context) DeployableSpecDependenciesLabelsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeployableSpecDependenciesLabelsOutput)
}

type DeployableSpecDependenciesLabelsOutput struct{ *pulumi.OutputState }

func (DeployableSpecDependenciesLabelsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeployableSpecDependenciesLabels)(nil)).Elem()
}

func (o DeployableSpecDependenciesLabelsOutput) ToDeployableSpecDependenciesLabelsOutput() DeployableSpecDependenciesLabelsOutput {
	return o
}

func (o DeployableSpecDependenciesLabelsOutput) ToDeployableSpecDependenciesLabelsOutputWithContext(ctx context.Context) DeployableSpecDependenciesLabelsOutput {
	return o
}

// Overrides field in deployable
type DeployableSpecOverrides struct {
	ClusterName      string                   `pulumi:"clusterName"`
	ClusterOverrides []map[string]interface{} `pulumi:"clusterOverrides"`
}

// DeployableSpecOverridesInput is an input type that accepts DeployableSpecOverridesArgs and DeployableSpecOverridesOutput values.
// You can construct a concrete instance of `DeployableSpecOverridesInput` via:
//
//          DeployableSpecOverridesArgs{...}
type DeployableSpecOverridesInput interface {
	pulumi.Input

	ToDeployableSpecOverridesOutput() DeployableSpecOverridesOutput
	ToDeployableSpecOverridesOutputWithContext(context.Context) DeployableSpecOverridesOutput
}

// Overrides field in deployable
type DeployableSpecOverridesArgs struct {
	ClusterName      pulumi.StringInput   `pulumi:"clusterName"`
	ClusterOverrides pulumi.MapArrayInput `pulumi:"clusterOverrides"`
}

func (DeployableSpecOverridesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeployableSpecOverrides)(nil)).Elem()
}

func (i DeployableSpecOverridesArgs) ToDeployableSpecOverridesOutput() DeployableSpecOverridesOutput {
	return i.ToDeployableSpecOverridesOutputWithContext(context.Background())
}

func (i DeployableSpecOverridesArgs) ToDeployableSpecOverridesOutputWithContext(ctx context.Context) DeployableSpecOverridesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeployableSpecOverridesOutput)
}

// DeployableSpecOverridesArrayInput is an input type that accepts DeployableSpecOverridesArray and DeployableSpecOverridesArrayOutput values.
// You can construct a concrete instance of `DeployableSpecOverridesArrayInput` via:
//
//          DeployableSpecOverridesArray{ DeployableSpecOverridesArgs{...} }
type DeployableSpecOverridesArrayInput interface {
	pulumi.Input

	ToDeployableSpecOverridesArrayOutput() DeployableSpecOverridesArrayOutput
	ToDeployableSpecOverridesArrayOutputWithContext(context.Context) DeployableSpecOverridesArrayOutput
}

type DeployableSpecOverridesArray []DeployableSpecOverridesInput

func (DeployableSpecOverridesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeployableSpecOverrides)(nil)).Elem()
}

func (i DeployableSpecOverridesArray) ToDeployableSpecOverridesArrayOutput() DeployableSpecOverridesArrayOutput {
	return i.ToDeployableSpecOverridesArrayOutputWithContext(context.Background())
}

func (i DeployableSpecOverridesArray) ToDeployableSpecOverridesArrayOutputWithContext(ctx context.Context) DeployableSpecOverridesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeployableSpecOverridesArrayOutput)
}

// Overrides field in deployable
type DeployableSpecOverridesOutput struct{ *pulumi.OutputState }

func (DeployableSpecOverridesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeployableSpecOverrides)(nil)).Elem()
}

func (o DeployableSpecOverridesOutput) ToDeployableSpecOverridesOutput() DeployableSpecOverridesOutput {
	return o
}

func (o DeployableSpecOverridesOutput) ToDeployableSpecOverridesOutputWithContext(ctx context.Context) DeployableSpecOverridesOutput {
	return o
}

func (o DeployableSpecOverridesOutput) ClusterName() pulumi.StringOutput {
	return o.ApplyT(func(v DeployableSpecOverrides) string { return v.ClusterName }).(pulumi.StringOutput)
}

func (o DeployableSpecOverridesOutput) ClusterOverrides() pulumi.MapArrayOutput {
	return o.ApplyT(func(v DeployableSpecOverrides) []map[string]interface{} { return v.ClusterOverrides }).(pulumi.MapArrayOutput)
}

type DeployableSpecOverridesArrayOutput struct{ *pulumi.OutputState }

func (DeployableSpecOverridesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeployableSpecOverrides)(nil)).Elem()
}

func (o DeployableSpecOverridesArrayOutput) ToDeployableSpecOverridesArrayOutput() DeployableSpecOverridesArrayOutput {
	return o
}

func (o DeployableSpecOverridesArrayOutput) ToDeployableSpecOverridesArrayOutputWithContext(ctx context.Context) DeployableSpecOverridesArrayOutput {
	return o
}

func (o DeployableSpecOverridesArrayOutput) Index(i pulumi.IntInput) DeployableSpecOverridesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeployableSpecOverrides {
		return vs[0].([]DeployableSpecOverrides)[vs[1].(int)]
	}).(DeployableSpecOverridesOutput)
}

// ClusterOverride describes rules for override
type DeployableSpecOverridesClusterOverrides struct {
}

// DeployableSpecOverridesClusterOverridesInput is an input type that accepts DeployableSpecOverridesClusterOverridesArgs and DeployableSpecOverridesClusterOverridesOutput values.
// You can construct a concrete instance of `DeployableSpecOverridesClusterOverridesInput` via:
//
//          DeployableSpecOverridesClusterOverridesArgs{...}
type DeployableSpecOverridesClusterOverridesInput interface {
	pulumi.Input

	ToDeployableSpecOverridesClusterOverridesOutput() DeployableSpecOverridesClusterOverridesOutput
	ToDeployableSpecOverridesClusterOverridesOutputWithContext(context.Context) DeployableSpecOverridesClusterOverridesOutput
}

// ClusterOverride describes rules for override
type DeployableSpecOverridesClusterOverridesArgs struct {
}

func (DeployableSpecOverridesClusterOverridesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeployableSpecOverridesClusterOverrides)(nil)).Elem()
}

func (i DeployableSpecOverridesClusterOverridesArgs) ToDeployableSpecOverridesClusterOverridesOutput() DeployableSpecOverridesClusterOverridesOutput {
	return i.ToDeployableSpecOverridesClusterOverridesOutputWithContext(context.Background())
}

func (i DeployableSpecOverridesClusterOverridesArgs) ToDeployableSpecOverridesClusterOverridesOutputWithContext(ctx context.Context) DeployableSpecOverridesClusterOverridesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeployableSpecOverridesClusterOverridesOutput)
}

// ClusterOverride describes rules for override
type DeployableSpecOverridesClusterOverridesOutput struct{ *pulumi.OutputState }

func (DeployableSpecOverridesClusterOverridesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeployableSpecOverridesClusterOverrides)(nil)).Elem()
}

func (o DeployableSpecOverridesClusterOverridesOutput) ToDeployableSpecOverridesClusterOverridesOutput() DeployableSpecOverridesClusterOverridesOutput {
	return o
}

func (o DeployableSpecOverridesClusterOverridesOutput) ToDeployableSpecOverridesClusterOverridesOutputWithContext(ctx context.Context) DeployableSpecOverridesClusterOverridesOutput {
	return o
}

// Placement field to be referenced in specs, align with Fedv2, add placementref
type DeployableSpecPlacement struct {
	// A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
	ClusterSelector *DeployableSpecPlacementClusterSelector `pulumi:"clusterSelector"`
	Clusters        []DeployableSpecPlacementClusters       `pulumi:"clusters"`
	Local           *bool                                   `pulumi:"local"`
	// ObjectReference contains enough information to let you inspect or modify the referred object.
	PlacementRef *DeployableSpecPlacementPlacementRef `pulumi:"placementRef"`
}

// DeployableSpecPlacementInput is an input type that accepts DeployableSpecPlacementArgs and DeployableSpecPlacementOutput values.
// You can construct a concrete instance of `DeployableSpecPlacementInput` via:
//
//          DeployableSpecPlacementArgs{...}
type DeployableSpecPlacementInput interface {
	pulumi.Input

	ToDeployableSpecPlacementOutput() DeployableSpecPlacementOutput
	ToDeployableSpecPlacementOutputWithContext(context.Context) DeployableSpecPlacementOutput
}

// Placement field to be referenced in specs, align with Fedv2, add placementref
type DeployableSpecPlacementArgs struct {
	// A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
	ClusterSelector DeployableSpecPlacementClusterSelectorPtrInput `pulumi:"clusterSelector"`
	Clusters        DeployableSpecPlacementClustersArrayInput      `pulumi:"clusters"`
	Local           pulumi.BoolPtrInput                            `pulumi:"local"`
	// ObjectReference contains enough information to let you inspect or modify the referred object.
	PlacementRef DeployableSpecPlacementPlacementRefPtrInput `pulumi:"placementRef"`
}

func (DeployableSpecPlacementArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeployableSpecPlacement)(nil)).Elem()
}

func (i DeployableSpecPlacementArgs) ToDeployableSpecPlacementOutput() DeployableSpecPlacementOutput {
	return i.ToDeployableSpecPlacementOutputWithContext(context.Background())
}

func (i DeployableSpecPlacementArgs) ToDeployableSpecPlacementOutputWithContext(ctx context.Context) DeployableSpecPlacementOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeployableSpecPlacementOutput)
}

func (i DeployableSpecPlacementArgs) ToDeployableSpecPlacementPtrOutput() DeployableSpecPlacementPtrOutput {
	return i.ToDeployableSpecPlacementPtrOutputWithContext(context.Background())
}

func (i DeployableSpecPlacementArgs) ToDeployableSpecPlacementPtrOutputWithContext(ctx context.Context) DeployableSpecPlacementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeployableSpecPlacementOutput).ToDeployableSpecPlacementPtrOutputWithContext(ctx)
}

// DeployableSpecPlacementPtrInput is an input type that accepts DeployableSpecPlacementArgs, DeployableSpecPlacementPtr and DeployableSpecPlacementPtrOutput values.
// You can construct a concrete instance of `DeployableSpecPlacementPtrInput` via:
//
//          DeployableSpecPlacementArgs{...}
//
//  or:
//
//          nil
type DeployableSpecPlacementPtrInput interface {
	pulumi.Input

	ToDeployableSpecPlacementPtrOutput() DeployableSpecPlacementPtrOutput
	ToDeployableSpecPlacementPtrOutputWithContext(context.Context) DeployableSpecPlacementPtrOutput
}

type deployableSpecPlacementPtrType DeployableSpecPlacementArgs

func DeployableSpecPlacementPtr(v *DeployableSpecPlacementArgs) DeployableSpecPlacementPtrInput {
	return (*deployableSpecPlacementPtrType)(v)
}

func (*deployableSpecPlacementPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DeployableSpecPlacement)(nil)).Elem()
}

func (i *deployableSpecPlacementPtrType) ToDeployableSpecPlacementPtrOutput() DeployableSpecPlacementPtrOutput {
	return i.ToDeployableSpecPlacementPtrOutputWithContext(context.Background())
}

func (i *deployableSpecPlacementPtrType) ToDeployableSpecPlacementPtrOutputWithContext(ctx context.Context) DeployableSpecPlacementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeployableSpecPlacementPtrOutput)
}

// Placement field to be referenced in specs, align with Fedv2, add placementref
type DeployableSpecPlacementOutput struct{ *pulumi.OutputState }

func (DeployableSpecPlacementOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeployableSpecPlacement)(nil)).Elem()
}

func (o DeployableSpecPlacementOutput) ToDeployableSpecPlacementOutput() DeployableSpecPlacementOutput {
	return o
}

func (o DeployableSpecPlacementOutput) ToDeployableSpecPlacementOutputWithContext(ctx context.Context) DeployableSpecPlacementOutput {
	return o
}

func (o DeployableSpecPlacementOutput) ToDeployableSpecPlacementPtrOutput() DeployableSpecPlacementPtrOutput {
	return o.ToDeployableSpecPlacementPtrOutputWithContext(context.Background())
}

func (o DeployableSpecPlacementOutput) ToDeployableSpecPlacementPtrOutputWithContext(ctx context.Context) DeployableSpecPlacementPtrOutput {
	return o.ApplyT(func(v DeployableSpecPlacement) *DeployableSpecPlacement {
		return &v
	}).(DeployableSpecPlacementPtrOutput)
}

// A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
func (o DeployableSpecPlacementOutput) ClusterSelector() DeployableSpecPlacementClusterSelectorPtrOutput {
	return o.ApplyT(func(v DeployableSpecPlacement) *DeployableSpecPlacementClusterSelector { return v.ClusterSelector }).(DeployableSpecPlacementClusterSelectorPtrOutput)
}

func (o DeployableSpecPlacementOutput) Clusters() DeployableSpecPlacementClustersArrayOutput {
	return o.ApplyT(func(v DeployableSpecPlacement) []DeployableSpecPlacementClusters { return v.Clusters }).(DeployableSpecPlacementClustersArrayOutput)
}

func (o DeployableSpecPlacementOutput) Local() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v DeployableSpecPlacement) *bool { return v.Local }).(pulumi.BoolPtrOutput)
}

// ObjectReference contains enough information to let you inspect or modify the referred object.
func (o DeployableSpecPlacementOutput) PlacementRef() DeployableSpecPlacementPlacementRefPtrOutput {
	return o.ApplyT(func(v DeployableSpecPlacement) *DeployableSpecPlacementPlacementRef { return v.PlacementRef }).(DeployableSpecPlacementPlacementRefPtrOutput)
}

type DeployableSpecPlacementPtrOutput struct{ *pulumi.OutputState }

func (DeployableSpecPlacementPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DeployableSpecPlacement)(nil)).Elem()
}

func (o DeployableSpecPlacementPtrOutput) ToDeployableSpecPlacementPtrOutput() DeployableSpecPlacementPtrOutput {
	return o
}

func (o DeployableSpecPlacementPtrOutput) ToDeployableSpecPlacementPtrOutputWithContext(ctx context.Context) DeployableSpecPlacementPtrOutput {
	return o
}

func (o DeployableSpecPlacementPtrOutput) Elem() DeployableSpecPlacementOutput {
	return o.ApplyT(func(v *DeployableSpecPlacement) DeployableSpecPlacement { return *v }).(DeployableSpecPlacementOutput)
}

// A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
func (o DeployableSpecPlacementPtrOutput) ClusterSelector() DeployableSpecPlacementClusterSelectorPtrOutput {
	return o.ApplyT(func(v *DeployableSpecPlacement) *DeployableSpecPlacementClusterSelector {
		if v == nil {
			return nil
		}
		return v.ClusterSelector
	}).(DeployableSpecPlacementClusterSelectorPtrOutput)
}

func (o DeployableSpecPlacementPtrOutput) Clusters() DeployableSpecPlacementClustersArrayOutput {
	return o.ApplyT(func(v *DeployableSpecPlacement) []DeployableSpecPlacementClusters {
		if v == nil {
			return nil
		}
		return v.Clusters
	}).(DeployableSpecPlacementClustersArrayOutput)
}

func (o DeployableSpecPlacementPtrOutput) Local() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *DeployableSpecPlacement) *bool {
		if v == nil {
			return nil
		}
		return v.Local
	}).(pulumi.BoolPtrOutput)
}

// ObjectReference contains enough information to let you inspect or modify the referred object.
func (o DeployableSpecPlacementPtrOutput) PlacementRef() DeployableSpecPlacementPlacementRefPtrOutput {
	return o.ApplyT(func(v *DeployableSpecPlacement) *DeployableSpecPlacementPlacementRef {
		if v == nil {
			return nil
		}
		return v.PlacementRef
	}).(DeployableSpecPlacementPlacementRefPtrOutput)
}

// A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
type DeployableSpecPlacementClusterSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []DeployableSpecPlacementClusterSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// DeployableSpecPlacementClusterSelectorInput is an input type that accepts DeployableSpecPlacementClusterSelectorArgs and DeployableSpecPlacementClusterSelectorOutput values.
// You can construct a concrete instance of `DeployableSpecPlacementClusterSelectorInput` via:
//
//          DeployableSpecPlacementClusterSelectorArgs{...}
type DeployableSpecPlacementClusterSelectorInput interface {
	pulumi.Input

	ToDeployableSpecPlacementClusterSelectorOutput() DeployableSpecPlacementClusterSelectorOutput
	ToDeployableSpecPlacementClusterSelectorOutputWithContext(context.Context) DeployableSpecPlacementClusterSelectorOutput
}

// A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
type DeployableSpecPlacementClusterSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions DeployableSpecPlacementClusterSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (DeployableSpecPlacementClusterSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeployableSpecPlacementClusterSelector)(nil)).Elem()
}

func (i DeployableSpecPlacementClusterSelectorArgs) ToDeployableSpecPlacementClusterSelectorOutput() DeployableSpecPlacementClusterSelectorOutput {
	return i.ToDeployableSpecPlacementClusterSelectorOutputWithContext(context.Background())
}

func (i DeployableSpecPlacementClusterSelectorArgs) ToDeployableSpecPlacementClusterSelectorOutputWithContext(ctx context.Context) DeployableSpecPlacementClusterSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeployableSpecPlacementClusterSelectorOutput)
}

func (i DeployableSpecPlacementClusterSelectorArgs) ToDeployableSpecPlacementClusterSelectorPtrOutput() DeployableSpecPlacementClusterSelectorPtrOutput {
	return i.ToDeployableSpecPlacementClusterSelectorPtrOutputWithContext(context.Background())
}

func (i DeployableSpecPlacementClusterSelectorArgs) ToDeployableSpecPlacementClusterSelectorPtrOutputWithContext(ctx context.Context) DeployableSpecPlacementClusterSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeployableSpecPlacementClusterSelectorOutput).ToDeployableSpecPlacementClusterSelectorPtrOutputWithContext(ctx)
}

// DeployableSpecPlacementClusterSelectorPtrInput is an input type that accepts DeployableSpecPlacementClusterSelectorArgs, DeployableSpecPlacementClusterSelectorPtr and DeployableSpecPlacementClusterSelectorPtrOutput values.
// You can construct a concrete instance of `DeployableSpecPlacementClusterSelectorPtrInput` via:
//
//          DeployableSpecPlacementClusterSelectorArgs{...}
//
//  or:
//
//          nil
type DeployableSpecPlacementClusterSelectorPtrInput interface {
	pulumi.Input

	ToDeployableSpecPlacementClusterSelectorPtrOutput() DeployableSpecPlacementClusterSelectorPtrOutput
	ToDeployableSpecPlacementClusterSelectorPtrOutputWithContext(context.Context) DeployableSpecPlacementClusterSelectorPtrOutput
}

type deployableSpecPlacementClusterSelectorPtrType DeployableSpecPlacementClusterSelectorArgs

func DeployableSpecPlacementClusterSelectorPtr(v *DeployableSpecPlacementClusterSelectorArgs) DeployableSpecPlacementClusterSelectorPtrInput {
	return (*deployableSpecPlacementClusterSelectorPtrType)(v)
}

func (*deployableSpecPlacementClusterSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DeployableSpecPlacementClusterSelector)(nil)).Elem()
}

func (i *deployableSpecPlacementClusterSelectorPtrType) ToDeployableSpecPlacementClusterSelectorPtrOutput() DeployableSpecPlacementClusterSelectorPtrOutput {
	return i.ToDeployableSpecPlacementClusterSelectorPtrOutputWithContext(context.Background())
}

func (i *deployableSpecPlacementClusterSelectorPtrType) ToDeployableSpecPlacementClusterSelectorPtrOutputWithContext(ctx context.Context) DeployableSpecPlacementClusterSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeployableSpecPlacementClusterSelectorPtrOutput)
}

// A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
type DeployableSpecPlacementClusterSelectorOutput struct{ *pulumi.OutputState }

func (DeployableSpecPlacementClusterSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeployableSpecPlacementClusterSelector)(nil)).Elem()
}

func (o DeployableSpecPlacementClusterSelectorOutput) ToDeployableSpecPlacementClusterSelectorOutput() DeployableSpecPlacementClusterSelectorOutput {
	return o
}

func (o DeployableSpecPlacementClusterSelectorOutput) ToDeployableSpecPlacementClusterSelectorOutputWithContext(ctx context.Context) DeployableSpecPlacementClusterSelectorOutput {
	return o
}

func (o DeployableSpecPlacementClusterSelectorOutput) ToDeployableSpecPlacementClusterSelectorPtrOutput() DeployableSpecPlacementClusterSelectorPtrOutput {
	return o.ToDeployableSpecPlacementClusterSelectorPtrOutputWithContext(context.Background())
}

func (o DeployableSpecPlacementClusterSelectorOutput) ToDeployableSpecPlacementClusterSelectorPtrOutputWithContext(ctx context.Context) DeployableSpecPlacementClusterSelectorPtrOutput {
	return o.ApplyT(func(v DeployableSpecPlacementClusterSelector) *DeployableSpecPlacementClusterSelector {
		return &v
	}).(DeployableSpecPlacementClusterSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o DeployableSpecPlacementClusterSelectorOutput) MatchExpressions() DeployableSpecPlacementClusterSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v DeployableSpecPlacementClusterSelector) []DeployableSpecPlacementClusterSelectorMatchExpressions {
		return v.MatchExpressions
	}).(DeployableSpecPlacementClusterSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o DeployableSpecPlacementClusterSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v DeployableSpecPlacementClusterSelector) map[string]string { return v.MatchLabels }).(pulumi.StringMapOutput)
}

type DeployableSpecPlacementClusterSelectorPtrOutput struct{ *pulumi.OutputState }

func (DeployableSpecPlacementClusterSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DeployableSpecPlacementClusterSelector)(nil)).Elem()
}

func (o DeployableSpecPlacementClusterSelectorPtrOutput) ToDeployableSpecPlacementClusterSelectorPtrOutput() DeployableSpecPlacementClusterSelectorPtrOutput {
	return o
}

func (o DeployableSpecPlacementClusterSelectorPtrOutput) ToDeployableSpecPlacementClusterSelectorPtrOutputWithContext(ctx context.Context) DeployableSpecPlacementClusterSelectorPtrOutput {
	return o
}

func (o DeployableSpecPlacementClusterSelectorPtrOutput) Elem() DeployableSpecPlacementClusterSelectorOutput {
	return o.ApplyT(func(v *DeployableSpecPlacementClusterSelector) DeployableSpecPlacementClusterSelector { return *v }).(DeployableSpecPlacementClusterSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o DeployableSpecPlacementClusterSelectorPtrOutput) MatchExpressions() DeployableSpecPlacementClusterSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *DeployableSpecPlacementClusterSelector) []DeployableSpecPlacementClusterSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(DeployableSpecPlacementClusterSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o DeployableSpecPlacementClusterSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *DeployableSpecPlacementClusterSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type DeployableSpecPlacementClusterSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// DeployableSpecPlacementClusterSelectorMatchExpressionsInput is an input type that accepts DeployableSpecPlacementClusterSelectorMatchExpressionsArgs and DeployableSpecPlacementClusterSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `DeployableSpecPlacementClusterSelectorMatchExpressionsInput` via:
//
//          DeployableSpecPlacementClusterSelectorMatchExpressionsArgs{...}
type DeployableSpecPlacementClusterSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToDeployableSpecPlacementClusterSelectorMatchExpressionsOutput() DeployableSpecPlacementClusterSelectorMatchExpressionsOutput
	ToDeployableSpecPlacementClusterSelectorMatchExpressionsOutputWithContext(context.Context) DeployableSpecPlacementClusterSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type DeployableSpecPlacementClusterSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (DeployableSpecPlacementClusterSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeployableSpecPlacementClusterSelectorMatchExpressions)(nil)).Elem()
}

func (i DeployableSpecPlacementClusterSelectorMatchExpressionsArgs) ToDeployableSpecPlacementClusterSelectorMatchExpressionsOutput() DeployableSpecPlacementClusterSelectorMatchExpressionsOutput {
	return i.ToDeployableSpecPlacementClusterSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i DeployableSpecPlacementClusterSelectorMatchExpressionsArgs) ToDeployableSpecPlacementClusterSelectorMatchExpressionsOutputWithContext(ctx context.Context) DeployableSpecPlacementClusterSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeployableSpecPlacementClusterSelectorMatchExpressionsOutput)
}

// DeployableSpecPlacementClusterSelectorMatchExpressionsArrayInput is an input type that accepts DeployableSpecPlacementClusterSelectorMatchExpressionsArray and DeployableSpecPlacementClusterSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `DeployableSpecPlacementClusterSelectorMatchExpressionsArrayInput` via:
//
//          DeployableSpecPlacementClusterSelectorMatchExpressionsArray{ DeployableSpecPlacementClusterSelectorMatchExpressionsArgs{...} }
type DeployableSpecPlacementClusterSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToDeployableSpecPlacementClusterSelectorMatchExpressionsArrayOutput() DeployableSpecPlacementClusterSelectorMatchExpressionsArrayOutput
	ToDeployableSpecPlacementClusterSelectorMatchExpressionsArrayOutputWithContext(context.Context) DeployableSpecPlacementClusterSelectorMatchExpressionsArrayOutput
}

type DeployableSpecPlacementClusterSelectorMatchExpressionsArray []DeployableSpecPlacementClusterSelectorMatchExpressionsInput

func (DeployableSpecPlacementClusterSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeployableSpecPlacementClusterSelectorMatchExpressions)(nil)).Elem()
}

func (i DeployableSpecPlacementClusterSelectorMatchExpressionsArray) ToDeployableSpecPlacementClusterSelectorMatchExpressionsArrayOutput() DeployableSpecPlacementClusterSelectorMatchExpressionsArrayOutput {
	return i.ToDeployableSpecPlacementClusterSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i DeployableSpecPlacementClusterSelectorMatchExpressionsArray) ToDeployableSpecPlacementClusterSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) DeployableSpecPlacementClusterSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeployableSpecPlacementClusterSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type DeployableSpecPlacementClusterSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (DeployableSpecPlacementClusterSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeployableSpecPlacementClusterSelectorMatchExpressions)(nil)).Elem()
}

func (o DeployableSpecPlacementClusterSelectorMatchExpressionsOutput) ToDeployableSpecPlacementClusterSelectorMatchExpressionsOutput() DeployableSpecPlacementClusterSelectorMatchExpressionsOutput {
	return o
}

func (o DeployableSpecPlacementClusterSelectorMatchExpressionsOutput) ToDeployableSpecPlacementClusterSelectorMatchExpressionsOutputWithContext(ctx context.Context) DeployableSpecPlacementClusterSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o DeployableSpecPlacementClusterSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v DeployableSpecPlacementClusterSelectorMatchExpressions) string { return v.Key }).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
func (o DeployableSpecPlacementClusterSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v DeployableSpecPlacementClusterSelectorMatchExpressions) string { return v.Operator }).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
func (o DeployableSpecPlacementClusterSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v DeployableSpecPlacementClusterSelectorMatchExpressions) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type DeployableSpecPlacementClusterSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (DeployableSpecPlacementClusterSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeployableSpecPlacementClusterSelectorMatchExpressions)(nil)).Elem()
}

func (o DeployableSpecPlacementClusterSelectorMatchExpressionsArrayOutput) ToDeployableSpecPlacementClusterSelectorMatchExpressionsArrayOutput() DeployableSpecPlacementClusterSelectorMatchExpressionsArrayOutput {
	return o
}

func (o DeployableSpecPlacementClusterSelectorMatchExpressionsArrayOutput) ToDeployableSpecPlacementClusterSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) DeployableSpecPlacementClusterSelectorMatchExpressionsArrayOutput {
	return o
}

func (o DeployableSpecPlacementClusterSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) DeployableSpecPlacementClusterSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeployableSpecPlacementClusterSelectorMatchExpressions {
		return vs[0].([]DeployableSpecPlacementClusterSelectorMatchExpressions)[vs[1].(int)]
	}).(DeployableSpecPlacementClusterSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type DeployableSpecPlacementClusterSelectorMatchLabels struct {
}

// DeployableSpecPlacementClusterSelectorMatchLabelsInput is an input type that accepts DeployableSpecPlacementClusterSelectorMatchLabelsArgs and DeployableSpecPlacementClusterSelectorMatchLabelsOutput values.
// You can construct a concrete instance of `DeployableSpecPlacementClusterSelectorMatchLabelsInput` via:
//
//          DeployableSpecPlacementClusterSelectorMatchLabelsArgs{...}
type DeployableSpecPlacementClusterSelectorMatchLabelsInput interface {
	pulumi.Input

	ToDeployableSpecPlacementClusterSelectorMatchLabelsOutput() DeployableSpecPlacementClusterSelectorMatchLabelsOutput
	ToDeployableSpecPlacementClusterSelectorMatchLabelsOutputWithContext(context.Context) DeployableSpecPlacementClusterSelectorMatchLabelsOutput
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type DeployableSpecPlacementClusterSelectorMatchLabelsArgs struct {
}

func (DeployableSpecPlacementClusterSelectorMatchLabelsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeployableSpecPlacementClusterSelectorMatchLabels)(nil)).Elem()
}

func (i DeployableSpecPlacementClusterSelectorMatchLabelsArgs) ToDeployableSpecPlacementClusterSelectorMatchLabelsOutput() DeployableSpecPlacementClusterSelectorMatchLabelsOutput {
	return i.ToDeployableSpecPlacementClusterSelectorMatchLabelsOutputWithContext(context.Background())
}

func (i DeployableSpecPlacementClusterSelectorMatchLabelsArgs) ToDeployableSpecPlacementClusterSelectorMatchLabelsOutputWithContext(ctx context.Context) DeployableSpecPlacementClusterSelectorMatchLabelsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeployableSpecPlacementClusterSelectorMatchLabelsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type DeployableSpecPlacementClusterSelectorMatchLabelsOutput struct{ *pulumi.OutputState }

func (DeployableSpecPlacementClusterSelectorMatchLabelsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeployableSpecPlacementClusterSelectorMatchLabels)(nil)).Elem()
}

func (o DeployableSpecPlacementClusterSelectorMatchLabelsOutput) ToDeployableSpecPlacementClusterSelectorMatchLabelsOutput() DeployableSpecPlacementClusterSelectorMatchLabelsOutput {
	return o
}

func (o DeployableSpecPlacementClusterSelectorMatchLabelsOutput) ToDeployableSpecPlacementClusterSelectorMatchLabelsOutputWithContext(ctx context.Context) DeployableSpecPlacementClusterSelectorMatchLabelsOutput {
	return o
}

// GenericClusterReference - in alignment with kubefed
type DeployableSpecPlacementClusters struct {
	Name string `pulumi:"name"`
}

// DeployableSpecPlacementClustersInput is an input type that accepts DeployableSpecPlacementClustersArgs and DeployableSpecPlacementClustersOutput values.
// You can construct a concrete instance of `DeployableSpecPlacementClustersInput` via:
//
//          DeployableSpecPlacementClustersArgs{...}
type DeployableSpecPlacementClustersInput interface {
	pulumi.Input

	ToDeployableSpecPlacementClustersOutput() DeployableSpecPlacementClustersOutput
	ToDeployableSpecPlacementClustersOutputWithContext(context.Context) DeployableSpecPlacementClustersOutput
}

// GenericClusterReference - in alignment with kubefed
type DeployableSpecPlacementClustersArgs struct {
	Name pulumi.StringInput `pulumi:"name"`
}

func (DeployableSpecPlacementClustersArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeployableSpecPlacementClusters)(nil)).Elem()
}

func (i DeployableSpecPlacementClustersArgs) ToDeployableSpecPlacementClustersOutput() DeployableSpecPlacementClustersOutput {
	return i.ToDeployableSpecPlacementClustersOutputWithContext(context.Background())
}

func (i DeployableSpecPlacementClustersArgs) ToDeployableSpecPlacementClustersOutputWithContext(ctx context.Context) DeployableSpecPlacementClustersOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeployableSpecPlacementClustersOutput)
}

// DeployableSpecPlacementClustersArrayInput is an input type that accepts DeployableSpecPlacementClustersArray and DeployableSpecPlacementClustersArrayOutput values.
// You can construct a concrete instance of `DeployableSpecPlacementClustersArrayInput` via:
//
//          DeployableSpecPlacementClustersArray{ DeployableSpecPlacementClustersArgs{...} }
type DeployableSpecPlacementClustersArrayInput interface {
	pulumi.Input

	ToDeployableSpecPlacementClustersArrayOutput() DeployableSpecPlacementClustersArrayOutput
	ToDeployableSpecPlacementClustersArrayOutputWithContext(context.Context) DeployableSpecPlacementClustersArrayOutput
}

type DeployableSpecPlacementClustersArray []DeployableSpecPlacementClustersInput

func (DeployableSpecPlacementClustersArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeployableSpecPlacementClusters)(nil)).Elem()
}

func (i DeployableSpecPlacementClustersArray) ToDeployableSpecPlacementClustersArrayOutput() DeployableSpecPlacementClustersArrayOutput {
	return i.ToDeployableSpecPlacementClustersArrayOutputWithContext(context.Background())
}

func (i DeployableSpecPlacementClustersArray) ToDeployableSpecPlacementClustersArrayOutputWithContext(ctx context.Context) DeployableSpecPlacementClustersArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeployableSpecPlacementClustersArrayOutput)
}

// GenericClusterReference - in alignment with kubefed
type DeployableSpecPlacementClustersOutput struct{ *pulumi.OutputState }

func (DeployableSpecPlacementClustersOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeployableSpecPlacementClusters)(nil)).Elem()
}

func (o DeployableSpecPlacementClustersOutput) ToDeployableSpecPlacementClustersOutput() DeployableSpecPlacementClustersOutput {
	return o
}

func (o DeployableSpecPlacementClustersOutput) ToDeployableSpecPlacementClustersOutputWithContext(ctx context.Context) DeployableSpecPlacementClustersOutput {
	return o
}

func (o DeployableSpecPlacementClustersOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v DeployableSpecPlacementClusters) string { return v.Name }).(pulumi.StringOutput)
}

type DeployableSpecPlacementClustersArrayOutput struct{ *pulumi.OutputState }

func (DeployableSpecPlacementClustersArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DeployableSpecPlacementClusters)(nil)).Elem()
}

func (o DeployableSpecPlacementClustersArrayOutput) ToDeployableSpecPlacementClustersArrayOutput() DeployableSpecPlacementClustersArrayOutput {
	return o
}

func (o DeployableSpecPlacementClustersArrayOutput) ToDeployableSpecPlacementClustersArrayOutputWithContext(ctx context.Context) DeployableSpecPlacementClustersArrayOutput {
	return o
}

func (o DeployableSpecPlacementClustersArrayOutput) Index(i pulumi.IntInput) DeployableSpecPlacementClustersOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DeployableSpecPlacementClusters {
		return vs[0].([]DeployableSpecPlacementClusters)[vs[1].(int)]
	}).(DeployableSpecPlacementClustersOutput)
}

// ObjectReference contains enough information to let you inspect or modify the referred object.
type DeployableSpecPlacementPlacementRef struct {
	// API version of the referent.
	ApiVersion *string `pulumi:"apiVersion"`
	// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
	FieldPath *string `pulumi:"fieldPath"`
	// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name *string `pulumi:"name"`
	// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
	Namespace *string `pulumi:"namespace"`
	// Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
	ResourceVersion *string `pulumi:"resourceVersion"`
	// UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
	Uid *string `pulumi:"uid"`
}

// DeployableSpecPlacementPlacementRefInput is an input type that accepts DeployableSpecPlacementPlacementRefArgs and DeployableSpecPlacementPlacementRefOutput values.
// You can construct a concrete instance of `DeployableSpecPlacementPlacementRefInput` via:
//
//          DeployableSpecPlacementPlacementRefArgs{...}
type DeployableSpecPlacementPlacementRefInput interface {
	pulumi.Input

	ToDeployableSpecPlacementPlacementRefOutput() DeployableSpecPlacementPlacementRefOutput
	ToDeployableSpecPlacementPlacementRefOutputWithContext(context.Context) DeployableSpecPlacementPlacementRefOutput
}

// ObjectReference contains enough information to let you inspect or modify the referred object.
type DeployableSpecPlacementPlacementRefArgs struct {
	// API version of the referent.
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
	FieldPath pulumi.StringPtrInput `pulumi:"fieldPath"`
	// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
	ResourceVersion pulumi.StringPtrInput `pulumi:"resourceVersion"`
	// UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
	Uid pulumi.StringPtrInput `pulumi:"uid"`
}

func (DeployableSpecPlacementPlacementRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeployableSpecPlacementPlacementRef)(nil)).Elem()
}

func (i DeployableSpecPlacementPlacementRefArgs) ToDeployableSpecPlacementPlacementRefOutput() DeployableSpecPlacementPlacementRefOutput {
	return i.ToDeployableSpecPlacementPlacementRefOutputWithContext(context.Background())
}

func (i DeployableSpecPlacementPlacementRefArgs) ToDeployableSpecPlacementPlacementRefOutputWithContext(ctx context.Context) DeployableSpecPlacementPlacementRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeployableSpecPlacementPlacementRefOutput)
}

func (i DeployableSpecPlacementPlacementRefArgs) ToDeployableSpecPlacementPlacementRefPtrOutput() DeployableSpecPlacementPlacementRefPtrOutput {
	return i.ToDeployableSpecPlacementPlacementRefPtrOutputWithContext(context.Background())
}

func (i DeployableSpecPlacementPlacementRefArgs) ToDeployableSpecPlacementPlacementRefPtrOutputWithContext(ctx context.Context) DeployableSpecPlacementPlacementRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeployableSpecPlacementPlacementRefOutput).ToDeployableSpecPlacementPlacementRefPtrOutputWithContext(ctx)
}

// DeployableSpecPlacementPlacementRefPtrInput is an input type that accepts DeployableSpecPlacementPlacementRefArgs, DeployableSpecPlacementPlacementRefPtr and DeployableSpecPlacementPlacementRefPtrOutput values.
// You can construct a concrete instance of `DeployableSpecPlacementPlacementRefPtrInput` via:
//
//          DeployableSpecPlacementPlacementRefArgs{...}
//
//  or:
//
//          nil
type DeployableSpecPlacementPlacementRefPtrInput interface {
	pulumi.Input

	ToDeployableSpecPlacementPlacementRefPtrOutput() DeployableSpecPlacementPlacementRefPtrOutput
	ToDeployableSpecPlacementPlacementRefPtrOutputWithContext(context.Context) DeployableSpecPlacementPlacementRefPtrOutput
}

type deployableSpecPlacementPlacementRefPtrType DeployableSpecPlacementPlacementRefArgs

func DeployableSpecPlacementPlacementRefPtr(v *DeployableSpecPlacementPlacementRefArgs) DeployableSpecPlacementPlacementRefPtrInput {
	return (*deployableSpecPlacementPlacementRefPtrType)(v)
}

func (*deployableSpecPlacementPlacementRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DeployableSpecPlacementPlacementRef)(nil)).Elem()
}

func (i *deployableSpecPlacementPlacementRefPtrType) ToDeployableSpecPlacementPlacementRefPtrOutput() DeployableSpecPlacementPlacementRefPtrOutput {
	return i.ToDeployableSpecPlacementPlacementRefPtrOutputWithContext(context.Background())
}

func (i *deployableSpecPlacementPlacementRefPtrType) ToDeployableSpecPlacementPlacementRefPtrOutputWithContext(ctx context.Context) DeployableSpecPlacementPlacementRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeployableSpecPlacementPlacementRefPtrOutput)
}

// ObjectReference contains enough information to let you inspect or modify the referred object.
type DeployableSpecPlacementPlacementRefOutput struct{ *pulumi.OutputState }

func (DeployableSpecPlacementPlacementRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeployableSpecPlacementPlacementRef)(nil)).Elem()
}

func (o DeployableSpecPlacementPlacementRefOutput) ToDeployableSpecPlacementPlacementRefOutput() DeployableSpecPlacementPlacementRefOutput {
	return o
}

func (o DeployableSpecPlacementPlacementRefOutput) ToDeployableSpecPlacementPlacementRefOutputWithContext(ctx context.Context) DeployableSpecPlacementPlacementRefOutput {
	return o
}

func (o DeployableSpecPlacementPlacementRefOutput) ToDeployableSpecPlacementPlacementRefPtrOutput() DeployableSpecPlacementPlacementRefPtrOutput {
	return o.ToDeployableSpecPlacementPlacementRefPtrOutputWithContext(context.Background())
}

func (o DeployableSpecPlacementPlacementRefOutput) ToDeployableSpecPlacementPlacementRefPtrOutputWithContext(ctx context.Context) DeployableSpecPlacementPlacementRefPtrOutput {
	return o.ApplyT(func(v DeployableSpecPlacementPlacementRef) *DeployableSpecPlacementPlacementRef {
		return &v
	}).(DeployableSpecPlacementPlacementRefPtrOutput)
}

// API version of the referent.
func (o DeployableSpecPlacementPlacementRefOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeployableSpecPlacementPlacementRef) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
func (o DeployableSpecPlacementPlacementRefOutput) FieldPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeployableSpecPlacementPlacementRef) *string { return v.FieldPath }).(pulumi.StringPtrOutput)
}

// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
func (o DeployableSpecPlacementPlacementRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeployableSpecPlacementPlacementRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o DeployableSpecPlacementPlacementRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeployableSpecPlacementPlacementRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
func (o DeployableSpecPlacementPlacementRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeployableSpecPlacementPlacementRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
func (o DeployableSpecPlacementPlacementRefOutput) ResourceVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeployableSpecPlacementPlacementRef) *string { return v.ResourceVersion }).(pulumi.StringPtrOutput)
}

// UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
func (o DeployableSpecPlacementPlacementRefOutput) Uid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DeployableSpecPlacementPlacementRef) *string { return v.Uid }).(pulumi.StringPtrOutput)
}

type DeployableSpecPlacementPlacementRefPtrOutput struct{ *pulumi.OutputState }

func (DeployableSpecPlacementPlacementRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DeployableSpecPlacementPlacementRef)(nil)).Elem()
}

func (o DeployableSpecPlacementPlacementRefPtrOutput) ToDeployableSpecPlacementPlacementRefPtrOutput() DeployableSpecPlacementPlacementRefPtrOutput {
	return o
}

func (o DeployableSpecPlacementPlacementRefPtrOutput) ToDeployableSpecPlacementPlacementRefPtrOutputWithContext(ctx context.Context) DeployableSpecPlacementPlacementRefPtrOutput {
	return o
}

func (o DeployableSpecPlacementPlacementRefPtrOutput) Elem() DeployableSpecPlacementPlacementRefOutput {
	return o.ApplyT(func(v *DeployableSpecPlacementPlacementRef) DeployableSpecPlacementPlacementRef { return *v }).(DeployableSpecPlacementPlacementRefOutput)
}

// API version of the referent.
func (o DeployableSpecPlacementPlacementRefPtrOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DeployableSpecPlacementPlacementRef) *string {
		if v == nil {
			return nil
		}
		return v.ApiVersion
	}).(pulumi.StringPtrOutput)
}

// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
func (o DeployableSpecPlacementPlacementRefPtrOutput) FieldPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DeployableSpecPlacementPlacementRef) *string {
		if v == nil {
			return nil
		}
		return v.FieldPath
	}).(pulumi.StringPtrOutput)
}

// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
func (o DeployableSpecPlacementPlacementRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DeployableSpecPlacementPlacementRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o DeployableSpecPlacementPlacementRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DeployableSpecPlacementPlacementRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
func (o DeployableSpecPlacementPlacementRefPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DeployableSpecPlacementPlacementRef) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
func (o DeployableSpecPlacementPlacementRefPtrOutput) ResourceVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DeployableSpecPlacementPlacementRef) *string {
		if v == nil {
			return nil
		}
		return v.ResourceVersion
	}).(pulumi.StringPtrOutput)
}

// UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
func (o DeployableSpecPlacementPlacementRefPtrOutput) Uid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DeployableSpecPlacementPlacementRef) *string {
		if v == nil {
			return nil
		}
		return v.Uid
	}).(pulumi.StringPtrOutput)
}

type DeployableSpecTemplate struct {
}

// DeployableSpecTemplateInput is an input type that accepts DeployableSpecTemplateArgs and DeployableSpecTemplateOutput values.
// You can construct a concrete instance of `DeployableSpecTemplateInput` via:
//
//          DeployableSpecTemplateArgs{...}
type DeployableSpecTemplateInput interface {
	pulumi.Input

	ToDeployableSpecTemplateOutput() DeployableSpecTemplateOutput
	ToDeployableSpecTemplateOutputWithContext(context.Context) DeployableSpecTemplateOutput
}

type DeployableSpecTemplateArgs struct {
}

func (DeployableSpecTemplateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeployableSpecTemplate)(nil)).Elem()
}

func (i DeployableSpecTemplateArgs) ToDeployableSpecTemplateOutput() DeployableSpecTemplateOutput {
	return i.ToDeployableSpecTemplateOutputWithContext(context.Background())
}

func (i DeployableSpecTemplateArgs) ToDeployableSpecTemplateOutputWithContext(ctx context.Context) DeployableSpecTemplateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeployableSpecTemplateOutput)
}

type DeployableSpecTemplateOutput struct{ *pulumi.OutputState }

func (DeployableSpecTemplateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeployableSpecTemplate)(nil)).Elem()
}

func (o DeployableSpecTemplateOutput) ToDeployableSpecTemplateOutput() DeployableSpecTemplateOutput {
	return o
}

func (o DeployableSpecTemplateOutput) ToDeployableSpecTemplateOutputWithContext(ctx context.Context) DeployableSpecTemplateOutput {
	return o
}

// DeployableStatus defines the observed state of Deployable
type DeployableStatus struct {
	TargetClusters interface{} `pulumi:"targetClusters"`
}

// DeployableStatusInput is an input type that accepts DeployableStatusArgs and DeployableStatusOutput values.
// You can construct a concrete instance of `DeployableStatusInput` via:
//
//          DeployableStatusArgs{...}
type DeployableStatusInput interface {
	pulumi.Input

	ToDeployableStatusOutput() DeployableStatusOutput
	ToDeployableStatusOutputWithContext(context.Context) DeployableStatusOutput
}

// DeployableStatus defines the observed state of Deployable
type DeployableStatusArgs struct {
	TargetClusters pulumi.Input `pulumi:"targetClusters"`
}

func (DeployableStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DeployableStatus)(nil)).Elem()
}

func (i DeployableStatusArgs) ToDeployableStatusOutput() DeployableStatusOutput {
	return i.ToDeployableStatusOutputWithContext(context.Background())
}

func (i DeployableStatusArgs) ToDeployableStatusOutputWithContext(ctx context.Context) DeployableStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeployableStatusOutput)
}

func (i DeployableStatusArgs) ToDeployableStatusPtrOutput() DeployableStatusPtrOutput {
	return i.ToDeployableStatusPtrOutputWithContext(context.Background())
}

func (i DeployableStatusArgs) ToDeployableStatusPtrOutputWithContext(ctx context.Context) DeployableStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeployableStatusOutput).ToDeployableStatusPtrOutputWithContext(ctx)
}

// DeployableStatusPtrInput is an input type that accepts DeployableStatusArgs, DeployableStatusPtr and DeployableStatusPtrOutput values.
// You can construct a concrete instance of `DeployableStatusPtrInput` via:
//
//          DeployableStatusArgs{...}
//
//  or:
//
//          nil
type DeployableStatusPtrInput interface {
	pulumi.Input

	ToDeployableStatusPtrOutput() DeployableStatusPtrOutput
	ToDeployableStatusPtrOutputWithContext(context.Context) DeployableStatusPtrOutput
}

type deployableStatusPtrType DeployableStatusArgs

func DeployableStatusPtr(v *DeployableStatusArgs) DeployableStatusPtrInput {
	return (*deployableStatusPtrType)(v)
}

func (*deployableStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DeployableStatus)(nil)).Elem()
}

func (i *deployableStatusPtrType) ToDeployableStatusPtrOutput() DeployableStatusPtrOutput {
	return i.ToDeployableStatusPtrOutputWithContext(context.Background())
}

func (i *deployableStatusPtrType) ToDeployableStatusPtrOutputWithContext(ctx context.Context) DeployableStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DeployableStatusPtrOutput)
}

// DeployableStatus defines the observed state of Deployable
type DeployableStatusOutput struct{ *pulumi.OutputState }

func (DeployableStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DeployableStatus)(nil)).Elem()
}

func (o DeployableStatusOutput) ToDeployableStatusOutput() DeployableStatusOutput {
	return o
}

func (o DeployableStatusOutput) ToDeployableStatusOutputWithContext(ctx context.Context) DeployableStatusOutput {
	return o
}

func (o DeployableStatusOutput) ToDeployableStatusPtrOutput() DeployableStatusPtrOutput {
	return o.ToDeployableStatusPtrOutputWithContext(context.Background())
}

func (o DeployableStatusOutput) ToDeployableStatusPtrOutputWithContext(ctx context.Context) DeployableStatusPtrOutput {
	return o.ApplyT(func(v DeployableStatus) *DeployableStatus {
		return &v
	}).(DeployableStatusPtrOutput)
}
func (o DeployableStatusOutput) TargetClusters() pulumi.AnyOutput {
	return o.ApplyT(func(v DeployableStatus) interface{} { return v.TargetClusters }).(pulumi.AnyOutput)
}

type DeployableStatusPtrOutput struct{ *pulumi.OutputState }

func (DeployableStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DeployableStatus)(nil)).Elem()
}

func (o DeployableStatusPtrOutput) ToDeployableStatusPtrOutput() DeployableStatusPtrOutput {
	return o
}

func (o DeployableStatusPtrOutput) ToDeployableStatusPtrOutputWithContext(ctx context.Context) DeployableStatusPtrOutput {
	return o
}

func (o DeployableStatusPtrOutput) Elem() DeployableStatusOutput {
	return o.ApplyT(func(v *DeployableStatus) DeployableStatus { return *v }).(DeployableStatusOutput)
}

func (o DeployableStatusPtrOutput) TargetClusters() pulumi.AnyOutput {
	return o.ApplyT(func(v *DeployableStatus) interface{} {
		if v == nil {
			return nil
		}
		return v.TargetClusters
	}).(pulumi.AnyOutput)
}

// HelmRelease is the Schema for the subscriptionreleases API
type HelmReleaseType struct {
	ApiVersion *string            `pulumi:"apiVersion"`
	Kind       *string            `pulumi:"kind"`
	Metadata   *metav1.ObjectMeta `pulumi:"metadata"`
	// HelmReleaseRepo defines the repository of HelmRelease
	Repo   *HelmReleaseRepo   `pulumi:"repo"`
	Spec   interface{}        `pulumi:"spec"`
	Status *HelmReleaseStatus `pulumi:"status"`
}

// HelmReleaseTypeInput is an input type that accepts HelmReleaseTypeArgs and HelmReleaseTypeOutput values.
// You can construct a concrete instance of `HelmReleaseTypeInput` via:
//
//          HelmReleaseTypeArgs{...}
type HelmReleaseTypeInput interface {
	pulumi.Input

	ToHelmReleaseTypeOutput() HelmReleaseTypeOutput
	ToHelmReleaseTypeOutputWithContext(context.Context) HelmReleaseTypeOutput
}

// HelmRelease is the Schema for the subscriptionreleases API
type HelmReleaseTypeArgs struct {
	ApiVersion pulumi.StringPtrInput     `pulumi:"apiVersion"`
	Kind       pulumi.StringPtrInput     `pulumi:"kind"`
	Metadata   metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	// HelmReleaseRepo defines the repository of HelmRelease
	Repo   HelmReleaseRepoPtrInput   `pulumi:"repo"`
	Spec   pulumi.Input              `pulumi:"spec"`
	Status HelmReleaseStatusPtrInput `pulumi:"status"`
}

func (HelmReleaseTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HelmReleaseType)(nil)).Elem()
}

func (i HelmReleaseTypeArgs) ToHelmReleaseTypeOutput() HelmReleaseTypeOutput {
	return i.ToHelmReleaseTypeOutputWithContext(context.Background())
}

func (i HelmReleaseTypeArgs) ToHelmReleaseTypeOutputWithContext(ctx context.Context) HelmReleaseTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HelmReleaseTypeOutput)
}

// HelmRelease is the Schema for the subscriptionreleases API
type HelmReleaseTypeOutput struct{ *pulumi.OutputState }

func (HelmReleaseTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HelmReleaseType)(nil)).Elem()
}

func (o HelmReleaseTypeOutput) ToHelmReleaseTypeOutput() HelmReleaseTypeOutput {
	return o
}

func (o HelmReleaseTypeOutput) ToHelmReleaseTypeOutputWithContext(ctx context.Context) HelmReleaseTypeOutput {
	return o
}

func (o HelmReleaseTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HelmReleaseType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

func (o HelmReleaseTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HelmReleaseType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

func (o HelmReleaseTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v HelmReleaseType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

// HelmReleaseRepo defines the repository of HelmRelease
func (o HelmReleaseTypeOutput) Repo() HelmReleaseRepoPtrOutput {
	return o.ApplyT(func(v HelmReleaseType) *HelmReleaseRepo { return v.Repo }).(HelmReleaseRepoPtrOutput)
}

func (o HelmReleaseTypeOutput) Spec() pulumi.AnyOutput {
	return o.ApplyT(func(v HelmReleaseType) interface{} { return v.Spec }).(pulumi.AnyOutput)
}

func (o HelmReleaseTypeOutput) Status() HelmReleaseStatusPtrOutput {
	return o.ApplyT(func(v HelmReleaseType) *HelmReleaseStatus { return v.Status }).(HelmReleaseStatusPtrOutput)
}

type HelmReleaseMetadata struct {
}

// HelmReleaseMetadataInput is an input type that accepts HelmReleaseMetadataArgs and HelmReleaseMetadataOutput values.
// You can construct a concrete instance of `HelmReleaseMetadataInput` via:
//
//          HelmReleaseMetadataArgs{...}
type HelmReleaseMetadataInput interface {
	pulumi.Input

	ToHelmReleaseMetadataOutput() HelmReleaseMetadataOutput
	ToHelmReleaseMetadataOutputWithContext(context.Context) HelmReleaseMetadataOutput
}

type HelmReleaseMetadataArgs struct {
}

func (HelmReleaseMetadataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HelmReleaseMetadata)(nil)).Elem()
}

func (i HelmReleaseMetadataArgs) ToHelmReleaseMetadataOutput() HelmReleaseMetadataOutput {
	return i.ToHelmReleaseMetadataOutputWithContext(context.Background())
}

func (i HelmReleaseMetadataArgs) ToHelmReleaseMetadataOutputWithContext(ctx context.Context) HelmReleaseMetadataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HelmReleaseMetadataOutput)
}

type HelmReleaseMetadataOutput struct{ *pulumi.OutputState }

func (HelmReleaseMetadataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HelmReleaseMetadata)(nil)).Elem()
}

func (o HelmReleaseMetadataOutput) ToHelmReleaseMetadataOutput() HelmReleaseMetadataOutput {
	return o
}

func (o HelmReleaseMetadataOutput) ToHelmReleaseMetadataOutputWithContext(ctx context.Context) HelmReleaseMetadataOutput {
	return o
}

// HelmReleaseRepo defines the repository of HelmRelease
type HelmReleaseRepo struct {
	// ChartName is the name of the chart within the repo
	ChartName *string `pulumi:"chartName"`
	// Configuration parameters to access the helm-repo defined in the CatalogSource
	ConfigMapRef *HelmReleaseRepoConfigMapRef `pulumi:"configMapRef"`
	// Used to skip repo server's TLS certificate verification
	InsecureSkipVerify *bool `pulumi:"insecureSkipVerify"`
	// Secret to use to access the helm-repo defined in the CatalogSource.
	SecretRef *HelmReleaseRepoSecretRef `pulumi:"secretRef"`
	// INSERT ADDITIONAL SPEC FIELDS - desired state of cluster Important: Run "operator-sdk generate k8s" to regenerate code after modifying this file Add custom validation using kubebuilder tags: https://book-v1.book.kubebuilder.io/beyond_basics/generating_crd.html Source holds the url toward the helm-chart
	Source *HelmReleaseRepoSource `pulumi:"source"`
	// Version is the chart version
	Version *string `pulumi:"version"`
}

// HelmReleaseRepoInput is an input type that accepts HelmReleaseRepoArgs and HelmReleaseRepoOutput values.
// You can construct a concrete instance of `HelmReleaseRepoInput` via:
//
//          HelmReleaseRepoArgs{...}
type HelmReleaseRepoInput interface {
	pulumi.Input

	ToHelmReleaseRepoOutput() HelmReleaseRepoOutput
	ToHelmReleaseRepoOutputWithContext(context.Context) HelmReleaseRepoOutput
}

// HelmReleaseRepo defines the repository of HelmRelease
type HelmReleaseRepoArgs struct {
	// ChartName is the name of the chart within the repo
	ChartName pulumi.StringPtrInput `pulumi:"chartName"`
	// Configuration parameters to access the helm-repo defined in the CatalogSource
	ConfigMapRef HelmReleaseRepoConfigMapRefPtrInput `pulumi:"configMapRef"`
	// Used to skip repo server's TLS certificate verification
	InsecureSkipVerify pulumi.BoolPtrInput `pulumi:"insecureSkipVerify"`
	// Secret to use to access the helm-repo defined in the CatalogSource.
	SecretRef HelmReleaseRepoSecretRefPtrInput `pulumi:"secretRef"`
	// INSERT ADDITIONAL SPEC FIELDS - desired state of cluster Important: Run "operator-sdk generate k8s" to regenerate code after modifying this file Add custom validation using kubebuilder tags: https://book-v1.book.kubebuilder.io/beyond_basics/generating_crd.html Source holds the url toward the helm-chart
	Source HelmReleaseRepoSourcePtrInput `pulumi:"source"`
	// Version is the chart version
	Version pulumi.StringPtrInput `pulumi:"version"`
}

func (HelmReleaseRepoArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HelmReleaseRepo)(nil)).Elem()
}

func (i HelmReleaseRepoArgs) ToHelmReleaseRepoOutput() HelmReleaseRepoOutput {
	return i.ToHelmReleaseRepoOutputWithContext(context.Background())
}

func (i HelmReleaseRepoArgs) ToHelmReleaseRepoOutputWithContext(ctx context.Context) HelmReleaseRepoOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HelmReleaseRepoOutput)
}

func (i HelmReleaseRepoArgs) ToHelmReleaseRepoPtrOutput() HelmReleaseRepoPtrOutput {
	return i.ToHelmReleaseRepoPtrOutputWithContext(context.Background())
}

func (i HelmReleaseRepoArgs) ToHelmReleaseRepoPtrOutputWithContext(ctx context.Context) HelmReleaseRepoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HelmReleaseRepoOutput).ToHelmReleaseRepoPtrOutputWithContext(ctx)
}

// HelmReleaseRepoPtrInput is an input type that accepts HelmReleaseRepoArgs, HelmReleaseRepoPtr and HelmReleaseRepoPtrOutput values.
// You can construct a concrete instance of `HelmReleaseRepoPtrInput` via:
//
//          HelmReleaseRepoArgs{...}
//
//  or:
//
//          nil
type HelmReleaseRepoPtrInput interface {
	pulumi.Input

	ToHelmReleaseRepoPtrOutput() HelmReleaseRepoPtrOutput
	ToHelmReleaseRepoPtrOutputWithContext(context.Context) HelmReleaseRepoPtrOutput
}

type helmReleaseRepoPtrType HelmReleaseRepoArgs

func HelmReleaseRepoPtr(v *HelmReleaseRepoArgs) HelmReleaseRepoPtrInput {
	return (*helmReleaseRepoPtrType)(v)
}

func (*helmReleaseRepoPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HelmReleaseRepo)(nil)).Elem()
}

func (i *helmReleaseRepoPtrType) ToHelmReleaseRepoPtrOutput() HelmReleaseRepoPtrOutput {
	return i.ToHelmReleaseRepoPtrOutputWithContext(context.Background())
}

func (i *helmReleaseRepoPtrType) ToHelmReleaseRepoPtrOutputWithContext(ctx context.Context) HelmReleaseRepoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HelmReleaseRepoPtrOutput)
}

// HelmReleaseRepo defines the repository of HelmRelease
type HelmReleaseRepoOutput struct{ *pulumi.OutputState }

func (HelmReleaseRepoOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HelmReleaseRepo)(nil)).Elem()
}

func (o HelmReleaseRepoOutput) ToHelmReleaseRepoOutput() HelmReleaseRepoOutput {
	return o
}

func (o HelmReleaseRepoOutput) ToHelmReleaseRepoOutputWithContext(ctx context.Context) HelmReleaseRepoOutput {
	return o
}

func (o HelmReleaseRepoOutput) ToHelmReleaseRepoPtrOutput() HelmReleaseRepoPtrOutput {
	return o.ToHelmReleaseRepoPtrOutputWithContext(context.Background())
}

func (o HelmReleaseRepoOutput) ToHelmReleaseRepoPtrOutputWithContext(ctx context.Context) HelmReleaseRepoPtrOutput {
	return o.ApplyT(func(v HelmReleaseRepo) *HelmReleaseRepo {
		return &v
	}).(HelmReleaseRepoPtrOutput)
}

// ChartName is the name of the chart within the repo
func (o HelmReleaseRepoOutput) ChartName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HelmReleaseRepo) *string { return v.ChartName }).(pulumi.StringPtrOutput)
}

// Configuration parameters to access the helm-repo defined in the CatalogSource
func (o HelmReleaseRepoOutput) ConfigMapRef() HelmReleaseRepoConfigMapRefPtrOutput {
	return o.ApplyT(func(v HelmReleaseRepo) *HelmReleaseRepoConfigMapRef { return v.ConfigMapRef }).(HelmReleaseRepoConfigMapRefPtrOutput)
}

// Used to skip repo server's TLS certificate verification
func (o HelmReleaseRepoOutput) InsecureSkipVerify() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v HelmReleaseRepo) *bool { return v.InsecureSkipVerify }).(pulumi.BoolPtrOutput)
}

// Secret to use to access the helm-repo defined in the CatalogSource.
func (o HelmReleaseRepoOutput) SecretRef() HelmReleaseRepoSecretRefPtrOutput {
	return o.ApplyT(func(v HelmReleaseRepo) *HelmReleaseRepoSecretRef { return v.SecretRef }).(HelmReleaseRepoSecretRefPtrOutput)
}

// INSERT ADDITIONAL SPEC FIELDS - desired state of cluster Important: Run "operator-sdk generate k8s" to regenerate code after modifying this file Add custom validation using kubebuilder tags: https://book-v1.book.kubebuilder.io/beyond_basics/generating_crd.html Source holds the url toward the helm-chart
func (o HelmReleaseRepoOutput) Source() HelmReleaseRepoSourcePtrOutput {
	return o.ApplyT(func(v HelmReleaseRepo) *HelmReleaseRepoSource { return v.Source }).(HelmReleaseRepoSourcePtrOutput)
}

// Version is the chart version
func (o HelmReleaseRepoOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HelmReleaseRepo) *string { return v.Version }).(pulumi.StringPtrOutput)
}

type HelmReleaseRepoPtrOutput struct{ *pulumi.OutputState }

func (HelmReleaseRepoPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HelmReleaseRepo)(nil)).Elem()
}

func (o HelmReleaseRepoPtrOutput) ToHelmReleaseRepoPtrOutput() HelmReleaseRepoPtrOutput {
	return o
}

func (o HelmReleaseRepoPtrOutput) ToHelmReleaseRepoPtrOutputWithContext(ctx context.Context) HelmReleaseRepoPtrOutput {
	return o
}

func (o HelmReleaseRepoPtrOutput) Elem() HelmReleaseRepoOutput {
	return o.ApplyT(func(v *HelmReleaseRepo) HelmReleaseRepo { return *v }).(HelmReleaseRepoOutput)
}

// ChartName is the name of the chart within the repo
func (o HelmReleaseRepoPtrOutput) ChartName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HelmReleaseRepo) *string {
		if v == nil {
			return nil
		}
		return v.ChartName
	}).(pulumi.StringPtrOutput)
}

// Configuration parameters to access the helm-repo defined in the CatalogSource
func (o HelmReleaseRepoPtrOutput) ConfigMapRef() HelmReleaseRepoConfigMapRefPtrOutput {
	return o.ApplyT(func(v *HelmReleaseRepo) *HelmReleaseRepoConfigMapRef {
		if v == nil {
			return nil
		}
		return v.ConfigMapRef
	}).(HelmReleaseRepoConfigMapRefPtrOutput)
}

// Used to skip repo server's TLS certificate verification
func (o HelmReleaseRepoPtrOutput) InsecureSkipVerify() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *HelmReleaseRepo) *bool {
		if v == nil {
			return nil
		}
		return v.InsecureSkipVerify
	}).(pulumi.BoolPtrOutput)
}

// Secret to use to access the helm-repo defined in the CatalogSource.
func (o HelmReleaseRepoPtrOutput) SecretRef() HelmReleaseRepoSecretRefPtrOutput {
	return o.ApplyT(func(v *HelmReleaseRepo) *HelmReleaseRepoSecretRef {
		if v == nil {
			return nil
		}
		return v.SecretRef
	}).(HelmReleaseRepoSecretRefPtrOutput)
}

// INSERT ADDITIONAL SPEC FIELDS - desired state of cluster Important: Run "operator-sdk generate k8s" to regenerate code after modifying this file Add custom validation using kubebuilder tags: https://book-v1.book.kubebuilder.io/beyond_basics/generating_crd.html Source holds the url toward the helm-chart
func (o HelmReleaseRepoPtrOutput) Source() HelmReleaseRepoSourcePtrOutput {
	return o.ApplyT(func(v *HelmReleaseRepo) *HelmReleaseRepoSource {
		if v == nil {
			return nil
		}
		return v.Source
	}).(HelmReleaseRepoSourcePtrOutput)
}

// Version is the chart version
func (o HelmReleaseRepoPtrOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HelmReleaseRepo) *string {
		if v == nil {
			return nil
		}
		return v.Version
	}).(pulumi.StringPtrOutput)
}

// Configuration parameters to access the helm-repo defined in the CatalogSource
type HelmReleaseRepoConfigMapRef struct {
	// API version of the referent.
	ApiVersion *string `pulumi:"apiVersion"`
	// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
	FieldPath *string `pulumi:"fieldPath"`
	// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name *string `pulumi:"name"`
	// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
	Namespace *string `pulumi:"namespace"`
	// Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
	ResourceVersion *string `pulumi:"resourceVersion"`
	// UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
	Uid *string `pulumi:"uid"`
}

// HelmReleaseRepoConfigMapRefInput is an input type that accepts HelmReleaseRepoConfigMapRefArgs and HelmReleaseRepoConfigMapRefOutput values.
// You can construct a concrete instance of `HelmReleaseRepoConfigMapRefInput` via:
//
//          HelmReleaseRepoConfigMapRefArgs{...}
type HelmReleaseRepoConfigMapRefInput interface {
	pulumi.Input

	ToHelmReleaseRepoConfigMapRefOutput() HelmReleaseRepoConfigMapRefOutput
	ToHelmReleaseRepoConfigMapRefOutputWithContext(context.Context) HelmReleaseRepoConfigMapRefOutput
}

// Configuration parameters to access the helm-repo defined in the CatalogSource
type HelmReleaseRepoConfigMapRefArgs struct {
	// API version of the referent.
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
	FieldPath pulumi.StringPtrInput `pulumi:"fieldPath"`
	// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
	ResourceVersion pulumi.StringPtrInput `pulumi:"resourceVersion"`
	// UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
	Uid pulumi.StringPtrInput `pulumi:"uid"`
}

func (HelmReleaseRepoConfigMapRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HelmReleaseRepoConfigMapRef)(nil)).Elem()
}

func (i HelmReleaseRepoConfigMapRefArgs) ToHelmReleaseRepoConfigMapRefOutput() HelmReleaseRepoConfigMapRefOutput {
	return i.ToHelmReleaseRepoConfigMapRefOutputWithContext(context.Background())
}

func (i HelmReleaseRepoConfigMapRefArgs) ToHelmReleaseRepoConfigMapRefOutputWithContext(ctx context.Context) HelmReleaseRepoConfigMapRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HelmReleaseRepoConfigMapRefOutput)
}

func (i HelmReleaseRepoConfigMapRefArgs) ToHelmReleaseRepoConfigMapRefPtrOutput() HelmReleaseRepoConfigMapRefPtrOutput {
	return i.ToHelmReleaseRepoConfigMapRefPtrOutputWithContext(context.Background())
}

func (i HelmReleaseRepoConfigMapRefArgs) ToHelmReleaseRepoConfigMapRefPtrOutputWithContext(ctx context.Context) HelmReleaseRepoConfigMapRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HelmReleaseRepoConfigMapRefOutput).ToHelmReleaseRepoConfigMapRefPtrOutputWithContext(ctx)
}

// HelmReleaseRepoConfigMapRefPtrInput is an input type that accepts HelmReleaseRepoConfigMapRefArgs, HelmReleaseRepoConfigMapRefPtr and HelmReleaseRepoConfigMapRefPtrOutput values.
// You can construct a concrete instance of `HelmReleaseRepoConfigMapRefPtrInput` via:
//
//          HelmReleaseRepoConfigMapRefArgs{...}
//
//  or:
//
//          nil
type HelmReleaseRepoConfigMapRefPtrInput interface {
	pulumi.Input

	ToHelmReleaseRepoConfigMapRefPtrOutput() HelmReleaseRepoConfigMapRefPtrOutput
	ToHelmReleaseRepoConfigMapRefPtrOutputWithContext(context.Context) HelmReleaseRepoConfigMapRefPtrOutput
}

type helmReleaseRepoConfigMapRefPtrType HelmReleaseRepoConfigMapRefArgs

func HelmReleaseRepoConfigMapRefPtr(v *HelmReleaseRepoConfigMapRefArgs) HelmReleaseRepoConfigMapRefPtrInput {
	return (*helmReleaseRepoConfigMapRefPtrType)(v)
}

func (*helmReleaseRepoConfigMapRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HelmReleaseRepoConfigMapRef)(nil)).Elem()
}

func (i *helmReleaseRepoConfigMapRefPtrType) ToHelmReleaseRepoConfigMapRefPtrOutput() HelmReleaseRepoConfigMapRefPtrOutput {
	return i.ToHelmReleaseRepoConfigMapRefPtrOutputWithContext(context.Background())
}

func (i *helmReleaseRepoConfigMapRefPtrType) ToHelmReleaseRepoConfigMapRefPtrOutputWithContext(ctx context.Context) HelmReleaseRepoConfigMapRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HelmReleaseRepoConfigMapRefPtrOutput)
}

// Configuration parameters to access the helm-repo defined in the CatalogSource
type HelmReleaseRepoConfigMapRefOutput struct{ *pulumi.OutputState }

func (HelmReleaseRepoConfigMapRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HelmReleaseRepoConfigMapRef)(nil)).Elem()
}

func (o HelmReleaseRepoConfigMapRefOutput) ToHelmReleaseRepoConfigMapRefOutput() HelmReleaseRepoConfigMapRefOutput {
	return o
}

func (o HelmReleaseRepoConfigMapRefOutput) ToHelmReleaseRepoConfigMapRefOutputWithContext(ctx context.Context) HelmReleaseRepoConfigMapRefOutput {
	return o
}

func (o HelmReleaseRepoConfigMapRefOutput) ToHelmReleaseRepoConfigMapRefPtrOutput() HelmReleaseRepoConfigMapRefPtrOutput {
	return o.ToHelmReleaseRepoConfigMapRefPtrOutputWithContext(context.Background())
}

func (o HelmReleaseRepoConfigMapRefOutput) ToHelmReleaseRepoConfigMapRefPtrOutputWithContext(ctx context.Context) HelmReleaseRepoConfigMapRefPtrOutput {
	return o.ApplyT(func(v HelmReleaseRepoConfigMapRef) *HelmReleaseRepoConfigMapRef {
		return &v
	}).(HelmReleaseRepoConfigMapRefPtrOutput)
}

// API version of the referent.
func (o HelmReleaseRepoConfigMapRefOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HelmReleaseRepoConfigMapRef) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
func (o HelmReleaseRepoConfigMapRefOutput) FieldPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HelmReleaseRepoConfigMapRef) *string { return v.FieldPath }).(pulumi.StringPtrOutput)
}

// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
func (o HelmReleaseRepoConfigMapRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HelmReleaseRepoConfigMapRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o HelmReleaseRepoConfigMapRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HelmReleaseRepoConfigMapRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
func (o HelmReleaseRepoConfigMapRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HelmReleaseRepoConfigMapRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
func (o HelmReleaseRepoConfigMapRefOutput) ResourceVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HelmReleaseRepoConfigMapRef) *string { return v.ResourceVersion }).(pulumi.StringPtrOutput)
}

// UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
func (o HelmReleaseRepoConfigMapRefOutput) Uid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HelmReleaseRepoConfigMapRef) *string { return v.Uid }).(pulumi.StringPtrOutput)
}

type HelmReleaseRepoConfigMapRefPtrOutput struct{ *pulumi.OutputState }

func (HelmReleaseRepoConfigMapRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HelmReleaseRepoConfigMapRef)(nil)).Elem()
}

func (o HelmReleaseRepoConfigMapRefPtrOutput) ToHelmReleaseRepoConfigMapRefPtrOutput() HelmReleaseRepoConfigMapRefPtrOutput {
	return o
}

func (o HelmReleaseRepoConfigMapRefPtrOutput) ToHelmReleaseRepoConfigMapRefPtrOutputWithContext(ctx context.Context) HelmReleaseRepoConfigMapRefPtrOutput {
	return o
}

func (o HelmReleaseRepoConfigMapRefPtrOutput) Elem() HelmReleaseRepoConfigMapRefOutput {
	return o.ApplyT(func(v *HelmReleaseRepoConfigMapRef) HelmReleaseRepoConfigMapRef { return *v }).(HelmReleaseRepoConfigMapRefOutput)
}

// API version of the referent.
func (o HelmReleaseRepoConfigMapRefPtrOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HelmReleaseRepoConfigMapRef) *string {
		if v == nil {
			return nil
		}
		return v.ApiVersion
	}).(pulumi.StringPtrOutput)
}

// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
func (o HelmReleaseRepoConfigMapRefPtrOutput) FieldPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HelmReleaseRepoConfigMapRef) *string {
		if v == nil {
			return nil
		}
		return v.FieldPath
	}).(pulumi.StringPtrOutput)
}

// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
func (o HelmReleaseRepoConfigMapRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HelmReleaseRepoConfigMapRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o HelmReleaseRepoConfigMapRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HelmReleaseRepoConfigMapRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
func (o HelmReleaseRepoConfigMapRefPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HelmReleaseRepoConfigMapRef) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
func (o HelmReleaseRepoConfigMapRefPtrOutput) ResourceVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HelmReleaseRepoConfigMapRef) *string {
		if v == nil {
			return nil
		}
		return v.ResourceVersion
	}).(pulumi.StringPtrOutput)
}

// UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
func (o HelmReleaseRepoConfigMapRefPtrOutput) Uid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HelmReleaseRepoConfigMapRef) *string {
		if v == nil {
			return nil
		}
		return v.Uid
	}).(pulumi.StringPtrOutput)
}

// Secret to use to access the helm-repo defined in the CatalogSource.
type HelmReleaseRepoSecretRef struct {
	// API version of the referent.
	ApiVersion *string `pulumi:"apiVersion"`
	// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
	FieldPath *string `pulumi:"fieldPath"`
	// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name *string `pulumi:"name"`
	// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
	Namespace *string `pulumi:"namespace"`
	// Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
	ResourceVersion *string `pulumi:"resourceVersion"`
	// UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
	Uid *string `pulumi:"uid"`
}

// HelmReleaseRepoSecretRefInput is an input type that accepts HelmReleaseRepoSecretRefArgs and HelmReleaseRepoSecretRefOutput values.
// You can construct a concrete instance of `HelmReleaseRepoSecretRefInput` via:
//
//          HelmReleaseRepoSecretRefArgs{...}
type HelmReleaseRepoSecretRefInput interface {
	pulumi.Input

	ToHelmReleaseRepoSecretRefOutput() HelmReleaseRepoSecretRefOutput
	ToHelmReleaseRepoSecretRefOutputWithContext(context.Context) HelmReleaseRepoSecretRefOutput
}

// Secret to use to access the helm-repo defined in the CatalogSource.
type HelmReleaseRepoSecretRefArgs struct {
	// API version of the referent.
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
	FieldPath pulumi.StringPtrInput `pulumi:"fieldPath"`
	// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
	ResourceVersion pulumi.StringPtrInput `pulumi:"resourceVersion"`
	// UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
	Uid pulumi.StringPtrInput `pulumi:"uid"`
}

func (HelmReleaseRepoSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HelmReleaseRepoSecretRef)(nil)).Elem()
}

func (i HelmReleaseRepoSecretRefArgs) ToHelmReleaseRepoSecretRefOutput() HelmReleaseRepoSecretRefOutput {
	return i.ToHelmReleaseRepoSecretRefOutputWithContext(context.Background())
}

func (i HelmReleaseRepoSecretRefArgs) ToHelmReleaseRepoSecretRefOutputWithContext(ctx context.Context) HelmReleaseRepoSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HelmReleaseRepoSecretRefOutput)
}

func (i HelmReleaseRepoSecretRefArgs) ToHelmReleaseRepoSecretRefPtrOutput() HelmReleaseRepoSecretRefPtrOutput {
	return i.ToHelmReleaseRepoSecretRefPtrOutputWithContext(context.Background())
}

func (i HelmReleaseRepoSecretRefArgs) ToHelmReleaseRepoSecretRefPtrOutputWithContext(ctx context.Context) HelmReleaseRepoSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HelmReleaseRepoSecretRefOutput).ToHelmReleaseRepoSecretRefPtrOutputWithContext(ctx)
}

// HelmReleaseRepoSecretRefPtrInput is an input type that accepts HelmReleaseRepoSecretRefArgs, HelmReleaseRepoSecretRefPtr and HelmReleaseRepoSecretRefPtrOutput values.
// You can construct a concrete instance of `HelmReleaseRepoSecretRefPtrInput` via:
//
//          HelmReleaseRepoSecretRefArgs{...}
//
//  or:
//
//          nil
type HelmReleaseRepoSecretRefPtrInput interface {
	pulumi.Input

	ToHelmReleaseRepoSecretRefPtrOutput() HelmReleaseRepoSecretRefPtrOutput
	ToHelmReleaseRepoSecretRefPtrOutputWithContext(context.Context) HelmReleaseRepoSecretRefPtrOutput
}

type helmReleaseRepoSecretRefPtrType HelmReleaseRepoSecretRefArgs

func HelmReleaseRepoSecretRefPtr(v *HelmReleaseRepoSecretRefArgs) HelmReleaseRepoSecretRefPtrInput {
	return (*helmReleaseRepoSecretRefPtrType)(v)
}

func (*helmReleaseRepoSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HelmReleaseRepoSecretRef)(nil)).Elem()
}

func (i *helmReleaseRepoSecretRefPtrType) ToHelmReleaseRepoSecretRefPtrOutput() HelmReleaseRepoSecretRefPtrOutput {
	return i.ToHelmReleaseRepoSecretRefPtrOutputWithContext(context.Background())
}

func (i *helmReleaseRepoSecretRefPtrType) ToHelmReleaseRepoSecretRefPtrOutputWithContext(ctx context.Context) HelmReleaseRepoSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HelmReleaseRepoSecretRefPtrOutput)
}

// Secret to use to access the helm-repo defined in the CatalogSource.
type HelmReleaseRepoSecretRefOutput struct{ *pulumi.OutputState }

func (HelmReleaseRepoSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HelmReleaseRepoSecretRef)(nil)).Elem()
}

func (o HelmReleaseRepoSecretRefOutput) ToHelmReleaseRepoSecretRefOutput() HelmReleaseRepoSecretRefOutput {
	return o
}

func (o HelmReleaseRepoSecretRefOutput) ToHelmReleaseRepoSecretRefOutputWithContext(ctx context.Context) HelmReleaseRepoSecretRefOutput {
	return o
}

func (o HelmReleaseRepoSecretRefOutput) ToHelmReleaseRepoSecretRefPtrOutput() HelmReleaseRepoSecretRefPtrOutput {
	return o.ToHelmReleaseRepoSecretRefPtrOutputWithContext(context.Background())
}

func (o HelmReleaseRepoSecretRefOutput) ToHelmReleaseRepoSecretRefPtrOutputWithContext(ctx context.Context) HelmReleaseRepoSecretRefPtrOutput {
	return o.ApplyT(func(v HelmReleaseRepoSecretRef) *HelmReleaseRepoSecretRef {
		return &v
	}).(HelmReleaseRepoSecretRefPtrOutput)
}

// API version of the referent.
func (o HelmReleaseRepoSecretRefOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HelmReleaseRepoSecretRef) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
func (o HelmReleaseRepoSecretRefOutput) FieldPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HelmReleaseRepoSecretRef) *string { return v.FieldPath }).(pulumi.StringPtrOutput)
}

// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
func (o HelmReleaseRepoSecretRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HelmReleaseRepoSecretRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o HelmReleaseRepoSecretRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HelmReleaseRepoSecretRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
func (o HelmReleaseRepoSecretRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HelmReleaseRepoSecretRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
func (o HelmReleaseRepoSecretRefOutput) ResourceVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HelmReleaseRepoSecretRef) *string { return v.ResourceVersion }).(pulumi.StringPtrOutput)
}

// UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
func (o HelmReleaseRepoSecretRefOutput) Uid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HelmReleaseRepoSecretRef) *string { return v.Uid }).(pulumi.StringPtrOutput)
}

type HelmReleaseRepoSecretRefPtrOutput struct{ *pulumi.OutputState }

func (HelmReleaseRepoSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HelmReleaseRepoSecretRef)(nil)).Elem()
}

func (o HelmReleaseRepoSecretRefPtrOutput) ToHelmReleaseRepoSecretRefPtrOutput() HelmReleaseRepoSecretRefPtrOutput {
	return o
}

func (o HelmReleaseRepoSecretRefPtrOutput) ToHelmReleaseRepoSecretRefPtrOutputWithContext(ctx context.Context) HelmReleaseRepoSecretRefPtrOutput {
	return o
}

func (o HelmReleaseRepoSecretRefPtrOutput) Elem() HelmReleaseRepoSecretRefOutput {
	return o.ApplyT(func(v *HelmReleaseRepoSecretRef) HelmReleaseRepoSecretRef { return *v }).(HelmReleaseRepoSecretRefOutput)
}

// API version of the referent.
func (o HelmReleaseRepoSecretRefPtrOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HelmReleaseRepoSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.ApiVersion
	}).(pulumi.StringPtrOutput)
}

// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
func (o HelmReleaseRepoSecretRefPtrOutput) FieldPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HelmReleaseRepoSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.FieldPath
	}).(pulumi.StringPtrOutput)
}

// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
func (o HelmReleaseRepoSecretRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HelmReleaseRepoSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o HelmReleaseRepoSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HelmReleaseRepoSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
func (o HelmReleaseRepoSecretRefPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HelmReleaseRepoSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
func (o HelmReleaseRepoSecretRefPtrOutput) ResourceVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HelmReleaseRepoSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.ResourceVersion
	}).(pulumi.StringPtrOutput)
}

// UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
func (o HelmReleaseRepoSecretRefPtrOutput) Uid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HelmReleaseRepoSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Uid
	}).(pulumi.StringPtrOutput)
}

// INSERT ADDITIONAL SPEC FIELDS - desired state of cluster Important: Run "operator-sdk generate k8s" to regenerate code after modifying this file Add custom validation using kubebuilder tags: https://book-v1.book.kubebuilder.io/beyond_basics/generating_crd.html Source holds the url toward the helm-chart
type HelmReleaseRepoSource struct {
	// GitHub provides the parameters to access the helm-chart located in a github repo
	Github *HelmReleaseRepoSourceGithub `pulumi:"github"`
	// HelmRepo provides the urls to retrieve the helm-chart
	HelmRepo *HelmReleaseRepoSourceHelmRepo `pulumi:"helmRepo"`
	// SourceTypeEnum types of sources
	Type *string `pulumi:"type"`
}

// HelmReleaseRepoSourceInput is an input type that accepts HelmReleaseRepoSourceArgs and HelmReleaseRepoSourceOutput values.
// You can construct a concrete instance of `HelmReleaseRepoSourceInput` via:
//
//          HelmReleaseRepoSourceArgs{...}
type HelmReleaseRepoSourceInput interface {
	pulumi.Input

	ToHelmReleaseRepoSourceOutput() HelmReleaseRepoSourceOutput
	ToHelmReleaseRepoSourceOutputWithContext(context.Context) HelmReleaseRepoSourceOutput
}

// INSERT ADDITIONAL SPEC FIELDS - desired state of cluster Important: Run "operator-sdk generate k8s" to regenerate code after modifying this file Add custom validation using kubebuilder tags: https://book-v1.book.kubebuilder.io/beyond_basics/generating_crd.html Source holds the url toward the helm-chart
type HelmReleaseRepoSourceArgs struct {
	// GitHub provides the parameters to access the helm-chart located in a github repo
	Github HelmReleaseRepoSourceGithubPtrInput `pulumi:"github"`
	// HelmRepo provides the urls to retrieve the helm-chart
	HelmRepo HelmReleaseRepoSourceHelmRepoPtrInput `pulumi:"helmRepo"`
	// SourceTypeEnum types of sources
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (HelmReleaseRepoSourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HelmReleaseRepoSource)(nil)).Elem()
}

func (i HelmReleaseRepoSourceArgs) ToHelmReleaseRepoSourceOutput() HelmReleaseRepoSourceOutput {
	return i.ToHelmReleaseRepoSourceOutputWithContext(context.Background())
}

func (i HelmReleaseRepoSourceArgs) ToHelmReleaseRepoSourceOutputWithContext(ctx context.Context) HelmReleaseRepoSourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HelmReleaseRepoSourceOutput)
}

func (i HelmReleaseRepoSourceArgs) ToHelmReleaseRepoSourcePtrOutput() HelmReleaseRepoSourcePtrOutput {
	return i.ToHelmReleaseRepoSourcePtrOutputWithContext(context.Background())
}

func (i HelmReleaseRepoSourceArgs) ToHelmReleaseRepoSourcePtrOutputWithContext(ctx context.Context) HelmReleaseRepoSourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HelmReleaseRepoSourceOutput).ToHelmReleaseRepoSourcePtrOutputWithContext(ctx)
}

// HelmReleaseRepoSourcePtrInput is an input type that accepts HelmReleaseRepoSourceArgs, HelmReleaseRepoSourcePtr and HelmReleaseRepoSourcePtrOutput values.
// You can construct a concrete instance of `HelmReleaseRepoSourcePtrInput` via:
//
//          HelmReleaseRepoSourceArgs{...}
//
//  or:
//
//          nil
type HelmReleaseRepoSourcePtrInput interface {
	pulumi.Input

	ToHelmReleaseRepoSourcePtrOutput() HelmReleaseRepoSourcePtrOutput
	ToHelmReleaseRepoSourcePtrOutputWithContext(context.Context) HelmReleaseRepoSourcePtrOutput
}

type helmReleaseRepoSourcePtrType HelmReleaseRepoSourceArgs

func HelmReleaseRepoSourcePtr(v *HelmReleaseRepoSourceArgs) HelmReleaseRepoSourcePtrInput {
	return (*helmReleaseRepoSourcePtrType)(v)
}

func (*helmReleaseRepoSourcePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HelmReleaseRepoSource)(nil)).Elem()
}

func (i *helmReleaseRepoSourcePtrType) ToHelmReleaseRepoSourcePtrOutput() HelmReleaseRepoSourcePtrOutput {
	return i.ToHelmReleaseRepoSourcePtrOutputWithContext(context.Background())
}

func (i *helmReleaseRepoSourcePtrType) ToHelmReleaseRepoSourcePtrOutputWithContext(ctx context.Context) HelmReleaseRepoSourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HelmReleaseRepoSourcePtrOutput)
}

// INSERT ADDITIONAL SPEC FIELDS - desired state of cluster Important: Run "operator-sdk generate k8s" to regenerate code after modifying this file Add custom validation using kubebuilder tags: https://book-v1.book.kubebuilder.io/beyond_basics/generating_crd.html Source holds the url toward the helm-chart
type HelmReleaseRepoSourceOutput struct{ *pulumi.OutputState }

func (HelmReleaseRepoSourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HelmReleaseRepoSource)(nil)).Elem()
}

func (o HelmReleaseRepoSourceOutput) ToHelmReleaseRepoSourceOutput() HelmReleaseRepoSourceOutput {
	return o
}

func (o HelmReleaseRepoSourceOutput) ToHelmReleaseRepoSourceOutputWithContext(ctx context.Context) HelmReleaseRepoSourceOutput {
	return o
}

func (o HelmReleaseRepoSourceOutput) ToHelmReleaseRepoSourcePtrOutput() HelmReleaseRepoSourcePtrOutput {
	return o.ToHelmReleaseRepoSourcePtrOutputWithContext(context.Background())
}

func (o HelmReleaseRepoSourceOutput) ToHelmReleaseRepoSourcePtrOutputWithContext(ctx context.Context) HelmReleaseRepoSourcePtrOutput {
	return o.ApplyT(func(v HelmReleaseRepoSource) *HelmReleaseRepoSource {
		return &v
	}).(HelmReleaseRepoSourcePtrOutput)
}

// GitHub provides the parameters to access the helm-chart located in a github repo
func (o HelmReleaseRepoSourceOutput) Github() HelmReleaseRepoSourceGithubPtrOutput {
	return o.ApplyT(func(v HelmReleaseRepoSource) *HelmReleaseRepoSourceGithub { return v.Github }).(HelmReleaseRepoSourceGithubPtrOutput)
}

// HelmRepo provides the urls to retrieve the helm-chart
func (o HelmReleaseRepoSourceOutput) HelmRepo() HelmReleaseRepoSourceHelmRepoPtrOutput {
	return o.ApplyT(func(v HelmReleaseRepoSource) *HelmReleaseRepoSourceHelmRepo { return v.HelmRepo }).(HelmReleaseRepoSourceHelmRepoPtrOutput)
}

// SourceTypeEnum types of sources
func (o HelmReleaseRepoSourceOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HelmReleaseRepoSource) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type HelmReleaseRepoSourcePtrOutput struct{ *pulumi.OutputState }

func (HelmReleaseRepoSourcePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HelmReleaseRepoSource)(nil)).Elem()
}

func (o HelmReleaseRepoSourcePtrOutput) ToHelmReleaseRepoSourcePtrOutput() HelmReleaseRepoSourcePtrOutput {
	return o
}

func (o HelmReleaseRepoSourcePtrOutput) ToHelmReleaseRepoSourcePtrOutputWithContext(ctx context.Context) HelmReleaseRepoSourcePtrOutput {
	return o
}

func (o HelmReleaseRepoSourcePtrOutput) Elem() HelmReleaseRepoSourceOutput {
	return o.ApplyT(func(v *HelmReleaseRepoSource) HelmReleaseRepoSource { return *v }).(HelmReleaseRepoSourceOutput)
}

// GitHub provides the parameters to access the helm-chart located in a github repo
func (o HelmReleaseRepoSourcePtrOutput) Github() HelmReleaseRepoSourceGithubPtrOutput {
	return o.ApplyT(func(v *HelmReleaseRepoSource) *HelmReleaseRepoSourceGithub {
		if v == nil {
			return nil
		}
		return v.Github
	}).(HelmReleaseRepoSourceGithubPtrOutput)
}

// HelmRepo provides the urls to retrieve the helm-chart
func (o HelmReleaseRepoSourcePtrOutput) HelmRepo() HelmReleaseRepoSourceHelmRepoPtrOutput {
	return o.ApplyT(func(v *HelmReleaseRepoSource) *HelmReleaseRepoSourceHelmRepo {
		if v == nil {
			return nil
		}
		return v.HelmRepo
	}).(HelmReleaseRepoSourceHelmRepoPtrOutput)
}

// SourceTypeEnum types of sources
func (o HelmReleaseRepoSourcePtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HelmReleaseRepoSource) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// GitHub provides the parameters to access the helm-chart located in a github repo
type HelmReleaseRepoSourceGithub struct {
	Branch    *string  `pulumi:"branch"`
	ChartPath *string  `pulumi:"chartPath"`
	Urls      []string `pulumi:"urls"`
}

// HelmReleaseRepoSourceGithubInput is an input type that accepts HelmReleaseRepoSourceGithubArgs and HelmReleaseRepoSourceGithubOutput values.
// You can construct a concrete instance of `HelmReleaseRepoSourceGithubInput` via:
//
//          HelmReleaseRepoSourceGithubArgs{...}
type HelmReleaseRepoSourceGithubInput interface {
	pulumi.Input

	ToHelmReleaseRepoSourceGithubOutput() HelmReleaseRepoSourceGithubOutput
	ToHelmReleaseRepoSourceGithubOutputWithContext(context.Context) HelmReleaseRepoSourceGithubOutput
}

// GitHub provides the parameters to access the helm-chart located in a github repo
type HelmReleaseRepoSourceGithubArgs struct {
	Branch    pulumi.StringPtrInput   `pulumi:"branch"`
	ChartPath pulumi.StringPtrInput   `pulumi:"chartPath"`
	Urls      pulumi.StringArrayInput `pulumi:"urls"`
}

func (HelmReleaseRepoSourceGithubArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HelmReleaseRepoSourceGithub)(nil)).Elem()
}

func (i HelmReleaseRepoSourceGithubArgs) ToHelmReleaseRepoSourceGithubOutput() HelmReleaseRepoSourceGithubOutput {
	return i.ToHelmReleaseRepoSourceGithubOutputWithContext(context.Background())
}

func (i HelmReleaseRepoSourceGithubArgs) ToHelmReleaseRepoSourceGithubOutputWithContext(ctx context.Context) HelmReleaseRepoSourceGithubOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HelmReleaseRepoSourceGithubOutput)
}

func (i HelmReleaseRepoSourceGithubArgs) ToHelmReleaseRepoSourceGithubPtrOutput() HelmReleaseRepoSourceGithubPtrOutput {
	return i.ToHelmReleaseRepoSourceGithubPtrOutputWithContext(context.Background())
}

func (i HelmReleaseRepoSourceGithubArgs) ToHelmReleaseRepoSourceGithubPtrOutputWithContext(ctx context.Context) HelmReleaseRepoSourceGithubPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HelmReleaseRepoSourceGithubOutput).ToHelmReleaseRepoSourceGithubPtrOutputWithContext(ctx)
}

// HelmReleaseRepoSourceGithubPtrInput is an input type that accepts HelmReleaseRepoSourceGithubArgs, HelmReleaseRepoSourceGithubPtr and HelmReleaseRepoSourceGithubPtrOutput values.
// You can construct a concrete instance of `HelmReleaseRepoSourceGithubPtrInput` via:
//
//          HelmReleaseRepoSourceGithubArgs{...}
//
//  or:
//
//          nil
type HelmReleaseRepoSourceGithubPtrInput interface {
	pulumi.Input

	ToHelmReleaseRepoSourceGithubPtrOutput() HelmReleaseRepoSourceGithubPtrOutput
	ToHelmReleaseRepoSourceGithubPtrOutputWithContext(context.Context) HelmReleaseRepoSourceGithubPtrOutput
}

type helmReleaseRepoSourceGithubPtrType HelmReleaseRepoSourceGithubArgs

func HelmReleaseRepoSourceGithubPtr(v *HelmReleaseRepoSourceGithubArgs) HelmReleaseRepoSourceGithubPtrInput {
	return (*helmReleaseRepoSourceGithubPtrType)(v)
}

func (*helmReleaseRepoSourceGithubPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HelmReleaseRepoSourceGithub)(nil)).Elem()
}

func (i *helmReleaseRepoSourceGithubPtrType) ToHelmReleaseRepoSourceGithubPtrOutput() HelmReleaseRepoSourceGithubPtrOutput {
	return i.ToHelmReleaseRepoSourceGithubPtrOutputWithContext(context.Background())
}

func (i *helmReleaseRepoSourceGithubPtrType) ToHelmReleaseRepoSourceGithubPtrOutputWithContext(ctx context.Context) HelmReleaseRepoSourceGithubPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HelmReleaseRepoSourceGithubPtrOutput)
}

// GitHub provides the parameters to access the helm-chart located in a github repo
type HelmReleaseRepoSourceGithubOutput struct{ *pulumi.OutputState }

func (HelmReleaseRepoSourceGithubOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HelmReleaseRepoSourceGithub)(nil)).Elem()
}

func (o HelmReleaseRepoSourceGithubOutput) ToHelmReleaseRepoSourceGithubOutput() HelmReleaseRepoSourceGithubOutput {
	return o
}

func (o HelmReleaseRepoSourceGithubOutput) ToHelmReleaseRepoSourceGithubOutputWithContext(ctx context.Context) HelmReleaseRepoSourceGithubOutput {
	return o
}

func (o HelmReleaseRepoSourceGithubOutput) ToHelmReleaseRepoSourceGithubPtrOutput() HelmReleaseRepoSourceGithubPtrOutput {
	return o.ToHelmReleaseRepoSourceGithubPtrOutputWithContext(context.Background())
}

func (o HelmReleaseRepoSourceGithubOutput) ToHelmReleaseRepoSourceGithubPtrOutputWithContext(ctx context.Context) HelmReleaseRepoSourceGithubPtrOutput {
	return o.ApplyT(func(v HelmReleaseRepoSourceGithub) *HelmReleaseRepoSourceGithub {
		return &v
	}).(HelmReleaseRepoSourceGithubPtrOutput)
}
func (o HelmReleaseRepoSourceGithubOutput) Branch() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HelmReleaseRepoSourceGithub) *string { return v.Branch }).(pulumi.StringPtrOutput)
}

func (o HelmReleaseRepoSourceGithubOutput) ChartPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HelmReleaseRepoSourceGithub) *string { return v.ChartPath }).(pulumi.StringPtrOutput)
}

func (o HelmReleaseRepoSourceGithubOutput) Urls() pulumi.StringArrayOutput {
	return o.ApplyT(func(v HelmReleaseRepoSourceGithub) []string { return v.Urls }).(pulumi.StringArrayOutput)
}

type HelmReleaseRepoSourceGithubPtrOutput struct{ *pulumi.OutputState }

func (HelmReleaseRepoSourceGithubPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HelmReleaseRepoSourceGithub)(nil)).Elem()
}

func (o HelmReleaseRepoSourceGithubPtrOutput) ToHelmReleaseRepoSourceGithubPtrOutput() HelmReleaseRepoSourceGithubPtrOutput {
	return o
}

func (o HelmReleaseRepoSourceGithubPtrOutput) ToHelmReleaseRepoSourceGithubPtrOutputWithContext(ctx context.Context) HelmReleaseRepoSourceGithubPtrOutput {
	return o
}

func (o HelmReleaseRepoSourceGithubPtrOutput) Elem() HelmReleaseRepoSourceGithubOutput {
	return o.ApplyT(func(v *HelmReleaseRepoSourceGithub) HelmReleaseRepoSourceGithub { return *v }).(HelmReleaseRepoSourceGithubOutput)
}

func (o HelmReleaseRepoSourceGithubPtrOutput) Branch() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HelmReleaseRepoSourceGithub) *string {
		if v == nil {
			return nil
		}
		return v.Branch
	}).(pulumi.StringPtrOutput)
}

func (o HelmReleaseRepoSourceGithubPtrOutput) ChartPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HelmReleaseRepoSourceGithub) *string {
		if v == nil {
			return nil
		}
		return v.ChartPath
	}).(pulumi.StringPtrOutput)
}

func (o HelmReleaseRepoSourceGithubPtrOutput) Urls() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *HelmReleaseRepoSourceGithub) []string {
		if v == nil {
			return nil
		}
		return v.Urls
	}).(pulumi.StringArrayOutput)
}

// HelmRepo provides the urls to retrieve the helm-chart
type HelmReleaseRepoSourceHelmRepo struct {
	Urls []string `pulumi:"urls"`
}

// HelmReleaseRepoSourceHelmRepoInput is an input type that accepts HelmReleaseRepoSourceHelmRepoArgs and HelmReleaseRepoSourceHelmRepoOutput values.
// You can construct a concrete instance of `HelmReleaseRepoSourceHelmRepoInput` via:
//
//          HelmReleaseRepoSourceHelmRepoArgs{...}
type HelmReleaseRepoSourceHelmRepoInput interface {
	pulumi.Input

	ToHelmReleaseRepoSourceHelmRepoOutput() HelmReleaseRepoSourceHelmRepoOutput
	ToHelmReleaseRepoSourceHelmRepoOutputWithContext(context.Context) HelmReleaseRepoSourceHelmRepoOutput
}

// HelmRepo provides the urls to retrieve the helm-chart
type HelmReleaseRepoSourceHelmRepoArgs struct {
	Urls pulumi.StringArrayInput `pulumi:"urls"`
}

func (HelmReleaseRepoSourceHelmRepoArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HelmReleaseRepoSourceHelmRepo)(nil)).Elem()
}

func (i HelmReleaseRepoSourceHelmRepoArgs) ToHelmReleaseRepoSourceHelmRepoOutput() HelmReleaseRepoSourceHelmRepoOutput {
	return i.ToHelmReleaseRepoSourceHelmRepoOutputWithContext(context.Background())
}

func (i HelmReleaseRepoSourceHelmRepoArgs) ToHelmReleaseRepoSourceHelmRepoOutputWithContext(ctx context.Context) HelmReleaseRepoSourceHelmRepoOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HelmReleaseRepoSourceHelmRepoOutput)
}

func (i HelmReleaseRepoSourceHelmRepoArgs) ToHelmReleaseRepoSourceHelmRepoPtrOutput() HelmReleaseRepoSourceHelmRepoPtrOutput {
	return i.ToHelmReleaseRepoSourceHelmRepoPtrOutputWithContext(context.Background())
}

func (i HelmReleaseRepoSourceHelmRepoArgs) ToHelmReleaseRepoSourceHelmRepoPtrOutputWithContext(ctx context.Context) HelmReleaseRepoSourceHelmRepoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HelmReleaseRepoSourceHelmRepoOutput).ToHelmReleaseRepoSourceHelmRepoPtrOutputWithContext(ctx)
}

// HelmReleaseRepoSourceHelmRepoPtrInput is an input type that accepts HelmReleaseRepoSourceHelmRepoArgs, HelmReleaseRepoSourceHelmRepoPtr and HelmReleaseRepoSourceHelmRepoPtrOutput values.
// You can construct a concrete instance of `HelmReleaseRepoSourceHelmRepoPtrInput` via:
//
//          HelmReleaseRepoSourceHelmRepoArgs{...}
//
//  or:
//
//          nil
type HelmReleaseRepoSourceHelmRepoPtrInput interface {
	pulumi.Input

	ToHelmReleaseRepoSourceHelmRepoPtrOutput() HelmReleaseRepoSourceHelmRepoPtrOutput
	ToHelmReleaseRepoSourceHelmRepoPtrOutputWithContext(context.Context) HelmReleaseRepoSourceHelmRepoPtrOutput
}

type helmReleaseRepoSourceHelmRepoPtrType HelmReleaseRepoSourceHelmRepoArgs

func HelmReleaseRepoSourceHelmRepoPtr(v *HelmReleaseRepoSourceHelmRepoArgs) HelmReleaseRepoSourceHelmRepoPtrInput {
	return (*helmReleaseRepoSourceHelmRepoPtrType)(v)
}

func (*helmReleaseRepoSourceHelmRepoPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HelmReleaseRepoSourceHelmRepo)(nil)).Elem()
}

func (i *helmReleaseRepoSourceHelmRepoPtrType) ToHelmReleaseRepoSourceHelmRepoPtrOutput() HelmReleaseRepoSourceHelmRepoPtrOutput {
	return i.ToHelmReleaseRepoSourceHelmRepoPtrOutputWithContext(context.Background())
}

func (i *helmReleaseRepoSourceHelmRepoPtrType) ToHelmReleaseRepoSourceHelmRepoPtrOutputWithContext(ctx context.Context) HelmReleaseRepoSourceHelmRepoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HelmReleaseRepoSourceHelmRepoPtrOutput)
}

// HelmRepo provides the urls to retrieve the helm-chart
type HelmReleaseRepoSourceHelmRepoOutput struct{ *pulumi.OutputState }

func (HelmReleaseRepoSourceHelmRepoOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HelmReleaseRepoSourceHelmRepo)(nil)).Elem()
}

func (o HelmReleaseRepoSourceHelmRepoOutput) ToHelmReleaseRepoSourceHelmRepoOutput() HelmReleaseRepoSourceHelmRepoOutput {
	return o
}

func (o HelmReleaseRepoSourceHelmRepoOutput) ToHelmReleaseRepoSourceHelmRepoOutputWithContext(ctx context.Context) HelmReleaseRepoSourceHelmRepoOutput {
	return o
}

func (o HelmReleaseRepoSourceHelmRepoOutput) ToHelmReleaseRepoSourceHelmRepoPtrOutput() HelmReleaseRepoSourceHelmRepoPtrOutput {
	return o.ToHelmReleaseRepoSourceHelmRepoPtrOutputWithContext(context.Background())
}

func (o HelmReleaseRepoSourceHelmRepoOutput) ToHelmReleaseRepoSourceHelmRepoPtrOutputWithContext(ctx context.Context) HelmReleaseRepoSourceHelmRepoPtrOutput {
	return o.ApplyT(func(v HelmReleaseRepoSourceHelmRepo) *HelmReleaseRepoSourceHelmRepo {
		return &v
	}).(HelmReleaseRepoSourceHelmRepoPtrOutput)
}
func (o HelmReleaseRepoSourceHelmRepoOutput) Urls() pulumi.StringArrayOutput {
	return o.ApplyT(func(v HelmReleaseRepoSourceHelmRepo) []string { return v.Urls }).(pulumi.StringArrayOutput)
}

type HelmReleaseRepoSourceHelmRepoPtrOutput struct{ *pulumi.OutputState }

func (HelmReleaseRepoSourceHelmRepoPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HelmReleaseRepoSourceHelmRepo)(nil)).Elem()
}

func (o HelmReleaseRepoSourceHelmRepoPtrOutput) ToHelmReleaseRepoSourceHelmRepoPtrOutput() HelmReleaseRepoSourceHelmRepoPtrOutput {
	return o
}

func (o HelmReleaseRepoSourceHelmRepoPtrOutput) ToHelmReleaseRepoSourceHelmRepoPtrOutputWithContext(ctx context.Context) HelmReleaseRepoSourceHelmRepoPtrOutput {
	return o
}

func (o HelmReleaseRepoSourceHelmRepoPtrOutput) Elem() HelmReleaseRepoSourceHelmRepoOutput {
	return o.ApplyT(func(v *HelmReleaseRepoSourceHelmRepo) HelmReleaseRepoSourceHelmRepo { return *v }).(HelmReleaseRepoSourceHelmRepoOutput)
}

func (o HelmReleaseRepoSourceHelmRepoPtrOutput) Urls() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *HelmReleaseRepoSourceHelmRepo) []string {
		if v == nil {
			return nil
		}
		return v.Urls
	}).(pulumi.StringArrayOutput)
}

type HelmReleaseStatus struct {
	Conditions      []HelmReleaseStatusConditions     `pulumi:"conditions"`
	DeployedRelease *HelmReleaseStatusDeployedRelease `pulumi:"deployedRelease"`
}

// HelmReleaseStatusInput is an input type that accepts HelmReleaseStatusArgs and HelmReleaseStatusOutput values.
// You can construct a concrete instance of `HelmReleaseStatusInput` via:
//
//          HelmReleaseStatusArgs{...}
type HelmReleaseStatusInput interface {
	pulumi.Input

	ToHelmReleaseStatusOutput() HelmReleaseStatusOutput
	ToHelmReleaseStatusOutputWithContext(context.Context) HelmReleaseStatusOutput
}

type HelmReleaseStatusArgs struct {
	Conditions      HelmReleaseStatusConditionsArrayInput    `pulumi:"conditions"`
	DeployedRelease HelmReleaseStatusDeployedReleasePtrInput `pulumi:"deployedRelease"`
}

func (HelmReleaseStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HelmReleaseStatus)(nil)).Elem()
}

func (i HelmReleaseStatusArgs) ToHelmReleaseStatusOutput() HelmReleaseStatusOutput {
	return i.ToHelmReleaseStatusOutputWithContext(context.Background())
}

func (i HelmReleaseStatusArgs) ToHelmReleaseStatusOutputWithContext(ctx context.Context) HelmReleaseStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HelmReleaseStatusOutput)
}

func (i HelmReleaseStatusArgs) ToHelmReleaseStatusPtrOutput() HelmReleaseStatusPtrOutput {
	return i.ToHelmReleaseStatusPtrOutputWithContext(context.Background())
}

func (i HelmReleaseStatusArgs) ToHelmReleaseStatusPtrOutputWithContext(ctx context.Context) HelmReleaseStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HelmReleaseStatusOutput).ToHelmReleaseStatusPtrOutputWithContext(ctx)
}

// HelmReleaseStatusPtrInput is an input type that accepts HelmReleaseStatusArgs, HelmReleaseStatusPtr and HelmReleaseStatusPtrOutput values.
// You can construct a concrete instance of `HelmReleaseStatusPtrInput` via:
//
//          HelmReleaseStatusArgs{...}
//
//  or:
//
//          nil
type HelmReleaseStatusPtrInput interface {
	pulumi.Input

	ToHelmReleaseStatusPtrOutput() HelmReleaseStatusPtrOutput
	ToHelmReleaseStatusPtrOutputWithContext(context.Context) HelmReleaseStatusPtrOutput
}

type helmReleaseStatusPtrType HelmReleaseStatusArgs

func HelmReleaseStatusPtr(v *HelmReleaseStatusArgs) HelmReleaseStatusPtrInput {
	return (*helmReleaseStatusPtrType)(v)
}

func (*helmReleaseStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HelmReleaseStatus)(nil)).Elem()
}

func (i *helmReleaseStatusPtrType) ToHelmReleaseStatusPtrOutput() HelmReleaseStatusPtrOutput {
	return i.ToHelmReleaseStatusPtrOutputWithContext(context.Background())
}

func (i *helmReleaseStatusPtrType) ToHelmReleaseStatusPtrOutputWithContext(ctx context.Context) HelmReleaseStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HelmReleaseStatusPtrOutput)
}

type HelmReleaseStatusOutput struct{ *pulumi.OutputState }

func (HelmReleaseStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HelmReleaseStatus)(nil)).Elem()
}

func (o HelmReleaseStatusOutput) ToHelmReleaseStatusOutput() HelmReleaseStatusOutput {
	return o
}

func (o HelmReleaseStatusOutput) ToHelmReleaseStatusOutputWithContext(ctx context.Context) HelmReleaseStatusOutput {
	return o
}

func (o HelmReleaseStatusOutput) ToHelmReleaseStatusPtrOutput() HelmReleaseStatusPtrOutput {
	return o.ToHelmReleaseStatusPtrOutputWithContext(context.Background())
}

func (o HelmReleaseStatusOutput) ToHelmReleaseStatusPtrOutputWithContext(ctx context.Context) HelmReleaseStatusPtrOutput {
	return o.ApplyT(func(v HelmReleaseStatus) *HelmReleaseStatus {
		return &v
	}).(HelmReleaseStatusPtrOutput)
}
func (o HelmReleaseStatusOutput) Conditions() HelmReleaseStatusConditionsArrayOutput {
	return o.ApplyT(func(v HelmReleaseStatus) []HelmReleaseStatusConditions { return v.Conditions }).(HelmReleaseStatusConditionsArrayOutput)
}

func (o HelmReleaseStatusOutput) DeployedRelease() HelmReleaseStatusDeployedReleasePtrOutput {
	return o.ApplyT(func(v HelmReleaseStatus) *HelmReleaseStatusDeployedRelease { return v.DeployedRelease }).(HelmReleaseStatusDeployedReleasePtrOutput)
}

type HelmReleaseStatusPtrOutput struct{ *pulumi.OutputState }

func (HelmReleaseStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HelmReleaseStatus)(nil)).Elem()
}

func (o HelmReleaseStatusPtrOutput) ToHelmReleaseStatusPtrOutput() HelmReleaseStatusPtrOutput {
	return o
}

func (o HelmReleaseStatusPtrOutput) ToHelmReleaseStatusPtrOutputWithContext(ctx context.Context) HelmReleaseStatusPtrOutput {
	return o
}

func (o HelmReleaseStatusPtrOutput) Elem() HelmReleaseStatusOutput {
	return o.ApplyT(func(v *HelmReleaseStatus) HelmReleaseStatus { return *v }).(HelmReleaseStatusOutput)
}

func (o HelmReleaseStatusPtrOutput) Conditions() HelmReleaseStatusConditionsArrayOutput {
	return o.ApplyT(func(v *HelmReleaseStatus) []HelmReleaseStatusConditions {
		if v == nil {
			return nil
		}
		return v.Conditions
	}).(HelmReleaseStatusConditionsArrayOutput)
}

func (o HelmReleaseStatusPtrOutput) DeployedRelease() HelmReleaseStatusDeployedReleasePtrOutput {
	return o.ApplyT(func(v *HelmReleaseStatus) *HelmReleaseStatusDeployedRelease {
		if v == nil {
			return nil
		}
		return v.DeployedRelease
	}).(HelmReleaseStatusDeployedReleasePtrOutput)
}

type HelmReleaseStatusConditions struct {
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	Message            *string `pulumi:"message"`
	Reason             *string `pulumi:"reason"`
	Status             string  `pulumi:"status"`
	Type               string  `pulumi:"type"`
}

// HelmReleaseStatusConditionsInput is an input type that accepts HelmReleaseStatusConditionsArgs and HelmReleaseStatusConditionsOutput values.
// You can construct a concrete instance of `HelmReleaseStatusConditionsInput` via:
//
//          HelmReleaseStatusConditionsArgs{...}
type HelmReleaseStatusConditionsInput interface {
	pulumi.Input

	ToHelmReleaseStatusConditionsOutput() HelmReleaseStatusConditionsOutput
	ToHelmReleaseStatusConditionsOutputWithContext(context.Context) HelmReleaseStatusConditionsOutput
}

type HelmReleaseStatusConditionsArgs struct {
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	Message            pulumi.StringPtrInput `pulumi:"message"`
	Reason             pulumi.StringPtrInput `pulumi:"reason"`
	Status             pulumi.StringInput    `pulumi:"status"`
	Type               pulumi.StringInput    `pulumi:"type"`
}

func (HelmReleaseStatusConditionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HelmReleaseStatusConditions)(nil)).Elem()
}

func (i HelmReleaseStatusConditionsArgs) ToHelmReleaseStatusConditionsOutput() HelmReleaseStatusConditionsOutput {
	return i.ToHelmReleaseStatusConditionsOutputWithContext(context.Background())
}

func (i HelmReleaseStatusConditionsArgs) ToHelmReleaseStatusConditionsOutputWithContext(ctx context.Context) HelmReleaseStatusConditionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HelmReleaseStatusConditionsOutput)
}

// HelmReleaseStatusConditionsArrayInput is an input type that accepts HelmReleaseStatusConditionsArray and HelmReleaseStatusConditionsArrayOutput values.
// You can construct a concrete instance of `HelmReleaseStatusConditionsArrayInput` via:
//
//          HelmReleaseStatusConditionsArray{ HelmReleaseStatusConditionsArgs{...} }
type HelmReleaseStatusConditionsArrayInput interface {
	pulumi.Input

	ToHelmReleaseStatusConditionsArrayOutput() HelmReleaseStatusConditionsArrayOutput
	ToHelmReleaseStatusConditionsArrayOutputWithContext(context.Context) HelmReleaseStatusConditionsArrayOutput
}

type HelmReleaseStatusConditionsArray []HelmReleaseStatusConditionsInput

func (HelmReleaseStatusConditionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HelmReleaseStatusConditions)(nil)).Elem()
}

func (i HelmReleaseStatusConditionsArray) ToHelmReleaseStatusConditionsArrayOutput() HelmReleaseStatusConditionsArrayOutput {
	return i.ToHelmReleaseStatusConditionsArrayOutputWithContext(context.Background())
}

func (i HelmReleaseStatusConditionsArray) ToHelmReleaseStatusConditionsArrayOutputWithContext(ctx context.Context) HelmReleaseStatusConditionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HelmReleaseStatusConditionsArrayOutput)
}

type HelmReleaseStatusConditionsOutput struct{ *pulumi.OutputState }

func (HelmReleaseStatusConditionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HelmReleaseStatusConditions)(nil)).Elem()
}

func (o HelmReleaseStatusConditionsOutput) ToHelmReleaseStatusConditionsOutput() HelmReleaseStatusConditionsOutput {
	return o
}

func (o HelmReleaseStatusConditionsOutput) ToHelmReleaseStatusConditionsOutputWithContext(ctx context.Context) HelmReleaseStatusConditionsOutput {
	return o
}

func (o HelmReleaseStatusConditionsOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HelmReleaseStatusConditions) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

func (o HelmReleaseStatusConditionsOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HelmReleaseStatusConditions) *string { return v.Message }).(pulumi.StringPtrOutput)
}

func (o HelmReleaseStatusConditionsOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HelmReleaseStatusConditions) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

func (o HelmReleaseStatusConditionsOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v HelmReleaseStatusConditions) string { return v.Status }).(pulumi.StringOutput)
}

func (o HelmReleaseStatusConditionsOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v HelmReleaseStatusConditions) string { return v.Type }).(pulumi.StringOutput)
}

type HelmReleaseStatusConditionsArrayOutput struct{ *pulumi.OutputState }

func (HelmReleaseStatusConditionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HelmReleaseStatusConditions)(nil)).Elem()
}

func (o HelmReleaseStatusConditionsArrayOutput) ToHelmReleaseStatusConditionsArrayOutput() HelmReleaseStatusConditionsArrayOutput {
	return o
}

func (o HelmReleaseStatusConditionsArrayOutput) ToHelmReleaseStatusConditionsArrayOutputWithContext(ctx context.Context) HelmReleaseStatusConditionsArrayOutput {
	return o
}

func (o HelmReleaseStatusConditionsArrayOutput) Index(i pulumi.IntInput) HelmReleaseStatusConditionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HelmReleaseStatusConditions {
		return vs[0].([]HelmReleaseStatusConditions)[vs[1].(int)]
	}).(HelmReleaseStatusConditionsOutput)
}

type HelmReleaseStatusDeployedRelease struct {
	Manifest *string `pulumi:"manifest"`
	Name     *string `pulumi:"name"`
}

// HelmReleaseStatusDeployedReleaseInput is an input type that accepts HelmReleaseStatusDeployedReleaseArgs and HelmReleaseStatusDeployedReleaseOutput values.
// You can construct a concrete instance of `HelmReleaseStatusDeployedReleaseInput` via:
//
//          HelmReleaseStatusDeployedReleaseArgs{...}
type HelmReleaseStatusDeployedReleaseInput interface {
	pulumi.Input

	ToHelmReleaseStatusDeployedReleaseOutput() HelmReleaseStatusDeployedReleaseOutput
	ToHelmReleaseStatusDeployedReleaseOutputWithContext(context.Context) HelmReleaseStatusDeployedReleaseOutput
}

type HelmReleaseStatusDeployedReleaseArgs struct {
	Manifest pulumi.StringPtrInput `pulumi:"manifest"`
	Name     pulumi.StringPtrInput `pulumi:"name"`
}

func (HelmReleaseStatusDeployedReleaseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HelmReleaseStatusDeployedRelease)(nil)).Elem()
}

func (i HelmReleaseStatusDeployedReleaseArgs) ToHelmReleaseStatusDeployedReleaseOutput() HelmReleaseStatusDeployedReleaseOutput {
	return i.ToHelmReleaseStatusDeployedReleaseOutputWithContext(context.Background())
}

func (i HelmReleaseStatusDeployedReleaseArgs) ToHelmReleaseStatusDeployedReleaseOutputWithContext(ctx context.Context) HelmReleaseStatusDeployedReleaseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HelmReleaseStatusDeployedReleaseOutput)
}

func (i HelmReleaseStatusDeployedReleaseArgs) ToHelmReleaseStatusDeployedReleasePtrOutput() HelmReleaseStatusDeployedReleasePtrOutput {
	return i.ToHelmReleaseStatusDeployedReleasePtrOutputWithContext(context.Background())
}

func (i HelmReleaseStatusDeployedReleaseArgs) ToHelmReleaseStatusDeployedReleasePtrOutputWithContext(ctx context.Context) HelmReleaseStatusDeployedReleasePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HelmReleaseStatusDeployedReleaseOutput).ToHelmReleaseStatusDeployedReleasePtrOutputWithContext(ctx)
}

// HelmReleaseStatusDeployedReleasePtrInput is an input type that accepts HelmReleaseStatusDeployedReleaseArgs, HelmReleaseStatusDeployedReleasePtr and HelmReleaseStatusDeployedReleasePtrOutput values.
// You can construct a concrete instance of `HelmReleaseStatusDeployedReleasePtrInput` via:
//
//          HelmReleaseStatusDeployedReleaseArgs{...}
//
//  or:
//
//          nil
type HelmReleaseStatusDeployedReleasePtrInput interface {
	pulumi.Input

	ToHelmReleaseStatusDeployedReleasePtrOutput() HelmReleaseStatusDeployedReleasePtrOutput
	ToHelmReleaseStatusDeployedReleasePtrOutputWithContext(context.Context) HelmReleaseStatusDeployedReleasePtrOutput
}

type helmReleaseStatusDeployedReleasePtrType HelmReleaseStatusDeployedReleaseArgs

func HelmReleaseStatusDeployedReleasePtr(v *HelmReleaseStatusDeployedReleaseArgs) HelmReleaseStatusDeployedReleasePtrInput {
	return (*helmReleaseStatusDeployedReleasePtrType)(v)
}

func (*helmReleaseStatusDeployedReleasePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HelmReleaseStatusDeployedRelease)(nil)).Elem()
}

func (i *helmReleaseStatusDeployedReleasePtrType) ToHelmReleaseStatusDeployedReleasePtrOutput() HelmReleaseStatusDeployedReleasePtrOutput {
	return i.ToHelmReleaseStatusDeployedReleasePtrOutputWithContext(context.Background())
}

func (i *helmReleaseStatusDeployedReleasePtrType) ToHelmReleaseStatusDeployedReleasePtrOutputWithContext(ctx context.Context) HelmReleaseStatusDeployedReleasePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HelmReleaseStatusDeployedReleasePtrOutput)
}

type HelmReleaseStatusDeployedReleaseOutput struct{ *pulumi.OutputState }

func (HelmReleaseStatusDeployedReleaseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HelmReleaseStatusDeployedRelease)(nil)).Elem()
}

func (o HelmReleaseStatusDeployedReleaseOutput) ToHelmReleaseStatusDeployedReleaseOutput() HelmReleaseStatusDeployedReleaseOutput {
	return o
}

func (o HelmReleaseStatusDeployedReleaseOutput) ToHelmReleaseStatusDeployedReleaseOutputWithContext(ctx context.Context) HelmReleaseStatusDeployedReleaseOutput {
	return o
}

func (o HelmReleaseStatusDeployedReleaseOutput) ToHelmReleaseStatusDeployedReleasePtrOutput() HelmReleaseStatusDeployedReleasePtrOutput {
	return o.ToHelmReleaseStatusDeployedReleasePtrOutputWithContext(context.Background())
}

func (o HelmReleaseStatusDeployedReleaseOutput) ToHelmReleaseStatusDeployedReleasePtrOutputWithContext(ctx context.Context) HelmReleaseStatusDeployedReleasePtrOutput {
	return o.ApplyT(func(v HelmReleaseStatusDeployedRelease) *HelmReleaseStatusDeployedRelease {
		return &v
	}).(HelmReleaseStatusDeployedReleasePtrOutput)
}
func (o HelmReleaseStatusDeployedReleaseOutput) Manifest() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HelmReleaseStatusDeployedRelease) *string { return v.Manifest }).(pulumi.StringPtrOutput)
}

func (o HelmReleaseStatusDeployedReleaseOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HelmReleaseStatusDeployedRelease) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type HelmReleaseStatusDeployedReleasePtrOutput struct{ *pulumi.OutputState }

func (HelmReleaseStatusDeployedReleasePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HelmReleaseStatusDeployedRelease)(nil)).Elem()
}

func (o HelmReleaseStatusDeployedReleasePtrOutput) ToHelmReleaseStatusDeployedReleasePtrOutput() HelmReleaseStatusDeployedReleasePtrOutput {
	return o
}

func (o HelmReleaseStatusDeployedReleasePtrOutput) ToHelmReleaseStatusDeployedReleasePtrOutputWithContext(ctx context.Context) HelmReleaseStatusDeployedReleasePtrOutput {
	return o
}

func (o HelmReleaseStatusDeployedReleasePtrOutput) Elem() HelmReleaseStatusDeployedReleaseOutput {
	return o.ApplyT(func(v *HelmReleaseStatusDeployedRelease) HelmReleaseStatusDeployedRelease { return *v }).(HelmReleaseStatusDeployedReleaseOutput)
}

func (o HelmReleaseStatusDeployedReleasePtrOutput) Manifest() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HelmReleaseStatusDeployedRelease) *string {
		if v == nil {
			return nil
		}
		return v.Manifest
	}).(pulumi.StringPtrOutput)
}

func (o HelmReleaseStatusDeployedReleasePtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HelmReleaseStatusDeployedRelease) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// PlacementRule is the Schema for the placementrules API
type PlacementRuleType struct {
	ApiVersion *string            `pulumi:"apiVersion"`
	Kind       *string            `pulumi:"kind"`
	Metadata   *metav1.ObjectMeta `pulumi:"metadata"`
	// PlacementRuleSpec defines the desired state of PlacementRule
	Spec *PlacementRuleSpec `pulumi:"spec"`
	// PlacementRuleStatus defines the observed state of PlacementRule
	Status *PlacementRuleStatus `pulumi:"status"`
}

// PlacementRuleTypeInput is an input type that accepts PlacementRuleTypeArgs and PlacementRuleTypeOutput values.
// You can construct a concrete instance of `PlacementRuleTypeInput` via:
//
//          PlacementRuleTypeArgs{...}
type PlacementRuleTypeInput interface {
	pulumi.Input

	ToPlacementRuleTypeOutput() PlacementRuleTypeOutput
	ToPlacementRuleTypeOutputWithContext(context.Context) PlacementRuleTypeOutput
}

// PlacementRule is the Schema for the placementrules API
type PlacementRuleTypeArgs struct {
	ApiVersion pulumi.StringPtrInput     `pulumi:"apiVersion"`
	Kind       pulumi.StringPtrInput     `pulumi:"kind"`
	Metadata   metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	// PlacementRuleSpec defines the desired state of PlacementRule
	Spec PlacementRuleSpecPtrInput `pulumi:"spec"`
	// PlacementRuleStatus defines the observed state of PlacementRule
	Status PlacementRuleStatusPtrInput `pulumi:"status"`
}

func (PlacementRuleTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PlacementRuleType)(nil)).Elem()
}

func (i PlacementRuleTypeArgs) ToPlacementRuleTypeOutput() PlacementRuleTypeOutput {
	return i.ToPlacementRuleTypeOutputWithContext(context.Background())
}

func (i PlacementRuleTypeArgs) ToPlacementRuleTypeOutputWithContext(ctx context.Context) PlacementRuleTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PlacementRuleTypeOutput)
}

// PlacementRule is the Schema for the placementrules API
type PlacementRuleTypeOutput struct{ *pulumi.OutputState }

func (PlacementRuleTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PlacementRuleType)(nil)).Elem()
}

func (o PlacementRuleTypeOutput) ToPlacementRuleTypeOutput() PlacementRuleTypeOutput {
	return o
}

func (o PlacementRuleTypeOutput) ToPlacementRuleTypeOutputWithContext(ctx context.Context) PlacementRuleTypeOutput {
	return o
}

func (o PlacementRuleTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PlacementRuleType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

func (o PlacementRuleTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PlacementRuleType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

func (o PlacementRuleTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v PlacementRuleType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

// PlacementRuleSpec defines the desired state of PlacementRule
func (o PlacementRuleTypeOutput) Spec() PlacementRuleSpecPtrOutput {
	return o.ApplyT(func(v PlacementRuleType) *PlacementRuleSpec { return v.Spec }).(PlacementRuleSpecPtrOutput)
}

// PlacementRuleStatus defines the observed state of PlacementRule
func (o PlacementRuleTypeOutput) Status() PlacementRuleStatusPtrOutput {
	return o.ApplyT(func(v PlacementRuleType) *PlacementRuleStatus { return v.Status }).(PlacementRuleStatusPtrOutput)
}

type PlacementRuleMetadata struct {
}

// PlacementRuleMetadataInput is an input type that accepts PlacementRuleMetadataArgs and PlacementRuleMetadataOutput values.
// You can construct a concrete instance of `PlacementRuleMetadataInput` via:
//
//          PlacementRuleMetadataArgs{...}
type PlacementRuleMetadataInput interface {
	pulumi.Input

	ToPlacementRuleMetadataOutput() PlacementRuleMetadataOutput
	ToPlacementRuleMetadataOutputWithContext(context.Context) PlacementRuleMetadataOutput
}

type PlacementRuleMetadataArgs struct {
}

func (PlacementRuleMetadataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PlacementRuleMetadata)(nil)).Elem()
}

func (i PlacementRuleMetadataArgs) ToPlacementRuleMetadataOutput() PlacementRuleMetadataOutput {
	return i.ToPlacementRuleMetadataOutputWithContext(context.Background())
}

func (i PlacementRuleMetadataArgs) ToPlacementRuleMetadataOutputWithContext(ctx context.Context) PlacementRuleMetadataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PlacementRuleMetadataOutput)
}

type PlacementRuleMetadataOutput struct{ *pulumi.OutputState }

func (PlacementRuleMetadataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PlacementRuleMetadata)(nil)).Elem()
}

func (o PlacementRuleMetadataOutput) ToPlacementRuleMetadataOutput() PlacementRuleMetadataOutput {
	return o
}

func (o PlacementRuleMetadataOutput) ToPlacementRuleMetadataOutputWithContext(ctx context.Context) PlacementRuleMetadataOutput {
	return o
}

// PlacementRuleSpec defines the desired state of PlacementRule
type PlacementRuleSpec struct {
	ClusterConditions []PlacementRuleSpecClusterConditions `pulumi:"clusterConditions"`
	// number of replicas Application wants to
	ClusterReplicas *int `pulumi:"clusterReplicas"`
	// A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
	ClusterSelector *PlacementRuleSpecClusterSelector `pulumi:"clusterSelector"`
	Clusters        []PlacementRuleSpecClusters       `pulumi:"clusters"`
	// Set Policy Filters
	Policies []PlacementRuleSpecPolicies `pulumi:"policies"`
	// Select Resource
	ResourceHint *PlacementRuleSpecResourceHint `pulumi:"resourceHint"`
	// INSERT ADDITIONAL SPEC FIELDS - desired state of cluster Important: Run "make" to regenerate code after modifying this file schedulerName, default to use mcm controller
	SchedulerName *string `pulumi:"schedulerName"`
}

// PlacementRuleSpecInput is an input type that accepts PlacementRuleSpecArgs and PlacementRuleSpecOutput values.
// You can construct a concrete instance of `PlacementRuleSpecInput` via:
//
//          PlacementRuleSpecArgs{...}
type PlacementRuleSpecInput interface {
	pulumi.Input

	ToPlacementRuleSpecOutput() PlacementRuleSpecOutput
	ToPlacementRuleSpecOutputWithContext(context.Context) PlacementRuleSpecOutput
}

// PlacementRuleSpec defines the desired state of PlacementRule
type PlacementRuleSpecArgs struct {
	ClusterConditions PlacementRuleSpecClusterConditionsArrayInput `pulumi:"clusterConditions"`
	// number of replicas Application wants to
	ClusterReplicas pulumi.IntPtrInput `pulumi:"clusterReplicas"`
	// A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
	ClusterSelector PlacementRuleSpecClusterSelectorPtrInput `pulumi:"clusterSelector"`
	Clusters        PlacementRuleSpecClustersArrayInput      `pulumi:"clusters"`
	// Set Policy Filters
	Policies PlacementRuleSpecPoliciesArrayInput `pulumi:"policies"`
	// Select Resource
	ResourceHint PlacementRuleSpecResourceHintPtrInput `pulumi:"resourceHint"`
	// INSERT ADDITIONAL SPEC FIELDS - desired state of cluster Important: Run "make" to regenerate code after modifying this file schedulerName, default to use mcm controller
	SchedulerName pulumi.StringPtrInput `pulumi:"schedulerName"`
}

func (PlacementRuleSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PlacementRuleSpec)(nil)).Elem()
}

func (i PlacementRuleSpecArgs) ToPlacementRuleSpecOutput() PlacementRuleSpecOutput {
	return i.ToPlacementRuleSpecOutputWithContext(context.Background())
}

func (i PlacementRuleSpecArgs) ToPlacementRuleSpecOutputWithContext(ctx context.Context) PlacementRuleSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PlacementRuleSpecOutput)
}

func (i PlacementRuleSpecArgs) ToPlacementRuleSpecPtrOutput() PlacementRuleSpecPtrOutput {
	return i.ToPlacementRuleSpecPtrOutputWithContext(context.Background())
}

func (i PlacementRuleSpecArgs) ToPlacementRuleSpecPtrOutputWithContext(ctx context.Context) PlacementRuleSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PlacementRuleSpecOutput).ToPlacementRuleSpecPtrOutputWithContext(ctx)
}

// PlacementRuleSpecPtrInput is an input type that accepts PlacementRuleSpecArgs, PlacementRuleSpecPtr and PlacementRuleSpecPtrOutput values.
// You can construct a concrete instance of `PlacementRuleSpecPtrInput` via:
//
//          PlacementRuleSpecArgs{...}
//
//  or:
//
//          nil
type PlacementRuleSpecPtrInput interface {
	pulumi.Input

	ToPlacementRuleSpecPtrOutput() PlacementRuleSpecPtrOutput
	ToPlacementRuleSpecPtrOutputWithContext(context.Context) PlacementRuleSpecPtrOutput
}

type placementRuleSpecPtrType PlacementRuleSpecArgs

func PlacementRuleSpecPtr(v *PlacementRuleSpecArgs) PlacementRuleSpecPtrInput {
	return (*placementRuleSpecPtrType)(v)
}

func (*placementRuleSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PlacementRuleSpec)(nil)).Elem()
}

func (i *placementRuleSpecPtrType) ToPlacementRuleSpecPtrOutput() PlacementRuleSpecPtrOutput {
	return i.ToPlacementRuleSpecPtrOutputWithContext(context.Background())
}

func (i *placementRuleSpecPtrType) ToPlacementRuleSpecPtrOutputWithContext(ctx context.Context) PlacementRuleSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PlacementRuleSpecPtrOutput)
}

// PlacementRuleSpec defines the desired state of PlacementRule
type PlacementRuleSpecOutput struct{ *pulumi.OutputState }

func (PlacementRuleSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PlacementRuleSpec)(nil)).Elem()
}

func (o PlacementRuleSpecOutput) ToPlacementRuleSpecOutput() PlacementRuleSpecOutput {
	return o
}

func (o PlacementRuleSpecOutput) ToPlacementRuleSpecOutputWithContext(ctx context.Context) PlacementRuleSpecOutput {
	return o
}

func (o PlacementRuleSpecOutput) ToPlacementRuleSpecPtrOutput() PlacementRuleSpecPtrOutput {
	return o.ToPlacementRuleSpecPtrOutputWithContext(context.Background())
}

func (o PlacementRuleSpecOutput) ToPlacementRuleSpecPtrOutputWithContext(ctx context.Context) PlacementRuleSpecPtrOutput {
	return o.ApplyT(func(v PlacementRuleSpec) *PlacementRuleSpec {
		return &v
	}).(PlacementRuleSpecPtrOutput)
}
func (o PlacementRuleSpecOutput) ClusterConditions() PlacementRuleSpecClusterConditionsArrayOutput {
	return o.ApplyT(func(v PlacementRuleSpec) []PlacementRuleSpecClusterConditions { return v.ClusterConditions }).(PlacementRuleSpecClusterConditionsArrayOutput)
}

// number of replicas Application wants to
func (o PlacementRuleSpecOutput) ClusterReplicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v PlacementRuleSpec) *int { return v.ClusterReplicas }).(pulumi.IntPtrOutput)
}

// A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
func (o PlacementRuleSpecOutput) ClusterSelector() PlacementRuleSpecClusterSelectorPtrOutput {
	return o.ApplyT(func(v PlacementRuleSpec) *PlacementRuleSpecClusterSelector { return v.ClusterSelector }).(PlacementRuleSpecClusterSelectorPtrOutput)
}

func (o PlacementRuleSpecOutput) Clusters() PlacementRuleSpecClustersArrayOutput {
	return o.ApplyT(func(v PlacementRuleSpec) []PlacementRuleSpecClusters { return v.Clusters }).(PlacementRuleSpecClustersArrayOutput)
}

// Set Policy Filters
func (o PlacementRuleSpecOutput) Policies() PlacementRuleSpecPoliciesArrayOutput {
	return o.ApplyT(func(v PlacementRuleSpec) []PlacementRuleSpecPolicies { return v.Policies }).(PlacementRuleSpecPoliciesArrayOutput)
}

// Select Resource
func (o PlacementRuleSpecOutput) ResourceHint() PlacementRuleSpecResourceHintPtrOutput {
	return o.ApplyT(func(v PlacementRuleSpec) *PlacementRuleSpecResourceHint { return v.ResourceHint }).(PlacementRuleSpecResourceHintPtrOutput)
}

// INSERT ADDITIONAL SPEC FIELDS - desired state of cluster Important: Run "make" to regenerate code after modifying this file schedulerName, default to use mcm controller
func (o PlacementRuleSpecOutput) SchedulerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PlacementRuleSpec) *string { return v.SchedulerName }).(pulumi.StringPtrOutput)
}

type PlacementRuleSpecPtrOutput struct{ *pulumi.OutputState }

func (PlacementRuleSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PlacementRuleSpec)(nil)).Elem()
}

func (o PlacementRuleSpecPtrOutput) ToPlacementRuleSpecPtrOutput() PlacementRuleSpecPtrOutput {
	return o
}

func (o PlacementRuleSpecPtrOutput) ToPlacementRuleSpecPtrOutputWithContext(ctx context.Context) PlacementRuleSpecPtrOutput {
	return o
}

func (o PlacementRuleSpecPtrOutput) Elem() PlacementRuleSpecOutput {
	return o.ApplyT(func(v *PlacementRuleSpec) PlacementRuleSpec { return *v }).(PlacementRuleSpecOutput)
}

func (o PlacementRuleSpecPtrOutput) ClusterConditions() PlacementRuleSpecClusterConditionsArrayOutput {
	return o.ApplyT(func(v *PlacementRuleSpec) []PlacementRuleSpecClusterConditions {
		if v == nil {
			return nil
		}
		return v.ClusterConditions
	}).(PlacementRuleSpecClusterConditionsArrayOutput)
}

// number of replicas Application wants to
func (o PlacementRuleSpecPtrOutput) ClusterReplicas() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *PlacementRuleSpec) *int {
		if v == nil {
			return nil
		}
		return v.ClusterReplicas
	}).(pulumi.IntPtrOutput)
}

// A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
func (o PlacementRuleSpecPtrOutput) ClusterSelector() PlacementRuleSpecClusterSelectorPtrOutput {
	return o.ApplyT(func(v *PlacementRuleSpec) *PlacementRuleSpecClusterSelector {
		if v == nil {
			return nil
		}
		return v.ClusterSelector
	}).(PlacementRuleSpecClusterSelectorPtrOutput)
}

func (o PlacementRuleSpecPtrOutput) Clusters() PlacementRuleSpecClustersArrayOutput {
	return o.ApplyT(func(v *PlacementRuleSpec) []PlacementRuleSpecClusters {
		if v == nil {
			return nil
		}
		return v.Clusters
	}).(PlacementRuleSpecClustersArrayOutput)
}

// Set Policy Filters
func (o PlacementRuleSpecPtrOutput) Policies() PlacementRuleSpecPoliciesArrayOutput {
	return o.ApplyT(func(v *PlacementRuleSpec) []PlacementRuleSpecPolicies {
		if v == nil {
			return nil
		}
		return v.Policies
	}).(PlacementRuleSpecPoliciesArrayOutput)
}

// Select Resource
func (o PlacementRuleSpecPtrOutput) ResourceHint() PlacementRuleSpecResourceHintPtrOutput {
	return o.ApplyT(func(v *PlacementRuleSpec) *PlacementRuleSpecResourceHint {
		if v == nil {
			return nil
		}
		return v.ResourceHint
	}).(PlacementRuleSpecResourceHintPtrOutput)
}

// INSERT ADDITIONAL SPEC FIELDS - desired state of cluster Important: Run "make" to regenerate code after modifying this file schedulerName, default to use mcm controller
func (o PlacementRuleSpecPtrOutput) SchedulerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PlacementRuleSpec) *string {
		if v == nil {
			return nil
		}
		return v.SchedulerName
	}).(pulumi.StringPtrOutput)
}

// ClusterConditionFilter defines filter to filter cluster condition
type PlacementRuleSpecClusterConditions struct {
	Status *string `pulumi:"status"`
	Type   *string `pulumi:"type"`
}

// PlacementRuleSpecClusterConditionsInput is an input type that accepts PlacementRuleSpecClusterConditionsArgs and PlacementRuleSpecClusterConditionsOutput values.
// You can construct a concrete instance of `PlacementRuleSpecClusterConditionsInput` via:
//
//          PlacementRuleSpecClusterConditionsArgs{...}
type PlacementRuleSpecClusterConditionsInput interface {
	pulumi.Input

	ToPlacementRuleSpecClusterConditionsOutput() PlacementRuleSpecClusterConditionsOutput
	ToPlacementRuleSpecClusterConditionsOutputWithContext(context.Context) PlacementRuleSpecClusterConditionsOutput
}

// ClusterConditionFilter defines filter to filter cluster condition
type PlacementRuleSpecClusterConditionsArgs struct {
	Status pulumi.StringPtrInput `pulumi:"status"`
	Type   pulumi.StringPtrInput `pulumi:"type"`
}

func (PlacementRuleSpecClusterConditionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PlacementRuleSpecClusterConditions)(nil)).Elem()
}

func (i PlacementRuleSpecClusterConditionsArgs) ToPlacementRuleSpecClusterConditionsOutput() PlacementRuleSpecClusterConditionsOutput {
	return i.ToPlacementRuleSpecClusterConditionsOutputWithContext(context.Background())
}

func (i PlacementRuleSpecClusterConditionsArgs) ToPlacementRuleSpecClusterConditionsOutputWithContext(ctx context.Context) PlacementRuleSpecClusterConditionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PlacementRuleSpecClusterConditionsOutput)
}

// PlacementRuleSpecClusterConditionsArrayInput is an input type that accepts PlacementRuleSpecClusterConditionsArray and PlacementRuleSpecClusterConditionsArrayOutput values.
// You can construct a concrete instance of `PlacementRuleSpecClusterConditionsArrayInput` via:
//
//          PlacementRuleSpecClusterConditionsArray{ PlacementRuleSpecClusterConditionsArgs{...} }
type PlacementRuleSpecClusterConditionsArrayInput interface {
	pulumi.Input

	ToPlacementRuleSpecClusterConditionsArrayOutput() PlacementRuleSpecClusterConditionsArrayOutput
	ToPlacementRuleSpecClusterConditionsArrayOutputWithContext(context.Context) PlacementRuleSpecClusterConditionsArrayOutput
}

type PlacementRuleSpecClusterConditionsArray []PlacementRuleSpecClusterConditionsInput

func (PlacementRuleSpecClusterConditionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PlacementRuleSpecClusterConditions)(nil)).Elem()
}

func (i PlacementRuleSpecClusterConditionsArray) ToPlacementRuleSpecClusterConditionsArrayOutput() PlacementRuleSpecClusterConditionsArrayOutput {
	return i.ToPlacementRuleSpecClusterConditionsArrayOutputWithContext(context.Background())
}

func (i PlacementRuleSpecClusterConditionsArray) ToPlacementRuleSpecClusterConditionsArrayOutputWithContext(ctx context.Context) PlacementRuleSpecClusterConditionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PlacementRuleSpecClusterConditionsArrayOutput)
}

// ClusterConditionFilter defines filter to filter cluster condition
type PlacementRuleSpecClusterConditionsOutput struct{ *pulumi.OutputState }

func (PlacementRuleSpecClusterConditionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PlacementRuleSpecClusterConditions)(nil)).Elem()
}

func (o PlacementRuleSpecClusterConditionsOutput) ToPlacementRuleSpecClusterConditionsOutput() PlacementRuleSpecClusterConditionsOutput {
	return o
}

func (o PlacementRuleSpecClusterConditionsOutput) ToPlacementRuleSpecClusterConditionsOutputWithContext(ctx context.Context) PlacementRuleSpecClusterConditionsOutput {
	return o
}

func (o PlacementRuleSpecClusterConditionsOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PlacementRuleSpecClusterConditions) *string { return v.Status }).(pulumi.StringPtrOutput)
}

func (o PlacementRuleSpecClusterConditionsOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PlacementRuleSpecClusterConditions) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type PlacementRuleSpecClusterConditionsArrayOutput struct{ *pulumi.OutputState }

func (PlacementRuleSpecClusterConditionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PlacementRuleSpecClusterConditions)(nil)).Elem()
}

func (o PlacementRuleSpecClusterConditionsArrayOutput) ToPlacementRuleSpecClusterConditionsArrayOutput() PlacementRuleSpecClusterConditionsArrayOutput {
	return o
}

func (o PlacementRuleSpecClusterConditionsArrayOutput) ToPlacementRuleSpecClusterConditionsArrayOutputWithContext(ctx context.Context) PlacementRuleSpecClusterConditionsArrayOutput {
	return o
}

func (o PlacementRuleSpecClusterConditionsArrayOutput) Index(i pulumi.IntInput) PlacementRuleSpecClusterConditionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) PlacementRuleSpecClusterConditions {
		return vs[0].([]PlacementRuleSpecClusterConditions)[vs[1].(int)]
	}).(PlacementRuleSpecClusterConditionsOutput)
}

// A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
type PlacementRuleSpecClusterSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []PlacementRuleSpecClusterSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// PlacementRuleSpecClusterSelectorInput is an input type that accepts PlacementRuleSpecClusterSelectorArgs and PlacementRuleSpecClusterSelectorOutput values.
// You can construct a concrete instance of `PlacementRuleSpecClusterSelectorInput` via:
//
//          PlacementRuleSpecClusterSelectorArgs{...}
type PlacementRuleSpecClusterSelectorInput interface {
	pulumi.Input

	ToPlacementRuleSpecClusterSelectorOutput() PlacementRuleSpecClusterSelectorOutput
	ToPlacementRuleSpecClusterSelectorOutputWithContext(context.Context) PlacementRuleSpecClusterSelectorOutput
}

// A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
type PlacementRuleSpecClusterSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions PlacementRuleSpecClusterSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (PlacementRuleSpecClusterSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PlacementRuleSpecClusterSelector)(nil)).Elem()
}

func (i PlacementRuleSpecClusterSelectorArgs) ToPlacementRuleSpecClusterSelectorOutput() PlacementRuleSpecClusterSelectorOutput {
	return i.ToPlacementRuleSpecClusterSelectorOutputWithContext(context.Background())
}

func (i PlacementRuleSpecClusterSelectorArgs) ToPlacementRuleSpecClusterSelectorOutputWithContext(ctx context.Context) PlacementRuleSpecClusterSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PlacementRuleSpecClusterSelectorOutput)
}

func (i PlacementRuleSpecClusterSelectorArgs) ToPlacementRuleSpecClusterSelectorPtrOutput() PlacementRuleSpecClusterSelectorPtrOutput {
	return i.ToPlacementRuleSpecClusterSelectorPtrOutputWithContext(context.Background())
}

func (i PlacementRuleSpecClusterSelectorArgs) ToPlacementRuleSpecClusterSelectorPtrOutputWithContext(ctx context.Context) PlacementRuleSpecClusterSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PlacementRuleSpecClusterSelectorOutput).ToPlacementRuleSpecClusterSelectorPtrOutputWithContext(ctx)
}

// PlacementRuleSpecClusterSelectorPtrInput is an input type that accepts PlacementRuleSpecClusterSelectorArgs, PlacementRuleSpecClusterSelectorPtr and PlacementRuleSpecClusterSelectorPtrOutput values.
// You can construct a concrete instance of `PlacementRuleSpecClusterSelectorPtrInput` via:
//
//          PlacementRuleSpecClusterSelectorArgs{...}
//
//  or:
//
//          nil
type PlacementRuleSpecClusterSelectorPtrInput interface {
	pulumi.Input

	ToPlacementRuleSpecClusterSelectorPtrOutput() PlacementRuleSpecClusterSelectorPtrOutput
	ToPlacementRuleSpecClusterSelectorPtrOutputWithContext(context.Context) PlacementRuleSpecClusterSelectorPtrOutput
}

type placementRuleSpecClusterSelectorPtrType PlacementRuleSpecClusterSelectorArgs

func PlacementRuleSpecClusterSelectorPtr(v *PlacementRuleSpecClusterSelectorArgs) PlacementRuleSpecClusterSelectorPtrInput {
	return (*placementRuleSpecClusterSelectorPtrType)(v)
}

func (*placementRuleSpecClusterSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PlacementRuleSpecClusterSelector)(nil)).Elem()
}

func (i *placementRuleSpecClusterSelectorPtrType) ToPlacementRuleSpecClusterSelectorPtrOutput() PlacementRuleSpecClusterSelectorPtrOutput {
	return i.ToPlacementRuleSpecClusterSelectorPtrOutputWithContext(context.Background())
}

func (i *placementRuleSpecClusterSelectorPtrType) ToPlacementRuleSpecClusterSelectorPtrOutputWithContext(ctx context.Context) PlacementRuleSpecClusterSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PlacementRuleSpecClusterSelectorPtrOutput)
}

// A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
type PlacementRuleSpecClusterSelectorOutput struct{ *pulumi.OutputState }

func (PlacementRuleSpecClusterSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PlacementRuleSpecClusterSelector)(nil)).Elem()
}

func (o PlacementRuleSpecClusterSelectorOutput) ToPlacementRuleSpecClusterSelectorOutput() PlacementRuleSpecClusterSelectorOutput {
	return o
}

func (o PlacementRuleSpecClusterSelectorOutput) ToPlacementRuleSpecClusterSelectorOutputWithContext(ctx context.Context) PlacementRuleSpecClusterSelectorOutput {
	return o
}

func (o PlacementRuleSpecClusterSelectorOutput) ToPlacementRuleSpecClusterSelectorPtrOutput() PlacementRuleSpecClusterSelectorPtrOutput {
	return o.ToPlacementRuleSpecClusterSelectorPtrOutputWithContext(context.Background())
}

func (o PlacementRuleSpecClusterSelectorOutput) ToPlacementRuleSpecClusterSelectorPtrOutputWithContext(ctx context.Context) PlacementRuleSpecClusterSelectorPtrOutput {
	return o.ApplyT(func(v PlacementRuleSpecClusterSelector) *PlacementRuleSpecClusterSelector {
		return &v
	}).(PlacementRuleSpecClusterSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o PlacementRuleSpecClusterSelectorOutput) MatchExpressions() PlacementRuleSpecClusterSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v PlacementRuleSpecClusterSelector) []PlacementRuleSpecClusterSelectorMatchExpressions {
		return v.MatchExpressions
	}).(PlacementRuleSpecClusterSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o PlacementRuleSpecClusterSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v PlacementRuleSpecClusterSelector) map[string]string { return v.MatchLabels }).(pulumi.StringMapOutput)
}

type PlacementRuleSpecClusterSelectorPtrOutput struct{ *pulumi.OutputState }

func (PlacementRuleSpecClusterSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PlacementRuleSpecClusterSelector)(nil)).Elem()
}

func (o PlacementRuleSpecClusterSelectorPtrOutput) ToPlacementRuleSpecClusterSelectorPtrOutput() PlacementRuleSpecClusterSelectorPtrOutput {
	return o
}

func (o PlacementRuleSpecClusterSelectorPtrOutput) ToPlacementRuleSpecClusterSelectorPtrOutputWithContext(ctx context.Context) PlacementRuleSpecClusterSelectorPtrOutput {
	return o
}

func (o PlacementRuleSpecClusterSelectorPtrOutput) Elem() PlacementRuleSpecClusterSelectorOutput {
	return o.ApplyT(func(v *PlacementRuleSpecClusterSelector) PlacementRuleSpecClusterSelector { return *v }).(PlacementRuleSpecClusterSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o PlacementRuleSpecClusterSelectorPtrOutput) MatchExpressions() PlacementRuleSpecClusterSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *PlacementRuleSpecClusterSelector) []PlacementRuleSpecClusterSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(PlacementRuleSpecClusterSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o PlacementRuleSpecClusterSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *PlacementRuleSpecClusterSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type PlacementRuleSpecClusterSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// PlacementRuleSpecClusterSelectorMatchExpressionsInput is an input type that accepts PlacementRuleSpecClusterSelectorMatchExpressionsArgs and PlacementRuleSpecClusterSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `PlacementRuleSpecClusterSelectorMatchExpressionsInput` via:
//
//          PlacementRuleSpecClusterSelectorMatchExpressionsArgs{...}
type PlacementRuleSpecClusterSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToPlacementRuleSpecClusterSelectorMatchExpressionsOutput() PlacementRuleSpecClusterSelectorMatchExpressionsOutput
	ToPlacementRuleSpecClusterSelectorMatchExpressionsOutputWithContext(context.Context) PlacementRuleSpecClusterSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type PlacementRuleSpecClusterSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (PlacementRuleSpecClusterSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PlacementRuleSpecClusterSelectorMatchExpressions)(nil)).Elem()
}

func (i PlacementRuleSpecClusterSelectorMatchExpressionsArgs) ToPlacementRuleSpecClusterSelectorMatchExpressionsOutput() PlacementRuleSpecClusterSelectorMatchExpressionsOutput {
	return i.ToPlacementRuleSpecClusterSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i PlacementRuleSpecClusterSelectorMatchExpressionsArgs) ToPlacementRuleSpecClusterSelectorMatchExpressionsOutputWithContext(ctx context.Context) PlacementRuleSpecClusterSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PlacementRuleSpecClusterSelectorMatchExpressionsOutput)
}

// PlacementRuleSpecClusterSelectorMatchExpressionsArrayInput is an input type that accepts PlacementRuleSpecClusterSelectorMatchExpressionsArray and PlacementRuleSpecClusterSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `PlacementRuleSpecClusterSelectorMatchExpressionsArrayInput` via:
//
//          PlacementRuleSpecClusterSelectorMatchExpressionsArray{ PlacementRuleSpecClusterSelectorMatchExpressionsArgs{...} }
type PlacementRuleSpecClusterSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToPlacementRuleSpecClusterSelectorMatchExpressionsArrayOutput() PlacementRuleSpecClusterSelectorMatchExpressionsArrayOutput
	ToPlacementRuleSpecClusterSelectorMatchExpressionsArrayOutputWithContext(context.Context) PlacementRuleSpecClusterSelectorMatchExpressionsArrayOutput
}

type PlacementRuleSpecClusterSelectorMatchExpressionsArray []PlacementRuleSpecClusterSelectorMatchExpressionsInput

func (PlacementRuleSpecClusterSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PlacementRuleSpecClusterSelectorMatchExpressions)(nil)).Elem()
}

func (i PlacementRuleSpecClusterSelectorMatchExpressionsArray) ToPlacementRuleSpecClusterSelectorMatchExpressionsArrayOutput() PlacementRuleSpecClusterSelectorMatchExpressionsArrayOutput {
	return i.ToPlacementRuleSpecClusterSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i PlacementRuleSpecClusterSelectorMatchExpressionsArray) ToPlacementRuleSpecClusterSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) PlacementRuleSpecClusterSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PlacementRuleSpecClusterSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type PlacementRuleSpecClusterSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (PlacementRuleSpecClusterSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PlacementRuleSpecClusterSelectorMatchExpressions)(nil)).Elem()
}

func (o PlacementRuleSpecClusterSelectorMatchExpressionsOutput) ToPlacementRuleSpecClusterSelectorMatchExpressionsOutput() PlacementRuleSpecClusterSelectorMatchExpressionsOutput {
	return o
}

func (o PlacementRuleSpecClusterSelectorMatchExpressionsOutput) ToPlacementRuleSpecClusterSelectorMatchExpressionsOutputWithContext(ctx context.Context) PlacementRuleSpecClusterSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o PlacementRuleSpecClusterSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v PlacementRuleSpecClusterSelectorMatchExpressions) string { return v.Key }).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
func (o PlacementRuleSpecClusterSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v PlacementRuleSpecClusterSelectorMatchExpressions) string { return v.Operator }).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
func (o PlacementRuleSpecClusterSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v PlacementRuleSpecClusterSelectorMatchExpressions) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type PlacementRuleSpecClusterSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (PlacementRuleSpecClusterSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PlacementRuleSpecClusterSelectorMatchExpressions)(nil)).Elem()
}

func (o PlacementRuleSpecClusterSelectorMatchExpressionsArrayOutput) ToPlacementRuleSpecClusterSelectorMatchExpressionsArrayOutput() PlacementRuleSpecClusterSelectorMatchExpressionsArrayOutput {
	return o
}

func (o PlacementRuleSpecClusterSelectorMatchExpressionsArrayOutput) ToPlacementRuleSpecClusterSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) PlacementRuleSpecClusterSelectorMatchExpressionsArrayOutput {
	return o
}

func (o PlacementRuleSpecClusterSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) PlacementRuleSpecClusterSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) PlacementRuleSpecClusterSelectorMatchExpressions {
		return vs[0].([]PlacementRuleSpecClusterSelectorMatchExpressions)[vs[1].(int)]
	}).(PlacementRuleSpecClusterSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type PlacementRuleSpecClusterSelectorMatchLabels struct {
}

// PlacementRuleSpecClusterSelectorMatchLabelsInput is an input type that accepts PlacementRuleSpecClusterSelectorMatchLabelsArgs and PlacementRuleSpecClusterSelectorMatchLabelsOutput values.
// You can construct a concrete instance of `PlacementRuleSpecClusterSelectorMatchLabelsInput` via:
//
//          PlacementRuleSpecClusterSelectorMatchLabelsArgs{...}
type PlacementRuleSpecClusterSelectorMatchLabelsInput interface {
	pulumi.Input

	ToPlacementRuleSpecClusterSelectorMatchLabelsOutput() PlacementRuleSpecClusterSelectorMatchLabelsOutput
	ToPlacementRuleSpecClusterSelectorMatchLabelsOutputWithContext(context.Context) PlacementRuleSpecClusterSelectorMatchLabelsOutput
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type PlacementRuleSpecClusterSelectorMatchLabelsArgs struct {
}

func (PlacementRuleSpecClusterSelectorMatchLabelsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PlacementRuleSpecClusterSelectorMatchLabels)(nil)).Elem()
}

func (i PlacementRuleSpecClusterSelectorMatchLabelsArgs) ToPlacementRuleSpecClusterSelectorMatchLabelsOutput() PlacementRuleSpecClusterSelectorMatchLabelsOutput {
	return i.ToPlacementRuleSpecClusterSelectorMatchLabelsOutputWithContext(context.Background())
}

func (i PlacementRuleSpecClusterSelectorMatchLabelsArgs) ToPlacementRuleSpecClusterSelectorMatchLabelsOutputWithContext(ctx context.Context) PlacementRuleSpecClusterSelectorMatchLabelsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PlacementRuleSpecClusterSelectorMatchLabelsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type PlacementRuleSpecClusterSelectorMatchLabelsOutput struct{ *pulumi.OutputState }

func (PlacementRuleSpecClusterSelectorMatchLabelsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PlacementRuleSpecClusterSelectorMatchLabels)(nil)).Elem()
}

func (o PlacementRuleSpecClusterSelectorMatchLabelsOutput) ToPlacementRuleSpecClusterSelectorMatchLabelsOutput() PlacementRuleSpecClusterSelectorMatchLabelsOutput {
	return o
}

func (o PlacementRuleSpecClusterSelectorMatchLabelsOutput) ToPlacementRuleSpecClusterSelectorMatchLabelsOutputWithContext(ctx context.Context) PlacementRuleSpecClusterSelectorMatchLabelsOutput {
	return o
}

// GenericClusterReference - in alignment with kubefed
type PlacementRuleSpecClusters struct {
	Name string `pulumi:"name"`
}

// PlacementRuleSpecClustersInput is an input type that accepts PlacementRuleSpecClustersArgs and PlacementRuleSpecClustersOutput values.
// You can construct a concrete instance of `PlacementRuleSpecClustersInput` via:
//
//          PlacementRuleSpecClustersArgs{...}
type PlacementRuleSpecClustersInput interface {
	pulumi.Input

	ToPlacementRuleSpecClustersOutput() PlacementRuleSpecClustersOutput
	ToPlacementRuleSpecClustersOutputWithContext(context.Context) PlacementRuleSpecClustersOutput
}

// GenericClusterReference - in alignment with kubefed
type PlacementRuleSpecClustersArgs struct {
	Name pulumi.StringInput `pulumi:"name"`
}

func (PlacementRuleSpecClustersArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PlacementRuleSpecClusters)(nil)).Elem()
}

func (i PlacementRuleSpecClustersArgs) ToPlacementRuleSpecClustersOutput() PlacementRuleSpecClustersOutput {
	return i.ToPlacementRuleSpecClustersOutputWithContext(context.Background())
}

func (i PlacementRuleSpecClustersArgs) ToPlacementRuleSpecClustersOutputWithContext(ctx context.Context) PlacementRuleSpecClustersOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PlacementRuleSpecClustersOutput)
}

// PlacementRuleSpecClustersArrayInput is an input type that accepts PlacementRuleSpecClustersArray and PlacementRuleSpecClustersArrayOutput values.
// You can construct a concrete instance of `PlacementRuleSpecClustersArrayInput` via:
//
//          PlacementRuleSpecClustersArray{ PlacementRuleSpecClustersArgs{...} }
type PlacementRuleSpecClustersArrayInput interface {
	pulumi.Input

	ToPlacementRuleSpecClustersArrayOutput() PlacementRuleSpecClustersArrayOutput
	ToPlacementRuleSpecClustersArrayOutputWithContext(context.Context) PlacementRuleSpecClustersArrayOutput
}

type PlacementRuleSpecClustersArray []PlacementRuleSpecClustersInput

func (PlacementRuleSpecClustersArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PlacementRuleSpecClusters)(nil)).Elem()
}

func (i PlacementRuleSpecClustersArray) ToPlacementRuleSpecClustersArrayOutput() PlacementRuleSpecClustersArrayOutput {
	return i.ToPlacementRuleSpecClustersArrayOutputWithContext(context.Background())
}

func (i PlacementRuleSpecClustersArray) ToPlacementRuleSpecClustersArrayOutputWithContext(ctx context.Context) PlacementRuleSpecClustersArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PlacementRuleSpecClustersArrayOutput)
}

// GenericClusterReference - in alignment with kubefed
type PlacementRuleSpecClustersOutput struct{ *pulumi.OutputState }

func (PlacementRuleSpecClustersOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PlacementRuleSpecClusters)(nil)).Elem()
}

func (o PlacementRuleSpecClustersOutput) ToPlacementRuleSpecClustersOutput() PlacementRuleSpecClustersOutput {
	return o
}

func (o PlacementRuleSpecClustersOutput) ToPlacementRuleSpecClustersOutputWithContext(ctx context.Context) PlacementRuleSpecClustersOutput {
	return o
}

func (o PlacementRuleSpecClustersOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v PlacementRuleSpecClusters) string { return v.Name }).(pulumi.StringOutput)
}

type PlacementRuleSpecClustersArrayOutput struct{ *pulumi.OutputState }

func (PlacementRuleSpecClustersArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PlacementRuleSpecClusters)(nil)).Elem()
}

func (o PlacementRuleSpecClustersArrayOutput) ToPlacementRuleSpecClustersArrayOutput() PlacementRuleSpecClustersArrayOutput {
	return o
}

func (o PlacementRuleSpecClustersArrayOutput) ToPlacementRuleSpecClustersArrayOutputWithContext(ctx context.Context) PlacementRuleSpecClustersArrayOutput {
	return o
}

func (o PlacementRuleSpecClustersArrayOutput) Index(i pulumi.IntInput) PlacementRuleSpecClustersOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) PlacementRuleSpecClusters {
		return vs[0].([]PlacementRuleSpecClusters)[vs[1].(int)]
	}).(PlacementRuleSpecClustersOutput)
}

// ObjectReference contains enough information to let you inspect or modify the referred object. --- New uses of this type are discouraged because of difficulty describing its usage when embedded in APIs.  1. Ignored fields.  It includes many fields which are not generally honored.  For instance, ResourceVersion and FieldPath are both very rarely valid in actual usage.  2. Invalid usage help.  It is impossible to add specific help for individual usage.  In most embedded usages, there are particular     restrictions like, "must refer only to types A and B" or "UID not honored" or "name must be restricted".     Those cannot be well described when embedded.  3. Inconsistent validation.  Because the usages are different, the validation rules are different by usage, which makes it hard for users to predict what will happen.  4. The fields are both imprecise and overly precise.  Kind is not a precise mapping to a URL. This can produce ambiguity     during interpretation and require a REST mapping.  In most cases, the dependency is on the group,resource tuple     and the version of the actual struct is irrelevant.  5. We cannot easily change it.  Because this type is embedded in many locations, updates to this type     will affect numerous schemas.  Don't make new APIs embed an underspecified API type they do not control. Instead of using this type, create a locally provided and used type that is well-focused on your reference. For example, ServiceReferences for admission registration: https://github.com/kubernetes/api/blob/release-1.17/admissionregistration/v1/types.go#L533 .
type PlacementRuleSpecPolicies struct {
	// API version of the referent.
	ApiVersion *string `pulumi:"apiVersion"`
	// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
	FieldPath *string `pulumi:"fieldPath"`
	// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name *string `pulumi:"name"`
	// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
	Namespace *string `pulumi:"namespace"`
	// Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
	ResourceVersion *string `pulumi:"resourceVersion"`
	// UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
	Uid *string `pulumi:"uid"`
}

// PlacementRuleSpecPoliciesInput is an input type that accepts PlacementRuleSpecPoliciesArgs and PlacementRuleSpecPoliciesOutput values.
// You can construct a concrete instance of `PlacementRuleSpecPoliciesInput` via:
//
//          PlacementRuleSpecPoliciesArgs{...}
type PlacementRuleSpecPoliciesInput interface {
	pulumi.Input

	ToPlacementRuleSpecPoliciesOutput() PlacementRuleSpecPoliciesOutput
	ToPlacementRuleSpecPoliciesOutputWithContext(context.Context) PlacementRuleSpecPoliciesOutput
}

// ObjectReference contains enough information to let you inspect or modify the referred object. --- New uses of this type are discouraged because of difficulty describing its usage when embedded in APIs.  1. Ignored fields.  It includes many fields which are not generally honored.  For instance, ResourceVersion and FieldPath are both very rarely valid in actual usage.  2. Invalid usage help.  It is impossible to add specific help for individual usage.  In most embedded usages, there are particular     restrictions like, "must refer only to types A and B" or "UID not honored" or "name must be restricted".     Those cannot be well described when embedded.  3. Inconsistent validation.  Because the usages are different, the validation rules are different by usage, which makes it hard for users to predict what will happen.  4. The fields are both imprecise and overly precise.  Kind is not a precise mapping to a URL. This can produce ambiguity     during interpretation and require a REST mapping.  In most cases, the dependency is on the group,resource tuple     and the version of the actual struct is irrelevant.  5. We cannot easily change it.  Because this type is embedded in many locations, updates to this type     will affect numerous schemas.  Don't make new APIs embed an underspecified API type they do not control. Instead of using this type, create a locally provided and used type that is well-focused on your reference. For example, ServiceReferences for admission registration: https://github.com/kubernetes/api/blob/release-1.17/admissionregistration/v1/types.go#L533 .
type PlacementRuleSpecPoliciesArgs struct {
	// API version of the referent.
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
	FieldPath pulumi.StringPtrInput `pulumi:"fieldPath"`
	// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
	ResourceVersion pulumi.StringPtrInput `pulumi:"resourceVersion"`
	// UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
	Uid pulumi.StringPtrInput `pulumi:"uid"`
}

func (PlacementRuleSpecPoliciesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PlacementRuleSpecPolicies)(nil)).Elem()
}

func (i PlacementRuleSpecPoliciesArgs) ToPlacementRuleSpecPoliciesOutput() PlacementRuleSpecPoliciesOutput {
	return i.ToPlacementRuleSpecPoliciesOutputWithContext(context.Background())
}

func (i PlacementRuleSpecPoliciesArgs) ToPlacementRuleSpecPoliciesOutputWithContext(ctx context.Context) PlacementRuleSpecPoliciesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PlacementRuleSpecPoliciesOutput)
}

// PlacementRuleSpecPoliciesArrayInput is an input type that accepts PlacementRuleSpecPoliciesArray and PlacementRuleSpecPoliciesArrayOutput values.
// You can construct a concrete instance of `PlacementRuleSpecPoliciesArrayInput` via:
//
//          PlacementRuleSpecPoliciesArray{ PlacementRuleSpecPoliciesArgs{...} }
type PlacementRuleSpecPoliciesArrayInput interface {
	pulumi.Input

	ToPlacementRuleSpecPoliciesArrayOutput() PlacementRuleSpecPoliciesArrayOutput
	ToPlacementRuleSpecPoliciesArrayOutputWithContext(context.Context) PlacementRuleSpecPoliciesArrayOutput
}

type PlacementRuleSpecPoliciesArray []PlacementRuleSpecPoliciesInput

func (PlacementRuleSpecPoliciesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PlacementRuleSpecPolicies)(nil)).Elem()
}

func (i PlacementRuleSpecPoliciesArray) ToPlacementRuleSpecPoliciesArrayOutput() PlacementRuleSpecPoliciesArrayOutput {
	return i.ToPlacementRuleSpecPoliciesArrayOutputWithContext(context.Background())
}

func (i PlacementRuleSpecPoliciesArray) ToPlacementRuleSpecPoliciesArrayOutputWithContext(ctx context.Context) PlacementRuleSpecPoliciesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PlacementRuleSpecPoliciesArrayOutput)
}

// ObjectReference contains enough information to let you inspect or modify the referred object. --- New uses of this type are discouraged because of difficulty describing its usage when embedded in APIs.  1. Ignored fields.  It includes many fields which are not generally honored.  For instance, ResourceVersion and FieldPath are both very rarely valid in actual usage.  2. Invalid usage help.  It is impossible to add specific help for individual usage.  In most embedded usages, there are particular     restrictions like, "must refer only to types A and B" or "UID not honored" or "name must be restricted".     Those cannot be well described when embedded.  3. Inconsistent validation.  Because the usages are different, the validation rules are different by usage, which makes it hard for users to predict what will happen.  4. The fields are both imprecise and overly precise.  Kind is not a precise mapping to a URL. This can produce ambiguity     during interpretation and require a REST mapping.  In most cases, the dependency is on the group,resource tuple     and the version of the actual struct is irrelevant.  5. We cannot easily change it.  Because this type is embedded in many locations, updates to this type     will affect numerous schemas.  Don't make new APIs embed an underspecified API type they do not control. Instead of using this type, create a locally provided and used type that is well-focused on your reference. For example, ServiceReferences for admission registration: https://github.com/kubernetes/api/blob/release-1.17/admissionregistration/v1/types.go#L533 .
type PlacementRuleSpecPoliciesOutput struct{ *pulumi.OutputState }

func (PlacementRuleSpecPoliciesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PlacementRuleSpecPolicies)(nil)).Elem()
}

func (o PlacementRuleSpecPoliciesOutput) ToPlacementRuleSpecPoliciesOutput() PlacementRuleSpecPoliciesOutput {
	return o
}

func (o PlacementRuleSpecPoliciesOutput) ToPlacementRuleSpecPoliciesOutputWithContext(ctx context.Context) PlacementRuleSpecPoliciesOutput {
	return o
}

// API version of the referent.
func (o PlacementRuleSpecPoliciesOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PlacementRuleSpecPolicies) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
func (o PlacementRuleSpecPoliciesOutput) FieldPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PlacementRuleSpecPolicies) *string { return v.FieldPath }).(pulumi.StringPtrOutput)
}

// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o PlacementRuleSpecPoliciesOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PlacementRuleSpecPolicies) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o PlacementRuleSpecPoliciesOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PlacementRuleSpecPolicies) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
func (o PlacementRuleSpecPoliciesOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PlacementRuleSpecPolicies) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
func (o PlacementRuleSpecPoliciesOutput) ResourceVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PlacementRuleSpecPolicies) *string { return v.ResourceVersion }).(pulumi.StringPtrOutput)
}

// UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
func (o PlacementRuleSpecPoliciesOutput) Uid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PlacementRuleSpecPolicies) *string { return v.Uid }).(pulumi.StringPtrOutput)
}

type PlacementRuleSpecPoliciesArrayOutput struct{ *pulumi.OutputState }

func (PlacementRuleSpecPoliciesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PlacementRuleSpecPolicies)(nil)).Elem()
}

func (o PlacementRuleSpecPoliciesArrayOutput) ToPlacementRuleSpecPoliciesArrayOutput() PlacementRuleSpecPoliciesArrayOutput {
	return o
}

func (o PlacementRuleSpecPoliciesArrayOutput) ToPlacementRuleSpecPoliciesArrayOutputWithContext(ctx context.Context) PlacementRuleSpecPoliciesArrayOutput {
	return o
}

func (o PlacementRuleSpecPoliciesArrayOutput) Index(i pulumi.IntInput) PlacementRuleSpecPoliciesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) PlacementRuleSpecPolicies {
		return vs[0].([]PlacementRuleSpecPolicies)[vs[1].(int)]
	}).(PlacementRuleSpecPoliciesOutput)
}

// Select Resource
type PlacementRuleSpecResourceHint struct {
	// SelectionOrder is the type for Nodes
	Order *string `pulumi:"order"`
	// ResourceType defines types can be sorted
	Type *string `pulumi:"type"`
}

// PlacementRuleSpecResourceHintInput is an input type that accepts PlacementRuleSpecResourceHintArgs and PlacementRuleSpecResourceHintOutput values.
// You can construct a concrete instance of `PlacementRuleSpecResourceHintInput` via:
//
//          PlacementRuleSpecResourceHintArgs{...}
type PlacementRuleSpecResourceHintInput interface {
	pulumi.Input

	ToPlacementRuleSpecResourceHintOutput() PlacementRuleSpecResourceHintOutput
	ToPlacementRuleSpecResourceHintOutputWithContext(context.Context) PlacementRuleSpecResourceHintOutput
}

// Select Resource
type PlacementRuleSpecResourceHintArgs struct {
	// SelectionOrder is the type for Nodes
	Order pulumi.StringPtrInput `pulumi:"order"`
	// ResourceType defines types can be sorted
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (PlacementRuleSpecResourceHintArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PlacementRuleSpecResourceHint)(nil)).Elem()
}

func (i PlacementRuleSpecResourceHintArgs) ToPlacementRuleSpecResourceHintOutput() PlacementRuleSpecResourceHintOutput {
	return i.ToPlacementRuleSpecResourceHintOutputWithContext(context.Background())
}

func (i PlacementRuleSpecResourceHintArgs) ToPlacementRuleSpecResourceHintOutputWithContext(ctx context.Context) PlacementRuleSpecResourceHintOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PlacementRuleSpecResourceHintOutput)
}

func (i PlacementRuleSpecResourceHintArgs) ToPlacementRuleSpecResourceHintPtrOutput() PlacementRuleSpecResourceHintPtrOutput {
	return i.ToPlacementRuleSpecResourceHintPtrOutputWithContext(context.Background())
}

func (i PlacementRuleSpecResourceHintArgs) ToPlacementRuleSpecResourceHintPtrOutputWithContext(ctx context.Context) PlacementRuleSpecResourceHintPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PlacementRuleSpecResourceHintOutput).ToPlacementRuleSpecResourceHintPtrOutputWithContext(ctx)
}

// PlacementRuleSpecResourceHintPtrInput is an input type that accepts PlacementRuleSpecResourceHintArgs, PlacementRuleSpecResourceHintPtr and PlacementRuleSpecResourceHintPtrOutput values.
// You can construct a concrete instance of `PlacementRuleSpecResourceHintPtrInput` via:
//
//          PlacementRuleSpecResourceHintArgs{...}
//
//  or:
//
//          nil
type PlacementRuleSpecResourceHintPtrInput interface {
	pulumi.Input

	ToPlacementRuleSpecResourceHintPtrOutput() PlacementRuleSpecResourceHintPtrOutput
	ToPlacementRuleSpecResourceHintPtrOutputWithContext(context.Context) PlacementRuleSpecResourceHintPtrOutput
}

type placementRuleSpecResourceHintPtrType PlacementRuleSpecResourceHintArgs

func PlacementRuleSpecResourceHintPtr(v *PlacementRuleSpecResourceHintArgs) PlacementRuleSpecResourceHintPtrInput {
	return (*placementRuleSpecResourceHintPtrType)(v)
}

func (*placementRuleSpecResourceHintPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PlacementRuleSpecResourceHint)(nil)).Elem()
}

func (i *placementRuleSpecResourceHintPtrType) ToPlacementRuleSpecResourceHintPtrOutput() PlacementRuleSpecResourceHintPtrOutput {
	return i.ToPlacementRuleSpecResourceHintPtrOutputWithContext(context.Background())
}

func (i *placementRuleSpecResourceHintPtrType) ToPlacementRuleSpecResourceHintPtrOutputWithContext(ctx context.Context) PlacementRuleSpecResourceHintPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PlacementRuleSpecResourceHintPtrOutput)
}

// Select Resource
type PlacementRuleSpecResourceHintOutput struct{ *pulumi.OutputState }

func (PlacementRuleSpecResourceHintOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PlacementRuleSpecResourceHint)(nil)).Elem()
}

func (o PlacementRuleSpecResourceHintOutput) ToPlacementRuleSpecResourceHintOutput() PlacementRuleSpecResourceHintOutput {
	return o
}

func (o PlacementRuleSpecResourceHintOutput) ToPlacementRuleSpecResourceHintOutputWithContext(ctx context.Context) PlacementRuleSpecResourceHintOutput {
	return o
}

func (o PlacementRuleSpecResourceHintOutput) ToPlacementRuleSpecResourceHintPtrOutput() PlacementRuleSpecResourceHintPtrOutput {
	return o.ToPlacementRuleSpecResourceHintPtrOutputWithContext(context.Background())
}

func (o PlacementRuleSpecResourceHintOutput) ToPlacementRuleSpecResourceHintPtrOutputWithContext(ctx context.Context) PlacementRuleSpecResourceHintPtrOutput {
	return o.ApplyT(func(v PlacementRuleSpecResourceHint) *PlacementRuleSpecResourceHint {
		return &v
	}).(PlacementRuleSpecResourceHintPtrOutput)
}

// SelectionOrder is the type for Nodes
func (o PlacementRuleSpecResourceHintOutput) Order() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PlacementRuleSpecResourceHint) *string { return v.Order }).(pulumi.StringPtrOutput)
}

// ResourceType defines types can be sorted
func (o PlacementRuleSpecResourceHintOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PlacementRuleSpecResourceHint) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type PlacementRuleSpecResourceHintPtrOutput struct{ *pulumi.OutputState }

func (PlacementRuleSpecResourceHintPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PlacementRuleSpecResourceHint)(nil)).Elem()
}

func (o PlacementRuleSpecResourceHintPtrOutput) ToPlacementRuleSpecResourceHintPtrOutput() PlacementRuleSpecResourceHintPtrOutput {
	return o
}

func (o PlacementRuleSpecResourceHintPtrOutput) ToPlacementRuleSpecResourceHintPtrOutputWithContext(ctx context.Context) PlacementRuleSpecResourceHintPtrOutput {
	return o
}

func (o PlacementRuleSpecResourceHintPtrOutput) Elem() PlacementRuleSpecResourceHintOutput {
	return o.ApplyT(func(v *PlacementRuleSpecResourceHint) PlacementRuleSpecResourceHint { return *v }).(PlacementRuleSpecResourceHintOutput)
}

// SelectionOrder is the type for Nodes
func (o PlacementRuleSpecResourceHintPtrOutput) Order() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PlacementRuleSpecResourceHint) *string {
		if v == nil {
			return nil
		}
		return v.Order
	}).(pulumi.StringPtrOutput)
}

// ResourceType defines types can be sorted
func (o PlacementRuleSpecResourceHintPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PlacementRuleSpecResourceHint) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// PlacementRuleStatus defines the observed state of PlacementRule
type PlacementRuleStatus struct {
	// INSERT ADDITIONAL STATUS FIELD - define observed state of cluster Important: Run "make" to regenerate code after modifying this file
	Decisions []PlacementRuleStatusDecisions `pulumi:"decisions"`
}

// PlacementRuleStatusInput is an input type that accepts PlacementRuleStatusArgs and PlacementRuleStatusOutput values.
// You can construct a concrete instance of `PlacementRuleStatusInput` via:
//
//          PlacementRuleStatusArgs{...}
type PlacementRuleStatusInput interface {
	pulumi.Input

	ToPlacementRuleStatusOutput() PlacementRuleStatusOutput
	ToPlacementRuleStatusOutputWithContext(context.Context) PlacementRuleStatusOutput
}

// PlacementRuleStatus defines the observed state of PlacementRule
type PlacementRuleStatusArgs struct {
	// INSERT ADDITIONAL STATUS FIELD - define observed state of cluster Important: Run "make" to regenerate code after modifying this file
	Decisions PlacementRuleStatusDecisionsArrayInput `pulumi:"decisions"`
}

func (PlacementRuleStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PlacementRuleStatus)(nil)).Elem()
}

func (i PlacementRuleStatusArgs) ToPlacementRuleStatusOutput() PlacementRuleStatusOutput {
	return i.ToPlacementRuleStatusOutputWithContext(context.Background())
}

func (i PlacementRuleStatusArgs) ToPlacementRuleStatusOutputWithContext(ctx context.Context) PlacementRuleStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PlacementRuleStatusOutput)
}

func (i PlacementRuleStatusArgs) ToPlacementRuleStatusPtrOutput() PlacementRuleStatusPtrOutput {
	return i.ToPlacementRuleStatusPtrOutputWithContext(context.Background())
}

func (i PlacementRuleStatusArgs) ToPlacementRuleStatusPtrOutputWithContext(ctx context.Context) PlacementRuleStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PlacementRuleStatusOutput).ToPlacementRuleStatusPtrOutputWithContext(ctx)
}

// PlacementRuleStatusPtrInput is an input type that accepts PlacementRuleStatusArgs, PlacementRuleStatusPtr and PlacementRuleStatusPtrOutput values.
// You can construct a concrete instance of `PlacementRuleStatusPtrInput` via:
//
//          PlacementRuleStatusArgs{...}
//
//  or:
//
//          nil
type PlacementRuleStatusPtrInput interface {
	pulumi.Input

	ToPlacementRuleStatusPtrOutput() PlacementRuleStatusPtrOutput
	ToPlacementRuleStatusPtrOutputWithContext(context.Context) PlacementRuleStatusPtrOutput
}

type placementRuleStatusPtrType PlacementRuleStatusArgs

func PlacementRuleStatusPtr(v *PlacementRuleStatusArgs) PlacementRuleStatusPtrInput {
	return (*placementRuleStatusPtrType)(v)
}

func (*placementRuleStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PlacementRuleStatus)(nil)).Elem()
}

func (i *placementRuleStatusPtrType) ToPlacementRuleStatusPtrOutput() PlacementRuleStatusPtrOutput {
	return i.ToPlacementRuleStatusPtrOutputWithContext(context.Background())
}

func (i *placementRuleStatusPtrType) ToPlacementRuleStatusPtrOutputWithContext(ctx context.Context) PlacementRuleStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PlacementRuleStatusPtrOutput)
}

// PlacementRuleStatus defines the observed state of PlacementRule
type PlacementRuleStatusOutput struct{ *pulumi.OutputState }

func (PlacementRuleStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PlacementRuleStatus)(nil)).Elem()
}

func (o PlacementRuleStatusOutput) ToPlacementRuleStatusOutput() PlacementRuleStatusOutput {
	return o
}

func (o PlacementRuleStatusOutput) ToPlacementRuleStatusOutputWithContext(ctx context.Context) PlacementRuleStatusOutput {
	return o
}

func (o PlacementRuleStatusOutput) ToPlacementRuleStatusPtrOutput() PlacementRuleStatusPtrOutput {
	return o.ToPlacementRuleStatusPtrOutputWithContext(context.Background())
}

func (o PlacementRuleStatusOutput) ToPlacementRuleStatusPtrOutputWithContext(ctx context.Context) PlacementRuleStatusPtrOutput {
	return o.ApplyT(func(v PlacementRuleStatus) *PlacementRuleStatus {
		return &v
	}).(PlacementRuleStatusPtrOutput)
}

// INSERT ADDITIONAL STATUS FIELD - define observed state of cluster Important: Run "make" to regenerate code after modifying this file
func (o PlacementRuleStatusOutput) Decisions() PlacementRuleStatusDecisionsArrayOutput {
	return o.ApplyT(func(v PlacementRuleStatus) []PlacementRuleStatusDecisions { return v.Decisions }).(PlacementRuleStatusDecisionsArrayOutput)
}

type PlacementRuleStatusPtrOutput struct{ *pulumi.OutputState }

func (PlacementRuleStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PlacementRuleStatus)(nil)).Elem()
}

func (o PlacementRuleStatusPtrOutput) ToPlacementRuleStatusPtrOutput() PlacementRuleStatusPtrOutput {
	return o
}

func (o PlacementRuleStatusPtrOutput) ToPlacementRuleStatusPtrOutputWithContext(ctx context.Context) PlacementRuleStatusPtrOutput {
	return o
}

func (o PlacementRuleStatusPtrOutput) Elem() PlacementRuleStatusOutput {
	return o.ApplyT(func(v *PlacementRuleStatus) PlacementRuleStatus { return *v }).(PlacementRuleStatusOutput)
}

// INSERT ADDITIONAL STATUS FIELD - define observed state of cluster Important: Run "make" to regenerate code after modifying this file
func (o PlacementRuleStatusPtrOutput) Decisions() PlacementRuleStatusDecisionsArrayOutput {
	return o.ApplyT(func(v *PlacementRuleStatus) []PlacementRuleStatusDecisions {
		if v == nil {
			return nil
		}
		return v.Decisions
	}).(PlacementRuleStatusDecisionsArrayOutput)
}

// PlacementDecision defines the decision made by controller
type PlacementRuleStatusDecisions struct {
	ClusterName      *string `pulumi:"clusterName"`
	ClusterNamespace *string `pulumi:"clusterNamespace"`
}

// PlacementRuleStatusDecisionsInput is an input type that accepts PlacementRuleStatusDecisionsArgs and PlacementRuleStatusDecisionsOutput values.
// You can construct a concrete instance of `PlacementRuleStatusDecisionsInput` via:
//
//          PlacementRuleStatusDecisionsArgs{...}
type PlacementRuleStatusDecisionsInput interface {
	pulumi.Input

	ToPlacementRuleStatusDecisionsOutput() PlacementRuleStatusDecisionsOutput
	ToPlacementRuleStatusDecisionsOutputWithContext(context.Context) PlacementRuleStatusDecisionsOutput
}

// PlacementDecision defines the decision made by controller
type PlacementRuleStatusDecisionsArgs struct {
	ClusterName      pulumi.StringPtrInput `pulumi:"clusterName"`
	ClusterNamespace pulumi.StringPtrInput `pulumi:"clusterNamespace"`
}

func (PlacementRuleStatusDecisionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PlacementRuleStatusDecisions)(nil)).Elem()
}

func (i PlacementRuleStatusDecisionsArgs) ToPlacementRuleStatusDecisionsOutput() PlacementRuleStatusDecisionsOutput {
	return i.ToPlacementRuleStatusDecisionsOutputWithContext(context.Background())
}

func (i PlacementRuleStatusDecisionsArgs) ToPlacementRuleStatusDecisionsOutputWithContext(ctx context.Context) PlacementRuleStatusDecisionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PlacementRuleStatusDecisionsOutput)
}

// PlacementRuleStatusDecisionsArrayInput is an input type that accepts PlacementRuleStatusDecisionsArray and PlacementRuleStatusDecisionsArrayOutput values.
// You can construct a concrete instance of `PlacementRuleStatusDecisionsArrayInput` via:
//
//          PlacementRuleStatusDecisionsArray{ PlacementRuleStatusDecisionsArgs{...} }
type PlacementRuleStatusDecisionsArrayInput interface {
	pulumi.Input

	ToPlacementRuleStatusDecisionsArrayOutput() PlacementRuleStatusDecisionsArrayOutput
	ToPlacementRuleStatusDecisionsArrayOutputWithContext(context.Context) PlacementRuleStatusDecisionsArrayOutput
}

type PlacementRuleStatusDecisionsArray []PlacementRuleStatusDecisionsInput

func (PlacementRuleStatusDecisionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PlacementRuleStatusDecisions)(nil)).Elem()
}

func (i PlacementRuleStatusDecisionsArray) ToPlacementRuleStatusDecisionsArrayOutput() PlacementRuleStatusDecisionsArrayOutput {
	return i.ToPlacementRuleStatusDecisionsArrayOutputWithContext(context.Background())
}

func (i PlacementRuleStatusDecisionsArray) ToPlacementRuleStatusDecisionsArrayOutputWithContext(ctx context.Context) PlacementRuleStatusDecisionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PlacementRuleStatusDecisionsArrayOutput)
}

// PlacementDecision defines the decision made by controller
type PlacementRuleStatusDecisionsOutput struct{ *pulumi.OutputState }

func (PlacementRuleStatusDecisionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PlacementRuleStatusDecisions)(nil)).Elem()
}

func (o PlacementRuleStatusDecisionsOutput) ToPlacementRuleStatusDecisionsOutput() PlacementRuleStatusDecisionsOutput {
	return o
}

func (o PlacementRuleStatusDecisionsOutput) ToPlacementRuleStatusDecisionsOutputWithContext(ctx context.Context) PlacementRuleStatusDecisionsOutput {
	return o
}

func (o PlacementRuleStatusDecisionsOutput) ClusterName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PlacementRuleStatusDecisions) *string { return v.ClusterName }).(pulumi.StringPtrOutput)
}

func (o PlacementRuleStatusDecisionsOutput) ClusterNamespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PlacementRuleStatusDecisions) *string { return v.ClusterNamespace }).(pulumi.StringPtrOutput)
}

type PlacementRuleStatusDecisionsArrayOutput struct{ *pulumi.OutputState }

func (PlacementRuleStatusDecisionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PlacementRuleStatusDecisions)(nil)).Elem()
}

func (o PlacementRuleStatusDecisionsArrayOutput) ToPlacementRuleStatusDecisionsArrayOutput() PlacementRuleStatusDecisionsArrayOutput {
	return o
}

func (o PlacementRuleStatusDecisionsArrayOutput) ToPlacementRuleStatusDecisionsArrayOutputWithContext(ctx context.Context) PlacementRuleStatusDecisionsArrayOutput {
	return o
}

func (o PlacementRuleStatusDecisionsArrayOutput) Index(i pulumi.IntInput) PlacementRuleStatusDecisionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) PlacementRuleStatusDecisions {
		return vs[0].([]PlacementRuleStatusDecisions)[vs[1].(int)]
	}).(PlacementRuleStatusDecisionsOutput)
}

// Subscription is the Schema for the subscriptions API
type SubscriptionType struct {
	ApiVersion *string            `pulumi:"apiVersion"`
	Kind       *string            `pulumi:"kind"`
	Metadata   *metav1.ObjectMeta `pulumi:"metadata"`
	// SubscriptionSpec defines the desired state of Subscription
	Spec *SubscriptionSpec `pulumi:"spec"`
	// SubscriptionStatus defines the observed state of Subscription Examples - status of a subscription on hub Status: 	phase: Propagated 	statuses: 	  washdc: 		packages: 		  nginx: 			phase: Subscribed 		  mongodb: 			phase: Failed 			Reason: "not authorized" 			Message: "user xxx does not have permission to start pod" 			resourceStatus: {}    toronto: 		packages: 		  nginx: 			phase: Subscribed 		  mongodb: 			phase: Subscribed Status of a subscription on managed cluster will only have 1 cluster in the map.
	Status *SubscriptionStatus `pulumi:"status"`
}

// SubscriptionTypeInput is an input type that accepts SubscriptionTypeArgs and SubscriptionTypeOutput values.
// You can construct a concrete instance of `SubscriptionTypeInput` via:
//
//          SubscriptionTypeArgs{...}
type SubscriptionTypeInput interface {
	pulumi.Input

	ToSubscriptionTypeOutput() SubscriptionTypeOutput
	ToSubscriptionTypeOutputWithContext(context.Context) SubscriptionTypeOutput
}

// Subscription is the Schema for the subscriptions API
type SubscriptionTypeArgs struct {
	ApiVersion pulumi.StringPtrInput     `pulumi:"apiVersion"`
	Kind       pulumi.StringPtrInput     `pulumi:"kind"`
	Metadata   metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	// SubscriptionSpec defines the desired state of Subscription
	Spec SubscriptionSpecPtrInput `pulumi:"spec"`
	// SubscriptionStatus defines the observed state of Subscription Examples - status of a subscription on hub Status: 	phase: Propagated 	statuses: 	  washdc: 		packages: 		  nginx: 			phase: Subscribed 		  mongodb: 			phase: Failed 			Reason: "not authorized" 			Message: "user xxx does not have permission to start pod" 			resourceStatus: {}    toronto: 		packages: 		  nginx: 			phase: Subscribed 		  mongodb: 			phase: Subscribed Status of a subscription on managed cluster will only have 1 cluster in the map.
	Status SubscriptionStatusPtrInput `pulumi:"status"`
}

func (SubscriptionTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionType)(nil)).Elem()
}

func (i SubscriptionTypeArgs) ToSubscriptionTypeOutput() SubscriptionTypeOutput {
	return i.ToSubscriptionTypeOutputWithContext(context.Background())
}

func (i SubscriptionTypeArgs) ToSubscriptionTypeOutputWithContext(ctx context.Context) SubscriptionTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionTypeOutput)
}

// Subscription is the Schema for the subscriptions API
type SubscriptionTypeOutput struct{ *pulumi.OutputState }

func (SubscriptionTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionType)(nil)).Elem()
}

func (o SubscriptionTypeOutput) ToSubscriptionTypeOutput() SubscriptionTypeOutput {
	return o
}

func (o SubscriptionTypeOutput) ToSubscriptionTypeOutputWithContext(ctx context.Context) SubscriptionTypeOutput {
	return o
}

func (o SubscriptionTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

func (o SubscriptionTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

func (o SubscriptionTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v SubscriptionType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

// SubscriptionSpec defines the desired state of Subscription
func (o SubscriptionTypeOutput) Spec() SubscriptionSpecPtrOutput {
	return o.ApplyT(func(v SubscriptionType) *SubscriptionSpec { return v.Spec }).(SubscriptionSpecPtrOutput)
}

// SubscriptionStatus defines the observed state of Subscription Examples - status of a subscription on hub Status: 	phase: Propagated 	statuses: 	  washdc: 		packages: 		  nginx: 			phase: Subscribed 		  mongodb: 			phase: Failed 			Reason: "not authorized" 			Message: "user xxx does not have permission to start pod" 			resourceStatus: {}    toronto: 		packages: 		  nginx: 			phase: Subscribed 		  mongodb: 			phase: Subscribed Status of a subscription on managed cluster will only have 1 cluster in the map.
func (o SubscriptionTypeOutput) Status() SubscriptionStatusPtrOutput {
	return o.ApplyT(func(v SubscriptionType) *SubscriptionStatus { return v.Status }).(SubscriptionStatusPtrOutput)
}

type SubscriptionMetadata struct {
}

// SubscriptionMetadataInput is an input type that accepts SubscriptionMetadataArgs and SubscriptionMetadataOutput values.
// You can construct a concrete instance of `SubscriptionMetadataInput` via:
//
//          SubscriptionMetadataArgs{...}
type SubscriptionMetadataInput interface {
	pulumi.Input

	ToSubscriptionMetadataOutput() SubscriptionMetadataOutput
	ToSubscriptionMetadataOutputWithContext(context.Context) SubscriptionMetadataOutput
}

type SubscriptionMetadataArgs struct {
}

func (SubscriptionMetadataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionMetadata)(nil)).Elem()
}

func (i SubscriptionMetadataArgs) ToSubscriptionMetadataOutput() SubscriptionMetadataOutput {
	return i.ToSubscriptionMetadataOutputWithContext(context.Background())
}

func (i SubscriptionMetadataArgs) ToSubscriptionMetadataOutputWithContext(ctx context.Context) SubscriptionMetadataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionMetadataOutput)
}

type SubscriptionMetadataOutput struct{ *pulumi.OutputState }

func (SubscriptionMetadataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionMetadata)(nil)).Elem()
}

func (o SubscriptionMetadataOutput) ToSubscriptionMetadataOutput() SubscriptionMetadataOutput {
	return o
}

func (o SubscriptionMetadataOutput) ToSubscriptionMetadataOutputWithContext(ctx context.Context) SubscriptionMetadataOutput {
	return o
}

// SubscriptionSpec defines the desired state of Subscription
type SubscriptionSpec struct {
	Channel string `pulumi:"channel"`
	// ObjectReference contains enough information to let you inspect or modify the referred object. --- New uses of this type are discouraged because of difficulty describing its usage when embedded in APIs.  1. Ignored fields.  It includes many fields which are not generally honored.  For instance, ResourceVersion and FieldPath are both very rarely valid in actual usage.  2. Invalid usage help.  It is impossible to add specific help for individual usage.  In most embedded usages, there are particular     restrictions like, "must refer only to types A and B" or "UID not honored" or "name must be restricted".     Those cannot be well described when embedded.  3. Inconsistent validation.  Because the usages are different, the validation rules are different by usage, which makes it hard for users to predict what will happen.  4. The fields are both imprecise and overly precise.  Kind is not a precise mapping to a URL. This can produce ambiguity     during interpretation and require a REST mapping.  In most cases, the dependency is on the group,resource tuple     and the version of the actual struct is irrelevant.  5. We cannot easily change it.  Because this type is embedded in many locations, updates to this type     will affect numerous schemas.  Don't make new APIs embed an underspecified API type they do not control. Instead of using this type, create a locally provided and used type that is well-focused on your reference. For example, ServiceReferences for admission registration: https://github.com/kubernetes/api/blob/release-1.17/admissionregistration/v1/types.go#L533 .
	Hooksecretref *SubscriptionSpecHooksecretref `pulumi:"hooksecretref"`
	// To specify 1 package in channel
	Name *string `pulumi:"name"`
	// for hub use only to specify the overrides when apply to clusters
	Overrides []SubscriptionSpecOverrides `pulumi:"overrides"`
	// To specify more than 1 package in channel
	PackageFilter *SubscriptionSpecPackageFilter `pulumi:"packageFilter"`
	// To provide flexibility to override package in channel with local input
	PackageOverrides []SubscriptionSpecPackageOverrides `pulumi:"packageOverrides"`
	// For hub use only, to specify which clusters to go to
	Placement *SubscriptionSpecPlacement `pulumi:"placement"`
	// help user control when the subscription will take affect
	Timewindow *SubscriptionSpecTimewindow `pulumi:"timewindow"`
}

// SubscriptionSpecInput is an input type that accepts SubscriptionSpecArgs and SubscriptionSpecOutput values.
// You can construct a concrete instance of `SubscriptionSpecInput` via:
//
//          SubscriptionSpecArgs{...}
type SubscriptionSpecInput interface {
	pulumi.Input

	ToSubscriptionSpecOutput() SubscriptionSpecOutput
	ToSubscriptionSpecOutputWithContext(context.Context) SubscriptionSpecOutput
}

// SubscriptionSpec defines the desired state of Subscription
type SubscriptionSpecArgs struct {
	Channel pulumi.StringInput `pulumi:"channel"`
	// ObjectReference contains enough information to let you inspect or modify the referred object. --- New uses of this type are discouraged because of difficulty describing its usage when embedded in APIs.  1. Ignored fields.  It includes many fields which are not generally honored.  For instance, ResourceVersion and FieldPath are both very rarely valid in actual usage.  2. Invalid usage help.  It is impossible to add specific help for individual usage.  In most embedded usages, there are particular     restrictions like, "must refer only to types A and B" or "UID not honored" or "name must be restricted".     Those cannot be well described when embedded.  3. Inconsistent validation.  Because the usages are different, the validation rules are different by usage, which makes it hard for users to predict what will happen.  4. The fields are both imprecise and overly precise.  Kind is not a precise mapping to a URL. This can produce ambiguity     during interpretation and require a REST mapping.  In most cases, the dependency is on the group,resource tuple     and the version of the actual struct is irrelevant.  5. We cannot easily change it.  Because this type is embedded in many locations, updates to this type     will affect numerous schemas.  Don't make new APIs embed an underspecified API type they do not control. Instead of using this type, create a locally provided and used type that is well-focused on your reference. For example, ServiceReferences for admission registration: https://github.com/kubernetes/api/blob/release-1.17/admissionregistration/v1/types.go#L533 .
	Hooksecretref SubscriptionSpecHooksecretrefPtrInput `pulumi:"hooksecretref"`
	// To specify 1 package in channel
	Name pulumi.StringPtrInput `pulumi:"name"`
	// for hub use only to specify the overrides when apply to clusters
	Overrides SubscriptionSpecOverridesArrayInput `pulumi:"overrides"`
	// To specify more than 1 package in channel
	PackageFilter SubscriptionSpecPackageFilterPtrInput `pulumi:"packageFilter"`
	// To provide flexibility to override package in channel with local input
	PackageOverrides SubscriptionSpecPackageOverridesArrayInput `pulumi:"packageOverrides"`
	// For hub use only, to specify which clusters to go to
	Placement SubscriptionSpecPlacementPtrInput `pulumi:"placement"`
	// help user control when the subscription will take affect
	Timewindow SubscriptionSpecTimewindowPtrInput `pulumi:"timewindow"`
}

func (SubscriptionSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionSpec)(nil)).Elem()
}

func (i SubscriptionSpecArgs) ToSubscriptionSpecOutput() SubscriptionSpecOutput {
	return i.ToSubscriptionSpecOutputWithContext(context.Background())
}

func (i SubscriptionSpecArgs) ToSubscriptionSpecOutputWithContext(ctx context.Context) SubscriptionSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecOutput)
}

func (i SubscriptionSpecArgs) ToSubscriptionSpecPtrOutput() SubscriptionSpecPtrOutput {
	return i.ToSubscriptionSpecPtrOutputWithContext(context.Background())
}

func (i SubscriptionSpecArgs) ToSubscriptionSpecPtrOutputWithContext(ctx context.Context) SubscriptionSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecOutput).ToSubscriptionSpecPtrOutputWithContext(ctx)
}

// SubscriptionSpecPtrInput is an input type that accepts SubscriptionSpecArgs, SubscriptionSpecPtr and SubscriptionSpecPtrOutput values.
// You can construct a concrete instance of `SubscriptionSpecPtrInput` via:
//
//          SubscriptionSpecArgs{...}
//
//  or:
//
//          nil
type SubscriptionSpecPtrInput interface {
	pulumi.Input

	ToSubscriptionSpecPtrOutput() SubscriptionSpecPtrOutput
	ToSubscriptionSpecPtrOutputWithContext(context.Context) SubscriptionSpecPtrOutput
}

type subscriptionSpecPtrType SubscriptionSpecArgs

func SubscriptionSpecPtr(v *SubscriptionSpecArgs) SubscriptionSpecPtrInput {
	return (*subscriptionSpecPtrType)(v)
}

func (*subscriptionSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SubscriptionSpec)(nil)).Elem()
}

func (i *subscriptionSpecPtrType) ToSubscriptionSpecPtrOutput() SubscriptionSpecPtrOutput {
	return i.ToSubscriptionSpecPtrOutputWithContext(context.Background())
}

func (i *subscriptionSpecPtrType) ToSubscriptionSpecPtrOutputWithContext(ctx context.Context) SubscriptionSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecPtrOutput)
}

// SubscriptionSpec defines the desired state of Subscription
type SubscriptionSpecOutput struct{ *pulumi.OutputState }

func (SubscriptionSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionSpec)(nil)).Elem()
}

func (o SubscriptionSpecOutput) ToSubscriptionSpecOutput() SubscriptionSpecOutput {
	return o
}

func (o SubscriptionSpecOutput) ToSubscriptionSpecOutputWithContext(ctx context.Context) SubscriptionSpecOutput {
	return o
}

func (o SubscriptionSpecOutput) ToSubscriptionSpecPtrOutput() SubscriptionSpecPtrOutput {
	return o.ToSubscriptionSpecPtrOutputWithContext(context.Background())
}

func (o SubscriptionSpecOutput) ToSubscriptionSpecPtrOutputWithContext(ctx context.Context) SubscriptionSpecPtrOutput {
	return o.ApplyT(func(v SubscriptionSpec) *SubscriptionSpec {
		return &v
	}).(SubscriptionSpecPtrOutput)
}
func (o SubscriptionSpecOutput) Channel() pulumi.StringOutput {
	return o.ApplyT(func(v SubscriptionSpec) string { return v.Channel }).(pulumi.StringOutput)
}

// ObjectReference contains enough information to let you inspect or modify the referred object. --- New uses of this type are discouraged because of difficulty describing its usage when embedded in APIs.  1. Ignored fields.  It includes many fields which are not generally honored.  For instance, ResourceVersion and FieldPath are both very rarely valid in actual usage.  2. Invalid usage help.  It is impossible to add specific help for individual usage.  In most embedded usages, there are particular     restrictions like, "must refer only to types A and B" or "UID not honored" or "name must be restricted".     Those cannot be well described when embedded.  3. Inconsistent validation.  Because the usages are different, the validation rules are different by usage, which makes it hard for users to predict what will happen.  4. The fields are both imprecise and overly precise.  Kind is not a precise mapping to a URL. This can produce ambiguity     during interpretation and require a REST mapping.  In most cases, the dependency is on the group,resource tuple     and the version of the actual struct is irrelevant.  5. We cannot easily change it.  Because this type is embedded in many locations, updates to this type     will affect numerous schemas.  Don't make new APIs embed an underspecified API type they do not control. Instead of using this type, create a locally provided and used type that is well-focused on your reference. For example, ServiceReferences for admission registration: https://github.com/kubernetes/api/blob/release-1.17/admissionregistration/v1/types.go#L533 .
func (o SubscriptionSpecOutput) Hooksecretref() SubscriptionSpecHooksecretrefPtrOutput {
	return o.ApplyT(func(v SubscriptionSpec) *SubscriptionSpecHooksecretref { return v.Hooksecretref }).(SubscriptionSpecHooksecretrefPtrOutput)
}

// To specify 1 package in channel
func (o SubscriptionSpecOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionSpec) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// for hub use only to specify the overrides when apply to clusters
func (o SubscriptionSpecOutput) Overrides() SubscriptionSpecOverridesArrayOutput {
	return o.ApplyT(func(v SubscriptionSpec) []SubscriptionSpecOverrides { return v.Overrides }).(SubscriptionSpecOverridesArrayOutput)
}

// To specify more than 1 package in channel
func (o SubscriptionSpecOutput) PackageFilter() SubscriptionSpecPackageFilterPtrOutput {
	return o.ApplyT(func(v SubscriptionSpec) *SubscriptionSpecPackageFilter { return v.PackageFilter }).(SubscriptionSpecPackageFilterPtrOutput)
}

// To provide flexibility to override package in channel with local input
func (o SubscriptionSpecOutput) PackageOverrides() SubscriptionSpecPackageOverridesArrayOutput {
	return o.ApplyT(func(v SubscriptionSpec) []SubscriptionSpecPackageOverrides { return v.PackageOverrides }).(SubscriptionSpecPackageOverridesArrayOutput)
}

// For hub use only, to specify which clusters to go to
func (o SubscriptionSpecOutput) Placement() SubscriptionSpecPlacementPtrOutput {
	return o.ApplyT(func(v SubscriptionSpec) *SubscriptionSpecPlacement { return v.Placement }).(SubscriptionSpecPlacementPtrOutput)
}

// help user control when the subscription will take affect
func (o SubscriptionSpecOutput) Timewindow() SubscriptionSpecTimewindowPtrOutput {
	return o.ApplyT(func(v SubscriptionSpec) *SubscriptionSpecTimewindow { return v.Timewindow }).(SubscriptionSpecTimewindowPtrOutput)
}

type SubscriptionSpecPtrOutput struct{ *pulumi.OutputState }

func (SubscriptionSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SubscriptionSpec)(nil)).Elem()
}

func (o SubscriptionSpecPtrOutput) ToSubscriptionSpecPtrOutput() SubscriptionSpecPtrOutput {
	return o
}

func (o SubscriptionSpecPtrOutput) ToSubscriptionSpecPtrOutputWithContext(ctx context.Context) SubscriptionSpecPtrOutput {
	return o
}

func (o SubscriptionSpecPtrOutput) Elem() SubscriptionSpecOutput {
	return o.ApplyT(func(v *SubscriptionSpec) SubscriptionSpec { return *v }).(SubscriptionSpecOutput)
}

func (o SubscriptionSpecPtrOutput) Channel() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionSpec) *string {
		if v == nil {
			return nil
		}
		return &v.Channel
	}).(pulumi.StringPtrOutput)
}

// ObjectReference contains enough information to let you inspect or modify the referred object. --- New uses of this type are discouraged because of difficulty describing its usage when embedded in APIs.  1. Ignored fields.  It includes many fields which are not generally honored.  For instance, ResourceVersion and FieldPath are both very rarely valid in actual usage.  2. Invalid usage help.  It is impossible to add specific help for individual usage.  In most embedded usages, there are particular     restrictions like, "must refer only to types A and B" or "UID not honored" or "name must be restricted".     Those cannot be well described when embedded.  3. Inconsistent validation.  Because the usages are different, the validation rules are different by usage, which makes it hard for users to predict what will happen.  4. The fields are both imprecise and overly precise.  Kind is not a precise mapping to a URL. This can produce ambiguity     during interpretation and require a REST mapping.  In most cases, the dependency is on the group,resource tuple     and the version of the actual struct is irrelevant.  5. We cannot easily change it.  Because this type is embedded in many locations, updates to this type     will affect numerous schemas.  Don't make new APIs embed an underspecified API type they do not control. Instead of using this type, create a locally provided and used type that is well-focused on your reference. For example, ServiceReferences for admission registration: https://github.com/kubernetes/api/blob/release-1.17/admissionregistration/v1/types.go#L533 .
func (o SubscriptionSpecPtrOutput) Hooksecretref() SubscriptionSpecHooksecretrefPtrOutput {
	return o.ApplyT(func(v *SubscriptionSpec) *SubscriptionSpecHooksecretref {
		if v == nil {
			return nil
		}
		return v.Hooksecretref
	}).(SubscriptionSpecHooksecretrefPtrOutput)
}

// To specify 1 package in channel
func (o SubscriptionSpecPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionSpec) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// for hub use only to specify the overrides when apply to clusters
func (o SubscriptionSpecPtrOutput) Overrides() SubscriptionSpecOverridesArrayOutput {
	return o.ApplyT(func(v *SubscriptionSpec) []SubscriptionSpecOverrides {
		if v == nil {
			return nil
		}
		return v.Overrides
	}).(SubscriptionSpecOverridesArrayOutput)
}

// To specify more than 1 package in channel
func (o SubscriptionSpecPtrOutput) PackageFilter() SubscriptionSpecPackageFilterPtrOutput {
	return o.ApplyT(func(v *SubscriptionSpec) *SubscriptionSpecPackageFilter {
		if v == nil {
			return nil
		}
		return v.PackageFilter
	}).(SubscriptionSpecPackageFilterPtrOutput)
}

// To provide flexibility to override package in channel with local input
func (o SubscriptionSpecPtrOutput) PackageOverrides() SubscriptionSpecPackageOverridesArrayOutput {
	return o.ApplyT(func(v *SubscriptionSpec) []SubscriptionSpecPackageOverrides {
		if v == nil {
			return nil
		}
		return v.PackageOverrides
	}).(SubscriptionSpecPackageOverridesArrayOutput)
}

// For hub use only, to specify which clusters to go to
func (o SubscriptionSpecPtrOutput) Placement() SubscriptionSpecPlacementPtrOutput {
	return o.ApplyT(func(v *SubscriptionSpec) *SubscriptionSpecPlacement {
		if v == nil {
			return nil
		}
		return v.Placement
	}).(SubscriptionSpecPlacementPtrOutput)
}

// help user control when the subscription will take affect
func (o SubscriptionSpecPtrOutput) Timewindow() SubscriptionSpecTimewindowPtrOutput {
	return o.ApplyT(func(v *SubscriptionSpec) *SubscriptionSpecTimewindow {
		if v == nil {
			return nil
		}
		return v.Timewindow
	}).(SubscriptionSpecTimewindowPtrOutput)
}

// ObjectReference contains enough information to let you inspect or modify the referred object. --- New uses of this type are discouraged because of difficulty describing its usage when embedded in APIs.  1. Ignored fields.  It includes many fields which are not generally honored.  For instance, ResourceVersion and FieldPath are both very rarely valid in actual usage.  2. Invalid usage help.  It is impossible to add specific help for individual usage.  In most embedded usages, there are particular     restrictions like, "must refer only to types A and B" or "UID not honored" or "name must be restricted".     Those cannot be well described when embedded.  3. Inconsistent validation.  Because the usages are different, the validation rules are different by usage, which makes it hard for users to predict what will happen.  4. The fields are both imprecise and overly precise.  Kind is not a precise mapping to a URL. This can produce ambiguity     during interpretation and require a REST mapping.  In most cases, the dependency is on the group,resource tuple     and the version of the actual struct is irrelevant.  5. We cannot easily change it.  Because this type is embedded in many locations, updates to this type     will affect numerous schemas.  Don't make new APIs embed an underspecified API type they do not control. Instead of using this type, create a locally provided and used type that is well-focused on your reference. For example, ServiceReferences for admission registration: https://github.com/kubernetes/api/blob/release-1.17/admissionregistration/v1/types.go#L533 .
type SubscriptionSpecHooksecretref struct {
	// API version of the referent.
	ApiVersion *string `pulumi:"apiVersion"`
	// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
	FieldPath *string `pulumi:"fieldPath"`
	// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name *string `pulumi:"name"`
	// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
	Namespace *string `pulumi:"namespace"`
	// Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
	ResourceVersion *string `pulumi:"resourceVersion"`
	// UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
	Uid *string `pulumi:"uid"`
}

// SubscriptionSpecHooksecretrefInput is an input type that accepts SubscriptionSpecHooksecretrefArgs and SubscriptionSpecHooksecretrefOutput values.
// You can construct a concrete instance of `SubscriptionSpecHooksecretrefInput` via:
//
//          SubscriptionSpecHooksecretrefArgs{...}
type SubscriptionSpecHooksecretrefInput interface {
	pulumi.Input

	ToSubscriptionSpecHooksecretrefOutput() SubscriptionSpecHooksecretrefOutput
	ToSubscriptionSpecHooksecretrefOutputWithContext(context.Context) SubscriptionSpecHooksecretrefOutput
}

// ObjectReference contains enough information to let you inspect or modify the referred object. --- New uses of this type are discouraged because of difficulty describing its usage when embedded in APIs.  1. Ignored fields.  It includes many fields which are not generally honored.  For instance, ResourceVersion and FieldPath are both very rarely valid in actual usage.  2. Invalid usage help.  It is impossible to add specific help for individual usage.  In most embedded usages, there are particular     restrictions like, "must refer only to types A and B" or "UID not honored" or "name must be restricted".     Those cannot be well described when embedded.  3. Inconsistent validation.  Because the usages are different, the validation rules are different by usage, which makes it hard for users to predict what will happen.  4. The fields are both imprecise and overly precise.  Kind is not a precise mapping to a URL. This can produce ambiguity     during interpretation and require a REST mapping.  In most cases, the dependency is on the group,resource tuple     and the version of the actual struct is irrelevant.  5. We cannot easily change it.  Because this type is embedded in many locations, updates to this type     will affect numerous schemas.  Don't make new APIs embed an underspecified API type they do not control. Instead of using this type, create a locally provided and used type that is well-focused on your reference. For example, ServiceReferences for admission registration: https://github.com/kubernetes/api/blob/release-1.17/admissionregistration/v1/types.go#L533 .
type SubscriptionSpecHooksecretrefArgs struct {
	// API version of the referent.
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
	FieldPath pulumi.StringPtrInput `pulumi:"fieldPath"`
	// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
	ResourceVersion pulumi.StringPtrInput `pulumi:"resourceVersion"`
	// UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
	Uid pulumi.StringPtrInput `pulumi:"uid"`
}

func (SubscriptionSpecHooksecretrefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionSpecHooksecretref)(nil)).Elem()
}

func (i SubscriptionSpecHooksecretrefArgs) ToSubscriptionSpecHooksecretrefOutput() SubscriptionSpecHooksecretrefOutput {
	return i.ToSubscriptionSpecHooksecretrefOutputWithContext(context.Background())
}

func (i SubscriptionSpecHooksecretrefArgs) ToSubscriptionSpecHooksecretrefOutputWithContext(ctx context.Context) SubscriptionSpecHooksecretrefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecHooksecretrefOutput)
}

func (i SubscriptionSpecHooksecretrefArgs) ToSubscriptionSpecHooksecretrefPtrOutput() SubscriptionSpecHooksecretrefPtrOutput {
	return i.ToSubscriptionSpecHooksecretrefPtrOutputWithContext(context.Background())
}

func (i SubscriptionSpecHooksecretrefArgs) ToSubscriptionSpecHooksecretrefPtrOutputWithContext(ctx context.Context) SubscriptionSpecHooksecretrefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecHooksecretrefOutput).ToSubscriptionSpecHooksecretrefPtrOutputWithContext(ctx)
}

// SubscriptionSpecHooksecretrefPtrInput is an input type that accepts SubscriptionSpecHooksecretrefArgs, SubscriptionSpecHooksecretrefPtr and SubscriptionSpecHooksecretrefPtrOutput values.
// You can construct a concrete instance of `SubscriptionSpecHooksecretrefPtrInput` via:
//
//          SubscriptionSpecHooksecretrefArgs{...}
//
//  or:
//
//          nil
type SubscriptionSpecHooksecretrefPtrInput interface {
	pulumi.Input

	ToSubscriptionSpecHooksecretrefPtrOutput() SubscriptionSpecHooksecretrefPtrOutput
	ToSubscriptionSpecHooksecretrefPtrOutputWithContext(context.Context) SubscriptionSpecHooksecretrefPtrOutput
}

type subscriptionSpecHooksecretrefPtrType SubscriptionSpecHooksecretrefArgs

func SubscriptionSpecHooksecretrefPtr(v *SubscriptionSpecHooksecretrefArgs) SubscriptionSpecHooksecretrefPtrInput {
	return (*subscriptionSpecHooksecretrefPtrType)(v)
}

func (*subscriptionSpecHooksecretrefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SubscriptionSpecHooksecretref)(nil)).Elem()
}

func (i *subscriptionSpecHooksecretrefPtrType) ToSubscriptionSpecHooksecretrefPtrOutput() SubscriptionSpecHooksecretrefPtrOutput {
	return i.ToSubscriptionSpecHooksecretrefPtrOutputWithContext(context.Background())
}

func (i *subscriptionSpecHooksecretrefPtrType) ToSubscriptionSpecHooksecretrefPtrOutputWithContext(ctx context.Context) SubscriptionSpecHooksecretrefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecHooksecretrefPtrOutput)
}

// ObjectReference contains enough information to let you inspect or modify the referred object. --- New uses of this type are discouraged because of difficulty describing its usage when embedded in APIs.  1. Ignored fields.  It includes many fields which are not generally honored.  For instance, ResourceVersion and FieldPath are both very rarely valid in actual usage.  2. Invalid usage help.  It is impossible to add specific help for individual usage.  In most embedded usages, there are particular     restrictions like, "must refer only to types A and B" or "UID not honored" or "name must be restricted".     Those cannot be well described when embedded.  3. Inconsistent validation.  Because the usages are different, the validation rules are different by usage, which makes it hard for users to predict what will happen.  4. The fields are both imprecise and overly precise.  Kind is not a precise mapping to a URL. This can produce ambiguity     during interpretation and require a REST mapping.  In most cases, the dependency is on the group,resource tuple     and the version of the actual struct is irrelevant.  5. We cannot easily change it.  Because this type is embedded in many locations, updates to this type     will affect numerous schemas.  Don't make new APIs embed an underspecified API type they do not control. Instead of using this type, create a locally provided and used type that is well-focused on your reference. For example, ServiceReferences for admission registration: https://github.com/kubernetes/api/blob/release-1.17/admissionregistration/v1/types.go#L533 .
type SubscriptionSpecHooksecretrefOutput struct{ *pulumi.OutputState }

func (SubscriptionSpecHooksecretrefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionSpecHooksecretref)(nil)).Elem()
}

func (o SubscriptionSpecHooksecretrefOutput) ToSubscriptionSpecHooksecretrefOutput() SubscriptionSpecHooksecretrefOutput {
	return o
}

func (o SubscriptionSpecHooksecretrefOutput) ToSubscriptionSpecHooksecretrefOutputWithContext(ctx context.Context) SubscriptionSpecHooksecretrefOutput {
	return o
}

func (o SubscriptionSpecHooksecretrefOutput) ToSubscriptionSpecHooksecretrefPtrOutput() SubscriptionSpecHooksecretrefPtrOutput {
	return o.ToSubscriptionSpecHooksecretrefPtrOutputWithContext(context.Background())
}

func (o SubscriptionSpecHooksecretrefOutput) ToSubscriptionSpecHooksecretrefPtrOutputWithContext(ctx context.Context) SubscriptionSpecHooksecretrefPtrOutput {
	return o.ApplyT(func(v SubscriptionSpecHooksecretref) *SubscriptionSpecHooksecretref {
		return &v
	}).(SubscriptionSpecHooksecretrefPtrOutput)
}

// API version of the referent.
func (o SubscriptionSpecHooksecretrefOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionSpecHooksecretref) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
func (o SubscriptionSpecHooksecretrefOutput) FieldPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionSpecHooksecretref) *string { return v.FieldPath }).(pulumi.StringPtrOutput)
}

// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o SubscriptionSpecHooksecretrefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionSpecHooksecretref) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o SubscriptionSpecHooksecretrefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionSpecHooksecretref) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
func (o SubscriptionSpecHooksecretrefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionSpecHooksecretref) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
func (o SubscriptionSpecHooksecretrefOutput) ResourceVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionSpecHooksecretref) *string { return v.ResourceVersion }).(pulumi.StringPtrOutput)
}

// UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
func (o SubscriptionSpecHooksecretrefOutput) Uid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionSpecHooksecretref) *string { return v.Uid }).(pulumi.StringPtrOutput)
}

type SubscriptionSpecHooksecretrefPtrOutput struct{ *pulumi.OutputState }

func (SubscriptionSpecHooksecretrefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SubscriptionSpecHooksecretref)(nil)).Elem()
}

func (o SubscriptionSpecHooksecretrefPtrOutput) ToSubscriptionSpecHooksecretrefPtrOutput() SubscriptionSpecHooksecretrefPtrOutput {
	return o
}

func (o SubscriptionSpecHooksecretrefPtrOutput) ToSubscriptionSpecHooksecretrefPtrOutputWithContext(ctx context.Context) SubscriptionSpecHooksecretrefPtrOutput {
	return o
}

func (o SubscriptionSpecHooksecretrefPtrOutput) Elem() SubscriptionSpecHooksecretrefOutput {
	return o.ApplyT(func(v *SubscriptionSpecHooksecretref) SubscriptionSpecHooksecretref { return *v }).(SubscriptionSpecHooksecretrefOutput)
}

// API version of the referent.
func (o SubscriptionSpecHooksecretrefPtrOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionSpecHooksecretref) *string {
		if v == nil {
			return nil
		}
		return v.ApiVersion
	}).(pulumi.StringPtrOutput)
}

// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
func (o SubscriptionSpecHooksecretrefPtrOutput) FieldPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionSpecHooksecretref) *string {
		if v == nil {
			return nil
		}
		return v.FieldPath
	}).(pulumi.StringPtrOutput)
}

// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o SubscriptionSpecHooksecretrefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionSpecHooksecretref) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o SubscriptionSpecHooksecretrefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionSpecHooksecretref) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
func (o SubscriptionSpecHooksecretrefPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionSpecHooksecretref) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
func (o SubscriptionSpecHooksecretrefPtrOutput) ResourceVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionSpecHooksecretref) *string {
		if v == nil {
			return nil
		}
		return v.ResourceVersion
	}).(pulumi.StringPtrOutput)
}

// UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
func (o SubscriptionSpecHooksecretrefPtrOutput) Uid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionSpecHooksecretref) *string {
		if v == nil {
			return nil
		}
		return v.Uid
	}).(pulumi.StringPtrOutput)
}

// Overrides field in deployable
type SubscriptionSpecOverrides struct {
	ClusterName      string                   `pulumi:"clusterName"`
	ClusterOverrides []map[string]interface{} `pulumi:"clusterOverrides"`
}

// SubscriptionSpecOverridesInput is an input type that accepts SubscriptionSpecOverridesArgs and SubscriptionSpecOverridesOutput values.
// You can construct a concrete instance of `SubscriptionSpecOverridesInput` via:
//
//          SubscriptionSpecOverridesArgs{...}
type SubscriptionSpecOverridesInput interface {
	pulumi.Input

	ToSubscriptionSpecOverridesOutput() SubscriptionSpecOverridesOutput
	ToSubscriptionSpecOverridesOutputWithContext(context.Context) SubscriptionSpecOverridesOutput
}

// Overrides field in deployable
type SubscriptionSpecOverridesArgs struct {
	ClusterName      pulumi.StringInput   `pulumi:"clusterName"`
	ClusterOverrides pulumi.MapArrayInput `pulumi:"clusterOverrides"`
}

func (SubscriptionSpecOverridesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionSpecOverrides)(nil)).Elem()
}

func (i SubscriptionSpecOverridesArgs) ToSubscriptionSpecOverridesOutput() SubscriptionSpecOverridesOutput {
	return i.ToSubscriptionSpecOverridesOutputWithContext(context.Background())
}

func (i SubscriptionSpecOverridesArgs) ToSubscriptionSpecOverridesOutputWithContext(ctx context.Context) SubscriptionSpecOverridesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecOverridesOutput)
}

// SubscriptionSpecOverridesArrayInput is an input type that accepts SubscriptionSpecOverridesArray and SubscriptionSpecOverridesArrayOutput values.
// You can construct a concrete instance of `SubscriptionSpecOverridesArrayInput` via:
//
//          SubscriptionSpecOverridesArray{ SubscriptionSpecOverridesArgs{...} }
type SubscriptionSpecOverridesArrayInput interface {
	pulumi.Input

	ToSubscriptionSpecOverridesArrayOutput() SubscriptionSpecOverridesArrayOutput
	ToSubscriptionSpecOverridesArrayOutputWithContext(context.Context) SubscriptionSpecOverridesArrayOutput
}

type SubscriptionSpecOverridesArray []SubscriptionSpecOverridesInput

func (SubscriptionSpecOverridesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SubscriptionSpecOverrides)(nil)).Elem()
}

func (i SubscriptionSpecOverridesArray) ToSubscriptionSpecOverridesArrayOutput() SubscriptionSpecOverridesArrayOutput {
	return i.ToSubscriptionSpecOverridesArrayOutputWithContext(context.Background())
}

func (i SubscriptionSpecOverridesArray) ToSubscriptionSpecOverridesArrayOutputWithContext(ctx context.Context) SubscriptionSpecOverridesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecOverridesArrayOutput)
}

// Overrides field in deployable
type SubscriptionSpecOverridesOutput struct{ *pulumi.OutputState }

func (SubscriptionSpecOverridesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionSpecOverrides)(nil)).Elem()
}

func (o SubscriptionSpecOverridesOutput) ToSubscriptionSpecOverridesOutput() SubscriptionSpecOverridesOutput {
	return o
}

func (o SubscriptionSpecOverridesOutput) ToSubscriptionSpecOverridesOutputWithContext(ctx context.Context) SubscriptionSpecOverridesOutput {
	return o
}

func (o SubscriptionSpecOverridesOutput) ClusterName() pulumi.StringOutput {
	return o.ApplyT(func(v SubscriptionSpecOverrides) string { return v.ClusterName }).(pulumi.StringOutput)
}

func (o SubscriptionSpecOverridesOutput) ClusterOverrides() pulumi.MapArrayOutput {
	return o.ApplyT(func(v SubscriptionSpecOverrides) []map[string]interface{} { return v.ClusterOverrides }).(pulumi.MapArrayOutput)
}

type SubscriptionSpecOverridesArrayOutput struct{ *pulumi.OutputState }

func (SubscriptionSpecOverridesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SubscriptionSpecOverrides)(nil)).Elem()
}

func (o SubscriptionSpecOverridesArrayOutput) ToSubscriptionSpecOverridesArrayOutput() SubscriptionSpecOverridesArrayOutput {
	return o
}

func (o SubscriptionSpecOverridesArrayOutput) ToSubscriptionSpecOverridesArrayOutputWithContext(ctx context.Context) SubscriptionSpecOverridesArrayOutput {
	return o
}

func (o SubscriptionSpecOverridesArrayOutput) Index(i pulumi.IntInput) SubscriptionSpecOverridesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SubscriptionSpecOverrides {
		return vs[0].([]SubscriptionSpecOverrides)[vs[1].(int)]
	}).(SubscriptionSpecOverridesOutput)
}

// ClusterOverride describes rules for override
type SubscriptionSpecOverridesClusterOverrides struct {
}

// SubscriptionSpecOverridesClusterOverridesInput is an input type that accepts SubscriptionSpecOverridesClusterOverridesArgs and SubscriptionSpecOverridesClusterOverridesOutput values.
// You can construct a concrete instance of `SubscriptionSpecOverridesClusterOverridesInput` via:
//
//          SubscriptionSpecOverridesClusterOverridesArgs{...}
type SubscriptionSpecOverridesClusterOverridesInput interface {
	pulumi.Input

	ToSubscriptionSpecOverridesClusterOverridesOutput() SubscriptionSpecOverridesClusterOverridesOutput
	ToSubscriptionSpecOverridesClusterOverridesOutputWithContext(context.Context) SubscriptionSpecOverridesClusterOverridesOutput
}

// ClusterOverride describes rules for override
type SubscriptionSpecOverridesClusterOverridesArgs struct {
}

func (SubscriptionSpecOverridesClusterOverridesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionSpecOverridesClusterOverrides)(nil)).Elem()
}

func (i SubscriptionSpecOverridesClusterOverridesArgs) ToSubscriptionSpecOverridesClusterOverridesOutput() SubscriptionSpecOverridesClusterOverridesOutput {
	return i.ToSubscriptionSpecOverridesClusterOverridesOutputWithContext(context.Background())
}

func (i SubscriptionSpecOverridesClusterOverridesArgs) ToSubscriptionSpecOverridesClusterOverridesOutputWithContext(ctx context.Context) SubscriptionSpecOverridesClusterOverridesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecOverridesClusterOverridesOutput)
}

// ClusterOverride describes rules for override
type SubscriptionSpecOverridesClusterOverridesOutput struct{ *pulumi.OutputState }

func (SubscriptionSpecOverridesClusterOverridesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionSpecOverridesClusterOverrides)(nil)).Elem()
}

func (o SubscriptionSpecOverridesClusterOverridesOutput) ToSubscriptionSpecOverridesClusterOverridesOutput() SubscriptionSpecOverridesClusterOverridesOutput {
	return o
}

func (o SubscriptionSpecOverridesClusterOverridesOutput) ToSubscriptionSpecOverridesClusterOverridesOutputWithContext(ctx context.Context) SubscriptionSpecOverridesClusterOverridesOutput {
	return o
}

// To specify more than 1 package in channel
type SubscriptionSpecPackageFilter struct {
	Annotations map[string]string `pulumi:"annotations"`
	// LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
	FilterRef *SubscriptionSpecPackageFilterFilterRef `pulumi:"filterRef"`
	// A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
	LabelSelector *SubscriptionSpecPackageFilterLabelSelector `pulumi:"labelSelector"`
	Version       *string                                     `pulumi:"version"`
}

// SubscriptionSpecPackageFilterInput is an input type that accepts SubscriptionSpecPackageFilterArgs and SubscriptionSpecPackageFilterOutput values.
// You can construct a concrete instance of `SubscriptionSpecPackageFilterInput` via:
//
//          SubscriptionSpecPackageFilterArgs{...}
type SubscriptionSpecPackageFilterInput interface {
	pulumi.Input

	ToSubscriptionSpecPackageFilterOutput() SubscriptionSpecPackageFilterOutput
	ToSubscriptionSpecPackageFilterOutputWithContext(context.Context) SubscriptionSpecPackageFilterOutput
}

// To specify more than 1 package in channel
type SubscriptionSpecPackageFilterArgs struct {
	Annotations pulumi.StringMapInput `pulumi:"annotations"`
	// LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
	FilterRef SubscriptionSpecPackageFilterFilterRefPtrInput `pulumi:"filterRef"`
	// A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
	LabelSelector SubscriptionSpecPackageFilterLabelSelectorPtrInput `pulumi:"labelSelector"`
	Version       pulumi.StringPtrInput                              `pulumi:"version"`
}

func (SubscriptionSpecPackageFilterArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionSpecPackageFilter)(nil)).Elem()
}

func (i SubscriptionSpecPackageFilterArgs) ToSubscriptionSpecPackageFilterOutput() SubscriptionSpecPackageFilterOutput {
	return i.ToSubscriptionSpecPackageFilterOutputWithContext(context.Background())
}

func (i SubscriptionSpecPackageFilterArgs) ToSubscriptionSpecPackageFilterOutputWithContext(ctx context.Context) SubscriptionSpecPackageFilterOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecPackageFilterOutput)
}

func (i SubscriptionSpecPackageFilterArgs) ToSubscriptionSpecPackageFilterPtrOutput() SubscriptionSpecPackageFilterPtrOutput {
	return i.ToSubscriptionSpecPackageFilterPtrOutputWithContext(context.Background())
}

func (i SubscriptionSpecPackageFilterArgs) ToSubscriptionSpecPackageFilterPtrOutputWithContext(ctx context.Context) SubscriptionSpecPackageFilterPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecPackageFilterOutput).ToSubscriptionSpecPackageFilterPtrOutputWithContext(ctx)
}

// SubscriptionSpecPackageFilterPtrInput is an input type that accepts SubscriptionSpecPackageFilterArgs, SubscriptionSpecPackageFilterPtr and SubscriptionSpecPackageFilterPtrOutput values.
// You can construct a concrete instance of `SubscriptionSpecPackageFilterPtrInput` via:
//
//          SubscriptionSpecPackageFilterArgs{...}
//
//  or:
//
//          nil
type SubscriptionSpecPackageFilterPtrInput interface {
	pulumi.Input

	ToSubscriptionSpecPackageFilterPtrOutput() SubscriptionSpecPackageFilterPtrOutput
	ToSubscriptionSpecPackageFilterPtrOutputWithContext(context.Context) SubscriptionSpecPackageFilterPtrOutput
}

type subscriptionSpecPackageFilterPtrType SubscriptionSpecPackageFilterArgs

func SubscriptionSpecPackageFilterPtr(v *SubscriptionSpecPackageFilterArgs) SubscriptionSpecPackageFilterPtrInput {
	return (*subscriptionSpecPackageFilterPtrType)(v)
}

func (*subscriptionSpecPackageFilterPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SubscriptionSpecPackageFilter)(nil)).Elem()
}

func (i *subscriptionSpecPackageFilterPtrType) ToSubscriptionSpecPackageFilterPtrOutput() SubscriptionSpecPackageFilterPtrOutput {
	return i.ToSubscriptionSpecPackageFilterPtrOutputWithContext(context.Background())
}

func (i *subscriptionSpecPackageFilterPtrType) ToSubscriptionSpecPackageFilterPtrOutputWithContext(ctx context.Context) SubscriptionSpecPackageFilterPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecPackageFilterPtrOutput)
}

// To specify more than 1 package in channel
type SubscriptionSpecPackageFilterOutput struct{ *pulumi.OutputState }

func (SubscriptionSpecPackageFilterOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionSpecPackageFilter)(nil)).Elem()
}

func (o SubscriptionSpecPackageFilterOutput) ToSubscriptionSpecPackageFilterOutput() SubscriptionSpecPackageFilterOutput {
	return o
}

func (o SubscriptionSpecPackageFilterOutput) ToSubscriptionSpecPackageFilterOutputWithContext(ctx context.Context) SubscriptionSpecPackageFilterOutput {
	return o
}

func (o SubscriptionSpecPackageFilterOutput) ToSubscriptionSpecPackageFilterPtrOutput() SubscriptionSpecPackageFilterPtrOutput {
	return o.ToSubscriptionSpecPackageFilterPtrOutputWithContext(context.Background())
}

func (o SubscriptionSpecPackageFilterOutput) ToSubscriptionSpecPackageFilterPtrOutputWithContext(ctx context.Context) SubscriptionSpecPackageFilterPtrOutput {
	return o.ApplyT(func(v SubscriptionSpecPackageFilter) *SubscriptionSpecPackageFilter {
		return &v
	}).(SubscriptionSpecPackageFilterPtrOutput)
}
func (o SubscriptionSpecPackageFilterOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v SubscriptionSpecPackageFilter) map[string]string { return v.Annotations }).(pulumi.StringMapOutput)
}

// LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
func (o SubscriptionSpecPackageFilterOutput) FilterRef() SubscriptionSpecPackageFilterFilterRefPtrOutput {
	return o.ApplyT(func(v SubscriptionSpecPackageFilter) *SubscriptionSpecPackageFilterFilterRef { return v.FilterRef }).(SubscriptionSpecPackageFilterFilterRefPtrOutput)
}

// A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
func (o SubscriptionSpecPackageFilterOutput) LabelSelector() SubscriptionSpecPackageFilterLabelSelectorPtrOutput {
	return o.ApplyT(func(v SubscriptionSpecPackageFilter) *SubscriptionSpecPackageFilterLabelSelector {
		return v.LabelSelector
	}).(SubscriptionSpecPackageFilterLabelSelectorPtrOutput)
}

func (o SubscriptionSpecPackageFilterOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionSpecPackageFilter) *string { return v.Version }).(pulumi.StringPtrOutput)
}

type SubscriptionSpecPackageFilterPtrOutput struct{ *pulumi.OutputState }

func (SubscriptionSpecPackageFilterPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SubscriptionSpecPackageFilter)(nil)).Elem()
}

func (o SubscriptionSpecPackageFilterPtrOutput) ToSubscriptionSpecPackageFilterPtrOutput() SubscriptionSpecPackageFilterPtrOutput {
	return o
}

func (o SubscriptionSpecPackageFilterPtrOutput) ToSubscriptionSpecPackageFilterPtrOutputWithContext(ctx context.Context) SubscriptionSpecPackageFilterPtrOutput {
	return o
}

func (o SubscriptionSpecPackageFilterPtrOutput) Elem() SubscriptionSpecPackageFilterOutput {
	return o.ApplyT(func(v *SubscriptionSpecPackageFilter) SubscriptionSpecPackageFilter { return *v }).(SubscriptionSpecPackageFilterOutput)
}

func (o SubscriptionSpecPackageFilterPtrOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *SubscriptionSpecPackageFilter) map[string]string {
		if v == nil {
			return nil
		}
		return v.Annotations
	}).(pulumi.StringMapOutput)
}

// LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
func (o SubscriptionSpecPackageFilterPtrOutput) FilterRef() SubscriptionSpecPackageFilterFilterRefPtrOutput {
	return o.ApplyT(func(v *SubscriptionSpecPackageFilter) *SubscriptionSpecPackageFilterFilterRef {
		if v == nil {
			return nil
		}
		return v.FilterRef
	}).(SubscriptionSpecPackageFilterFilterRefPtrOutput)
}

// A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
func (o SubscriptionSpecPackageFilterPtrOutput) LabelSelector() SubscriptionSpecPackageFilterLabelSelectorPtrOutput {
	return o.ApplyT(func(v *SubscriptionSpecPackageFilter) *SubscriptionSpecPackageFilterLabelSelector {
		if v == nil {
			return nil
		}
		return v.LabelSelector
	}).(SubscriptionSpecPackageFilterLabelSelectorPtrOutput)
}

func (o SubscriptionSpecPackageFilterPtrOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionSpecPackageFilter) *string {
		if v == nil {
			return nil
		}
		return v.Version
	}).(pulumi.StringPtrOutput)
}

type SubscriptionSpecPackageFilterAnnotations struct {
}

// SubscriptionSpecPackageFilterAnnotationsInput is an input type that accepts SubscriptionSpecPackageFilterAnnotationsArgs and SubscriptionSpecPackageFilterAnnotationsOutput values.
// You can construct a concrete instance of `SubscriptionSpecPackageFilterAnnotationsInput` via:
//
//          SubscriptionSpecPackageFilterAnnotationsArgs{...}
type SubscriptionSpecPackageFilterAnnotationsInput interface {
	pulumi.Input

	ToSubscriptionSpecPackageFilterAnnotationsOutput() SubscriptionSpecPackageFilterAnnotationsOutput
	ToSubscriptionSpecPackageFilterAnnotationsOutputWithContext(context.Context) SubscriptionSpecPackageFilterAnnotationsOutput
}

type SubscriptionSpecPackageFilterAnnotationsArgs struct {
}

func (SubscriptionSpecPackageFilterAnnotationsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionSpecPackageFilterAnnotations)(nil)).Elem()
}

func (i SubscriptionSpecPackageFilterAnnotationsArgs) ToSubscriptionSpecPackageFilterAnnotationsOutput() SubscriptionSpecPackageFilterAnnotationsOutput {
	return i.ToSubscriptionSpecPackageFilterAnnotationsOutputWithContext(context.Background())
}

func (i SubscriptionSpecPackageFilterAnnotationsArgs) ToSubscriptionSpecPackageFilterAnnotationsOutputWithContext(ctx context.Context) SubscriptionSpecPackageFilterAnnotationsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecPackageFilterAnnotationsOutput)
}

type SubscriptionSpecPackageFilterAnnotationsOutput struct{ *pulumi.OutputState }

func (SubscriptionSpecPackageFilterAnnotationsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionSpecPackageFilterAnnotations)(nil)).Elem()
}

func (o SubscriptionSpecPackageFilterAnnotationsOutput) ToSubscriptionSpecPackageFilterAnnotationsOutput() SubscriptionSpecPackageFilterAnnotationsOutput {
	return o
}

func (o SubscriptionSpecPackageFilterAnnotationsOutput) ToSubscriptionSpecPackageFilterAnnotationsOutputWithContext(ctx context.Context) SubscriptionSpecPackageFilterAnnotationsOutput {
	return o
}

// LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
type SubscriptionSpecPackageFilterFilterRef struct {
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
	Name *string `pulumi:"name"`
}

// SubscriptionSpecPackageFilterFilterRefInput is an input type that accepts SubscriptionSpecPackageFilterFilterRefArgs and SubscriptionSpecPackageFilterFilterRefOutput values.
// You can construct a concrete instance of `SubscriptionSpecPackageFilterFilterRefInput` via:
//
//          SubscriptionSpecPackageFilterFilterRefArgs{...}
type SubscriptionSpecPackageFilterFilterRefInput interface {
	pulumi.Input

	ToSubscriptionSpecPackageFilterFilterRefOutput() SubscriptionSpecPackageFilterFilterRefOutput
	ToSubscriptionSpecPackageFilterFilterRefOutputWithContext(context.Context) SubscriptionSpecPackageFilterFilterRefOutput
}

// LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
type SubscriptionSpecPackageFilterFilterRefArgs struct {
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (SubscriptionSpecPackageFilterFilterRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionSpecPackageFilterFilterRef)(nil)).Elem()
}

func (i SubscriptionSpecPackageFilterFilterRefArgs) ToSubscriptionSpecPackageFilterFilterRefOutput() SubscriptionSpecPackageFilterFilterRefOutput {
	return i.ToSubscriptionSpecPackageFilterFilterRefOutputWithContext(context.Background())
}

func (i SubscriptionSpecPackageFilterFilterRefArgs) ToSubscriptionSpecPackageFilterFilterRefOutputWithContext(ctx context.Context) SubscriptionSpecPackageFilterFilterRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecPackageFilterFilterRefOutput)
}

func (i SubscriptionSpecPackageFilterFilterRefArgs) ToSubscriptionSpecPackageFilterFilterRefPtrOutput() SubscriptionSpecPackageFilterFilterRefPtrOutput {
	return i.ToSubscriptionSpecPackageFilterFilterRefPtrOutputWithContext(context.Background())
}

func (i SubscriptionSpecPackageFilterFilterRefArgs) ToSubscriptionSpecPackageFilterFilterRefPtrOutputWithContext(ctx context.Context) SubscriptionSpecPackageFilterFilterRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecPackageFilterFilterRefOutput).ToSubscriptionSpecPackageFilterFilterRefPtrOutputWithContext(ctx)
}

// SubscriptionSpecPackageFilterFilterRefPtrInput is an input type that accepts SubscriptionSpecPackageFilterFilterRefArgs, SubscriptionSpecPackageFilterFilterRefPtr and SubscriptionSpecPackageFilterFilterRefPtrOutput values.
// You can construct a concrete instance of `SubscriptionSpecPackageFilterFilterRefPtrInput` via:
//
//          SubscriptionSpecPackageFilterFilterRefArgs{...}
//
//  or:
//
//          nil
type SubscriptionSpecPackageFilterFilterRefPtrInput interface {
	pulumi.Input

	ToSubscriptionSpecPackageFilterFilterRefPtrOutput() SubscriptionSpecPackageFilterFilterRefPtrOutput
	ToSubscriptionSpecPackageFilterFilterRefPtrOutputWithContext(context.Context) SubscriptionSpecPackageFilterFilterRefPtrOutput
}

type subscriptionSpecPackageFilterFilterRefPtrType SubscriptionSpecPackageFilterFilterRefArgs

func SubscriptionSpecPackageFilterFilterRefPtr(v *SubscriptionSpecPackageFilterFilterRefArgs) SubscriptionSpecPackageFilterFilterRefPtrInput {
	return (*subscriptionSpecPackageFilterFilterRefPtrType)(v)
}

func (*subscriptionSpecPackageFilterFilterRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SubscriptionSpecPackageFilterFilterRef)(nil)).Elem()
}

func (i *subscriptionSpecPackageFilterFilterRefPtrType) ToSubscriptionSpecPackageFilterFilterRefPtrOutput() SubscriptionSpecPackageFilterFilterRefPtrOutput {
	return i.ToSubscriptionSpecPackageFilterFilterRefPtrOutputWithContext(context.Background())
}

func (i *subscriptionSpecPackageFilterFilterRefPtrType) ToSubscriptionSpecPackageFilterFilterRefPtrOutputWithContext(ctx context.Context) SubscriptionSpecPackageFilterFilterRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecPackageFilterFilterRefPtrOutput)
}

// LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
type SubscriptionSpecPackageFilterFilterRefOutput struct{ *pulumi.OutputState }

func (SubscriptionSpecPackageFilterFilterRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionSpecPackageFilterFilterRef)(nil)).Elem()
}

func (o SubscriptionSpecPackageFilterFilterRefOutput) ToSubscriptionSpecPackageFilterFilterRefOutput() SubscriptionSpecPackageFilterFilterRefOutput {
	return o
}

func (o SubscriptionSpecPackageFilterFilterRefOutput) ToSubscriptionSpecPackageFilterFilterRefOutputWithContext(ctx context.Context) SubscriptionSpecPackageFilterFilterRefOutput {
	return o
}

func (o SubscriptionSpecPackageFilterFilterRefOutput) ToSubscriptionSpecPackageFilterFilterRefPtrOutput() SubscriptionSpecPackageFilterFilterRefPtrOutput {
	return o.ToSubscriptionSpecPackageFilterFilterRefPtrOutputWithContext(context.Background())
}

func (o SubscriptionSpecPackageFilterFilterRefOutput) ToSubscriptionSpecPackageFilterFilterRefPtrOutputWithContext(ctx context.Context) SubscriptionSpecPackageFilterFilterRefPtrOutput {
	return o.ApplyT(func(v SubscriptionSpecPackageFilterFilterRef) *SubscriptionSpecPackageFilterFilterRef {
		return &v
	}).(SubscriptionSpecPackageFilterFilterRefPtrOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
func (o SubscriptionSpecPackageFilterFilterRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionSpecPackageFilterFilterRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type SubscriptionSpecPackageFilterFilterRefPtrOutput struct{ *pulumi.OutputState }

func (SubscriptionSpecPackageFilterFilterRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SubscriptionSpecPackageFilterFilterRef)(nil)).Elem()
}

func (o SubscriptionSpecPackageFilterFilterRefPtrOutput) ToSubscriptionSpecPackageFilterFilterRefPtrOutput() SubscriptionSpecPackageFilterFilterRefPtrOutput {
	return o
}

func (o SubscriptionSpecPackageFilterFilterRefPtrOutput) ToSubscriptionSpecPackageFilterFilterRefPtrOutputWithContext(ctx context.Context) SubscriptionSpecPackageFilterFilterRefPtrOutput {
	return o
}

func (o SubscriptionSpecPackageFilterFilterRefPtrOutput) Elem() SubscriptionSpecPackageFilterFilterRefOutput {
	return o.ApplyT(func(v *SubscriptionSpecPackageFilterFilterRef) SubscriptionSpecPackageFilterFilterRef { return *v }).(SubscriptionSpecPackageFilterFilterRefOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
func (o SubscriptionSpecPackageFilterFilterRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionSpecPackageFilterFilterRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
type SubscriptionSpecPackageFilterLabelSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []SubscriptionSpecPackageFilterLabelSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// SubscriptionSpecPackageFilterLabelSelectorInput is an input type that accepts SubscriptionSpecPackageFilterLabelSelectorArgs and SubscriptionSpecPackageFilterLabelSelectorOutput values.
// You can construct a concrete instance of `SubscriptionSpecPackageFilterLabelSelectorInput` via:
//
//          SubscriptionSpecPackageFilterLabelSelectorArgs{...}
type SubscriptionSpecPackageFilterLabelSelectorInput interface {
	pulumi.Input

	ToSubscriptionSpecPackageFilterLabelSelectorOutput() SubscriptionSpecPackageFilterLabelSelectorOutput
	ToSubscriptionSpecPackageFilterLabelSelectorOutputWithContext(context.Context) SubscriptionSpecPackageFilterLabelSelectorOutput
}

// A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
type SubscriptionSpecPackageFilterLabelSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (SubscriptionSpecPackageFilterLabelSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionSpecPackageFilterLabelSelector)(nil)).Elem()
}

func (i SubscriptionSpecPackageFilterLabelSelectorArgs) ToSubscriptionSpecPackageFilterLabelSelectorOutput() SubscriptionSpecPackageFilterLabelSelectorOutput {
	return i.ToSubscriptionSpecPackageFilterLabelSelectorOutputWithContext(context.Background())
}

func (i SubscriptionSpecPackageFilterLabelSelectorArgs) ToSubscriptionSpecPackageFilterLabelSelectorOutputWithContext(ctx context.Context) SubscriptionSpecPackageFilterLabelSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecPackageFilterLabelSelectorOutput)
}

func (i SubscriptionSpecPackageFilterLabelSelectorArgs) ToSubscriptionSpecPackageFilterLabelSelectorPtrOutput() SubscriptionSpecPackageFilterLabelSelectorPtrOutput {
	return i.ToSubscriptionSpecPackageFilterLabelSelectorPtrOutputWithContext(context.Background())
}

func (i SubscriptionSpecPackageFilterLabelSelectorArgs) ToSubscriptionSpecPackageFilterLabelSelectorPtrOutputWithContext(ctx context.Context) SubscriptionSpecPackageFilterLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecPackageFilterLabelSelectorOutput).ToSubscriptionSpecPackageFilterLabelSelectorPtrOutputWithContext(ctx)
}

// SubscriptionSpecPackageFilterLabelSelectorPtrInput is an input type that accepts SubscriptionSpecPackageFilterLabelSelectorArgs, SubscriptionSpecPackageFilterLabelSelectorPtr and SubscriptionSpecPackageFilterLabelSelectorPtrOutput values.
// You can construct a concrete instance of `SubscriptionSpecPackageFilterLabelSelectorPtrInput` via:
//
//          SubscriptionSpecPackageFilterLabelSelectorArgs{...}
//
//  or:
//
//          nil
type SubscriptionSpecPackageFilterLabelSelectorPtrInput interface {
	pulumi.Input

	ToSubscriptionSpecPackageFilterLabelSelectorPtrOutput() SubscriptionSpecPackageFilterLabelSelectorPtrOutput
	ToSubscriptionSpecPackageFilterLabelSelectorPtrOutputWithContext(context.Context) SubscriptionSpecPackageFilterLabelSelectorPtrOutput
}

type subscriptionSpecPackageFilterLabelSelectorPtrType SubscriptionSpecPackageFilterLabelSelectorArgs

func SubscriptionSpecPackageFilterLabelSelectorPtr(v *SubscriptionSpecPackageFilterLabelSelectorArgs) SubscriptionSpecPackageFilterLabelSelectorPtrInput {
	return (*subscriptionSpecPackageFilterLabelSelectorPtrType)(v)
}

func (*subscriptionSpecPackageFilterLabelSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SubscriptionSpecPackageFilterLabelSelector)(nil)).Elem()
}

func (i *subscriptionSpecPackageFilterLabelSelectorPtrType) ToSubscriptionSpecPackageFilterLabelSelectorPtrOutput() SubscriptionSpecPackageFilterLabelSelectorPtrOutput {
	return i.ToSubscriptionSpecPackageFilterLabelSelectorPtrOutputWithContext(context.Background())
}

func (i *subscriptionSpecPackageFilterLabelSelectorPtrType) ToSubscriptionSpecPackageFilterLabelSelectorPtrOutputWithContext(ctx context.Context) SubscriptionSpecPackageFilterLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecPackageFilterLabelSelectorPtrOutput)
}

// A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
type SubscriptionSpecPackageFilterLabelSelectorOutput struct{ *pulumi.OutputState }

func (SubscriptionSpecPackageFilterLabelSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionSpecPackageFilterLabelSelector)(nil)).Elem()
}

func (o SubscriptionSpecPackageFilterLabelSelectorOutput) ToSubscriptionSpecPackageFilterLabelSelectorOutput() SubscriptionSpecPackageFilterLabelSelectorOutput {
	return o
}

func (o SubscriptionSpecPackageFilterLabelSelectorOutput) ToSubscriptionSpecPackageFilterLabelSelectorOutputWithContext(ctx context.Context) SubscriptionSpecPackageFilterLabelSelectorOutput {
	return o
}

func (o SubscriptionSpecPackageFilterLabelSelectorOutput) ToSubscriptionSpecPackageFilterLabelSelectorPtrOutput() SubscriptionSpecPackageFilterLabelSelectorPtrOutput {
	return o.ToSubscriptionSpecPackageFilterLabelSelectorPtrOutputWithContext(context.Background())
}

func (o SubscriptionSpecPackageFilterLabelSelectorOutput) ToSubscriptionSpecPackageFilterLabelSelectorPtrOutputWithContext(ctx context.Context) SubscriptionSpecPackageFilterLabelSelectorPtrOutput {
	return o.ApplyT(func(v SubscriptionSpecPackageFilterLabelSelector) *SubscriptionSpecPackageFilterLabelSelector {
		return &v
	}).(SubscriptionSpecPackageFilterLabelSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o SubscriptionSpecPackageFilterLabelSelectorOutput) MatchExpressions() SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v SubscriptionSpecPackageFilterLabelSelector) []SubscriptionSpecPackageFilterLabelSelectorMatchExpressions {
		return v.MatchExpressions
	}).(SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o SubscriptionSpecPackageFilterLabelSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v SubscriptionSpecPackageFilterLabelSelector) map[string]string { return v.MatchLabels }).(pulumi.StringMapOutput)
}

type SubscriptionSpecPackageFilterLabelSelectorPtrOutput struct{ *pulumi.OutputState }

func (SubscriptionSpecPackageFilterLabelSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SubscriptionSpecPackageFilterLabelSelector)(nil)).Elem()
}

func (o SubscriptionSpecPackageFilterLabelSelectorPtrOutput) ToSubscriptionSpecPackageFilterLabelSelectorPtrOutput() SubscriptionSpecPackageFilterLabelSelectorPtrOutput {
	return o
}

func (o SubscriptionSpecPackageFilterLabelSelectorPtrOutput) ToSubscriptionSpecPackageFilterLabelSelectorPtrOutputWithContext(ctx context.Context) SubscriptionSpecPackageFilterLabelSelectorPtrOutput {
	return o
}

func (o SubscriptionSpecPackageFilterLabelSelectorPtrOutput) Elem() SubscriptionSpecPackageFilterLabelSelectorOutput {
	return o.ApplyT(func(v *SubscriptionSpecPackageFilterLabelSelector) SubscriptionSpecPackageFilterLabelSelector {
		return *v
	}).(SubscriptionSpecPackageFilterLabelSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o SubscriptionSpecPackageFilterLabelSelectorPtrOutput) MatchExpressions() SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *SubscriptionSpecPackageFilterLabelSelector) []SubscriptionSpecPackageFilterLabelSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o SubscriptionSpecPackageFilterLabelSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *SubscriptionSpecPackageFilterLabelSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type SubscriptionSpecPackageFilterLabelSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsInput is an input type that accepts SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArgs and SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsInput` via:
//
//          SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArgs{...}
type SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToSubscriptionSpecPackageFilterLabelSelectorMatchExpressionsOutput() SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsOutput
	ToSubscriptionSpecPackageFilterLabelSelectorMatchExpressionsOutputWithContext(context.Context) SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionSpecPackageFilterLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArgs) ToSubscriptionSpecPackageFilterLabelSelectorMatchExpressionsOutput() SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsOutput {
	return i.ToSubscriptionSpecPackageFilterLabelSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArgs) ToSubscriptionSpecPackageFilterLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsOutput)
}

// SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArrayInput is an input type that accepts SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArray and SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArrayInput` via:
//
//          SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArray{ SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArgs{...} }
type SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToSubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArrayOutput() SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArrayOutput
	ToSubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArrayOutputWithContext(context.Context) SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArrayOutput
}

type SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArray []SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsInput

func (SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SubscriptionSpecPackageFilterLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArray) ToSubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArrayOutput() SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArrayOutput {
	return i.ToSubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArray) ToSubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionSpecPackageFilterLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsOutput) ToSubscriptionSpecPackageFilterLabelSelectorMatchExpressionsOutput() SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsOutput {
	return o
}

func (o SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsOutput) ToSubscriptionSpecPackageFilterLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v SubscriptionSpecPackageFilterLabelSelectorMatchExpressions) string { return v.Key }).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
func (o SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v SubscriptionSpecPackageFilterLabelSelectorMatchExpressions) string { return v.Operator }).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
func (o SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v SubscriptionSpecPackageFilterLabelSelectorMatchExpressions) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SubscriptionSpecPackageFilterLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArrayOutput) ToSubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArrayOutput() SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArrayOutput) ToSubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SubscriptionSpecPackageFilterLabelSelectorMatchExpressions {
		return vs[0].([]SubscriptionSpecPackageFilterLabelSelectorMatchExpressions)[vs[1].(int)]
	}).(SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type SubscriptionSpecPackageFilterLabelSelectorMatchLabels struct {
}

// SubscriptionSpecPackageFilterLabelSelectorMatchLabelsInput is an input type that accepts SubscriptionSpecPackageFilterLabelSelectorMatchLabelsArgs and SubscriptionSpecPackageFilterLabelSelectorMatchLabelsOutput values.
// You can construct a concrete instance of `SubscriptionSpecPackageFilterLabelSelectorMatchLabelsInput` via:
//
//          SubscriptionSpecPackageFilterLabelSelectorMatchLabelsArgs{...}
type SubscriptionSpecPackageFilterLabelSelectorMatchLabelsInput interface {
	pulumi.Input

	ToSubscriptionSpecPackageFilterLabelSelectorMatchLabelsOutput() SubscriptionSpecPackageFilterLabelSelectorMatchLabelsOutput
	ToSubscriptionSpecPackageFilterLabelSelectorMatchLabelsOutputWithContext(context.Context) SubscriptionSpecPackageFilterLabelSelectorMatchLabelsOutput
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type SubscriptionSpecPackageFilterLabelSelectorMatchLabelsArgs struct {
}

func (SubscriptionSpecPackageFilterLabelSelectorMatchLabelsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionSpecPackageFilterLabelSelectorMatchLabels)(nil)).Elem()
}

func (i SubscriptionSpecPackageFilterLabelSelectorMatchLabelsArgs) ToSubscriptionSpecPackageFilterLabelSelectorMatchLabelsOutput() SubscriptionSpecPackageFilterLabelSelectorMatchLabelsOutput {
	return i.ToSubscriptionSpecPackageFilterLabelSelectorMatchLabelsOutputWithContext(context.Background())
}

func (i SubscriptionSpecPackageFilterLabelSelectorMatchLabelsArgs) ToSubscriptionSpecPackageFilterLabelSelectorMatchLabelsOutputWithContext(ctx context.Context) SubscriptionSpecPackageFilterLabelSelectorMatchLabelsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecPackageFilterLabelSelectorMatchLabelsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type SubscriptionSpecPackageFilterLabelSelectorMatchLabelsOutput struct{ *pulumi.OutputState }

func (SubscriptionSpecPackageFilterLabelSelectorMatchLabelsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionSpecPackageFilterLabelSelectorMatchLabels)(nil)).Elem()
}

func (o SubscriptionSpecPackageFilterLabelSelectorMatchLabelsOutput) ToSubscriptionSpecPackageFilterLabelSelectorMatchLabelsOutput() SubscriptionSpecPackageFilterLabelSelectorMatchLabelsOutput {
	return o
}

func (o SubscriptionSpecPackageFilterLabelSelectorMatchLabelsOutput) ToSubscriptionSpecPackageFilterLabelSelectorMatchLabelsOutputWithContext(ctx context.Context) SubscriptionSpecPackageFilterLabelSelectorMatchLabelsOutput {
	return o
}

// Overrides field in deployable
type SubscriptionSpecPackageOverrides struct {
	PackageAlias     *string                  `pulumi:"packageAlias"`
	PackageName      string                   `pulumi:"packageName"`
	PackageOverrides []map[string]interface{} `pulumi:"packageOverrides"`
}

// SubscriptionSpecPackageOverridesInput is an input type that accepts SubscriptionSpecPackageOverridesArgs and SubscriptionSpecPackageOverridesOutput values.
// You can construct a concrete instance of `SubscriptionSpecPackageOverridesInput` via:
//
//          SubscriptionSpecPackageOverridesArgs{...}
type SubscriptionSpecPackageOverridesInput interface {
	pulumi.Input

	ToSubscriptionSpecPackageOverridesOutput() SubscriptionSpecPackageOverridesOutput
	ToSubscriptionSpecPackageOverridesOutputWithContext(context.Context) SubscriptionSpecPackageOverridesOutput
}

// Overrides field in deployable
type SubscriptionSpecPackageOverridesArgs struct {
	PackageAlias     pulumi.StringPtrInput `pulumi:"packageAlias"`
	PackageName      pulumi.StringInput    `pulumi:"packageName"`
	PackageOverrides pulumi.MapArrayInput  `pulumi:"packageOverrides"`
}

func (SubscriptionSpecPackageOverridesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionSpecPackageOverrides)(nil)).Elem()
}

func (i SubscriptionSpecPackageOverridesArgs) ToSubscriptionSpecPackageOverridesOutput() SubscriptionSpecPackageOverridesOutput {
	return i.ToSubscriptionSpecPackageOverridesOutputWithContext(context.Background())
}

func (i SubscriptionSpecPackageOverridesArgs) ToSubscriptionSpecPackageOverridesOutputWithContext(ctx context.Context) SubscriptionSpecPackageOverridesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecPackageOverridesOutput)
}

// SubscriptionSpecPackageOverridesArrayInput is an input type that accepts SubscriptionSpecPackageOverridesArray and SubscriptionSpecPackageOverridesArrayOutput values.
// You can construct a concrete instance of `SubscriptionSpecPackageOverridesArrayInput` via:
//
//          SubscriptionSpecPackageOverridesArray{ SubscriptionSpecPackageOverridesArgs{...} }
type SubscriptionSpecPackageOverridesArrayInput interface {
	pulumi.Input

	ToSubscriptionSpecPackageOverridesArrayOutput() SubscriptionSpecPackageOverridesArrayOutput
	ToSubscriptionSpecPackageOverridesArrayOutputWithContext(context.Context) SubscriptionSpecPackageOverridesArrayOutput
}

type SubscriptionSpecPackageOverridesArray []SubscriptionSpecPackageOverridesInput

func (SubscriptionSpecPackageOverridesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SubscriptionSpecPackageOverrides)(nil)).Elem()
}

func (i SubscriptionSpecPackageOverridesArray) ToSubscriptionSpecPackageOverridesArrayOutput() SubscriptionSpecPackageOverridesArrayOutput {
	return i.ToSubscriptionSpecPackageOverridesArrayOutputWithContext(context.Background())
}

func (i SubscriptionSpecPackageOverridesArray) ToSubscriptionSpecPackageOverridesArrayOutputWithContext(ctx context.Context) SubscriptionSpecPackageOverridesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecPackageOverridesArrayOutput)
}

// Overrides field in deployable
type SubscriptionSpecPackageOverridesOutput struct{ *pulumi.OutputState }

func (SubscriptionSpecPackageOverridesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionSpecPackageOverrides)(nil)).Elem()
}

func (o SubscriptionSpecPackageOverridesOutput) ToSubscriptionSpecPackageOverridesOutput() SubscriptionSpecPackageOverridesOutput {
	return o
}

func (o SubscriptionSpecPackageOverridesOutput) ToSubscriptionSpecPackageOverridesOutputWithContext(ctx context.Context) SubscriptionSpecPackageOverridesOutput {
	return o
}

func (o SubscriptionSpecPackageOverridesOutput) PackageAlias() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionSpecPackageOverrides) *string { return v.PackageAlias }).(pulumi.StringPtrOutput)
}

func (o SubscriptionSpecPackageOverridesOutput) PackageName() pulumi.StringOutput {
	return o.ApplyT(func(v SubscriptionSpecPackageOverrides) string { return v.PackageName }).(pulumi.StringOutput)
}

func (o SubscriptionSpecPackageOverridesOutput) PackageOverrides() pulumi.MapArrayOutput {
	return o.ApplyT(func(v SubscriptionSpecPackageOverrides) []map[string]interface{} { return v.PackageOverrides }).(pulumi.MapArrayOutput)
}

type SubscriptionSpecPackageOverridesArrayOutput struct{ *pulumi.OutputState }

func (SubscriptionSpecPackageOverridesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SubscriptionSpecPackageOverrides)(nil)).Elem()
}

func (o SubscriptionSpecPackageOverridesArrayOutput) ToSubscriptionSpecPackageOverridesArrayOutput() SubscriptionSpecPackageOverridesArrayOutput {
	return o
}

func (o SubscriptionSpecPackageOverridesArrayOutput) ToSubscriptionSpecPackageOverridesArrayOutputWithContext(ctx context.Context) SubscriptionSpecPackageOverridesArrayOutput {
	return o
}

func (o SubscriptionSpecPackageOverridesArrayOutput) Index(i pulumi.IntInput) SubscriptionSpecPackageOverridesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SubscriptionSpecPackageOverrides {
		return vs[0].([]SubscriptionSpecPackageOverrides)[vs[1].(int)]
	}).(SubscriptionSpecPackageOverridesOutput)
}

// PackageOverride describes rules for override
type SubscriptionSpecPackageOverridesPackageOverrides struct {
}

// SubscriptionSpecPackageOverridesPackageOverridesInput is an input type that accepts SubscriptionSpecPackageOverridesPackageOverridesArgs and SubscriptionSpecPackageOverridesPackageOverridesOutput values.
// You can construct a concrete instance of `SubscriptionSpecPackageOverridesPackageOverridesInput` via:
//
//          SubscriptionSpecPackageOverridesPackageOverridesArgs{...}
type SubscriptionSpecPackageOverridesPackageOverridesInput interface {
	pulumi.Input

	ToSubscriptionSpecPackageOverridesPackageOverridesOutput() SubscriptionSpecPackageOverridesPackageOverridesOutput
	ToSubscriptionSpecPackageOverridesPackageOverridesOutputWithContext(context.Context) SubscriptionSpecPackageOverridesPackageOverridesOutput
}

// PackageOverride describes rules for override
type SubscriptionSpecPackageOverridesPackageOverridesArgs struct {
}

func (SubscriptionSpecPackageOverridesPackageOverridesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionSpecPackageOverridesPackageOverrides)(nil)).Elem()
}

func (i SubscriptionSpecPackageOverridesPackageOverridesArgs) ToSubscriptionSpecPackageOverridesPackageOverridesOutput() SubscriptionSpecPackageOverridesPackageOverridesOutput {
	return i.ToSubscriptionSpecPackageOverridesPackageOverridesOutputWithContext(context.Background())
}

func (i SubscriptionSpecPackageOverridesPackageOverridesArgs) ToSubscriptionSpecPackageOverridesPackageOverridesOutputWithContext(ctx context.Context) SubscriptionSpecPackageOverridesPackageOverridesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecPackageOverridesPackageOverridesOutput)
}

// PackageOverride describes rules for override
type SubscriptionSpecPackageOverridesPackageOverridesOutput struct{ *pulumi.OutputState }

func (SubscriptionSpecPackageOverridesPackageOverridesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionSpecPackageOverridesPackageOverrides)(nil)).Elem()
}

func (o SubscriptionSpecPackageOverridesPackageOverridesOutput) ToSubscriptionSpecPackageOverridesPackageOverridesOutput() SubscriptionSpecPackageOverridesPackageOverridesOutput {
	return o
}

func (o SubscriptionSpecPackageOverridesPackageOverridesOutput) ToSubscriptionSpecPackageOverridesPackageOverridesOutputWithContext(ctx context.Context) SubscriptionSpecPackageOverridesPackageOverridesOutput {
	return o
}

// For hub use only, to specify which clusters to go to
type SubscriptionSpecPlacement struct {
	// A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
	ClusterSelector *SubscriptionSpecPlacementClusterSelector `pulumi:"clusterSelector"`
	Clusters        []SubscriptionSpecPlacementClusters       `pulumi:"clusters"`
	Local           *bool                                     `pulumi:"local"`
	// ObjectReference contains enough information to let you inspect or modify the referred object.
	PlacementRef *SubscriptionSpecPlacementPlacementRef `pulumi:"placementRef"`
}

// SubscriptionSpecPlacementInput is an input type that accepts SubscriptionSpecPlacementArgs and SubscriptionSpecPlacementOutput values.
// You can construct a concrete instance of `SubscriptionSpecPlacementInput` via:
//
//          SubscriptionSpecPlacementArgs{...}
type SubscriptionSpecPlacementInput interface {
	pulumi.Input

	ToSubscriptionSpecPlacementOutput() SubscriptionSpecPlacementOutput
	ToSubscriptionSpecPlacementOutputWithContext(context.Context) SubscriptionSpecPlacementOutput
}

// For hub use only, to specify which clusters to go to
type SubscriptionSpecPlacementArgs struct {
	// A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
	ClusterSelector SubscriptionSpecPlacementClusterSelectorPtrInput `pulumi:"clusterSelector"`
	Clusters        SubscriptionSpecPlacementClustersArrayInput      `pulumi:"clusters"`
	Local           pulumi.BoolPtrInput                              `pulumi:"local"`
	// ObjectReference contains enough information to let you inspect or modify the referred object.
	PlacementRef SubscriptionSpecPlacementPlacementRefPtrInput `pulumi:"placementRef"`
}

func (SubscriptionSpecPlacementArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionSpecPlacement)(nil)).Elem()
}

func (i SubscriptionSpecPlacementArgs) ToSubscriptionSpecPlacementOutput() SubscriptionSpecPlacementOutput {
	return i.ToSubscriptionSpecPlacementOutputWithContext(context.Background())
}

func (i SubscriptionSpecPlacementArgs) ToSubscriptionSpecPlacementOutputWithContext(ctx context.Context) SubscriptionSpecPlacementOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecPlacementOutput)
}

func (i SubscriptionSpecPlacementArgs) ToSubscriptionSpecPlacementPtrOutput() SubscriptionSpecPlacementPtrOutput {
	return i.ToSubscriptionSpecPlacementPtrOutputWithContext(context.Background())
}

func (i SubscriptionSpecPlacementArgs) ToSubscriptionSpecPlacementPtrOutputWithContext(ctx context.Context) SubscriptionSpecPlacementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecPlacementOutput).ToSubscriptionSpecPlacementPtrOutputWithContext(ctx)
}

// SubscriptionSpecPlacementPtrInput is an input type that accepts SubscriptionSpecPlacementArgs, SubscriptionSpecPlacementPtr and SubscriptionSpecPlacementPtrOutput values.
// You can construct a concrete instance of `SubscriptionSpecPlacementPtrInput` via:
//
//          SubscriptionSpecPlacementArgs{...}
//
//  or:
//
//          nil
type SubscriptionSpecPlacementPtrInput interface {
	pulumi.Input

	ToSubscriptionSpecPlacementPtrOutput() SubscriptionSpecPlacementPtrOutput
	ToSubscriptionSpecPlacementPtrOutputWithContext(context.Context) SubscriptionSpecPlacementPtrOutput
}

type subscriptionSpecPlacementPtrType SubscriptionSpecPlacementArgs

func SubscriptionSpecPlacementPtr(v *SubscriptionSpecPlacementArgs) SubscriptionSpecPlacementPtrInput {
	return (*subscriptionSpecPlacementPtrType)(v)
}

func (*subscriptionSpecPlacementPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SubscriptionSpecPlacement)(nil)).Elem()
}

func (i *subscriptionSpecPlacementPtrType) ToSubscriptionSpecPlacementPtrOutput() SubscriptionSpecPlacementPtrOutput {
	return i.ToSubscriptionSpecPlacementPtrOutputWithContext(context.Background())
}

func (i *subscriptionSpecPlacementPtrType) ToSubscriptionSpecPlacementPtrOutputWithContext(ctx context.Context) SubscriptionSpecPlacementPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecPlacementPtrOutput)
}

// For hub use only, to specify which clusters to go to
type SubscriptionSpecPlacementOutput struct{ *pulumi.OutputState }

func (SubscriptionSpecPlacementOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionSpecPlacement)(nil)).Elem()
}

func (o SubscriptionSpecPlacementOutput) ToSubscriptionSpecPlacementOutput() SubscriptionSpecPlacementOutput {
	return o
}

func (o SubscriptionSpecPlacementOutput) ToSubscriptionSpecPlacementOutputWithContext(ctx context.Context) SubscriptionSpecPlacementOutput {
	return o
}

func (o SubscriptionSpecPlacementOutput) ToSubscriptionSpecPlacementPtrOutput() SubscriptionSpecPlacementPtrOutput {
	return o.ToSubscriptionSpecPlacementPtrOutputWithContext(context.Background())
}

func (o SubscriptionSpecPlacementOutput) ToSubscriptionSpecPlacementPtrOutputWithContext(ctx context.Context) SubscriptionSpecPlacementPtrOutput {
	return o.ApplyT(func(v SubscriptionSpecPlacement) *SubscriptionSpecPlacement {
		return &v
	}).(SubscriptionSpecPlacementPtrOutput)
}

// A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
func (o SubscriptionSpecPlacementOutput) ClusterSelector() SubscriptionSpecPlacementClusterSelectorPtrOutput {
	return o.ApplyT(func(v SubscriptionSpecPlacement) *SubscriptionSpecPlacementClusterSelector { return v.ClusterSelector }).(SubscriptionSpecPlacementClusterSelectorPtrOutput)
}

func (o SubscriptionSpecPlacementOutput) Clusters() SubscriptionSpecPlacementClustersArrayOutput {
	return o.ApplyT(func(v SubscriptionSpecPlacement) []SubscriptionSpecPlacementClusters { return v.Clusters }).(SubscriptionSpecPlacementClustersArrayOutput)
}

func (o SubscriptionSpecPlacementOutput) Local() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v SubscriptionSpecPlacement) *bool { return v.Local }).(pulumi.BoolPtrOutput)
}

// ObjectReference contains enough information to let you inspect or modify the referred object.
func (o SubscriptionSpecPlacementOutput) PlacementRef() SubscriptionSpecPlacementPlacementRefPtrOutput {
	return o.ApplyT(func(v SubscriptionSpecPlacement) *SubscriptionSpecPlacementPlacementRef { return v.PlacementRef }).(SubscriptionSpecPlacementPlacementRefPtrOutput)
}

type SubscriptionSpecPlacementPtrOutput struct{ *pulumi.OutputState }

func (SubscriptionSpecPlacementPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SubscriptionSpecPlacement)(nil)).Elem()
}

func (o SubscriptionSpecPlacementPtrOutput) ToSubscriptionSpecPlacementPtrOutput() SubscriptionSpecPlacementPtrOutput {
	return o
}

func (o SubscriptionSpecPlacementPtrOutput) ToSubscriptionSpecPlacementPtrOutputWithContext(ctx context.Context) SubscriptionSpecPlacementPtrOutput {
	return o
}

func (o SubscriptionSpecPlacementPtrOutput) Elem() SubscriptionSpecPlacementOutput {
	return o.ApplyT(func(v *SubscriptionSpecPlacement) SubscriptionSpecPlacement { return *v }).(SubscriptionSpecPlacementOutput)
}

// A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
func (o SubscriptionSpecPlacementPtrOutput) ClusterSelector() SubscriptionSpecPlacementClusterSelectorPtrOutput {
	return o.ApplyT(func(v *SubscriptionSpecPlacement) *SubscriptionSpecPlacementClusterSelector {
		if v == nil {
			return nil
		}
		return v.ClusterSelector
	}).(SubscriptionSpecPlacementClusterSelectorPtrOutput)
}

func (o SubscriptionSpecPlacementPtrOutput) Clusters() SubscriptionSpecPlacementClustersArrayOutput {
	return o.ApplyT(func(v *SubscriptionSpecPlacement) []SubscriptionSpecPlacementClusters {
		if v == nil {
			return nil
		}
		return v.Clusters
	}).(SubscriptionSpecPlacementClustersArrayOutput)
}

func (o SubscriptionSpecPlacementPtrOutput) Local() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *SubscriptionSpecPlacement) *bool {
		if v == nil {
			return nil
		}
		return v.Local
	}).(pulumi.BoolPtrOutput)
}

// ObjectReference contains enough information to let you inspect or modify the referred object.
func (o SubscriptionSpecPlacementPtrOutput) PlacementRef() SubscriptionSpecPlacementPlacementRefPtrOutput {
	return o.ApplyT(func(v *SubscriptionSpecPlacement) *SubscriptionSpecPlacementPlacementRef {
		if v == nil {
			return nil
		}
		return v.PlacementRef
	}).(SubscriptionSpecPlacementPlacementRefPtrOutput)
}

// A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
type SubscriptionSpecPlacementClusterSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []SubscriptionSpecPlacementClusterSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// SubscriptionSpecPlacementClusterSelectorInput is an input type that accepts SubscriptionSpecPlacementClusterSelectorArgs and SubscriptionSpecPlacementClusterSelectorOutput values.
// You can construct a concrete instance of `SubscriptionSpecPlacementClusterSelectorInput` via:
//
//          SubscriptionSpecPlacementClusterSelectorArgs{...}
type SubscriptionSpecPlacementClusterSelectorInput interface {
	pulumi.Input

	ToSubscriptionSpecPlacementClusterSelectorOutput() SubscriptionSpecPlacementClusterSelectorOutput
	ToSubscriptionSpecPlacementClusterSelectorOutputWithContext(context.Context) SubscriptionSpecPlacementClusterSelectorOutput
}

// A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
type SubscriptionSpecPlacementClusterSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions SubscriptionSpecPlacementClusterSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (SubscriptionSpecPlacementClusterSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionSpecPlacementClusterSelector)(nil)).Elem()
}

func (i SubscriptionSpecPlacementClusterSelectorArgs) ToSubscriptionSpecPlacementClusterSelectorOutput() SubscriptionSpecPlacementClusterSelectorOutput {
	return i.ToSubscriptionSpecPlacementClusterSelectorOutputWithContext(context.Background())
}

func (i SubscriptionSpecPlacementClusterSelectorArgs) ToSubscriptionSpecPlacementClusterSelectorOutputWithContext(ctx context.Context) SubscriptionSpecPlacementClusterSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecPlacementClusterSelectorOutput)
}

func (i SubscriptionSpecPlacementClusterSelectorArgs) ToSubscriptionSpecPlacementClusterSelectorPtrOutput() SubscriptionSpecPlacementClusterSelectorPtrOutput {
	return i.ToSubscriptionSpecPlacementClusterSelectorPtrOutputWithContext(context.Background())
}

func (i SubscriptionSpecPlacementClusterSelectorArgs) ToSubscriptionSpecPlacementClusterSelectorPtrOutputWithContext(ctx context.Context) SubscriptionSpecPlacementClusterSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecPlacementClusterSelectorOutput).ToSubscriptionSpecPlacementClusterSelectorPtrOutputWithContext(ctx)
}

// SubscriptionSpecPlacementClusterSelectorPtrInput is an input type that accepts SubscriptionSpecPlacementClusterSelectorArgs, SubscriptionSpecPlacementClusterSelectorPtr and SubscriptionSpecPlacementClusterSelectorPtrOutput values.
// You can construct a concrete instance of `SubscriptionSpecPlacementClusterSelectorPtrInput` via:
//
//          SubscriptionSpecPlacementClusterSelectorArgs{...}
//
//  or:
//
//          nil
type SubscriptionSpecPlacementClusterSelectorPtrInput interface {
	pulumi.Input

	ToSubscriptionSpecPlacementClusterSelectorPtrOutput() SubscriptionSpecPlacementClusterSelectorPtrOutput
	ToSubscriptionSpecPlacementClusterSelectorPtrOutputWithContext(context.Context) SubscriptionSpecPlacementClusterSelectorPtrOutput
}

type subscriptionSpecPlacementClusterSelectorPtrType SubscriptionSpecPlacementClusterSelectorArgs

func SubscriptionSpecPlacementClusterSelectorPtr(v *SubscriptionSpecPlacementClusterSelectorArgs) SubscriptionSpecPlacementClusterSelectorPtrInput {
	return (*subscriptionSpecPlacementClusterSelectorPtrType)(v)
}

func (*subscriptionSpecPlacementClusterSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SubscriptionSpecPlacementClusterSelector)(nil)).Elem()
}

func (i *subscriptionSpecPlacementClusterSelectorPtrType) ToSubscriptionSpecPlacementClusterSelectorPtrOutput() SubscriptionSpecPlacementClusterSelectorPtrOutput {
	return i.ToSubscriptionSpecPlacementClusterSelectorPtrOutputWithContext(context.Background())
}

func (i *subscriptionSpecPlacementClusterSelectorPtrType) ToSubscriptionSpecPlacementClusterSelectorPtrOutputWithContext(ctx context.Context) SubscriptionSpecPlacementClusterSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecPlacementClusterSelectorPtrOutput)
}

// A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
type SubscriptionSpecPlacementClusterSelectorOutput struct{ *pulumi.OutputState }

func (SubscriptionSpecPlacementClusterSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionSpecPlacementClusterSelector)(nil)).Elem()
}

func (o SubscriptionSpecPlacementClusterSelectorOutput) ToSubscriptionSpecPlacementClusterSelectorOutput() SubscriptionSpecPlacementClusterSelectorOutput {
	return o
}

func (o SubscriptionSpecPlacementClusterSelectorOutput) ToSubscriptionSpecPlacementClusterSelectorOutputWithContext(ctx context.Context) SubscriptionSpecPlacementClusterSelectorOutput {
	return o
}

func (o SubscriptionSpecPlacementClusterSelectorOutput) ToSubscriptionSpecPlacementClusterSelectorPtrOutput() SubscriptionSpecPlacementClusterSelectorPtrOutput {
	return o.ToSubscriptionSpecPlacementClusterSelectorPtrOutputWithContext(context.Background())
}

func (o SubscriptionSpecPlacementClusterSelectorOutput) ToSubscriptionSpecPlacementClusterSelectorPtrOutputWithContext(ctx context.Context) SubscriptionSpecPlacementClusterSelectorPtrOutput {
	return o.ApplyT(func(v SubscriptionSpecPlacementClusterSelector) *SubscriptionSpecPlacementClusterSelector {
		return &v
	}).(SubscriptionSpecPlacementClusterSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o SubscriptionSpecPlacementClusterSelectorOutput) MatchExpressions() SubscriptionSpecPlacementClusterSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v SubscriptionSpecPlacementClusterSelector) []SubscriptionSpecPlacementClusterSelectorMatchExpressions {
		return v.MatchExpressions
	}).(SubscriptionSpecPlacementClusterSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o SubscriptionSpecPlacementClusterSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v SubscriptionSpecPlacementClusterSelector) map[string]string { return v.MatchLabels }).(pulumi.StringMapOutput)
}

type SubscriptionSpecPlacementClusterSelectorPtrOutput struct{ *pulumi.OutputState }

func (SubscriptionSpecPlacementClusterSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SubscriptionSpecPlacementClusterSelector)(nil)).Elem()
}

func (o SubscriptionSpecPlacementClusterSelectorPtrOutput) ToSubscriptionSpecPlacementClusterSelectorPtrOutput() SubscriptionSpecPlacementClusterSelectorPtrOutput {
	return o
}

func (o SubscriptionSpecPlacementClusterSelectorPtrOutput) ToSubscriptionSpecPlacementClusterSelectorPtrOutputWithContext(ctx context.Context) SubscriptionSpecPlacementClusterSelectorPtrOutput {
	return o
}

func (o SubscriptionSpecPlacementClusterSelectorPtrOutput) Elem() SubscriptionSpecPlacementClusterSelectorOutput {
	return o.ApplyT(func(v *SubscriptionSpecPlacementClusterSelector) SubscriptionSpecPlacementClusterSelector { return *v }).(SubscriptionSpecPlacementClusterSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o SubscriptionSpecPlacementClusterSelectorPtrOutput) MatchExpressions() SubscriptionSpecPlacementClusterSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *SubscriptionSpecPlacementClusterSelector) []SubscriptionSpecPlacementClusterSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(SubscriptionSpecPlacementClusterSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o SubscriptionSpecPlacementClusterSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *SubscriptionSpecPlacementClusterSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type SubscriptionSpecPlacementClusterSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// SubscriptionSpecPlacementClusterSelectorMatchExpressionsInput is an input type that accepts SubscriptionSpecPlacementClusterSelectorMatchExpressionsArgs and SubscriptionSpecPlacementClusterSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `SubscriptionSpecPlacementClusterSelectorMatchExpressionsInput` via:
//
//          SubscriptionSpecPlacementClusterSelectorMatchExpressionsArgs{...}
type SubscriptionSpecPlacementClusterSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToSubscriptionSpecPlacementClusterSelectorMatchExpressionsOutput() SubscriptionSpecPlacementClusterSelectorMatchExpressionsOutput
	ToSubscriptionSpecPlacementClusterSelectorMatchExpressionsOutputWithContext(context.Context) SubscriptionSpecPlacementClusterSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type SubscriptionSpecPlacementClusterSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (SubscriptionSpecPlacementClusterSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionSpecPlacementClusterSelectorMatchExpressions)(nil)).Elem()
}

func (i SubscriptionSpecPlacementClusterSelectorMatchExpressionsArgs) ToSubscriptionSpecPlacementClusterSelectorMatchExpressionsOutput() SubscriptionSpecPlacementClusterSelectorMatchExpressionsOutput {
	return i.ToSubscriptionSpecPlacementClusterSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i SubscriptionSpecPlacementClusterSelectorMatchExpressionsArgs) ToSubscriptionSpecPlacementClusterSelectorMatchExpressionsOutputWithContext(ctx context.Context) SubscriptionSpecPlacementClusterSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecPlacementClusterSelectorMatchExpressionsOutput)
}

// SubscriptionSpecPlacementClusterSelectorMatchExpressionsArrayInput is an input type that accepts SubscriptionSpecPlacementClusterSelectorMatchExpressionsArray and SubscriptionSpecPlacementClusterSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `SubscriptionSpecPlacementClusterSelectorMatchExpressionsArrayInput` via:
//
//          SubscriptionSpecPlacementClusterSelectorMatchExpressionsArray{ SubscriptionSpecPlacementClusterSelectorMatchExpressionsArgs{...} }
type SubscriptionSpecPlacementClusterSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToSubscriptionSpecPlacementClusterSelectorMatchExpressionsArrayOutput() SubscriptionSpecPlacementClusterSelectorMatchExpressionsArrayOutput
	ToSubscriptionSpecPlacementClusterSelectorMatchExpressionsArrayOutputWithContext(context.Context) SubscriptionSpecPlacementClusterSelectorMatchExpressionsArrayOutput
}

type SubscriptionSpecPlacementClusterSelectorMatchExpressionsArray []SubscriptionSpecPlacementClusterSelectorMatchExpressionsInput

func (SubscriptionSpecPlacementClusterSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SubscriptionSpecPlacementClusterSelectorMatchExpressions)(nil)).Elem()
}

func (i SubscriptionSpecPlacementClusterSelectorMatchExpressionsArray) ToSubscriptionSpecPlacementClusterSelectorMatchExpressionsArrayOutput() SubscriptionSpecPlacementClusterSelectorMatchExpressionsArrayOutput {
	return i.ToSubscriptionSpecPlacementClusterSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i SubscriptionSpecPlacementClusterSelectorMatchExpressionsArray) ToSubscriptionSpecPlacementClusterSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) SubscriptionSpecPlacementClusterSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecPlacementClusterSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type SubscriptionSpecPlacementClusterSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (SubscriptionSpecPlacementClusterSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionSpecPlacementClusterSelectorMatchExpressions)(nil)).Elem()
}

func (o SubscriptionSpecPlacementClusterSelectorMatchExpressionsOutput) ToSubscriptionSpecPlacementClusterSelectorMatchExpressionsOutput() SubscriptionSpecPlacementClusterSelectorMatchExpressionsOutput {
	return o
}

func (o SubscriptionSpecPlacementClusterSelectorMatchExpressionsOutput) ToSubscriptionSpecPlacementClusterSelectorMatchExpressionsOutputWithContext(ctx context.Context) SubscriptionSpecPlacementClusterSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o SubscriptionSpecPlacementClusterSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v SubscriptionSpecPlacementClusterSelectorMatchExpressions) string { return v.Key }).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
func (o SubscriptionSpecPlacementClusterSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v SubscriptionSpecPlacementClusterSelectorMatchExpressions) string { return v.Operator }).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
func (o SubscriptionSpecPlacementClusterSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v SubscriptionSpecPlacementClusterSelectorMatchExpressions) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type SubscriptionSpecPlacementClusterSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (SubscriptionSpecPlacementClusterSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SubscriptionSpecPlacementClusterSelectorMatchExpressions)(nil)).Elem()
}

func (o SubscriptionSpecPlacementClusterSelectorMatchExpressionsArrayOutput) ToSubscriptionSpecPlacementClusterSelectorMatchExpressionsArrayOutput() SubscriptionSpecPlacementClusterSelectorMatchExpressionsArrayOutput {
	return o
}

func (o SubscriptionSpecPlacementClusterSelectorMatchExpressionsArrayOutput) ToSubscriptionSpecPlacementClusterSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) SubscriptionSpecPlacementClusterSelectorMatchExpressionsArrayOutput {
	return o
}

func (o SubscriptionSpecPlacementClusterSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) SubscriptionSpecPlacementClusterSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SubscriptionSpecPlacementClusterSelectorMatchExpressions {
		return vs[0].([]SubscriptionSpecPlacementClusterSelectorMatchExpressions)[vs[1].(int)]
	}).(SubscriptionSpecPlacementClusterSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type SubscriptionSpecPlacementClusterSelectorMatchLabels struct {
}

// SubscriptionSpecPlacementClusterSelectorMatchLabelsInput is an input type that accepts SubscriptionSpecPlacementClusterSelectorMatchLabelsArgs and SubscriptionSpecPlacementClusterSelectorMatchLabelsOutput values.
// You can construct a concrete instance of `SubscriptionSpecPlacementClusterSelectorMatchLabelsInput` via:
//
//          SubscriptionSpecPlacementClusterSelectorMatchLabelsArgs{...}
type SubscriptionSpecPlacementClusterSelectorMatchLabelsInput interface {
	pulumi.Input

	ToSubscriptionSpecPlacementClusterSelectorMatchLabelsOutput() SubscriptionSpecPlacementClusterSelectorMatchLabelsOutput
	ToSubscriptionSpecPlacementClusterSelectorMatchLabelsOutputWithContext(context.Context) SubscriptionSpecPlacementClusterSelectorMatchLabelsOutput
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type SubscriptionSpecPlacementClusterSelectorMatchLabelsArgs struct {
}

func (SubscriptionSpecPlacementClusterSelectorMatchLabelsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionSpecPlacementClusterSelectorMatchLabels)(nil)).Elem()
}

func (i SubscriptionSpecPlacementClusterSelectorMatchLabelsArgs) ToSubscriptionSpecPlacementClusterSelectorMatchLabelsOutput() SubscriptionSpecPlacementClusterSelectorMatchLabelsOutput {
	return i.ToSubscriptionSpecPlacementClusterSelectorMatchLabelsOutputWithContext(context.Background())
}

func (i SubscriptionSpecPlacementClusterSelectorMatchLabelsArgs) ToSubscriptionSpecPlacementClusterSelectorMatchLabelsOutputWithContext(ctx context.Context) SubscriptionSpecPlacementClusterSelectorMatchLabelsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecPlacementClusterSelectorMatchLabelsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type SubscriptionSpecPlacementClusterSelectorMatchLabelsOutput struct{ *pulumi.OutputState }

func (SubscriptionSpecPlacementClusterSelectorMatchLabelsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionSpecPlacementClusterSelectorMatchLabels)(nil)).Elem()
}

func (o SubscriptionSpecPlacementClusterSelectorMatchLabelsOutput) ToSubscriptionSpecPlacementClusterSelectorMatchLabelsOutput() SubscriptionSpecPlacementClusterSelectorMatchLabelsOutput {
	return o
}

func (o SubscriptionSpecPlacementClusterSelectorMatchLabelsOutput) ToSubscriptionSpecPlacementClusterSelectorMatchLabelsOutputWithContext(ctx context.Context) SubscriptionSpecPlacementClusterSelectorMatchLabelsOutput {
	return o
}

// GenericClusterReference - in alignment with kubefed
type SubscriptionSpecPlacementClusters struct {
	Name string `pulumi:"name"`
}

// SubscriptionSpecPlacementClustersInput is an input type that accepts SubscriptionSpecPlacementClustersArgs and SubscriptionSpecPlacementClustersOutput values.
// You can construct a concrete instance of `SubscriptionSpecPlacementClustersInput` via:
//
//          SubscriptionSpecPlacementClustersArgs{...}
type SubscriptionSpecPlacementClustersInput interface {
	pulumi.Input

	ToSubscriptionSpecPlacementClustersOutput() SubscriptionSpecPlacementClustersOutput
	ToSubscriptionSpecPlacementClustersOutputWithContext(context.Context) SubscriptionSpecPlacementClustersOutput
}

// GenericClusterReference - in alignment with kubefed
type SubscriptionSpecPlacementClustersArgs struct {
	Name pulumi.StringInput `pulumi:"name"`
}

func (SubscriptionSpecPlacementClustersArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionSpecPlacementClusters)(nil)).Elem()
}

func (i SubscriptionSpecPlacementClustersArgs) ToSubscriptionSpecPlacementClustersOutput() SubscriptionSpecPlacementClustersOutput {
	return i.ToSubscriptionSpecPlacementClustersOutputWithContext(context.Background())
}

func (i SubscriptionSpecPlacementClustersArgs) ToSubscriptionSpecPlacementClustersOutputWithContext(ctx context.Context) SubscriptionSpecPlacementClustersOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecPlacementClustersOutput)
}

// SubscriptionSpecPlacementClustersArrayInput is an input type that accepts SubscriptionSpecPlacementClustersArray and SubscriptionSpecPlacementClustersArrayOutput values.
// You can construct a concrete instance of `SubscriptionSpecPlacementClustersArrayInput` via:
//
//          SubscriptionSpecPlacementClustersArray{ SubscriptionSpecPlacementClustersArgs{...} }
type SubscriptionSpecPlacementClustersArrayInput interface {
	pulumi.Input

	ToSubscriptionSpecPlacementClustersArrayOutput() SubscriptionSpecPlacementClustersArrayOutput
	ToSubscriptionSpecPlacementClustersArrayOutputWithContext(context.Context) SubscriptionSpecPlacementClustersArrayOutput
}

type SubscriptionSpecPlacementClustersArray []SubscriptionSpecPlacementClustersInput

func (SubscriptionSpecPlacementClustersArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SubscriptionSpecPlacementClusters)(nil)).Elem()
}

func (i SubscriptionSpecPlacementClustersArray) ToSubscriptionSpecPlacementClustersArrayOutput() SubscriptionSpecPlacementClustersArrayOutput {
	return i.ToSubscriptionSpecPlacementClustersArrayOutputWithContext(context.Background())
}

func (i SubscriptionSpecPlacementClustersArray) ToSubscriptionSpecPlacementClustersArrayOutputWithContext(ctx context.Context) SubscriptionSpecPlacementClustersArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecPlacementClustersArrayOutput)
}

// GenericClusterReference - in alignment with kubefed
type SubscriptionSpecPlacementClustersOutput struct{ *pulumi.OutputState }

func (SubscriptionSpecPlacementClustersOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionSpecPlacementClusters)(nil)).Elem()
}

func (o SubscriptionSpecPlacementClustersOutput) ToSubscriptionSpecPlacementClustersOutput() SubscriptionSpecPlacementClustersOutput {
	return o
}

func (o SubscriptionSpecPlacementClustersOutput) ToSubscriptionSpecPlacementClustersOutputWithContext(ctx context.Context) SubscriptionSpecPlacementClustersOutput {
	return o
}

func (o SubscriptionSpecPlacementClustersOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v SubscriptionSpecPlacementClusters) string { return v.Name }).(pulumi.StringOutput)
}

type SubscriptionSpecPlacementClustersArrayOutput struct{ *pulumi.OutputState }

func (SubscriptionSpecPlacementClustersArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SubscriptionSpecPlacementClusters)(nil)).Elem()
}

func (o SubscriptionSpecPlacementClustersArrayOutput) ToSubscriptionSpecPlacementClustersArrayOutput() SubscriptionSpecPlacementClustersArrayOutput {
	return o
}

func (o SubscriptionSpecPlacementClustersArrayOutput) ToSubscriptionSpecPlacementClustersArrayOutputWithContext(ctx context.Context) SubscriptionSpecPlacementClustersArrayOutput {
	return o
}

func (o SubscriptionSpecPlacementClustersArrayOutput) Index(i pulumi.IntInput) SubscriptionSpecPlacementClustersOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SubscriptionSpecPlacementClusters {
		return vs[0].([]SubscriptionSpecPlacementClusters)[vs[1].(int)]
	}).(SubscriptionSpecPlacementClustersOutput)
}

// ObjectReference contains enough information to let you inspect or modify the referred object.
type SubscriptionSpecPlacementPlacementRef struct {
	// API version of the referent.
	ApiVersion *string `pulumi:"apiVersion"`
	// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
	FieldPath *string `pulumi:"fieldPath"`
	// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name *string `pulumi:"name"`
	// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
	Namespace *string `pulumi:"namespace"`
	// Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
	ResourceVersion *string `pulumi:"resourceVersion"`
	// UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
	Uid *string `pulumi:"uid"`
}

// SubscriptionSpecPlacementPlacementRefInput is an input type that accepts SubscriptionSpecPlacementPlacementRefArgs and SubscriptionSpecPlacementPlacementRefOutput values.
// You can construct a concrete instance of `SubscriptionSpecPlacementPlacementRefInput` via:
//
//          SubscriptionSpecPlacementPlacementRefArgs{...}
type SubscriptionSpecPlacementPlacementRefInput interface {
	pulumi.Input

	ToSubscriptionSpecPlacementPlacementRefOutput() SubscriptionSpecPlacementPlacementRefOutput
	ToSubscriptionSpecPlacementPlacementRefOutputWithContext(context.Context) SubscriptionSpecPlacementPlacementRefOutput
}

// ObjectReference contains enough information to let you inspect or modify the referred object.
type SubscriptionSpecPlacementPlacementRefArgs struct {
	// API version of the referent.
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
	FieldPath pulumi.StringPtrInput `pulumi:"fieldPath"`
	// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
	ResourceVersion pulumi.StringPtrInput `pulumi:"resourceVersion"`
	// UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
	Uid pulumi.StringPtrInput `pulumi:"uid"`
}

func (SubscriptionSpecPlacementPlacementRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionSpecPlacementPlacementRef)(nil)).Elem()
}

func (i SubscriptionSpecPlacementPlacementRefArgs) ToSubscriptionSpecPlacementPlacementRefOutput() SubscriptionSpecPlacementPlacementRefOutput {
	return i.ToSubscriptionSpecPlacementPlacementRefOutputWithContext(context.Background())
}

func (i SubscriptionSpecPlacementPlacementRefArgs) ToSubscriptionSpecPlacementPlacementRefOutputWithContext(ctx context.Context) SubscriptionSpecPlacementPlacementRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecPlacementPlacementRefOutput)
}

func (i SubscriptionSpecPlacementPlacementRefArgs) ToSubscriptionSpecPlacementPlacementRefPtrOutput() SubscriptionSpecPlacementPlacementRefPtrOutput {
	return i.ToSubscriptionSpecPlacementPlacementRefPtrOutputWithContext(context.Background())
}

func (i SubscriptionSpecPlacementPlacementRefArgs) ToSubscriptionSpecPlacementPlacementRefPtrOutputWithContext(ctx context.Context) SubscriptionSpecPlacementPlacementRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecPlacementPlacementRefOutput).ToSubscriptionSpecPlacementPlacementRefPtrOutputWithContext(ctx)
}

// SubscriptionSpecPlacementPlacementRefPtrInput is an input type that accepts SubscriptionSpecPlacementPlacementRefArgs, SubscriptionSpecPlacementPlacementRefPtr and SubscriptionSpecPlacementPlacementRefPtrOutput values.
// You can construct a concrete instance of `SubscriptionSpecPlacementPlacementRefPtrInput` via:
//
//          SubscriptionSpecPlacementPlacementRefArgs{...}
//
//  or:
//
//          nil
type SubscriptionSpecPlacementPlacementRefPtrInput interface {
	pulumi.Input

	ToSubscriptionSpecPlacementPlacementRefPtrOutput() SubscriptionSpecPlacementPlacementRefPtrOutput
	ToSubscriptionSpecPlacementPlacementRefPtrOutputWithContext(context.Context) SubscriptionSpecPlacementPlacementRefPtrOutput
}

type subscriptionSpecPlacementPlacementRefPtrType SubscriptionSpecPlacementPlacementRefArgs

func SubscriptionSpecPlacementPlacementRefPtr(v *SubscriptionSpecPlacementPlacementRefArgs) SubscriptionSpecPlacementPlacementRefPtrInput {
	return (*subscriptionSpecPlacementPlacementRefPtrType)(v)
}

func (*subscriptionSpecPlacementPlacementRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SubscriptionSpecPlacementPlacementRef)(nil)).Elem()
}

func (i *subscriptionSpecPlacementPlacementRefPtrType) ToSubscriptionSpecPlacementPlacementRefPtrOutput() SubscriptionSpecPlacementPlacementRefPtrOutput {
	return i.ToSubscriptionSpecPlacementPlacementRefPtrOutputWithContext(context.Background())
}

func (i *subscriptionSpecPlacementPlacementRefPtrType) ToSubscriptionSpecPlacementPlacementRefPtrOutputWithContext(ctx context.Context) SubscriptionSpecPlacementPlacementRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecPlacementPlacementRefPtrOutput)
}

// ObjectReference contains enough information to let you inspect or modify the referred object.
type SubscriptionSpecPlacementPlacementRefOutput struct{ *pulumi.OutputState }

func (SubscriptionSpecPlacementPlacementRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionSpecPlacementPlacementRef)(nil)).Elem()
}

func (o SubscriptionSpecPlacementPlacementRefOutput) ToSubscriptionSpecPlacementPlacementRefOutput() SubscriptionSpecPlacementPlacementRefOutput {
	return o
}

func (o SubscriptionSpecPlacementPlacementRefOutput) ToSubscriptionSpecPlacementPlacementRefOutputWithContext(ctx context.Context) SubscriptionSpecPlacementPlacementRefOutput {
	return o
}

func (o SubscriptionSpecPlacementPlacementRefOutput) ToSubscriptionSpecPlacementPlacementRefPtrOutput() SubscriptionSpecPlacementPlacementRefPtrOutput {
	return o.ToSubscriptionSpecPlacementPlacementRefPtrOutputWithContext(context.Background())
}

func (o SubscriptionSpecPlacementPlacementRefOutput) ToSubscriptionSpecPlacementPlacementRefPtrOutputWithContext(ctx context.Context) SubscriptionSpecPlacementPlacementRefPtrOutput {
	return o.ApplyT(func(v SubscriptionSpecPlacementPlacementRef) *SubscriptionSpecPlacementPlacementRef {
		return &v
	}).(SubscriptionSpecPlacementPlacementRefPtrOutput)
}

// API version of the referent.
func (o SubscriptionSpecPlacementPlacementRefOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionSpecPlacementPlacementRef) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
func (o SubscriptionSpecPlacementPlacementRefOutput) FieldPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionSpecPlacementPlacementRef) *string { return v.FieldPath }).(pulumi.StringPtrOutput)
}

// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
func (o SubscriptionSpecPlacementPlacementRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionSpecPlacementPlacementRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o SubscriptionSpecPlacementPlacementRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionSpecPlacementPlacementRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
func (o SubscriptionSpecPlacementPlacementRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionSpecPlacementPlacementRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
func (o SubscriptionSpecPlacementPlacementRefOutput) ResourceVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionSpecPlacementPlacementRef) *string { return v.ResourceVersion }).(pulumi.StringPtrOutput)
}

// UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
func (o SubscriptionSpecPlacementPlacementRefOutput) Uid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionSpecPlacementPlacementRef) *string { return v.Uid }).(pulumi.StringPtrOutput)
}

type SubscriptionSpecPlacementPlacementRefPtrOutput struct{ *pulumi.OutputState }

func (SubscriptionSpecPlacementPlacementRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SubscriptionSpecPlacementPlacementRef)(nil)).Elem()
}

func (o SubscriptionSpecPlacementPlacementRefPtrOutput) ToSubscriptionSpecPlacementPlacementRefPtrOutput() SubscriptionSpecPlacementPlacementRefPtrOutput {
	return o
}

func (o SubscriptionSpecPlacementPlacementRefPtrOutput) ToSubscriptionSpecPlacementPlacementRefPtrOutputWithContext(ctx context.Context) SubscriptionSpecPlacementPlacementRefPtrOutput {
	return o
}

func (o SubscriptionSpecPlacementPlacementRefPtrOutput) Elem() SubscriptionSpecPlacementPlacementRefOutput {
	return o.ApplyT(func(v *SubscriptionSpecPlacementPlacementRef) SubscriptionSpecPlacementPlacementRef { return *v }).(SubscriptionSpecPlacementPlacementRefOutput)
}

// API version of the referent.
func (o SubscriptionSpecPlacementPlacementRefPtrOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionSpecPlacementPlacementRef) *string {
		if v == nil {
			return nil
		}
		return v.ApiVersion
	}).(pulumi.StringPtrOutput)
}

// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
func (o SubscriptionSpecPlacementPlacementRefPtrOutput) FieldPath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionSpecPlacementPlacementRef) *string {
		if v == nil {
			return nil
		}
		return v.FieldPath
	}).(pulumi.StringPtrOutput)
}

// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
func (o SubscriptionSpecPlacementPlacementRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionSpecPlacementPlacementRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o SubscriptionSpecPlacementPlacementRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionSpecPlacementPlacementRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
func (o SubscriptionSpecPlacementPlacementRefPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionSpecPlacementPlacementRef) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
func (o SubscriptionSpecPlacementPlacementRefPtrOutput) ResourceVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionSpecPlacementPlacementRef) *string {
		if v == nil {
			return nil
		}
		return v.ResourceVersion
	}).(pulumi.StringPtrOutput)
}

// UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
func (o SubscriptionSpecPlacementPlacementRefPtrOutput) Uid() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionSpecPlacementPlacementRef) *string {
		if v == nil {
			return nil
		}
		return v.Uid
	}).(pulumi.StringPtrOutput)
}

// help user control when the subscription will take affect
type SubscriptionSpecTimewindow struct {
	// weekdays defined the day of the week for this time window https://golang.org/pkg/time/#Weekday
	Daysofweek []string                          `pulumi:"daysofweek"`
	Hours      []SubscriptionSpecTimewindowHours `pulumi:"hours"`
	// https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
	Location *string `pulumi:"location"`
	// active time window or not, if timewindow is active, then deploy will only applies during these windows Note, if you want to generation crd with operator-sdk v0.10.0, then the following line should be: <+kubebuilder:validation:Enum=active,blocked,Active,Blocked>
	Windowtype *string `pulumi:"windowtype"`
}

// SubscriptionSpecTimewindowInput is an input type that accepts SubscriptionSpecTimewindowArgs and SubscriptionSpecTimewindowOutput values.
// You can construct a concrete instance of `SubscriptionSpecTimewindowInput` via:
//
//          SubscriptionSpecTimewindowArgs{...}
type SubscriptionSpecTimewindowInput interface {
	pulumi.Input

	ToSubscriptionSpecTimewindowOutput() SubscriptionSpecTimewindowOutput
	ToSubscriptionSpecTimewindowOutputWithContext(context.Context) SubscriptionSpecTimewindowOutput
}

// help user control when the subscription will take affect
type SubscriptionSpecTimewindowArgs struct {
	// weekdays defined the day of the week for this time window https://golang.org/pkg/time/#Weekday
	Daysofweek pulumi.StringArrayInput                   `pulumi:"daysofweek"`
	Hours      SubscriptionSpecTimewindowHoursArrayInput `pulumi:"hours"`
	// https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
	Location pulumi.StringPtrInput `pulumi:"location"`
	// active time window or not, if timewindow is active, then deploy will only applies during these windows Note, if you want to generation crd with operator-sdk v0.10.0, then the following line should be: <+kubebuilder:validation:Enum=active,blocked,Active,Blocked>
	Windowtype pulumi.StringPtrInput `pulumi:"windowtype"`
}

func (SubscriptionSpecTimewindowArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionSpecTimewindow)(nil)).Elem()
}

func (i SubscriptionSpecTimewindowArgs) ToSubscriptionSpecTimewindowOutput() SubscriptionSpecTimewindowOutput {
	return i.ToSubscriptionSpecTimewindowOutputWithContext(context.Background())
}

func (i SubscriptionSpecTimewindowArgs) ToSubscriptionSpecTimewindowOutputWithContext(ctx context.Context) SubscriptionSpecTimewindowOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecTimewindowOutput)
}

func (i SubscriptionSpecTimewindowArgs) ToSubscriptionSpecTimewindowPtrOutput() SubscriptionSpecTimewindowPtrOutput {
	return i.ToSubscriptionSpecTimewindowPtrOutputWithContext(context.Background())
}

func (i SubscriptionSpecTimewindowArgs) ToSubscriptionSpecTimewindowPtrOutputWithContext(ctx context.Context) SubscriptionSpecTimewindowPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecTimewindowOutput).ToSubscriptionSpecTimewindowPtrOutputWithContext(ctx)
}

// SubscriptionSpecTimewindowPtrInput is an input type that accepts SubscriptionSpecTimewindowArgs, SubscriptionSpecTimewindowPtr and SubscriptionSpecTimewindowPtrOutput values.
// You can construct a concrete instance of `SubscriptionSpecTimewindowPtrInput` via:
//
//          SubscriptionSpecTimewindowArgs{...}
//
//  or:
//
//          nil
type SubscriptionSpecTimewindowPtrInput interface {
	pulumi.Input

	ToSubscriptionSpecTimewindowPtrOutput() SubscriptionSpecTimewindowPtrOutput
	ToSubscriptionSpecTimewindowPtrOutputWithContext(context.Context) SubscriptionSpecTimewindowPtrOutput
}

type subscriptionSpecTimewindowPtrType SubscriptionSpecTimewindowArgs

func SubscriptionSpecTimewindowPtr(v *SubscriptionSpecTimewindowArgs) SubscriptionSpecTimewindowPtrInput {
	return (*subscriptionSpecTimewindowPtrType)(v)
}

func (*subscriptionSpecTimewindowPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SubscriptionSpecTimewindow)(nil)).Elem()
}

func (i *subscriptionSpecTimewindowPtrType) ToSubscriptionSpecTimewindowPtrOutput() SubscriptionSpecTimewindowPtrOutput {
	return i.ToSubscriptionSpecTimewindowPtrOutputWithContext(context.Background())
}

func (i *subscriptionSpecTimewindowPtrType) ToSubscriptionSpecTimewindowPtrOutputWithContext(ctx context.Context) SubscriptionSpecTimewindowPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecTimewindowPtrOutput)
}

// help user control when the subscription will take affect
type SubscriptionSpecTimewindowOutput struct{ *pulumi.OutputState }

func (SubscriptionSpecTimewindowOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionSpecTimewindow)(nil)).Elem()
}

func (o SubscriptionSpecTimewindowOutput) ToSubscriptionSpecTimewindowOutput() SubscriptionSpecTimewindowOutput {
	return o
}

func (o SubscriptionSpecTimewindowOutput) ToSubscriptionSpecTimewindowOutputWithContext(ctx context.Context) SubscriptionSpecTimewindowOutput {
	return o
}

func (o SubscriptionSpecTimewindowOutput) ToSubscriptionSpecTimewindowPtrOutput() SubscriptionSpecTimewindowPtrOutput {
	return o.ToSubscriptionSpecTimewindowPtrOutputWithContext(context.Background())
}

func (o SubscriptionSpecTimewindowOutput) ToSubscriptionSpecTimewindowPtrOutputWithContext(ctx context.Context) SubscriptionSpecTimewindowPtrOutput {
	return o.ApplyT(func(v SubscriptionSpecTimewindow) *SubscriptionSpecTimewindow {
		return &v
	}).(SubscriptionSpecTimewindowPtrOutput)
}

// weekdays defined the day of the week for this time window https://golang.org/pkg/time/#Weekday
func (o SubscriptionSpecTimewindowOutput) Daysofweek() pulumi.StringArrayOutput {
	return o.ApplyT(func(v SubscriptionSpecTimewindow) []string { return v.Daysofweek }).(pulumi.StringArrayOutput)
}

func (o SubscriptionSpecTimewindowOutput) Hours() SubscriptionSpecTimewindowHoursArrayOutput {
	return o.ApplyT(func(v SubscriptionSpecTimewindow) []SubscriptionSpecTimewindowHours { return v.Hours }).(SubscriptionSpecTimewindowHoursArrayOutput)
}

// https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
func (o SubscriptionSpecTimewindowOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionSpecTimewindow) *string { return v.Location }).(pulumi.StringPtrOutput)
}

// active time window or not, if timewindow is active, then deploy will only applies during these windows Note, if you want to generation crd with operator-sdk v0.10.0, then the following line should be: <+kubebuilder:validation:Enum=active,blocked,Active,Blocked>
func (o SubscriptionSpecTimewindowOutput) Windowtype() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionSpecTimewindow) *string { return v.Windowtype }).(pulumi.StringPtrOutput)
}

type SubscriptionSpecTimewindowPtrOutput struct{ *pulumi.OutputState }

func (SubscriptionSpecTimewindowPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SubscriptionSpecTimewindow)(nil)).Elem()
}

func (o SubscriptionSpecTimewindowPtrOutput) ToSubscriptionSpecTimewindowPtrOutput() SubscriptionSpecTimewindowPtrOutput {
	return o
}

func (o SubscriptionSpecTimewindowPtrOutput) ToSubscriptionSpecTimewindowPtrOutputWithContext(ctx context.Context) SubscriptionSpecTimewindowPtrOutput {
	return o
}

func (o SubscriptionSpecTimewindowPtrOutput) Elem() SubscriptionSpecTimewindowOutput {
	return o.ApplyT(func(v *SubscriptionSpecTimewindow) SubscriptionSpecTimewindow { return *v }).(SubscriptionSpecTimewindowOutput)
}

// weekdays defined the day of the week for this time window https://golang.org/pkg/time/#Weekday
func (o SubscriptionSpecTimewindowPtrOutput) Daysofweek() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *SubscriptionSpecTimewindow) []string {
		if v == nil {
			return nil
		}
		return v.Daysofweek
	}).(pulumi.StringArrayOutput)
}

func (o SubscriptionSpecTimewindowPtrOutput) Hours() SubscriptionSpecTimewindowHoursArrayOutput {
	return o.ApplyT(func(v *SubscriptionSpecTimewindow) []SubscriptionSpecTimewindowHours {
		if v == nil {
			return nil
		}
		return v.Hours
	}).(SubscriptionSpecTimewindowHoursArrayOutput)
}

// https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
func (o SubscriptionSpecTimewindowPtrOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionSpecTimewindow) *string {
		if v == nil {
			return nil
		}
		return v.Location
	}).(pulumi.StringPtrOutput)
}

// active time window or not, if timewindow is active, then deploy will only applies during these windows Note, if you want to generation crd with operator-sdk v0.10.0, then the following line should be: <+kubebuilder:validation:Enum=active,blocked,Active,Blocked>
func (o SubscriptionSpecTimewindowPtrOutput) Windowtype() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionSpecTimewindow) *string {
		if v == nil {
			return nil
		}
		return v.Windowtype
	}).(pulumi.StringPtrOutput)
}

// HourRange time format for each time will be Kitchen format, defined at https://golang.org/pkg/time/#pkg-constants
type SubscriptionSpecTimewindowHours struct {
	End   *string `pulumi:"end"`
	Start *string `pulumi:"start"`
}

// SubscriptionSpecTimewindowHoursInput is an input type that accepts SubscriptionSpecTimewindowHoursArgs and SubscriptionSpecTimewindowHoursOutput values.
// You can construct a concrete instance of `SubscriptionSpecTimewindowHoursInput` via:
//
//          SubscriptionSpecTimewindowHoursArgs{...}
type SubscriptionSpecTimewindowHoursInput interface {
	pulumi.Input

	ToSubscriptionSpecTimewindowHoursOutput() SubscriptionSpecTimewindowHoursOutput
	ToSubscriptionSpecTimewindowHoursOutputWithContext(context.Context) SubscriptionSpecTimewindowHoursOutput
}

// HourRange time format for each time will be Kitchen format, defined at https://golang.org/pkg/time/#pkg-constants
type SubscriptionSpecTimewindowHoursArgs struct {
	End   pulumi.StringPtrInput `pulumi:"end"`
	Start pulumi.StringPtrInput `pulumi:"start"`
}

func (SubscriptionSpecTimewindowHoursArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionSpecTimewindowHours)(nil)).Elem()
}

func (i SubscriptionSpecTimewindowHoursArgs) ToSubscriptionSpecTimewindowHoursOutput() SubscriptionSpecTimewindowHoursOutput {
	return i.ToSubscriptionSpecTimewindowHoursOutputWithContext(context.Background())
}

func (i SubscriptionSpecTimewindowHoursArgs) ToSubscriptionSpecTimewindowHoursOutputWithContext(ctx context.Context) SubscriptionSpecTimewindowHoursOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecTimewindowHoursOutput)
}

// SubscriptionSpecTimewindowHoursArrayInput is an input type that accepts SubscriptionSpecTimewindowHoursArray and SubscriptionSpecTimewindowHoursArrayOutput values.
// You can construct a concrete instance of `SubscriptionSpecTimewindowHoursArrayInput` via:
//
//          SubscriptionSpecTimewindowHoursArray{ SubscriptionSpecTimewindowHoursArgs{...} }
type SubscriptionSpecTimewindowHoursArrayInput interface {
	pulumi.Input

	ToSubscriptionSpecTimewindowHoursArrayOutput() SubscriptionSpecTimewindowHoursArrayOutput
	ToSubscriptionSpecTimewindowHoursArrayOutputWithContext(context.Context) SubscriptionSpecTimewindowHoursArrayOutput
}

type SubscriptionSpecTimewindowHoursArray []SubscriptionSpecTimewindowHoursInput

func (SubscriptionSpecTimewindowHoursArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SubscriptionSpecTimewindowHours)(nil)).Elem()
}

func (i SubscriptionSpecTimewindowHoursArray) ToSubscriptionSpecTimewindowHoursArrayOutput() SubscriptionSpecTimewindowHoursArrayOutput {
	return i.ToSubscriptionSpecTimewindowHoursArrayOutputWithContext(context.Background())
}

func (i SubscriptionSpecTimewindowHoursArray) ToSubscriptionSpecTimewindowHoursArrayOutputWithContext(ctx context.Context) SubscriptionSpecTimewindowHoursArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionSpecTimewindowHoursArrayOutput)
}

// HourRange time format for each time will be Kitchen format, defined at https://golang.org/pkg/time/#pkg-constants
type SubscriptionSpecTimewindowHoursOutput struct{ *pulumi.OutputState }

func (SubscriptionSpecTimewindowHoursOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionSpecTimewindowHours)(nil)).Elem()
}

func (o SubscriptionSpecTimewindowHoursOutput) ToSubscriptionSpecTimewindowHoursOutput() SubscriptionSpecTimewindowHoursOutput {
	return o
}

func (o SubscriptionSpecTimewindowHoursOutput) ToSubscriptionSpecTimewindowHoursOutputWithContext(ctx context.Context) SubscriptionSpecTimewindowHoursOutput {
	return o
}

func (o SubscriptionSpecTimewindowHoursOutput) End() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionSpecTimewindowHours) *string { return v.End }).(pulumi.StringPtrOutput)
}

func (o SubscriptionSpecTimewindowHoursOutput) Start() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionSpecTimewindowHours) *string { return v.Start }).(pulumi.StringPtrOutput)
}

type SubscriptionSpecTimewindowHoursArrayOutput struct{ *pulumi.OutputState }

func (SubscriptionSpecTimewindowHoursArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]SubscriptionSpecTimewindowHours)(nil)).Elem()
}

func (o SubscriptionSpecTimewindowHoursArrayOutput) ToSubscriptionSpecTimewindowHoursArrayOutput() SubscriptionSpecTimewindowHoursArrayOutput {
	return o
}

func (o SubscriptionSpecTimewindowHoursArrayOutput) ToSubscriptionSpecTimewindowHoursArrayOutputWithContext(ctx context.Context) SubscriptionSpecTimewindowHoursArrayOutput {
	return o
}

func (o SubscriptionSpecTimewindowHoursArrayOutput) Index(i pulumi.IntInput) SubscriptionSpecTimewindowHoursOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) SubscriptionSpecTimewindowHours {
		return vs[0].([]SubscriptionSpecTimewindowHours)[vs[1].(int)]
	}).(SubscriptionSpecTimewindowHoursOutput)
}

// SubscriptionStatus defines the observed state of Subscription Examples - status of a subscription on hub Status: 	phase: Propagated 	statuses: 	  washdc: 		packages: 		  nginx: 			phase: Subscribed 		  mongodb: 			phase: Failed 			Reason: "not authorized" 			Message: "user xxx does not have permission to start pod" 			resourceStatus: {}    toronto: 		packages: 		  nginx: 			phase: Subscribed 		  mongodb: 			phase: Subscribed Status of a subscription on managed cluster will only have 1 cluster in the map.
type SubscriptionStatus struct {
	Ansiblejobs    *SubscriptionStatusAnsiblejobs `pulumi:"ansiblejobs"`
	LastUpdateTime *string                        `pulumi:"lastUpdateTime"`
	Message        *string                        `pulumi:"message"`
	// INSERT ADDITIONAL STATUS FIELD - define observed state of cluster Important: Run "make" to regenerate code after modifying this file
	Phase  *string `pulumi:"phase"`
	Reason *string `pulumi:"reason"`
	// For endpoint, it is the status of subscription, key is packagename, For hub, it aggregates all status, key is cluster name
	Statuses map[string]SubscriptionStatusStatuses `pulumi:"statuses"`
}

// SubscriptionStatusInput is an input type that accepts SubscriptionStatusArgs and SubscriptionStatusOutput values.
// You can construct a concrete instance of `SubscriptionStatusInput` via:
//
//          SubscriptionStatusArgs{...}
type SubscriptionStatusInput interface {
	pulumi.Input

	ToSubscriptionStatusOutput() SubscriptionStatusOutput
	ToSubscriptionStatusOutputWithContext(context.Context) SubscriptionStatusOutput
}

// SubscriptionStatus defines the observed state of Subscription Examples - status of a subscription on hub Status: 	phase: Propagated 	statuses: 	  washdc: 		packages: 		  nginx: 			phase: Subscribed 		  mongodb: 			phase: Failed 			Reason: "not authorized" 			Message: "user xxx does not have permission to start pod" 			resourceStatus: {}    toronto: 		packages: 		  nginx: 			phase: Subscribed 		  mongodb: 			phase: Subscribed Status of a subscription on managed cluster will only have 1 cluster in the map.
type SubscriptionStatusArgs struct {
	Ansiblejobs    SubscriptionStatusAnsiblejobsPtrInput `pulumi:"ansiblejobs"`
	LastUpdateTime pulumi.StringPtrInput                 `pulumi:"lastUpdateTime"`
	Message        pulumi.StringPtrInput                 `pulumi:"message"`
	// INSERT ADDITIONAL STATUS FIELD - define observed state of cluster Important: Run "make" to regenerate code after modifying this file
	Phase  pulumi.StringPtrInput `pulumi:"phase"`
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// For endpoint, it is the status of subscription, key is packagename, For hub, it aggregates all status, key is cluster name
	Statuses SubscriptionStatusStatusesMapInput `pulumi:"statuses"`
}

func (SubscriptionStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionStatus)(nil)).Elem()
}

func (i SubscriptionStatusArgs) ToSubscriptionStatusOutput() SubscriptionStatusOutput {
	return i.ToSubscriptionStatusOutputWithContext(context.Background())
}

func (i SubscriptionStatusArgs) ToSubscriptionStatusOutputWithContext(ctx context.Context) SubscriptionStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionStatusOutput)
}

func (i SubscriptionStatusArgs) ToSubscriptionStatusPtrOutput() SubscriptionStatusPtrOutput {
	return i.ToSubscriptionStatusPtrOutputWithContext(context.Background())
}

func (i SubscriptionStatusArgs) ToSubscriptionStatusPtrOutputWithContext(ctx context.Context) SubscriptionStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionStatusOutput).ToSubscriptionStatusPtrOutputWithContext(ctx)
}

// SubscriptionStatusPtrInput is an input type that accepts SubscriptionStatusArgs, SubscriptionStatusPtr and SubscriptionStatusPtrOutput values.
// You can construct a concrete instance of `SubscriptionStatusPtrInput` via:
//
//          SubscriptionStatusArgs{...}
//
//  or:
//
//          nil
type SubscriptionStatusPtrInput interface {
	pulumi.Input

	ToSubscriptionStatusPtrOutput() SubscriptionStatusPtrOutput
	ToSubscriptionStatusPtrOutputWithContext(context.Context) SubscriptionStatusPtrOutput
}

type subscriptionStatusPtrType SubscriptionStatusArgs

func SubscriptionStatusPtr(v *SubscriptionStatusArgs) SubscriptionStatusPtrInput {
	return (*subscriptionStatusPtrType)(v)
}

func (*subscriptionStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SubscriptionStatus)(nil)).Elem()
}

func (i *subscriptionStatusPtrType) ToSubscriptionStatusPtrOutput() SubscriptionStatusPtrOutput {
	return i.ToSubscriptionStatusPtrOutputWithContext(context.Background())
}

func (i *subscriptionStatusPtrType) ToSubscriptionStatusPtrOutputWithContext(ctx context.Context) SubscriptionStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionStatusPtrOutput)
}

// SubscriptionStatus defines the observed state of Subscription Examples - status of a subscription on hub Status: 	phase: Propagated 	statuses: 	  washdc: 		packages: 		  nginx: 			phase: Subscribed 		  mongodb: 			phase: Failed 			Reason: "not authorized" 			Message: "user xxx does not have permission to start pod" 			resourceStatus: {}    toronto: 		packages: 		  nginx: 			phase: Subscribed 		  mongodb: 			phase: Subscribed Status of a subscription on managed cluster will only have 1 cluster in the map.
type SubscriptionStatusOutput struct{ *pulumi.OutputState }

func (SubscriptionStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionStatus)(nil)).Elem()
}

func (o SubscriptionStatusOutput) ToSubscriptionStatusOutput() SubscriptionStatusOutput {
	return o
}

func (o SubscriptionStatusOutput) ToSubscriptionStatusOutputWithContext(ctx context.Context) SubscriptionStatusOutput {
	return o
}

func (o SubscriptionStatusOutput) ToSubscriptionStatusPtrOutput() SubscriptionStatusPtrOutput {
	return o.ToSubscriptionStatusPtrOutputWithContext(context.Background())
}

func (o SubscriptionStatusOutput) ToSubscriptionStatusPtrOutputWithContext(ctx context.Context) SubscriptionStatusPtrOutput {
	return o.ApplyT(func(v SubscriptionStatus) *SubscriptionStatus {
		return &v
	}).(SubscriptionStatusPtrOutput)
}
func (o SubscriptionStatusOutput) Ansiblejobs() SubscriptionStatusAnsiblejobsPtrOutput {
	return o.ApplyT(func(v SubscriptionStatus) *SubscriptionStatusAnsiblejobs { return v.Ansiblejobs }).(SubscriptionStatusAnsiblejobsPtrOutput)
}

func (o SubscriptionStatusOutput) LastUpdateTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionStatus) *string { return v.LastUpdateTime }).(pulumi.StringPtrOutput)
}

func (o SubscriptionStatusOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionStatus) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// INSERT ADDITIONAL STATUS FIELD - define observed state of cluster Important: Run "make" to regenerate code after modifying this file
func (o SubscriptionStatusOutput) Phase() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionStatus) *string { return v.Phase }).(pulumi.StringPtrOutput)
}

func (o SubscriptionStatusOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionStatus) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// For endpoint, it is the status of subscription, key is packagename, For hub, it aggregates all status, key is cluster name
func (o SubscriptionStatusOutput) Statuses() SubscriptionStatusStatusesMapOutput {
	return o.ApplyT(func(v SubscriptionStatus) map[string]SubscriptionStatusStatuses { return v.Statuses }).(SubscriptionStatusStatusesMapOutput)
}

type SubscriptionStatusPtrOutput struct{ *pulumi.OutputState }

func (SubscriptionStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SubscriptionStatus)(nil)).Elem()
}

func (o SubscriptionStatusPtrOutput) ToSubscriptionStatusPtrOutput() SubscriptionStatusPtrOutput {
	return o
}

func (o SubscriptionStatusPtrOutput) ToSubscriptionStatusPtrOutputWithContext(ctx context.Context) SubscriptionStatusPtrOutput {
	return o
}

func (o SubscriptionStatusPtrOutput) Elem() SubscriptionStatusOutput {
	return o.ApplyT(func(v *SubscriptionStatus) SubscriptionStatus { return *v }).(SubscriptionStatusOutput)
}

func (o SubscriptionStatusPtrOutput) Ansiblejobs() SubscriptionStatusAnsiblejobsPtrOutput {
	return o.ApplyT(func(v *SubscriptionStatus) *SubscriptionStatusAnsiblejobs {
		if v == nil {
			return nil
		}
		return v.Ansiblejobs
	}).(SubscriptionStatusAnsiblejobsPtrOutput)
}

func (o SubscriptionStatusPtrOutput) LastUpdateTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionStatus) *string {
		if v == nil {
			return nil
		}
		return v.LastUpdateTime
	}).(pulumi.StringPtrOutput)
}

func (o SubscriptionStatusPtrOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionStatus) *string {
		if v == nil {
			return nil
		}
		return v.Message
	}).(pulumi.StringPtrOutput)
}

// INSERT ADDITIONAL STATUS FIELD - define observed state of cluster Important: Run "make" to regenerate code after modifying this file
func (o SubscriptionStatusPtrOutput) Phase() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionStatus) *string {
		if v == nil {
			return nil
		}
		return v.Phase
	}).(pulumi.StringPtrOutput)
}

func (o SubscriptionStatusPtrOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionStatus) *string {
		if v == nil {
			return nil
		}
		return v.Reason
	}).(pulumi.StringPtrOutput)
}

// For endpoint, it is the status of subscription, key is packagename, For hub, it aggregates all status, key is cluster name
func (o SubscriptionStatusPtrOutput) Statuses() SubscriptionStatusStatusesMapOutput {
	return o.ApplyT(func(v *SubscriptionStatus) map[string]SubscriptionStatusStatuses {
		if v == nil {
			return nil
		}
		return v.Statuses
	}).(SubscriptionStatusStatusesMapOutput)
}

type SubscriptionStatusAnsiblejobs struct {
	Lastposthookjob     *string  `pulumi:"lastposthookjob"`
	Lastprehookjob      *string  `pulumi:"lastprehookjob"`
	Posthookjobshistory []string `pulumi:"posthookjobshistory"`
	Prehookjobshistory  []string `pulumi:"prehookjobshistory"`
}

// SubscriptionStatusAnsiblejobsInput is an input type that accepts SubscriptionStatusAnsiblejobsArgs and SubscriptionStatusAnsiblejobsOutput values.
// You can construct a concrete instance of `SubscriptionStatusAnsiblejobsInput` via:
//
//          SubscriptionStatusAnsiblejobsArgs{...}
type SubscriptionStatusAnsiblejobsInput interface {
	pulumi.Input

	ToSubscriptionStatusAnsiblejobsOutput() SubscriptionStatusAnsiblejobsOutput
	ToSubscriptionStatusAnsiblejobsOutputWithContext(context.Context) SubscriptionStatusAnsiblejobsOutput
}

type SubscriptionStatusAnsiblejobsArgs struct {
	Lastposthookjob     pulumi.StringPtrInput   `pulumi:"lastposthookjob"`
	Lastprehookjob      pulumi.StringPtrInput   `pulumi:"lastprehookjob"`
	Posthookjobshistory pulumi.StringArrayInput `pulumi:"posthookjobshistory"`
	Prehookjobshistory  pulumi.StringArrayInput `pulumi:"prehookjobshistory"`
}

func (SubscriptionStatusAnsiblejobsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionStatusAnsiblejobs)(nil)).Elem()
}

func (i SubscriptionStatusAnsiblejobsArgs) ToSubscriptionStatusAnsiblejobsOutput() SubscriptionStatusAnsiblejobsOutput {
	return i.ToSubscriptionStatusAnsiblejobsOutputWithContext(context.Background())
}

func (i SubscriptionStatusAnsiblejobsArgs) ToSubscriptionStatusAnsiblejobsOutputWithContext(ctx context.Context) SubscriptionStatusAnsiblejobsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionStatusAnsiblejobsOutput)
}

func (i SubscriptionStatusAnsiblejobsArgs) ToSubscriptionStatusAnsiblejobsPtrOutput() SubscriptionStatusAnsiblejobsPtrOutput {
	return i.ToSubscriptionStatusAnsiblejobsPtrOutputWithContext(context.Background())
}

func (i SubscriptionStatusAnsiblejobsArgs) ToSubscriptionStatusAnsiblejobsPtrOutputWithContext(ctx context.Context) SubscriptionStatusAnsiblejobsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionStatusAnsiblejobsOutput).ToSubscriptionStatusAnsiblejobsPtrOutputWithContext(ctx)
}

// SubscriptionStatusAnsiblejobsPtrInput is an input type that accepts SubscriptionStatusAnsiblejobsArgs, SubscriptionStatusAnsiblejobsPtr and SubscriptionStatusAnsiblejobsPtrOutput values.
// You can construct a concrete instance of `SubscriptionStatusAnsiblejobsPtrInput` via:
//
//          SubscriptionStatusAnsiblejobsArgs{...}
//
//  or:
//
//          nil
type SubscriptionStatusAnsiblejobsPtrInput interface {
	pulumi.Input

	ToSubscriptionStatusAnsiblejobsPtrOutput() SubscriptionStatusAnsiblejobsPtrOutput
	ToSubscriptionStatusAnsiblejobsPtrOutputWithContext(context.Context) SubscriptionStatusAnsiblejobsPtrOutput
}

type subscriptionStatusAnsiblejobsPtrType SubscriptionStatusAnsiblejobsArgs

func SubscriptionStatusAnsiblejobsPtr(v *SubscriptionStatusAnsiblejobsArgs) SubscriptionStatusAnsiblejobsPtrInput {
	return (*subscriptionStatusAnsiblejobsPtrType)(v)
}

func (*subscriptionStatusAnsiblejobsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**SubscriptionStatusAnsiblejobs)(nil)).Elem()
}

func (i *subscriptionStatusAnsiblejobsPtrType) ToSubscriptionStatusAnsiblejobsPtrOutput() SubscriptionStatusAnsiblejobsPtrOutput {
	return i.ToSubscriptionStatusAnsiblejobsPtrOutputWithContext(context.Background())
}

func (i *subscriptionStatusAnsiblejobsPtrType) ToSubscriptionStatusAnsiblejobsPtrOutputWithContext(ctx context.Context) SubscriptionStatusAnsiblejobsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionStatusAnsiblejobsPtrOutput)
}

type SubscriptionStatusAnsiblejobsOutput struct{ *pulumi.OutputState }

func (SubscriptionStatusAnsiblejobsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionStatusAnsiblejobs)(nil)).Elem()
}

func (o SubscriptionStatusAnsiblejobsOutput) ToSubscriptionStatusAnsiblejobsOutput() SubscriptionStatusAnsiblejobsOutput {
	return o
}

func (o SubscriptionStatusAnsiblejobsOutput) ToSubscriptionStatusAnsiblejobsOutputWithContext(ctx context.Context) SubscriptionStatusAnsiblejobsOutput {
	return o
}

func (o SubscriptionStatusAnsiblejobsOutput) ToSubscriptionStatusAnsiblejobsPtrOutput() SubscriptionStatusAnsiblejobsPtrOutput {
	return o.ToSubscriptionStatusAnsiblejobsPtrOutputWithContext(context.Background())
}

func (o SubscriptionStatusAnsiblejobsOutput) ToSubscriptionStatusAnsiblejobsPtrOutputWithContext(ctx context.Context) SubscriptionStatusAnsiblejobsPtrOutput {
	return o.ApplyT(func(v SubscriptionStatusAnsiblejobs) *SubscriptionStatusAnsiblejobs {
		return &v
	}).(SubscriptionStatusAnsiblejobsPtrOutput)
}
func (o SubscriptionStatusAnsiblejobsOutput) Lastposthookjob() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionStatusAnsiblejobs) *string { return v.Lastposthookjob }).(pulumi.StringPtrOutput)
}

func (o SubscriptionStatusAnsiblejobsOutput) Lastprehookjob() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionStatusAnsiblejobs) *string { return v.Lastprehookjob }).(pulumi.StringPtrOutput)
}

func (o SubscriptionStatusAnsiblejobsOutput) Posthookjobshistory() pulumi.StringArrayOutput {
	return o.ApplyT(func(v SubscriptionStatusAnsiblejobs) []string { return v.Posthookjobshistory }).(pulumi.StringArrayOutput)
}

func (o SubscriptionStatusAnsiblejobsOutput) Prehookjobshistory() pulumi.StringArrayOutput {
	return o.ApplyT(func(v SubscriptionStatusAnsiblejobs) []string { return v.Prehookjobshistory }).(pulumi.StringArrayOutput)
}

type SubscriptionStatusAnsiblejobsPtrOutput struct{ *pulumi.OutputState }

func (SubscriptionStatusAnsiblejobsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SubscriptionStatusAnsiblejobs)(nil)).Elem()
}

func (o SubscriptionStatusAnsiblejobsPtrOutput) ToSubscriptionStatusAnsiblejobsPtrOutput() SubscriptionStatusAnsiblejobsPtrOutput {
	return o
}

func (o SubscriptionStatusAnsiblejobsPtrOutput) ToSubscriptionStatusAnsiblejobsPtrOutputWithContext(ctx context.Context) SubscriptionStatusAnsiblejobsPtrOutput {
	return o
}

func (o SubscriptionStatusAnsiblejobsPtrOutput) Elem() SubscriptionStatusAnsiblejobsOutput {
	return o.ApplyT(func(v *SubscriptionStatusAnsiblejobs) SubscriptionStatusAnsiblejobs { return *v }).(SubscriptionStatusAnsiblejobsOutput)
}

func (o SubscriptionStatusAnsiblejobsPtrOutput) Lastposthookjob() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionStatusAnsiblejobs) *string {
		if v == nil {
			return nil
		}
		return v.Lastposthookjob
	}).(pulumi.StringPtrOutput)
}

func (o SubscriptionStatusAnsiblejobsPtrOutput) Lastprehookjob() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SubscriptionStatusAnsiblejobs) *string {
		if v == nil {
			return nil
		}
		return v.Lastprehookjob
	}).(pulumi.StringPtrOutput)
}

func (o SubscriptionStatusAnsiblejobsPtrOutput) Posthookjobshistory() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *SubscriptionStatusAnsiblejobs) []string {
		if v == nil {
			return nil
		}
		return v.Posthookjobshistory
	}).(pulumi.StringArrayOutput)
}

func (o SubscriptionStatusAnsiblejobsPtrOutput) Prehookjobshistory() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *SubscriptionStatusAnsiblejobs) []string {
		if v == nil {
			return nil
		}
		return v.Prehookjobshistory
	}).(pulumi.StringArrayOutput)
}

// SubscriptionPerClusterStatus defines status for subscription in each cluster, key is package name
type SubscriptionStatusStatuses struct {
	Packages map[string]SubscriptionStatusStatusesPackages `pulumi:"packages"`
}

// SubscriptionStatusStatusesInput is an input type that accepts SubscriptionStatusStatusesArgs and SubscriptionStatusStatusesOutput values.
// You can construct a concrete instance of `SubscriptionStatusStatusesInput` via:
//
//          SubscriptionStatusStatusesArgs{...}
type SubscriptionStatusStatusesInput interface {
	pulumi.Input

	ToSubscriptionStatusStatusesOutput() SubscriptionStatusStatusesOutput
	ToSubscriptionStatusStatusesOutputWithContext(context.Context) SubscriptionStatusStatusesOutput
}

// SubscriptionPerClusterStatus defines status for subscription in each cluster, key is package name
type SubscriptionStatusStatusesArgs struct {
	Packages SubscriptionStatusStatusesPackagesMapInput `pulumi:"packages"`
}

func (SubscriptionStatusStatusesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionStatusStatuses)(nil)).Elem()
}

func (i SubscriptionStatusStatusesArgs) ToSubscriptionStatusStatusesOutput() SubscriptionStatusStatusesOutput {
	return i.ToSubscriptionStatusStatusesOutputWithContext(context.Background())
}

func (i SubscriptionStatusStatusesArgs) ToSubscriptionStatusStatusesOutputWithContext(ctx context.Context) SubscriptionStatusStatusesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionStatusStatusesOutput)
}

// SubscriptionStatusStatusesMapInput is an input type that accepts SubscriptionStatusStatusesMap and SubscriptionStatusStatusesMapOutput values.
// You can construct a concrete instance of `SubscriptionStatusStatusesMapInput` via:
//
//          SubscriptionStatusStatusesMap{ "key": SubscriptionStatusStatusesArgs{...} }
type SubscriptionStatusStatusesMapInput interface {
	pulumi.Input

	ToSubscriptionStatusStatusesMapOutput() SubscriptionStatusStatusesMapOutput
	ToSubscriptionStatusStatusesMapOutputWithContext(context.Context) SubscriptionStatusStatusesMapOutput
}

type SubscriptionStatusStatusesMap map[string]SubscriptionStatusStatusesInput

func (SubscriptionStatusStatusesMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]SubscriptionStatusStatuses)(nil)).Elem()
}

func (i SubscriptionStatusStatusesMap) ToSubscriptionStatusStatusesMapOutput() SubscriptionStatusStatusesMapOutput {
	return i.ToSubscriptionStatusStatusesMapOutputWithContext(context.Background())
}

func (i SubscriptionStatusStatusesMap) ToSubscriptionStatusStatusesMapOutputWithContext(ctx context.Context) SubscriptionStatusStatusesMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionStatusStatusesMapOutput)
}

// SubscriptionPerClusterStatus defines status for subscription in each cluster, key is package name
type SubscriptionStatusStatusesOutput struct{ *pulumi.OutputState }

func (SubscriptionStatusStatusesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionStatusStatuses)(nil)).Elem()
}

func (o SubscriptionStatusStatusesOutput) ToSubscriptionStatusStatusesOutput() SubscriptionStatusStatusesOutput {
	return o
}

func (o SubscriptionStatusStatusesOutput) ToSubscriptionStatusStatusesOutputWithContext(ctx context.Context) SubscriptionStatusStatusesOutput {
	return o
}

func (o SubscriptionStatusStatusesOutput) Packages() SubscriptionStatusStatusesPackagesMapOutput {
	return o.ApplyT(func(v SubscriptionStatusStatuses) map[string]SubscriptionStatusStatusesPackages { return v.Packages }).(SubscriptionStatusStatusesPackagesMapOutput)
}

type SubscriptionStatusStatusesMapOutput struct{ *pulumi.OutputState }

func (SubscriptionStatusStatusesMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]SubscriptionStatusStatuses)(nil)).Elem()
}

func (o SubscriptionStatusStatusesMapOutput) ToSubscriptionStatusStatusesMapOutput() SubscriptionStatusStatusesMapOutput {
	return o
}

func (o SubscriptionStatusStatusesMapOutput) ToSubscriptionStatusStatusesMapOutputWithContext(ctx context.Context) SubscriptionStatusStatusesMapOutput {
	return o
}

func (o SubscriptionStatusStatusesMapOutput) MapIndex(k pulumi.StringInput) SubscriptionStatusStatusesOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) SubscriptionStatusStatuses {
		return vs[0].(map[string]SubscriptionStatusStatuses)[vs[1].(string)]
	}).(SubscriptionStatusStatusesOutput)
}

// SubscriptionUnitStatus defines status of a unit (subscription or package)
type SubscriptionStatusStatusesPackages struct {
	LastUpdateTime string  `pulumi:"lastUpdateTime"`
	Message        *string `pulumi:"message"`
	// Phase are Propagated if it is in hub or Subscribed if it is in endpoint
	Phase          *string                `pulumi:"phase"`
	Reason         *string                `pulumi:"reason"`
	ResourceStatus map[string]interface{} `pulumi:"resourceStatus"`
}

// SubscriptionStatusStatusesPackagesInput is an input type that accepts SubscriptionStatusStatusesPackagesArgs and SubscriptionStatusStatusesPackagesOutput values.
// You can construct a concrete instance of `SubscriptionStatusStatusesPackagesInput` via:
//
//          SubscriptionStatusStatusesPackagesArgs{...}
type SubscriptionStatusStatusesPackagesInput interface {
	pulumi.Input

	ToSubscriptionStatusStatusesPackagesOutput() SubscriptionStatusStatusesPackagesOutput
	ToSubscriptionStatusStatusesPackagesOutputWithContext(context.Context) SubscriptionStatusStatusesPackagesOutput
}

// SubscriptionUnitStatus defines status of a unit (subscription or package)
type SubscriptionStatusStatusesPackagesArgs struct {
	LastUpdateTime pulumi.StringInput    `pulumi:"lastUpdateTime"`
	Message        pulumi.StringPtrInput `pulumi:"message"`
	// Phase are Propagated if it is in hub or Subscribed if it is in endpoint
	Phase          pulumi.StringPtrInput `pulumi:"phase"`
	Reason         pulumi.StringPtrInput `pulumi:"reason"`
	ResourceStatus pulumi.MapInput       `pulumi:"resourceStatus"`
}

func (SubscriptionStatusStatusesPackagesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionStatusStatusesPackages)(nil)).Elem()
}

func (i SubscriptionStatusStatusesPackagesArgs) ToSubscriptionStatusStatusesPackagesOutput() SubscriptionStatusStatusesPackagesOutput {
	return i.ToSubscriptionStatusStatusesPackagesOutputWithContext(context.Background())
}

func (i SubscriptionStatusStatusesPackagesArgs) ToSubscriptionStatusStatusesPackagesOutputWithContext(ctx context.Context) SubscriptionStatusStatusesPackagesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionStatusStatusesPackagesOutput)
}

// SubscriptionStatusStatusesPackagesMapInput is an input type that accepts SubscriptionStatusStatusesPackagesMap and SubscriptionStatusStatusesPackagesMapOutput values.
// You can construct a concrete instance of `SubscriptionStatusStatusesPackagesMapInput` via:
//
//          SubscriptionStatusStatusesPackagesMap{ "key": SubscriptionStatusStatusesPackagesArgs{...} }
type SubscriptionStatusStatusesPackagesMapInput interface {
	pulumi.Input

	ToSubscriptionStatusStatusesPackagesMapOutput() SubscriptionStatusStatusesPackagesMapOutput
	ToSubscriptionStatusStatusesPackagesMapOutputWithContext(context.Context) SubscriptionStatusStatusesPackagesMapOutput
}

type SubscriptionStatusStatusesPackagesMap map[string]SubscriptionStatusStatusesPackagesInput

func (SubscriptionStatusStatusesPackagesMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]SubscriptionStatusStatusesPackages)(nil)).Elem()
}

func (i SubscriptionStatusStatusesPackagesMap) ToSubscriptionStatusStatusesPackagesMapOutput() SubscriptionStatusStatusesPackagesMapOutput {
	return i.ToSubscriptionStatusStatusesPackagesMapOutputWithContext(context.Background())
}

func (i SubscriptionStatusStatusesPackagesMap) ToSubscriptionStatusStatusesPackagesMapOutputWithContext(ctx context.Context) SubscriptionStatusStatusesPackagesMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionStatusStatusesPackagesMapOutput)
}

// SubscriptionUnitStatus defines status of a unit (subscription or package)
type SubscriptionStatusStatusesPackagesOutput struct{ *pulumi.OutputState }

func (SubscriptionStatusStatusesPackagesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionStatusStatusesPackages)(nil)).Elem()
}

func (o SubscriptionStatusStatusesPackagesOutput) ToSubscriptionStatusStatusesPackagesOutput() SubscriptionStatusStatusesPackagesOutput {
	return o
}

func (o SubscriptionStatusStatusesPackagesOutput) ToSubscriptionStatusStatusesPackagesOutputWithContext(ctx context.Context) SubscriptionStatusStatusesPackagesOutput {
	return o
}

func (o SubscriptionStatusStatusesPackagesOutput) LastUpdateTime() pulumi.StringOutput {
	return o.ApplyT(func(v SubscriptionStatusStatusesPackages) string { return v.LastUpdateTime }).(pulumi.StringOutput)
}

func (o SubscriptionStatusStatusesPackagesOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionStatusStatusesPackages) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// Phase are Propagated if it is in hub or Subscribed if it is in endpoint
func (o SubscriptionStatusStatusesPackagesOutput) Phase() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionStatusStatusesPackages) *string { return v.Phase }).(pulumi.StringPtrOutput)
}

func (o SubscriptionStatusStatusesPackagesOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v SubscriptionStatusStatusesPackages) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

func (o SubscriptionStatusStatusesPackagesOutput) ResourceStatus() pulumi.MapOutput {
	return o.ApplyT(func(v SubscriptionStatusStatusesPackages) map[string]interface{} { return v.ResourceStatus }).(pulumi.MapOutput)
}

type SubscriptionStatusStatusesPackagesMapOutput struct{ *pulumi.OutputState }

func (SubscriptionStatusStatusesPackagesMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]SubscriptionStatusStatusesPackages)(nil)).Elem()
}

func (o SubscriptionStatusStatusesPackagesMapOutput) ToSubscriptionStatusStatusesPackagesMapOutput() SubscriptionStatusStatusesPackagesMapOutput {
	return o
}

func (o SubscriptionStatusStatusesPackagesMapOutput) ToSubscriptionStatusStatusesPackagesMapOutputWithContext(ctx context.Context) SubscriptionStatusStatusesPackagesMapOutput {
	return o
}

func (o SubscriptionStatusStatusesPackagesMapOutput) MapIndex(k pulumi.StringInput) SubscriptionStatusStatusesPackagesOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) SubscriptionStatusStatusesPackages {
		return vs[0].(map[string]SubscriptionStatusStatusesPackages)[vs[1].(string)]
	}).(SubscriptionStatusStatusesPackagesOutput)
}

type SubscriptionStatusStatusesPackagesResourceStatus struct {
}

// SubscriptionStatusStatusesPackagesResourceStatusInput is an input type that accepts SubscriptionStatusStatusesPackagesResourceStatusArgs and SubscriptionStatusStatusesPackagesResourceStatusOutput values.
// You can construct a concrete instance of `SubscriptionStatusStatusesPackagesResourceStatusInput` via:
//
//          SubscriptionStatusStatusesPackagesResourceStatusArgs{...}
type SubscriptionStatusStatusesPackagesResourceStatusInput interface {
	pulumi.Input

	ToSubscriptionStatusStatusesPackagesResourceStatusOutput() SubscriptionStatusStatusesPackagesResourceStatusOutput
	ToSubscriptionStatusStatusesPackagesResourceStatusOutputWithContext(context.Context) SubscriptionStatusStatusesPackagesResourceStatusOutput
}

type SubscriptionStatusStatusesPackagesResourceStatusArgs struct {
}

func (SubscriptionStatusStatusesPackagesResourceStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionStatusStatusesPackagesResourceStatus)(nil)).Elem()
}

func (i SubscriptionStatusStatusesPackagesResourceStatusArgs) ToSubscriptionStatusStatusesPackagesResourceStatusOutput() SubscriptionStatusStatusesPackagesResourceStatusOutput {
	return i.ToSubscriptionStatusStatusesPackagesResourceStatusOutputWithContext(context.Background())
}

func (i SubscriptionStatusStatusesPackagesResourceStatusArgs) ToSubscriptionStatusStatusesPackagesResourceStatusOutputWithContext(ctx context.Context) SubscriptionStatusStatusesPackagesResourceStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubscriptionStatusStatusesPackagesResourceStatusOutput)
}

type SubscriptionStatusStatusesPackagesResourceStatusOutput struct{ *pulumi.OutputState }

func (SubscriptionStatusStatusesPackagesResourceStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*SubscriptionStatusStatusesPackagesResourceStatus)(nil)).Elem()
}

func (o SubscriptionStatusStatusesPackagesResourceStatusOutput) ToSubscriptionStatusStatusesPackagesResourceStatusOutput() SubscriptionStatusStatusesPackagesResourceStatusOutput {
	return o
}

func (o SubscriptionStatusStatusesPackagesResourceStatusOutput) ToSubscriptionStatusStatusesPackagesResourceStatusOutputWithContext(ctx context.Context) SubscriptionStatusStatusesPackagesResourceStatusOutput {
	return o
}

func init() {
	pulumi.RegisterOutputType(ChannelTypeOutput{})
	pulumi.RegisterOutputType(ChannelMetadataOutput{})
	pulumi.RegisterOutputType(ChannelSpecOutput{})
	pulumi.RegisterOutputType(ChannelSpecPtrOutput{})
	pulumi.RegisterOutputType(ChannelSpecConfigMapRefOutput{})
	pulumi.RegisterOutputType(ChannelSpecConfigMapRefPtrOutput{})
	pulumi.RegisterOutputType(ChannelSpecGatesOutput{})
	pulumi.RegisterOutputType(ChannelSpecGatesPtrOutput{})
	pulumi.RegisterOutputType(ChannelSpecGatesAnnotationsOutput{})
	pulumi.RegisterOutputType(ChannelSpecGatesLabelSelectorOutput{})
	pulumi.RegisterOutputType(ChannelSpecGatesLabelSelectorPtrOutput{})
	pulumi.RegisterOutputType(ChannelSpecGatesLabelSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChannelSpecGatesLabelSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChannelSpecGatesLabelSelectorMatchLabelsOutput{})
	pulumi.RegisterOutputType(ChannelSpecSecretRefOutput{})
	pulumi.RegisterOutputType(ChannelSpecSecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChannelStatusOutput{})
	pulumi.RegisterOutputType(DeployableTypeOutput{})
	pulumi.RegisterOutputType(DeployableMetadataOutput{})
	pulumi.RegisterOutputType(DeployableSpecOutput{})
	pulumi.RegisterOutputType(DeployableSpecPtrOutput{})
	pulumi.RegisterOutputType(DeployableSpecDependenciesOutput{})
	pulumi.RegisterOutputType(DeployableSpecDependenciesArrayOutput{})
	pulumi.RegisterOutputType(DeployableSpecDependenciesAnnotationsOutput{})
	pulumi.RegisterOutputType(DeployableSpecDependenciesLabelsOutput{})
	pulumi.RegisterOutputType(DeployableSpecOverridesOutput{})
	pulumi.RegisterOutputType(DeployableSpecOverridesArrayOutput{})
	pulumi.RegisterOutputType(DeployableSpecOverridesClusterOverridesOutput{})
	pulumi.RegisterOutputType(DeployableSpecPlacementOutput{})
	pulumi.RegisterOutputType(DeployableSpecPlacementPtrOutput{})
	pulumi.RegisterOutputType(DeployableSpecPlacementClusterSelectorOutput{})
	pulumi.RegisterOutputType(DeployableSpecPlacementClusterSelectorPtrOutput{})
	pulumi.RegisterOutputType(DeployableSpecPlacementClusterSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(DeployableSpecPlacementClusterSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(DeployableSpecPlacementClusterSelectorMatchLabelsOutput{})
	pulumi.RegisterOutputType(DeployableSpecPlacementClustersOutput{})
	pulumi.RegisterOutputType(DeployableSpecPlacementClustersArrayOutput{})
	pulumi.RegisterOutputType(DeployableSpecPlacementPlacementRefOutput{})
	pulumi.RegisterOutputType(DeployableSpecPlacementPlacementRefPtrOutput{})
	pulumi.RegisterOutputType(DeployableSpecTemplateOutput{})
	pulumi.RegisterOutputType(DeployableStatusOutput{})
	pulumi.RegisterOutputType(DeployableStatusPtrOutput{})
	pulumi.RegisterOutputType(HelmReleaseTypeOutput{})
	pulumi.RegisterOutputType(HelmReleaseMetadataOutput{})
	pulumi.RegisterOutputType(HelmReleaseRepoOutput{})
	pulumi.RegisterOutputType(HelmReleaseRepoPtrOutput{})
	pulumi.RegisterOutputType(HelmReleaseRepoConfigMapRefOutput{})
	pulumi.RegisterOutputType(HelmReleaseRepoConfigMapRefPtrOutput{})
	pulumi.RegisterOutputType(HelmReleaseRepoSecretRefOutput{})
	pulumi.RegisterOutputType(HelmReleaseRepoSecretRefPtrOutput{})
	pulumi.RegisterOutputType(HelmReleaseRepoSourceOutput{})
	pulumi.RegisterOutputType(HelmReleaseRepoSourcePtrOutput{})
	pulumi.RegisterOutputType(HelmReleaseRepoSourceGithubOutput{})
	pulumi.RegisterOutputType(HelmReleaseRepoSourceGithubPtrOutput{})
	pulumi.RegisterOutputType(HelmReleaseRepoSourceHelmRepoOutput{})
	pulumi.RegisterOutputType(HelmReleaseRepoSourceHelmRepoPtrOutput{})
	pulumi.RegisterOutputType(HelmReleaseStatusOutput{})
	pulumi.RegisterOutputType(HelmReleaseStatusPtrOutput{})
	pulumi.RegisterOutputType(HelmReleaseStatusConditionsOutput{})
	pulumi.RegisterOutputType(HelmReleaseStatusConditionsArrayOutput{})
	pulumi.RegisterOutputType(HelmReleaseStatusDeployedReleaseOutput{})
	pulumi.RegisterOutputType(HelmReleaseStatusDeployedReleasePtrOutput{})
	pulumi.RegisterOutputType(PlacementRuleTypeOutput{})
	pulumi.RegisterOutputType(PlacementRuleMetadataOutput{})
	pulumi.RegisterOutputType(PlacementRuleSpecOutput{})
	pulumi.RegisterOutputType(PlacementRuleSpecPtrOutput{})
	pulumi.RegisterOutputType(PlacementRuleSpecClusterConditionsOutput{})
	pulumi.RegisterOutputType(PlacementRuleSpecClusterConditionsArrayOutput{})
	pulumi.RegisterOutputType(PlacementRuleSpecClusterSelectorOutput{})
	pulumi.RegisterOutputType(PlacementRuleSpecClusterSelectorPtrOutput{})
	pulumi.RegisterOutputType(PlacementRuleSpecClusterSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(PlacementRuleSpecClusterSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(PlacementRuleSpecClusterSelectorMatchLabelsOutput{})
	pulumi.RegisterOutputType(PlacementRuleSpecClustersOutput{})
	pulumi.RegisterOutputType(PlacementRuleSpecClustersArrayOutput{})
	pulumi.RegisterOutputType(PlacementRuleSpecPoliciesOutput{})
	pulumi.RegisterOutputType(PlacementRuleSpecPoliciesArrayOutput{})
	pulumi.RegisterOutputType(PlacementRuleSpecResourceHintOutput{})
	pulumi.RegisterOutputType(PlacementRuleSpecResourceHintPtrOutput{})
	pulumi.RegisterOutputType(PlacementRuleStatusOutput{})
	pulumi.RegisterOutputType(PlacementRuleStatusPtrOutput{})
	pulumi.RegisterOutputType(PlacementRuleStatusDecisionsOutput{})
	pulumi.RegisterOutputType(PlacementRuleStatusDecisionsArrayOutput{})
	pulumi.RegisterOutputType(SubscriptionTypeOutput{})
	pulumi.RegisterOutputType(SubscriptionMetadataOutput{})
	pulumi.RegisterOutputType(SubscriptionSpecOutput{})
	pulumi.RegisterOutputType(SubscriptionSpecPtrOutput{})
	pulumi.RegisterOutputType(SubscriptionSpecHooksecretrefOutput{})
	pulumi.RegisterOutputType(SubscriptionSpecHooksecretrefPtrOutput{})
	pulumi.RegisterOutputType(SubscriptionSpecOverridesOutput{})
	pulumi.RegisterOutputType(SubscriptionSpecOverridesArrayOutput{})
	pulumi.RegisterOutputType(SubscriptionSpecOverridesClusterOverridesOutput{})
	pulumi.RegisterOutputType(SubscriptionSpecPackageFilterOutput{})
	pulumi.RegisterOutputType(SubscriptionSpecPackageFilterPtrOutput{})
	pulumi.RegisterOutputType(SubscriptionSpecPackageFilterAnnotationsOutput{})
	pulumi.RegisterOutputType(SubscriptionSpecPackageFilterFilterRefOutput{})
	pulumi.RegisterOutputType(SubscriptionSpecPackageFilterFilterRefPtrOutput{})
	pulumi.RegisterOutputType(SubscriptionSpecPackageFilterLabelSelectorOutput{})
	pulumi.RegisterOutputType(SubscriptionSpecPackageFilterLabelSelectorPtrOutput{})
	pulumi.RegisterOutputType(SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(SubscriptionSpecPackageFilterLabelSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(SubscriptionSpecPackageFilterLabelSelectorMatchLabelsOutput{})
	pulumi.RegisterOutputType(SubscriptionSpecPackageOverridesOutput{})
	pulumi.RegisterOutputType(SubscriptionSpecPackageOverridesArrayOutput{})
	pulumi.RegisterOutputType(SubscriptionSpecPackageOverridesPackageOverridesOutput{})
	pulumi.RegisterOutputType(SubscriptionSpecPlacementOutput{})
	pulumi.RegisterOutputType(SubscriptionSpecPlacementPtrOutput{})
	pulumi.RegisterOutputType(SubscriptionSpecPlacementClusterSelectorOutput{})
	pulumi.RegisterOutputType(SubscriptionSpecPlacementClusterSelectorPtrOutput{})
	pulumi.RegisterOutputType(SubscriptionSpecPlacementClusterSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(SubscriptionSpecPlacementClusterSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(SubscriptionSpecPlacementClusterSelectorMatchLabelsOutput{})
	pulumi.RegisterOutputType(SubscriptionSpecPlacementClustersOutput{})
	pulumi.RegisterOutputType(SubscriptionSpecPlacementClustersArrayOutput{})
	pulumi.RegisterOutputType(SubscriptionSpecPlacementPlacementRefOutput{})
	pulumi.RegisterOutputType(SubscriptionSpecPlacementPlacementRefPtrOutput{})
	pulumi.RegisterOutputType(SubscriptionSpecTimewindowOutput{})
	pulumi.RegisterOutputType(SubscriptionSpecTimewindowPtrOutput{})
	pulumi.RegisterOutputType(SubscriptionSpecTimewindowHoursOutput{})
	pulumi.RegisterOutputType(SubscriptionSpecTimewindowHoursArrayOutput{})
	pulumi.RegisterOutputType(SubscriptionStatusOutput{})
	pulumi.RegisterOutputType(SubscriptionStatusPtrOutput{})
	pulumi.RegisterOutputType(SubscriptionStatusAnsiblejobsOutput{})
	pulumi.RegisterOutputType(SubscriptionStatusAnsiblejobsPtrOutput{})
	pulumi.RegisterOutputType(SubscriptionStatusStatusesOutput{})
	pulumi.RegisterOutputType(SubscriptionStatusStatusesMapOutput{})
	pulumi.RegisterOutputType(SubscriptionStatusStatusesPackagesOutput{})
	pulumi.RegisterOutputType(SubscriptionStatusStatusesPackagesMapOutput{})
	pulumi.RegisterOutputType(SubscriptionStatusStatusesPackagesResourceStatusOutput{})
}
