// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

import {ObjectMeta} from "../meta/v1";

export namespace app {
    export namespace v1beta1 {
        /**
         * ApplicationSpec defines the specification for an Application.
         */
        export interface ApplicationSpec {
            /**
             * AddOwnerRef objects - flag to indicate if we need to add OwnerRefs to matching objects Matching is done by using Selector to query all ComponentGroupKinds
             */
            addOwnerRef?: boolean;
            /**
             * AssemblyPhase represents the current phase of the application's assembly. An empty value is equivalent to "Succeeded".
             */
            assemblyPhase?: string;
            /**
             * ComponentGroupKinds is a list of Kinds for Application's components (e.g. Deployments, Pods, Services, CRDs). It can be used in conjunction with the Application's Selector to list or watch the Applications components.
             */
            componentKinds?: outputs.app.v1beta1.ApplicationSpecComponentKinds[];
            /**
             * Descriptor regroups information and metadata about an application.
             */
            descriptor?: outputs.app.v1beta1.ApplicationSpecDescriptor;
            /**
             * Info contains human readable key,value pairs for the Application.
             */
            info?: outputs.app.v1beta1.ApplicationSpecInfo[];
            /**
             * Selector is a label query over kinds that created by the application. It must match the component objects' labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
             */
            selector?: outputs.app.v1beta1.ApplicationSpecSelector;
        }

        /**
         * GroupKind specifies a Group and a Kind, but does not force a version.  This is useful for identifying concepts during lookup stages without having partially valid types
         */
        export interface ApplicationSpecComponentKinds {
            group: string;
            kind: string;
        }

        /**
         * Descriptor regroups information and metadata about an application.
         */
        export interface ApplicationSpecDescriptor {
            /**
             * Description is a brief string description of the Application.
             */
            description?: string;
            /**
             * Icons is an optional list of icons for an application. Icon information includes the source, size, and mime type.
             */
            icons?: outputs.app.v1beta1.ApplicationSpecDescriptorIcons[];
            /**
             * Keywords is an optional list of key words associated with the application (e.g. MySQL, RDBMS, database).
             */
            keywords?: string[];
            /**
             * Links are a list of descriptive URLs intended to be used to surface additional documentation, dashboards, etc.
             */
            links?: outputs.app.v1beta1.ApplicationSpecDescriptorLinks[];
            /**
             * Maintainers is an optional list of maintainers of the application. The maintainers in this list maintain the the source code, images, and package for the application.
             */
            maintainers?: outputs.app.v1beta1.ApplicationSpecDescriptorMaintainers[];
            /**
             * Notes contain a human readable snippets intended as a quick start for the users of the Application. CommonMark markdown syntax may be used for rich text representation.
             */
            notes?: string;
            /**
             * Owners is an optional list of the owners of the installed application. The owners of the application should be contacted in the event of a planned or unplanned disruption affecting the application.
             */
            owners?: outputs.app.v1beta1.ApplicationSpecDescriptorOwners[];
            /**
             * Type is the type of the application (e.g. WordPress, MySQL, Cassandra).
             */
            type?: string;
            /**
             * Version is an optional version indicator for the Application.
             */
            version?: string;
        }

        /**
         * ImageSpec contains information about an image used as an icon.
         */
        export interface ApplicationSpecDescriptorIcons {
            /**
             * (optional) The size of the image in pixels (e.g., 25x25).
             */
            size?: string;
            /**
             * The source for image represented as either an absolute URL to the image or a Data URL containing the image. Data URLs are defined in RFC 2397.
             */
            src: string;
            /**
             * (optional) The mine type of the image (e.g., "image/png").
             */
            type?: string;
        }

        /**
         * Link contains information about an URL to surface documentation, dashboards, etc.
         */
        export interface ApplicationSpecDescriptorLinks {
            /**
             * Description is human readable content explaining the purpose of the link.
             */
            description?: string;
            /**
             * Url typically points at a website address.
             */
            url?: string;
        }

        /**
         * ContactData contains information about an individual or organization.
         */
        export interface ApplicationSpecDescriptorMaintainers {
            /**
             * Email is the email address.
             */
            email?: string;
            /**
             * Name is the descriptive name.
             */
            name?: string;
            /**
             * Url could typically be a website address.
             */
            url?: string;
        }

        /**
         * ContactData contains information about an individual or organization.
         */
        export interface ApplicationSpecDescriptorOwners {
            /**
             * Email is the email address.
             */
            email?: string;
            /**
             * Name is the descriptive name.
             */
            name?: string;
            /**
             * Url could typically be a website address.
             */
            url?: string;
        }

        /**
         * InfoItem is a human readable key,value pair containing important information about how to access the Application.
         */
        export interface ApplicationSpecInfo {
            /**
             * Name is a human readable title for this piece of information.
             */
            name?: string;
            /**
             * Type of the value for this InfoItem.
             */
            type?: string;
            /**
             * Value is human readable content.
             */
            value?: string;
            /**
             * ValueFrom defines a reference to derive the value from another source.
             */
            valueFrom?: outputs.app.v1beta1.ApplicationSpecInfoValueFrom;
        }

        /**
         * ValueFrom defines a reference to derive the value from another source.
         */
        export interface ApplicationSpecInfoValueFrom {
            /**
             * Selects a key of a ConfigMap.
             */
            configMapKeyRef?: outputs.app.v1beta1.ApplicationSpecInfoValueFromConfigMapKeyRef;
            /**
             * Select an Ingress.
             */
            ingressRef?: outputs.app.v1beta1.ApplicationSpecInfoValueFromIngressRef;
            /**
             * Selects a key of a Secret.
             */
            secretKeyRef?: outputs.app.v1beta1.ApplicationSpecInfoValueFromSecretKeyRef;
            /**
             * Select a Service.
             */
            serviceRef?: outputs.app.v1beta1.ApplicationSpecInfoValueFromServiceRef;
            /**
             * Type of source.
             */
            type?: string;
        }

        /**
         * Selects a key of a ConfigMap.
         */
        export interface ApplicationSpecInfoValueFromConfigMapKeyRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * The key to select.
             */
            key?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * Select an Ingress.
         */
        export interface ApplicationSpecInfoValueFromIngressRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * The optional host to select.
             */
            host?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * The optional HTTP path.
             */
            path?: string;
            /**
             * Protocol for the ingress
             */
            protocol?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * Selects a key of a Secret.
         */
        export interface ApplicationSpecInfoValueFromSecretKeyRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * The key to select.
             */
            key?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * Select a Service.
         */
        export interface ApplicationSpecInfoValueFromServiceRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * The optional HTTP path.
             */
            path?: string;
            /**
             * The optional port to select.
             */
            port?: number;
            /**
             * Protocol for the service
             */
            protocol?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * Selector is a label query over kinds that created by the application. It must match the component objects' labels. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
         */
        export interface ApplicationSpecSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.app.v1beta1.ApplicationSpecSelectorMatchExpressions[];
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: {[key: string]: string};
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
         */
        export interface ApplicationSpecSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string;
            /**
             * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string;
            /**
             * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
             */
            values?: string[];
        }

        /**
         * ApplicationStatus defines controller's the observed state of Application
         */
        export interface ApplicationStatus {
            /**
             * Object status array for all matching objects
             */
            components?: outputs.app.v1beta1.ApplicationStatusComponents[];
            /**
             * ComponentsReady: status of the components in the format ready/total
             */
            componentsReady?: string;
            /**
             * Conditions represents the latest state of the object
             */
            conditions?: outputs.app.v1beta1.ApplicationStatusConditions[];
            /**
             * ObservedGeneration is the most recent generation observed. It corresponds to the Object's generation, which is updated on mutation by the API Server.
             */
            observedGeneration?: number;
        }

        /**
         * ObjectStatus is a generic status holder for objects
         */
        export interface ApplicationStatusComponents {
            /**
             * Object group
             */
            group?: string;
            /**
             * Kind of object
             */
            kind?: string;
            /**
             * Link to object
             */
            link?: string;
            /**
             * Name of object
             */
            name?: string;
            /**
             * Status. Values: InProgress, Ready, Unknown
             */
            status?: string;
        }

        /**
         * Condition describes the state of an object at a certain point.
         */
        export interface ApplicationStatusConditions {
            /**
             * Last time the condition transitioned from one status to another.
             */
            lastTransitionTime?: string;
            /**
             * Last time the condition was probed
             */
            lastUpdateTime?: string;
            /**
             * A human readable message indicating details about the transition.
             */
            message?: string;
            /**
             * The reason for the condition's last transition.
             */
            reason?: string;
            /**
             * Status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * Type of condition.
             */
            type: string;
        }
    }
}

export namespace apps {
    export namespace v1 {
        /**
         * ChannelSpec defines the desired state of Channel
         */
        export interface ChannelSpec {
            /**
             * Reference to a ConfigMap which contains additional settings for accessing the channel. For example, the `insecureSkipVerify` option for accessing HTTPS endpoints can be set in the ConfigMap to indicate a insecure connection.
             */
            configMapRef?: outputs.apps.v1.ChannelSpecConfigMapRef;
            /**
             * Criteria for promoting a Deployable from the sourceNamespaces to Channel.
             */
            gates?: outputs.apps.v1.ChannelSpecGates;
            /**
             * Skip server TLS certificate verification for Git or Helm channel.
             */
            insecureSkipVerify?: boolean;
            /**
             * For a `namespace` channel, pathname is the name of the namespace; For a `helmrepo` or `github` channel, pathname is the remote URL for the channel contents; For a `objectbucket` channel, pathname is the URL and name of the bucket.
             */
            pathname: string;
            /**
             * For a `github` channel or a `helmrepo` channel on github, this can be used to reference a Secret which contains the credentials for authentication, i.e. `user` and `accessToken`. For a `objectbucket` channel, this can be used to reference a Secret which contains the AWS credentials, i.e. `AccessKeyID` and `SecretAccessKey`.
             */
            secretRef?: outputs.apps.v1.ChannelSpecSecretRef;
            /**
             * A list of namespace names from which Deployables can be promoted.
             */
            sourceNamespaces?: string[];
            /**
             * ChannelType defines types of channel
             */
            type: string;
        }

        /**
         * Reference to a ConfigMap which contains additional settings for accessing the channel. For example, the `insecureSkipVerify` option for accessing HTTPS endpoints can be set in the ConfigMap to indicate a insecure connection.
         */
        export interface ChannelSpecConfigMapRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * Criteria for promoting a Deployable from the sourceNamespaces to Channel.
         */
        export interface ChannelSpecGates {
            /**
             * The annotations which must present on a Deployable for it to be eligible for promotion.
             */
            annotations?: {[key: string]: string};
            /**
             * A label selector for selecting the Deployables.
             */
            labelSelector?: outputs.apps.v1.ChannelSpecGatesLabelSelector;
            name?: string;
        }

        /**
         * A label selector for selecting the Deployables.
         */
        export interface ChannelSpecGatesLabelSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.apps.v1.ChannelSpecGatesLabelSelectorMatchExpressions[];
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: {[key: string]: string};
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
         */
        export interface ChannelSpecGatesLabelSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string;
            /**
             * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string;
            /**
             * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
             */
            values?: string[];
        }

        /**
         * For a `github` channel or a `helmrepo` channel on github, this can be used to reference a Secret which contains the credentials for authentication, i.e. `user` and `accessToken`. For a `objectbucket` channel, this can be used to reference a Secret which contains the AWS credentials, i.e. `AccessKeyID` and `SecretAccessKey`.
         */
        export interface ChannelSpecSecretRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * DeployableSpec defines the desired state of Deployable
         */
        export interface DeployableSpec {
            channels?: string[];
            dependencies?: outputs.apps.v1.DeployableSpecDependencies[];
            overrides?: outputs.apps.v1.DeployableSpecOverrides[];
            /**
             * Placement field to be referenced in specs, align with Fedv2, add placementref
             */
            placement?: outputs.apps.v1.DeployableSpecPlacement;
            template: {[key: string]: any};
        }

        /**
         * Dependency of Deployable Properties field is the flexiblity for different Kind
         */
        export interface DeployableSpecDependencies {
            annotations?: {[key: string]: string};
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
             */
            kind?: string;
            labels?: {[key: string]: string};
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * Overrides field in deployable
         */
        export interface DeployableSpecOverrides {
            clusterName: string;
            clusterOverrides: {[key: string]: any}[];
        }

        /**
         * Placement field to be referenced in specs, align with Fedv2, add placementref
         */
        export interface DeployableSpecPlacement {
            /**
             * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
             */
            clusterSelector?: outputs.apps.v1.DeployableSpecPlacementClusterSelector;
            clusters?: outputs.apps.v1.DeployableSpecPlacementClusters[];
            local?: boolean;
            /**
             * ObjectReference contains enough information to let you inspect or modify the referred object.
             */
            placementRef?: outputs.apps.v1.DeployableSpecPlacementPlacementRef;
        }

        /**
         * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
         */
        export interface DeployableSpecPlacementClusterSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.apps.v1.DeployableSpecPlacementClusterSelectorMatchExpressions[];
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: {[key: string]: string};
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
         */
        export interface DeployableSpecPlacementClusterSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string;
            /**
             * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string;
            /**
             * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
             */
            values?: string[];
        }

        /**
         * GenericClusterReference - in alignment with kubefed
         */
        export interface DeployableSpecPlacementClusters {
            name: string;
        }

        /**
         * ObjectReference contains enough information to let you inspect or modify the referred object.
         */
        export interface DeployableSpecPlacementPlacementRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * DeployableStatus defines the observed state of Deployable
         */
        export interface DeployableStatus {
            targetClusters?: any;
        }

        /**
         * HelmReleaseRepo defines the repository of HelmRelease
         */
        export interface HelmReleaseRepo {
            /**
             * ChartName is the name of the chart within the repo
             */
            chartName?: string;
            /**
             * Configuration parameters to access the helm-repo defined in the CatalogSource
             */
            configMapRef?: outputs.apps.v1.HelmReleaseRepoConfigMapRef;
            /**
             * Used to skip repo server's TLS certificate verification
             */
            insecureSkipVerify?: boolean;
            /**
             * Secret to use to access the helm-repo defined in the CatalogSource.
             */
            secretRef?: outputs.apps.v1.HelmReleaseRepoSecretRef;
            /**
             * INSERT ADDITIONAL SPEC FIELDS - desired state of cluster Important: Run "operator-sdk generate k8s" to regenerate code after modifying this file Add custom validation using kubebuilder tags: https://book-v1.book.kubebuilder.io/beyond_basics/generating_crd.html Source holds the url toward the helm-chart
             */
            source?: outputs.apps.v1.HelmReleaseRepoSource;
            /**
             * Version is the chart version
             */
            version?: string;
        }

        /**
         * Configuration parameters to access the helm-repo defined in the CatalogSource
         */
        export interface HelmReleaseRepoConfigMapRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * Secret to use to access the helm-repo defined in the CatalogSource.
         */
        export interface HelmReleaseRepoSecretRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * INSERT ADDITIONAL SPEC FIELDS - desired state of cluster Important: Run "operator-sdk generate k8s" to regenerate code after modifying this file Add custom validation using kubebuilder tags: https://book-v1.book.kubebuilder.io/beyond_basics/generating_crd.html Source holds the url toward the helm-chart
         */
        export interface HelmReleaseRepoSource {
            /**
             * GitHub provides the parameters to access the helm-chart located in a github repo
             */
            github?: outputs.apps.v1.HelmReleaseRepoSourceGithub;
            /**
             * HelmRepo provides the urls to retrieve the helm-chart
             */
            helmRepo?: outputs.apps.v1.HelmReleaseRepoSourceHelmRepo;
            /**
             * SourceTypeEnum types of sources
             */
            type?: string;
        }

        /**
         * GitHub provides the parameters to access the helm-chart located in a github repo
         */
        export interface HelmReleaseRepoSourceGithub {
            branch?: string;
            chartPath?: string;
            urls?: string[];
        }

        /**
         * HelmRepo provides the urls to retrieve the helm-chart
         */
        export interface HelmReleaseRepoSourceHelmRepo {
            urls?: string[];
        }

        export interface HelmReleaseStatus {
            conditions: outputs.apps.v1.HelmReleaseStatusConditions[];
            deployedRelease?: outputs.apps.v1.HelmReleaseStatusDeployedRelease;
        }

        export interface HelmReleaseStatusConditions {
            lastTransitionTime?: string;
            message?: string;
            reason?: string;
            status: string;
            type: string;
        }

        export interface HelmReleaseStatusDeployedRelease {
            manifest?: string;
            name?: string;
        }

        /**
         * PlacementRuleSpec defines the desired state of PlacementRule
         */
        export interface PlacementRuleSpec {
            clusterConditions?: outputs.apps.v1.PlacementRuleSpecClusterConditions[];
            /**
             * number of replicas Application wants to
             */
            clusterReplicas?: number;
            /**
             * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
             */
            clusterSelector?: outputs.apps.v1.PlacementRuleSpecClusterSelector;
            clusters?: outputs.apps.v1.PlacementRuleSpecClusters[];
            /**
             * Set Policy Filters
             */
            policies?: outputs.apps.v1.PlacementRuleSpecPolicies[];
            /**
             * Select Resource
             */
            resourceHint?: outputs.apps.v1.PlacementRuleSpecResourceHint;
            /**
             * INSERT ADDITIONAL SPEC FIELDS - desired state of cluster Important: Run "make" to regenerate code after modifying this file schedulerName, default to use mcm controller
             */
            schedulerName?: string;
        }

        /**
         * ClusterConditionFilter defines filter to filter cluster condition
         */
        export interface PlacementRuleSpecClusterConditions {
            status?: string;
            type?: string;
        }

        /**
         * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
         */
        export interface PlacementRuleSpecClusterSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.apps.v1.PlacementRuleSpecClusterSelectorMatchExpressions[];
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: {[key: string]: string};
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
         */
        export interface PlacementRuleSpecClusterSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string;
            /**
             * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string;
            /**
             * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
             */
            values?: string[];
        }

        /**
         * GenericClusterReference - in alignment with kubefed
         */
        export interface PlacementRuleSpecClusters {
            name: string;
        }

        /**
         * ObjectReference contains enough information to let you inspect or modify the referred object. --- New uses of this type are discouraged because of difficulty describing its usage when embedded in APIs.  1. Ignored fields.  It includes many fields which are not generally honored.  For instance, ResourceVersion and FieldPath are both very rarely valid in actual usage.  2. Invalid usage help.  It is impossible to add specific help for individual usage.  In most embedded usages, there are particular     restrictions like, "must refer only to types A and B" or "UID not honored" or "name must be restricted".     Those cannot be well described when embedded.  3. Inconsistent validation.  Because the usages are different, the validation rules are different by usage, which makes it hard for users to predict what will happen.  4. The fields are both imprecise and overly precise.  Kind is not a precise mapping to a URL. This can produce ambiguity     during interpretation and require a REST mapping.  In most cases, the dependency is on the group,resource tuple     and the version of the actual struct is irrelevant.  5. We cannot easily change it.  Because this type is embedded in many locations, updates to this type     will affect numerous schemas.  Don't make new APIs embed an underspecified API type they do not control. Instead of using this type, create a locally provided and used type that is well-focused on your reference. For example, ServiceReferences for admission registration: https://github.com/kubernetes/api/blob/release-1.17/admissionregistration/v1/types.go#L533 .
         */
        export interface PlacementRuleSpecPolicies {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * Select Resource
         */
        export interface PlacementRuleSpecResourceHint {
            /**
             * SelectionOrder is the type for Nodes
             */
            order?: string;
            /**
             * ResourceType defines types can be sorted
             */
            type?: string;
        }

        /**
         * PlacementRuleStatus defines the observed state of PlacementRule
         */
        export interface PlacementRuleStatus {
            /**
             * INSERT ADDITIONAL STATUS FIELD - define observed state of cluster Important: Run "make" to regenerate code after modifying this file
             */
            decisions?: outputs.apps.v1.PlacementRuleStatusDecisions[];
        }

        /**
         * PlacementDecision defines the decision made by controller
         */
        export interface PlacementRuleStatusDecisions {
            clusterName?: string;
            clusterNamespace?: string;
        }

        /**
         * SubscriptionSpec defines the desired state of Subscription
         */
        export interface SubscriptionSpec {
            channel: string;
            /**
             * ObjectReference contains enough information to let you inspect or modify the referred object. --- New uses of this type are discouraged because of difficulty describing its usage when embedded in APIs.  1. Ignored fields.  It includes many fields which are not generally honored.  For instance, ResourceVersion and FieldPath are both very rarely valid in actual usage.  2. Invalid usage help.  It is impossible to add specific help for individual usage.  In most embedded usages, there are particular     restrictions like, "must refer only to types A and B" or "UID not honored" or "name must be restricted".     Those cannot be well described when embedded.  3. Inconsistent validation.  Because the usages are different, the validation rules are different by usage, which makes it hard for users to predict what will happen.  4. The fields are both imprecise and overly precise.  Kind is not a precise mapping to a URL. This can produce ambiguity     during interpretation and require a REST mapping.  In most cases, the dependency is on the group,resource tuple     and the version of the actual struct is irrelevant.  5. We cannot easily change it.  Because this type is embedded in many locations, updates to this type     will affect numerous schemas.  Don't make new APIs embed an underspecified API type they do not control. Instead of using this type, create a locally provided and used type that is well-focused on your reference. For example, ServiceReferences for admission registration: https://github.com/kubernetes/api/blob/release-1.17/admissionregistration/v1/types.go#L533 .
             */
            hooksecretref?: outputs.apps.v1.SubscriptionSpecHooksecretref;
            /**
             * To specify 1 package in channel
             */
            name?: string;
            /**
             * for hub use only to specify the overrides when apply to clusters
             */
            overrides?: outputs.apps.v1.SubscriptionSpecOverrides[];
            /**
             * To specify more than 1 package in channel
             */
            packageFilter?: outputs.apps.v1.SubscriptionSpecPackageFilter;
            /**
             * To provide flexibility to override package in channel with local input
             */
            packageOverrides?: outputs.apps.v1.SubscriptionSpecPackageOverrides[];
            /**
             * For hub use only, to specify which clusters to go to
             */
            placement?: outputs.apps.v1.SubscriptionSpecPlacement;
            /**
             * help user control when the subscription will take affect
             */
            timewindow?: outputs.apps.v1.SubscriptionSpecTimewindow;
        }

        /**
         * ObjectReference contains enough information to let you inspect or modify the referred object. --- New uses of this type are discouraged because of difficulty describing its usage when embedded in APIs.  1. Ignored fields.  It includes many fields which are not generally honored.  For instance, ResourceVersion and FieldPath are both very rarely valid in actual usage.  2. Invalid usage help.  It is impossible to add specific help for individual usage.  In most embedded usages, there are particular     restrictions like, "must refer only to types A and B" or "UID not honored" or "name must be restricted".     Those cannot be well described when embedded.  3. Inconsistent validation.  Because the usages are different, the validation rules are different by usage, which makes it hard for users to predict what will happen.  4. The fields are both imprecise and overly precise.  Kind is not a precise mapping to a URL. This can produce ambiguity     during interpretation and require a REST mapping.  In most cases, the dependency is on the group,resource tuple     and the version of the actual struct is irrelevant.  5. We cannot easily change it.  Because this type is embedded in many locations, updates to this type     will affect numerous schemas.  Don't make new APIs embed an underspecified API type they do not control. Instead of using this type, create a locally provided and used type that is well-focused on your reference. For example, ServiceReferences for admission registration: https://github.com/kubernetes/api/blob/release-1.17/admissionregistration/v1/types.go#L533 .
         */
        export interface SubscriptionSpecHooksecretref {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * Overrides field in deployable
         */
        export interface SubscriptionSpecOverrides {
            clusterName: string;
            clusterOverrides: {[key: string]: any}[];
        }

        /**
         * To specify more than 1 package in channel
         */
        export interface SubscriptionSpecPackageFilter {
            annotations?: {[key: string]: string};
            /**
             * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
             */
            filterRef?: outputs.apps.v1.SubscriptionSpecPackageFilterFilterRef;
            /**
             * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
             */
            labelSelector?: outputs.apps.v1.SubscriptionSpecPackageFilterLabelSelector;
            version?: string;
        }

        /**
         * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
         */
        export interface SubscriptionSpecPackageFilterFilterRef {
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
             */
            name?: string;
        }

        /**
         * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
         */
        export interface SubscriptionSpecPackageFilterLabelSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.apps.v1.SubscriptionSpecPackageFilterLabelSelectorMatchExpressions[];
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: {[key: string]: string};
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
         */
        export interface SubscriptionSpecPackageFilterLabelSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string;
            /**
             * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string;
            /**
             * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
             */
            values?: string[];
        }

        /**
         * Overrides field in deployable
         */
        export interface SubscriptionSpecPackageOverrides {
            packageAlias?: string;
            packageName: string;
            packageOverrides?: {[key: string]: any}[];
        }

        /**
         * For hub use only, to specify which clusters to go to
         */
        export interface SubscriptionSpecPlacement {
            /**
             * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
             */
            clusterSelector?: outputs.apps.v1.SubscriptionSpecPlacementClusterSelector;
            clusters?: outputs.apps.v1.SubscriptionSpecPlacementClusters[];
            local?: boolean;
            /**
             * ObjectReference contains enough information to let you inspect or modify the referred object.
             */
            placementRef?: outputs.apps.v1.SubscriptionSpecPlacementPlacementRef;
        }

        /**
         * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
         */
        export interface SubscriptionSpecPlacementClusterSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.apps.v1.SubscriptionSpecPlacementClusterSelectorMatchExpressions[];
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: {[key: string]: string};
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
         */
        export interface SubscriptionSpecPlacementClusterSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string;
            /**
             * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string;
            /**
             * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
             */
            values?: string[];
        }

        /**
         * GenericClusterReference - in alignment with kubefed
         */
        export interface SubscriptionSpecPlacementClusters {
            name: string;
        }

        /**
         * ObjectReference contains enough information to let you inspect or modify the referred object.
         */
        export interface SubscriptionSpecPlacementPlacementRef {
            /**
             * API version of the referent.
             */
            apiVersion?: string;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: string;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
             */
            kind?: string;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: string;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: string;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: string;
        }

        /**
         * help user control when the subscription will take affect
         */
        export interface SubscriptionSpecTimewindow {
            /**
             * weekdays defined the day of the week for this time window https://golang.org/pkg/time/#Weekday
             */
            daysofweek?: string[];
            hours?: outputs.apps.v1.SubscriptionSpecTimewindowHours[];
            /**
             * https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
             */
            location?: string;
            /**
             * active time window or not, if timewindow is active, then deploy will only applies during these windows Note, if you want to generation crd with operator-sdk v0.10.0, then the following line should be: <+kubebuilder:validation:Enum=active,blocked,Active,Blocked>
             */
            windowtype?: string;
        }

        /**
         * HourRange time format for each time will be Kitchen format, defined at https://golang.org/pkg/time/#pkg-constants
         */
        export interface SubscriptionSpecTimewindowHours {
            end?: string;
            start?: string;
        }

        /**
         * SubscriptionStatus defines the observed state of Subscription Examples - status of a subscription on hub Status: 	phase: Propagated 	statuses: 	  washdc: 		packages: 		  nginx: 			phase: Subscribed 		  mongodb: 			phase: Failed 			Reason: "not authorized" 			Message: "user xxx does not have permission to start pod" 			resourceStatus: {}    toronto: 		packages: 		  nginx: 			phase: Subscribed 		  mongodb: 			phase: Subscribed Status of a subscription on managed cluster will only have 1 cluster in the map.
         */
        export interface SubscriptionStatus {
            ansiblejobs?: outputs.apps.v1.SubscriptionStatusAnsiblejobs;
            lastUpdateTime?: string;
            message?: string;
            /**
             * INSERT ADDITIONAL STATUS FIELD - define observed state of cluster Important: Run "make" to regenerate code after modifying this file
             */
            phase?: string;
            reason?: string;
            /**
             * For endpoint, it is the status of subscription, key is packagename, For hub, it aggregates all status, key is cluster name
             */
            statuses?: {[key: string]: outputs.apps.v1.SubscriptionStatusStatuses};
        }

        export interface SubscriptionStatusAnsiblejobs {
            lastposthookjob?: string;
            lastprehookjob?: string;
            posthookjobshistory?: string[];
            prehookjobshistory?: string[];
        }

        /**
         * SubscriptionPerClusterStatus defines status for subscription in each cluster, key is package name
         */
        export interface SubscriptionStatusStatuses {
            packages?: {[key: string]: outputs.apps.v1.SubscriptionStatusStatusesPackages};
        }

        /**
         * SubscriptionUnitStatus defines status of a unit (subscription or package)
         */
        export interface SubscriptionStatusStatusesPackages {
            lastUpdateTime: string;
            message?: string;
            /**
             * Phase are Propagated if it is in hub or Subscribed if it is in endpoint
             */
            phase?: string;
            reason?: string;
            resourceStatus?: {[key: string]: any};
        }

    }
}
