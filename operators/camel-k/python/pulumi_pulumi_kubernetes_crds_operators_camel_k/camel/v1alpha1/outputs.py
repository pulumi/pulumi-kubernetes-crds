# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from ... import _utilities, _tables
from . import outputs

__all__ = [
    'KameletBindingSpec',
    'KameletBindingSpecIntegration',
    'KameletBindingSpecIntegrationConfiguration',
    'KameletBindingSpecIntegrationResources',
    'KameletBindingSpecIntegrationSources',
    'KameletBindingSpecIntegrationTraits',
    'KameletBindingSpecSink',
    'KameletBindingSpecSinkRef',
    'KameletBindingSpecSource',
    'KameletBindingSpecSourceRef',
    'KameletBindingStatus',
    'KameletBindingStatusConditions',
    'KameletSpec',
    'KameletSpecDefinition',
    'KameletSpecDefinitionExternalDocs',
    'KameletSpecSources',
    'KameletSpecTypes',
    'KameletSpecTypesSchema',
    'KameletSpecTypesSchemaExternalDocs',
    'KameletStatus',
    'KameletStatusConditions',
    'KameletStatusProperties',
]

@pulumi.output_type
class KameletBindingSpec(dict):
    """
    KameletBindingSpec --
    """
    def __init__(__self__, *,
                 integration: Optional['outputs.KameletBindingSpecIntegration'] = None,
                 sink: Optional['outputs.KameletBindingSpecSink'] = None,
                 source: Optional['outputs.KameletBindingSpecSource'] = None):
        """
        KameletBindingSpec --
        :param 'KameletBindingSpecIntegrationArgs' integration: Integration is an optional integration used to specify custom parameters
        :param 'KameletBindingSpecSinkArgs' sink: Sink is the destination of the integration defined by this binding
        :param 'KameletBindingSpecSourceArgs' source: Source is the starting point of the integration defined by this binding
        """
        if integration is not None:
            pulumi.set(__self__, "integration", integration)
        if sink is not None:
            pulumi.set(__self__, "sink", sink)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter
    def integration(self) -> Optional['outputs.KameletBindingSpecIntegration']:
        """
        Integration is an optional integration used to specify custom parameters
        """
        return pulumi.get(self, "integration")

    @property
    @pulumi.getter
    def sink(self) -> Optional['outputs.KameletBindingSpecSink']:
        """
        Sink is the destination of the integration defined by this binding
        """
        return pulumi.get(self, "sink")

    @property
    @pulumi.getter
    def source(self) -> Optional['outputs.KameletBindingSpecSource']:
        """
        Source is the starting point of the integration defined by this binding
        """
        return pulumi.get(self, "source")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KameletBindingSpecIntegration(dict):
    """
    Integration is an optional integration used to specify custom parameters
    """
    def __init__(__self__, *,
                 configuration: Optional[Sequence['outputs.KameletBindingSpecIntegrationConfiguration']] = None,
                 dependencies: Optional[Sequence[str]] = None,
                 flows: Optional[Sequence[Mapping[str, Any]]] = None,
                 kit: Optional[str] = None,
                 profile: Optional[str] = None,
                 replicas: Optional[int] = None,
                 repositories: Optional[Sequence[str]] = None,
                 resources: Optional[Sequence['outputs.KameletBindingSpecIntegrationResources']] = None,
                 service_account_name: Optional[str] = None,
                 sources: Optional[Sequence['outputs.KameletBindingSpecIntegrationSources']] = None,
                 traits: Optional[Mapping[str, 'outputs.KameletBindingSpecIntegrationTraits']] = None):
        """
        Integration is an optional integration used to specify custom parameters
        :param str profile: TraitProfile represents lists of traits that are enabled for the specific installation/integration
        """
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if dependencies is not None:
            pulumi.set(__self__, "dependencies", dependencies)
        if flows is not None:
            pulumi.set(__self__, "flows", flows)
        if kit is not None:
            pulumi.set(__self__, "kit", kit)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if repositories is not None:
            pulumi.set(__self__, "repositories", repositories)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if service_account_name is not None:
            pulumi.set(__self__, "service_account_name", service_account_name)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)
        if traits is not None:
            pulumi.set(__self__, "traits", traits)

    @property
    @pulumi.getter
    def configuration(self) -> Optional[Sequence['outputs.KameletBindingSpecIntegrationConfiguration']]:
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter
    def dependencies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "dependencies")

    @property
    @pulumi.getter
    def flows(self) -> Optional[Sequence[Mapping[str, Any]]]:
        return pulumi.get(self, "flows")

    @property
    @pulumi.getter
    def kit(self) -> Optional[str]:
        return pulumi.get(self, "kit")

    @property
    @pulumi.getter
    def profile(self) -> Optional[str]:
        """
        TraitProfile represents lists of traits that are enabled for the specific installation/integration
        """
        return pulumi.get(self, "profile")

    @property
    @pulumi.getter
    def replicas(self) -> Optional[int]:
        return pulumi.get(self, "replicas")

    @property
    @pulumi.getter
    def repositories(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "repositories")

    @property
    @pulumi.getter
    def resources(self) -> Optional[Sequence['outputs.KameletBindingSpecIntegrationResources']]:
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter(name="serviceAccountName")
    def service_account_name(self) -> Optional[str]:
        return pulumi.get(self, "service_account_name")

    @property
    @pulumi.getter
    def sources(self) -> Optional[Sequence['outputs.KameletBindingSpecIntegrationSources']]:
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def traits(self) -> Optional[Mapping[str, 'outputs.KameletBindingSpecIntegrationTraits']]:
        return pulumi.get(self, "traits")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KameletBindingSpecIntegrationConfiguration(dict):
    """
    ConfigurationSpec --
    """
    def __init__(__self__, *,
                 type: str,
                 value: str):
        """
        ConfigurationSpec --
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KameletBindingSpecIntegrationResources(dict):
    """
    ResourceSpec --
    """
    def __init__(__self__, *,
                 compression: Optional[bool] = None,
                 content: Optional[str] = None,
                 content_key: Optional[str] = None,
                 content_ref: Optional[str] = None,
                 mount_path: Optional[str] = None,
                 name: Optional[str] = None,
                 type: Optional[str] = None):
        """
        ResourceSpec --
        :param str type: ResourceType --
        """
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if content_key is not None:
            pulumi.set(__self__, "content_key", content_key)
        if content_ref is not None:
            pulumi.set(__self__, "content_ref", content_ref)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def compression(self) -> Optional[bool]:
        return pulumi.get(self, "compression")

    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="contentKey")
    def content_key(self) -> Optional[str]:
        return pulumi.get(self, "content_key")

    @property
    @pulumi.getter(name="contentRef")
    def content_ref(self) -> Optional[str]:
        return pulumi.get(self, "content_ref")

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[str]:
        return pulumi.get(self, "mount_path")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        ResourceType --
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KameletBindingSpecIntegrationSources(dict):
    """
    SourceSpec --
    """
    def __init__(__self__, *,
                 compression: Optional[bool] = None,
                 content: Optional[str] = None,
                 content_key: Optional[str] = None,
                 content_ref: Optional[str] = None,
                 interceptors: Optional[Sequence[str]] = None,
                 language: Optional[str] = None,
                 loader: Optional[str] = None,
                 name: Optional[str] = None,
                 property_names: Optional[Sequence[str]] = None,
                 type: Optional[str] = None):
        """
        SourceSpec --
        :param Sequence[str] interceptors: Interceptors are optional identifiers the org.apache.camel.k.RoutesLoader uses to pre/post process sources
        :param str language: Language --
        :param str loader: Loader is an optional id of the org.apache.camel.k.RoutesLoader that will interpret this source at runtime
        :param Sequence[str] property_names: List of property names defined in the source (e.g. if type is "template")
        :param str type: Type defines the kind of source described by this object
        """
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if content_key is not None:
            pulumi.set(__self__, "content_key", content_key)
        if content_ref is not None:
            pulumi.set(__self__, "content_ref", content_ref)
        if interceptors is not None:
            pulumi.set(__self__, "interceptors", interceptors)
        if language is not None:
            pulumi.set(__self__, "language", language)
        if loader is not None:
            pulumi.set(__self__, "loader", loader)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if property_names is not None:
            pulumi.set(__self__, "property_names", property_names)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def compression(self) -> Optional[bool]:
        return pulumi.get(self, "compression")

    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="contentKey")
    def content_key(self) -> Optional[str]:
        return pulumi.get(self, "content_key")

    @property
    @pulumi.getter(name="contentRef")
    def content_ref(self) -> Optional[str]:
        return pulumi.get(self, "content_ref")

    @property
    @pulumi.getter
    def interceptors(self) -> Optional[Sequence[str]]:
        """
        Interceptors are optional identifiers the org.apache.camel.k.RoutesLoader uses to pre/post process sources
        """
        return pulumi.get(self, "interceptors")

    @property
    @pulumi.getter
    def language(self) -> Optional[str]:
        """
        Language --
        """
        return pulumi.get(self, "language")

    @property
    @pulumi.getter
    def loader(self) -> Optional[str]:
        """
        Loader is an optional id of the org.apache.camel.k.RoutesLoader that will interpret this source at runtime
        """
        return pulumi.get(self, "loader")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="property-names")
    def property_names(self) -> Optional[Sequence[str]]:
        """
        List of property names defined in the source (e.g. if type is "template")
        """
        return pulumi.get(self, "property_names")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type defines the kind of source described by this object
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KameletBindingSpecIntegrationTraits(dict):
    """
    A TraitSpec contains the configuration of a trait
    """
    def __init__(__self__, *,
                 configuration: Mapping[str, Any]):
        """
        A TraitSpec contains the configuration of a trait
        """
        pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def configuration(self) -> Mapping[str, Any]:
        return pulumi.get(self, "configuration")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KameletBindingSpecSink(dict):
    """
    Sink is the destination of the integration defined by this binding
    """
    def __init__(__self__, *,
                 properties: Optional[Mapping[str, Any]] = None,
                 ref: Optional['outputs.KameletBindingSpecSinkRef'] = None,
                 uri: Optional[str] = None):
        """
        Sink is the destination of the integration defined by this binding
        :param Mapping[str, Any] properties: Properties are a key value representation of endpoint properties
        :param 'KameletBindingSpecSinkRefArgs' ref: Ref can be used to declare a Kubernetes resource as source/sink endpoint
        :param str uri: URI can alternatively be used to specify the (Camel) endpoint explicitly
        """
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if ref is not None:
            pulumi.set(__self__, "ref", ref)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, Any]]:
        """
        Properties are a key value representation of endpoint properties
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def ref(self) -> Optional['outputs.KameletBindingSpecSinkRef']:
        """
        Ref can be used to declare a Kubernetes resource as source/sink endpoint
        """
        return pulumi.get(self, "ref")

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        """
        URI can alternatively be used to specify the (Camel) endpoint explicitly
        """
        return pulumi.get(self, "uri")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KameletBindingSpecSinkRef(dict):
    """
    Ref can be used to declare a Kubernetes resource as source/sink endpoint
    """
    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 resource_version: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        Ref can be used to declare a Kubernetes resource as source/sink endpoint
        :param str api_version: API version of the referent.
        :param str field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param str kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param str resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param str uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[str]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KameletBindingSpecSource(dict):
    """
    Source is the starting point of the integration defined by this binding
    """
    def __init__(__self__, *,
                 properties: Optional[Mapping[str, Any]] = None,
                 ref: Optional['outputs.KameletBindingSpecSourceRef'] = None,
                 uri: Optional[str] = None):
        """
        Source is the starting point of the integration defined by this binding
        :param Mapping[str, Any] properties: Properties are a key value representation of endpoint properties
        :param 'KameletBindingSpecSourceRefArgs' ref: Ref can be used to declare a Kubernetes resource as source/sink endpoint
        :param str uri: URI can alternatively be used to specify the (Camel) endpoint explicitly
        """
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if ref is not None:
            pulumi.set(__self__, "ref", ref)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, Any]]:
        """
        Properties are a key value representation of endpoint properties
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def ref(self) -> Optional['outputs.KameletBindingSpecSourceRef']:
        """
        Ref can be used to declare a Kubernetes resource as source/sink endpoint
        """
        return pulumi.get(self, "ref")

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        """
        URI can alternatively be used to specify the (Camel) endpoint explicitly
        """
        return pulumi.get(self, "uri")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KameletBindingSpecSourceRef(dict):
    """
    Ref can be used to declare a Kubernetes resource as source/sink endpoint
    """
    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 resource_version: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        Ref can be used to declare a Kubernetes resource as source/sink endpoint
        :param str api_version: API version of the referent.
        :param str field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param str kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param str resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param str uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[str]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KameletBindingStatus(dict):
    """
    KameletBindingStatus --
    """
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.KameletBindingStatusConditions']] = None,
                 phase: Optional[str] = None):
        """
        KameletBindingStatus --
        :param Sequence['KameletBindingStatusConditionsArgs'] conditions: Conditions --
        :param str phase: Phase --
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.KameletBindingStatusConditions']]:
        """
        Conditions --
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def phase(self) -> Optional[str]:
        """
        Phase --
        """
        return pulumi.get(self, "phase")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KameletBindingStatusConditions(dict):
    """
    KameletBindingCondition describes the state of a resource at a certain point.
    """
    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 last_update_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None):
        """
        KameletBindingCondition describes the state of a resource at a certain point.
        :param str status: Status of the condition, one of True, False, Unknown.
        :param str type: Type of kameletBinding condition.
        :param str last_transition_time: Last time the condition transitioned from one status to another.
        :param str last_update_time: The last time this condition was updated.
        :param str message: A human readable message indicating details about the transition.
        :param str reason: The reason for the condition's last transition.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if last_update_time is not None:
            pulumi.set(__self__, "last_update_time", last_update_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of kameletBinding condition.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        Last time the condition transitioned from one status to another.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter(name="lastUpdateTime")
    def last_update_time(self) -> Optional[str]:
        """
        The last time this condition was updated.
        """
        return pulumi.get(self, "last_update_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        A human readable message indicating details about the transition.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        The reason for the condition's last transition.
        """
        return pulumi.get(self, "reason")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KameletSpec(dict):
    """
    KameletSpec defines the desired state of Kamelet
    """
    def __init__(__self__, *,
                 authorization: Optional[Mapping[str, Any]] = None,
                 definition: Optional['outputs.KameletSpecDefinition'] = None,
                 dependencies: Optional[Sequence[str]] = None,
                 flow: Optional[Mapping[str, Any]] = None,
                 sources: Optional[Sequence['outputs.KameletSpecSources']] = None,
                 types: Optional[Mapping[str, 'outputs.KameletSpecTypes']] = None):
        """
        KameletSpec defines the desired state of Kamelet
        :param Mapping[str, Any] authorization: AuthorizationSpec is TODO (oauth information)
        :param 'KameletSpecDefinitionArgs' definition: JSONSchemaProps is a JSON-Schema definition.
        """
        if authorization is not None:
            pulumi.set(__self__, "authorization", authorization)
        if definition is not None:
            pulumi.set(__self__, "definition", definition)
        if dependencies is not None:
            pulumi.set(__self__, "dependencies", dependencies)
        if flow is not None:
            pulumi.set(__self__, "flow", flow)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)
        if types is not None:
            pulumi.set(__self__, "types", types)

    @property
    @pulumi.getter
    def authorization(self) -> Optional[Mapping[str, Any]]:
        """
        AuthorizationSpec is TODO (oauth information)
        """
        return pulumi.get(self, "authorization")

    @property
    @pulumi.getter
    def definition(self) -> Optional['outputs.KameletSpecDefinition']:
        """
        JSONSchemaProps is a JSON-Schema definition.
        """
        return pulumi.get(self, "definition")

    @property
    @pulumi.getter
    def dependencies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "dependencies")

    @property
    @pulumi.getter
    def flow(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "flow")

    @property
    @pulumi.getter
    def sources(self) -> Optional[Sequence['outputs.KameletSpecSources']]:
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def types(self) -> Optional[Mapping[str, 'outputs.KameletSpecTypes']]:
        return pulumi.get(self, "types")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KameletSpecDefinition(dict):
    """
    JSONSchemaProps is a JSON-Schema definition.
    """
    def __init__(__self__, *,
                 _ref: Optional[str] = None,
                 _schema: Optional[str] = None,
                 additional_items: Optional[bool] = None,
                 additional_properties: Optional[bool] = None,
                 all_of: Optional[Sequence[Any]] = None,
                 any_of: Optional[Sequence[Any]] = None,
                 default: Optional[Any] = None,
                 definitions: Optional[Mapping[str, Any]] = None,
                 dependencies: Optional[Mapping[str, Sequence[str]]] = None,
                 description: Optional[str] = None,
                 enum: Optional[Sequence[Any]] = None,
                 example: Optional[Any] = None,
                 exclusive_maximum: Optional[bool] = None,
                 exclusive_minimum: Optional[bool] = None,
                 external_docs: Optional['outputs.KameletSpecDefinitionExternalDocs'] = None,
                 format: Optional[str] = None,
                 id: Optional[str] = None,
                 items: Optional[Any] = None,
                 max_items: Optional[int] = None,
                 max_length: Optional[int] = None,
                 max_properties: Optional[int] = None,
                 maximum: Optional[str] = None,
                 min_items: Optional[int] = None,
                 min_length: Optional[int] = None,
                 min_properties: Optional[int] = None,
                 minimum: Optional[str] = None,
                 multiple_of: Optional[str] = None,
                 not_: Optional[Any] = None,
                 nullable: Optional[bool] = None,
                 one_of: Optional[Sequence[Any]] = None,
                 pattern: Optional[str] = None,
                 pattern_properties: Optional[Mapping[str, Any]] = None,
                 properties: Optional[Mapping[str, Any]] = None,
                 required: Optional[Sequence[str]] = None,
                 title: Optional[str] = None,
                 type: Optional[str] = None,
                 unique_items: Optional[bool] = None,
                 x_descriptors: Optional[Sequence[str]] = None,
                 x_kubernetes_embedded_resource: Optional[bool] = None,
                 x_kubernetes_int_or_string: Optional[bool] = None,
                 x_kubernetes_list_map_keys: Optional[Sequence[str]] = None,
                 x_kubernetes_list_type: Optional[str] = None,
                 x_kubernetes_map_type: Optional[str] = None,
                 x_kubernetes_preserve_unknown_fields: Optional[bool] = None):
        """
        JSONSchemaProps is a JSON-Schema definition.
        :param str _schema: JSONSchemaURL represents a schema url.
        :param Any default: default is a default value for undefined object fields. Defaulting is a beta feature under the CustomResourceDefaulting feature gate. Defaulting requires spec.preserveUnknownFields to be false.
        :param Mapping[str, Any] definitions: JSONSchemaDefinitions contains the models explicitly defined in this spec.
        :param Mapping[str, Sequence[str]] dependencies: JSONSchemaDependencies represent a dependencies property.
        :param 'KameletSpecDefinitionExternalDocsArgs' external_docs: ExternalDocumentation allows referencing an external resource for extended documentation.
        :param str format: format is an OpenAPI v3 format string. Unknown formats are ignored. The following formats are validated: 
                - bsonobjectid: a bson object ID, i.e. a 24 characters hex string - uri: an URI as parsed by Golang net/url.ParseRequestURI - email: an email address as parsed by Golang net/mail.ParseAddress - hostname: a valid representation for an Internet host name, as defined by RFC 1034, section 3.1 [RFC1034]. - ipv4: an IPv4 IP as parsed by Golang net.ParseIP - ipv6: an IPv6 IP as parsed by Golang net.ParseIP - cidr: a CIDR as parsed by Golang net.ParseCIDR - mac: a MAC address as parsed by Golang net.ParseMAC - uuid: an UUID that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{12}$ - uuid3: an UUID3 that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?3[0-9a-f]{3}-?[0-9a-f]{4}-?[0-9a-f]{12}$ - uuid4: an UUID4 that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?4[0-9a-f]{3}-?[89ab][0-9a-f]{3}-?[0-9a-f]{12}$ - uuid5: an UUID5 that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?5[0-9a-f]{3}-?[89ab][0-9a-f]{3}-?[0-9a-f]{12}$ - isbn: an ISBN10 or ISBN13 number string like "0321751043" or "978-0321751041" - isbn10: an ISBN10 number string like "0321751043" - isbn13: an ISBN13 number string like "978-0321751041" - creditcard: a credit card number defined by the regex ^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\\d{3})\\d{11})$ with any non digit characters mixed in - ssn: a U.S. social security number following the regex ^\\d{3}[- ]?\\d{2}[- ]?\\d{4}$ - hexcolor: an hexadecimal color code like "#FFFFFF: following the regex ^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$ - rgbcolor: an RGB color code like rgb like "rgb(255,255,2559" - byte: base64 encoded binary data - password: any kind of string - date: a date string like "2006-01-02" as defined by full-date in RFC3339 - duration: a duration string like "22 ns" as parsed by Golang time.ParseDuration or compatible with Scala duration format - datetime: a date time string like "2014-12-15T19:30:20.000Z" as defined by date-time in RFC3339.
        :param str maximum: A Number represents a JSON number literal.
        :param str minimum: A Number represents a JSON number literal.
        :param str multiple_of: A Number represents a JSON number literal.
        :param Sequence[str] x_descriptors: x-descriptors annotates an object to define additional display options.
        :param bool x_kubernetes_embedded_resource: x-kubernetes-embedded-resource defines that the value is an embedded Kubernetes runtime.Object, with TypeMeta and ObjectMeta. The type must be object. It is allowed to further restrict the embedded object. kind, apiVersion and metadata are validated automatically. x-kubernetes-preserve-unknown-fields is allowed to be true, but does not have to be if the object is fully specified (up to kind, apiVersion, metadata).
        :param bool x_kubernetes_int_or_string: x-kubernetes-int-or-string specifies that this value is either an integer or a string. If this is true, an empty type is allowed and type as child of anyOf is permitted if following one of the following patterns: 
                1) anyOf:    - type: integer    - type: string 2) allOf:    - anyOf:      - type: integer      - type: string    - ... zero or more
        :param Sequence[str] x_kubernetes_list_map_keys: x-kubernetes-list-map-keys annotates an array with the x-kubernetes-list-type `map` by specifying the keys used as the index of the map. 
                This tag MUST only be used on lists that have the "x-kubernetes-list-type" extension set to "map". Also, the values specified for this attribute must be a scalar typed field of the child structure (no nesting is supported). 
                The properties specified must either be required or have a default value, to ensure those properties are present for all list items.
        :param str x_kubernetes_list_type: x-kubernetes-list-type annotates an array to further describe its topology. This extension must only be used on lists and may have 3 possible values: 
                1) `atomic`: the list is treated as a single entity, like a scalar.      Atomic lists will be entirely replaced when updated. This extension      may be used on any type of list (struct, scalar, ...). 2) `set`:      Sets are lists that must not have multiple items with the same value. Each      value must be a scalar, an object with x-kubernetes-map-type `atomic` or an      array with x-kubernetes-list-type `atomic`. 3) `map`:      These lists are like maps in that their elements have a non-index key      used to identify them. Order is preserved upon merge. The map tag      must only be used on a list with elements of type object. Defaults to atomic for arrays.
        :param str x_kubernetes_map_type: x-kubernetes-map-type annotates an object to further describe its topology. This extension must only be used when type is object and may have 2 possible values: 
                1) `granular`:      These maps are actual maps (key-value pairs) and each fields are independent      from each other (they can each be manipulated by separate actors). This is      the default behaviour for all maps. 2) `atomic`: the list is treated as a single entity, like a scalar.      Atomic maps will be entirely replaced when updated.
        :param bool x_kubernetes_preserve_unknown_fields: x-kubernetes-preserve-unknown-fields stops the API server decoding step from pruning fields which are not specified in the validation schema. This affects fields recursively, but switches back to normal pruning behaviour if nested properties or additionalProperties are specified in the schema. This can either be true or undefined. False is forbidden.
        """
        if _ref is not None:
            pulumi.set(__self__, "_ref", _ref)
        if _schema is not None:
            pulumi.set(__self__, "_schema", _schema)
        if additional_items is not None:
            pulumi.set(__self__, "additional_items", additional_items)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)
        if all_of is not None:
            pulumi.set(__self__, "all_of", all_of)
        if any_of is not None:
            pulumi.set(__self__, "any_of", any_of)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if definitions is not None:
            pulumi.set(__self__, "definitions", definitions)
        if dependencies is not None:
            pulumi.set(__self__, "dependencies", dependencies)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enum is not None:
            pulumi.set(__self__, "enum", enum)
        if example is not None:
            pulumi.set(__self__, "example", example)
        if exclusive_maximum is not None:
            pulumi.set(__self__, "exclusive_maximum", exclusive_maximum)
        if exclusive_minimum is not None:
            pulumi.set(__self__, "exclusive_minimum", exclusive_minimum)
        if external_docs is not None:
            pulumi.set(__self__, "external_docs", external_docs)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if max_items is not None:
            pulumi.set(__self__, "max_items", max_items)
        if max_length is not None:
            pulumi.set(__self__, "max_length", max_length)
        if max_properties is not None:
            pulumi.set(__self__, "max_properties", max_properties)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if min_items is not None:
            pulumi.set(__self__, "min_items", min_items)
        if min_length is not None:
            pulumi.set(__self__, "min_length", min_length)
        if min_properties is not None:
            pulumi.set(__self__, "min_properties", min_properties)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)
        if multiple_of is not None:
            pulumi.set(__self__, "multiple_of", multiple_of)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if one_of is not None:
            pulumi.set(__self__, "one_of", one_of)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)
        if pattern_properties is not None:
            pulumi.set(__self__, "pattern_properties", pattern_properties)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unique_items is not None:
            pulumi.set(__self__, "unique_items", unique_items)
        if x_descriptors is not None:
            pulumi.set(__self__, "x_descriptors", x_descriptors)
        if x_kubernetes_embedded_resource is not None:
            pulumi.set(__self__, "x_kubernetes_embedded_resource", x_kubernetes_embedded_resource)
        if x_kubernetes_int_or_string is not None:
            pulumi.set(__self__, "x_kubernetes_int_or_string", x_kubernetes_int_or_string)
        if x_kubernetes_list_map_keys is not None:
            pulumi.set(__self__, "x_kubernetes_list_map_keys", x_kubernetes_list_map_keys)
        if x_kubernetes_list_type is not None:
            pulumi.set(__self__, "x_kubernetes_list_type", x_kubernetes_list_type)
        if x_kubernetes_map_type is not None:
            pulumi.set(__self__, "x_kubernetes_map_type", x_kubernetes_map_type)
        if x_kubernetes_preserve_unknown_fields is not None:
            pulumi.set(__self__, "x_kubernetes_preserve_unknown_fields", x_kubernetes_preserve_unknown_fields)

    @property
    @pulumi.getter(name="$ref")
    def _ref(self) -> Optional[str]:
        return pulumi.get(self, "_ref")

    @property
    @pulumi.getter(name="$schema")
    def _schema(self) -> Optional[str]:
        """
        JSONSchemaURL represents a schema url.
        """
        return pulumi.get(self, "_schema")

    @property
    @pulumi.getter(name="additionalItems")
    def additional_items(self) -> Optional[bool]:
        return pulumi.get(self, "additional_items")

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[bool]:
        return pulumi.get(self, "additional_properties")

    @property
    @pulumi.getter(name="allOf")
    def all_of(self) -> Optional[Sequence[Any]]:
        return pulumi.get(self, "all_of")

    @property
    @pulumi.getter(name="anyOf")
    def any_of(self) -> Optional[Sequence[Any]]:
        return pulumi.get(self, "any_of")

    @property
    @pulumi.getter
    def default(self) -> Optional[Any]:
        """
        default is a default value for undefined object fields. Defaulting is a beta feature under the CustomResourceDefaulting feature gate. Defaulting requires spec.preserveUnknownFields to be false.
        """
        return pulumi.get(self, "default")

    @property
    @pulumi.getter
    def definitions(self) -> Optional[Mapping[str, Any]]:
        """
        JSONSchemaDefinitions contains the models explicitly defined in this spec.
        """
        return pulumi.get(self, "definitions")

    @property
    @pulumi.getter
    def dependencies(self) -> Optional[Mapping[str, Sequence[str]]]:
        """
        JSONSchemaDependencies represent a dependencies property.
        """
        return pulumi.get(self, "dependencies")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def enum(self) -> Optional[Sequence[Any]]:
        return pulumi.get(self, "enum")

    @property
    @pulumi.getter
    def example(self) -> Optional[Any]:
        return pulumi.get(self, "example")

    @property
    @pulumi.getter(name="exclusiveMaximum")
    def exclusive_maximum(self) -> Optional[bool]:
        return pulumi.get(self, "exclusive_maximum")

    @property
    @pulumi.getter(name="exclusiveMinimum")
    def exclusive_minimum(self) -> Optional[bool]:
        return pulumi.get(self, "exclusive_minimum")

    @property
    @pulumi.getter(name="externalDocs")
    def external_docs(self) -> Optional['outputs.KameletSpecDefinitionExternalDocs']:
        """
        ExternalDocumentation allows referencing an external resource for extended documentation.
        """
        return pulumi.get(self, "external_docs")

    @property
    @pulumi.getter
    def format(self) -> Optional[str]:
        """
        format is an OpenAPI v3 format string. Unknown formats are ignored. The following formats are validated: 
         - bsonobjectid: a bson object ID, i.e. a 24 characters hex string - uri: an URI as parsed by Golang net/url.ParseRequestURI - email: an email address as parsed by Golang net/mail.ParseAddress - hostname: a valid representation for an Internet host name, as defined by RFC 1034, section 3.1 [RFC1034]. - ipv4: an IPv4 IP as parsed by Golang net.ParseIP - ipv6: an IPv6 IP as parsed by Golang net.ParseIP - cidr: a CIDR as parsed by Golang net.ParseCIDR - mac: a MAC address as parsed by Golang net.ParseMAC - uuid: an UUID that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{12}$ - uuid3: an UUID3 that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?3[0-9a-f]{3}-?[0-9a-f]{4}-?[0-9a-f]{12}$ - uuid4: an UUID4 that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?4[0-9a-f]{3}-?[89ab][0-9a-f]{3}-?[0-9a-f]{12}$ - uuid5: an UUID5 that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?5[0-9a-f]{3}-?[89ab][0-9a-f]{3}-?[0-9a-f]{12}$ - isbn: an ISBN10 or ISBN13 number string like "0321751043" or "978-0321751041" - isbn10: an ISBN10 number string like "0321751043" - isbn13: an ISBN13 number string like "978-0321751041" - creditcard: a credit card number defined by the regex ^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\\d{3})\\d{11})$ with any non digit characters mixed in - ssn: a U.S. social security number following the regex ^\\d{3}[- ]?\\d{2}[- ]?\\d{4}$ - hexcolor: an hexadecimal color code like "#FFFFFF: following the regex ^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$ - rgbcolor: an RGB color code like rgb like "rgb(255,255,2559" - byte: base64 encoded binary data - password: any kind of string - date: a date string like "2006-01-02" as defined by full-date in RFC3339 - duration: a duration string like "22 ns" as parsed by Golang time.ParseDuration or compatible with Scala duration format - datetime: a date time string like "2014-12-15T19:30:20.000Z" as defined by date-time in RFC3339.
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def items(self) -> Optional[Any]:
        return pulumi.get(self, "items")

    @property
    @pulumi.getter(name="maxItems")
    def max_items(self) -> Optional[int]:
        return pulumi.get(self, "max_items")

    @property
    @pulumi.getter(name="maxLength")
    def max_length(self) -> Optional[int]:
        return pulumi.get(self, "max_length")

    @property
    @pulumi.getter(name="maxProperties")
    def max_properties(self) -> Optional[int]:
        return pulumi.get(self, "max_properties")

    @property
    @pulumi.getter
    def maximum(self) -> Optional[str]:
        """
        A Number represents a JSON number literal.
        """
        return pulumi.get(self, "maximum")

    @property
    @pulumi.getter(name="minItems")
    def min_items(self) -> Optional[int]:
        return pulumi.get(self, "min_items")

    @property
    @pulumi.getter(name="minLength")
    def min_length(self) -> Optional[int]:
        return pulumi.get(self, "min_length")

    @property
    @pulumi.getter(name="minProperties")
    def min_properties(self) -> Optional[int]:
        return pulumi.get(self, "min_properties")

    @property
    @pulumi.getter
    def minimum(self) -> Optional[str]:
        """
        A Number represents a JSON number literal.
        """
        return pulumi.get(self, "minimum")

    @property
    @pulumi.getter(name="multipleOf")
    def multiple_of(self) -> Optional[str]:
        """
        A Number represents a JSON number literal.
        """
        return pulumi.get(self, "multiple_of")

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[Any]:
        return pulumi.get(self, "not_")

    @property
    @pulumi.getter
    def nullable(self) -> Optional[bool]:
        return pulumi.get(self, "nullable")

    @property
    @pulumi.getter(name="oneOf")
    def one_of(self) -> Optional[Sequence[Any]]:
        return pulumi.get(self, "one_of")

    @property
    @pulumi.getter
    def pattern(self) -> Optional[str]:
        return pulumi.get(self, "pattern")

    @property
    @pulumi.getter(name="patternProperties")
    def pattern_properties(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "pattern_properties")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def required(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "required")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="uniqueItems")
    def unique_items(self) -> Optional[bool]:
        return pulumi.get(self, "unique_items")

    @property
    @pulumi.getter(name="x-descriptors")
    def x_descriptors(self) -> Optional[Sequence[str]]:
        """
        x-descriptors annotates an object to define additional display options.
        """
        return pulumi.get(self, "x_descriptors")

    @property
    @pulumi.getter(name="x-kubernetes-embedded-resource")
    def x_kubernetes_embedded_resource(self) -> Optional[bool]:
        """
        x-kubernetes-embedded-resource defines that the value is an embedded Kubernetes runtime.Object, with TypeMeta and ObjectMeta. The type must be object. It is allowed to further restrict the embedded object. kind, apiVersion and metadata are validated automatically. x-kubernetes-preserve-unknown-fields is allowed to be true, but does not have to be if the object is fully specified (up to kind, apiVersion, metadata).
        """
        return pulumi.get(self, "x_kubernetes_embedded_resource")

    @property
    @pulumi.getter(name="x-kubernetes-int-or-string")
    def x_kubernetes_int_or_string(self) -> Optional[bool]:
        """
        x-kubernetes-int-or-string specifies that this value is either an integer or a string. If this is true, an empty type is allowed and type as child of anyOf is permitted if following one of the following patterns: 
         1) anyOf:    - type: integer    - type: string 2) allOf:    - anyOf:      - type: integer      - type: string    - ... zero or more
        """
        return pulumi.get(self, "x_kubernetes_int_or_string")

    @property
    @pulumi.getter(name="x-kubernetes-list-map-keys")
    def x_kubernetes_list_map_keys(self) -> Optional[Sequence[str]]:
        """
        x-kubernetes-list-map-keys annotates an array with the x-kubernetes-list-type `map` by specifying the keys used as the index of the map. 
         This tag MUST only be used on lists that have the "x-kubernetes-list-type" extension set to "map". Also, the values specified for this attribute must be a scalar typed field of the child structure (no nesting is supported). 
         The properties specified must either be required or have a default value, to ensure those properties are present for all list items.
        """
        return pulumi.get(self, "x_kubernetes_list_map_keys")

    @property
    @pulumi.getter(name="x-kubernetes-list-type")
    def x_kubernetes_list_type(self) -> Optional[str]:
        """
        x-kubernetes-list-type annotates an array to further describe its topology. This extension must only be used on lists and may have 3 possible values: 
         1) `atomic`: the list is treated as a single entity, like a scalar.      Atomic lists will be entirely replaced when updated. This extension      may be used on any type of list (struct, scalar, ...). 2) `set`:      Sets are lists that must not have multiple items with the same value. Each      value must be a scalar, an object with x-kubernetes-map-type `atomic` or an      array with x-kubernetes-list-type `atomic`. 3) `map`:      These lists are like maps in that their elements have a non-index key      used to identify them. Order is preserved upon merge. The map tag      must only be used on a list with elements of type object. Defaults to atomic for arrays.
        """
        return pulumi.get(self, "x_kubernetes_list_type")

    @property
    @pulumi.getter(name="x-kubernetes-map-type")
    def x_kubernetes_map_type(self) -> Optional[str]:
        """
        x-kubernetes-map-type annotates an object to further describe its topology. This extension must only be used when type is object and may have 2 possible values: 
         1) `granular`:      These maps are actual maps (key-value pairs) and each fields are independent      from each other (they can each be manipulated by separate actors). This is      the default behaviour for all maps. 2) `atomic`: the list is treated as a single entity, like a scalar.      Atomic maps will be entirely replaced when updated.
        """
        return pulumi.get(self, "x_kubernetes_map_type")

    @property
    @pulumi.getter(name="x-kubernetes-preserve-unknown-fields")
    def x_kubernetes_preserve_unknown_fields(self) -> Optional[bool]:
        """
        x-kubernetes-preserve-unknown-fields stops the API server decoding step from pruning fields which are not specified in the validation schema. This affects fields recursively, but switches back to normal pruning behaviour if nested properties or additionalProperties are specified in the schema. This can either be true or undefined. False is forbidden.
        """
        return pulumi.get(self, "x_kubernetes_preserve_unknown_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KameletSpecDefinitionExternalDocs(dict):
    """
    ExternalDocumentation allows referencing an external resource for extended documentation.
    """
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 url: Optional[str] = None):
        """
        ExternalDocumentation allows referencing an external resource for extended documentation.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        return pulumi.get(self, "url")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KameletSpecSources(dict):
    """
    SourceSpec --
    """
    def __init__(__self__, *,
                 compression: Optional[bool] = None,
                 content: Optional[str] = None,
                 content_key: Optional[str] = None,
                 content_ref: Optional[str] = None,
                 interceptors: Optional[Sequence[str]] = None,
                 language: Optional[str] = None,
                 loader: Optional[str] = None,
                 name: Optional[str] = None,
                 property_names: Optional[Sequence[str]] = None,
                 type: Optional[str] = None):
        """
        SourceSpec --
        :param Sequence[str] interceptors: Interceptors are optional identifiers the org.apache.camel.k.RoutesLoader uses to pre/post process sources
        :param str language: Language --
        :param str loader: Loader is an optional id of the org.apache.camel.k.RoutesLoader that will interpret this source at runtime
        :param Sequence[str] property_names: List of property names defined in the source (e.g. if type is "template")
        :param str type: Type defines the kind of source described by this object
        """
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if content_key is not None:
            pulumi.set(__self__, "content_key", content_key)
        if content_ref is not None:
            pulumi.set(__self__, "content_ref", content_ref)
        if interceptors is not None:
            pulumi.set(__self__, "interceptors", interceptors)
        if language is not None:
            pulumi.set(__self__, "language", language)
        if loader is not None:
            pulumi.set(__self__, "loader", loader)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if property_names is not None:
            pulumi.set(__self__, "property_names", property_names)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def compression(self) -> Optional[bool]:
        return pulumi.get(self, "compression")

    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="contentKey")
    def content_key(self) -> Optional[str]:
        return pulumi.get(self, "content_key")

    @property
    @pulumi.getter(name="contentRef")
    def content_ref(self) -> Optional[str]:
        return pulumi.get(self, "content_ref")

    @property
    @pulumi.getter
    def interceptors(self) -> Optional[Sequence[str]]:
        """
        Interceptors are optional identifiers the org.apache.camel.k.RoutesLoader uses to pre/post process sources
        """
        return pulumi.get(self, "interceptors")

    @property
    @pulumi.getter
    def language(self) -> Optional[str]:
        """
        Language --
        """
        return pulumi.get(self, "language")

    @property
    @pulumi.getter
    def loader(self) -> Optional[str]:
        """
        Loader is an optional id of the org.apache.camel.k.RoutesLoader that will interpret this source at runtime
        """
        return pulumi.get(self, "loader")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="property-names")
    def property_names(self) -> Optional[Sequence[str]]:
        """
        List of property names defined in the source (e.g. if type is "template")
        """
        return pulumi.get(self, "property_names")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type defines the kind of source described by this object
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KameletSpecTypes(dict):
    def __init__(__self__, *,
                 media_type: Optional[str] = None,
                 schema: Optional['outputs.KameletSpecTypesSchema'] = None):
        """
        :param 'KameletSpecTypesSchemaArgs' schema: JSONSchemaProps is a JSON-Schema definition.
        """
        if media_type is not None:
            pulumi.set(__self__, "media_type", media_type)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)

    @property
    @pulumi.getter(name="mediaType")
    def media_type(self) -> Optional[str]:
        return pulumi.get(self, "media_type")

    @property
    @pulumi.getter
    def schema(self) -> Optional['outputs.KameletSpecTypesSchema']:
        """
        JSONSchemaProps is a JSON-Schema definition.
        """
        return pulumi.get(self, "schema")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KameletSpecTypesSchema(dict):
    """
    JSONSchemaProps is a JSON-Schema definition.
    """
    def __init__(__self__, *,
                 _ref: Optional[str] = None,
                 _schema: Optional[str] = None,
                 additional_items: Optional[bool] = None,
                 additional_properties: Optional[bool] = None,
                 all_of: Optional[Sequence[Any]] = None,
                 any_of: Optional[Sequence[Any]] = None,
                 default: Optional[Any] = None,
                 definitions: Optional[Mapping[str, Any]] = None,
                 dependencies: Optional[Mapping[str, Sequence[str]]] = None,
                 description: Optional[str] = None,
                 enum: Optional[Sequence[Any]] = None,
                 example: Optional[Any] = None,
                 exclusive_maximum: Optional[bool] = None,
                 exclusive_minimum: Optional[bool] = None,
                 external_docs: Optional['outputs.KameletSpecTypesSchemaExternalDocs'] = None,
                 format: Optional[str] = None,
                 id: Optional[str] = None,
                 items: Optional[Any] = None,
                 max_items: Optional[int] = None,
                 max_length: Optional[int] = None,
                 max_properties: Optional[int] = None,
                 maximum: Optional[str] = None,
                 min_items: Optional[int] = None,
                 min_length: Optional[int] = None,
                 min_properties: Optional[int] = None,
                 minimum: Optional[str] = None,
                 multiple_of: Optional[str] = None,
                 not_: Optional[Any] = None,
                 nullable: Optional[bool] = None,
                 one_of: Optional[Sequence[Any]] = None,
                 pattern: Optional[str] = None,
                 pattern_properties: Optional[Mapping[str, Any]] = None,
                 properties: Optional[Mapping[str, Any]] = None,
                 required: Optional[Sequence[str]] = None,
                 title: Optional[str] = None,
                 type: Optional[str] = None,
                 unique_items: Optional[bool] = None,
                 x_descriptors: Optional[Sequence[str]] = None,
                 x_kubernetes_embedded_resource: Optional[bool] = None,
                 x_kubernetes_int_or_string: Optional[bool] = None,
                 x_kubernetes_list_map_keys: Optional[Sequence[str]] = None,
                 x_kubernetes_list_type: Optional[str] = None,
                 x_kubernetes_map_type: Optional[str] = None,
                 x_kubernetes_preserve_unknown_fields: Optional[bool] = None):
        """
        JSONSchemaProps is a JSON-Schema definition.
        :param str _schema: JSONSchemaURL represents a schema url.
        :param Any default: default is a default value for undefined object fields. Defaulting is a beta feature under the CustomResourceDefaulting feature gate. Defaulting requires spec.preserveUnknownFields to be false.
        :param Mapping[str, Any] definitions: JSONSchemaDefinitions contains the models explicitly defined in this spec.
        :param Mapping[str, Sequence[str]] dependencies: JSONSchemaDependencies represent a dependencies property.
        :param 'KameletSpecTypesSchemaExternalDocsArgs' external_docs: ExternalDocumentation allows referencing an external resource for extended documentation.
        :param str format: format is an OpenAPI v3 format string. Unknown formats are ignored. The following formats are validated: 
                - bsonobjectid: a bson object ID, i.e. a 24 characters hex string - uri: an URI as parsed by Golang net/url.ParseRequestURI - email: an email address as parsed by Golang net/mail.ParseAddress - hostname: a valid representation for an Internet host name, as defined by RFC 1034, section 3.1 [RFC1034]. - ipv4: an IPv4 IP as parsed by Golang net.ParseIP - ipv6: an IPv6 IP as parsed by Golang net.ParseIP - cidr: a CIDR as parsed by Golang net.ParseCIDR - mac: a MAC address as parsed by Golang net.ParseMAC - uuid: an UUID that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{12}$ - uuid3: an UUID3 that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?3[0-9a-f]{3}-?[0-9a-f]{4}-?[0-9a-f]{12}$ - uuid4: an UUID4 that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?4[0-9a-f]{3}-?[89ab][0-9a-f]{3}-?[0-9a-f]{12}$ - uuid5: an UUID5 that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?5[0-9a-f]{3}-?[89ab][0-9a-f]{3}-?[0-9a-f]{12}$ - isbn: an ISBN10 or ISBN13 number string like "0321751043" or "978-0321751041" - isbn10: an ISBN10 number string like "0321751043" - isbn13: an ISBN13 number string like "978-0321751041" - creditcard: a credit card number defined by the regex ^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\\d{3})\\d{11})$ with any non digit characters mixed in - ssn: a U.S. social security number following the regex ^\\d{3}[- ]?\\d{2}[- ]?\\d{4}$ - hexcolor: an hexadecimal color code like "#FFFFFF: following the regex ^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$ - rgbcolor: an RGB color code like rgb like "rgb(255,255,2559" - byte: base64 encoded binary data - password: any kind of string - date: a date string like "2006-01-02" as defined by full-date in RFC3339 - duration: a duration string like "22 ns" as parsed by Golang time.ParseDuration or compatible with Scala duration format - datetime: a date time string like "2014-12-15T19:30:20.000Z" as defined by date-time in RFC3339.
        :param str maximum: A Number represents a JSON number literal.
        :param str minimum: A Number represents a JSON number literal.
        :param str multiple_of: A Number represents a JSON number literal.
        :param Sequence[str] x_descriptors: x-descriptors annotates an object to define additional display options.
        :param bool x_kubernetes_embedded_resource: x-kubernetes-embedded-resource defines that the value is an embedded Kubernetes runtime.Object, with TypeMeta and ObjectMeta. The type must be object. It is allowed to further restrict the embedded object. kind, apiVersion and metadata are validated automatically. x-kubernetes-preserve-unknown-fields is allowed to be true, but does not have to be if the object is fully specified (up to kind, apiVersion, metadata).
        :param bool x_kubernetes_int_or_string: x-kubernetes-int-or-string specifies that this value is either an integer or a string. If this is true, an empty type is allowed and type as child of anyOf is permitted if following one of the following patterns: 
                1) anyOf:    - type: integer    - type: string 2) allOf:    - anyOf:      - type: integer      - type: string    - ... zero or more
        :param Sequence[str] x_kubernetes_list_map_keys: x-kubernetes-list-map-keys annotates an array with the x-kubernetes-list-type `map` by specifying the keys used as the index of the map. 
                This tag MUST only be used on lists that have the "x-kubernetes-list-type" extension set to "map". Also, the values specified for this attribute must be a scalar typed field of the child structure (no nesting is supported). 
                The properties specified must either be required or have a default value, to ensure those properties are present for all list items.
        :param str x_kubernetes_list_type: x-kubernetes-list-type annotates an array to further describe its topology. This extension must only be used on lists and may have 3 possible values: 
                1) `atomic`: the list is treated as a single entity, like a scalar.      Atomic lists will be entirely replaced when updated. This extension      may be used on any type of list (struct, scalar, ...). 2) `set`:      Sets are lists that must not have multiple items with the same value. Each      value must be a scalar, an object with x-kubernetes-map-type `atomic` or an      array with x-kubernetes-list-type `atomic`. 3) `map`:      These lists are like maps in that their elements have a non-index key      used to identify them. Order is preserved upon merge. The map tag      must only be used on a list with elements of type object. Defaults to atomic for arrays.
        :param str x_kubernetes_map_type: x-kubernetes-map-type annotates an object to further describe its topology. This extension must only be used when type is object and may have 2 possible values: 
                1) `granular`:      These maps are actual maps (key-value pairs) and each fields are independent      from each other (they can each be manipulated by separate actors). This is      the default behaviour for all maps. 2) `atomic`: the list is treated as a single entity, like a scalar.      Atomic maps will be entirely replaced when updated.
        :param bool x_kubernetes_preserve_unknown_fields: x-kubernetes-preserve-unknown-fields stops the API server decoding step from pruning fields which are not specified in the validation schema. This affects fields recursively, but switches back to normal pruning behaviour if nested properties or additionalProperties are specified in the schema. This can either be true or undefined. False is forbidden.
        """
        if _ref is not None:
            pulumi.set(__self__, "_ref", _ref)
        if _schema is not None:
            pulumi.set(__self__, "_schema", _schema)
        if additional_items is not None:
            pulumi.set(__self__, "additional_items", additional_items)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)
        if all_of is not None:
            pulumi.set(__self__, "all_of", all_of)
        if any_of is not None:
            pulumi.set(__self__, "any_of", any_of)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if definitions is not None:
            pulumi.set(__self__, "definitions", definitions)
        if dependencies is not None:
            pulumi.set(__self__, "dependencies", dependencies)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enum is not None:
            pulumi.set(__self__, "enum", enum)
        if example is not None:
            pulumi.set(__self__, "example", example)
        if exclusive_maximum is not None:
            pulumi.set(__self__, "exclusive_maximum", exclusive_maximum)
        if exclusive_minimum is not None:
            pulumi.set(__self__, "exclusive_minimum", exclusive_minimum)
        if external_docs is not None:
            pulumi.set(__self__, "external_docs", external_docs)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if max_items is not None:
            pulumi.set(__self__, "max_items", max_items)
        if max_length is not None:
            pulumi.set(__self__, "max_length", max_length)
        if max_properties is not None:
            pulumi.set(__self__, "max_properties", max_properties)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if min_items is not None:
            pulumi.set(__self__, "min_items", min_items)
        if min_length is not None:
            pulumi.set(__self__, "min_length", min_length)
        if min_properties is not None:
            pulumi.set(__self__, "min_properties", min_properties)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)
        if multiple_of is not None:
            pulumi.set(__self__, "multiple_of", multiple_of)
        if not_ is not None:
            pulumi.set(__self__, "not_", not_)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if one_of is not None:
            pulumi.set(__self__, "one_of", one_of)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)
        if pattern_properties is not None:
            pulumi.set(__self__, "pattern_properties", pattern_properties)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unique_items is not None:
            pulumi.set(__self__, "unique_items", unique_items)
        if x_descriptors is not None:
            pulumi.set(__self__, "x_descriptors", x_descriptors)
        if x_kubernetes_embedded_resource is not None:
            pulumi.set(__self__, "x_kubernetes_embedded_resource", x_kubernetes_embedded_resource)
        if x_kubernetes_int_or_string is not None:
            pulumi.set(__self__, "x_kubernetes_int_or_string", x_kubernetes_int_or_string)
        if x_kubernetes_list_map_keys is not None:
            pulumi.set(__self__, "x_kubernetes_list_map_keys", x_kubernetes_list_map_keys)
        if x_kubernetes_list_type is not None:
            pulumi.set(__self__, "x_kubernetes_list_type", x_kubernetes_list_type)
        if x_kubernetes_map_type is not None:
            pulumi.set(__self__, "x_kubernetes_map_type", x_kubernetes_map_type)
        if x_kubernetes_preserve_unknown_fields is not None:
            pulumi.set(__self__, "x_kubernetes_preserve_unknown_fields", x_kubernetes_preserve_unknown_fields)

    @property
    @pulumi.getter(name="$ref")
    def _ref(self) -> Optional[str]:
        return pulumi.get(self, "_ref")

    @property
    @pulumi.getter(name="$schema")
    def _schema(self) -> Optional[str]:
        """
        JSONSchemaURL represents a schema url.
        """
        return pulumi.get(self, "_schema")

    @property
    @pulumi.getter(name="additionalItems")
    def additional_items(self) -> Optional[bool]:
        return pulumi.get(self, "additional_items")

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[bool]:
        return pulumi.get(self, "additional_properties")

    @property
    @pulumi.getter(name="allOf")
    def all_of(self) -> Optional[Sequence[Any]]:
        return pulumi.get(self, "all_of")

    @property
    @pulumi.getter(name="anyOf")
    def any_of(self) -> Optional[Sequence[Any]]:
        return pulumi.get(self, "any_of")

    @property
    @pulumi.getter
    def default(self) -> Optional[Any]:
        """
        default is a default value for undefined object fields. Defaulting is a beta feature under the CustomResourceDefaulting feature gate. Defaulting requires spec.preserveUnknownFields to be false.
        """
        return pulumi.get(self, "default")

    @property
    @pulumi.getter
    def definitions(self) -> Optional[Mapping[str, Any]]:
        """
        JSONSchemaDefinitions contains the models explicitly defined in this spec.
        """
        return pulumi.get(self, "definitions")

    @property
    @pulumi.getter
    def dependencies(self) -> Optional[Mapping[str, Sequence[str]]]:
        """
        JSONSchemaDependencies represent a dependencies property.
        """
        return pulumi.get(self, "dependencies")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def enum(self) -> Optional[Sequence[Any]]:
        return pulumi.get(self, "enum")

    @property
    @pulumi.getter
    def example(self) -> Optional[Any]:
        return pulumi.get(self, "example")

    @property
    @pulumi.getter(name="exclusiveMaximum")
    def exclusive_maximum(self) -> Optional[bool]:
        return pulumi.get(self, "exclusive_maximum")

    @property
    @pulumi.getter(name="exclusiveMinimum")
    def exclusive_minimum(self) -> Optional[bool]:
        return pulumi.get(self, "exclusive_minimum")

    @property
    @pulumi.getter(name="externalDocs")
    def external_docs(self) -> Optional['outputs.KameletSpecTypesSchemaExternalDocs']:
        """
        ExternalDocumentation allows referencing an external resource for extended documentation.
        """
        return pulumi.get(self, "external_docs")

    @property
    @pulumi.getter
    def format(self) -> Optional[str]:
        """
        format is an OpenAPI v3 format string. Unknown formats are ignored. The following formats are validated: 
         - bsonobjectid: a bson object ID, i.e. a 24 characters hex string - uri: an URI as parsed by Golang net/url.ParseRequestURI - email: an email address as parsed by Golang net/mail.ParseAddress - hostname: a valid representation for an Internet host name, as defined by RFC 1034, section 3.1 [RFC1034]. - ipv4: an IPv4 IP as parsed by Golang net.ParseIP - ipv6: an IPv6 IP as parsed by Golang net.ParseIP - cidr: a CIDR as parsed by Golang net.ParseCIDR - mac: a MAC address as parsed by Golang net.ParseMAC - uuid: an UUID that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{12}$ - uuid3: an UUID3 that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?3[0-9a-f]{3}-?[0-9a-f]{4}-?[0-9a-f]{12}$ - uuid4: an UUID4 that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?4[0-9a-f]{3}-?[89ab][0-9a-f]{3}-?[0-9a-f]{12}$ - uuid5: an UUID5 that allows uppercase defined by the regex (?i)^[0-9a-f]{8}-?[0-9a-f]{4}-?5[0-9a-f]{3}-?[89ab][0-9a-f]{3}-?[0-9a-f]{12}$ - isbn: an ISBN10 or ISBN13 number string like "0321751043" or "978-0321751041" - isbn10: an ISBN10 number string like "0321751043" - isbn13: an ISBN13 number string like "978-0321751041" - creditcard: a credit card number defined by the regex ^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\\d{3})\\d{11})$ with any non digit characters mixed in - ssn: a U.S. social security number following the regex ^\\d{3}[- ]?\\d{2}[- ]?\\d{4}$ - hexcolor: an hexadecimal color code like "#FFFFFF: following the regex ^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$ - rgbcolor: an RGB color code like rgb like "rgb(255,255,2559" - byte: base64 encoded binary data - password: any kind of string - date: a date string like "2006-01-02" as defined by full-date in RFC3339 - duration: a duration string like "22 ns" as parsed by Golang time.ParseDuration or compatible with Scala duration format - datetime: a date time string like "2014-12-15T19:30:20.000Z" as defined by date-time in RFC3339.
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def items(self) -> Optional[Any]:
        return pulumi.get(self, "items")

    @property
    @pulumi.getter(name="maxItems")
    def max_items(self) -> Optional[int]:
        return pulumi.get(self, "max_items")

    @property
    @pulumi.getter(name="maxLength")
    def max_length(self) -> Optional[int]:
        return pulumi.get(self, "max_length")

    @property
    @pulumi.getter(name="maxProperties")
    def max_properties(self) -> Optional[int]:
        return pulumi.get(self, "max_properties")

    @property
    @pulumi.getter
    def maximum(self) -> Optional[str]:
        """
        A Number represents a JSON number literal.
        """
        return pulumi.get(self, "maximum")

    @property
    @pulumi.getter(name="minItems")
    def min_items(self) -> Optional[int]:
        return pulumi.get(self, "min_items")

    @property
    @pulumi.getter(name="minLength")
    def min_length(self) -> Optional[int]:
        return pulumi.get(self, "min_length")

    @property
    @pulumi.getter(name="minProperties")
    def min_properties(self) -> Optional[int]:
        return pulumi.get(self, "min_properties")

    @property
    @pulumi.getter
    def minimum(self) -> Optional[str]:
        """
        A Number represents a JSON number literal.
        """
        return pulumi.get(self, "minimum")

    @property
    @pulumi.getter(name="multipleOf")
    def multiple_of(self) -> Optional[str]:
        """
        A Number represents a JSON number literal.
        """
        return pulumi.get(self, "multiple_of")

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional[Any]:
        return pulumi.get(self, "not_")

    @property
    @pulumi.getter
    def nullable(self) -> Optional[bool]:
        return pulumi.get(self, "nullable")

    @property
    @pulumi.getter(name="oneOf")
    def one_of(self) -> Optional[Sequence[Any]]:
        return pulumi.get(self, "one_of")

    @property
    @pulumi.getter
    def pattern(self) -> Optional[str]:
        return pulumi.get(self, "pattern")

    @property
    @pulumi.getter(name="patternProperties")
    def pattern_properties(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "pattern_properties")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def required(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "required")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="uniqueItems")
    def unique_items(self) -> Optional[bool]:
        return pulumi.get(self, "unique_items")

    @property
    @pulumi.getter(name="x-descriptors")
    def x_descriptors(self) -> Optional[Sequence[str]]:
        """
        x-descriptors annotates an object to define additional display options.
        """
        return pulumi.get(self, "x_descriptors")

    @property
    @pulumi.getter(name="x-kubernetes-embedded-resource")
    def x_kubernetes_embedded_resource(self) -> Optional[bool]:
        """
        x-kubernetes-embedded-resource defines that the value is an embedded Kubernetes runtime.Object, with TypeMeta and ObjectMeta. The type must be object. It is allowed to further restrict the embedded object. kind, apiVersion and metadata are validated automatically. x-kubernetes-preserve-unknown-fields is allowed to be true, but does not have to be if the object is fully specified (up to kind, apiVersion, metadata).
        """
        return pulumi.get(self, "x_kubernetes_embedded_resource")

    @property
    @pulumi.getter(name="x-kubernetes-int-or-string")
    def x_kubernetes_int_or_string(self) -> Optional[bool]:
        """
        x-kubernetes-int-or-string specifies that this value is either an integer or a string. If this is true, an empty type is allowed and type as child of anyOf is permitted if following one of the following patterns: 
         1) anyOf:    - type: integer    - type: string 2) allOf:    - anyOf:      - type: integer      - type: string    - ... zero or more
        """
        return pulumi.get(self, "x_kubernetes_int_or_string")

    @property
    @pulumi.getter(name="x-kubernetes-list-map-keys")
    def x_kubernetes_list_map_keys(self) -> Optional[Sequence[str]]:
        """
        x-kubernetes-list-map-keys annotates an array with the x-kubernetes-list-type `map` by specifying the keys used as the index of the map. 
         This tag MUST only be used on lists that have the "x-kubernetes-list-type" extension set to "map". Also, the values specified for this attribute must be a scalar typed field of the child structure (no nesting is supported). 
         The properties specified must either be required or have a default value, to ensure those properties are present for all list items.
        """
        return pulumi.get(self, "x_kubernetes_list_map_keys")

    @property
    @pulumi.getter(name="x-kubernetes-list-type")
    def x_kubernetes_list_type(self) -> Optional[str]:
        """
        x-kubernetes-list-type annotates an array to further describe its topology. This extension must only be used on lists and may have 3 possible values: 
         1) `atomic`: the list is treated as a single entity, like a scalar.      Atomic lists will be entirely replaced when updated. This extension      may be used on any type of list (struct, scalar, ...). 2) `set`:      Sets are lists that must not have multiple items with the same value. Each      value must be a scalar, an object with x-kubernetes-map-type `atomic` or an      array with x-kubernetes-list-type `atomic`. 3) `map`:      These lists are like maps in that their elements have a non-index key      used to identify them. Order is preserved upon merge. The map tag      must only be used on a list with elements of type object. Defaults to atomic for arrays.
        """
        return pulumi.get(self, "x_kubernetes_list_type")

    @property
    @pulumi.getter(name="x-kubernetes-map-type")
    def x_kubernetes_map_type(self) -> Optional[str]:
        """
        x-kubernetes-map-type annotates an object to further describe its topology. This extension must only be used when type is object and may have 2 possible values: 
         1) `granular`:      These maps are actual maps (key-value pairs) and each fields are independent      from each other (they can each be manipulated by separate actors). This is      the default behaviour for all maps. 2) `atomic`: the list is treated as a single entity, like a scalar.      Atomic maps will be entirely replaced when updated.
        """
        return pulumi.get(self, "x_kubernetes_map_type")

    @property
    @pulumi.getter(name="x-kubernetes-preserve-unknown-fields")
    def x_kubernetes_preserve_unknown_fields(self) -> Optional[bool]:
        """
        x-kubernetes-preserve-unknown-fields stops the API server decoding step from pruning fields which are not specified in the validation schema. This affects fields recursively, but switches back to normal pruning behaviour if nested properties or additionalProperties are specified in the schema. This can either be true or undefined. False is forbidden.
        """
        return pulumi.get(self, "x_kubernetes_preserve_unknown_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KameletSpecTypesSchemaExternalDocs(dict):
    """
    ExternalDocumentation allows referencing an external resource for extended documentation.
    """
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 url: Optional[str] = None):
        """
        ExternalDocumentation allows referencing an external resource for extended documentation.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        return pulumi.get(self, "url")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KameletStatus(dict):
    """
    KameletStatus defines the observed state of Kamelet
    """
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.KameletStatusConditions']] = None,
                 phase: Optional[str] = None,
                 properties: Optional[Sequence['outputs.KameletStatusProperties']] = None):
        """
        KameletStatus defines the observed state of Kamelet
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.KameletStatusConditions']]:
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def phase(self) -> Optional[str]:
        return pulumi.get(self, "phase")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Sequence['outputs.KameletStatusProperties']]:
        return pulumi.get(self, "properties")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KameletStatusConditions(dict):
    """
    KameletCondition describes the state of a resource at a certain point.
    """
    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 last_update_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None):
        """
        KameletCondition describes the state of a resource at a certain point.
        :param str status: Status of the condition, one of True, False, Unknown.
        :param str type: Type of kamelet condition.
        :param str last_transition_time: Last time the condition transitioned from one status to another.
        :param str last_update_time: The last time this condition was updated.
        :param str message: A human readable message indicating details about the transition.
        :param str reason: The reason for the condition's last transition.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if last_update_time is not None:
            pulumi.set(__self__, "last_update_time", last_update_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of kamelet condition.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        Last time the condition transitioned from one status to another.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter(name="lastUpdateTime")
    def last_update_time(self) -> Optional[str]:
        """
        The last time this condition was updated.
        """
        return pulumi.get(self, "last_update_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        A human readable message indicating details about the transition.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        The reason for the condition's last transition.
        """
        return pulumi.get(self, "reason")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KameletStatusProperties(dict):
    def __init__(__self__, *,
                 default: Optional[str] = None,
                 name: Optional[str] = None):
        if default is not None:
            pulumi.set(__self__, "default", default)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def default(self) -> Optional[str]:
        return pulumi.get(self, "default")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


