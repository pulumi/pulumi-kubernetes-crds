# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from ... import _utilities, _tables
from . import outputs

__all__ = [
    'ClusterManagerSpec',
    'ClusterManagerStatus',
    'ClusterManagerStatusConditions',
    'ClusterManagerStatusGenerations',
    'ClusterManagerStatusRelatedResources',
]

@pulumi.output_type
class ClusterManagerSpec(dict):
    """
    Spec represents a desired deployment configuration of controllers that govern registration and work distribution for attached Klusterlets.
    """
    def __init__(__self__, *,
                 registration_image_pull_spec: Optional[str] = None,
                 work_image_pull_spec: Optional[str] = None):
        """
        Spec represents a desired deployment configuration of controllers that govern registration and work distribution for attached Klusterlets.
        :param str registration_image_pull_spec: RegistrationImagePullSpec represents the desired image of registration controller/webhook installed on hub.
        :param str work_image_pull_spec: WorkImagePullSpec represents the desired image configuration of work controller/webhook installed on hub.
        """
        if registration_image_pull_spec is not None:
            pulumi.set(__self__, "registration_image_pull_spec", registration_image_pull_spec)
        if work_image_pull_spec is not None:
            pulumi.set(__self__, "work_image_pull_spec", work_image_pull_spec)

    @property
    @pulumi.getter(name="registrationImagePullSpec")
    def registration_image_pull_spec(self) -> Optional[str]:
        """
        RegistrationImagePullSpec represents the desired image of registration controller/webhook installed on hub.
        """
        return pulumi.get(self, "registration_image_pull_spec")

    @property
    @pulumi.getter(name="workImagePullSpec")
    def work_image_pull_spec(self) -> Optional[str]:
        """
        WorkImagePullSpec represents the desired image configuration of work controller/webhook installed on hub.
        """
        return pulumi.get(self, "work_image_pull_spec")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ClusterManagerStatus(dict):
    """
    Status represents the current status of controllers that govern the lifecycle of managed clusters.
    """
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.ClusterManagerStatusConditions']] = None,
                 generations: Optional[Sequence['outputs.ClusterManagerStatusGenerations']] = None,
                 observed_generation: Optional[int] = None,
                 related_resources: Optional[Sequence['outputs.ClusterManagerStatusRelatedResources']] = None):
        """
        Status represents the current status of controllers that govern the lifecycle of managed clusters.
        :param Sequence['ClusterManagerStatusConditionsArgs'] conditions: Conditions contain the different condition statuses for this ClusterManager. Valid condition types are: Applied: components in hub are applied. Available: components in hub are available and ready to serve. Progressing: components in hub are in a transitioning state. Degraded: components in hub do not match the desired configuration and only provide degraded service.
        :param Sequence['ClusterManagerStatusGenerationsArgs'] generations: Generations are used to determine when an item needs to be reconciled or has changed in a way that needs a reaction.
        :param int observed_generation: ObservedGeneration is the last generation change you've dealt with
        :param Sequence['ClusterManagerStatusRelatedResourcesArgs'] related_resources: RelatedResources are used to track the resources that are related to this ClusterManager
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if generations is not None:
            pulumi.set(__self__, "generations", generations)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if related_resources is not None:
            pulumi.set(__self__, "related_resources", related_resources)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.ClusterManagerStatusConditions']]:
        """
        Conditions contain the different condition statuses for this ClusterManager. Valid condition types are: Applied: components in hub are applied. Available: components in hub are available and ready to serve. Progressing: components in hub are in a transitioning state. Degraded: components in hub do not match the desired configuration and only provide degraded service.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def generations(self) -> Optional[Sequence['outputs.ClusterManagerStatusGenerations']]:
        """
        Generations are used to determine when an item needs to be reconciled or has changed in a way that needs a reaction.
        """
        return pulumi.get(self, "generations")

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[int]:
        """
        ObservedGeneration is the last generation change you've dealt with
        """
        return pulumi.get(self, "observed_generation")

    @property
    @pulumi.getter(name="relatedResources")
    def related_resources(self) -> Optional[Sequence['outputs.ClusterManagerStatusRelatedResources']]:
        """
        RelatedResources are used to track the resources that are related to this ClusterManager
        """
        return pulumi.get(self, "related_resources")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ClusterManagerStatusConditions(dict):
    """
    Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, type FooStatus struct{     // Represents the observations of a foo's current state.     // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"     // +patchMergeKey=type     // +patchStrategy=merge     // +listType=map     // +listMapKey=type     Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"` 
         // other fields }
    """
    def __init__(__self__, *,
                 last_transition_time: str,
                 message: str,
                 reason: str,
                 status: str,
                 type: str,
                 observed_generation: Optional[int] = None):
        """
        Condition contains details for one aspect of the current state of this API Resource. --- This struct is intended for direct use as an array at the field path .status.conditions.  For example, type FooStatus struct{     // Represents the observations of a foo's current state.     // Known .status.conditions.type are: "Available", "Progressing", and "Degraded"     // +patchMergeKey=type     // +patchStrategy=merge     // +listType=map     // +listMapKey=type     Conditions []metav1.Condition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,1,rep,name=conditions"` 
             // other fields }
        :param str last_transition_time: lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
        :param str message: message is a human readable message indicating details about the transition. This may be an empty string.
        :param str reason: reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
        :param str status: status of the condition, one of True, False, Unknown.
        :param str type: type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
        :param int observed_generation: observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
        """
        pulumi.set(__self__, "last_transition_time", last_transition_time)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "reason", reason)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> str:
        """
        lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        message is a human readable message indicating details about the transition. This may be an empty string.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> str:
        """
        reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[int]:
        """
        observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
        """
        return pulumi.get(self, "observed_generation")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ClusterManagerStatusGenerations(dict):
    """
    GenerationStatus keeps track of the generation for a given resource so that decisions about forced updates can be made. the definition matches the GenerationStatus defined in github.com/openshift/api/v1
    """
    def __init__(__self__, *,
                 group: Optional[str] = None,
                 last_generation: Optional[int] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 resource: Optional[str] = None,
                 version: Optional[str] = None):
        """
        GenerationStatus keeps track of the generation for a given resource so that decisions about forced updates can be made. the definition matches the GenerationStatus defined in github.com/openshift/api/v1
        :param str group: group is the group of the thing you're tracking
        :param int last_generation: lastGeneration is the last generation of the thing that controller applies
        :param str name: name is the name of the thing you're tracking
        :param str namespace: namespace is where the thing you're tracking is
        :param str resource: resource is the resource type of the thing you're tracking
        :param str version: version is the version of the thing you're tracking
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if last_generation is not None:
            pulumi.set(__self__, "last_generation", last_generation)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        group is the group of the thing you're tracking
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter(name="lastGeneration")
    def last_generation(self) -> Optional[int]:
        """
        lastGeneration is the last generation of the thing that controller applies
        """
        return pulumi.get(self, "last_generation")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        name is the name of the thing you're tracking
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        namespace is where the thing you're tracking is
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def resource(self) -> Optional[str]:
        """
        resource is the resource type of the thing you're tracking
        """
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        version is the version of the thing you're tracking
        """
        return pulumi.get(self, "version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ClusterManagerStatusRelatedResources(dict):
    """
    RelatedResourceMeta represents the resource that is managed by an operator
    """
    def __init__(__self__, *,
                 group: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 resource: Optional[str] = None,
                 version: Optional[str] = None):
        """
        RelatedResourceMeta represents the resource that is managed by an operator
        :param str group: group is the group of the thing you're tracking
        :param str name: name is the name of the thing you're tracking
        :param str namespace: namespace is where the thing you're tracking is
        :param str resource: resource is the resource type of the thing you're tracking
        :param str version: version is the version of the thing you're tracking
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        group is the group of the thing you're tracking
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        name is the name of the thing you're tracking
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        namespace is where the thing you're tracking is
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def resource(self) -> Optional[str]:
        """
        resource is the resource type of the thing you're tracking
        """
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        version is the version of the thing you're tracking
        """
        return pulumi.get(self, "version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


