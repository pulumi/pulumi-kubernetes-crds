// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package v1alpha1

import (
	"context"
	"reflect"

	metav1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/meta/v1"
	"github.com/pulumi/pulumi/sdk/v2/go/pulumi"
)

// Hyperfoil is the Schema for the hyperfoils API
type HyperfoilType struct {
	ApiVersion *string            `pulumi:"apiVersion"`
	Kind       *string            `pulumi:"kind"`
	Metadata   *metav1.ObjectMeta `pulumi:"metadata"`
	// Configures Hyperfoil Controller and related resources.
	Spec *HyperfoilSpec `pulumi:"spec"`
	// status defines the observed state of Hyperfoil
	Status *HyperfoilStatus `pulumi:"status"`
}

// HyperfoilTypeInput is an input type that accepts HyperfoilTypeArgs and HyperfoilTypeOutput values.
// You can construct a concrete instance of `HyperfoilTypeInput` via:
//
//          HyperfoilTypeArgs{...}
type HyperfoilTypeInput interface {
	pulumi.Input

	ToHyperfoilTypeOutput() HyperfoilTypeOutput
	ToHyperfoilTypeOutputWithContext(context.Context) HyperfoilTypeOutput
}

// Hyperfoil is the Schema for the hyperfoils API
type HyperfoilTypeArgs struct {
	ApiVersion pulumi.StringPtrInput     `pulumi:"apiVersion"`
	Kind       pulumi.StringPtrInput     `pulumi:"kind"`
	Metadata   metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	// Configures Hyperfoil Controller and related resources.
	Spec HyperfoilSpecPtrInput `pulumi:"spec"`
	// status defines the observed state of Hyperfoil
	Status HyperfoilStatusPtrInput `pulumi:"status"`
}

func (HyperfoilTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HyperfoilType)(nil)).Elem()
}

func (i HyperfoilTypeArgs) ToHyperfoilTypeOutput() HyperfoilTypeOutput {
	return i.ToHyperfoilTypeOutputWithContext(context.Background())
}

func (i HyperfoilTypeArgs) ToHyperfoilTypeOutputWithContext(ctx context.Context) HyperfoilTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HyperfoilTypeOutput)
}

// Hyperfoil is the Schema for the hyperfoils API
type HyperfoilTypeOutput struct{ *pulumi.OutputState }

func (HyperfoilTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HyperfoilType)(nil)).Elem()
}

func (o HyperfoilTypeOutput) ToHyperfoilTypeOutput() HyperfoilTypeOutput {
	return o
}

func (o HyperfoilTypeOutput) ToHyperfoilTypeOutputWithContext(ctx context.Context) HyperfoilTypeOutput {
	return o
}

func (o HyperfoilTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HyperfoilType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

func (o HyperfoilTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HyperfoilType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

func (o HyperfoilTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v HyperfoilType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

// Configures Hyperfoil Controller and related resources.
func (o HyperfoilTypeOutput) Spec() HyperfoilSpecPtrOutput {
	return o.ApplyT(func(v HyperfoilType) *HyperfoilSpec { return v.Spec }).(HyperfoilSpecPtrOutput)
}

// status defines the observed state of Hyperfoil
func (o HyperfoilTypeOutput) Status() HyperfoilStatusPtrOutput {
	return o.ApplyT(func(v HyperfoilType) *HyperfoilStatus { return v.Status }).(HyperfoilStatusPtrOutput)
}

type HyperfoilMetadata struct {
}

// HyperfoilMetadataInput is an input type that accepts HyperfoilMetadataArgs and HyperfoilMetadataOutput values.
// You can construct a concrete instance of `HyperfoilMetadataInput` via:
//
//          HyperfoilMetadataArgs{...}
type HyperfoilMetadataInput interface {
	pulumi.Input

	ToHyperfoilMetadataOutput() HyperfoilMetadataOutput
	ToHyperfoilMetadataOutputWithContext(context.Context) HyperfoilMetadataOutput
}

type HyperfoilMetadataArgs struct {
}

func (HyperfoilMetadataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HyperfoilMetadata)(nil)).Elem()
}

func (i HyperfoilMetadataArgs) ToHyperfoilMetadataOutput() HyperfoilMetadataOutput {
	return i.ToHyperfoilMetadataOutputWithContext(context.Background())
}

func (i HyperfoilMetadataArgs) ToHyperfoilMetadataOutputWithContext(ctx context.Context) HyperfoilMetadataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HyperfoilMetadataOutput)
}

type HyperfoilMetadataOutput struct{ *pulumi.OutputState }

func (HyperfoilMetadataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HyperfoilMetadata)(nil)).Elem()
}

func (o HyperfoilMetadataOutput) ToHyperfoilMetadataOutput() HyperfoilMetadataOutput {
	return o
}

func (o HyperfoilMetadataOutput) ToHyperfoilMetadataOutputWithContext(ctx context.Context) HyperfoilMetadataOutput {
	return o
}

// Configures Hyperfoil Controller and related resources.
type HyperfoilSpec struct {
	// Deploy timeout for agents, in milliseconds.
	AgentDeployTimeout *int `pulumi:"agentDeployTimeout"`
	// Controller image. If 'version' is defined, too, the tag is replaced (or appended). Defaults to 'quay.io/hyperfoil/hyperfoil'
	Image *string `pulumi:"image"`
	// Name of the config map and optionally its entry (separated by '/': e.g myconfigmap/log4j2-superverbose.xml) storing Log4j2 configuration file. By default the Controller uses its embedded configuration.
	Log *string `pulumi:"log"`
	// Name of the PVC hyperfoil should mount for its workdir.
	PersistentVolumeClaim *string `pulumi:"persistentVolumeClaim"`
	// Name of config map holding hooks that run when the run finishes.
	PostHooks *string `pulumi:"postHooks"`
	// Name of config map holding hooks that run before the run starts.
	PreHooks *string `pulumi:"preHooks"`
	// Host for the route leading to Controller REST endpoint.
	Route *string `pulumi:"route"`
	// List of secrets in this namespace; each entry from those secrets will be mapped as environment variable, using the key as variable name.
	SecretEnvVars []string `pulumi:"secretEnvVars"`
	// If this is set the controller does not start benchmark run right away after hitting /benchmark/my-benchmark/start ; instead it responds with status 301 and header Location set to concatenation of this string and 'BENCHMARK=my-benchmark&RUN_ID=xxxx'. CLI interprets that response as a request to hit CI instance on this URL, assuming that CI will trigger a new job that will eventually call /benchmark/my-benchmark/start?runId=xxxx with header 'x-trigger-job'. This is useful if the the CI has to synchronize Hyperfoil to other benchmarks that don't use this controller instance.
	TriggerUrl *string `pulumi:"triggerUrl"`
	// Tag for controller image. Defaults to version matching the operator version.
	Version *string `pulumi:"version"`
}

// HyperfoilSpecInput is an input type that accepts HyperfoilSpecArgs and HyperfoilSpecOutput values.
// You can construct a concrete instance of `HyperfoilSpecInput` via:
//
//          HyperfoilSpecArgs{...}
type HyperfoilSpecInput interface {
	pulumi.Input

	ToHyperfoilSpecOutput() HyperfoilSpecOutput
	ToHyperfoilSpecOutputWithContext(context.Context) HyperfoilSpecOutput
}

// Configures Hyperfoil Controller and related resources.
type HyperfoilSpecArgs struct {
	// Deploy timeout for agents, in milliseconds.
	AgentDeployTimeout pulumi.IntPtrInput `pulumi:"agentDeployTimeout"`
	// Controller image. If 'version' is defined, too, the tag is replaced (or appended). Defaults to 'quay.io/hyperfoil/hyperfoil'
	Image pulumi.StringPtrInput `pulumi:"image"`
	// Name of the config map and optionally its entry (separated by '/': e.g myconfigmap/log4j2-superverbose.xml) storing Log4j2 configuration file. By default the Controller uses its embedded configuration.
	Log pulumi.StringPtrInput `pulumi:"log"`
	// Name of the PVC hyperfoil should mount for its workdir.
	PersistentVolumeClaim pulumi.StringPtrInput `pulumi:"persistentVolumeClaim"`
	// Name of config map holding hooks that run when the run finishes.
	PostHooks pulumi.StringPtrInput `pulumi:"postHooks"`
	// Name of config map holding hooks that run before the run starts.
	PreHooks pulumi.StringPtrInput `pulumi:"preHooks"`
	// Host for the route leading to Controller REST endpoint.
	Route pulumi.StringPtrInput `pulumi:"route"`
	// List of secrets in this namespace; each entry from those secrets will be mapped as environment variable, using the key as variable name.
	SecretEnvVars pulumi.StringArrayInput `pulumi:"secretEnvVars"`
	// If this is set the controller does not start benchmark run right away after hitting /benchmark/my-benchmark/start ; instead it responds with status 301 and header Location set to concatenation of this string and 'BENCHMARK=my-benchmark&RUN_ID=xxxx'. CLI interprets that response as a request to hit CI instance on this URL, assuming that CI will trigger a new job that will eventually call /benchmark/my-benchmark/start?runId=xxxx with header 'x-trigger-job'. This is useful if the the CI has to synchronize Hyperfoil to other benchmarks that don't use this controller instance.
	TriggerUrl pulumi.StringPtrInput `pulumi:"triggerUrl"`
	// Tag for controller image. Defaults to version matching the operator version.
	Version pulumi.StringPtrInput `pulumi:"version"`
}

func (HyperfoilSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HyperfoilSpec)(nil)).Elem()
}

func (i HyperfoilSpecArgs) ToHyperfoilSpecOutput() HyperfoilSpecOutput {
	return i.ToHyperfoilSpecOutputWithContext(context.Background())
}

func (i HyperfoilSpecArgs) ToHyperfoilSpecOutputWithContext(ctx context.Context) HyperfoilSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HyperfoilSpecOutput)
}

func (i HyperfoilSpecArgs) ToHyperfoilSpecPtrOutput() HyperfoilSpecPtrOutput {
	return i.ToHyperfoilSpecPtrOutputWithContext(context.Background())
}

func (i HyperfoilSpecArgs) ToHyperfoilSpecPtrOutputWithContext(ctx context.Context) HyperfoilSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HyperfoilSpecOutput).ToHyperfoilSpecPtrOutputWithContext(ctx)
}

// HyperfoilSpecPtrInput is an input type that accepts HyperfoilSpecArgs, HyperfoilSpecPtr and HyperfoilSpecPtrOutput values.
// You can construct a concrete instance of `HyperfoilSpecPtrInput` via:
//
//          HyperfoilSpecArgs{...}
//
//  or:
//
//          nil
type HyperfoilSpecPtrInput interface {
	pulumi.Input

	ToHyperfoilSpecPtrOutput() HyperfoilSpecPtrOutput
	ToHyperfoilSpecPtrOutputWithContext(context.Context) HyperfoilSpecPtrOutput
}

type hyperfoilSpecPtrType HyperfoilSpecArgs

func HyperfoilSpecPtr(v *HyperfoilSpecArgs) HyperfoilSpecPtrInput {
	return (*hyperfoilSpecPtrType)(v)
}

func (*hyperfoilSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HyperfoilSpec)(nil)).Elem()
}

func (i *hyperfoilSpecPtrType) ToHyperfoilSpecPtrOutput() HyperfoilSpecPtrOutput {
	return i.ToHyperfoilSpecPtrOutputWithContext(context.Background())
}

func (i *hyperfoilSpecPtrType) ToHyperfoilSpecPtrOutputWithContext(ctx context.Context) HyperfoilSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HyperfoilSpecPtrOutput)
}

// Configures Hyperfoil Controller and related resources.
type HyperfoilSpecOutput struct{ *pulumi.OutputState }

func (HyperfoilSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HyperfoilSpec)(nil)).Elem()
}

func (o HyperfoilSpecOutput) ToHyperfoilSpecOutput() HyperfoilSpecOutput {
	return o
}

func (o HyperfoilSpecOutput) ToHyperfoilSpecOutputWithContext(ctx context.Context) HyperfoilSpecOutput {
	return o
}

func (o HyperfoilSpecOutput) ToHyperfoilSpecPtrOutput() HyperfoilSpecPtrOutput {
	return o.ToHyperfoilSpecPtrOutputWithContext(context.Background())
}

func (o HyperfoilSpecOutput) ToHyperfoilSpecPtrOutputWithContext(ctx context.Context) HyperfoilSpecPtrOutput {
	return o.ApplyT(func(v HyperfoilSpec) *HyperfoilSpec {
		return &v
	}).(HyperfoilSpecPtrOutput)
}

// Deploy timeout for agents, in milliseconds.
func (o HyperfoilSpecOutput) AgentDeployTimeout() pulumi.IntPtrOutput {
	return o.ApplyT(func(v HyperfoilSpec) *int { return v.AgentDeployTimeout }).(pulumi.IntPtrOutput)
}

// Controller image. If 'version' is defined, too, the tag is replaced (or appended). Defaults to 'quay.io/hyperfoil/hyperfoil'
func (o HyperfoilSpecOutput) Image() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HyperfoilSpec) *string { return v.Image }).(pulumi.StringPtrOutput)
}

// Name of the config map and optionally its entry (separated by '/': e.g myconfigmap/log4j2-superverbose.xml) storing Log4j2 configuration file. By default the Controller uses its embedded configuration.
func (o HyperfoilSpecOutput) Log() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HyperfoilSpec) *string { return v.Log }).(pulumi.StringPtrOutput)
}

// Name of the PVC hyperfoil should mount for its workdir.
func (o HyperfoilSpecOutput) PersistentVolumeClaim() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HyperfoilSpec) *string { return v.PersistentVolumeClaim }).(pulumi.StringPtrOutput)
}

// Name of config map holding hooks that run when the run finishes.
func (o HyperfoilSpecOutput) PostHooks() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HyperfoilSpec) *string { return v.PostHooks }).(pulumi.StringPtrOutput)
}

// Name of config map holding hooks that run before the run starts.
func (o HyperfoilSpecOutput) PreHooks() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HyperfoilSpec) *string { return v.PreHooks }).(pulumi.StringPtrOutput)
}

// Host for the route leading to Controller REST endpoint.
func (o HyperfoilSpecOutput) Route() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HyperfoilSpec) *string { return v.Route }).(pulumi.StringPtrOutput)
}

// List of secrets in this namespace; each entry from those secrets will be mapped as environment variable, using the key as variable name.
func (o HyperfoilSpecOutput) SecretEnvVars() pulumi.StringArrayOutput {
	return o.ApplyT(func(v HyperfoilSpec) []string { return v.SecretEnvVars }).(pulumi.StringArrayOutput)
}

// If this is set the controller does not start benchmark run right away after hitting /benchmark/my-benchmark/start ; instead it responds with status 301 and header Location set to concatenation of this string and 'BENCHMARK=my-benchmark&RUN_ID=xxxx'. CLI interprets that response as a request to hit CI instance on this URL, assuming that CI will trigger a new job that will eventually call /benchmark/my-benchmark/start?runId=xxxx with header 'x-trigger-job'. This is useful if the the CI has to synchronize Hyperfoil to other benchmarks that don't use this controller instance.
func (o HyperfoilSpecOutput) TriggerUrl() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HyperfoilSpec) *string { return v.TriggerUrl }).(pulumi.StringPtrOutput)
}

// Tag for controller image. Defaults to version matching the operator version.
func (o HyperfoilSpecOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HyperfoilSpec) *string { return v.Version }).(pulumi.StringPtrOutput)
}

type HyperfoilSpecPtrOutput struct{ *pulumi.OutputState }

func (HyperfoilSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HyperfoilSpec)(nil)).Elem()
}

func (o HyperfoilSpecPtrOutput) ToHyperfoilSpecPtrOutput() HyperfoilSpecPtrOutput {
	return o
}

func (o HyperfoilSpecPtrOutput) ToHyperfoilSpecPtrOutputWithContext(ctx context.Context) HyperfoilSpecPtrOutput {
	return o
}

func (o HyperfoilSpecPtrOutput) Elem() HyperfoilSpecOutput {
	return o.ApplyT(func(v *HyperfoilSpec) HyperfoilSpec { return *v }).(HyperfoilSpecOutput)
}

// Deploy timeout for agents, in milliseconds.
func (o HyperfoilSpecPtrOutput) AgentDeployTimeout() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *HyperfoilSpec) *int {
		if v == nil {
			return nil
		}
		return v.AgentDeployTimeout
	}).(pulumi.IntPtrOutput)
}

// Controller image. If 'version' is defined, too, the tag is replaced (or appended). Defaults to 'quay.io/hyperfoil/hyperfoil'
func (o HyperfoilSpecPtrOutput) Image() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HyperfoilSpec) *string {
		if v == nil {
			return nil
		}
		return v.Image
	}).(pulumi.StringPtrOutput)
}

// Name of the config map and optionally its entry (separated by '/': e.g myconfigmap/log4j2-superverbose.xml) storing Log4j2 configuration file. By default the Controller uses its embedded configuration.
func (o HyperfoilSpecPtrOutput) Log() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HyperfoilSpec) *string {
		if v == nil {
			return nil
		}
		return v.Log
	}).(pulumi.StringPtrOutput)
}

// Name of the PVC hyperfoil should mount for its workdir.
func (o HyperfoilSpecPtrOutput) PersistentVolumeClaim() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HyperfoilSpec) *string {
		if v == nil {
			return nil
		}
		return v.PersistentVolumeClaim
	}).(pulumi.StringPtrOutput)
}

// Name of config map holding hooks that run when the run finishes.
func (o HyperfoilSpecPtrOutput) PostHooks() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HyperfoilSpec) *string {
		if v == nil {
			return nil
		}
		return v.PostHooks
	}).(pulumi.StringPtrOutput)
}

// Name of config map holding hooks that run before the run starts.
func (o HyperfoilSpecPtrOutput) PreHooks() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HyperfoilSpec) *string {
		if v == nil {
			return nil
		}
		return v.PreHooks
	}).(pulumi.StringPtrOutput)
}

// Host for the route leading to Controller REST endpoint.
func (o HyperfoilSpecPtrOutput) Route() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HyperfoilSpec) *string {
		if v == nil {
			return nil
		}
		return v.Route
	}).(pulumi.StringPtrOutput)
}

// List of secrets in this namespace; each entry from those secrets will be mapped as environment variable, using the key as variable name.
func (o HyperfoilSpecPtrOutput) SecretEnvVars() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *HyperfoilSpec) []string {
		if v == nil {
			return nil
		}
		return v.SecretEnvVars
	}).(pulumi.StringArrayOutput)
}

// If this is set the controller does not start benchmark run right away after hitting /benchmark/my-benchmark/start ; instead it responds with status 301 and header Location set to concatenation of this string and 'BENCHMARK=my-benchmark&RUN_ID=xxxx'. CLI interprets that response as a request to hit CI instance on this URL, assuming that CI will trigger a new job that will eventually call /benchmark/my-benchmark/start?runId=xxxx with header 'x-trigger-job'. This is useful if the the CI has to synchronize Hyperfoil to other benchmarks that don't use this controller instance.
func (o HyperfoilSpecPtrOutput) TriggerUrl() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HyperfoilSpec) *string {
		if v == nil {
			return nil
		}
		return v.TriggerUrl
	}).(pulumi.StringPtrOutput)
}

// Tag for controller image. Defaults to version matching the operator version.
func (o HyperfoilSpecPtrOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HyperfoilSpec) *string {
		if v == nil {
			return nil
		}
		return v.Version
	}).(pulumi.StringPtrOutput)
}

// status defines the observed state of Hyperfoil
type HyperfoilStatus struct {
	// RFC 3339 date and time of the last update.
	LastUpdate *string `pulumi:"lastUpdate"`
	// Human readable explanation for the status.
	Reason *string `pulumi:"reason"`
	// One of: 'Ready', 'Pending' or 'Error'
	Status *string `pulumi:"status"`
}

// HyperfoilStatusInput is an input type that accepts HyperfoilStatusArgs and HyperfoilStatusOutput values.
// You can construct a concrete instance of `HyperfoilStatusInput` via:
//
//          HyperfoilStatusArgs{...}
type HyperfoilStatusInput interface {
	pulumi.Input

	ToHyperfoilStatusOutput() HyperfoilStatusOutput
	ToHyperfoilStatusOutputWithContext(context.Context) HyperfoilStatusOutput
}

// status defines the observed state of Hyperfoil
type HyperfoilStatusArgs struct {
	// RFC 3339 date and time of the last update.
	LastUpdate pulumi.StringPtrInput `pulumi:"lastUpdate"`
	// Human readable explanation for the status.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// One of: 'Ready', 'Pending' or 'Error'
	Status pulumi.StringPtrInput `pulumi:"status"`
}

func (HyperfoilStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*HyperfoilStatus)(nil)).Elem()
}

func (i HyperfoilStatusArgs) ToHyperfoilStatusOutput() HyperfoilStatusOutput {
	return i.ToHyperfoilStatusOutputWithContext(context.Background())
}

func (i HyperfoilStatusArgs) ToHyperfoilStatusOutputWithContext(ctx context.Context) HyperfoilStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HyperfoilStatusOutput)
}

func (i HyperfoilStatusArgs) ToHyperfoilStatusPtrOutput() HyperfoilStatusPtrOutput {
	return i.ToHyperfoilStatusPtrOutputWithContext(context.Background())
}

func (i HyperfoilStatusArgs) ToHyperfoilStatusPtrOutputWithContext(ctx context.Context) HyperfoilStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HyperfoilStatusOutput).ToHyperfoilStatusPtrOutputWithContext(ctx)
}

// HyperfoilStatusPtrInput is an input type that accepts HyperfoilStatusArgs, HyperfoilStatusPtr and HyperfoilStatusPtrOutput values.
// You can construct a concrete instance of `HyperfoilStatusPtrInput` via:
//
//          HyperfoilStatusArgs{...}
//
//  or:
//
//          nil
type HyperfoilStatusPtrInput interface {
	pulumi.Input

	ToHyperfoilStatusPtrOutput() HyperfoilStatusPtrOutput
	ToHyperfoilStatusPtrOutputWithContext(context.Context) HyperfoilStatusPtrOutput
}

type hyperfoilStatusPtrType HyperfoilStatusArgs

func HyperfoilStatusPtr(v *HyperfoilStatusArgs) HyperfoilStatusPtrInput {
	return (*hyperfoilStatusPtrType)(v)
}

func (*hyperfoilStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HyperfoilStatus)(nil)).Elem()
}

func (i *hyperfoilStatusPtrType) ToHyperfoilStatusPtrOutput() HyperfoilStatusPtrOutput {
	return i.ToHyperfoilStatusPtrOutputWithContext(context.Background())
}

func (i *hyperfoilStatusPtrType) ToHyperfoilStatusPtrOutputWithContext(ctx context.Context) HyperfoilStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HyperfoilStatusPtrOutput)
}

// status defines the observed state of Hyperfoil
type HyperfoilStatusOutput struct{ *pulumi.OutputState }

func (HyperfoilStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HyperfoilStatus)(nil)).Elem()
}

func (o HyperfoilStatusOutput) ToHyperfoilStatusOutput() HyperfoilStatusOutput {
	return o
}

func (o HyperfoilStatusOutput) ToHyperfoilStatusOutputWithContext(ctx context.Context) HyperfoilStatusOutput {
	return o
}

func (o HyperfoilStatusOutput) ToHyperfoilStatusPtrOutput() HyperfoilStatusPtrOutput {
	return o.ToHyperfoilStatusPtrOutputWithContext(context.Background())
}

func (o HyperfoilStatusOutput) ToHyperfoilStatusPtrOutputWithContext(ctx context.Context) HyperfoilStatusPtrOutput {
	return o.ApplyT(func(v HyperfoilStatus) *HyperfoilStatus {
		return &v
	}).(HyperfoilStatusPtrOutput)
}

// RFC 3339 date and time of the last update.
func (o HyperfoilStatusOutput) LastUpdate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HyperfoilStatus) *string { return v.LastUpdate }).(pulumi.StringPtrOutput)
}

// Human readable explanation for the status.
func (o HyperfoilStatusOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HyperfoilStatus) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// One of: 'Ready', 'Pending' or 'Error'
func (o HyperfoilStatusOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v HyperfoilStatus) *string { return v.Status }).(pulumi.StringPtrOutput)
}

type HyperfoilStatusPtrOutput struct{ *pulumi.OutputState }

func (HyperfoilStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HyperfoilStatus)(nil)).Elem()
}

func (o HyperfoilStatusPtrOutput) ToHyperfoilStatusPtrOutput() HyperfoilStatusPtrOutput {
	return o
}

func (o HyperfoilStatusPtrOutput) ToHyperfoilStatusPtrOutputWithContext(ctx context.Context) HyperfoilStatusPtrOutput {
	return o
}

func (o HyperfoilStatusPtrOutput) Elem() HyperfoilStatusOutput {
	return o.ApplyT(func(v *HyperfoilStatus) HyperfoilStatus { return *v }).(HyperfoilStatusOutput)
}

// RFC 3339 date and time of the last update.
func (o HyperfoilStatusPtrOutput) LastUpdate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HyperfoilStatus) *string {
		if v == nil {
			return nil
		}
		return v.LastUpdate
	}).(pulumi.StringPtrOutput)
}

// Human readable explanation for the status.
func (o HyperfoilStatusPtrOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HyperfoilStatus) *string {
		if v == nil {
			return nil
		}
		return v.Reason
	}).(pulumi.StringPtrOutput)
}

// One of: 'Ready', 'Pending' or 'Error'
func (o HyperfoilStatusPtrOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *HyperfoilStatus) *string {
		if v == nil {
			return nil
		}
		return v.Status
	}).(pulumi.StringPtrOutput)
}

func init() {
	pulumi.RegisterOutputType(HyperfoilTypeOutput{})
	pulumi.RegisterOutputType(HyperfoilMetadataOutput{})
	pulumi.RegisterOutputType(HyperfoilSpecOutput{})
	pulumi.RegisterOutputType(HyperfoilSpecPtrOutput{})
	pulumi.RegisterOutputType(HyperfoilStatusOutput{})
	pulumi.RegisterOutputType(HyperfoilStatusPtrOutput{})
}
