# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from ... import _utilities, _tables

__all__ = [
    'HyperfoilSpec',
    'HyperfoilStatus',
]

@pulumi.output_type
class HyperfoilSpec(dict):
    """
    Configures Hyperfoil Controller and related resources.
    """
    def __init__(__self__, *,
                 agent_deploy_timeout: Optional[int] = None,
                 image: Optional[str] = None,
                 log: Optional[str] = None,
                 persistent_volume_claim: Optional[str] = None,
                 post_hooks: Optional[str] = None,
                 pre_hooks: Optional[str] = None,
                 route: Optional[str] = None,
                 secret_env_vars: Optional[Sequence[str]] = None,
                 trigger_url: Optional[str] = None,
                 version: Optional[str] = None):
        """
        Configures Hyperfoil Controller and related resources.
        :param int agent_deploy_timeout: Deploy timeout for agents, in milliseconds.
        :param str image: Controller image. If 'version' is defined, too, the tag is replaced (or appended). Defaults to 'quay.io/hyperfoil/hyperfoil'
        :param str log: Name of the config map and optionally its entry (separated by '/': e.g myconfigmap/log4j2-superverbose.xml) storing Log4j2 configuration file. By default the Controller uses its embedded configuration.
        :param str persistent_volume_claim: Name of the PVC hyperfoil should mount for its workdir.
        :param str post_hooks: Name of config map holding hooks that run when the run finishes.
        :param str pre_hooks: Name of config map holding hooks that run before the run starts.
        :param str route: Host for the route leading to Controller REST endpoint.
        :param Sequence[str] secret_env_vars: List of secrets in this namespace; each entry from those secrets will be mapped as environment variable, using the key as variable name.
        :param str trigger_url: If this is set the controller does not start benchmark run right away after hitting /benchmark/my-benchmark/start ; instead it responds with status 301 and header Location set to concatenation of this string and 'BENCHMARK=my-benchmark&RUN_ID=xxxx'. CLI interprets that response as a request to hit CI instance on this URL, assuming that CI will trigger a new job that will eventually call /benchmark/my-benchmark/start?runId=xxxx with header 'x-trigger-job'. This is useful if the the CI has to synchronize Hyperfoil to other benchmarks that don't use this controller instance.
        :param str version: Tag for controller image. Defaults to version matching the operator version.
        """
        if agent_deploy_timeout is not None:
            pulumi.set(__self__, "agent_deploy_timeout", agent_deploy_timeout)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if log is not None:
            pulumi.set(__self__, "log", log)
        if persistent_volume_claim is not None:
            pulumi.set(__self__, "persistent_volume_claim", persistent_volume_claim)
        if post_hooks is not None:
            pulumi.set(__self__, "post_hooks", post_hooks)
        if pre_hooks is not None:
            pulumi.set(__self__, "pre_hooks", pre_hooks)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if secret_env_vars is not None:
            pulumi.set(__self__, "secret_env_vars", secret_env_vars)
        if trigger_url is not None:
            pulumi.set(__self__, "trigger_url", trigger_url)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="agentDeployTimeout")
    def agent_deploy_timeout(self) -> Optional[int]:
        """
        Deploy timeout for agents, in milliseconds.
        """
        return pulumi.get(self, "agent_deploy_timeout")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        Controller image. If 'version' is defined, too, the tag is replaced (or appended). Defaults to 'quay.io/hyperfoil/hyperfoil'
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def log(self) -> Optional[str]:
        """
        Name of the config map and optionally its entry (separated by '/': e.g myconfigmap/log4j2-superverbose.xml) storing Log4j2 configuration file. By default the Controller uses its embedded configuration.
        """
        return pulumi.get(self, "log")

    @property
    @pulumi.getter(name="persistentVolumeClaim")
    def persistent_volume_claim(self) -> Optional[str]:
        """
        Name of the PVC hyperfoil should mount for its workdir.
        """
        return pulumi.get(self, "persistent_volume_claim")

    @property
    @pulumi.getter(name="postHooks")
    def post_hooks(self) -> Optional[str]:
        """
        Name of config map holding hooks that run when the run finishes.
        """
        return pulumi.get(self, "post_hooks")

    @property
    @pulumi.getter(name="preHooks")
    def pre_hooks(self) -> Optional[str]:
        """
        Name of config map holding hooks that run before the run starts.
        """
        return pulumi.get(self, "pre_hooks")

    @property
    @pulumi.getter
    def route(self) -> Optional[str]:
        """
        Host for the route leading to Controller REST endpoint.
        """
        return pulumi.get(self, "route")

    @property
    @pulumi.getter(name="secretEnvVars")
    def secret_env_vars(self) -> Optional[Sequence[str]]:
        """
        List of secrets in this namespace; each entry from those secrets will be mapped as environment variable, using the key as variable name.
        """
        return pulumi.get(self, "secret_env_vars")

    @property
    @pulumi.getter(name="triggerUrl")
    def trigger_url(self) -> Optional[str]:
        """
        If this is set the controller does not start benchmark run right away after hitting /benchmark/my-benchmark/start ; instead it responds with status 301 and header Location set to concatenation of this string and 'BENCHMARK=my-benchmark&RUN_ID=xxxx'. CLI interprets that response as a request to hit CI instance on this URL, assuming that CI will trigger a new job that will eventually call /benchmark/my-benchmark/start?runId=xxxx with header 'x-trigger-job'. This is useful if the the CI has to synchronize Hyperfoil to other benchmarks that don't use this controller instance.
        """
        return pulumi.get(self, "trigger_url")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Tag for controller image. Defaults to version matching the operator version.
        """
        return pulumi.get(self, "version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HyperfoilStatus(dict):
    """
    status defines the observed state of Hyperfoil
    """
    def __init__(__self__, *,
                 last_update: Optional[str] = None,
                 reason: Optional[str] = None,
                 status: Optional[str] = None):
        """
        status defines the observed state of Hyperfoil
        :param str last_update: RFC 3339 date and time of the last update.
        :param str reason: Human readable explanation for the status.
        :param str status: One of: 'Ready', 'Pending' or 'Error'
        """
        if last_update is not None:
            pulumi.set(__self__, "last_update", last_update)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="lastUpdate")
    def last_update(self) -> Optional[str]:
        """
        RFC 3339 date and time of the last update.
        """
        return pulumi.get(self, "last_update")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        Human readable explanation for the status.
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        One of: 'Ready', 'Pending' or 'Error'
        """
        return pulumi.get(self, "status")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


