# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from ... import _utilities, _tables
from . import outputs

__all__ = [
    'HyperfoilSpec',
    'HyperfoilSpecAuth',
    'HyperfoilSpecRoute',
    'HyperfoilStatus',
]

@pulumi.output_type
class HyperfoilSpec(dict):
    """
    HyperfoilSpec Configures Hyperfoil Controller and related resources.
    """
    def __init__(__self__, *,
                 agent_deploy_timeout: Optional[int] = None,
                 auth: Optional['outputs.HyperfoilSpecAuth'] = None,
                 image: Optional[str] = None,
                 log: Optional[str] = None,
                 persistent_volume_claim: Optional[str] = None,
                 post_hooks: Optional[Sequence[str]] = None,
                 pre_hooks: Optional[Sequence[str]] = None,
                 route: Optional['outputs.HyperfoilSpecRoute'] = None,
                 secret_env_vars: Optional[Sequence[str]] = None,
                 trigger_url: Optional[str] = None,
                 version: Optional[str] = None):
        """
        HyperfoilSpec Configures Hyperfoil Controller and related resources.
        :param int agent_deploy_timeout: Deploy timeout for agents, in milliseconds.
        :param 'HyperfoilSpecAuthArgs' auth: Authentication/authorization settings.
        :param str image: Controller image. If 'version' is defined, too, the tag is replaced (or appended). Defaults to 'quay.io/hyperfoil/hyperfoil'
        :param str log: Name of the config map and optionally its entry (separated by '/': e.g myconfigmap/log4j2-superverbose.xml) storing Log4j2 configuration file. By default the Controller uses its embedded configuration.
        :param str persistent_volume_claim: Name of the PVC hyperfoil should mount for its workdir.
        :param Sequence[str] post_hooks: Names of config maps and optionally keys (separated by '/') holding hooks that run after the run finishes.
        :param Sequence[str] pre_hooks: Names of config maps and optionally keys (separated by '/') holding hooks that run before the run starts.
        :param 'HyperfoilSpecRouteArgs' route: Specification of the exposed route.
        :param Sequence[str] secret_env_vars: List of secrets in this namespace; each entry from those secrets will be mapped as environment variable, using the key as variable name.
        :param str trigger_url: If this is set the controller does not start benchmark run right away after hitting /benchmark/my-benchmark/start ; instead it responds with status 301 and header Location set to concatenation of this string and 'BENCHMARK=my-benchmark&RUN_ID=xxxx'. CLI interprets that response as a request to hit CI instance on this URL, assuming that CI will trigger a new job that will eventually call /benchmark/my-benchmark/start?runId=xxxx with header 'x-trigger-job'. This is useful if the the CI has to synchronize Hyperfoil to other benchmarks that don't use this controller instance.
        :param str version: Tag for controller image. Defaults to version matching the operator version.
        """
        if agent_deploy_timeout is not None:
            pulumi.set(__self__, "agent_deploy_timeout", agent_deploy_timeout)
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if log is not None:
            pulumi.set(__self__, "log", log)
        if persistent_volume_claim is not None:
            pulumi.set(__self__, "persistent_volume_claim", persistent_volume_claim)
        if post_hooks is not None:
            pulumi.set(__self__, "post_hooks", post_hooks)
        if pre_hooks is not None:
            pulumi.set(__self__, "pre_hooks", pre_hooks)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if secret_env_vars is not None:
            pulumi.set(__self__, "secret_env_vars", secret_env_vars)
        if trigger_url is not None:
            pulumi.set(__self__, "trigger_url", trigger_url)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="agentDeployTimeout")
    def agent_deploy_timeout(self) -> Optional[int]:
        """
        Deploy timeout for agents, in milliseconds.
        """
        return pulumi.get(self, "agent_deploy_timeout")

    @property
    @pulumi.getter
    def auth(self) -> Optional['outputs.HyperfoilSpecAuth']:
        """
        Authentication/authorization settings.
        """
        return pulumi.get(self, "auth")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        Controller image. If 'version' is defined, too, the tag is replaced (or appended). Defaults to 'quay.io/hyperfoil/hyperfoil'
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def log(self) -> Optional[str]:
        """
        Name of the config map and optionally its entry (separated by '/': e.g myconfigmap/log4j2-superverbose.xml) storing Log4j2 configuration file. By default the Controller uses its embedded configuration.
        """
        return pulumi.get(self, "log")

    @property
    @pulumi.getter(name="persistentVolumeClaim")
    def persistent_volume_claim(self) -> Optional[str]:
        """
        Name of the PVC hyperfoil should mount for its workdir.
        """
        return pulumi.get(self, "persistent_volume_claim")

    @property
    @pulumi.getter(name="postHooks")
    def post_hooks(self) -> Optional[Sequence[str]]:
        """
        Names of config maps and optionally keys (separated by '/') holding hooks that run after the run finishes.
        """
        return pulumi.get(self, "post_hooks")

    @property
    @pulumi.getter(name="preHooks")
    def pre_hooks(self) -> Optional[Sequence[str]]:
        """
        Names of config maps and optionally keys (separated by '/') holding hooks that run before the run starts.
        """
        return pulumi.get(self, "pre_hooks")

    @property
    @pulumi.getter
    def route(self) -> Optional['outputs.HyperfoilSpecRoute']:
        """
        Specification of the exposed route.
        """
        return pulumi.get(self, "route")

    @property
    @pulumi.getter(name="secretEnvVars")
    def secret_env_vars(self) -> Optional[Sequence[str]]:
        """
        List of secrets in this namespace; each entry from those secrets will be mapped as environment variable, using the key as variable name.
        """
        return pulumi.get(self, "secret_env_vars")

    @property
    @pulumi.getter(name="triggerUrl")
    def trigger_url(self) -> Optional[str]:
        """
        If this is set the controller does not start benchmark run right away after hitting /benchmark/my-benchmark/start ; instead it responds with status 301 and header Location set to concatenation of this string and 'BENCHMARK=my-benchmark&RUN_ID=xxxx'. CLI interprets that response as a request to hit CI instance on this URL, assuming that CI will trigger a new job that will eventually call /benchmark/my-benchmark/start?runId=xxxx with header 'x-trigger-job'. This is useful if the the CI has to synchronize Hyperfoil to other benchmarks that don't use this controller instance.
        """
        return pulumi.get(self, "trigger_url")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Tag for controller image. Defaults to version matching the operator version.
        """
        return pulumi.get(self, "version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HyperfoilSpecAuth(dict):
    """
    Authentication/authorization settings.
    """
    def __init__(__self__, *,
                 secret: Optional[str] = None):
        """
        Authentication/authorization settings.
        :param str secret: Optional; Name of secret used for basic authentication. Must contain key 'password'.
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @property
    @pulumi.getter
    def secret(self) -> Optional[str]:
        """
        Optional; Name of secret used for basic authentication. Must contain key 'password'.
        """
        return pulumi.get(self, "secret")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HyperfoilSpecRoute(dict):
    """
    Specification of the exposed route.
    """
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 tls: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Specification of the exposed route.
        :param str host: Host for the route leading to Controller REST endpoint. Example: hyperfoil.apps.cloud.example.com
        :param str tls: Optional for edge and reencrypt routes, required for passthrough; Name of the secret hosting `tls.crt`, `tls.key` and optionally `ca.crt`
        :param str type: Either 'http' (for plain-text routes - not recommended), 'edge', 'reencrypt' or 'passthrough'
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host for the route leading to Controller REST endpoint. Example: hyperfoil.apps.cloud.example.com
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def tls(self) -> Optional[str]:
        """
        Optional for edge and reencrypt routes, required for passthrough; Name of the secret hosting `tls.crt`, `tls.key` and optionally `ca.crt`
        """
        return pulumi.get(self, "tls")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Either 'http' (for plain-text routes - not recommended), 'edge', 'reencrypt' or 'passthrough'
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class HyperfoilStatus(dict):
    """
    HyperfoilStatus defines the observed state of Hyperfoil.
    """
    def __init__(__self__, *,
                 last_update: Optional[str] = None,
                 reason: Optional[str] = None,
                 status: Optional[str] = None):
        """
        HyperfoilStatus defines the observed state of Hyperfoil.
        :param str last_update: RFC 3339 date and time of the last update.
        :param str reason: Human readable explanation for the status.
        :param str status: "One of: 'Ready', 'Pending' or 'Error'"
        """
        if last_update is not None:
            pulumi.set(__self__, "last_update", last_update)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="lastUpdate")
    def last_update(self) -> Optional[str]:
        """
        RFC 3339 date and time of the last update.
        """
        return pulumi.get(self, "last_update")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        Human readable explanation for the status.
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        "One of: 'Ready', 'Pending' or 'Error'"
        """
        return pulumi.get(self, "status")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


