# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from ... import _utilities, _tables

__all__ = [
    'ApmServerSpecArgs',
    'ApmServerSpecElasticsearchRefArgs',
    'ApmServerSpecHttpArgs',
    'ApmServerSpecHttpServiceArgs',
    'ApmServerSpecHttpServiceSpecArgs',
    'ApmServerSpecHttpServiceSpecPortsArgs',
    'ApmServerSpecHttpServiceSpecPortsTargetPortArgs',
    'ApmServerSpecHttpServiceSpecSessionAffinityConfigArgs',
    'ApmServerSpecHttpServiceSpecSessionAffinityConfigClientIPArgs',
    'ApmServerSpecHttpTlsArgs',
    'ApmServerSpecHttpTlsCertificateArgs',
    'ApmServerSpecHttpTlsSelfSignedCertificateArgs',
    'ApmServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArgs',
    'ApmServerSpecKibanaRefArgs',
    'ApmServerSpecSecureSettingsArgs',
    'ApmServerSpecSecureSettingsEntriesArgs',
    'ApmServerStatusArgs',
]

@pulumi.input_type
class ApmServerSpecArgs:
    def __init__(__self__, *,
                 version: pulumi.Input[str],
                 config: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 count: Optional[pulumi.Input[int]] = None,
                 elasticsearch_ref: Optional[pulumi.Input['ApmServerSpecElasticsearchRefArgs']] = None,
                 http: Optional[pulumi.Input['ApmServerSpecHttpArgs']] = None,
                 image: Optional[pulumi.Input[str]] = None,
                 kibana_ref: Optional[pulumi.Input['ApmServerSpecKibanaRefArgs']] = None,
                 pod_template: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 secure_settings: Optional[pulumi.Input[Sequence[pulumi.Input['ApmServerSpecSecureSettingsArgs']]]] = None,
                 service_account_name: Optional[pulumi.Input[str]] = None):
        """
        ApmServerSpec holds the specification of an APM Server.
        :param pulumi.Input[str] version: Version of the APM Server.
        :param pulumi.Input[Mapping[str, Any]] config: Config holds the APM Server configuration. See: https://www.elastic.co/guide/en/apm/server/current/configuring-howto-apm-server.html
        :param pulumi.Input[int] count: Count of APM Server instances to deploy.
        :param pulumi.Input['ApmServerSpecElasticsearchRefArgs'] elasticsearch_ref: ElasticsearchRef is a reference to the output Elasticsearch cluster running in the same Kubernetes cluster.
        :param pulumi.Input['ApmServerSpecHttpArgs'] http: HTTP holds the HTTP layer configuration for the APM Server resource.
        :param pulumi.Input[str] image: Image is the APM Server Docker image to deploy.
        :param pulumi.Input['ApmServerSpecKibanaRefArgs'] kibana_ref: KibanaRef is a reference to a Kibana instance running in the same Kubernetes cluster. It allows APM agent central configuration management in Kibana.
        :param pulumi.Input[Mapping[str, Any]] pod_template: PodTemplate provides customisation options (labels, annotations, affinity rules, resource requests, and so on) for the APM Server pods.
        :param pulumi.Input[Sequence[pulumi.Input['ApmServerSpecSecureSettingsArgs']]] secure_settings: SecureSettings is a list of references to Kubernetes secrets containing sensitive configuration options for APM Server.
        :param pulumi.Input[str] service_account_name: ServiceAccountName is used to check access from the current resource to a resource (eg. Elasticsearch) in a different namespace. Can only be used if ECK is enforcing RBAC on references.
        """
        pulumi.set(__self__, "version", version)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if elasticsearch_ref is not None:
            pulumi.set(__self__, "elasticsearch_ref", elasticsearch_ref)
        if http is not None:
            pulumi.set(__self__, "http", http)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if kibana_ref is not None:
            pulumi.set(__self__, "kibana_ref", kibana_ref)
        if pod_template is not None:
            pulumi.set(__self__, "pod_template", pod_template)
        if secure_settings is not None:
            pulumi.set(__self__, "secure_settings", secure_settings)
        if service_account_name is not None:
            pulumi.set(__self__, "service_account_name", service_account_name)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[str]:
        """
        Version of the APM Server.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[str]):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Config holds the APM Server configuration. See: https://www.elastic.co/guide/en/apm/server/current/configuring-howto-apm-server.html
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "config", value)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[int]]:
        """
        Count of APM Server instances to deploy.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter(name="elasticsearchRef")
    def elasticsearch_ref(self) -> Optional[pulumi.Input['ApmServerSpecElasticsearchRefArgs']]:
        """
        ElasticsearchRef is a reference to the output Elasticsearch cluster running in the same Kubernetes cluster.
        """
        return pulumi.get(self, "elasticsearch_ref")

    @elasticsearch_ref.setter
    def elasticsearch_ref(self, value: Optional[pulumi.Input['ApmServerSpecElasticsearchRefArgs']]):
        pulumi.set(self, "elasticsearch_ref", value)

    @property
    @pulumi.getter
    def http(self) -> Optional[pulumi.Input['ApmServerSpecHttpArgs']]:
        """
        HTTP holds the HTTP layer configuration for the APM Server resource.
        """
        return pulumi.get(self, "http")

    @http.setter
    def http(self, value: Optional[pulumi.Input['ApmServerSpecHttpArgs']]):
        pulumi.set(self, "http", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        Image is the APM Server Docker image to deploy.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="kibanaRef")
    def kibana_ref(self) -> Optional[pulumi.Input['ApmServerSpecKibanaRefArgs']]:
        """
        KibanaRef is a reference to a Kibana instance running in the same Kubernetes cluster. It allows APM agent central configuration management in Kibana.
        """
        return pulumi.get(self, "kibana_ref")

    @kibana_ref.setter
    def kibana_ref(self, value: Optional[pulumi.Input['ApmServerSpecKibanaRefArgs']]):
        pulumi.set(self, "kibana_ref", value)

    @property
    @pulumi.getter(name="podTemplate")
    def pod_template(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        PodTemplate provides customisation options (labels, annotations, affinity rules, resource requests, and so on) for the APM Server pods.
        """
        return pulumi.get(self, "pod_template")

    @pod_template.setter
    def pod_template(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "pod_template", value)

    @property
    @pulumi.getter(name="secureSettings")
    def secure_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApmServerSpecSecureSettingsArgs']]]]:
        """
        SecureSettings is a list of references to Kubernetes secrets containing sensitive configuration options for APM Server.
        """
        return pulumi.get(self, "secure_settings")

    @secure_settings.setter
    def secure_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApmServerSpecSecureSettingsArgs']]]]):
        pulumi.set(self, "secure_settings", value)

    @property
    @pulumi.getter(name="serviceAccountName")
    def service_account_name(self) -> Optional[pulumi.Input[str]]:
        """
        ServiceAccountName is used to check access from the current resource to a resource (eg. Elasticsearch) in a different namespace. Can only be used if ECK is enforcing RBAC on references.
        """
        return pulumi.get(self, "service_account_name")

    @service_account_name.setter
    def service_account_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_account_name", value)


@pulumi.input_type
class ApmServerSpecElasticsearchRefArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 namespace: Optional[pulumi.Input[str]] = None):
        """
        ElasticsearchRef is a reference to the output Elasticsearch cluster running in the same Kubernetes cluster.
        :param pulumi.Input[str] name: Name of the Kubernetes object.
        :param pulumi.Input[str] namespace: Namespace of the Kubernetes object. If empty, defaults to the current namespace.
        """
        pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the Kubernetes object.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the Kubernetes object. If empty, defaults to the current namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)


@pulumi.input_type
class ApmServerSpecHttpArgs:
    def __init__(__self__, *,
                 service: Optional[pulumi.Input['ApmServerSpecHttpServiceArgs']] = None,
                 tls: Optional[pulumi.Input['ApmServerSpecHttpTlsArgs']] = None):
        """
        HTTP holds the HTTP layer configuration for the APM Server resource.
        :param pulumi.Input['ApmServerSpecHttpServiceArgs'] service: Service defines the template for the associated Kubernetes Service object.
        :param pulumi.Input['ApmServerSpecHttpTlsArgs'] tls: TLS defines options for configuring TLS for HTTP.
        """
        if service is not None:
            pulumi.set(__self__, "service", service)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input['ApmServerSpecHttpServiceArgs']]:
        """
        Service defines the template for the associated Kubernetes Service object.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input['ApmServerSpecHttpServiceArgs']]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input['ApmServerSpecHttpTlsArgs']]:
        """
        TLS defines options for configuring TLS for HTTP.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input['ApmServerSpecHttpTlsArgs']]):
        pulumi.set(self, "tls", value)


@pulumi.input_type
class ApmServerSpecHttpServiceArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 spec: Optional[pulumi.Input['ApmServerSpecHttpServiceSpecArgs']] = None):
        """
        Service defines the template for the associated Kubernetes Service object.
        :param pulumi.Input[Mapping[str, Any]] metadata: ObjectMeta is the metadata of the service. The name and namespace provided here are managed by ECK and will be ignored.
        :param pulumi.Input['ApmServerSpecHttpServiceSpecArgs'] spec: Spec is the specification of the service.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        ObjectMeta is the metadata of the service. The name and namespace provided here are managed by ECK and will be ignored.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter
    def spec(self) -> Optional[pulumi.Input['ApmServerSpecHttpServiceSpecArgs']]:
        """
        Spec is the specification of the service.
        """
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: Optional[pulumi.Input['ApmServerSpecHttpServiceSpecArgs']]):
        pulumi.set(self, "spec", value)


@pulumi.input_type
class ApmServerSpecHttpServiceSpecArgs:
    def __init__(__self__, *,
                 cluster_ip: Optional[pulumi.Input[str]] = None,
                 external_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 external_name: Optional[pulumi.Input[str]] = None,
                 external_traffic_policy: Optional[pulumi.Input[str]] = None,
                 health_check_node_port: Optional[pulumi.Input[int]] = None,
                 ip_family: Optional[pulumi.Input[str]] = None,
                 load_balancer_ip: Optional[pulumi.Input[str]] = None,
                 load_balancer_source_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input['ApmServerSpecHttpServiceSpecPortsArgs']]]] = None,
                 publish_not_ready_addresses: Optional[pulumi.Input[bool]] = None,
                 selector: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 session_affinity: Optional[pulumi.Input[str]] = None,
                 session_affinity_config: Optional[pulumi.Input['ApmServerSpecHttpServiceSpecSessionAffinityConfigArgs']] = None,
                 topology_keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        Spec is the specification of the service.
        :param pulumi.Input[str] cluster_ip: clusterIP is the IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are "None", empty string (""), or a valid IP address. "None" can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
        :param pulumi.Input[Sequence[pulumi.Input[str]]] external_ips: externalIPs is a list of IP addresses for which nodes in the cluster will also accept traffic for this service.  These IPs are not managed by Kubernetes.  The user is responsible for ensuring that traffic arrives at a node with this IP.  A common example is external load-balancers that are not part of the Kubernetes system.
        :param pulumi.Input[str] external_name: externalName is the external reference that kubedns or equivalent will return as a CNAME record for this service. No proxying will be involved. Must be a valid RFC-1123 hostname (https://tools.ietf.org/html/rfc1123) and requires Type to be ExternalName.
        :param pulumi.Input[str] external_traffic_policy: externalTrafficPolicy denotes if this Service desires to route external traffic to node-local or cluster-wide endpoints. "Local" preserves the client source IP and avoids a second hop for LoadBalancer and Nodeport type services, but risks potentially imbalanced traffic spreading. "Cluster" obscures the client source IP and may cause a second hop to another node, but should have good overall load-spreading.
        :param pulumi.Input[int] health_check_node_port: healthCheckNodePort specifies the healthcheck nodePort for the service. If not specified, HealthCheckNodePort is created by the service api backend with the allocated nodePort. Will use user-specified nodePort value if specified by the client. Only effects when Type is set to LoadBalancer and ExternalTrafficPolicy is set to Local.
        :param pulumi.Input[str] ip_family: ipFamily specifies whether this Service has a preference for a particular IP family (e.g. IPv4 vs. IPv6).  If a specific IP family is requested, the clusterIP field will be allocated from that family, if it is available in the cluster.  If no IP family is requested, the cluster's primary IP family will be used. Other IP fields (loadBalancerIP, loadBalancerSourceRanges, externalIPs) and controllers which allocate external load-balancers should use the same IP family.  Endpoints for this Service will be of this family.  This field is immutable after creation. Assigning a ServiceIPFamily not available in the cluster (e.g. IPv6 in IPv4 only cluster) is an error condition and will fail during clusterIP assignment.
        :param pulumi.Input[str] load_balancer_ip: Only applies to Service Type: LoadBalancer LoadBalancer will get created with the IP specified in this field. This feature depends on whether the underlying cloud-provider supports specifying the loadBalancerIP when a load balancer is created. This field will be ignored if the cloud-provider does not support the feature.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] load_balancer_source_ranges: If specified and supported by the platform, this will restrict traffic through the cloud-provider load-balancer will be restricted to the specified client IPs. This field will be ignored if the cloud-provider does not support the feature." More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/
        :param pulumi.Input[Sequence[pulumi.Input['ApmServerSpecHttpServiceSpecPortsArgs']]] ports: The list of ports that are exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
        :param pulumi.Input[bool] publish_not_ready_addresses: publishNotReadyAddresses, when set to true, indicates that DNS implementations must publish the notReadyAddresses of subsets for the Endpoints associated with the Service. The default value is false. The primary use case for setting this field is to use a StatefulSet's Headless Service to propagate SRV records for its Pods without respect to their readiness for purpose of peer discovery.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] selector: Route service traffic to pods with label keys and values matching this selector. If empty or not present, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/
        :param pulumi.Input[str] session_affinity: Supports "ClientIP" and "None". Used to maintain session affinity. Enable client IP based session affinity. Must be ClientIP or None. Defaults to None. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
        :param pulumi.Input['ApmServerSpecHttpServiceSpecSessionAffinityConfigArgs'] session_affinity_config: sessionAffinityConfig contains the configurations of session affinity.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] topology_keys: topologyKeys is a preference-order list of topology keys which implementations of services should use to preferentially sort endpoints when accessing this Service, it can not be used at the same time as externalTrafficPolicy=Local. Topology keys must be valid label keys and at most 16 keys may be specified. Endpoints are chosen based on the first topology key with available backends. If this field is specified and all entries have no backends that match the topology of the client, the service has no backends for that client and connections should fail. The special value "*" may be used to mean "any topology". This catch-all value, if used, only makes sense as the last value in the list. If this is not specified or empty, no topology constraints will be applied.
        :param pulumi.Input[str] type: type determines how the Service is exposed. Defaults to ClusterIP. Valid options are ExternalName, ClusterIP, NodePort, and LoadBalancer. "ExternalName" maps to the specified externalName. "ClusterIP" allocates a cluster-internal IP address for load-balancing to endpoints. Endpoints are determined by the selector or if that is not specified, by manual construction of an Endpoints object. If clusterIP is "None", no virtual IP is allocated and the endpoints are published as a set of endpoints rather than a stable IP. "NodePort" builds on ClusterIP and allocates a port on every node which routes to the clusterIP. "LoadBalancer" builds on NodePort and creates an external load-balancer (if supported in the current cloud) which routes to the clusterIP. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
        """
        if cluster_ip is not None:
            pulumi.set(__self__, "cluster_ip", cluster_ip)
        if external_ips is not None:
            pulumi.set(__self__, "external_ips", external_ips)
        if external_name is not None:
            pulumi.set(__self__, "external_name", external_name)
        if external_traffic_policy is not None:
            pulumi.set(__self__, "external_traffic_policy", external_traffic_policy)
        if health_check_node_port is not None:
            pulumi.set(__self__, "health_check_node_port", health_check_node_port)
        if ip_family is not None:
            pulumi.set(__self__, "ip_family", ip_family)
        if load_balancer_ip is not None:
            pulumi.set(__self__, "load_balancer_ip", load_balancer_ip)
        if load_balancer_source_ranges is not None:
            pulumi.set(__self__, "load_balancer_source_ranges", load_balancer_source_ranges)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if publish_not_ready_addresses is not None:
            pulumi.set(__self__, "publish_not_ready_addresses", publish_not_ready_addresses)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if session_affinity is not None:
            pulumi.set(__self__, "session_affinity", session_affinity)
        if session_affinity_config is not None:
            pulumi.set(__self__, "session_affinity_config", session_affinity_config)
        if topology_keys is not None:
            pulumi.set(__self__, "topology_keys", topology_keys)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="clusterIP")
    def cluster_ip(self) -> Optional[pulumi.Input[str]]:
        """
        clusterIP is the IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are "None", empty string (""), or a valid IP address. "None" can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
        """
        return pulumi.get(self, "cluster_ip")

    @cluster_ip.setter
    def cluster_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_ip", value)

    @property
    @pulumi.getter(name="externalIPs")
    def external_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        externalIPs is a list of IP addresses for which nodes in the cluster will also accept traffic for this service.  These IPs are not managed by Kubernetes.  The user is responsible for ensuring that traffic arrives at a node with this IP.  A common example is external load-balancers that are not part of the Kubernetes system.
        """
        return pulumi.get(self, "external_ips")

    @external_ips.setter
    def external_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "external_ips", value)

    @property
    @pulumi.getter(name="externalName")
    def external_name(self) -> Optional[pulumi.Input[str]]:
        """
        externalName is the external reference that kubedns or equivalent will return as a CNAME record for this service. No proxying will be involved. Must be a valid RFC-1123 hostname (https://tools.ietf.org/html/rfc1123) and requires Type to be ExternalName.
        """
        return pulumi.get(self, "external_name")

    @external_name.setter
    def external_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "external_name", value)

    @property
    @pulumi.getter(name="externalTrafficPolicy")
    def external_traffic_policy(self) -> Optional[pulumi.Input[str]]:
        """
        externalTrafficPolicy denotes if this Service desires to route external traffic to node-local or cluster-wide endpoints. "Local" preserves the client source IP and avoids a second hop for LoadBalancer and Nodeport type services, but risks potentially imbalanced traffic spreading. "Cluster" obscures the client source IP and may cause a second hop to another node, but should have good overall load-spreading.
        """
        return pulumi.get(self, "external_traffic_policy")

    @external_traffic_policy.setter
    def external_traffic_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "external_traffic_policy", value)

    @property
    @pulumi.getter(name="healthCheckNodePort")
    def health_check_node_port(self) -> Optional[pulumi.Input[int]]:
        """
        healthCheckNodePort specifies the healthcheck nodePort for the service. If not specified, HealthCheckNodePort is created by the service api backend with the allocated nodePort. Will use user-specified nodePort value if specified by the client. Only effects when Type is set to LoadBalancer and ExternalTrafficPolicy is set to Local.
        """
        return pulumi.get(self, "health_check_node_port")

    @health_check_node_port.setter
    def health_check_node_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "health_check_node_port", value)

    @property
    @pulumi.getter(name="ipFamily")
    def ip_family(self) -> Optional[pulumi.Input[str]]:
        """
        ipFamily specifies whether this Service has a preference for a particular IP family (e.g. IPv4 vs. IPv6).  If a specific IP family is requested, the clusterIP field will be allocated from that family, if it is available in the cluster.  If no IP family is requested, the cluster's primary IP family will be used. Other IP fields (loadBalancerIP, loadBalancerSourceRanges, externalIPs) and controllers which allocate external load-balancers should use the same IP family.  Endpoints for this Service will be of this family.  This field is immutable after creation. Assigning a ServiceIPFamily not available in the cluster (e.g. IPv6 in IPv4 only cluster) is an error condition and will fail during clusterIP assignment.
        """
        return pulumi.get(self, "ip_family")

    @ip_family.setter
    def ip_family(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_family", value)

    @property
    @pulumi.getter(name="loadBalancerIP")
    def load_balancer_ip(self) -> Optional[pulumi.Input[str]]:
        """
        Only applies to Service Type: LoadBalancer LoadBalancer will get created with the IP specified in this field. This feature depends on whether the underlying cloud-provider supports specifying the loadBalancerIP when a load balancer is created. This field will be ignored if the cloud-provider does not support the feature.
        """
        return pulumi.get(self, "load_balancer_ip")

    @load_balancer_ip.setter
    def load_balancer_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "load_balancer_ip", value)

    @property
    @pulumi.getter(name="loadBalancerSourceRanges")
    def load_balancer_source_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        If specified and supported by the platform, this will restrict traffic through the cloud-provider load-balancer will be restricted to the specified client IPs. This field will be ignored if the cloud-provider does not support the feature." More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/
        """
        return pulumi.get(self, "load_balancer_source_ranges")

    @load_balancer_source_ranges.setter
    def load_balancer_source_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "load_balancer_source_ranges", value)

    @property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApmServerSpecHttpServiceSpecPortsArgs']]]]:
        """
        The list of ports that are exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApmServerSpecHttpServiceSpecPortsArgs']]]]):
        pulumi.set(self, "ports", value)

    @property
    @pulumi.getter(name="publishNotReadyAddresses")
    def publish_not_ready_addresses(self) -> Optional[pulumi.Input[bool]]:
        """
        publishNotReadyAddresses, when set to true, indicates that DNS implementations must publish the notReadyAddresses of subsets for the Endpoints associated with the Service. The default value is false. The primary use case for setting this field is to use a StatefulSet's Headless Service to propagate SRV records for its Pods without respect to their readiness for purpose of peer discovery.
        """
        return pulumi.get(self, "publish_not_ready_addresses")

    @publish_not_ready_addresses.setter
    def publish_not_ready_addresses(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "publish_not_ready_addresses", value)

    @property
    @pulumi.getter
    def selector(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Route service traffic to pods with label keys and values matching this selector. If empty or not present, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "selector", value)

    @property
    @pulumi.getter(name="sessionAffinity")
    def session_affinity(self) -> Optional[pulumi.Input[str]]:
        """
        Supports "ClientIP" and "None". Used to maintain session affinity. Enable client IP based session affinity. Must be ClientIP or None. Defaults to None. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
        """
        return pulumi.get(self, "session_affinity")

    @session_affinity.setter
    def session_affinity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "session_affinity", value)

    @property
    @pulumi.getter(name="sessionAffinityConfig")
    def session_affinity_config(self) -> Optional[pulumi.Input['ApmServerSpecHttpServiceSpecSessionAffinityConfigArgs']]:
        """
        sessionAffinityConfig contains the configurations of session affinity.
        """
        return pulumi.get(self, "session_affinity_config")

    @session_affinity_config.setter
    def session_affinity_config(self, value: Optional[pulumi.Input['ApmServerSpecHttpServiceSpecSessionAffinityConfigArgs']]):
        pulumi.set(self, "session_affinity_config", value)

    @property
    @pulumi.getter(name="topologyKeys")
    def topology_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        topologyKeys is a preference-order list of topology keys which implementations of services should use to preferentially sort endpoints when accessing this Service, it can not be used at the same time as externalTrafficPolicy=Local. Topology keys must be valid label keys and at most 16 keys may be specified. Endpoints are chosen based on the first topology key with available backends. If this field is specified and all entries have no backends that match the topology of the client, the service has no backends for that client and connections should fail. The special value "*" may be used to mean "any topology". This catch-all value, if used, only makes sense as the last value in the list. If this is not specified or empty, no topology constraints will be applied.
        """
        return pulumi.get(self, "topology_keys")

    @topology_keys.setter
    def topology_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "topology_keys", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        type determines how the Service is exposed. Defaults to ClusterIP. Valid options are ExternalName, ClusterIP, NodePort, and LoadBalancer. "ExternalName" maps to the specified externalName. "ClusterIP" allocates a cluster-internal IP address for load-balancing to endpoints. Endpoints are determined by the selector or if that is not specified, by manual construction of an Endpoints object. If clusterIP is "None", no virtual IP is allocated and the endpoints are published as a set of endpoints rather than a stable IP. "NodePort" builds on ClusterIP and allocates a port on every node which routes to the clusterIP. "LoadBalancer" builds on NodePort and creates an external load-balancer (if supported in the current cloud) which routes to the clusterIP. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ApmServerSpecHttpServiceSpecPortsArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[int],
                 name: Optional[pulumi.Input[str]] = None,
                 node_port: Optional[pulumi.Input[int]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 target_port: Optional[pulumi.Input['ApmServerSpecHttpServiceSpecPortsTargetPortArgs']] = None):
        """
        ServicePort contains information on service's port.
        :param pulumi.Input[int] port: The port that will be exposed by this service.
        :param pulumi.Input[str] name: The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. When considering the endpoints for a Service, this must match the 'name' field in the EndpointPort. Optional if only one ServicePort is defined on this service.
        :param pulumi.Input[int] node_port: The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
        :param pulumi.Input[str] protocol: The IP protocol for this port. Supports "TCP", "UDP", and "SCTP". Default is TCP.
        :param pulumi.Input['ApmServerSpecHttpServiceSpecPortsTargetPortArgs'] target_port: Number or name of the port to access on the pods targeted by the service. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. If this is a string, it will be looked up as a named port in the target Pod's container ports. If this is not specified, the value of the 'port' field is used (an identity map). This field is ignored for services with clusterIP=None, and should be omitted or set equal to the 'port' field. More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
        """
        pulumi.set(__self__, "port", port)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if node_port is not None:
            pulumi.set(__self__, "node_port", node_port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if target_port is not None:
            pulumi.set(__self__, "target_port", target_port)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        The port that will be exposed by this service.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. When considering the endpoints for a Service, this must match the 'name' field in the EndpointPort. Optional if only one ServicePort is defined on this service.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nodePort")
    def node_port(self) -> Optional[pulumi.Input[int]]:
        """
        The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
        """
        return pulumi.get(self, "node_port")

    @node_port.setter
    def node_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "node_port", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        The IP protocol for this port. Supports "TCP", "UDP", and "SCTP". Default is TCP.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> Optional[pulumi.Input['ApmServerSpecHttpServiceSpecPortsTargetPortArgs']]:
        """
        Number or name of the port to access on the pods targeted by the service. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. If this is a string, it will be looked up as a named port in the target Pod's container ports. If this is not specified, the value of the 'port' field is used (an identity map). This field is ignored for services with clusterIP=None, and should be omitted or set equal to the 'port' field. More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
        """
        return pulumi.get(self, "target_port")

    @target_port.setter
    def target_port(self, value: Optional[pulumi.Input['ApmServerSpecHttpServiceSpecPortsTargetPortArgs']]):
        pulumi.set(self, "target_port", value)


@pulumi.input_type
class ApmServerSpecHttpServiceSpecPortsTargetPortArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class ApmServerSpecHttpServiceSpecSessionAffinityConfigArgs:
    def __init__(__self__, *,
                 client_ip: Optional[pulumi.Input['ApmServerSpecHttpServiceSpecSessionAffinityConfigClientIPArgs']] = None):
        """
        sessionAffinityConfig contains the configurations of session affinity.
        :param pulumi.Input['ApmServerSpecHttpServiceSpecSessionAffinityConfigClientIPArgs'] client_ip: clientIP contains the configurations of Client IP based session affinity.
        """
        if client_ip is not None:
            pulumi.set(__self__, "client_ip", client_ip)

    @property
    @pulumi.getter(name="clientIP")
    def client_ip(self) -> Optional[pulumi.Input['ApmServerSpecHttpServiceSpecSessionAffinityConfigClientIPArgs']]:
        """
        clientIP contains the configurations of Client IP based session affinity.
        """
        return pulumi.get(self, "client_ip")

    @client_ip.setter
    def client_ip(self, value: Optional[pulumi.Input['ApmServerSpecHttpServiceSpecSessionAffinityConfigClientIPArgs']]):
        pulumi.set(self, "client_ip", value)


@pulumi.input_type
class ApmServerSpecHttpServiceSpecSessionAffinityConfigClientIPArgs:
    def __init__(__self__, *,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        clientIP contains the configurations of Client IP based session affinity.
        :param pulumi.Input[int] timeout_seconds: timeoutSeconds specifies the seconds of ClientIP type session sticky time. The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP". Default value is 10800(for 3 hours).
        """
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        timeoutSeconds specifies the seconds of ClientIP type session sticky time. The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP". Default value is 10800(for 3 hours).
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


@pulumi.input_type
class ApmServerSpecHttpTlsArgs:
    def __init__(__self__, *,
                 certificate: Optional[pulumi.Input['ApmServerSpecHttpTlsCertificateArgs']] = None,
                 self_signed_certificate: Optional[pulumi.Input['ApmServerSpecHttpTlsSelfSignedCertificateArgs']] = None):
        """
        TLS defines options for configuring TLS for HTTP.
        :param pulumi.Input['ApmServerSpecHttpTlsCertificateArgs'] certificate: Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS. The referenced secret should contain the following: 
                - `ca.crt`: The certificate authority (optional). - `tls.crt`: The certificate (or a chain). - `tls.key`: The private key to the first certificate in the certificate chain.
        :param pulumi.Input['ApmServerSpecHttpTlsSelfSignedCertificateArgs'] self_signed_certificate: SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
        """
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if self_signed_certificate is not None:
            pulumi.set(__self__, "self_signed_certificate", self_signed_certificate)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input['ApmServerSpecHttpTlsCertificateArgs']]:
        """
        Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS. The referenced secret should contain the following: 
         - `ca.crt`: The certificate authority (optional). - `tls.crt`: The certificate (or a chain). - `tls.key`: The private key to the first certificate in the certificate chain.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input['ApmServerSpecHttpTlsCertificateArgs']]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="selfSignedCertificate")
    def self_signed_certificate(self) -> Optional[pulumi.Input['ApmServerSpecHttpTlsSelfSignedCertificateArgs']]:
        """
        SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
        """
        return pulumi.get(self, "self_signed_certificate")

    @self_signed_certificate.setter
    def self_signed_certificate(self, value: Optional[pulumi.Input['ApmServerSpecHttpTlsSelfSignedCertificateArgs']]):
        pulumi.set(self, "self_signed_certificate", value)


@pulumi.input_type
class ApmServerSpecHttpTlsCertificateArgs:
    def __init__(__self__, *,
                 secret_name: Optional[pulumi.Input[str]] = None):
        """
        Certificate is a reference to a Kubernetes secret that contains the certificate and private key for enabling TLS. The referenced secret should contain the following: 
         - `ca.crt`: The certificate authority (optional). - `tls.crt`: The certificate (or a chain). - `tls.key`: The private key to the first certificate in the certificate chain.
        :param pulumi.Input[str] secret_name: SecretName is the name of the secret.
        """
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[pulumi.Input[str]]:
        """
        SecretName is the name of the secret.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class ApmServerSpecHttpTlsSelfSignedCertificateArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 subject_alt_names: Optional[pulumi.Input[Sequence[pulumi.Input['ApmServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArgs']]]] = None):
        """
        SelfSignedCertificate allows configuring the self-signed certificate generated by the operator.
        :param pulumi.Input[bool] disabled: Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
        :param pulumi.Input[Sequence[pulumi.Input['ApmServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArgs']]] subject_alt_names: SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if subject_alt_names is not None:
            pulumi.set(__self__, "subject_alt_names", subject_alt_names)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Disabled indicates that the provisioning of the self-signed certifcate should be disabled.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="subjectAltNames")
    def subject_alt_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApmServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArgs']]]]:
        """
        SubjectAlternativeNames is a list of SANs to include in the generated HTTP TLS certificate.
        """
        return pulumi.get(self, "subject_alt_names")

    @subject_alt_names.setter
    def subject_alt_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApmServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArgs']]]]):
        pulumi.set(self, "subject_alt_names", value)


@pulumi.input_type
class ApmServerSpecHttpTlsSelfSignedCertificateSubjectAltNamesArgs:
    def __init__(__self__, *,
                 dns: Optional[pulumi.Input[str]] = None,
                 ip: Optional[pulumi.Input[str]] = None):
        """
        SubjectAlternativeName represents a SAN entry in a x509 certificate.
        :param pulumi.Input[str] dns: DNS is the DNS name of the subject.
        :param pulumi.Input[str] ip: IP is the IP address of the subject.
        """
        if dns is not None:
            pulumi.set(__self__, "dns", dns)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def dns(self) -> Optional[pulumi.Input[str]]:
        """
        DNS is the DNS name of the subject.
        """
        return pulumi.get(self, "dns")

    @dns.setter
    def dns(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        """
        IP is the IP address of the subject.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)


@pulumi.input_type
class ApmServerSpecKibanaRefArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 namespace: Optional[pulumi.Input[str]] = None):
        """
        KibanaRef is a reference to a Kibana instance running in the same Kubernetes cluster. It allows APM agent central configuration management in Kibana.
        :param pulumi.Input[str] name: Name of the Kubernetes object.
        :param pulumi.Input[str] namespace: Namespace of the Kubernetes object. If empty, defaults to the current namespace.
        """
        pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the Kubernetes object.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the Kubernetes object. If empty, defaults to the current namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)


@pulumi.input_type
class ApmServerSpecSecureSettingsArgs:
    def __init__(__self__, *,
                 secret_name: pulumi.Input[str],
                 entries: Optional[pulumi.Input[Sequence[pulumi.Input['ApmServerSpecSecureSettingsEntriesArgs']]]] = None):
        """
        SecretSource defines a data source based on a Kubernetes Secret.
        :param pulumi.Input[str] secret_name: SecretName is the name of the secret.
        :param pulumi.Input[Sequence[pulumi.Input['ApmServerSpecSecureSettingsEntriesArgs']]] entries: Entries define how to project each key-value pair in the secret to filesystem paths. If not defined, all keys will be projected to similarly named paths in the filesystem. If defined, only the specified keys will be projected to the corresponding paths.
        """
        pulumi.set(__self__, "secret_name", secret_name)
        if entries is not None:
            pulumi.set(__self__, "entries", entries)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        SecretName is the name of the secret.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)

    @property
    @pulumi.getter
    def entries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApmServerSpecSecureSettingsEntriesArgs']]]]:
        """
        Entries define how to project each key-value pair in the secret to filesystem paths. If not defined, all keys will be projected to similarly named paths in the filesystem. If defined, only the specified keys will be projected to the corresponding paths.
        """
        return pulumi.get(self, "entries")

    @entries.setter
    def entries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApmServerSpecSecureSettingsEntriesArgs']]]]):
        pulumi.set(self, "entries", value)


@pulumi.input_type
class ApmServerSpecSecureSettingsEntriesArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 path: Optional[pulumi.Input[str]] = None):
        """
        KeyToPath defines how to map a key in a Secret object to a filesystem path.
        :param pulumi.Input[str] key: Key is the key contained in the secret.
        :param pulumi.Input[str] path: Path is the relative file path to map the key to. Path must not be an absolute file path and must not contain any ".." components.
        """
        pulumi.set(__self__, "key", key)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Key is the key contained in the secret.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Path is the relative file path to map the key to. Path must not be an absolute file path and must not contain any ".." components.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


@pulumi.input_type
class ApmServerStatusArgs:
    def __init__(__self__, *,
                 available_nodes: Optional[pulumi.Input[int]] = None,
                 elasticsearch_association_status: Optional[pulumi.Input[str]] = None,
                 health: Optional[pulumi.Input[str]] = None,
                 kibana_association_status: Optional[pulumi.Input[str]] = None,
                 secret_token_secret: Optional[pulumi.Input[str]] = None,
                 service: Optional[pulumi.Input[str]] = None):
        """
        ApmServerStatus defines the observed state of ApmServer
        :param pulumi.Input[str] elasticsearch_association_status: ElasticsearchAssociationStatus is the status of any auto-linking to Elasticsearch clusters.
        :param pulumi.Input[str] health: ApmServerHealth expresses the status of the Apm Server instances.
        :param pulumi.Input[str] kibana_association_status: KibanaAssociationStatus is the status of any auto-linking to Kibana.
        :param pulumi.Input[str] secret_token_secret: SecretTokenSecretName is the name of the Secret that contains the secret token
        :param pulumi.Input[str] service: ExternalService is the name of the service the agents should connect to.
        """
        if available_nodes is not None:
            pulumi.set(__self__, "available_nodes", available_nodes)
        if elasticsearch_association_status is not None:
            pulumi.set(__self__, "elasticsearch_association_status", elasticsearch_association_status)
        if health is not None:
            pulumi.set(__self__, "health", health)
        if kibana_association_status is not None:
            pulumi.set(__self__, "kibana_association_status", kibana_association_status)
        if secret_token_secret is not None:
            pulumi.set(__self__, "secret_token_secret", secret_token_secret)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter(name="availableNodes")
    def available_nodes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "available_nodes")

    @available_nodes.setter
    def available_nodes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "available_nodes", value)

    @property
    @pulumi.getter(name="elasticsearchAssociationStatus")
    def elasticsearch_association_status(self) -> Optional[pulumi.Input[str]]:
        """
        ElasticsearchAssociationStatus is the status of any auto-linking to Elasticsearch clusters.
        """
        return pulumi.get(self, "elasticsearch_association_status")

    @elasticsearch_association_status.setter
    def elasticsearch_association_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "elasticsearch_association_status", value)

    @property
    @pulumi.getter
    def health(self) -> Optional[pulumi.Input[str]]:
        """
        ApmServerHealth expresses the status of the Apm Server instances.
        """
        return pulumi.get(self, "health")

    @health.setter
    def health(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "health", value)

    @property
    @pulumi.getter(name="kibanaAssociationStatus")
    def kibana_association_status(self) -> Optional[pulumi.Input[str]]:
        """
        KibanaAssociationStatus is the status of any auto-linking to Kibana.
        """
        return pulumi.get(self, "kibana_association_status")

    @kibana_association_status.setter
    def kibana_association_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kibana_association_status", value)

    @property
    @pulumi.getter(name="secretTokenSecret")
    def secret_token_secret(self) -> Optional[pulumi.Input[str]]:
        """
        SecretTokenSecretName is the name of the Secret that contains the secret token
        """
        return pulumi.get(self, "secret_token_secret")

    @secret_token_secret.setter
    def secret_token_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_token_secret", value)

    @property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[str]]:
        """
        ExternalService is the name of the service the agents should connect to.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service", value)


