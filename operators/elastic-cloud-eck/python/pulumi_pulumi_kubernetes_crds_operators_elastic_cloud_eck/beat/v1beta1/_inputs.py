# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from ... import _utilities, _tables

__all__ = [
    'BeatSpecArgs',
    'BeatSpecConfigRefArgs',
    'BeatSpecDaemonSetArgs',
    'BeatSpecDeploymentArgs',
    'BeatSpecDeploymentStrategyArgs',
    'BeatSpecDeploymentStrategyRollingUpdateArgs',
    'BeatSpecDeploymentStrategyRollingUpdateMaxSurgeArgs',
    'BeatSpecDeploymentStrategyRollingUpdateMaxUnavailableArgs',
    'BeatSpecElasticsearchRefArgs',
    'BeatSpecKibanaRefArgs',
    'BeatSpecSecureSettingsArgs',
    'BeatSpecSecureSettingsEntriesArgs',
    'BeatStatusArgs',
]

@pulumi.input_type
class BeatSpecArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 version: pulumi.Input[str],
                 config: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 config_ref: Optional[pulumi.Input['BeatSpecConfigRefArgs']] = None,
                 daemon_set: Optional[pulumi.Input['BeatSpecDaemonSetArgs']] = None,
                 deployment: Optional[pulumi.Input['BeatSpecDeploymentArgs']] = None,
                 elasticsearch_ref: Optional[pulumi.Input['BeatSpecElasticsearchRefArgs']] = None,
                 image: Optional[pulumi.Input[str]] = None,
                 kibana_ref: Optional[pulumi.Input['BeatSpecKibanaRefArgs']] = None,
                 secure_settings: Optional[pulumi.Input[Sequence[pulumi.Input['BeatSpecSecureSettingsArgs']]]] = None,
                 service_account_name: Optional[pulumi.Input[str]] = None):
        """
        BeatSpec defines the desired state of a Beat.
        :param pulumi.Input[str] type: Type is the type of the Beat to deploy (filebeat, metricbeat, heartbeat, auditbeat, journalbeat, packetbeat, etc.). Any string can be used, but well-known types will have the image field defaulted and have the appropriate Elasticsearch roles created automatically. It also allows for dashboard setup when combined with a `KibanaRef`.
        :param pulumi.Input[str] version: Version of the Beat.
        :param pulumi.Input[Mapping[str, Any]] config: Config holds the Beat configuration. At most one of [`Config`, `ConfigRef`] can be specified.
        :param pulumi.Input['BeatSpecConfigRefArgs'] config_ref: ConfigRef contains a reference to an existing Kubernetes Secret holding the Beat configuration. Beat settings must be specified as yaml, under a single "beat.yml" entry. At most one of [`Config`, `ConfigRef`] can be specified.
        :param pulumi.Input['BeatSpecDaemonSetArgs'] daemon_set: DaemonSet specifies the Beat should be deployed as a DaemonSet, and allows providing its spec. Cannot be used along with `deployment`. If both are absent a default for the Type is used.
        :param pulumi.Input['BeatSpecDeploymentArgs'] deployment: Deployment specifies the Beat should be deployed as a Deployment, and allows providing its spec. Cannot be used along with `daemonSet`. If both are absent a default for the Type is used.
        :param pulumi.Input['BeatSpecElasticsearchRefArgs'] elasticsearch_ref: ElasticsearchRef is a reference to an Elasticsearch cluster running in the same Kubernetes cluster.
        :param pulumi.Input[str] image: Image is the Beat Docker image to deploy. Version and Type have to match the Beat in the image.
        :param pulumi.Input['BeatSpecKibanaRefArgs'] kibana_ref: KibanaRef is a reference to a Kibana instance running in the same Kubernetes cluster. It allows automatic setup of dashboards and visualizations.
        :param pulumi.Input[Sequence[pulumi.Input['BeatSpecSecureSettingsArgs']]] secure_settings: SecureSettings is a list of references to Kubernetes Secrets containing sensitive configuration options for the Beat. Secrets data can be then referenced in the Beat config using the Secret's keys or as specified in `Entries` field of each SecureSetting.
        :param pulumi.Input[str] service_account_name: ServiceAccountName is used to check access from the current resource to Elasticsearch resource in a different namespace. Can only be used if ECK is enforcing RBAC on references.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "version", version)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if config_ref is not None:
            pulumi.set(__self__, "config_ref", config_ref)
        if daemon_set is not None:
            pulumi.set(__self__, "daemon_set", daemon_set)
        if deployment is not None:
            pulumi.set(__self__, "deployment", deployment)
        if elasticsearch_ref is not None:
            pulumi.set(__self__, "elasticsearch_ref", elasticsearch_ref)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if kibana_ref is not None:
            pulumi.set(__self__, "kibana_ref", kibana_ref)
        if secure_settings is not None:
            pulumi.set(__self__, "secure_settings", secure_settings)
        if service_account_name is not None:
            pulumi.set(__self__, "service_account_name", service_account_name)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type is the type of the Beat to deploy (filebeat, metricbeat, heartbeat, auditbeat, journalbeat, packetbeat, etc.). Any string can be used, but well-known types will have the image field defaulted and have the appropriate Elasticsearch roles created automatically. It also allows for dashboard setup when combined with a `KibanaRef`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[str]:
        """
        Version of the Beat.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[str]):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Config holds the Beat configuration. At most one of [`Config`, `ConfigRef`] can be specified.
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "config", value)

    @property
    @pulumi.getter(name="configRef")
    def config_ref(self) -> Optional[pulumi.Input['BeatSpecConfigRefArgs']]:
        """
        ConfigRef contains a reference to an existing Kubernetes Secret holding the Beat configuration. Beat settings must be specified as yaml, under a single "beat.yml" entry. At most one of [`Config`, `ConfigRef`] can be specified.
        """
        return pulumi.get(self, "config_ref")

    @config_ref.setter
    def config_ref(self, value: Optional[pulumi.Input['BeatSpecConfigRefArgs']]):
        pulumi.set(self, "config_ref", value)

    @property
    @pulumi.getter(name="daemonSet")
    def daemon_set(self) -> Optional[pulumi.Input['BeatSpecDaemonSetArgs']]:
        """
        DaemonSet specifies the Beat should be deployed as a DaemonSet, and allows providing its spec. Cannot be used along with `deployment`. If both are absent a default for the Type is used.
        """
        return pulumi.get(self, "daemon_set")

    @daemon_set.setter
    def daemon_set(self, value: Optional[pulumi.Input['BeatSpecDaemonSetArgs']]):
        pulumi.set(self, "daemon_set", value)

    @property
    @pulumi.getter
    def deployment(self) -> Optional[pulumi.Input['BeatSpecDeploymentArgs']]:
        """
        Deployment specifies the Beat should be deployed as a Deployment, and allows providing its spec. Cannot be used along with `daemonSet`. If both are absent a default for the Type is used.
        """
        return pulumi.get(self, "deployment")

    @deployment.setter
    def deployment(self, value: Optional[pulumi.Input['BeatSpecDeploymentArgs']]):
        pulumi.set(self, "deployment", value)

    @property
    @pulumi.getter(name="elasticsearchRef")
    def elasticsearch_ref(self) -> Optional[pulumi.Input['BeatSpecElasticsearchRefArgs']]:
        """
        ElasticsearchRef is a reference to an Elasticsearch cluster running in the same Kubernetes cluster.
        """
        return pulumi.get(self, "elasticsearch_ref")

    @elasticsearch_ref.setter
    def elasticsearch_ref(self, value: Optional[pulumi.Input['BeatSpecElasticsearchRefArgs']]):
        pulumi.set(self, "elasticsearch_ref", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        Image is the Beat Docker image to deploy. Version and Type have to match the Beat in the image.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="kibanaRef")
    def kibana_ref(self) -> Optional[pulumi.Input['BeatSpecKibanaRefArgs']]:
        """
        KibanaRef is a reference to a Kibana instance running in the same Kubernetes cluster. It allows automatic setup of dashboards and visualizations.
        """
        return pulumi.get(self, "kibana_ref")

    @kibana_ref.setter
    def kibana_ref(self, value: Optional[pulumi.Input['BeatSpecKibanaRefArgs']]):
        pulumi.set(self, "kibana_ref", value)

    @property
    @pulumi.getter(name="secureSettings")
    def secure_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BeatSpecSecureSettingsArgs']]]]:
        """
        SecureSettings is a list of references to Kubernetes Secrets containing sensitive configuration options for the Beat. Secrets data can be then referenced in the Beat config using the Secret's keys or as specified in `Entries` field of each SecureSetting.
        """
        return pulumi.get(self, "secure_settings")

    @secure_settings.setter
    def secure_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BeatSpecSecureSettingsArgs']]]]):
        pulumi.set(self, "secure_settings", value)

    @property
    @pulumi.getter(name="serviceAccountName")
    def service_account_name(self) -> Optional[pulumi.Input[str]]:
        """
        ServiceAccountName is used to check access from the current resource to Elasticsearch resource in a different namespace. Can only be used if ECK is enforcing RBAC on references.
        """
        return pulumi.get(self, "service_account_name")

    @service_account_name.setter
    def service_account_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_account_name", value)


@pulumi.input_type
class BeatSpecConfigRefArgs:
    def __init__(__self__, *,
                 secret_name: Optional[pulumi.Input[str]] = None):
        """
        ConfigRef contains a reference to an existing Kubernetes Secret holding the Beat configuration. Beat settings must be specified as yaml, under a single "beat.yml" entry. At most one of [`Config`, `ConfigRef`] can be specified.
        :param pulumi.Input[str] secret_name: SecretName is the name of the secret.
        """
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[pulumi.Input[str]]:
        """
        SecretName is the name of the secret.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class BeatSpecDaemonSetArgs:
    def __init__(__self__):
        """
        DaemonSet specifies the Beat should be deployed as a DaemonSet, and allows providing its spec. Cannot be used along with `deployment`. If both are absent a default for the Type is used.
        """
        pass


@pulumi.input_type
class BeatSpecDeploymentArgs:
    def __init__(__self__, *,
                 replicas: Optional[pulumi.Input[int]] = None,
                 strategy: Optional[pulumi.Input['BeatSpecDeploymentStrategyArgs']] = None):
        """
        Deployment specifies the Beat should be deployed as a Deployment, and allows providing its spec. Cannot be used along with `daemonSet`. If both are absent a default for the Type is used.
        :param pulumi.Input['BeatSpecDeploymentStrategyArgs'] strategy: DeploymentStrategy describes how to replace existing pods with new ones.
        """
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @property
    @pulumi.getter
    def replicas(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "replicas", value)

    @property
    @pulumi.getter
    def strategy(self) -> Optional[pulumi.Input['BeatSpecDeploymentStrategyArgs']]:
        """
        DeploymentStrategy describes how to replace existing pods with new ones.
        """
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: Optional[pulumi.Input['BeatSpecDeploymentStrategyArgs']]):
        pulumi.set(self, "strategy", value)


@pulumi.input_type
class BeatSpecDeploymentStrategyArgs:
    def __init__(__self__, *,
                 rolling_update: Optional[pulumi.Input['BeatSpecDeploymentStrategyRollingUpdateArgs']] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        DeploymentStrategy describes how to replace existing pods with new ones.
        :param pulumi.Input['BeatSpecDeploymentStrategyRollingUpdateArgs'] rolling_update: Rolling update config params. Present only if DeploymentStrategyType = RollingUpdate. --- TODO: Update this to follow our convention for oneOf, whatever we decide it to be.
        :param pulumi.Input[str] type: Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
        """
        if rolling_update is not None:
            pulumi.set(__self__, "rolling_update", rolling_update)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="rollingUpdate")
    def rolling_update(self) -> Optional[pulumi.Input['BeatSpecDeploymentStrategyRollingUpdateArgs']]:
        """
        Rolling update config params. Present only if DeploymentStrategyType = RollingUpdate. --- TODO: Update this to follow our convention for oneOf, whatever we decide it to be.
        """
        return pulumi.get(self, "rolling_update")

    @rolling_update.setter
    def rolling_update(self, value: Optional[pulumi.Input['BeatSpecDeploymentStrategyRollingUpdateArgs']]):
        pulumi.set(self, "rolling_update", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class BeatSpecDeploymentStrategyRollingUpdateArgs:
    def __init__(__self__, *,
                 max_surge: Optional[pulumi.Input['BeatSpecDeploymentStrategyRollingUpdateMaxSurgeArgs']] = None,
                 max_unavailable: Optional[pulumi.Input['BeatSpecDeploymentStrategyRollingUpdateMaxUnavailableArgs']] = None):
        """
        Rolling update config params. Present only if DeploymentStrategyType = RollingUpdate. --- TODO: Update this to follow our convention for oneOf, whatever we decide it to be.
        :param pulumi.Input['BeatSpecDeploymentStrategyRollingUpdateMaxSurgeArgs'] max_surge: The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up. Defaults to 25%. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods.
        :param pulumi.Input['BeatSpecDeploymentStrategyRollingUpdateMaxUnavailableArgs'] max_unavailable: The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0. Defaults to 25%. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods.
        """
        if max_surge is not None:
            pulumi.set(__self__, "max_surge", max_surge)
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)

    @property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> Optional[pulumi.Input['BeatSpecDeploymentStrategyRollingUpdateMaxSurgeArgs']]:
        """
        The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up. Defaults to 25%. Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time during the update is at most 130% of desired pods.
        """
        return pulumi.get(self, "max_surge")

    @max_surge.setter
    def max_surge(self, value: Optional[pulumi.Input['BeatSpecDeploymentStrategyRollingUpdateMaxSurgeArgs']]):
        pulumi.set(self, "max_surge", value)

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[pulumi.Input['BeatSpecDeploymentStrategyRollingUpdateMaxUnavailableArgs']]:
        """
        The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0. Defaults to 25%. Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old ReplicaSet can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods.
        """
        return pulumi.get(self, "max_unavailable")

    @max_unavailable.setter
    def max_unavailable(self, value: Optional[pulumi.Input['BeatSpecDeploymentStrategyRollingUpdateMaxUnavailableArgs']]):
        pulumi.set(self, "max_unavailable", value)


@pulumi.input_type
class BeatSpecDeploymentStrategyRollingUpdateMaxSurgeArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class BeatSpecDeploymentStrategyRollingUpdateMaxUnavailableArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class BeatSpecElasticsearchRefArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 namespace: Optional[pulumi.Input[str]] = None):
        """
        ElasticsearchRef is a reference to an Elasticsearch cluster running in the same Kubernetes cluster.
        :param pulumi.Input[str] name: Name of the Kubernetes object.
        :param pulumi.Input[str] namespace: Namespace of the Kubernetes object. If empty, defaults to the current namespace.
        """
        pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the Kubernetes object.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the Kubernetes object. If empty, defaults to the current namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)


@pulumi.input_type
class BeatSpecKibanaRefArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 namespace: Optional[pulumi.Input[str]] = None):
        """
        KibanaRef is a reference to a Kibana instance running in the same Kubernetes cluster. It allows automatic setup of dashboards and visualizations.
        :param pulumi.Input[str] name: Name of the Kubernetes object.
        :param pulumi.Input[str] namespace: Namespace of the Kubernetes object. If empty, defaults to the current namespace.
        """
        pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the Kubernetes object.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the Kubernetes object. If empty, defaults to the current namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)


@pulumi.input_type
class BeatSpecSecureSettingsArgs:
    def __init__(__self__, *,
                 secret_name: pulumi.Input[str],
                 entries: Optional[pulumi.Input[Sequence[pulumi.Input['BeatSpecSecureSettingsEntriesArgs']]]] = None):
        """
        SecretSource defines a data source based on a Kubernetes Secret.
        :param pulumi.Input[str] secret_name: SecretName is the name of the secret.
        :param pulumi.Input[Sequence[pulumi.Input['BeatSpecSecureSettingsEntriesArgs']]] entries: Entries define how to project each key-value pair in the secret to filesystem paths. If not defined, all keys will be projected to similarly named paths in the filesystem. If defined, only the specified keys will be projected to the corresponding paths.
        """
        pulumi.set(__self__, "secret_name", secret_name)
        if entries is not None:
            pulumi.set(__self__, "entries", entries)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        SecretName is the name of the secret.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)

    @property
    @pulumi.getter
    def entries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BeatSpecSecureSettingsEntriesArgs']]]]:
        """
        Entries define how to project each key-value pair in the secret to filesystem paths. If not defined, all keys will be projected to similarly named paths in the filesystem. If defined, only the specified keys will be projected to the corresponding paths.
        """
        return pulumi.get(self, "entries")

    @entries.setter
    def entries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BeatSpecSecureSettingsEntriesArgs']]]]):
        pulumi.set(self, "entries", value)


@pulumi.input_type
class BeatSpecSecureSettingsEntriesArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 path: Optional[pulumi.Input[str]] = None):
        """
        KeyToPath defines how to map a key in a Secret object to a filesystem path.
        :param pulumi.Input[str] key: Key is the key contained in the secret.
        :param pulumi.Input[str] path: Path is the relative file path to map the key to. Path must not be an absolute file path and must not contain any ".." components.
        """
        pulumi.set(__self__, "key", key)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Key is the key contained in the secret.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Path is the relative file path to map the key to. Path must not be an absolute file path and must not contain any ".." components.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


@pulumi.input_type
class BeatStatusArgs:
    def __init__(__self__, *,
                 available_nodes: Optional[pulumi.Input[int]] = None,
                 elasticsearch_association_status: Optional[pulumi.Input[str]] = None,
                 expected_nodes: Optional[pulumi.Input[int]] = None,
                 health: Optional[pulumi.Input[str]] = None,
                 kibana_association_status: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        BeatStatus defines the observed state of a Beat.
        :param pulumi.Input[str] elasticsearch_association_status: AssociationStatus is the status of an association resource.
        :param pulumi.Input[str] kibana_association_status: AssociationStatus is the status of an association resource.
        :param pulumi.Input[str] version: Version of the stack resource currently running. During version upgrades, multiple versions may run in parallel: this value specifies the lowest version currently running.
        """
        if available_nodes is not None:
            pulumi.set(__self__, "available_nodes", available_nodes)
        if elasticsearch_association_status is not None:
            pulumi.set(__self__, "elasticsearch_association_status", elasticsearch_association_status)
        if expected_nodes is not None:
            pulumi.set(__self__, "expected_nodes", expected_nodes)
        if health is not None:
            pulumi.set(__self__, "health", health)
        if kibana_association_status is not None:
            pulumi.set(__self__, "kibana_association_status", kibana_association_status)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="availableNodes")
    def available_nodes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "available_nodes")

    @available_nodes.setter
    def available_nodes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "available_nodes", value)

    @property
    @pulumi.getter(name="elasticsearchAssociationStatus")
    def elasticsearch_association_status(self) -> Optional[pulumi.Input[str]]:
        """
        AssociationStatus is the status of an association resource.
        """
        return pulumi.get(self, "elasticsearch_association_status")

    @elasticsearch_association_status.setter
    def elasticsearch_association_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "elasticsearch_association_status", value)

    @property
    @pulumi.getter(name="expectedNodes")
    def expected_nodes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "expected_nodes")

    @expected_nodes.setter
    def expected_nodes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "expected_nodes", value)

    @property
    @pulumi.getter
    def health(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "health")

    @health.setter
    def health(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "health", value)

    @property
    @pulumi.getter(name="kibanaAssociationStatus")
    def kibana_association_status(self) -> Optional[pulumi.Input[str]]:
        """
        AssociationStatus is the status of an association resource.
        """
        return pulumi.get(self, "kibana_association_status")

    @kibana_association_status.setter
    def kibana_association_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kibana_association_status", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of the stack resource currently running. During version upgrades, multiple versions may run in parallel: this value specifies the lowest version currently running.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


