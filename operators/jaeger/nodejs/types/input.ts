// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

import {ObjectMeta} from "../meta/v1";

export namespace jaegertracing {
    export namespace v1 {
        export interface JaegerSpec {
            affinity?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAffinity>;
            agent?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgent>;
            allInOne?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOne>;
            annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            collector?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollector>;
            ingester?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngester>;
            ingress?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngress>;
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            query?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQuery>;
            resources?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecResources>;
            sampling?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecSampling>;
            securityContext?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecSecurityContext>;
            serviceAccount?: pulumi.Input<string>;
            storage?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorage>;
            strategy?: pulumi.Input<string>;
            tolerations?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecTolerations>[]>;
            ui?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecUi>;
            volumeMounts?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumeMounts>[]>;
            volumes?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumes>[]>;
        }

        export interface JaegerSpecAffinity {
            nodeAffinity?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAffinityNodeAffinity>;
            podAffinity?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAffinityPodAffinity>;
            podAntiAffinity?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAffinityPodAntiAffinity>;
        }

        export interface JaegerSpecAffinityNodeAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>;
        }

        export interface JaegerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference>;
            weight: pulumi.Input<number>;
        }

        export interface JaegerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>[]>;
        }

        export interface JaegerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            nodeSelectorTerms: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>[]>;
        }

        export interface JaegerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>[]>;
        }

        export interface JaegerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecAffinityPodAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface JaegerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight: pulumi.Input<number>;
        }

        export interface JaegerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface JaegerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface JaegerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecAffinityPodAntiAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface JaegerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight: pulumi.Input<number>;
        }

        export interface JaegerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface JaegerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface JaegerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecAgent {
            affinity?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentAffinity>;
            annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            config?: pulumi.Input<{[key: string]: any}>;
            image?: pulumi.Input<string>;
            imagePullSecrets?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentImagePullSecrets>[]>;
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            options?: pulumi.Input<{[key: string]: any}>;
            resources?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentResources>;
            securityContext?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentSecurityContext>;
            serviceAccount?: pulumi.Input<string>;
            sidecarSecurityContext?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentSidecarSecurityContext>;
            strategy?: pulumi.Input<string>;
            tolerations?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentTolerations>[]>;
            volumeMounts?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumeMounts>[]>;
            volumes?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumes>[]>;
        }

        export interface JaegerSpecAgentAffinity {
            nodeAffinity?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentAffinityNodeAffinity>;
            podAffinity?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentAffinityPodAffinity>;
            podAntiAffinity?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentAffinityPodAntiAffinity>;
        }

        export interface JaegerSpecAgentAffinityNodeAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>;
        }

        export interface JaegerSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference>;
            weight: pulumi.Input<number>;
        }

        export interface JaegerSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>[]>;
        }

        export interface JaegerSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            nodeSelectorTerms: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>[]>;
        }

        export interface JaegerSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>[]>;
        }

        export interface JaegerSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecAgentAffinityPodAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface JaegerSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight: pulumi.Input<number>;
        }

        export interface JaegerSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecAgentAffinityPodAntiAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface JaegerSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight: pulumi.Input<number>;
        }

        export interface JaegerSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecAgentImagePullSecrets {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentResources {
            limits?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            requests?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecAgentSecurityContext {
            fsGroup?: pulumi.Input<number>;
            fsGroupChangePolicy?: pulumi.Input<string>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentSecurityContextSeLinuxOptions>;
            supplementalGroups?: pulumi.Input<pulumi.Input<number>[]>;
            sysctls?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentSecurityContextSysctls>[]>;
            windowsOptions?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentSecurityContextWindowsOptions>;
        }

        export interface JaegerSpecAgentSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentSecurityContextSysctls {
            name: pulumi.Input<string>;
            value: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
            runAsUserName?: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentSidecarSecurityContext {
            allowPrivilegeEscalation?: pulumi.Input<boolean>;
            capabilities?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentSidecarSecurityContextCapabilities>;
            privileged?: pulumi.Input<boolean>;
            procMount?: pulumi.Input<string>;
            readOnlyRootFilesystem?: pulumi.Input<boolean>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentSidecarSecurityContextSeLinuxOptions>;
            windowsOptions?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentSidecarSecurityContextWindowsOptions>;
        }

        export interface JaegerSpecAgentSidecarSecurityContextCapabilities {
            add?: pulumi.Input<pulumi.Input<string>[]>;
            drop?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecAgentSidecarSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentSidecarSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
            runAsUserName?: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentTolerations {
            effect?: pulumi.Input<string>;
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            tolerationSeconds?: pulumi.Input<number>;
            value?: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentVolumeMounts {
            mountPath: pulumi.Input<string>;
            mountPropagation?: pulumi.Input<string>;
            name: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            subPath?: pulumi.Input<string>;
            subPathExpr?: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentVolumes {
            awsElasticBlockStore?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesAwsElasticBlockStore>;
            azureDisk?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesAzureDisk>;
            azureFile?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesAzureFile>;
            cephfs?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesCephfs>;
            cinder?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesCinder>;
            configMap?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesConfigMap>;
            csi?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesCsi>;
            downwardAPI?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesDownwardAPI>;
            emptyDir?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesEmptyDir>;
            fc?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesFc>;
            flexVolume?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesFlexVolume>;
            flocker?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesFlocker>;
            gcePersistentDisk?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesGcePersistentDisk>;
            gitRepo?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesGitRepo>;
            glusterfs?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesGlusterfs>;
            hostPath?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesHostPath>;
            iscsi?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesIscsi>;
            name: pulumi.Input<string>;
            nfs?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesNfs>;
            persistentVolumeClaim?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesPersistentVolumeClaim>;
            photonPersistentDisk?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesPhotonPersistentDisk>;
            portworxVolume?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesPortworxVolume>;
            projected?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesProjected>;
            quobyte?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesQuobyte>;
            rbd?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesRbd>;
            scaleIO?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesScaleIO>;
            secret?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesSecret>;
            storageos?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesStorageos>;
            vsphereVolume?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesVsphereVolume>;
        }

        export interface JaegerSpecAgentVolumesAwsElasticBlockStore {
            fsType?: pulumi.Input<string>;
            partition?: pulumi.Input<number>;
            readOnly?: pulumi.Input<boolean>;
            volumeID: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentVolumesAzureDisk {
            cachingMode?: pulumi.Input<string>;
            diskName: pulumi.Input<string>;
            diskURI: pulumi.Input<string>;
            fsType?: pulumi.Input<string>;
            kind?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecAgentVolumesAzureFile {
            readOnly?: pulumi.Input<boolean>;
            secretName: pulumi.Input<string>;
            shareName: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentVolumesCephfs {
            monitors: pulumi.Input<pulumi.Input<string>[]>;
            path?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretFile?: pulumi.Input<string>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesCephfsSecretRef>;
            user?: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentVolumesCephfsSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentVolumesCinder {
            fsType?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesCinderSecretRef>;
            volumeID: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentVolumesCinderSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentVolumesConfigMap {
            defaultMode?: pulumi.Input<number>;
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesConfigMapItems>[]>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecAgentVolumesConfigMapItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentVolumesCsi {
            driver: pulumi.Input<string>;
            fsType?: pulumi.Input<string>;
            nodePublishSecretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesCsiNodePublishSecretRef>;
            readOnly?: pulumi.Input<boolean>;
            volumeAttributes?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecAgentVolumesCsiNodePublishSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentVolumesDownwardAPI {
            defaultMode?: pulumi.Input<number>;
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesDownwardAPIItems>[]>;
        }

        export interface JaegerSpecAgentVolumesDownwardAPIItems {
            fieldRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesDownwardAPIItemsFieldRef>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
            resourceFieldRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesDownwardAPIItemsResourceFieldRef>;
        }

        export interface JaegerSpecAgentVolumesDownwardAPIItemsFieldRef {
            apiVersion?: pulumi.Input<string>;
            fieldPath: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentVolumesDownwardAPIItemsResourceFieldRef {
            containerName?: pulumi.Input<string>;
            divisor?: pulumi.Input<string>;
            resource: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentVolumesEmptyDir {
            medium?: pulumi.Input<string>;
            sizeLimit?: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentVolumesFc {
            fsType?: pulumi.Input<string>;
            lun?: pulumi.Input<number>;
            readOnly?: pulumi.Input<boolean>;
            targetWWNs?: pulumi.Input<pulumi.Input<string>[]>;
            wwids?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecAgentVolumesFlexVolume {
            driver: pulumi.Input<string>;
            fsType?: pulumi.Input<string>;
            options?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesFlexVolumeSecretRef>;
        }

        export interface JaegerSpecAgentVolumesFlexVolumeSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentVolumesFlocker {
            datasetName?: pulumi.Input<string>;
            datasetUUID?: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentVolumesGcePersistentDisk {
            fsType?: pulumi.Input<string>;
            partition?: pulumi.Input<number>;
            pdName: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecAgentVolumesGitRepo {
            directory?: pulumi.Input<string>;
            repository: pulumi.Input<string>;
            revision?: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentVolumesGlusterfs {
            endpoints: pulumi.Input<string>;
            path: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecAgentVolumesHostPath {
            path: pulumi.Input<string>;
            type?: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentVolumesIscsi {
            chapAuthDiscovery?: pulumi.Input<boolean>;
            chapAuthSession?: pulumi.Input<boolean>;
            fsType?: pulumi.Input<string>;
            initiatorName?: pulumi.Input<string>;
            iqn: pulumi.Input<string>;
            iscsiInterface?: pulumi.Input<string>;
            lun: pulumi.Input<number>;
            portals?: pulumi.Input<pulumi.Input<string>[]>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesIscsiSecretRef>;
            targetPortal: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentVolumesIscsiSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentVolumesNfs {
            path: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            server: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentVolumesPersistentVolumeClaim {
            claimName: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecAgentVolumesPhotonPersistentDisk {
            fsType?: pulumi.Input<string>;
            pdID: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentVolumesPortworxVolume {
            fsType?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            volumeID: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentVolumesProjected {
            defaultMode?: pulumi.Input<number>;
            sources: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesProjectedSources>[]>;
        }

        export interface JaegerSpecAgentVolumesProjectedSources {
            configMap?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesProjectedSourcesConfigMap>;
            downwardAPI?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesProjectedSourcesDownwardAPI>;
            secret?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesProjectedSourcesSecret>;
            serviceAccountToken?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesProjectedSourcesServiceAccountToken>;
        }

        export interface JaegerSpecAgentVolumesProjectedSourcesConfigMap {
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesProjectedSourcesConfigMapItems>[]>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecAgentVolumesProjectedSourcesConfigMapItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentVolumesProjectedSourcesDownwardAPI {
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesProjectedSourcesDownwardAPIItems>[]>;
        }

        export interface JaegerSpecAgentVolumesProjectedSourcesDownwardAPIItems {
            fieldRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesProjectedSourcesDownwardAPIItemsFieldRef>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
            resourceFieldRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef>;
        }

        export interface JaegerSpecAgentVolumesProjectedSourcesDownwardAPIItemsFieldRef {
            apiVersion?: pulumi.Input<string>;
            fieldPath: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef {
            containerName?: pulumi.Input<string>;
            divisor?: pulumi.Input<string>;
            resource: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentVolumesProjectedSourcesSecret {
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesProjectedSourcesSecretItems>[]>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecAgentVolumesProjectedSourcesSecretItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentVolumesProjectedSourcesServiceAccountToken {
            audience?: pulumi.Input<string>;
            expirationSeconds?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentVolumesQuobyte {
            group?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            registry: pulumi.Input<string>;
            tenant?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
            volume: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentVolumesRbd {
            fsType?: pulumi.Input<string>;
            image: pulumi.Input<string>;
            keyring?: pulumi.Input<string>;
            monitors: pulumi.Input<pulumi.Input<string>[]>;
            pool?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesRbdSecretRef>;
            user?: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentVolumesRbdSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentVolumesScaleIO {
            fsType?: pulumi.Input<string>;
            gateway: pulumi.Input<string>;
            protectionDomain?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesScaleIOSecretRef>;
            sslEnabled?: pulumi.Input<boolean>;
            storageMode?: pulumi.Input<string>;
            storagePool?: pulumi.Input<string>;
            system: pulumi.Input<string>;
            volumeName?: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentVolumesScaleIOSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentVolumesSecret {
            defaultMode?: pulumi.Input<number>;
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesSecretItems>[]>;
            optional?: pulumi.Input<boolean>;
            secretName?: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentVolumesSecretItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentVolumesStorageos {
            fsType?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAgentVolumesStorageosSecretRef>;
            volumeName?: pulumi.Input<string>;
            volumeNamespace?: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentVolumesStorageosSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecAgentVolumesVsphereVolume {
            fsType?: pulumi.Input<string>;
            storagePolicyID?: pulumi.Input<string>;
            storagePolicyName?: pulumi.Input<string>;
            volumePath: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOne {
            affinity?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneAffinity>;
            annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            config?: pulumi.Input<{[key: string]: any}>;
            image?: pulumi.Input<string>;
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            options?: pulumi.Input<{[key: string]: any}>;
            resources?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneResources>;
            securityContext?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneSecurityContext>;
            serviceAccount?: pulumi.Input<string>;
            tolerations?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneTolerations>[]>;
            volumeMounts?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumeMounts>[]>;
            volumes?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumes>[]>;
        }

        export interface JaegerSpecAllInOneAffinity {
            nodeAffinity?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneAffinityNodeAffinity>;
            podAffinity?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneAffinityPodAffinity>;
            podAntiAffinity?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneAffinityPodAntiAffinity>;
        }

        export interface JaegerSpecAllInOneAffinityNodeAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>;
        }

        export interface JaegerSpecAllInOneAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference>;
            weight: pulumi.Input<number>;
        }

        export interface JaegerSpecAllInOneAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>[]>;
        }

        export interface JaegerSpecAllInOneAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecAllInOneAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecAllInOneAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            nodeSelectorTerms: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>[]>;
        }

        export interface JaegerSpecAllInOneAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>[]>;
        }

        export interface JaegerSpecAllInOneAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecAllInOneAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecAllInOneAffinityPodAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface JaegerSpecAllInOneAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight: pulumi.Input<number>;
        }

        export interface JaegerSpecAllInOneAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOneAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecAllInOneAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecAllInOneAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOneAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecAllInOneAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecAllInOneAffinityPodAntiAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface JaegerSpecAllInOneAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight: pulumi.Input<number>;
        }

        export interface JaegerSpecAllInOneAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOneAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecAllInOneAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecAllInOneAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOneAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecAllInOneAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecAllInOneResources {
            limits?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            requests?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecAllInOneSecurityContext {
            fsGroup?: pulumi.Input<number>;
            fsGroupChangePolicy?: pulumi.Input<string>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneSecurityContextSeLinuxOptions>;
            supplementalGroups?: pulumi.Input<pulumi.Input<number>[]>;
            sysctls?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneSecurityContextSysctls>[]>;
            windowsOptions?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneSecurityContextWindowsOptions>;
        }

        export interface JaegerSpecAllInOneSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOneSecurityContextSysctls {
            name: pulumi.Input<string>;
            value: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOneSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
            runAsUserName?: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOneTolerations {
            effect?: pulumi.Input<string>;
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            tolerationSeconds?: pulumi.Input<number>;
            value?: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOneVolumeMounts {
            mountPath: pulumi.Input<string>;
            mountPropagation?: pulumi.Input<string>;
            name: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            subPath?: pulumi.Input<string>;
            subPathExpr?: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOneVolumes {
            awsElasticBlockStore?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesAwsElasticBlockStore>;
            azureDisk?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesAzureDisk>;
            azureFile?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesAzureFile>;
            cephfs?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesCephfs>;
            cinder?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesCinder>;
            configMap?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesConfigMap>;
            csi?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesCsi>;
            downwardAPI?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesDownwardAPI>;
            emptyDir?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesEmptyDir>;
            fc?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesFc>;
            flexVolume?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesFlexVolume>;
            flocker?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesFlocker>;
            gcePersistentDisk?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesGcePersistentDisk>;
            gitRepo?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesGitRepo>;
            glusterfs?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesGlusterfs>;
            hostPath?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesHostPath>;
            iscsi?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesIscsi>;
            name: pulumi.Input<string>;
            nfs?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesNfs>;
            persistentVolumeClaim?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesPersistentVolumeClaim>;
            photonPersistentDisk?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesPhotonPersistentDisk>;
            portworxVolume?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesPortworxVolume>;
            projected?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesProjected>;
            quobyte?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesQuobyte>;
            rbd?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesRbd>;
            scaleIO?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesScaleIO>;
            secret?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesSecret>;
            storageos?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesStorageos>;
            vsphereVolume?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesVsphereVolume>;
        }

        export interface JaegerSpecAllInOneVolumesAwsElasticBlockStore {
            fsType?: pulumi.Input<string>;
            partition?: pulumi.Input<number>;
            readOnly?: pulumi.Input<boolean>;
            volumeID: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOneVolumesAzureDisk {
            cachingMode?: pulumi.Input<string>;
            diskName: pulumi.Input<string>;
            diskURI: pulumi.Input<string>;
            fsType?: pulumi.Input<string>;
            kind?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecAllInOneVolumesAzureFile {
            readOnly?: pulumi.Input<boolean>;
            secretName: pulumi.Input<string>;
            shareName: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOneVolumesCephfs {
            monitors: pulumi.Input<pulumi.Input<string>[]>;
            path?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretFile?: pulumi.Input<string>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesCephfsSecretRef>;
            user?: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOneVolumesCephfsSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOneVolumesCinder {
            fsType?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesCinderSecretRef>;
            volumeID: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOneVolumesCinderSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOneVolumesConfigMap {
            defaultMode?: pulumi.Input<number>;
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesConfigMapItems>[]>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecAllInOneVolumesConfigMapItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOneVolumesCsi {
            driver: pulumi.Input<string>;
            fsType?: pulumi.Input<string>;
            nodePublishSecretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesCsiNodePublishSecretRef>;
            readOnly?: pulumi.Input<boolean>;
            volumeAttributes?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecAllInOneVolumesCsiNodePublishSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOneVolumesDownwardAPI {
            defaultMode?: pulumi.Input<number>;
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesDownwardAPIItems>[]>;
        }

        export interface JaegerSpecAllInOneVolumesDownwardAPIItems {
            fieldRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesDownwardAPIItemsFieldRef>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
            resourceFieldRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesDownwardAPIItemsResourceFieldRef>;
        }

        export interface JaegerSpecAllInOneVolumesDownwardAPIItemsFieldRef {
            apiVersion?: pulumi.Input<string>;
            fieldPath: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOneVolumesDownwardAPIItemsResourceFieldRef {
            containerName?: pulumi.Input<string>;
            divisor?: pulumi.Input<string>;
            resource: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOneVolumesEmptyDir {
            medium?: pulumi.Input<string>;
            sizeLimit?: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOneVolumesFc {
            fsType?: pulumi.Input<string>;
            lun?: pulumi.Input<number>;
            readOnly?: pulumi.Input<boolean>;
            targetWWNs?: pulumi.Input<pulumi.Input<string>[]>;
            wwids?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecAllInOneVolumesFlexVolume {
            driver: pulumi.Input<string>;
            fsType?: pulumi.Input<string>;
            options?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesFlexVolumeSecretRef>;
        }

        export interface JaegerSpecAllInOneVolumesFlexVolumeSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOneVolumesFlocker {
            datasetName?: pulumi.Input<string>;
            datasetUUID?: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOneVolumesGcePersistentDisk {
            fsType?: pulumi.Input<string>;
            partition?: pulumi.Input<number>;
            pdName: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecAllInOneVolumesGitRepo {
            directory?: pulumi.Input<string>;
            repository: pulumi.Input<string>;
            revision?: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOneVolumesGlusterfs {
            endpoints: pulumi.Input<string>;
            path: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecAllInOneVolumesHostPath {
            path: pulumi.Input<string>;
            type?: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOneVolumesIscsi {
            chapAuthDiscovery?: pulumi.Input<boolean>;
            chapAuthSession?: pulumi.Input<boolean>;
            fsType?: pulumi.Input<string>;
            initiatorName?: pulumi.Input<string>;
            iqn: pulumi.Input<string>;
            iscsiInterface?: pulumi.Input<string>;
            lun: pulumi.Input<number>;
            portals?: pulumi.Input<pulumi.Input<string>[]>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesIscsiSecretRef>;
            targetPortal: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOneVolumesIscsiSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOneVolumesNfs {
            path: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            server: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOneVolumesPersistentVolumeClaim {
            claimName: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecAllInOneVolumesPhotonPersistentDisk {
            fsType?: pulumi.Input<string>;
            pdID: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOneVolumesPortworxVolume {
            fsType?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            volumeID: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOneVolumesProjected {
            defaultMode?: pulumi.Input<number>;
            sources: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesProjectedSources>[]>;
        }

        export interface JaegerSpecAllInOneVolumesProjectedSources {
            configMap?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesProjectedSourcesConfigMap>;
            downwardAPI?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesProjectedSourcesDownwardAPI>;
            secret?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesProjectedSourcesSecret>;
            serviceAccountToken?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesProjectedSourcesServiceAccountToken>;
        }

        export interface JaegerSpecAllInOneVolumesProjectedSourcesConfigMap {
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesProjectedSourcesConfigMapItems>[]>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecAllInOneVolumesProjectedSourcesConfigMapItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOneVolumesProjectedSourcesDownwardAPI {
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesProjectedSourcesDownwardAPIItems>[]>;
        }

        export interface JaegerSpecAllInOneVolumesProjectedSourcesDownwardAPIItems {
            fieldRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesProjectedSourcesDownwardAPIItemsFieldRef>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
            resourceFieldRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef>;
        }

        export interface JaegerSpecAllInOneVolumesProjectedSourcesDownwardAPIItemsFieldRef {
            apiVersion?: pulumi.Input<string>;
            fieldPath: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOneVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef {
            containerName?: pulumi.Input<string>;
            divisor?: pulumi.Input<string>;
            resource: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOneVolumesProjectedSourcesSecret {
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesProjectedSourcesSecretItems>[]>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecAllInOneVolumesProjectedSourcesSecretItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOneVolumesProjectedSourcesServiceAccountToken {
            audience?: pulumi.Input<string>;
            expirationSeconds?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOneVolumesQuobyte {
            group?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            registry: pulumi.Input<string>;
            tenant?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
            volume: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOneVolumesRbd {
            fsType?: pulumi.Input<string>;
            image: pulumi.Input<string>;
            keyring?: pulumi.Input<string>;
            monitors: pulumi.Input<pulumi.Input<string>[]>;
            pool?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesRbdSecretRef>;
            user?: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOneVolumesRbdSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOneVolumesScaleIO {
            fsType?: pulumi.Input<string>;
            gateway: pulumi.Input<string>;
            protectionDomain?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesScaleIOSecretRef>;
            sslEnabled?: pulumi.Input<boolean>;
            storageMode?: pulumi.Input<string>;
            storagePool?: pulumi.Input<string>;
            system: pulumi.Input<string>;
            volumeName?: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOneVolumesScaleIOSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOneVolumesSecret {
            defaultMode?: pulumi.Input<number>;
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesSecretItems>[]>;
            optional?: pulumi.Input<boolean>;
            secretName?: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOneVolumesSecretItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOneVolumesStorageos {
            fsType?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecAllInOneVolumesStorageosSecretRef>;
            volumeName?: pulumi.Input<string>;
            volumeNamespace?: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOneVolumesStorageosSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecAllInOneVolumesVsphereVolume {
            fsType?: pulumi.Input<string>;
            storagePolicyID?: pulumi.Input<string>;
            storagePolicyName?: pulumi.Input<string>;
            volumePath: pulumi.Input<string>;
        }

        export interface JaegerSpecCollector {
            affinity?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorAffinity>;
            annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            autoscale?: pulumi.Input<boolean>;
            config?: pulumi.Input<{[key: string]: any}>;
            image?: pulumi.Input<string>;
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            maxReplicas?: pulumi.Input<number>;
            minReplicas?: pulumi.Input<number>;
            options?: pulumi.Input<{[key: string]: any}>;
            replicas?: pulumi.Input<number>;
            resources?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorResources>;
            securityContext?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorSecurityContext>;
            serviceAccount?: pulumi.Input<string>;
            tolerations?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorTolerations>[]>;
            volumeMounts?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumeMounts>[]>;
            volumes?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumes>[]>;
        }

        export interface JaegerSpecCollectorAffinity {
            nodeAffinity?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorAffinityNodeAffinity>;
            podAffinity?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorAffinityPodAffinity>;
            podAntiAffinity?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorAffinityPodAntiAffinity>;
        }

        export interface JaegerSpecCollectorAffinityNodeAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>;
        }

        export interface JaegerSpecCollectorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference>;
            weight: pulumi.Input<number>;
        }

        export interface JaegerSpecCollectorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>[]>;
        }

        export interface JaegerSpecCollectorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecCollectorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecCollectorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            nodeSelectorTerms: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>[]>;
        }

        export interface JaegerSpecCollectorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>[]>;
        }

        export interface JaegerSpecCollectorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecCollectorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecCollectorAffinityPodAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface JaegerSpecCollectorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight: pulumi.Input<number>;
        }

        export interface JaegerSpecCollectorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface JaegerSpecCollectorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecCollectorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecCollectorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface JaegerSpecCollectorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecCollectorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecCollectorAffinityPodAntiAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface JaegerSpecCollectorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight: pulumi.Input<number>;
        }

        export interface JaegerSpecCollectorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface JaegerSpecCollectorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecCollectorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecCollectorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface JaegerSpecCollectorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecCollectorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecCollectorResources {
            limits?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            requests?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecCollectorSecurityContext {
            fsGroup?: pulumi.Input<number>;
            fsGroupChangePolicy?: pulumi.Input<string>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorSecurityContextSeLinuxOptions>;
            supplementalGroups?: pulumi.Input<pulumi.Input<number>[]>;
            sysctls?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorSecurityContextSysctls>[]>;
            windowsOptions?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorSecurityContextWindowsOptions>;
        }

        export interface JaegerSpecCollectorSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface JaegerSpecCollectorSecurityContextSysctls {
            name: pulumi.Input<string>;
            value: pulumi.Input<string>;
        }

        export interface JaegerSpecCollectorSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
            runAsUserName?: pulumi.Input<string>;
        }

        export interface JaegerSpecCollectorTolerations {
            effect?: pulumi.Input<string>;
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            tolerationSeconds?: pulumi.Input<number>;
            value?: pulumi.Input<string>;
        }

        export interface JaegerSpecCollectorVolumeMounts {
            mountPath: pulumi.Input<string>;
            mountPropagation?: pulumi.Input<string>;
            name: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            subPath?: pulumi.Input<string>;
            subPathExpr?: pulumi.Input<string>;
        }

        export interface JaegerSpecCollectorVolumes {
            awsElasticBlockStore?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesAwsElasticBlockStore>;
            azureDisk?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesAzureDisk>;
            azureFile?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesAzureFile>;
            cephfs?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesCephfs>;
            cinder?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesCinder>;
            configMap?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesConfigMap>;
            csi?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesCsi>;
            downwardAPI?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesDownwardAPI>;
            emptyDir?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesEmptyDir>;
            fc?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesFc>;
            flexVolume?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesFlexVolume>;
            flocker?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesFlocker>;
            gcePersistentDisk?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesGcePersistentDisk>;
            gitRepo?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesGitRepo>;
            glusterfs?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesGlusterfs>;
            hostPath?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesHostPath>;
            iscsi?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesIscsi>;
            name: pulumi.Input<string>;
            nfs?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesNfs>;
            persistentVolumeClaim?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesPersistentVolumeClaim>;
            photonPersistentDisk?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesPhotonPersistentDisk>;
            portworxVolume?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesPortworxVolume>;
            projected?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesProjected>;
            quobyte?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesQuobyte>;
            rbd?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesRbd>;
            scaleIO?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesScaleIO>;
            secret?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesSecret>;
            storageos?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesStorageos>;
            vsphereVolume?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesVsphereVolume>;
        }

        export interface JaegerSpecCollectorVolumesAwsElasticBlockStore {
            fsType?: pulumi.Input<string>;
            partition?: pulumi.Input<number>;
            readOnly?: pulumi.Input<boolean>;
            volumeID: pulumi.Input<string>;
        }

        export interface JaegerSpecCollectorVolumesAzureDisk {
            cachingMode?: pulumi.Input<string>;
            diskName: pulumi.Input<string>;
            diskURI: pulumi.Input<string>;
            fsType?: pulumi.Input<string>;
            kind?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecCollectorVolumesAzureFile {
            readOnly?: pulumi.Input<boolean>;
            secretName: pulumi.Input<string>;
            shareName: pulumi.Input<string>;
        }

        export interface JaegerSpecCollectorVolumesCephfs {
            monitors: pulumi.Input<pulumi.Input<string>[]>;
            path?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretFile?: pulumi.Input<string>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesCephfsSecretRef>;
            user?: pulumi.Input<string>;
        }

        export interface JaegerSpecCollectorVolumesCephfsSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecCollectorVolumesCinder {
            fsType?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesCinderSecretRef>;
            volumeID: pulumi.Input<string>;
        }

        export interface JaegerSpecCollectorVolumesCinderSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecCollectorVolumesConfigMap {
            defaultMode?: pulumi.Input<number>;
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesConfigMapItems>[]>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecCollectorVolumesConfigMapItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecCollectorVolumesCsi {
            driver: pulumi.Input<string>;
            fsType?: pulumi.Input<string>;
            nodePublishSecretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesCsiNodePublishSecretRef>;
            readOnly?: pulumi.Input<boolean>;
            volumeAttributes?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecCollectorVolumesCsiNodePublishSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecCollectorVolumesDownwardAPI {
            defaultMode?: pulumi.Input<number>;
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesDownwardAPIItems>[]>;
        }

        export interface JaegerSpecCollectorVolumesDownwardAPIItems {
            fieldRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesDownwardAPIItemsFieldRef>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
            resourceFieldRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesDownwardAPIItemsResourceFieldRef>;
        }

        export interface JaegerSpecCollectorVolumesDownwardAPIItemsFieldRef {
            apiVersion?: pulumi.Input<string>;
            fieldPath: pulumi.Input<string>;
        }

        export interface JaegerSpecCollectorVolumesDownwardAPIItemsResourceFieldRef {
            containerName?: pulumi.Input<string>;
            divisor?: pulumi.Input<string>;
            resource: pulumi.Input<string>;
        }

        export interface JaegerSpecCollectorVolumesEmptyDir {
            medium?: pulumi.Input<string>;
            sizeLimit?: pulumi.Input<string>;
        }

        export interface JaegerSpecCollectorVolumesFc {
            fsType?: pulumi.Input<string>;
            lun?: pulumi.Input<number>;
            readOnly?: pulumi.Input<boolean>;
            targetWWNs?: pulumi.Input<pulumi.Input<string>[]>;
            wwids?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecCollectorVolumesFlexVolume {
            driver: pulumi.Input<string>;
            fsType?: pulumi.Input<string>;
            options?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesFlexVolumeSecretRef>;
        }

        export interface JaegerSpecCollectorVolumesFlexVolumeSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecCollectorVolumesFlocker {
            datasetName?: pulumi.Input<string>;
            datasetUUID?: pulumi.Input<string>;
        }

        export interface JaegerSpecCollectorVolumesGcePersistentDisk {
            fsType?: pulumi.Input<string>;
            partition?: pulumi.Input<number>;
            pdName: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecCollectorVolumesGitRepo {
            directory?: pulumi.Input<string>;
            repository: pulumi.Input<string>;
            revision?: pulumi.Input<string>;
        }

        export interface JaegerSpecCollectorVolumesGlusterfs {
            endpoints: pulumi.Input<string>;
            path: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecCollectorVolumesHostPath {
            path: pulumi.Input<string>;
            type?: pulumi.Input<string>;
        }

        export interface JaegerSpecCollectorVolumesIscsi {
            chapAuthDiscovery?: pulumi.Input<boolean>;
            chapAuthSession?: pulumi.Input<boolean>;
            fsType?: pulumi.Input<string>;
            initiatorName?: pulumi.Input<string>;
            iqn: pulumi.Input<string>;
            iscsiInterface?: pulumi.Input<string>;
            lun: pulumi.Input<number>;
            portals?: pulumi.Input<pulumi.Input<string>[]>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesIscsiSecretRef>;
            targetPortal: pulumi.Input<string>;
        }

        export interface JaegerSpecCollectorVolumesIscsiSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecCollectorVolumesNfs {
            path: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            server: pulumi.Input<string>;
        }

        export interface JaegerSpecCollectorVolumesPersistentVolumeClaim {
            claimName: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecCollectorVolumesPhotonPersistentDisk {
            fsType?: pulumi.Input<string>;
            pdID: pulumi.Input<string>;
        }

        export interface JaegerSpecCollectorVolumesPortworxVolume {
            fsType?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            volumeID: pulumi.Input<string>;
        }

        export interface JaegerSpecCollectorVolumesProjected {
            defaultMode?: pulumi.Input<number>;
            sources: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesProjectedSources>[]>;
        }

        export interface JaegerSpecCollectorVolumesProjectedSources {
            configMap?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesProjectedSourcesConfigMap>;
            downwardAPI?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesProjectedSourcesDownwardAPI>;
            secret?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesProjectedSourcesSecret>;
            serviceAccountToken?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesProjectedSourcesServiceAccountToken>;
        }

        export interface JaegerSpecCollectorVolumesProjectedSourcesConfigMap {
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesProjectedSourcesConfigMapItems>[]>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecCollectorVolumesProjectedSourcesConfigMapItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecCollectorVolumesProjectedSourcesDownwardAPI {
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesProjectedSourcesDownwardAPIItems>[]>;
        }

        export interface JaegerSpecCollectorVolumesProjectedSourcesDownwardAPIItems {
            fieldRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesProjectedSourcesDownwardAPIItemsFieldRef>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
            resourceFieldRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef>;
        }

        export interface JaegerSpecCollectorVolumesProjectedSourcesDownwardAPIItemsFieldRef {
            apiVersion?: pulumi.Input<string>;
            fieldPath: pulumi.Input<string>;
        }

        export interface JaegerSpecCollectorVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef {
            containerName?: pulumi.Input<string>;
            divisor?: pulumi.Input<string>;
            resource: pulumi.Input<string>;
        }

        export interface JaegerSpecCollectorVolumesProjectedSourcesSecret {
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesProjectedSourcesSecretItems>[]>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecCollectorVolumesProjectedSourcesSecretItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecCollectorVolumesProjectedSourcesServiceAccountToken {
            audience?: pulumi.Input<string>;
            expirationSeconds?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecCollectorVolumesQuobyte {
            group?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            registry: pulumi.Input<string>;
            tenant?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
            volume: pulumi.Input<string>;
        }

        export interface JaegerSpecCollectorVolumesRbd {
            fsType?: pulumi.Input<string>;
            image: pulumi.Input<string>;
            keyring?: pulumi.Input<string>;
            monitors: pulumi.Input<pulumi.Input<string>[]>;
            pool?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesRbdSecretRef>;
            user?: pulumi.Input<string>;
        }

        export interface JaegerSpecCollectorVolumesRbdSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecCollectorVolumesScaleIO {
            fsType?: pulumi.Input<string>;
            gateway: pulumi.Input<string>;
            protectionDomain?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesScaleIOSecretRef>;
            sslEnabled?: pulumi.Input<boolean>;
            storageMode?: pulumi.Input<string>;
            storagePool?: pulumi.Input<string>;
            system: pulumi.Input<string>;
            volumeName?: pulumi.Input<string>;
        }

        export interface JaegerSpecCollectorVolumesScaleIOSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecCollectorVolumesSecret {
            defaultMode?: pulumi.Input<number>;
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesSecretItems>[]>;
            optional?: pulumi.Input<boolean>;
            secretName?: pulumi.Input<string>;
        }

        export interface JaegerSpecCollectorVolumesSecretItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecCollectorVolumesStorageos {
            fsType?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecCollectorVolumesStorageosSecretRef>;
            volumeName?: pulumi.Input<string>;
            volumeNamespace?: pulumi.Input<string>;
        }

        export interface JaegerSpecCollectorVolumesStorageosSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecCollectorVolumesVsphereVolume {
            fsType?: pulumi.Input<string>;
            storagePolicyID?: pulumi.Input<string>;
            storagePolicyName?: pulumi.Input<string>;
            volumePath: pulumi.Input<string>;
        }

        export interface JaegerSpecIngester {
            affinity?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterAffinity>;
            annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            autoscale?: pulumi.Input<boolean>;
            config?: pulumi.Input<{[key: string]: any}>;
            image?: pulumi.Input<string>;
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            maxReplicas?: pulumi.Input<number>;
            minReplicas?: pulumi.Input<number>;
            options?: pulumi.Input<{[key: string]: any}>;
            replicas?: pulumi.Input<number>;
            resources?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterResources>;
            securityContext?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterSecurityContext>;
            serviceAccount?: pulumi.Input<string>;
            tolerations?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterTolerations>[]>;
            volumeMounts?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumeMounts>[]>;
            volumes?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumes>[]>;
        }

        export interface JaegerSpecIngesterAffinity {
            nodeAffinity?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterAffinityNodeAffinity>;
            podAffinity?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterAffinityPodAffinity>;
            podAntiAffinity?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterAffinityPodAntiAffinity>;
        }

        export interface JaegerSpecIngesterAffinityNodeAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>;
        }

        export interface JaegerSpecIngesterAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference>;
            weight: pulumi.Input<number>;
        }

        export interface JaegerSpecIngesterAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>[]>;
        }

        export interface JaegerSpecIngesterAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecIngesterAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecIngesterAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            nodeSelectorTerms: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>[]>;
        }

        export interface JaegerSpecIngesterAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>[]>;
        }

        export interface JaegerSpecIngesterAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecIngesterAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecIngesterAffinityPodAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface JaegerSpecIngesterAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight: pulumi.Input<number>;
        }

        export interface JaegerSpecIngesterAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface JaegerSpecIngesterAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecIngesterAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecIngesterAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface JaegerSpecIngesterAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecIngesterAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecIngesterAffinityPodAntiAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface JaegerSpecIngesterAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight: pulumi.Input<number>;
        }

        export interface JaegerSpecIngesterAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface JaegerSpecIngesterAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecIngesterAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecIngesterAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface JaegerSpecIngesterAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecIngesterAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecIngesterResources {
            limits?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            requests?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecIngesterSecurityContext {
            fsGroup?: pulumi.Input<number>;
            fsGroupChangePolicy?: pulumi.Input<string>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterSecurityContextSeLinuxOptions>;
            supplementalGroups?: pulumi.Input<pulumi.Input<number>[]>;
            sysctls?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterSecurityContextSysctls>[]>;
            windowsOptions?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterSecurityContextWindowsOptions>;
        }

        export interface JaegerSpecIngesterSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface JaegerSpecIngesterSecurityContextSysctls {
            name: pulumi.Input<string>;
            value: pulumi.Input<string>;
        }

        export interface JaegerSpecIngesterSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
            runAsUserName?: pulumi.Input<string>;
        }

        export interface JaegerSpecIngesterTolerations {
            effect?: pulumi.Input<string>;
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            tolerationSeconds?: pulumi.Input<number>;
            value?: pulumi.Input<string>;
        }

        export interface JaegerSpecIngesterVolumeMounts {
            mountPath: pulumi.Input<string>;
            mountPropagation?: pulumi.Input<string>;
            name: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            subPath?: pulumi.Input<string>;
            subPathExpr?: pulumi.Input<string>;
        }

        export interface JaegerSpecIngesterVolumes {
            awsElasticBlockStore?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesAwsElasticBlockStore>;
            azureDisk?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesAzureDisk>;
            azureFile?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesAzureFile>;
            cephfs?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesCephfs>;
            cinder?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesCinder>;
            configMap?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesConfigMap>;
            csi?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesCsi>;
            downwardAPI?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesDownwardAPI>;
            emptyDir?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesEmptyDir>;
            fc?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesFc>;
            flexVolume?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesFlexVolume>;
            flocker?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesFlocker>;
            gcePersistentDisk?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesGcePersistentDisk>;
            gitRepo?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesGitRepo>;
            glusterfs?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesGlusterfs>;
            hostPath?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesHostPath>;
            iscsi?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesIscsi>;
            name: pulumi.Input<string>;
            nfs?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesNfs>;
            persistentVolumeClaim?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesPersistentVolumeClaim>;
            photonPersistentDisk?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesPhotonPersistentDisk>;
            portworxVolume?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesPortworxVolume>;
            projected?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesProjected>;
            quobyte?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesQuobyte>;
            rbd?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesRbd>;
            scaleIO?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesScaleIO>;
            secret?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesSecret>;
            storageos?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesStorageos>;
            vsphereVolume?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesVsphereVolume>;
        }

        export interface JaegerSpecIngesterVolumesAwsElasticBlockStore {
            fsType?: pulumi.Input<string>;
            partition?: pulumi.Input<number>;
            readOnly?: pulumi.Input<boolean>;
            volumeID: pulumi.Input<string>;
        }

        export interface JaegerSpecIngesterVolumesAzureDisk {
            cachingMode?: pulumi.Input<string>;
            diskName: pulumi.Input<string>;
            diskURI: pulumi.Input<string>;
            fsType?: pulumi.Input<string>;
            kind?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecIngesterVolumesAzureFile {
            readOnly?: pulumi.Input<boolean>;
            secretName: pulumi.Input<string>;
            shareName: pulumi.Input<string>;
        }

        export interface JaegerSpecIngesterVolumesCephfs {
            monitors: pulumi.Input<pulumi.Input<string>[]>;
            path?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretFile?: pulumi.Input<string>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesCephfsSecretRef>;
            user?: pulumi.Input<string>;
        }

        export interface JaegerSpecIngesterVolumesCephfsSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecIngesterVolumesCinder {
            fsType?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesCinderSecretRef>;
            volumeID: pulumi.Input<string>;
        }

        export interface JaegerSpecIngesterVolumesCinderSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecIngesterVolumesConfigMap {
            defaultMode?: pulumi.Input<number>;
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesConfigMapItems>[]>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecIngesterVolumesConfigMapItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecIngesterVolumesCsi {
            driver: pulumi.Input<string>;
            fsType?: pulumi.Input<string>;
            nodePublishSecretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesCsiNodePublishSecretRef>;
            readOnly?: pulumi.Input<boolean>;
            volumeAttributes?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecIngesterVolumesCsiNodePublishSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecIngesterVolumesDownwardAPI {
            defaultMode?: pulumi.Input<number>;
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesDownwardAPIItems>[]>;
        }

        export interface JaegerSpecIngesterVolumesDownwardAPIItems {
            fieldRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesDownwardAPIItemsFieldRef>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
            resourceFieldRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesDownwardAPIItemsResourceFieldRef>;
        }

        export interface JaegerSpecIngesterVolumesDownwardAPIItemsFieldRef {
            apiVersion?: pulumi.Input<string>;
            fieldPath: pulumi.Input<string>;
        }

        export interface JaegerSpecIngesterVolumesDownwardAPIItemsResourceFieldRef {
            containerName?: pulumi.Input<string>;
            divisor?: pulumi.Input<string>;
            resource: pulumi.Input<string>;
        }

        export interface JaegerSpecIngesterVolumesEmptyDir {
            medium?: pulumi.Input<string>;
            sizeLimit?: pulumi.Input<string>;
        }

        export interface JaegerSpecIngesterVolumesFc {
            fsType?: pulumi.Input<string>;
            lun?: pulumi.Input<number>;
            readOnly?: pulumi.Input<boolean>;
            targetWWNs?: pulumi.Input<pulumi.Input<string>[]>;
            wwids?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecIngesterVolumesFlexVolume {
            driver: pulumi.Input<string>;
            fsType?: pulumi.Input<string>;
            options?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesFlexVolumeSecretRef>;
        }

        export interface JaegerSpecIngesterVolumesFlexVolumeSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecIngesterVolumesFlocker {
            datasetName?: pulumi.Input<string>;
            datasetUUID?: pulumi.Input<string>;
        }

        export interface JaegerSpecIngesterVolumesGcePersistentDisk {
            fsType?: pulumi.Input<string>;
            partition?: pulumi.Input<number>;
            pdName: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecIngesterVolumesGitRepo {
            directory?: pulumi.Input<string>;
            repository: pulumi.Input<string>;
            revision?: pulumi.Input<string>;
        }

        export interface JaegerSpecIngesterVolumesGlusterfs {
            endpoints: pulumi.Input<string>;
            path: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecIngesterVolumesHostPath {
            path: pulumi.Input<string>;
            type?: pulumi.Input<string>;
        }

        export interface JaegerSpecIngesterVolumesIscsi {
            chapAuthDiscovery?: pulumi.Input<boolean>;
            chapAuthSession?: pulumi.Input<boolean>;
            fsType?: pulumi.Input<string>;
            initiatorName?: pulumi.Input<string>;
            iqn: pulumi.Input<string>;
            iscsiInterface?: pulumi.Input<string>;
            lun: pulumi.Input<number>;
            portals?: pulumi.Input<pulumi.Input<string>[]>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesIscsiSecretRef>;
            targetPortal: pulumi.Input<string>;
        }

        export interface JaegerSpecIngesterVolumesIscsiSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecIngesterVolumesNfs {
            path: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            server: pulumi.Input<string>;
        }

        export interface JaegerSpecIngesterVolumesPersistentVolumeClaim {
            claimName: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecIngesterVolumesPhotonPersistentDisk {
            fsType?: pulumi.Input<string>;
            pdID: pulumi.Input<string>;
        }

        export interface JaegerSpecIngesterVolumesPortworxVolume {
            fsType?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            volumeID: pulumi.Input<string>;
        }

        export interface JaegerSpecIngesterVolumesProjected {
            defaultMode?: pulumi.Input<number>;
            sources: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesProjectedSources>[]>;
        }

        export interface JaegerSpecIngesterVolumesProjectedSources {
            configMap?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesProjectedSourcesConfigMap>;
            downwardAPI?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesProjectedSourcesDownwardAPI>;
            secret?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesProjectedSourcesSecret>;
            serviceAccountToken?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesProjectedSourcesServiceAccountToken>;
        }

        export interface JaegerSpecIngesterVolumesProjectedSourcesConfigMap {
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesProjectedSourcesConfigMapItems>[]>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecIngesterVolumesProjectedSourcesConfigMapItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecIngesterVolumesProjectedSourcesDownwardAPI {
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesProjectedSourcesDownwardAPIItems>[]>;
        }

        export interface JaegerSpecIngesterVolumesProjectedSourcesDownwardAPIItems {
            fieldRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesProjectedSourcesDownwardAPIItemsFieldRef>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
            resourceFieldRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef>;
        }

        export interface JaegerSpecIngesterVolumesProjectedSourcesDownwardAPIItemsFieldRef {
            apiVersion?: pulumi.Input<string>;
            fieldPath: pulumi.Input<string>;
        }

        export interface JaegerSpecIngesterVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef {
            containerName?: pulumi.Input<string>;
            divisor?: pulumi.Input<string>;
            resource: pulumi.Input<string>;
        }

        export interface JaegerSpecIngesterVolumesProjectedSourcesSecret {
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesProjectedSourcesSecretItems>[]>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecIngesterVolumesProjectedSourcesSecretItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecIngesterVolumesProjectedSourcesServiceAccountToken {
            audience?: pulumi.Input<string>;
            expirationSeconds?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecIngesterVolumesQuobyte {
            group?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            registry: pulumi.Input<string>;
            tenant?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
            volume: pulumi.Input<string>;
        }

        export interface JaegerSpecIngesterVolumesRbd {
            fsType?: pulumi.Input<string>;
            image: pulumi.Input<string>;
            keyring?: pulumi.Input<string>;
            monitors: pulumi.Input<pulumi.Input<string>[]>;
            pool?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesRbdSecretRef>;
            user?: pulumi.Input<string>;
        }

        export interface JaegerSpecIngesterVolumesRbdSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecIngesterVolumesScaleIO {
            fsType?: pulumi.Input<string>;
            gateway: pulumi.Input<string>;
            protectionDomain?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesScaleIOSecretRef>;
            sslEnabled?: pulumi.Input<boolean>;
            storageMode?: pulumi.Input<string>;
            storagePool?: pulumi.Input<string>;
            system: pulumi.Input<string>;
            volumeName?: pulumi.Input<string>;
        }

        export interface JaegerSpecIngesterVolumesScaleIOSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecIngesterVolumesSecret {
            defaultMode?: pulumi.Input<number>;
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesSecretItems>[]>;
            optional?: pulumi.Input<boolean>;
            secretName?: pulumi.Input<string>;
        }

        export interface JaegerSpecIngesterVolumesSecretItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecIngesterVolumesStorageos {
            fsType?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngesterVolumesStorageosSecretRef>;
            volumeName?: pulumi.Input<string>;
            volumeNamespace?: pulumi.Input<string>;
        }

        export interface JaegerSpecIngesterVolumesStorageosSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecIngesterVolumesVsphereVolume {
            fsType?: pulumi.Input<string>;
            storagePolicyID?: pulumi.Input<string>;
            storagePolicyName?: pulumi.Input<string>;
            volumePath: pulumi.Input<string>;
        }

        export interface JaegerSpecIngress {
            affinity?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressAffinity>;
            annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            enabled?: pulumi.Input<boolean>;
            hosts?: pulumi.Input<pulumi.Input<string>[]>;
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            openshift?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressOpenshift>;
            options?: pulumi.Input<{[key: string]: any}>;
            resources?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressResources>;
            secretName?: pulumi.Input<string>;
            security?: pulumi.Input<string>;
            securityContext?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressSecurityContext>;
            serviceAccount?: pulumi.Input<string>;
            tls?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressTls>[]>;
            tolerations?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressTolerations>[]>;
            volumeMounts?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumeMounts>[]>;
            volumes?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumes>[]>;
        }

        export interface JaegerSpecIngressAffinity {
            nodeAffinity?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressAffinityNodeAffinity>;
            podAffinity?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressAffinityPodAffinity>;
            podAntiAffinity?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressAffinityPodAntiAffinity>;
        }

        export interface JaegerSpecIngressAffinityNodeAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>;
        }

        export interface JaegerSpecIngressAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference>;
            weight: pulumi.Input<number>;
        }

        export interface JaegerSpecIngressAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>[]>;
        }

        export interface JaegerSpecIngressAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecIngressAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecIngressAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            nodeSelectorTerms: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>[]>;
        }

        export interface JaegerSpecIngressAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>[]>;
        }

        export interface JaegerSpecIngressAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecIngressAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecIngressAffinityPodAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface JaegerSpecIngressAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight: pulumi.Input<number>;
        }

        export interface JaegerSpecIngressAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecIngressAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecIngressAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecIngressAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecIngressAffinityPodAntiAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface JaegerSpecIngressAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight: pulumi.Input<number>;
        }

        export interface JaegerSpecIngressAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecIngressAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecIngressAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecIngressAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecIngressOpenshift {
            delegateUrls?: pulumi.Input<string>;
            htpasswdFile?: pulumi.Input<string>;
            sar?: pulumi.Input<string>;
            skipLogout?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecIngressResources {
            limits?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            requests?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecIngressSecurityContext {
            fsGroup?: pulumi.Input<number>;
            fsGroupChangePolicy?: pulumi.Input<string>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressSecurityContextSeLinuxOptions>;
            supplementalGroups?: pulumi.Input<pulumi.Input<number>[]>;
            sysctls?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressSecurityContextSysctls>[]>;
            windowsOptions?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressSecurityContextWindowsOptions>;
        }

        export interface JaegerSpecIngressSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressSecurityContextSysctls {
            name: pulumi.Input<string>;
            value: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
            runAsUserName?: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressTls {
            hosts?: pulumi.Input<pulumi.Input<string>[]>;
            secretName?: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressTolerations {
            effect?: pulumi.Input<string>;
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            tolerationSeconds?: pulumi.Input<number>;
            value?: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressVolumeMounts {
            mountPath: pulumi.Input<string>;
            mountPropagation?: pulumi.Input<string>;
            name: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            subPath?: pulumi.Input<string>;
            subPathExpr?: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressVolumes {
            awsElasticBlockStore?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesAwsElasticBlockStore>;
            azureDisk?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesAzureDisk>;
            azureFile?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesAzureFile>;
            cephfs?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesCephfs>;
            cinder?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesCinder>;
            configMap?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesConfigMap>;
            csi?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesCsi>;
            downwardAPI?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesDownwardAPI>;
            emptyDir?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesEmptyDir>;
            fc?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesFc>;
            flexVolume?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesFlexVolume>;
            flocker?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesFlocker>;
            gcePersistentDisk?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesGcePersistentDisk>;
            gitRepo?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesGitRepo>;
            glusterfs?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesGlusterfs>;
            hostPath?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesHostPath>;
            iscsi?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesIscsi>;
            name: pulumi.Input<string>;
            nfs?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesNfs>;
            persistentVolumeClaim?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesPersistentVolumeClaim>;
            photonPersistentDisk?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesPhotonPersistentDisk>;
            portworxVolume?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesPortworxVolume>;
            projected?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesProjected>;
            quobyte?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesQuobyte>;
            rbd?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesRbd>;
            scaleIO?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesScaleIO>;
            secret?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesSecret>;
            storageos?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesStorageos>;
            vsphereVolume?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesVsphereVolume>;
        }

        export interface JaegerSpecIngressVolumesAwsElasticBlockStore {
            fsType?: pulumi.Input<string>;
            partition?: pulumi.Input<number>;
            readOnly?: pulumi.Input<boolean>;
            volumeID: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressVolumesAzureDisk {
            cachingMode?: pulumi.Input<string>;
            diskName: pulumi.Input<string>;
            diskURI: pulumi.Input<string>;
            fsType?: pulumi.Input<string>;
            kind?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecIngressVolumesAzureFile {
            readOnly?: pulumi.Input<boolean>;
            secretName: pulumi.Input<string>;
            shareName: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressVolumesCephfs {
            monitors: pulumi.Input<pulumi.Input<string>[]>;
            path?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretFile?: pulumi.Input<string>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesCephfsSecretRef>;
            user?: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressVolumesCephfsSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressVolumesCinder {
            fsType?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesCinderSecretRef>;
            volumeID: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressVolumesCinderSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressVolumesConfigMap {
            defaultMode?: pulumi.Input<number>;
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesConfigMapItems>[]>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecIngressVolumesConfigMapItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressVolumesCsi {
            driver: pulumi.Input<string>;
            fsType?: pulumi.Input<string>;
            nodePublishSecretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesCsiNodePublishSecretRef>;
            readOnly?: pulumi.Input<boolean>;
            volumeAttributes?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecIngressVolumesCsiNodePublishSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressVolumesDownwardAPI {
            defaultMode?: pulumi.Input<number>;
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesDownwardAPIItems>[]>;
        }

        export interface JaegerSpecIngressVolumesDownwardAPIItems {
            fieldRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesDownwardAPIItemsFieldRef>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
            resourceFieldRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesDownwardAPIItemsResourceFieldRef>;
        }

        export interface JaegerSpecIngressVolumesDownwardAPIItemsFieldRef {
            apiVersion?: pulumi.Input<string>;
            fieldPath: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressVolumesDownwardAPIItemsResourceFieldRef {
            containerName?: pulumi.Input<string>;
            divisor?: pulumi.Input<string>;
            resource: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressVolumesEmptyDir {
            medium?: pulumi.Input<string>;
            sizeLimit?: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressVolumesFc {
            fsType?: pulumi.Input<string>;
            lun?: pulumi.Input<number>;
            readOnly?: pulumi.Input<boolean>;
            targetWWNs?: pulumi.Input<pulumi.Input<string>[]>;
            wwids?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecIngressVolumesFlexVolume {
            driver: pulumi.Input<string>;
            fsType?: pulumi.Input<string>;
            options?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesFlexVolumeSecretRef>;
        }

        export interface JaegerSpecIngressVolumesFlexVolumeSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressVolumesFlocker {
            datasetName?: pulumi.Input<string>;
            datasetUUID?: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressVolumesGcePersistentDisk {
            fsType?: pulumi.Input<string>;
            partition?: pulumi.Input<number>;
            pdName: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecIngressVolumesGitRepo {
            directory?: pulumi.Input<string>;
            repository: pulumi.Input<string>;
            revision?: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressVolumesGlusterfs {
            endpoints: pulumi.Input<string>;
            path: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecIngressVolumesHostPath {
            path: pulumi.Input<string>;
            type?: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressVolumesIscsi {
            chapAuthDiscovery?: pulumi.Input<boolean>;
            chapAuthSession?: pulumi.Input<boolean>;
            fsType?: pulumi.Input<string>;
            initiatorName?: pulumi.Input<string>;
            iqn: pulumi.Input<string>;
            iscsiInterface?: pulumi.Input<string>;
            lun: pulumi.Input<number>;
            portals?: pulumi.Input<pulumi.Input<string>[]>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesIscsiSecretRef>;
            targetPortal: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressVolumesIscsiSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressVolumesNfs {
            path: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            server: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressVolumesPersistentVolumeClaim {
            claimName: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecIngressVolumesPhotonPersistentDisk {
            fsType?: pulumi.Input<string>;
            pdID: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressVolumesPortworxVolume {
            fsType?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            volumeID: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressVolumesProjected {
            defaultMode?: pulumi.Input<number>;
            sources: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesProjectedSources>[]>;
        }

        export interface JaegerSpecIngressVolumesProjectedSources {
            configMap?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesProjectedSourcesConfigMap>;
            downwardAPI?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesProjectedSourcesDownwardAPI>;
            secret?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesProjectedSourcesSecret>;
            serviceAccountToken?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesProjectedSourcesServiceAccountToken>;
        }

        export interface JaegerSpecIngressVolumesProjectedSourcesConfigMap {
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesProjectedSourcesConfigMapItems>[]>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecIngressVolumesProjectedSourcesConfigMapItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressVolumesProjectedSourcesDownwardAPI {
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesProjectedSourcesDownwardAPIItems>[]>;
        }

        export interface JaegerSpecIngressVolumesProjectedSourcesDownwardAPIItems {
            fieldRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesProjectedSourcesDownwardAPIItemsFieldRef>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
            resourceFieldRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef>;
        }

        export interface JaegerSpecIngressVolumesProjectedSourcesDownwardAPIItemsFieldRef {
            apiVersion?: pulumi.Input<string>;
            fieldPath: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef {
            containerName?: pulumi.Input<string>;
            divisor?: pulumi.Input<string>;
            resource: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressVolumesProjectedSourcesSecret {
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesProjectedSourcesSecretItems>[]>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecIngressVolumesProjectedSourcesSecretItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressVolumesProjectedSourcesServiceAccountToken {
            audience?: pulumi.Input<string>;
            expirationSeconds?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressVolumesQuobyte {
            group?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            registry: pulumi.Input<string>;
            tenant?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
            volume: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressVolumesRbd {
            fsType?: pulumi.Input<string>;
            image: pulumi.Input<string>;
            keyring?: pulumi.Input<string>;
            monitors: pulumi.Input<pulumi.Input<string>[]>;
            pool?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesRbdSecretRef>;
            user?: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressVolumesRbdSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressVolumesScaleIO {
            fsType?: pulumi.Input<string>;
            gateway: pulumi.Input<string>;
            protectionDomain?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesScaleIOSecretRef>;
            sslEnabled?: pulumi.Input<boolean>;
            storageMode?: pulumi.Input<string>;
            storagePool?: pulumi.Input<string>;
            system: pulumi.Input<string>;
            volumeName?: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressVolumesScaleIOSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressVolumesSecret {
            defaultMode?: pulumi.Input<number>;
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesSecretItems>[]>;
            optional?: pulumi.Input<boolean>;
            secretName?: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressVolumesSecretItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressVolumesStorageos {
            fsType?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecIngressVolumesStorageosSecretRef>;
            volumeName?: pulumi.Input<string>;
            volumeNamespace?: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressVolumesStorageosSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecIngressVolumesVsphereVolume {
            fsType?: pulumi.Input<string>;
            storagePolicyID?: pulumi.Input<string>;
            storagePolicyName?: pulumi.Input<string>;
            volumePath: pulumi.Input<string>;
        }

        export interface JaegerSpecQuery {
            affinity?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryAffinity>;
            annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            image?: pulumi.Input<string>;
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            options?: pulumi.Input<{[key: string]: any}>;
            replicas?: pulumi.Input<number>;
            resources?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryResources>;
            securityContext?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQuerySecurityContext>;
            serviceAccount?: pulumi.Input<string>;
            serviceType?: pulumi.Input<string>;
            tolerations?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryTolerations>[]>;
            volumeMounts?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumeMounts>[]>;
            volumes?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumes>[]>;
        }

        export interface JaegerSpecQueryAffinity {
            nodeAffinity?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryAffinityNodeAffinity>;
            podAffinity?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryAffinityPodAffinity>;
            podAntiAffinity?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryAffinityPodAntiAffinity>;
        }

        export interface JaegerSpecQueryAffinityNodeAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>;
        }

        export interface JaegerSpecQueryAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference>;
            weight: pulumi.Input<number>;
        }

        export interface JaegerSpecQueryAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>[]>;
        }

        export interface JaegerSpecQueryAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecQueryAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecQueryAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            nodeSelectorTerms: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>[]>;
        }

        export interface JaegerSpecQueryAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>[]>;
        }

        export interface JaegerSpecQueryAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecQueryAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecQueryAffinityPodAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface JaegerSpecQueryAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight: pulumi.Input<number>;
        }

        export interface JaegerSpecQueryAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface JaegerSpecQueryAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecQueryAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecQueryAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface JaegerSpecQueryAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecQueryAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecQueryAffinityPodAntiAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface JaegerSpecQueryAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight: pulumi.Input<number>;
        }

        export interface JaegerSpecQueryAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface JaegerSpecQueryAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecQueryAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecQueryAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface JaegerSpecQueryAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecQueryAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecQueryResources {
            limits?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            requests?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecQuerySecurityContext {
            fsGroup?: pulumi.Input<number>;
            fsGroupChangePolicy?: pulumi.Input<string>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQuerySecurityContextSeLinuxOptions>;
            supplementalGroups?: pulumi.Input<pulumi.Input<number>[]>;
            sysctls?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQuerySecurityContextSysctls>[]>;
            windowsOptions?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQuerySecurityContextWindowsOptions>;
        }

        export interface JaegerSpecQuerySecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface JaegerSpecQuerySecurityContextSysctls {
            name: pulumi.Input<string>;
            value: pulumi.Input<string>;
        }

        export interface JaegerSpecQuerySecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
            runAsUserName?: pulumi.Input<string>;
        }

        export interface JaegerSpecQueryTolerations {
            effect?: pulumi.Input<string>;
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            tolerationSeconds?: pulumi.Input<number>;
            value?: pulumi.Input<string>;
        }

        export interface JaegerSpecQueryVolumeMounts {
            mountPath: pulumi.Input<string>;
            mountPropagation?: pulumi.Input<string>;
            name: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            subPath?: pulumi.Input<string>;
            subPathExpr?: pulumi.Input<string>;
        }

        export interface JaegerSpecQueryVolumes {
            awsElasticBlockStore?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesAwsElasticBlockStore>;
            azureDisk?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesAzureDisk>;
            azureFile?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesAzureFile>;
            cephfs?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesCephfs>;
            cinder?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesCinder>;
            configMap?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesConfigMap>;
            csi?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesCsi>;
            downwardAPI?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesDownwardAPI>;
            emptyDir?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesEmptyDir>;
            fc?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesFc>;
            flexVolume?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesFlexVolume>;
            flocker?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesFlocker>;
            gcePersistentDisk?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesGcePersistentDisk>;
            gitRepo?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesGitRepo>;
            glusterfs?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesGlusterfs>;
            hostPath?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesHostPath>;
            iscsi?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesIscsi>;
            name: pulumi.Input<string>;
            nfs?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesNfs>;
            persistentVolumeClaim?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesPersistentVolumeClaim>;
            photonPersistentDisk?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesPhotonPersistentDisk>;
            portworxVolume?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesPortworxVolume>;
            projected?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesProjected>;
            quobyte?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesQuobyte>;
            rbd?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesRbd>;
            scaleIO?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesScaleIO>;
            secret?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesSecret>;
            storageos?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesStorageos>;
            vsphereVolume?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesVsphereVolume>;
        }

        export interface JaegerSpecQueryVolumesAwsElasticBlockStore {
            fsType?: pulumi.Input<string>;
            partition?: pulumi.Input<number>;
            readOnly?: pulumi.Input<boolean>;
            volumeID: pulumi.Input<string>;
        }

        export interface JaegerSpecQueryVolumesAzureDisk {
            cachingMode?: pulumi.Input<string>;
            diskName: pulumi.Input<string>;
            diskURI: pulumi.Input<string>;
            fsType?: pulumi.Input<string>;
            kind?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecQueryVolumesAzureFile {
            readOnly?: pulumi.Input<boolean>;
            secretName: pulumi.Input<string>;
            shareName: pulumi.Input<string>;
        }

        export interface JaegerSpecQueryVolumesCephfs {
            monitors: pulumi.Input<pulumi.Input<string>[]>;
            path?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretFile?: pulumi.Input<string>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesCephfsSecretRef>;
            user?: pulumi.Input<string>;
        }

        export interface JaegerSpecQueryVolumesCephfsSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecQueryVolumesCinder {
            fsType?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesCinderSecretRef>;
            volumeID: pulumi.Input<string>;
        }

        export interface JaegerSpecQueryVolumesCinderSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecQueryVolumesConfigMap {
            defaultMode?: pulumi.Input<number>;
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesConfigMapItems>[]>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecQueryVolumesConfigMapItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecQueryVolumesCsi {
            driver: pulumi.Input<string>;
            fsType?: pulumi.Input<string>;
            nodePublishSecretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesCsiNodePublishSecretRef>;
            readOnly?: pulumi.Input<boolean>;
            volumeAttributes?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecQueryVolumesCsiNodePublishSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecQueryVolumesDownwardAPI {
            defaultMode?: pulumi.Input<number>;
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesDownwardAPIItems>[]>;
        }

        export interface JaegerSpecQueryVolumesDownwardAPIItems {
            fieldRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesDownwardAPIItemsFieldRef>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
            resourceFieldRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesDownwardAPIItemsResourceFieldRef>;
        }

        export interface JaegerSpecQueryVolumesDownwardAPIItemsFieldRef {
            apiVersion?: pulumi.Input<string>;
            fieldPath: pulumi.Input<string>;
        }

        export interface JaegerSpecQueryVolumesDownwardAPIItemsResourceFieldRef {
            containerName?: pulumi.Input<string>;
            divisor?: pulumi.Input<string>;
            resource: pulumi.Input<string>;
        }

        export interface JaegerSpecQueryVolumesEmptyDir {
            medium?: pulumi.Input<string>;
            sizeLimit?: pulumi.Input<string>;
        }

        export interface JaegerSpecQueryVolumesFc {
            fsType?: pulumi.Input<string>;
            lun?: pulumi.Input<number>;
            readOnly?: pulumi.Input<boolean>;
            targetWWNs?: pulumi.Input<pulumi.Input<string>[]>;
            wwids?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecQueryVolumesFlexVolume {
            driver: pulumi.Input<string>;
            fsType?: pulumi.Input<string>;
            options?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesFlexVolumeSecretRef>;
        }

        export interface JaegerSpecQueryVolumesFlexVolumeSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecQueryVolumesFlocker {
            datasetName?: pulumi.Input<string>;
            datasetUUID?: pulumi.Input<string>;
        }

        export interface JaegerSpecQueryVolumesGcePersistentDisk {
            fsType?: pulumi.Input<string>;
            partition?: pulumi.Input<number>;
            pdName: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecQueryVolumesGitRepo {
            directory?: pulumi.Input<string>;
            repository: pulumi.Input<string>;
            revision?: pulumi.Input<string>;
        }

        export interface JaegerSpecQueryVolumesGlusterfs {
            endpoints: pulumi.Input<string>;
            path: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecQueryVolumesHostPath {
            path: pulumi.Input<string>;
            type?: pulumi.Input<string>;
        }

        export interface JaegerSpecQueryVolumesIscsi {
            chapAuthDiscovery?: pulumi.Input<boolean>;
            chapAuthSession?: pulumi.Input<boolean>;
            fsType?: pulumi.Input<string>;
            initiatorName?: pulumi.Input<string>;
            iqn: pulumi.Input<string>;
            iscsiInterface?: pulumi.Input<string>;
            lun: pulumi.Input<number>;
            portals?: pulumi.Input<pulumi.Input<string>[]>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesIscsiSecretRef>;
            targetPortal: pulumi.Input<string>;
        }

        export interface JaegerSpecQueryVolumesIscsiSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecQueryVolumesNfs {
            path: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            server: pulumi.Input<string>;
        }

        export interface JaegerSpecQueryVolumesPersistentVolumeClaim {
            claimName: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecQueryVolumesPhotonPersistentDisk {
            fsType?: pulumi.Input<string>;
            pdID: pulumi.Input<string>;
        }

        export interface JaegerSpecQueryVolumesPortworxVolume {
            fsType?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            volumeID: pulumi.Input<string>;
        }

        export interface JaegerSpecQueryVolumesProjected {
            defaultMode?: pulumi.Input<number>;
            sources: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesProjectedSources>[]>;
        }

        export interface JaegerSpecQueryVolumesProjectedSources {
            configMap?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesProjectedSourcesConfigMap>;
            downwardAPI?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesProjectedSourcesDownwardAPI>;
            secret?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesProjectedSourcesSecret>;
            serviceAccountToken?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesProjectedSourcesServiceAccountToken>;
        }

        export interface JaegerSpecQueryVolumesProjectedSourcesConfigMap {
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesProjectedSourcesConfigMapItems>[]>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecQueryVolumesProjectedSourcesConfigMapItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecQueryVolumesProjectedSourcesDownwardAPI {
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesProjectedSourcesDownwardAPIItems>[]>;
        }

        export interface JaegerSpecQueryVolumesProjectedSourcesDownwardAPIItems {
            fieldRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesProjectedSourcesDownwardAPIItemsFieldRef>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
            resourceFieldRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef>;
        }

        export interface JaegerSpecQueryVolumesProjectedSourcesDownwardAPIItemsFieldRef {
            apiVersion?: pulumi.Input<string>;
            fieldPath: pulumi.Input<string>;
        }

        export interface JaegerSpecQueryVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef {
            containerName?: pulumi.Input<string>;
            divisor?: pulumi.Input<string>;
            resource: pulumi.Input<string>;
        }

        export interface JaegerSpecQueryVolumesProjectedSourcesSecret {
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesProjectedSourcesSecretItems>[]>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecQueryVolumesProjectedSourcesSecretItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecQueryVolumesProjectedSourcesServiceAccountToken {
            audience?: pulumi.Input<string>;
            expirationSeconds?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecQueryVolumesQuobyte {
            group?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            registry: pulumi.Input<string>;
            tenant?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
            volume: pulumi.Input<string>;
        }

        export interface JaegerSpecQueryVolumesRbd {
            fsType?: pulumi.Input<string>;
            image: pulumi.Input<string>;
            keyring?: pulumi.Input<string>;
            monitors: pulumi.Input<pulumi.Input<string>[]>;
            pool?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesRbdSecretRef>;
            user?: pulumi.Input<string>;
        }

        export interface JaegerSpecQueryVolumesRbdSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecQueryVolumesScaleIO {
            fsType?: pulumi.Input<string>;
            gateway: pulumi.Input<string>;
            protectionDomain?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesScaleIOSecretRef>;
            sslEnabled?: pulumi.Input<boolean>;
            storageMode?: pulumi.Input<string>;
            storagePool?: pulumi.Input<string>;
            system: pulumi.Input<string>;
            volumeName?: pulumi.Input<string>;
        }

        export interface JaegerSpecQueryVolumesScaleIOSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecQueryVolumesSecret {
            defaultMode?: pulumi.Input<number>;
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesSecretItems>[]>;
            optional?: pulumi.Input<boolean>;
            secretName?: pulumi.Input<string>;
        }

        export interface JaegerSpecQueryVolumesSecretItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecQueryVolumesStorageos {
            fsType?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecQueryVolumesStorageosSecretRef>;
            volumeName?: pulumi.Input<string>;
            volumeNamespace?: pulumi.Input<string>;
        }

        export interface JaegerSpecQueryVolumesStorageosSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecQueryVolumesVsphereVolume {
            fsType?: pulumi.Input<string>;
            storagePolicyID?: pulumi.Input<string>;
            storagePolicyName?: pulumi.Input<string>;
            volumePath: pulumi.Input<string>;
        }

        export interface JaegerSpecResources {
            limits?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            requests?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecSampling {
            options?: pulumi.Input<{[key: string]: any}>;
        }

        export interface JaegerSpecSecurityContext {
            fsGroup?: pulumi.Input<number>;
            fsGroupChangePolicy?: pulumi.Input<string>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecSecurityContextSeLinuxOptions>;
            supplementalGroups?: pulumi.Input<pulumi.Input<number>[]>;
            sysctls?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecSecurityContextSysctls>[]>;
            windowsOptions?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecSecurityContextWindowsOptions>;
        }

        export interface JaegerSpecSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface JaegerSpecSecurityContextSysctls {
            name: pulumi.Input<string>;
            value: pulumi.Input<string>;
        }

        export interface JaegerSpecSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
            runAsUserName?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorage {
            cassandraCreateSchema?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageCassandraCreateSchema>;
            dependencies?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependencies>;
            elasticsearch?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageElasticsearch>;
            esIndexCleaner?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleaner>;
            esRollover?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRollover>;
            options?: pulumi.Input<{[key: string]: any}>;
            secretName?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageCassandraCreateSchema {
            datacenter?: pulumi.Input<string>;
            enabled?: pulumi.Input<boolean>;
            image?: pulumi.Input<string>;
            mode?: pulumi.Input<string>;
            timeout?: pulumi.Input<string>;
            traceTTL?: pulumi.Input<string>;
            ttlSecondsAfterFinished?: pulumi.Input<number>;
        }

        export interface JaegerSpecStorageDependencies {
            affinity?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinity>;
            annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            cassandraClientAuthEnabled?: pulumi.Input<boolean>;
            elasticsearchClientNodeOnly?: pulumi.Input<boolean>;
            elasticsearchNodesWanOnly?: pulumi.Input<boolean>;
            enabled?: pulumi.Input<boolean>;
            image?: pulumi.Input<string>;
            javaOpts?: pulumi.Input<string>;
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            resources?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesResources>;
            schedule?: pulumi.Input<string>;
            securityContext?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesSecurityContext>;
            serviceAccount?: pulumi.Input<string>;
            sparkMaster?: pulumi.Input<string>;
            successfulJobsHistoryLimit?: pulumi.Input<number>;
            tolerations?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesTolerations>[]>;
            ttlSecondsAfterFinished?: pulumi.Input<number>;
            volumeMounts?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumeMounts>[]>;
            volumes?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumes>[]>;
        }

        export interface JaegerSpecStorageDependenciesAffinity {
            nodeAffinity?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityNodeAffinity>;
            podAffinity?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityPodAffinity>;
            podAntiAffinity?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityPodAntiAffinity>;
        }

        export interface JaegerSpecStorageDependenciesAffinityNodeAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>;
        }

        export interface JaegerSpecStorageDependenciesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference>;
            weight: pulumi.Input<number>;
        }

        export interface JaegerSpecStorageDependenciesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>[]>;
        }

        export interface JaegerSpecStorageDependenciesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecStorageDependenciesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecStorageDependenciesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            nodeSelectorTerms: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>[]>;
        }

        export interface JaegerSpecStorageDependenciesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>[]>;
        }

        export interface JaegerSpecStorageDependenciesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecStorageDependenciesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecStorageDependenciesAffinityPodAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface JaegerSpecStorageDependenciesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight: pulumi.Input<number>;
        }

        export interface JaegerSpecStorageDependenciesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageDependenciesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecStorageDependenciesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecStorageDependenciesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageDependenciesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecStorageDependenciesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecStorageDependenciesAffinityPodAntiAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface JaegerSpecStorageDependenciesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight: pulumi.Input<number>;
        }

        export interface JaegerSpecStorageDependenciesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageDependenciesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecStorageDependenciesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecStorageDependenciesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageDependenciesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecStorageDependenciesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecStorageDependenciesResources {
            limits?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            requests?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecStorageDependenciesSecurityContext {
            fsGroup?: pulumi.Input<number>;
            fsGroupChangePolicy?: pulumi.Input<string>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesSecurityContextSeLinuxOptions>;
            supplementalGroups?: pulumi.Input<pulumi.Input<number>[]>;
            sysctls?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesSecurityContextSysctls>[]>;
            windowsOptions?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesSecurityContextWindowsOptions>;
        }

        export interface JaegerSpecStorageDependenciesSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageDependenciesSecurityContextSysctls {
            name: pulumi.Input<string>;
            value: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageDependenciesSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
            runAsUserName?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageDependenciesTolerations {
            effect?: pulumi.Input<string>;
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            tolerationSeconds?: pulumi.Input<number>;
            value?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageDependenciesVolumeMounts {
            mountPath: pulumi.Input<string>;
            mountPropagation?: pulumi.Input<string>;
            name: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            subPath?: pulumi.Input<string>;
            subPathExpr?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageDependenciesVolumes {
            awsElasticBlockStore?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesAwsElasticBlockStore>;
            azureDisk?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesAzureDisk>;
            azureFile?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesAzureFile>;
            cephfs?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesCephfs>;
            cinder?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesCinder>;
            configMap?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesConfigMap>;
            csi?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesCsi>;
            downwardAPI?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesDownwardAPI>;
            emptyDir?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesEmptyDir>;
            fc?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesFc>;
            flexVolume?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesFlexVolume>;
            flocker?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesFlocker>;
            gcePersistentDisk?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesGcePersistentDisk>;
            gitRepo?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesGitRepo>;
            glusterfs?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesGlusterfs>;
            hostPath?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesHostPath>;
            iscsi?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesIscsi>;
            name: pulumi.Input<string>;
            nfs?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesNfs>;
            persistentVolumeClaim?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesPersistentVolumeClaim>;
            photonPersistentDisk?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesPhotonPersistentDisk>;
            portworxVolume?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesPortworxVolume>;
            projected?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesProjected>;
            quobyte?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesQuobyte>;
            rbd?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesRbd>;
            scaleIO?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesScaleIO>;
            secret?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesSecret>;
            storageos?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesStorageos>;
            vsphereVolume?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesVsphereVolume>;
        }

        export interface JaegerSpecStorageDependenciesVolumesAwsElasticBlockStore {
            fsType?: pulumi.Input<string>;
            partition?: pulumi.Input<number>;
            readOnly?: pulumi.Input<boolean>;
            volumeID: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageDependenciesVolumesAzureDisk {
            cachingMode?: pulumi.Input<string>;
            diskName: pulumi.Input<string>;
            diskURI: pulumi.Input<string>;
            fsType?: pulumi.Input<string>;
            kind?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecStorageDependenciesVolumesAzureFile {
            readOnly?: pulumi.Input<boolean>;
            secretName: pulumi.Input<string>;
            shareName: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageDependenciesVolumesCephfs {
            monitors: pulumi.Input<pulumi.Input<string>[]>;
            path?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretFile?: pulumi.Input<string>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesCephfsSecretRef>;
            user?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageDependenciesVolumesCephfsSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageDependenciesVolumesCinder {
            fsType?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesCinderSecretRef>;
            volumeID: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageDependenciesVolumesCinderSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageDependenciesVolumesConfigMap {
            defaultMode?: pulumi.Input<number>;
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesConfigMapItems>[]>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecStorageDependenciesVolumesConfigMapItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageDependenciesVolumesCsi {
            driver: pulumi.Input<string>;
            fsType?: pulumi.Input<string>;
            nodePublishSecretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesCsiNodePublishSecretRef>;
            readOnly?: pulumi.Input<boolean>;
            volumeAttributes?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecStorageDependenciesVolumesCsiNodePublishSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageDependenciesVolumesDownwardAPI {
            defaultMode?: pulumi.Input<number>;
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesDownwardAPIItems>[]>;
        }

        export interface JaegerSpecStorageDependenciesVolumesDownwardAPIItems {
            fieldRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesDownwardAPIItemsFieldRef>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
            resourceFieldRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesDownwardAPIItemsResourceFieldRef>;
        }

        export interface JaegerSpecStorageDependenciesVolumesDownwardAPIItemsFieldRef {
            apiVersion?: pulumi.Input<string>;
            fieldPath: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageDependenciesVolumesDownwardAPIItemsResourceFieldRef {
            containerName?: pulumi.Input<string>;
            divisor?: pulumi.Input<string>;
            resource: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageDependenciesVolumesEmptyDir {
            medium?: pulumi.Input<string>;
            sizeLimit?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageDependenciesVolumesFc {
            fsType?: pulumi.Input<string>;
            lun?: pulumi.Input<number>;
            readOnly?: pulumi.Input<boolean>;
            targetWWNs?: pulumi.Input<pulumi.Input<string>[]>;
            wwids?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecStorageDependenciesVolumesFlexVolume {
            driver: pulumi.Input<string>;
            fsType?: pulumi.Input<string>;
            options?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesFlexVolumeSecretRef>;
        }

        export interface JaegerSpecStorageDependenciesVolumesFlexVolumeSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageDependenciesVolumesFlocker {
            datasetName?: pulumi.Input<string>;
            datasetUUID?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageDependenciesVolumesGcePersistentDisk {
            fsType?: pulumi.Input<string>;
            partition?: pulumi.Input<number>;
            pdName: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecStorageDependenciesVolumesGitRepo {
            directory?: pulumi.Input<string>;
            repository: pulumi.Input<string>;
            revision?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageDependenciesVolumesGlusterfs {
            endpoints: pulumi.Input<string>;
            path: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecStorageDependenciesVolumesHostPath {
            path: pulumi.Input<string>;
            type?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageDependenciesVolumesIscsi {
            chapAuthDiscovery?: pulumi.Input<boolean>;
            chapAuthSession?: pulumi.Input<boolean>;
            fsType?: pulumi.Input<string>;
            initiatorName?: pulumi.Input<string>;
            iqn: pulumi.Input<string>;
            iscsiInterface?: pulumi.Input<string>;
            lun: pulumi.Input<number>;
            portals?: pulumi.Input<pulumi.Input<string>[]>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesIscsiSecretRef>;
            targetPortal: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageDependenciesVolumesIscsiSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageDependenciesVolumesNfs {
            path: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            server: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageDependenciesVolumesPersistentVolumeClaim {
            claimName: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecStorageDependenciesVolumesPhotonPersistentDisk {
            fsType?: pulumi.Input<string>;
            pdID: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageDependenciesVolumesPortworxVolume {
            fsType?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            volumeID: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageDependenciesVolumesProjected {
            defaultMode?: pulumi.Input<number>;
            sources: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesProjectedSources>[]>;
        }

        export interface JaegerSpecStorageDependenciesVolumesProjectedSources {
            configMap?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesProjectedSourcesConfigMap>;
            downwardAPI?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesProjectedSourcesDownwardAPI>;
            secret?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesProjectedSourcesSecret>;
            serviceAccountToken?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesProjectedSourcesServiceAccountToken>;
        }

        export interface JaegerSpecStorageDependenciesVolumesProjectedSourcesConfigMap {
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesProjectedSourcesConfigMapItems>[]>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecStorageDependenciesVolumesProjectedSourcesConfigMapItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageDependenciesVolumesProjectedSourcesDownwardAPI {
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesProjectedSourcesDownwardAPIItems>[]>;
        }

        export interface JaegerSpecStorageDependenciesVolumesProjectedSourcesDownwardAPIItems {
            fieldRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesProjectedSourcesDownwardAPIItemsFieldRef>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
            resourceFieldRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef>;
        }

        export interface JaegerSpecStorageDependenciesVolumesProjectedSourcesDownwardAPIItemsFieldRef {
            apiVersion?: pulumi.Input<string>;
            fieldPath: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageDependenciesVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef {
            containerName?: pulumi.Input<string>;
            divisor?: pulumi.Input<string>;
            resource: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageDependenciesVolumesProjectedSourcesSecret {
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesProjectedSourcesSecretItems>[]>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecStorageDependenciesVolumesProjectedSourcesSecretItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageDependenciesVolumesProjectedSourcesServiceAccountToken {
            audience?: pulumi.Input<string>;
            expirationSeconds?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageDependenciesVolumesQuobyte {
            group?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            registry: pulumi.Input<string>;
            tenant?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
            volume: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageDependenciesVolumesRbd {
            fsType?: pulumi.Input<string>;
            image: pulumi.Input<string>;
            keyring?: pulumi.Input<string>;
            monitors: pulumi.Input<pulumi.Input<string>[]>;
            pool?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesRbdSecretRef>;
            user?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageDependenciesVolumesRbdSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageDependenciesVolumesScaleIO {
            fsType?: pulumi.Input<string>;
            gateway: pulumi.Input<string>;
            protectionDomain?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesScaleIOSecretRef>;
            sslEnabled?: pulumi.Input<boolean>;
            storageMode?: pulumi.Input<string>;
            storagePool?: pulumi.Input<string>;
            system: pulumi.Input<string>;
            volumeName?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageDependenciesVolumesScaleIOSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageDependenciesVolumesSecret {
            defaultMode?: pulumi.Input<number>;
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesSecretItems>[]>;
            optional?: pulumi.Input<boolean>;
            secretName?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageDependenciesVolumesSecretItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageDependenciesVolumesStorageos {
            fsType?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesStorageosSecretRef>;
            volumeName?: pulumi.Input<string>;
            volumeNamespace?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageDependenciesVolumesStorageosSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageDependenciesVolumesVsphereVolume {
            fsType?: pulumi.Input<string>;
            storagePolicyID?: pulumi.Input<string>;
            storagePolicyName?: pulumi.Input<string>;
            volumePath: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageElasticsearch {
            image?: pulumi.Input<string>;
            nodeCount?: pulumi.Input<number>;
            nodeSelector?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            redundancyPolicy?: pulumi.Input<string>;
            resources?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageElasticsearchResources>;
            storage?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageElasticsearchStorage>;
        }

        export interface JaegerSpecStorageElasticsearchResources {
            limits?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            requests?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecStorageElasticsearchStorage {
            size?: pulumi.Input<string>;
            storageClassName?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleaner {
            affinity?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinity>;
            annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            enabled?: pulumi.Input<boolean>;
            image?: pulumi.Input<string>;
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            numberOfDays?: pulumi.Input<number>;
            resources?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerResources>;
            schedule?: pulumi.Input<string>;
            securityContext?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerSecurityContext>;
            serviceAccount?: pulumi.Input<string>;
            successfulJobsHistoryLimit?: pulumi.Input<number>;
            tolerations?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerTolerations>[]>;
            ttlSecondsAfterFinished?: pulumi.Input<number>;
            volumeMounts?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumeMounts>[]>;
            volumes?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumes>[]>;
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinity {
            nodeAffinity?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityNodeAffinity>;
            podAffinity?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityPodAffinity>;
            podAntiAffinity?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityPodAntiAffinity>;
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityNodeAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>;
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference>;
            weight: pulumi.Input<number>;
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>[]>;
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            nodeSelectorTerms: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>[]>;
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>[]>;
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityPodAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight: pulumi.Input<number>;
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityPodAntiAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight: pulumi.Input<number>;
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecStorageEsIndexCleanerResources {
            limits?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            requests?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecStorageEsIndexCleanerSecurityContext {
            fsGroup?: pulumi.Input<number>;
            fsGroupChangePolicy?: pulumi.Input<string>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerSecurityContextSeLinuxOptions>;
            supplementalGroups?: pulumi.Input<pulumi.Input<number>[]>;
            sysctls?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerSecurityContextSysctls>[]>;
            windowsOptions?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerSecurityContextWindowsOptions>;
        }

        export interface JaegerSpecStorageEsIndexCleanerSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleanerSecurityContextSysctls {
            name: pulumi.Input<string>;
            value: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleanerSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
            runAsUserName?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleanerTolerations {
            effect?: pulumi.Input<string>;
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            tolerationSeconds?: pulumi.Input<number>;
            value?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumeMounts {
            mountPath: pulumi.Input<string>;
            mountPropagation?: pulumi.Input<string>;
            name: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            subPath?: pulumi.Input<string>;
            subPathExpr?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumes {
            awsElasticBlockStore?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesAwsElasticBlockStore>;
            azureDisk?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesAzureDisk>;
            azureFile?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesAzureFile>;
            cephfs?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesCephfs>;
            cinder?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesCinder>;
            configMap?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesConfigMap>;
            csi?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesCsi>;
            downwardAPI?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesDownwardAPI>;
            emptyDir?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesEmptyDir>;
            fc?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesFc>;
            flexVolume?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesFlexVolume>;
            flocker?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesFlocker>;
            gcePersistentDisk?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesGcePersistentDisk>;
            gitRepo?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesGitRepo>;
            glusterfs?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesGlusterfs>;
            hostPath?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesHostPath>;
            iscsi?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesIscsi>;
            name: pulumi.Input<string>;
            nfs?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesNfs>;
            persistentVolumeClaim?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesPersistentVolumeClaim>;
            photonPersistentDisk?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesPhotonPersistentDisk>;
            portworxVolume?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesPortworxVolume>;
            projected?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesProjected>;
            quobyte?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesQuobyte>;
            rbd?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesRbd>;
            scaleIO?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesScaleIO>;
            secret?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesSecret>;
            storageos?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesStorageos>;
            vsphereVolume?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesVsphereVolume>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesAwsElasticBlockStore {
            fsType?: pulumi.Input<string>;
            partition?: pulumi.Input<number>;
            readOnly?: pulumi.Input<boolean>;
            volumeID: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesAzureDisk {
            cachingMode?: pulumi.Input<string>;
            diskName: pulumi.Input<string>;
            diskURI: pulumi.Input<string>;
            fsType?: pulumi.Input<string>;
            kind?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesAzureFile {
            readOnly?: pulumi.Input<boolean>;
            secretName: pulumi.Input<string>;
            shareName: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesCephfs {
            monitors: pulumi.Input<pulumi.Input<string>[]>;
            path?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretFile?: pulumi.Input<string>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesCephfsSecretRef>;
            user?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesCephfsSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesCinder {
            fsType?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesCinderSecretRef>;
            volumeID: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesCinderSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesConfigMap {
            defaultMode?: pulumi.Input<number>;
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesConfigMapItems>[]>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesConfigMapItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesCsi {
            driver: pulumi.Input<string>;
            fsType?: pulumi.Input<string>;
            nodePublishSecretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesCsiNodePublishSecretRef>;
            readOnly?: pulumi.Input<boolean>;
            volumeAttributes?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesCsiNodePublishSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesDownwardAPI {
            defaultMode?: pulumi.Input<number>;
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesDownwardAPIItems>[]>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesDownwardAPIItems {
            fieldRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesDownwardAPIItemsFieldRef>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
            resourceFieldRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesDownwardAPIItemsResourceFieldRef>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesDownwardAPIItemsFieldRef {
            apiVersion?: pulumi.Input<string>;
            fieldPath: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesDownwardAPIItemsResourceFieldRef {
            containerName?: pulumi.Input<string>;
            divisor?: pulumi.Input<string>;
            resource: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesEmptyDir {
            medium?: pulumi.Input<string>;
            sizeLimit?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesFc {
            fsType?: pulumi.Input<string>;
            lun?: pulumi.Input<number>;
            readOnly?: pulumi.Input<boolean>;
            targetWWNs?: pulumi.Input<pulumi.Input<string>[]>;
            wwids?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesFlexVolume {
            driver: pulumi.Input<string>;
            fsType?: pulumi.Input<string>;
            options?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesFlexVolumeSecretRef>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesFlexVolumeSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesFlocker {
            datasetName?: pulumi.Input<string>;
            datasetUUID?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesGcePersistentDisk {
            fsType?: pulumi.Input<string>;
            partition?: pulumi.Input<number>;
            pdName: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesGitRepo {
            directory?: pulumi.Input<string>;
            repository: pulumi.Input<string>;
            revision?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesGlusterfs {
            endpoints: pulumi.Input<string>;
            path: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesHostPath {
            path: pulumi.Input<string>;
            type?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesIscsi {
            chapAuthDiscovery?: pulumi.Input<boolean>;
            chapAuthSession?: pulumi.Input<boolean>;
            fsType?: pulumi.Input<string>;
            initiatorName?: pulumi.Input<string>;
            iqn: pulumi.Input<string>;
            iscsiInterface?: pulumi.Input<string>;
            lun: pulumi.Input<number>;
            portals?: pulumi.Input<pulumi.Input<string>[]>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesIscsiSecretRef>;
            targetPortal: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesIscsiSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesNfs {
            path: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            server: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesPersistentVolumeClaim {
            claimName: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesPhotonPersistentDisk {
            fsType?: pulumi.Input<string>;
            pdID: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesPortworxVolume {
            fsType?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            volumeID: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesProjected {
            defaultMode?: pulumi.Input<number>;
            sources: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesProjectedSources>[]>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesProjectedSources {
            configMap?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesProjectedSourcesConfigMap>;
            downwardAPI?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesProjectedSourcesDownwardAPI>;
            secret?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesProjectedSourcesSecret>;
            serviceAccountToken?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesProjectedSourcesServiceAccountToken>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesProjectedSourcesConfigMap {
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesProjectedSourcesConfigMapItems>[]>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesProjectedSourcesConfigMapItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesProjectedSourcesDownwardAPI {
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesProjectedSourcesDownwardAPIItems>[]>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesProjectedSourcesDownwardAPIItems {
            fieldRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesProjectedSourcesDownwardAPIItemsFieldRef>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
            resourceFieldRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesProjectedSourcesDownwardAPIItemsFieldRef {
            apiVersion?: pulumi.Input<string>;
            fieldPath: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef {
            containerName?: pulumi.Input<string>;
            divisor?: pulumi.Input<string>;
            resource: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesProjectedSourcesSecret {
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesProjectedSourcesSecretItems>[]>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesProjectedSourcesSecretItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesProjectedSourcesServiceAccountToken {
            audience?: pulumi.Input<string>;
            expirationSeconds?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesQuobyte {
            group?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            registry: pulumi.Input<string>;
            tenant?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
            volume: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesRbd {
            fsType?: pulumi.Input<string>;
            image: pulumi.Input<string>;
            keyring?: pulumi.Input<string>;
            monitors: pulumi.Input<pulumi.Input<string>[]>;
            pool?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesRbdSecretRef>;
            user?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesRbdSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesScaleIO {
            fsType?: pulumi.Input<string>;
            gateway: pulumi.Input<string>;
            protectionDomain?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesScaleIOSecretRef>;
            sslEnabled?: pulumi.Input<boolean>;
            storageMode?: pulumi.Input<string>;
            storagePool?: pulumi.Input<string>;
            system: pulumi.Input<string>;
            volumeName?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesScaleIOSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesSecret {
            defaultMode?: pulumi.Input<number>;
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesSecretItems>[]>;
            optional?: pulumi.Input<boolean>;
            secretName?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesSecretItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesStorageos {
            fsType?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesStorageosSecretRef>;
            volumeName?: pulumi.Input<string>;
            volumeNamespace?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesStorageosSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesVsphereVolume {
            fsType?: pulumi.Input<string>;
            storagePolicyID?: pulumi.Input<string>;
            storagePolicyName?: pulumi.Input<string>;
            volumePath: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRollover {
            affinity?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinity>;
            annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            conditions?: pulumi.Input<string>;
            image?: pulumi.Input<string>;
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            readTTL?: pulumi.Input<string>;
            resources?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverResources>;
            schedule?: pulumi.Input<string>;
            securityContext?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverSecurityContext>;
            serviceAccount?: pulumi.Input<string>;
            successfulJobsHistoryLimit?: pulumi.Input<number>;
            tolerations?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverTolerations>[]>;
            ttlSecondsAfterFinished?: pulumi.Input<number>;
            volumeMounts?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumeMounts>[]>;
            volumes?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumes>[]>;
        }

        export interface JaegerSpecStorageEsRolloverAffinity {
            nodeAffinity?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityNodeAffinity>;
            podAffinity?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityPodAffinity>;
            podAntiAffinity?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityPodAntiAffinity>;
        }

        export interface JaegerSpecStorageEsRolloverAffinityNodeAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>;
        }

        export interface JaegerSpecStorageEsRolloverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference>;
            weight: pulumi.Input<number>;
        }

        export interface JaegerSpecStorageEsRolloverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>[]>;
        }

        export interface JaegerSpecStorageEsRolloverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecStorageEsRolloverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecStorageEsRolloverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            nodeSelectorTerms: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>[]>;
        }

        export interface JaegerSpecStorageEsRolloverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>[]>;
        }

        export interface JaegerSpecStorageEsRolloverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecStorageEsRolloverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecStorageEsRolloverAffinityPodAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface JaegerSpecStorageEsRolloverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight: pulumi.Input<number>;
        }

        export interface JaegerSpecStorageEsRolloverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRolloverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecStorageEsRolloverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecStorageEsRolloverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRolloverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecStorageEsRolloverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecStorageEsRolloverAffinityPodAntiAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface JaegerSpecStorageEsRolloverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight: pulumi.Input<number>;
        }

        export interface JaegerSpecStorageEsRolloverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRolloverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecStorageEsRolloverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecStorageEsRolloverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRolloverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecStorageEsRolloverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecStorageEsRolloverResources {
            limits?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            requests?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecStorageEsRolloverSecurityContext {
            fsGroup?: pulumi.Input<number>;
            fsGroupChangePolicy?: pulumi.Input<string>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverSecurityContextSeLinuxOptions>;
            supplementalGroups?: pulumi.Input<pulumi.Input<number>[]>;
            sysctls?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverSecurityContextSysctls>[]>;
            windowsOptions?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverSecurityContextWindowsOptions>;
        }

        export interface JaegerSpecStorageEsRolloverSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRolloverSecurityContextSysctls {
            name: pulumi.Input<string>;
            value: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRolloverSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
            runAsUserName?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRolloverTolerations {
            effect?: pulumi.Input<string>;
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            tolerationSeconds?: pulumi.Input<number>;
            value?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRolloverVolumeMounts {
            mountPath: pulumi.Input<string>;
            mountPropagation?: pulumi.Input<string>;
            name: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            subPath?: pulumi.Input<string>;
            subPathExpr?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRolloverVolumes {
            awsElasticBlockStore?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesAwsElasticBlockStore>;
            azureDisk?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesAzureDisk>;
            azureFile?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesAzureFile>;
            cephfs?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesCephfs>;
            cinder?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesCinder>;
            configMap?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesConfigMap>;
            csi?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesCsi>;
            downwardAPI?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesDownwardAPI>;
            emptyDir?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesEmptyDir>;
            fc?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesFc>;
            flexVolume?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesFlexVolume>;
            flocker?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesFlocker>;
            gcePersistentDisk?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesGcePersistentDisk>;
            gitRepo?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesGitRepo>;
            glusterfs?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesGlusterfs>;
            hostPath?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesHostPath>;
            iscsi?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesIscsi>;
            name: pulumi.Input<string>;
            nfs?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesNfs>;
            persistentVolumeClaim?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesPersistentVolumeClaim>;
            photonPersistentDisk?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesPhotonPersistentDisk>;
            portworxVolume?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesPortworxVolume>;
            projected?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesProjected>;
            quobyte?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesQuobyte>;
            rbd?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesRbd>;
            scaleIO?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesScaleIO>;
            secret?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesSecret>;
            storageos?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesStorageos>;
            vsphereVolume?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesVsphereVolume>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesAwsElasticBlockStore {
            fsType?: pulumi.Input<string>;
            partition?: pulumi.Input<number>;
            readOnly?: pulumi.Input<boolean>;
            volumeID: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesAzureDisk {
            cachingMode?: pulumi.Input<string>;
            diskName: pulumi.Input<string>;
            diskURI: pulumi.Input<string>;
            fsType?: pulumi.Input<string>;
            kind?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesAzureFile {
            readOnly?: pulumi.Input<boolean>;
            secretName: pulumi.Input<string>;
            shareName: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesCephfs {
            monitors: pulumi.Input<pulumi.Input<string>[]>;
            path?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretFile?: pulumi.Input<string>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesCephfsSecretRef>;
            user?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesCephfsSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesCinder {
            fsType?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesCinderSecretRef>;
            volumeID: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesCinderSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesConfigMap {
            defaultMode?: pulumi.Input<number>;
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesConfigMapItems>[]>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesConfigMapItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesCsi {
            driver: pulumi.Input<string>;
            fsType?: pulumi.Input<string>;
            nodePublishSecretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesCsiNodePublishSecretRef>;
            readOnly?: pulumi.Input<boolean>;
            volumeAttributes?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesCsiNodePublishSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesDownwardAPI {
            defaultMode?: pulumi.Input<number>;
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesDownwardAPIItems>[]>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesDownwardAPIItems {
            fieldRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesDownwardAPIItemsFieldRef>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
            resourceFieldRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesDownwardAPIItemsResourceFieldRef>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesDownwardAPIItemsFieldRef {
            apiVersion?: pulumi.Input<string>;
            fieldPath: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesDownwardAPIItemsResourceFieldRef {
            containerName?: pulumi.Input<string>;
            divisor?: pulumi.Input<string>;
            resource: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesEmptyDir {
            medium?: pulumi.Input<string>;
            sizeLimit?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesFc {
            fsType?: pulumi.Input<string>;
            lun?: pulumi.Input<number>;
            readOnly?: pulumi.Input<boolean>;
            targetWWNs?: pulumi.Input<pulumi.Input<string>[]>;
            wwids?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesFlexVolume {
            driver: pulumi.Input<string>;
            fsType?: pulumi.Input<string>;
            options?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesFlexVolumeSecretRef>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesFlexVolumeSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesFlocker {
            datasetName?: pulumi.Input<string>;
            datasetUUID?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesGcePersistentDisk {
            fsType?: pulumi.Input<string>;
            partition?: pulumi.Input<number>;
            pdName: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesGitRepo {
            directory?: pulumi.Input<string>;
            repository: pulumi.Input<string>;
            revision?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesGlusterfs {
            endpoints: pulumi.Input<string>;
            path: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesHostPath {
            path: pulumi.Input<string>;
            type?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesIscsi {
            chapAuthDiscovery?: pulumi.Input<boolean>;
            chapAuthSession?: pulumi.Input<boolean>;
            fsType?: pulumi.Input<string>;
            initiatorName?: pulumi.Input<string>;
            iqn: pulumi.Input<string>;
            iscsiInterface?: pulumi.Input<string>;
            lun: pulumi.Input<number>;
            portals?: pulumi.Input<pulumi.Input<string>[]>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesIscsiSecretRef>;
            targetPortal: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesIscsiSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesNfs {
            path: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            server: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesPersistentVolumeClaim {
            claimName: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesPhotonPersistentDisk {
            fsType?: pulumi.Input<string>;
            pdID: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesPortworxVolume {
            fsType?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            volumeID: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesProjected {
            defaultMode?: pulumi.Input<number>;
            sources: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesProjectedSources>[]>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesProjectedSources {
            configMap?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesProjectedSourcesConfigMap>;
            downwardAPI?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesProjectedSourcesDownwardAPI>;
            secret?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesProjectedSourcesSecret>;
            serviceAccountToken?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesProjectedSourcesServiceAccountToken>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesProjectedSourcesConfigMap {
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesProjectedSourcesConfigMapItems>[]>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesProjectedSourcesConfigMapItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesProjectedSourcesDownwardAPI {
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesProjectedSourcesDownwardAPIItems>[]>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesProjectedSourcesDownwardAPIItems {
            fieldRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesProjectedSourcesDownwardAPIItemsFieldRef>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
            resourceFieldRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesProjectedSourcesDownwardAPIItemsFieldRef {
            apiVersion?: pulumi.Input<string>;
            fieldPath: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef {
            containerName?: pulumi.Input<string>;
            divisor?: pulumi.Input<string>;
            resource: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesProjectedSourcesSecret {
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesProjectedSourcesSecretItems>[]>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesProjectedSourcesSecretItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesProjectedSourcesServiceAccountToken {
            audience?: pulumi.Input<string>;
            expirationSeconds?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesQuobyte {
            group?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            registry: pulumi.Input<string>;
            tenant?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
            volume: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesRbd {
            fsType?: pulumi.Input<string>;
            image: pulumi.Input<string>;
            keyring?: pulumi.Input<string>;
            monitors: pulumi.Input<pulumi.Input<string>[]>;
            pool?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesRbdSecretRef>;
            user?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesRbdSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesScaleIO {
            fsType?: pulumi.Input<string>;
            gateway: pulumi.Input<string>;
            protectionDomain?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesScaleIOSecretRef>;
            sslEnabled?: pulumi.Input<boolean>;
            storageMode?: pulumi.Input<string>;
            storagePool?: pulumi.Input<string>;
            system: pulumi.Input<string>;
            volumeName?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesScaleIOSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesSecret {
            defaultMode?: pulumi.Input<number>;
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesSecretItems>[]>;
            optional?: pulumi.Input<boolean>;
            secretName?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesSecretItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesStorageos {
            fsType?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesStorageosSecretRef>;
            volumeName?: pulumi.Input<string>;
            volumeNamespace?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesStorageosSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecStorageEsRolloverVolumesVsphereVolume {
            fsType?: pulumi.Input<string>;
            storagePolicyID?: pulumi.Input<string>;
            storagePolicyName?: pulumi.Input<string>;
            volumePath: pulumi.Input<string>;
        }

        export interface JaegerSpecTolerations {
            effect?: pulumi.Input<string>;
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            tolerationSeconds?: pulumi.Input<number>;
            value?: pulumi.Input<string>;
        }

        export interface JaegerSpecUi {
            options?: pulumi.Input<{[key: string]: any}>;
        }

        export interface JaegerSpecVolumeMounts {
            mountPath: pulumi.Input<string>;
            mountPropagation?: pulumi.Input<string>;
            name: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            subPath?: pulumi.Input<string>;
            subPathExpr?: pulumi.Input<string>;
        }

        export interface JaegerSpecVolumes {
            awsElasticBlockStore?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesAwsElasticBlockStore>;
            azureDisk?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesAzureDisk>;
            azureFile?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesAzureFile>;
            cephfs?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesCephfs>;
            cinder?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesCinder>;
            configMap?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesConfigMap>;
            csi?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesCsi>;
            downwardAPI?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesDownwardAPI>;
            emptyDir?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesEmptyDir>;
            fc?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesFc>;
            flexVolume?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesFlexVolume>;
            flocker?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesFlocker>;
            gcePersistentDisk?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesGcePersistentDisk>;
            gitRepo?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesGitRepo>;
            glusterfs?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesGlusterfs>;
            hostPath?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesHostPath>;
            iscsi?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesIscsi>;
            name: pulumi.Input<string>;
            nfs?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesNfs>;
            persistentVolumeClaim?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesPersistentVolumeClaim>;
            photonPersistentDisk?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesPhotonPersistentDisk>;
            portworxVolume?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesPortworxVolume>;
            projected?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesProjected>;
            quobyte?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesQuobyte>;
            rbd?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesRbd>;
            scaleIO?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesScaleIO>;
            secret?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesSecret>;
            storageos?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesStorageos>;
            vsphereVolume?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesVsphereVolume>;
        }

        export interface JaegerSpecVolumesAwsElasticBlockStore {
            fsType?: pulumi.Input<string>;
            partition?: pulumi.Input<number>;
            readOnly?: pulumi.Input<boolean>;
            volumeID: pulumi.Input<string>;
        }

        export interface JaegerSpecVolumesAzureDisk {
            cachingMode?: pulumi.Input<string>;
            diskName: pulumi.Input<string>;
            diskURI: pulumi.Input<string>;
            fsType?: pulumi.Input<string>;
            kind?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecVolumesAzureFile {
            readOnly?: pulumi.Input<boolean>;
            secretName: pulumi.Input<string>;
            shareName: pulumi.Input<string>;
        }

        export interface JaegerSpecVolumesCephfs {
            monitors: pulumi.Input<pulumi.Input<string>[]>;
            path?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretFile?: pulumi.Input<string>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesCephfsSecretRef>;
            user?: pulumi.Input<string>;
        }

        export interface JaegerSpecVolumesCephfsSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecVolumesCinder {
            fsType?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesCinderSecretRef>;
            volumeID: pulumi.Input<string>;
        }

        export interface JaegerSpecVolumesCinderSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecVolumesConfigMap {
            defaultMode?: pulumi.Input<number>;
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesConfigMapItems>[]>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecVolumesConfigMapItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecVolumesCsi {
            driver: pulumi.Input<string>;
            fsType?: pulumi.Input<string>;
            nodePublishSecretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesCsiNodePublishSecretRef>;
            readOnly?: pulumi.Input<boolean>;
            volumeAttributes?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface JaegerSpecVolumesCsiNodePublishSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecVolumesDownwardAPI {
            defaultMode?: pulumi.Input<number>;
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesDownwardAPIItems>[]>;
        }

        export interface JaegerSpecVolumesDownwardAPIItems {
            fieldRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesDownwardAPIItemsFieldRef>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
            resourceFieldRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesDownwardAPIItemsResourceFieldRef>;
        }

        export interface JaegerSpecVolumesDownwardAPIItemsFieldRef {
            apiVersion?: pulumi.Input<string>;
            fieldPath: pulumi.Input<string>;
        }

        export interface JaegerSpecVolumesDownwardAPIItemsResourceFieldRef {
            containerName?: pulumi.Input<string>;
            divisor?: pulumi.Input<string>;
            resource: pulumi.Input<string>;
        }

        export interface JaegerSpecVolumesEmptyDir {
            medium?: pulumi.Input<string>;
            sizeLimit?: pulumi.Input<string>;
        }

        export interface JaegerSpecVolumesFc {
            fsType?: pulumi.Input<string>;
            lun?: pulumi.Input<number>;
            readOnly?: pulumi.Input<boolean>;
            targetWWNs?: pulumi.Input<pulumi.Input<string>[]>;
            wwids?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface JaegerSpecVolumesFlexVolume {
            driver: pulumi.Input<string>;
            fsType?: pulumi.Input<string>;
            options?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesFlexVolumeSecretRef>;
        }

        export interface JaegerSpecVolumesFlexVolumeSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecVolumesFlocker {
            datasetName?: pulumi.Input<string>;
            datasetUUID?: pulumi.Input<string>;
        }

        export interface JaegerSpecVolumesGcePersistentDisk {
            fsType?: pulumi.Input<string>;
            partition?: pulumi.Input<number>;
            pdName: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecVolumesGitRepo {
            directory?: pulumi.Input<string>;
            repository: pulumi.Input<string>;
            revision?: pulumi.Input<string>;
        }

        export interface JaegerSpecVolumesGlusterfs {
            endpoints: pulumi.Input<string>;
            path: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecVolumesHostPath {
            path: pulumi.Input<string>;
            type?: pulumi.Input<string>;
        }

        export interface JaegerSpecVolumesIscsi {
            chapAuthDiscovery?: pulumi.Input<boolean>;
            chapAuthSession?: pulumi.Input<boolean>;
            fsType?: pulumi.Input<string>;
            initiatorName?: pulumi.Input<string>;
            iqn: pulumi.Input<string>;
            iscsiInterface?: pulumi.Input<string>;
            lun: pulumi.Input<number>;
            portals?: pulumi.Input<pulumi.Input<string>[]>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesIscsiSecretRef>;
            targetPortal: pulumi.Input<string>;
        }

        export interface JaegerSpecVolumesIscsiSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecVolumesNfs {
            path: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            server: pulumi.Input<string>;
        }

        export interface JaegerSpecVolumesPersistentVolumeClaim {
            claimName: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecVolumesPhotonPersistentDisk {
            fsType?: pulumi.Input<string>;
            pdID: pulumi.Input<string>;
        }

        export interface JaegerSpecVolumesPortworxVolume {
            fsType?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            volumeID: pulumi.Input<string>;
        }

        export interface JaegerSpecVolumesProjected {
            defaultMode?: pulumi.Input<number>;
            sources: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesProjectedSources>[]>;
        }

        export interface JaegerSpecVolumesProjectedSources {
            configMap?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesProjectedSourcesConfigMap>;
            downwardAPI?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesProjectedSourcesDownwardAPI>;
            secret?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesProjectedSourcesSecret>;
            serviceAccountToken?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesProjectedSourcesServiceAccountToken>;
        }

        export interface JaegerSpecVolumesProjectedSourcesConfigMap {
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesProjectedSourcesConfigMapItems>[]>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecVolumesProjectedSourcesConfigMapItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecVolumesProjectedSourcesDownwardAPI {
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesProjectedSourcesDownwardAPIItems>[]>;
        }

        export interface JaegerSpecVolumesProjectedSourcesDownwardAPIItems {
            fieldRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesProjectedSourcesDownwardAPIItemsFieldRef>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
            resourceFieldRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef>;
        }

        export interface JaegerSpecVolumesProjectedSourcesDownwardAPIItemsFieldRef {
            apiVersion?: pulumi.Input<string>;
            fieldPath: pulumi.Input<string>;
        }

        export interface JaegerSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef {
            containerName?: pulumi.Input<string>;
            divisor?: pulumi.Input<string>;
            resource: pulumi.Input<string>;
        }

        export interface JaegerSpecVolumesProjectedSourcesSecret {
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesProjectedSourcesSecretItems>[]>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface JaegerSpecVolumesProjectedSourcesSecretItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecVolumesProjectedSourcesServiceAccountToken {
            audience?: pulumi.Input<string>;
            expirationSeconds?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecVolumesQuobyte {
            group?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            registry: pulumi.Input<string>;
            tenant?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
            volume: pulumi.Input<string>;
        }

        export interface JaegerSpecVolumesRbd {
            fsType?: pulumi.Input<string>;
            image: pulumi.Input<string>;
            keyring?: pulumi.Input<string>;
            monitors: pulumi.Input<pulumi.Input<string>[]>;
            pool?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesRbdSecretRef>;
            user?: pulumi.Input<string>;
        }

        export interface JaegerSpecVolumesRbdSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecVolumesScaleIO {
            fsType?: pulumi.Input<string>;
            gateway: pulumi.Input<string>;
            protectionDomain?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesScaleIOSecretRef>;
            sslEnabled?: pulumi.Input<boolean>;
            storageMode?: pulumi.Input<string>;
            storagePool?: pulumi.Input<string>;
            system: pulumi.Input<string>;
            volumeName?: pulumi.Input<string>;
        }

        export interface JaegerSpecVolumesScaleIOSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecVolumesSecret {
            defaultMode?: pulumi.Input<number>;
            items?: pulumi.Input<pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesSecretItems>[]>;
            optional?: pulumi.Input<boolean>;
            secretName?: pulumi.Input<string>;
        }

        export interface JaegerSpecVolumesSecretItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface JaegerSpecVolumesStorageos {
            fsType?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.jaegertracing.v1.JaegerSpecVolumesStorageosSecretRef>;
            volumeName?: pulumi.Input<string>;
            volumeNamespace?: pulumi.Input<string>;
        }

        export interface JaegerSpecVolumesStorageosSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface JaegerSpecVolumesVsphereVolume {
            fsType?: pulumi.Input<string>;
            storagePolicyID?: pulumi.Input<string>;
            storagePolicyName?: pulumi.Input<string>;
            volumePath: pulumi.Input<string>;
        }

        export interface JaegerStatus {
            phase: pulumi.Input<string>;
            version: pulumi.Input<string>;
        }
    }
}
