// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

import {ObjectMeta} from "../meta/v1";

export namespace jaegertracing {
    export namespace v1 {
        export interface JaegerSpec {
            affinity?: outputs.jaegertracing.v1.JaegerSpecAffinity;
            agent?: outputs.jaegertracing.v1.JaegerSpecAgent;
            allInOne?: outputs.jaegertracing.v1.JaegerSpecAllInOne;
            annotations?: {[key: string]: string};
            collector?: outputs.jaegertracing.v1.JaegerSpecCollector;
            ingester?: outputs.jaegertracing.v1.JaegerSpecIngester;
            ingress?: outputs.jaegertracing.v1.JaegerSpecIngress;
            labels?: {[key: string]: string};
            query?: outputs.jaegertracing.v1.JaegerSpecQuery;
            resources?: outputs.jaegertracing.v1.JaegerSpecResources;
            sampling?: outputs.jaegertracing.v1.JaegerSpecSampling;
            securityContext?: outputs.jaegertracing.v1.JaegerSpecSecurityContext;
            serviceAccount?: string;
            storage?: outputs.jaegertracing.v1.JaegerSpecStorage;
            strategy?: string;
            tolerations?: outputs.jaegertracing.v1.JaegerSpecTolerations[];
            ui?: outputs.jaegertracing.v1.JaegerSpecUi;
            volumeMounts?: outputs.jaegertracing.v1.JaegerSpecVolumeMounts[];
            volumes?: outputs.jaegertracing.v1.JaegerSpecVolumes[];
        }

        export interface JaegerSpecAffinity {
            nodeAffinity?: outputs.jaegertracing.v1.JaegerSpecAffinityNodeAffinity;
            podAffinity?: outputs.jaegertracing.v1.JaegerSpecAffinityPodAffinity;
            podAntiAffinity?: outputs.jaegertracing.v1.JaegerSpecAffinityPodAntiAffinity;
        }

        export interface JaegerSpecAffinityNodeAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
            requiredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
        }

        export interface JaegerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference: outputs.jaegertracing.v1.JaegerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
            weight: number;
        }

        export interface JaegerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];
            matchFields?: outputs.jaegertracing.v1.JaegerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];
        }

        export interface JaegerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            nodeSelectorTerms: outputs.jaegertracing.v1.JaegerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];
        }

        export interface JaegerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];
            matchFields?: outputs.jaegertracing.v1.JaegerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];
        }

        export interface JaegerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecAffinityPodAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
            requiredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
        }

        export interface JaegerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: outputs.jaegertracing.v1.JaegerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
            weight: number;
        }

        export interface JaegerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: outputs.jaegertracing.v1.JaegerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
            namespaces?: string[];
            topologyKey: string;
        }

        export interface JaegerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];
            matchLabels?: {[key: string]: string};
        }

        export interface JaegerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: outputs.jaegertracing.v1.JaegerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
            namespaces?: string[];
            topologyKey: string;
        }

        export interface JaegerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];
            matchLabels?: {[key: string]: string};
        }

        export interface JaegerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecAffinityPodAntiAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
            requiredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
        }

        export interface JaegerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: outputs.jaegertracing.v1.JaegerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
            weight: number;
        }

        export interface JaegerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: outputs.jaegertracing.v1.JaegerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
            namespaces?: string[];
            topologyKey: string;
        }

        export interface JaegerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];
            matchLabels?: {[key: string]: string};
        }

        export interface JaegerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: outputs.jaegertracing.v1.JaegerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
            namespaces?: string[];
            topologyKey: string;
        }

        export interface JaegerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];
            matchLabels?: {[key: string]: string};
        }

        export interface JaegerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecAgent {
            affinity?: outputs.jaegertracing.v1.JaegerSpecAgentAffinity;
            annotations?: {[key: string]: string};
            config?: {[key: string]: any};
            image?: string;
            imagePullSecrets?: outputs.jaegertracing.v1.JaegerSpecAgentImagePullSecrets[];
            labels?: {[key: string]: string};
            options?: {[key: string]: any};
            resources?: outputs.jaegertracing.v1.JaegerSpecAgentResources;
            securityContext?: outputs.jaegertracing.v1.JaegerSpecAgentSecurityContext;
            serviceAccount?: string;
            sidecarSecurityContext?: outputs.jaegertracing.v1.JaegerSpecAgentSidecarSecurityContext;
            strategy?: string;
            tolerations?: outputs.jaegertracing.v1.JaegerSpecAgentTolerations[];
            volumeMounts?: outputs.jaegertracing.v1.JaegerSpecAgentVolumeMounts[];
            volumes?: outputs.jaegertracing.v1.JaegerSpecAgentVolumes[];
        }

        export interface JaegerSpecAgentAffinity {
            nodeAffinity?: outputs.jaegertracing.v1.JaegerSpecAgentAffinityNodeAffinity;
            podAffinity?: outputs.jaegertracing.v1.JaegerSpecAgentAffinityPodAffinity;
            podAntiAffinity?: outputs.jaegertracing.v1.JaegerSpecAgentAffinityPodAntiAffinity;
        }

        export interface JaegerSpecAgentAffinityNodeAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
            requiredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
        }

        export interface JaegerSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference: outputs.jaegertracing.v1.JaegerSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
            weight: number;
        }

        export interface JaegerSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];
            matchFields?: outputs.jaegertracing.v1.JaegerSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];
        }

        export interface JaegerSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecAgentAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            nodeSelectorTerms: outputs.jaegertracing.v1.JaegerSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];
        }

        export interface JaegerSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];
            matchFields?: outputs.jaegertracing.v1.JaegerSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];
        }

        export interface JaegerSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecAgentAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecAgentAffinityPodAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
            requiredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
        }

        export interface JaegerSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: outputs.jaegertracing.v1.JaegerSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
            weight: number;
        }

        export interface JaegerSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: outputs.jaegertracing.v1.JaegerSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
            namespaces?: string[];
            topologyKey: string;
        }

        export interface JaegerSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];
            matchLabels?: {[key: string]: string};
        }

        export interface JaegerSpecAgentAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: outputs.jaegertracing.v1.JaegerSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
            namespaces?: string[];
            topologyKey: string;
        }

        export interface JaegerSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];
            matchLabels?: {[key: string]: string};
        }

        export interface JaegerSpecAgentAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecAgentAffinityPodAntiAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
            requiredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
        }

        export interface JaegerSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: outputs.jaegertracing.v1.JaegerSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
            weight: number;
        }

        export interface JaegerSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: outputs.jaegertracing.v1.JaegerSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
            namespaces?: string[];
            topologyKey: string;
        }

        export interface JaegerSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];
            matchLabels?: {[key: string]: string};
        }

        export interface JaegerSpecAgentAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: outputs.jaegertracing.v1.JaegerSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
            namespaces?: string[];
            topologyKey: string;
        }

        export interface JaegerSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];
            matchLabels?: {[key: string]: string};
        }

        export interface JaegerSpecAgentAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecAgentImagePullSecrets {
            name?: string;
        }

        export interface JaegerSpecAgentResources {
            limits?: {[key: string]: string};
            requests?: {[key: string]: string};
        }

        export interface JaegerSpecAgentSecurityContext {
            fsGroup?: number;
            fsGroupChangePolicy?: string;
            runAsGroup?: number;
            runAsNonRoot?: boolean;
            runAsUser?: number;
            seLinuxOptions?: outputs.jaegertracing.v1.JaegerSpecAgentSecurityContextSeLinuxOptions;
            supplementalGroups?: number[];
            sysctls?: outputs.jaegertracing.v1.JaegerSpecAgentSecurityContextSysctls[];
            windowsOptions?: outputs.jaegertracing.v1.JaegerSpecAgentSecurityContextWindowsOptions;
        }

        export interface JaegerSpecAgentSecurityContextSeLinuxOptions {
            level?: string;
            role?: string;
            type?: string;
            user?: string;
        }

        export interface JaegerSpecAgentSecurityContextSysctls {
            name: string;
            value: string;
        }

        export interface JaegerSpecAgentSecurityContextWindowsOptions {
            gmsaCredentialSpec?: string;
            gmsaCredentialSpecName?: string;
            runAsUserName?: string;
        }

        export interface JaegerSpecAgentSidecarSecurityContext {
            allowPrivilegeEscalation?: boolean;
            capabilities?: outputs.jaegertracing.v1.JaegerSpecAgentSidecarSecurityContextCapabilities;
            privileged?: boolean;
            procMount?: string;
            readOnlyRootFilesystem?: boolean;
            runAsGroup?: number;
            runAsNonRoot?: boolean;
            runAsUser?: number;
            seLinuxOptions?: outputs.jaegertracing.v1.JaegerSpecAgentSidecarSecurityContextSeLinuxOptions;
            windowsOptions?: outputs.jaegertracing.v1.JaegerSpecAgentSidecarSecurityContextWindowsOptions;
        }

        export interface JaegerSpecAgentSidecarSecurityContextCapabilities {
            add?: string[];
            drop?: string[];
        }

        export interface JaegerSpecAgentSidecarSecurityContextSeLinuxOptions {
            level?: string;
            role?: string;
            type?: string;
            user?: string;
        }

        export interface JaegerSpecAgentSidecarSecurityContextWindowsOptions {
            gmsaCredentialSpec?: string;
            gmsaCredentialSpecName?: string;
            runAsUserName?: string;
        }

        export interface JaegerSpecAgentTolerations {
            effect?: string;
            key?: string;
            operator?: string;
            tolerationSeconds?: number;
            value?: string;
        }

        export interface JaegerSpecAgentVolumeMounts {
            mountPath: string;
            mountPropagation?: string;
            name: string;
            readOnly?: boolean;
            subPath?: string;
            subPathExpr?: string;
        }

        export interface JaegerSpecAgentVolumes {
            awsElasticBlockStore?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesAwsElasticBlockStore;
            azureDisk?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesAzureDisk;
            azureFile?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesAzureFile;
            cephfs?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesCephfs;
            cinder?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesCinder;
            configMap?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesConfigMap;
            csi?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesCsi;
            downwardAPI?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesDownwardAPI;
            emptyDir?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesEmptyDir;
            fc?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesFc;
            flexVolume?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesFlexVolume;
            flocker?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesFlocker;
            gcePersistentDisk?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesGcePersistentDisk;
            gitRepo?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesGitRepo;
            glusterfs?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesGlusterfs;
            hostPath?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesHostPath;
            iscsi?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesIscsi;
            name: string;
            nfs?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesNfs;
            persistentVolumeClaim?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesPersistentVolumeClaim;
            photonPersistentDisk?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesPhotonPersistentDisk;
            portworxVolume?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesPortworxVolume;
            projected?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesProjected;
            quobyte?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesQuobyte;
            rbd?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesRbd;
            scaleIO?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesScaleIO;
            secret?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesSecret;
            storageos?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesStorageos;
            vsphereVolume?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesVsphereVolume;
        }

        export interface JaegerSpecAgentVolumesAwsElasticBlockStore {
            fsType?: string;
            partition?: number;
            readOnly?: boolean;
            volumeID: string;
        }

        export interface JaegerSpecAgentVolumesAzureDisk {
            cachingMode?: string;
            diskName: string;
            diskURI: string;
            fsType?: string;
            kind?: string;
            readOnly?: boolean;
        }

        export interface JaegerSpecAgentVolumesAzureFile {
            readOnly?: boolean;
            secretName: string;
            shareName: string;
        }

        export interface JaegerSpecAgentVolumesCephfs {
            monitors: string[];
            path?: string;
            readOnly?: boolean;
            secretFile?: string;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesCephfsSecretRef;
            user?: string;
        }

        export interface JaegerSpecAgentVolumesCephfsSecretRef {
            name?: string;
        }

        export interface JaegerSpecAgentVolumesCinder {
            fsType?: string;
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesCinderSecretRef;
            volumeID: string;
        }

        export interface JaegerSpecAgentVolumesCinderSecretRef {
            name?: string;
        }

        export interface JaegerSpecAgentVolumesConfigMap {
            defaultMode?: number;
            items?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesConfigMapItems[];
            name?: string;
            optional?: boolean;
        }

        export interface JaegerSpecAgentVolumesConfigMapItems {
            key: string;
            mode?: number;
            path: string;
        }

        export interface JaegerSpecAgentVolumesCsi {
            driver: string;
            fsType?: string;
            nodePublishSecretRef?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesCsiNodePublishSecretRef;
            readOnly?: boolean;
            volumeAttributes?: {[key: string]: string};
        }

        export interface JaegerSpecAgentVolumesCsiNodePublishSecretRef {
            name?: string;
        }

        export interface JaegerSpecAgentVolumesDownwardAPI {
            defaultMode?: number;
            items?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesDownwardAPIItems[];
        }

        export interface JaegerSpecAgentVolumesDownwardAPIItems {
            fieldRef?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesDownwardAPIItemsFieldRef;
            mode?: number;
            path: string;
            resourceFieldRef?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesDownwardAPIItemsResourceFieldRef;
        }

        export interface JaegerSpecAgentVolumesDownwardAPIItemsFieldRef {
            apiVersion?: string;
            fieldPath: string;
        }

        export interface JaegerSpecAgentVolumesDownwardAPIItemsResourceFieldRef {
            containerName?: string;
            divisor?: string;
            resource: string;
        }

        export interface JaegerSpecAgentVolumesEmptyDir {
            medium?: string;
            sizeLimit?: string;
        }

        export interface JaegerSpecAgentVolumesFc {
            fsType?: string;
            lun?: number;
            readOnly?: boolean;
            targetWWNs?: string[];
            wwids?: string[];
        }

        export interface JaegerSpecAgentVolumesFlexVolume {
            driver: string;
            fsType?: string;
            options?: {[key: string]: string};
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesFlexVolumeSecretRef;
        }

        export interface JaegerSpecAgentVolumesFlexVolumeSecretRef {
            name?: string;
        }

        export interface JaegerSpecAgentVolumesFlocker {
            datasetName?: string;
            datasetUUID?: string;
        }

        export interface JaegerSpecAgentVolumesGcePersistentDisk {
            fsType?: string;
            partition?: number;
            pdName: string;
            readOnly?: boolean;
        }

        export interface JaegerSpecAgentVolumesGitRepo {
            directory?: string;
            repository: string;
            revision?: string;
        }

        export interface JaegerSpecAgentVolumesGlusterfs {
            endpoints: string;
            path: string;
            readOnly?: boolean;
        }

        export interface JaegerSpecAgentVolumesHostPath {
            path: string;
            type?: string;
        }

        export interface JaegerSpecAgentVolumesIscsi {
            chapAuthDiscovery?: boolean;
            chapAuthSession?: boolean;
            fsType?: string;
            initiatorName?: string;
            iqn: string;
            iscsiInterface?: string;
            lun: number;
            portals?: string[];
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesIscsiSecretRef;
            targetPortal: string;
        }

        export interface JaegerSpecAgentVolumesIscsiSecretRef {
            name?: string;
        }

        export interface JaegerSpecAgentVolumesNfs {
            path: string;
            readOnly?: boolean;
            server: string;
        }

        export interface JaegerSpecAgentVolumesPersistentVolumeClaim {
            claimName: string;
            readOnly?: boolean;
        }

        export interface JaegerSpecAgentVolumesPhotonPersistentDisk {
            fsType?: string;
            pdID: string;
        }

        export interface JaegerSpecAgentVolumesPortworxVolume {
            fsType?: string;
            readOnly?: boolean;
            volumeID: string;
        }

        export interface JaegerSpecAgentVolumesProjected {
            defaultMode?: number;
            sources: outputs.jaegertracing.v1.JaegerSpecAgentVolumesProjectedSources[];
        }

        export interface JaegerSpecAgentVolumesProjectedSources {
            configMap?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesProjectedSourcesConfigMap;
            downwardAPI?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesProjectedSourcesDownwardAPI;
            secret?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesProjectedSourcesSecret;
            serviceAccountToken?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesProjectedSourcesServiceAccountToken;
        }

        export interface JaegerSpecAgentVolumesProjectedSourcesConfigMap {
            items?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesProjectedSourcesConfigMapItems[];
            name?: string;
            optional?: boolean;
        }

        export interface JaegerSpecAgentVolumesProjectedSourcesConfigMapItems {
            key: string;
            mode?: number;
            path: string;
        }

        export interface JaegerSpecAgentVolumesProjectedSourcesDownwardAPI {
            items?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesProjectedSourcesDownwardAPIItems[];
        }

        export interface JaegerSpecAgentVolumesProjectedSourcesDownwardAPIItems {
            fieldRef?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesProjectedSourcesDownwardAPIItemsFieldRef;
            mode?: number;
            path: string;
            resourceFieldRef?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef;
        }

        export interface JaegerSpecAgentVolumesProjectedSourcesDownwardAPIItemsFieldRef {
            apiVersion?: string;
            fieldPath: string;
        }

        export interface JaegerSpecAgentVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef {
            containerName?: string;
            divisor?: string;
            resource: string;
        }

        export interface JaegerSpecAgentVolumesProjectedSourcesSecret {
            items?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesProjectedSourcesSecretItems[];
            name?: string;
            optional?: boolean;
        }

        export interface JaegerSpecAgentVolumesProjectedSourcesSecretItems {
            key: string;
            mode?: number;
            path: string;
        }

        export interface JaegerSpecAgentVolumesProjectedSourcesServiceAccountToken {
            audience?: string;
            expirationSeconds?: number;
            path: string;
        }

        export interface JaegerSpecAgentVolumesQuobyte {
            group?: string;
            readOnly?: boolean;
            registry: string;
            tenant?: string;
            user?: string;
            volume: string;
        }

        export interface JaegerSpecAgentVolumesRbd {
            fsType?: string;
            image: string;
            keyring?: string;
            monitors: string[];
            pool?: string;
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesRbdSecretRef;
            user?: string;
        }

        export interface JaegerSpecAgentVolumesRbdSecretRef {
            name?: string;
        }

        export interface JaegerSpecAgentVolumesScaleIO {
            fsType?: string;
            gateway: string;
            protectionDomain?: string;
            readOnly?: boolean;
            secretRef: outputs.jaegertracing.v1.JaegerSpecAgentVolumesScaleIOSecretRef;
            sslEnabled?: boolean;
            storageMode?: string;
            storagePool?: string;
            system: string;
            volumeName?: string;
        }

        export interface JaegerSpecAgentVolumesScaleIOSecretRef {
            name?: string;
        }

        export interface JaegerSpecAgentVolumesSecret {
            defaultMode?: number;
            items?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesSecretItems[];
            optional?: boolean;
            secretName?: string;
        }

        export interface JaegerSpecAgentVolumesSecretItems {
            key: string;
            mode?: number;
            path: string;
        }

        export interface JaegerSpecAgentVolumesStorageos {
            fsType?: string;
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecAgentVolumesStorageosSecretRef;
            volumeName?: string;
            volumeNamespace?: string;
        }

        export interface JaegerSpecAgentVolumesStorageosSecretRef {
            name?: string;
        }

        export interface JaegerSpecAgentVolumesVsphereVolume {
            fsType?: string;
            storagePolicyID?: string;
            storagePolicyName?: string;
            volumePath: string;
        }

        export interface JaegerSpecAllInOne {
            affinity?: outputs.jaegertracing.v1.JaegerSpecAllInOneAffinity;
            annotations?: {[key: string]: string};
            config?: {[key: string]: any};
            image?: string;
            labels?: {[key: string]: string};
            options?: {[key: string]: any};
            resources?: outputs.jaegertracing.v1.JaegerSpecAllInOneResources;
            securityContext?: outputs.jaegertracing.v1.JaegerSpecAllInOneSecurityContext;
            serviceAccount?: string;
            tolerations?: outputs.jaegertracing.v1.JaegerSpecAllInOneTolerations[];
            volumeMounts?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumeMounts[];
            volumes?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumes[];
        }

        export interface JaegerSpecAllInOneAffinity {
            nodeAffinity?: outputs.jaegertracing.v1.JaegerSpecAllInOneAffinityNodeAffinity;
            podAffinity?: outputs.jaegertracing.v1.JaegerSpecAllInOneAffinityPodAffinity;
            podAntiAffinity?: outputs.jaegertracing.v1.JaegerSpecAllInOneAffinityPodAntiAffinity;
        }

        export interface JaegerSpecAllInOneAffinityNodeAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecAllInOneAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
            requiredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecAllInOneAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
        }

        export interface JaegerSpecAllInOneAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference: outputs.jaegertracing.v1.JaegerSpecAllInOneAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
            weight: number;
        }

        export interface JaegerSpecAllInOneAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecAllInOneAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];
            matchFields?: outputs.jaegertracing.v1.JaegerSpecAllInOneAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];
        }

        export interface JaegerSpecAllInOneAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecAllInOneAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecAllInOneAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            nodeSelectorTerms: outputs.jaegertracing.v1.JaegerSpecAllInOneAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];
        }

        export interface JaegerSpecAllInOneAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecAllInOneAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];
            matchFields?: outputs.jaegertracing.v1.JaegerSpecAllInOneAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];
        }

        export interface JaegerSpecAllInOneAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecAllInOneAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecAllInOneAffinityPodAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecAllInOneAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
            requiredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecAllInOneAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
        }

        export interface JaegerSpecAllInOneAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: outputs.jaegertracing.v1.JaegerSpecAllInOneAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
            weight: number;
        }

        export interface JaegerSpecAllInOneAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: outputs.jaegertracing.v1.JaegerSpecAllInOneAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
            namespaces?: string[];
            topologyKey: string;
        }

        export interface JaegerSpecAllInOneAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecAllInOneAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];
            matchLabels?: {[key: string]: string};
        }

        export interface JaegerSpecAllInOneAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecAllInOneAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: outputs.jaegertracing.v1.JaegerSpecAllInOneAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
            namespaces?: string[];
            topologyKey: string;
        }

        export interface JaegerSpecAllInOneAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecAllInOneAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];
            matchLabels?: {[key: string]: string};
        }

        export interface JaegerSpecAllInOneAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecAllInOneAffinityPodAntiAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecAllInOneAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
            requiredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecAllInOneAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
        }

        export interface JaegerSpecAllInOneAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: outputs.jaegertracing.v1.JaegerSpecAllInOneAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
            weight: number;
        }

        export interface JaegerSpecAllInOneAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: outputs.jaegertracing.v1.JaegerSpecAllInOneAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
            namespaces?: string[];
            topologyKey: string;
        }

        export interface JaegerSpecAllInOneAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecAllInOneAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];
            matchLabels?: {[key: string]: string};
        }

        export interface JaegerSpecAllInOneAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecAllInOneAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: outputs.jaegertracing.v1.JaegerSpecAllInOneAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
            namespaces?: string[];
            topologyKey: string;
        }

        export interface JaegerSpecAllInOneAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecAllInOneAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];
            matchLabels?: {[key: string]: string};
        }

        export interface JaegerSpecAllInOneAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecAllInOneResources {
            limits?: {[key: string]: string};
            requests?: {[key: string]: string};
        }

        export interface JaegerSpecAllInOneSecurityContext {
            fsGroup?: number;
            fsGroupChangePolicy?: string;
            runAsGroup?: number;
            runAsNonRoot?: boolean;
            runAsUser?: number;
            seLinuxOptions?: outputs.jaegertracing.v1.JaegerSpecAllInOneSecurityContextSeLinuxOptions;
            supplementalGroups?: number[];
            sysctls?: outputs.jaegertracing.v1.JaegerSpecAllInOneSecurityContextSysctls[];
            windowsOptions?: outputs.jaegertracing.v1.JaegerSpecAllInOneSecurityContextWindowsOptions;
        }

        export interface JaegerSpecAllInOneSecurityContextSeLinuxOptions {
            level?: string;
            role?: string;
            type?: string;
            user?: string;
        }

        export interface JaegerSpecAllInOneSecurityContextSysctls {
            name: string;
            value: string;
        }

        export interface JaegerSpecAllInOneSecurityContextWindowsOptions {
            gmsaCredentialSpec?: string;
            gmsaCredentialSpecName?: string;
            runAsUserName?: string;
        }

        export interface JaegerSpecAllInOneTolerations {
            effect?: string;
            key?: string;
            operator?: string;
            tolerationSeconds?: number;
            value?: string;
        }

        export interface JaegerSpecAllInOneVolumeMounts {
            mountPath: string;
            mountPropagation?: string;
            name: string;
            readOnly?: boolean;
            subPath?: string;
            subPathExpr?: string;
        }

        export interface JaegerSpecAllInOneVolumes {
            awsElasticBlockStore?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesAwsElasticBlockStore;
            azureDisk?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesAzureDisk;
            azureFile?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesAzureFile;
            cephfs?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesCephfs;
            cinder?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesCinder;
            configMap?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesConfigMap;
            csi?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesCsi;
            downwardAPI?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesDownwardAPI;
            emptyDir?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesEmptyDir;
            fc?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesFc;
            flexVolume?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesFlexVolume;
            flocker?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesFlocker;
            gcePersistentDisk?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesGcePersistentDisk;
            gitRepo?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesGitRepo;
            glusterfs?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesGlusterfs;
            hostPath?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesHostPath;
            iscsi?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesIscsi;
            name: string;
            nfs?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesNfs;
            persistentVolumeClaim?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesPersistentVolumeClaim;
            photonPersistentDisk?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesPhotonPersistentDisk;
            portworxVolume?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesPortworxVolume;
            projected?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesProjected;
            quobyte?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesQuobyte;
            rbd?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesRbd;
            scaleIO?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesScaleIO;
            secret?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesSecret;
            storageos?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesStorageos;
            vsphereVolume?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesVsphereVolume;
        }

        export interface JaegerSpecAllInOneVolumesAwsElasticBlockStore {
            fsType?: string;
            partition?: number;
            readOnly?: boolean;
            volumeID: string;
        }

        export interface JaegerSpecAllInOneVolumesAzureDisk {
            cachingMode?: string;
            diskName: string;
            diskURI: string;
            fsType?: string;
            kind?: string;
            readOnly?: boolean;
        }

        export interface JaegerSpecAllInOneVolumesAzureFile {
            readOnly?: boolean;
            secretName: string;
            shareName: string;
        }

        export interface JaegerSpecAllInOneVolumesCephfs {
            monitors: string[];
            path?: string;
            readOnly?: boolean;
            secretFile?: string;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesCephfsSecretRef;
            user?: string;
        }

        export interface JaegerSpecAllInOneVolumesCephfsSecretRef {
            name?: string;
        }

        export interface JaegerSpecAllInOneVolumesCinder {
            fsType?: string;
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesCinderSecretRef;
            volumeID: string;
        }

        export interface JaegerSpecAllInOneVolumesCinderSecretRef {
            name?: string;
        }

        export interface JaegerSpecAllInOneVolumesConfigMap {
            defaultMode?: number;
            items?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesConfigMapItems[];
            name?: string;
            optional?: boolean;
        }

        export interface JaegerSpecAllInOneVolumesConfigMapItems {
            key: string;
            mode?: number;
            path: string;
        }

        export interface JaegerSpecAllInOneVolumesCsi {
            driver: string;
            fsType?: string;
            nodePublishSecretRef?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesCsiNodePublishSecretRef;
            readOnly?: boolean;
            volumeAttributes?: {[key: string]: string};
        }

        export interface JaegerSpecAllInOneVolumesCsiNodePublishSecretRef {
            name?: string;
        }

        export interface JaegerSpecAllInOneVolumesDownwardAPI {
            defaultMode?: number;
            items?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesDownwardAPIItems[];
        }

        export interface JaegerSpecAllInOneVolumesDownwardAPIItems {
            fieldRef?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesDownwardAPIItemsFieldRef;
            mode?: number;
            path: string;
            resourceFieldRef?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesDownwardAPIItemsResourceFieldRef;
        }

        export interface JaegerSpecAllInOneVolumesDownwardAPIItemsFieldRef {
            apiVersion?: string;
            fieldPath: string;
        }

        export interface JaegerSpecAllInOneVolumesDownwardAPIItemsResourceFieldRef {
            containerName?: string;
            divisor?: string;
            resource: string;
        }

        export interface JaegerSpecAllInOneVolumesEmptyDir {
            medium?: string;
            sizeLimit?: string;
        }

        export interface JaegerSpecAllInOneVolumesFc {
            fsType?: string;
            lun?: number;
            readOnly?: boolean;
            targetWWNs?: string[];
            wwids?: string[];
        }

        export interface JaegerSpecAllInOneVolumesFlexVolume {
            driver: string;
            fsType?: string;
            options?: {[key: string]: string};
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesFlexVolumeSecretRef;
        }

        export interface JaegerSpecAllInOneVolumesFlexVolumeSecretRef {
            name?: string;
        }

        export interface JaegerSpecAllInOneVolumesFlocker {
            datasetName?: string;
            datasetUUID?: string;
        }

        export interface JaegerSpecAllInOneVolumesGcePersistentDisk {
            fsType?: string;
            partition?: number;
            pdName: string;
            readOnly?: boolean;
        }

        export interface JaegerSpecAllInOneVolumesGitRepo {
            directory?: string;
            repository: string;
            revision?: string;
        }

        export interface JaegerSpecAllInOneVolumesGlusterfs {
            endpoints: string;
            path: string;
            readOnly?: boolean;
        }

        export interface JaegerSpecAllInOneVolumesHostPath {
            path: string;
            type?: string;
        }

        export interface JaegerSpecAllInOneVolumesIscsi {
            chapAuthDiscovery?: boolean;
            chapAuthSession?: boolean;
            fsType?: string;
            initiatorName?: string;
            iqn: string;
            iscsiInterface?: string;
            lun: number;
            portals?: string[];
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesIscsiSecretRef;
            targetPortal: string;
        }

        export interface JaegerSpecAllInOneVolumesIscsiSecretRef {
            name?: string;
        }

        export interface JaegerSpecAllInOneVolumesNfs {
            path: string;
            readOnly?: boolean;
            server: string;
        }

        export interface JaegerSpecAllInOneVolumesPersistentVolumeClaim {
            claimName: string;
            readOnly?: boolean;
        }

        export interface JaegerSpecAllInOneVolumesPhotonPersistentDisk {
            fsType?: string;
            pdID: string;
        }

        export interface JaegerSpecAllInOneVolumesPortworxVolume {
            fsType?: string;
            readOnly?: boolean;
            volumeID: string;
        }

        export interface JaegerSpecAllInOneVolumesProjected {
            defaultMode?: number;
            sources: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesProjectedSources[];
        }

        export interface JaegerSpecAllInOneVolumesProjectedSources {
            configMap?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesProjectedSourcesConfigMap;
            downwardAPI?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesProjectedSourcesDownwardAPI;
            secret?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesProjectedSourcesSecret;
            serviceAccountToken?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesProjectedSourcesServiceAccountToken;
        }

        export interface JaegerSpecAllInOneVolumesProjectedSourcesConfigMap {
            items?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesProjectedSourcesConfigMapItems[];
            name?: string;
            optional?: boolean;
        }

        export interface JaegerSpecAllInOneVolumesProjectedSourcesConfigMapItems {
            key: string;
            mode?: number;
            path: string;
        }

        export interface JaegerSpecAllInOneVolumesProjectedSourcesDownwardAPI {
            items?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesProjectedSourcesDownwardAPIItems[];
        }

        export interface JaegerSpecAllInOneVolumesProjectedSourcesDownwardAPIItems {
            fieldRef?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesProjectedSourcesDownwardAPIItemsFieldRef;
            mode?: number;
            path: string;
            resourceFieldRef?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef;
        }

        export interface JaegerSpecAllInOneVolumesProjectedSourcesDownwardAPIItemsFieldRef {
            apiVersion?: string;
            fieldPath: string;
        }

        export interface JaegerSpecAllInOneVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef {
            containerName?: string;
            divisor?: string;
            resource: string;
        }

        export interface JaegerSpecAllInOneVolumesProjectedSourcesSecret {
            items?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesProjectedSourcesSecretItems[];
            name?: string;
            optional?: boolean;
        }

        export interface JaegerSpecAllInOneVolumesProjectedSourcesSecretItems {
            key: string;
            mode?: number;
            path: string;
        }

        export interface JaegerSpecAllInOneVolumesProjectedSourcesServiceAccountToken {
            audience?: string;
            expirationSeconds?: number;
            path: string;
        }

        export interface JaegerSpecAllInOneVolumesQuobyte {
            group?: string;
            readOnly?: boolean;
            registry: string;
            tenant?: string;
            user?: string;
            volume: string;
        }

        export interface JaegerSpecAllInOneVolumesRbd {
            fsType?: string;
            image: string;
            keyring?: string;
            monitors: string[];
            pool?: string;
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesRbdSecretRef;
            user?: string;
        }

        export interface JaegerSpecAllInOneVolumesRbdSecretRef {
            name?: string;
        }

        export interface JaegerSpecAllInOneVolumesScaleIO {
            fsType?: string;
            gateway: string;
            protectionDomain?: string;
            readOnly?: boolean;
            secretRef: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesScaleIOSecretRef;
            sslEnabled?: boolean;
            storageMode?: string;
            storagePool?: string;
            system: string;
            volumeName?: string;
        }

        export interface JaegerSpecAllInOneVolumesScaleIOSecretRef {
            name?: string;
        }

        export interface JaegerSpecAllInOneVolumesSecret {
            defaultMode?: number;
            items?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesSecretItems[];
            optional?: boolean;
            secretName?: string;
        }

        export interface JaegerSpecAllInOneVolumesSecretItems {
            key: string;
            mode?: number;
            path: string;
        }

        export interface JaegerSpecAllInOneVolumesStorageos {
            fsType?: string;
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecAllInOneVolumesStorageosSecretRef;
            volumeName?: string;
            volumeNamespace?: string;
        }

        export interface JaegerSpecAllInOneVolumesStorageosSecretRef {
            name?: string;
        }

        export interface JaegerSpecAllInOneVolumesVsphereVolume {
            fsType?: string;
            storagePolicyID?: string;
            storagePolicyName?: string;
            volumePath: string;
        }

        export interface JaegerSpecCollector {
            affinity?: outputs.jaegertracing.v1.JaegerSpecCollectorAffinity;
            annotations?: {[key: string]: string};
            autoscale?: boolean;
            config?: {[key: string]: any};
            image?: string;
            labels?: {[key: string]: string};
            maxReplicas?: number;
            minReplicas?: number;
            options?: {[key: string]: any};
            replicas?: number;
            resources?: outputs.jaegertracing.v1.JaegerSpecCollectorResources;
            securityContext?: outputs.jaegertracing.v1.JaegerSpecCollectorSecurityContext;
            serviceAccount?: string;
            tolerations?: outputs.jaegertracing.v1.JaegerSpecCollectorTolerations[];
            volumeMounts?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumeMounts[];
            volumes?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumes[];
        }

        export interface JaegerSpecCollectorAffinity {
            nodeAffinity?: outputs.jaegertracing.v1.JaegerSpecCollectorAffinityNodeAffinity;
            podAffinity?: outputs.jaegertracing.v1.JaegerSpecCollectorAffinityPodAffinity;
            podAntiAffinity?: outputs.jaegertracing.v1.JaegerSpecCollectorAffinityPodAntiAffinity;
        }

        export interface JaegerSpecCollectorAffinityNodeAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecCollectorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
            requiredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecCollectorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
        }

        export interface JaegerSpecCollectorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference: outputs.jaegertracing.v1.JaegerSpecCollectorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
            weight: number;
        }

        export interface JaegerSpecCollectorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecCollectorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];
            matchFields?: outputs.jaegertracing.v1.JaegerSpecCollectorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];
        }

        export interface JaegerSpecCollectorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecCollectorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecCollectorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            nodeSelectorTerms: outputs.jaegertracing.v1.JaegerSpecCollectorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];
        }

        export interface JaegerSpecCollectorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecCollectorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];
            matchFields?: outputs.jaegertracing.v1.JaegerSpecCollectorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];
        }

        export interface JaegerSpecCollectorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecCollectorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecCollectorAffinityPodAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecCollectorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
            requiredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecCollectorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
        }

        export interface JaegerSpecCollectorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: outputs.jaegertracing.v1.JaegerSpecCollectorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
            weight: number;
        }

        export interface JaegerSpecCollectorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: outputs.jaegertracing.v1.JaegerSpecCollectorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
            namespaces?: string[];
            topologyKey: string;
        }

        export interface JaegerSpecCollectorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecCollectorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];
            matchLabels?: {[key: string]: string};
        }

        export interface JaegerSpecCollectorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecCollectorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: outputs.jaegertracing.v1.JaegerSpecCollectorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
            namespaces?: string[];
            topologyKey: string;
        }

        export interface JaegerSpecCollectorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecCollectorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];
            matchLabels?: {[key: string]: string};
        }

        export interface JaegerSpecCollectorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecCollectorAffinityPodAntiAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecCollectorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
            requiredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecCollectorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
        }

        export interface JaegerSpecCollectorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: outputs.jaegertracing.v1.JaegerSpecCollectorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
            weight: number;
        }

        export interface JaegerSpecCollectorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: outputs.jaegertracing.v1.JaegerSpecCollectorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
            namespaces?: string[];
            topologyKey: string;
        }

        export interface JaegerSpecCollectorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecCollectorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];
            matchLabels?: {[key: string]: string};
        }

        export interface JaegerSpecCollectorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecCollectorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: outputs.jaegertracing.v1.JaegerSpecCollectorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
            namespaces?: string[];
            topologyKey: string;
        }

        export interface JaegerSpecCollectorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecCollectorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];
            matchLabels?: {[key: string]: string};
        }

        export interface JaegerSpecCollectorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecCollectorResources {
            limits?: {[key: string]: string};
            requests?: {[key: string]: string};
        }

        export interface JaegerSpecCollectorSecurityContext {
            fsGroup?: number;
            fsGroupChangePolicy?: string;
            runAsGroup?: number;
            runAsNonRoot?: boolean;
            runAsUser?: number;
            seLinuxOptions?: outputs.jaegertracing.v1.JaegerSpecCollectorSecurityContextSeLinuxOptions;
            supplementalGroups?: number[];
            sysctls?: outputs.jaegertracing.v1.JaegerSpecCollectorSecurityContextSysctls[];
            windowsOptions?: outputs.jaegertracing.v1.JaegerSpecCollectorSecurityContextWindowsOptions;
        }

        export interface JaegerSpecCollectorSecurityContextSeLinuxOptions {
            level?: string;
            role?: string;
            type?: string;
            user?: string;
        }

        export interface JaegerSpecCollectorSecurityContextSysctls {
            name: string;
            value: string;
        }

        export interface JaegerSpecCollectorSecurityContextWindowsOptions {
            gmsaCredentialSpec?: string;
            gmsaCredentialSpecName?: string;
            runAsUserName?: string;
        }

        export interface JaegerSpecCollectorTolerations {
            effect?: string;
            key?: string;
            operator?: string;
            tolerationSeconds?: number;
            value?: string;
        }

        export interface JaegerSpecCollectorVolumeMounts {
            mountPath: string;
            mountPropagation?: string;
            name: string;
            readOnly?: boolean;
            subPath?: string;
            subPathExpr?: string;
        }

        export interface JaegerSpecCollectorVolumes {
            awsElasticBlockStore?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesAwsElasticBlockStore;
            azureDisk?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesAzureDisk;
            azureFile?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesAzureFile;
            cephfs?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesCephfs;
            cinder?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesCinder;
            configMap?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesConfigMap;
            csi?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesCsi;
            downwardAPI?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesDownwardAPI;
            emptyDir?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesEmptyDir;
            fc?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesFc;
            flexVolume?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesFlexVolume;
            flocker?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesFlocker;
            gcePersistentDisk?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesGcePersistentDisk;
            gitRepo?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesGitRepo;
            glusterfs?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesGlusterfs;
            hostPath?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesHostPath;
            iscsi?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesIscsi;
            name: string;
            nfs?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesNfs;
            persistentVolumeClaim?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesPersistentVolumeClaim;
            photonPersistentDisk?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesPhotonPersistentDisk;
            portworxVolume?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesPortworxVolume;
            projected?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesProjected;
            quobyte?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesQuobyte;
            rbd?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesRbd;
            scaleIO?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesScaleIO;
            secret?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesSecret;
            storageos?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesStorageos;
            vsphereVolume?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesVsphereVolume;
        }

        export interface JaegerSpecCollectorVolumesAwsElasticBlockStore {
            fsType?: string;
            partition?: number;
            readOnly?: boolean;
            volumeID: string;
        }

        export interface JaegerSpecCollectorVolumesAzureDisk {
            cachingMode?: string;
            diskName: string;
            diskURI: string;
            fsType?: string;
            kind?: string;
            readOnly?: boolean;
        }

        export interface JaegerSpecCollectorVolumesAzureFile {
            readOnly?: boolean;
            secretName: string;
            shareName: string;
        }

        export interface JaegerSpecCollectorVolumesCephfs {
            monitors: string[];
            path?: string;
            readOnly?: boolean;
            secretFile?: string;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesCephfsSecretRef;
            user?: string;
        }

        export interface JaegerSpecCollectorVolumesCephfsSecretRef {
            name?: string;
        }

        export interface JaegerSpecCollectorVolumesCinder {
            fsType?: string;
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesCinderSecretRef;
            volumeID: string;
        }

        export interface JaegerSpecCollectorVolumesCinderSecretRef {
            name?: string;
        }

        export interface JaegerSpecCollectorVolumesConfigMap {
            defaultMode?: number;
            items?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesConfigMapItems[];
            name?: string;
            optional?: boolean;
        }

        export interface JaegerSpecCollectorVolumesConfigMapItems {
            key: string;
            mode?: number;
            path: string;
        }

        export interface JaegerSpecCollectorVolumesCsi {
            driver: string;
            fsType?: string;
            nodePublishSecretRef?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesCsiNodePublishSecretRef;
            readOnly?: boolean;
            volumeAttributes?: {[key: string]: string};
        }

        export interface JaegerSpecCollectorVolumesCsiNodePublishSecretRef {
            name?: string;
        }

        export interface JaegerSpecCollectorVolumesDownwardAPI {
            defaultMode?: number;
            items?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesDownwardAPIItems[];
        }

        export interface JaegerSpecCollectorVolumesDownwardAPIItems {
            fieldRef?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesDownwardAPIItemsFieldRef;
            mode?: number;
            path: string;
            resourceFieldRef?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesDownwardAPIItemsResourceFieldRef;
        }

        export interface JaegerSpecCollectorVolumesDownwardAPIItemsFieldRef {
            apiVersion?: string;
            fieldPath: string;
        }

        export interface JaegerSpecCollectorVolumesDownwardAPIItemsResourceFieldRef {
            containerName?: string;
            divisor?: string;
            resource: string;
        }

        export interface JaegerSpecCollectorVolumesEmptyDir {
            medium?: string;
            sizeLimit?: string;
        }

        export interface JaegerSpecCollectorVolumesFc {
            fsType?: string;
            lun?: number;
            readOnly?: boolean;
            targetWWNs?: string[];
            wwids?: string[];
        }

        export interface JaegerSpecCollectorVolumesFlexVolume {
            driver: string;
            fsType?: string;
            options?: {[key: string]: string};
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesFlexVolumeSecretRef;
        }

        export interface JaegerSpecCollectorVolumesFlexVolumeSecretRef {
            name?: string;
        }

        export interface JaegerSpecCollectorVolumesFlocker {
            datasetName?: string;
            datasetUUID?: string;
        }

        export interface JaegerSpecCollectorVolumesGcePersistentDisk {
            fsType?: string;
            partition?: number;
            pdName: string;
            readOnly?: boolean;
        }

        export interface JaegerSpecCollectorVolumesGitRepo {
            directory?: string;
            repository: string;
            revision?: string;
        }

        export interface JaegerSpecCollectorVolumesGlusterfs {
            endpoints: string;
            path: string;
            readOnly?: boolean;
        }

        export interface JaegerSpecCollectorVolumesHostPath {
            path: string;
            type?: string;
        }

        export interface JaegerSpecCollectorVolumesIscsi {
            chapAuthDiscovery?: boolean;
            chapAuthSession?: boolean;
            fsType?: string;
            initiatorName?: string;
            iqn: string;
            iscsiInterface?: string;
            lun: number;
            portals?: string[];
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesIscsiSecretRef;
            targetPortal: string;
        }

        export interface JaegerSpecCollectorVolumesIscsiSecretRef {
            name?: string;
        }

        export interface JaegerSpecCollectorVolumesNfs {
            path: string;
            readOnly?: boolean;
            server: string;
        }

        export interface JaegerSpecCollectorVolumesPersistentVolumeClaim {
            claimName: string;
            readOnly?: boolean;
        }

        export interface JaegerSpecCollectorVolumesPhotonPersistentDisk {
            fsType?: string;
            pdID: string;
        }

        export interface JaegerSpecCollectorVolumesPortworxVolume {
            fsType?: string;
            readOnly?: boolean;
            volumeID: string;
        }

        export interface JaegerSpecCollectorVolumesProjected {
            defaultMode?: number;
            sources: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesProjectedSources[];
        }

        export interface JaegerSpecCollectorVolumesProjectedSources {
            configMap?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesProjectedSourcesConfigMap;
            downwardAPI?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesProjectedSourcesDownwardAPI;
            secret?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesProjectedSourcesSecret;
            serviceAccountToken?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesProjectedSourcesServiceAccountToken;
        }

        export interface JaegerSpecCollectorVolumesProjectedSourcesConfigMap {
            items?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesProjectedSourcesConfigMapItems[];
            name?: string;
            optional?: boolean;
        }

        export interface JaegerSpecCollectorVolumesProjectedSourcesConfigMapItems {
            key: string;
            mode?: number;
            path: string;
        }

        export interface JaegerSpecCollectorVolumesProjectedSourcesDownwardAPI {
            items?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesProjectedSourcesDownwardAPIItems[];
        }

        export interface JaegerSpecCollectorVolumesProjectedSourcesDownwardAPIItems {
            fieldRef?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesProjectedSourcesDownwardAPIItemsFieldRef;
            mode?: number;
            path: string;
            resourceFieldRef?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef;
        }

        export interface JaegerSpecCollectorVolumesProjectedSourcesDownwardAPIItemsFieldRef {
            apiVersion?: string;
            fieldPath: string;
        }

        export interface JaegerSpecCollectorVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef {
            containerName?: string;
            divisor?: string;
            resource: string;
        }

        export interface JaegerSpecCollectorVolumesProjectedSourcesSecret {
            items?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesProjectedSourcesSecretItems[];
            name?: string;
            optional?: boolean;
        }

        export interface JaegerSpecCollectorVolumesProjectedSourcesSecretItems {
            key: string;
            mode?: number;
            path: string;
        }

        export interface JaegerSpecCollectorVolumesProjectedSourcesServiceAccountToken {
            audience?: string;
            expirationSeconds?: number;
            path: string;
        }

        export interface JaegerSpecCollectorVolumesQuobyte {
            group?: string;
            readOnly?: boolean;
            registry: string;
            tenant?: string;
            user?: string;
            volume: string;
        }

        export interface JaegerSpecCollectorVolumesRbd {
            fsType?: string;
            image: string;
            keyring?: string;
            monitors: string[];
            pool?: string;
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesRbdSecretRef;
            user?: string;
        }

        export interface JaegerSpecCollectorVolumesRbdSecretRef {
            name?: string;
        }

        export interface JaegerSpecCollectorVolumesScaleIO {
            fsType?: string;
            gateway: string;
            protectionDomain?: string;
            readOnly?: boolean;
            secretRef: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesScaleIOSecretRef;
            sslEnabled?: boolean;
            storageMode?: string;
            storagePool?: string;
            system: string;
            volumeName?: string;
        }

        export interface JaegerSpecCollectorVolumesScaleIOSecretRef {
            name?: string;
        }

        export interface JaegerSpecCollectorVolumesSecret {
            defaultMode?: number;
            items?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesSecretItems[];
            optional?: boolean;
            secretName?: string;
        }

        export interface JaegerSpecCollectorVolumesSecretItems {
            key: string;
            mode?: number;
            path: string;
        }

        export interface JaegerSpecCollectorVolumesStorageos {
            fsType?: string;
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecCollectorVolumesStorageosSecretRef;
            volumeName?: string;
            volumeNamespace?: string;
        }

        export interface JaegerSpecCollectorVolumesStorageosSecretRef {
            name?: string;
        }

        export interface JaegerSpecCollectorVolumesVsphereVolume {
            fsType?: string;
            storagePolicyID?: string;
            storagePolicyName?: string;
            volumePath: string;
        }

        export interface JaegerSpecIngester {
            affinity?: outputs.jaegertracing.v1.JaegerSpecIngesterAffinity;
            annotations?: {[key: string]: string};
            autoscale?: boolean;
            config?: {[key: string]: any};
            image?: string;
            labels?: {[key: string]: string};
            maxReplicas?: number;
            minReplicas?: number;
            options?: {[key: string]: any};
            replicas?: number;
            resources?: outputs.jaegertracing.v1.JaegerSpecIngesterResources;
            securityContext?: outputs.jaegertracing.v1.JaegerSpecIngesterSecurityContext;
            serviceAccount?: string;
            tolerations?: outputs.jaegertracing.v1.JaegerSpecIngesterTolerations[];
            volumeMounts?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumeMounts[];
            volumes?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumes[];
        }

        export interface JaegerSpecIngesterAffinity {
            nodeAffinity?: outputs.jaegertracing.v1.JaegerSpecIngesterAffinityNodeAffinity;
            podAffinity?: outputs.jaegertracing.v1.JaegerSpecIngesterAffinityPodAffinity;
            podAntiAffinity?: outputs.jaegertracing.v1.JaegerSpecIngesterAffinityPodAntiAffinity;
        }

        export interface JaegerSpecIngesterAffinityNodeAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecIngesterAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
            requiredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecIngesterAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
        }

        export interface JaegerSpecIngesterAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference: outputs.jaegertracing.v1.JaegerSpecIngesterAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
            weight: number;
        }

        export interface JaegerSpecIngesterAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecIngesterAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];
            matchFields?: outputs.jaegertracing.v1.JaegerSpecIngesterAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];
        }

        export interface JaegerSpecIngesterAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecIngesterAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecIngesterAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            nodeSelectorTerms: outputs.jaegertracing.v1.JaegerSpecIngesterAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];
        }

        export interface JaegerSpecIngesterAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecIngesterAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];
            matchFields?: outputs.jaegertracing.v1.JaegerSpecIngesterAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];
        }

        export interface JaegerSpecIngesterAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecIngesterAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecIngesterAffinityPodAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecIngesterAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
            requiredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecIngesterAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
        }

        export interface JaegerSpecIngesterAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: outputs.jaegertracing.v1.JaegerSpecIngesterAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
            weight: number;
        }

        export interface JaegerSpecIngesterAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: outputs.jaegertracing.v1.JaegerSpecIngesterAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
            namespaces?: string[];
            topologyKey: string;
        }

        export interface JaegerSpecIngesterAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecIngesterAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];
            matchLabels?: {[key: string]: string};
        }

        export interface JaegerSpecIngesterAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecIngesterAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: outputs.jaegertracing.v1.JaegerSpecIngesterAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
            namespaces?: string[];
            topologyKey: string;
        }

        export interface JaegerSpecIngesterAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecIngesterAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];
            matchLabels?: {[key: string]: string};
        }

        export interface JaegerSpecIngesterAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecIngesterAffinityPodAntiAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecIngesterAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
            requiredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecIngesterAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
        }

        export interface JaegerSpecIngesterAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: outputs.jaegertracing.v1.JaegerSpecIngesterAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
            weight: number;
        }

        export interface JaegerSpecIngesterAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: outputs.jaegertracing.v1.JaegerSpecIngesterAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
            namespaces?: string[];
            topologyKey: string;
        }

        export interface JaegerSpecIngesterAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecIngesterAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];
            matchLabels?: {[key: string]: string};
        }

        export interface JaegerSpecIngesterAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecIngesterAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: outputs.jaegertracing.v1.JaegerSpecIngesterAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
            namespaces?: string[];
            topologyKey: string;
        }

        export interface JaegerSpecIngesterAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecIngesterAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];
            matchLabels?: {[key: string]: string};
        }

        export interface JaegerSpecIngesterAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecIngesterResources {
            limits?: {[key: string]: string};
            requests?: {[key: string]: string};
        }

        export interface JaegerSpecIngesterSecurityContext {
            fsGroup?: number;
            fsGroupChangePolicy?: string;
            runAsGroup?: number;
            runAsNonRoot?: boolean;
            runAsUser?: number;
            seLinuxOptions?: outputs.jaegertracing.v1.JaegerSpecIngesterSecurityContextSeLinuxOptions;
            supplementalGroups?: number[];
            sysctls?: outputs.jaegertracing.v1.JaegerSpecIngesterSecurityContextSysctls[];
            windowsOptions?: outputs.jaegertracing.v1.JaegerSpecIngesterSecurityContextWindowsOptions;
        }

        export interface JaegerSpecIngesterSecurityContextSeLinuxOptions {
            level?: string;
            role?: string;
            type?: string;
            user?: string;
        }

        export interface JaegerSpecIngesterSecurityContextSysctls {
            name: string;
            value: string;
        }

        export interface JaegerSpecIngesterSecurityContextWindowsOptions {
            gmsaCredentialSpec?: string;
            gmsaCredentialSpecName?: string;
            runAsUserName?: string;
        }

        export interface JaegerSpecIngesterTolerations {
            effect?: string;
            key?: string;
            operator?: string;
            tolerationSeconds?: number;
            value?: string;
        }

        export interface JaegerSpecIngesterVolumeMounts {
            mountPath: string;
            mountPropagation?: string;
            name: string;
            readOnly?: boolean;
            subPath?: string;
            subPathExpr?: string;
        }

        export interface JaegerSpecIngesterVolumes {
            awsElasticBlockStore?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesAwsElasticBlockStore;
            azureDisk?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesAzureDisk;
            azureFile?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesAzureFile;
            cephfs?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesCephfs;
            cinder?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesCinder;
            configMap?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesConfigMap;
            csi?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesCsi;
            downwardAPI?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesDownwardAPI;
            emptyDir?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesEmptyDir;
            fc?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesFc;
            flexVolume?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesFlexVolume;
            flocker?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesFlocker;
            gcePersistentDisk?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesGcePersistentDisk;
            gitRepo?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesGitRepo;
            glusterfs?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesGlusterfs;
            hostPath?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesHostPath;
            iscsi?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesIscsi;
            name: string;
            nfs?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesNfs;
            persistentVolumeClaim?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesPersistentVolumeClaim;
            photonPersistentDisk?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesPhotonPersistentDisk;
            portworxVolume?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesPortworxVolume;
            projected?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesProjected;
            quobyte?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesQuobyte;
            rbd?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesRbd;
            scaleIO?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesScaleIO;
            secret?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesSecret;
            storageos?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesStorageos;
            vsphereVolume?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesVsphereVolume;
        }

        export interface JaegerSpecIngesterVolumesAwsElasticBlockStore {
            fsType?: string;
            partition?: number;
            readOnly?: boolean;
            volumeID: string;
        }

        export interface JaegerSpecIngesterVolumesAzureDisk {
            cachingMode?: string;
            diskName: string;
            diskURI: string;
            fsType?: string;
            kind?: string;
            readOnly?: boolean;
        }

        export interface JaegerSpecIngesterVolumesAzureFile {
            readOnly?: boolean;
            secretName: string;
            shareName: string;
        }

        export interface JaegerSpecIngesterVolumesCephfs {
            monitors: string[];
            path?: string;
            readOnly?: boolean;
            secretFile?: string;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesCephfsSecretRef;
            user?: string;
        }

        export interface JaegerSpecIngesterVolumesCephfsSecretRef {
            name?: string;
        }

        export interface JaegerSpecIngesterVolumesCinder {
            fsType?: string;
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesCinderSecretRef;
            volumeID: string;
        }

        export interface JaegerSpecIngesterVolumesCinderSecretRef {
            name?: string;
        }

        export interface JaegerSpecIngesterVolumesConfigMap {
            defaultMode?: number;
            items?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesConfigMapItems[];
            name?: string;
            optional?: boolean;
        }

        export interface JaegerSpecIngesterVolumesConfigMapItems {
            key: string;
            mode?: number;
            path: string;
        }

        export interface JaegerSpecIngesterVolumesCsi {
            driver: string;
            fsType?: string;
            nodePublishSecretRef?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesCsiNodePublishSecretRef;
            readOnly?: boolean;
            volumeAttributes?: {[key: string]: string};
        }

        export interface JaegerSpecIngesterVolumesCsiNodePublishSecretRef {
            name?: string;
        }

        export interface JaegerSpecIngesterVolumesDownwardAPI {
            defaultMode?: number;
            items?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesDownwardAPIItems[];
        }

        export interface JaegerSpecIngesterVolumesDownwardAPIItems {
            fieldRef?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesDownwardAPIItemsFieldRef;
            mode?: number;
            path: string;
            resourceFieldRef?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesDownwardAPIItemsResourceFieldRef;
        }

        export interface JaegerSpecIngesterVolumesDownwardAPIItemsFieldRef {
            apiVersion?: string;
            fieldPath: string;
        }

        export interface JaegerSpecIngesterVolumesDownwardAPIItemsResourceFieldRef {
            containerName?: string;
            divisor?: string;
            resource: string;
        }

        export interface JaegerSpecIngesterVolumesEmptyDir {
            medium?: string;
            sizeLimit?: string;
        }

        export interface JaegerSpecIngesterVolumesFc {
            fsType?: string;
            lun?: number;
            readOnly?: boolean;
            targetWWNs?: string[];
            wwids?: string[];
        }

        export interface JaegerSpecIngesterVolumesFlexVolume {
            driver: string;
            fsType?: string;
            options?: {[key: string]: string};
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesFlexVolumeSecretRef;
        }

        export interface JaegerSpecIngesterVolumesFlexVolumeSecretRef {
            name?: string;
        }

        export interface JaegerSpecIngesterVolumesFlocker {
            datasetName?: string;
            datasetUUID?: string;
        }

        export interface JaegerSpecIngesterVolumesGcePersistentDisk {
            fsType?: string;
            partition?: number;
            pdName: string;
            readOnly?: boolean;
        }

        export interface JaegerSpecIngesterVolumesGitRepo {
            directory?: string;
            repository: string;
            revision?: string;
        }

        export interface JaegerSpecIngesterVolumesGlusterfs {
            endpoints: string;
            path: string;
            readOnly?: boolean;
        }

        export interface JaegerSpecIngesterVolumesHostPath {
            path: string;
            type?: string;
        }

        export interface JaegerSpecIngesterVolumesIscsi {
            chapAuthDiscovery?: boolean;
            chapAuthSession?: boolean;
            fsType?: string;
            initiatorName?: string;
            iqn: string;
            iscsiInterface?: string;
            lun: number;
            portals?: string[];
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesIscsiSecretRef;
            targetPortal: string;
        }

        export interface JaegerSpecIngesterVolumesIscsiSecretRef {
            name?: string;
        }

        export interface JaegerSpecIngesterVolumesNfs {
            path: string;
            readOnly?: boolean;
            server: string;
        }

        export interface JaegerSpecIngesterVolumesPersistentVolumeClaim {
            claimName: string;
            readOnly?: boolean;
        }

        export interface JaegerSpecIngesterVolumesPhotonPersistentDisk {
            fsType?: string;
            pdID: string;
        }

        export interface JaegerSpecIngesterVolumesPortworxVolume {
            fsType?: string;
            readOnly?: boolean;
            volumeID: string;
        }

        export interface JaegerSpecIngesterVolumesProjected {
            defaultMode?: number;
            sources: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesProjectedSources[];
        }

        export interface JaegerSpecIngesterVolumesProjectedSources {
            configMap?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesProjectedSourcesConfigMap;
            downwardAPI?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesProjectedSourcesDownwardAPI;
            secret?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesProjectedSourcesSecret;
            serviceAccountToken?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesProjectedSourcesServiceAccountToken;
        }

        export interface JaegerSpecIngesterVolumesProjectedSourcesConfigMap {
            items?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesProjectedSourcesConfigMapItems[];
            name?: string;
            optional?: boolean;
        }

        export interface JaegerSpecIngesterVolumesProjectedSourcesConfigMapItems {
            key: string;
            mode?: number;
            path: string;
        }

        export interface JaegerSpecIngesterVolumesProjectedSourcesDownwardAPI {
            items?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesProjectedSourcesDownwardAPIItems[];
        }

        export interface JaegerSpecIngesterVolumesProjectedSourcesDownwardAPIItems {
            fieldRef?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesProjectedSourcesDownwardAPIItemsFieldRef;
            mode?: number;
            path: string;
            resourceFieldRef?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef;
        }

        export interface JaegerSpecIngesterVolumesProjectedSourcesDownwardAPIItemsFieldRef {
            apiVersion?: string;
            fieldPath: string;
        }

        export interface JaegerSpecIngesterVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef {
            containerName?: string;
            divisor?: string;
            resource: string;
        }

        export interface JaegerSpecIngesterVolumesProjectedSourcesSecret {
            items?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesProjectedSourcesSecretItems[];
            name?: string;
            optional?: boolean;
        }

        export interface JaegerSpecIngesterVolumesProjectedSourcesSecretItems {
            key: string;
            mode?: number;
            path: string;
        }

        export interface JaegerSpecIngesterVolumesProjectedSourcesServiceAccountToken {
            audience?: string;
            expirationSeconds?: number;
            path: string;
        }

        export interface JaegerSpecIngesterVolumesQuobyte {
            group?: string;
            readOnly?: boolean;
            registry: string;
            tenant?: string;
            user?: string;
            volume: string;
        }

        export interface JaegerSpecIngesterVolumesRbd {
            fsType?: string;
            image: string;
            keyring?: string;
            monitors: string[];
            pool?: string;
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesRbdSecretRef;
            user?: string;
        }

        export interface JaegerSpecIngesterVolumesRbdSecretRef {
            name?: string;
        }

        export interface JaegerSpecIngesterVolumesScaleIO {
            fsType?: string;
            gateway: string;
            protectionDomain?: string;
            readOnly?: boolean;
            secretRef: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesScaleIOSecretRef;
            sslEnabled?: boolean;
            storageMode?: string;
            storagePool?: string;
            system: string;
            volumeName?: string;
        }

        export interface JaegerSpecIngesterVolumesScaleIOSecretRef {
            name?: string;
        }

        export interface JaegerSpecIngesterVolumesSecret {
            defaultMode?: number;
            items?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesSecretItems[];
            optional?: boolean;
            secretName?: string;
        }

        export interface JaegerSpecIngesterVolumesSecretItems {
            key: string;
            mode?: number;
            path: string;
        }

        export interface JaegerSpecIngesterVolumesStorageos {
            fsType?: string;
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecIngesterVolumesStorageosSecretRef;
            volumeName?: string;
            volumeNamespace?: string;
        }

        export interface JaegerSpecIngesterVolumesStorageosSecretRef {
            name?: string;
        }

        export interface JaegerSpecIngesterVolumesVsphereVolume {
            fsType?: string;
            storagePolicyID?: string;
            storagePolicyName?: string;
            volumePath: string;
        }

        export interface JaegerSpecIngress {
            affinity?: outputs.jaegertracing.v1.JaegerSpecIngressAffinity;
            annotations?: {[key: string]: string};
            enabled?: boolean;
            hosts?: string[];
            labels?: {[key: string]: string};
            openshift?: outputs.jaegertracing.v1.JaegerSpecIngressOpenshift;
            options?: {[key: string]: any};
            resources?: outputs.jaegertracing.v1.JaegerSpecIngressResources;
            secretName?: string;
            security?: string;
            securityContext?: outputs.jaegertracing.v1.JaegerSpecIngressSecurityContext;
            serviceAccount?: string;
            tls?: outputs.jaegertracing.v1.JaegerSpecIngressTls[];
            tolerations?: outputs.jaegertracing.v1.JaegerSpecIngressTolerations[];
            volumeMounts?: outputs.jaegertracing.v1.JaegerSpecIngressVolumeMounts[];
            volumes?: outputs.jaegertracing.v1.JaegerSpecIngressVolumes[];
        }

        export interface JaegerSpecIngressAffinity {
            nodeAffinity?: outputs.jaegertracing.v1.JaegerSpecIngressAffinityNodeAffinity;
            podAffinity?: outputs.jaegertracing.v1.JaegerSpecIngressAffinityPodAffinity;
            podAntiAffinity?: outputs.jaegertracing.v1.JaegerSpecIngressAffinityPodAntiAffinity;
        }

        export interface JaegerSpecIngressAffinityNodeAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecIngressAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
            requiredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecIngressAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
        }

        export interface JaegerSpecIngressAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference: outputs.jaegertracing.v1.JaegerSpecIngressAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
            weight: number;
        }

        export interface JaegerSpecIngressAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecIngressAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];
            matchFields?: outputs.jaegertracing.v1.JaegerSpecIngressAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];
        }

        export interface JaegerSpecIngressAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecIngressAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecIngressAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            nodeSelectorTerms: outputs.jaegertracing.v1.JaegerSpecIngressAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];
        }

        export interface JaegerSpecIngressAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecIngressAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];
            matchFields?: outputs.jaegertracing.v1.JaegerSpecIngressAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];
        }

        export interface JaegerSpecIngressAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecIngressAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecIngressAffinityPodAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecIngressAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
            requiredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecIngressAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
        }

        export interface JaegerSpecIngressAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: outputs.jaegertracing.v1.JaegerSpecIngressAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
            weight: number;
        }

        export interface JaegerSpecIngressAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: outputs.jaegertracing.v1.JaegerSpecIngressAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
            namespaces?: string[];
            topologyKey: string;
        }

        export interface JaegerSpecIngressAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecIngressAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];
            matchLabels?: {[key: string]: string};
        }

        export interface JaegerSpecIngressAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecIngressAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: outputs.jaegertracing.v1.JaegerSpecIngressAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
            namespaces?: string[];
            topologyKey: string;
        }

        export interface JaegerSpecIngressAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecIngressAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];
            matchLabels?: {[key: string]: string};
        }

        export interface JaegerSpecIngressAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecIngressAffinityPodAntiAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecIngressAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
            requiredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecIngressAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
        }

        export interface JaegerSpecIngressAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: outputs.jaegertracing.v1.JaegerSpecIngressAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
            weight: number;
        }

        export interface JaegerSpecIngressAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: outputs.jaegertracing.v1.JaegerSpecIngressAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
            namespaces?: string[];
            topologyKey: string;
        }

        export interface JaegerSpecIngressAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecIngressAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];
            matchLabels?: {[key: string]: string};
        }

        export interface JaegerSpecIngressAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecIngressAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: outputs.jaegertracing.v1.JaegerSpecIngressAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
            namespaces?: string[];
            topologyKey: string;
        }

        export interface JaegerSpecIngressAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecIngressAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];
            matchLabels?: {[key: string]: string};
        }

        export interface JaegerSpecIngressAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecIngressOpenshift {
            delegateUrls?: string;
            htpasswdFile?: string;
            sar?: string;
            skipLogout?: boolean;
        }

        export interface JaegerSpecIngressResources {
            limits?: {[key: string]: string};
            requests?: {[key: string]: string};
        }

        export interface JaegerSpecIngressSecurityContext {
            fsGroup?: number;
            fsGroupChangePolicy?: string;
            runAsGroup?: number;
            runAsNonRoot?: boolean;
            runAsUser?: number;
            seLinuxOptions?: outputs.jaegertracing.v1.JaegerSpecIngressSecurityContextSeLinuxOptions;
            supplementalGroups?: number[];
            sysctls?: outputs.jaegertracing.v1.JaegerSpecIngressSecurityContextSysctls[];
            windowsOptions?: outputs.jaegertracing.v1.JaegerSpecIngressSecurityContextWindowsOptions;
        }

        export interface JaegerSpecIngressSecurityContextSeLinuxOptions {
            level?: string;
            role?: string;
            type?: string;
            user?: string;
        }

        export interface JaegerSpecIngressSecurityContextSysctls {
            name: string;
            value: string;
        }

        export interface JaegerSpecIngressSecurityContextWindowsOptions {
            gmsaCredentialSpec?: string;
            gmsaCredentialSpecName?: string;
            runAsUserName?: string;
        }

        export interface JaegerSpecIngressTls {
            hosts?: string[];
            secretName?: string;
        }

        export interface JaegerSpecIngressTolerations {
            effect?: string;
            key?: string;
            operator?: string;
            tolerationSeconds?: number;
            value?: string;
        }

        export interface JaegerSpecIngressVolumeMounts {
            mountPath: string;
            mountPropagation?: string;
            name: string;
            readOnly?: boolean;
            subPath?: string;
            subPathExpr?: string;
        }

        export interface JaegerSpecIngressVolumes {
            awsElasticBlockStore?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesAwsElasticBlockStore;
            azureDisk?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesAzureDisk;
            azureFile?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesAzureFile;
            cephfs?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesCephfs;
            cinder?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesCinder;
            configMap?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesConfigMap;
            csi?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesCsi;
            downwardAPI?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesDownwardAPI;
            emptyDir?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesEmptyDir;
            fc?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesFc;
            flexVolume?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesFlexVolume;
            flocker?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesFlocker;
            gcePersistentDisk?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesGcePersistentDisk;
            gitRepo?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesGitRepo;
            glusterfs?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesGlusterfs;
            hostPath?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesHostPath;
            iscsi?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesIscsi;
            name: string;
            nfs?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesNfs;
            persistentVolumeClaim?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesPersistentVolumeClaim;
            photonPersistentDisk?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesPhotonPersistentDisk;
            portworxVolume?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesPortworxVolume;
            projected?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesProjected;
            quobyte?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesQuobyte;
            rbd?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesRbd;
            scaleIO?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesScaleIO;
            secret?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesSecret;
            storageos?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesStorageos;
            vsphereVolume?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesVsphereVolume;
        }

        export interface JaegerSpecIngressVolumesAwsElasticBlockStore {
            fsType?: string;
            partition?: number;
            readOnly?: boolean;
            volumeID: string;
        }

        export interface JaegerSpecIngressVolumesAzureDisk {
            cachingMode?: string;
            diskName: string;
            diskURI: string;
            fsType?: string;
            kind?: string;
            readOnly?: boolean;
        }

        export interface JaegerSpecIngressVolumesAzureFile {
            readOnly?: boolean;
            secretName: string;
            shareName: string;
        }

        export interface JaegerSpecIngressVolumesCephfs {
            monitors: string[];
            path?: string;
            readOnly?: boolean;
            secretFile?: string;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesCephfsSecretRef;
            user?: string;
        }

        export interface JaegerSpecIngressVolumesCephfsSecretRef {
            name?: string;
        }

        export interface JaegerSpecIngressVolumesCinder {
            fsType?: string;
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesCinderSecretRef;
            volumeID: string;
        }

        export interface JaegerSpecIngressVolumesCinderSecretRef {
            name?: string;
        }

        export interface JaegerSpecIngressVolumesConfigMap {
            defaultMode?: number;
            items?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesConfigMapItems[];
            name?: string;
            optional?: boolean;
        }

        export interface JaegerSpecIngressVolumesConfigMapItems {
            key: string;
            mode?: number;
            path: string;
        }

        export interface JaegerSpecIngressVolumesCsi {
            driver: string;
            fsType?: string;
            nodePublishSecretRef?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesCsiNodePublishSecretRef;
            readOnly?: boolean;
            volumeAttributes?: {[key: string]: string};
        }

        export interface JaegerSpecIngressVolumesCsiNodePublishSecretRef {
            name?: string;
        }

        export interface JaegerSpecIngressVolumesDownwardAPI {
            defaultMode?: number;
            items?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesDownwardAPIItems[];
        }

        export interface JaegerSpecIngressVolumesDownwardAPIItems {
            fieldRef?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesDownwardAPIItemsFieldRef;
            mode?: number;
            path: string;
            resourceFieldRef?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesDownwardAPIItemsResourceFieldRef;
        }

        export interface JaegerSpecIngressVolumesDownwardAPIItemsFieldRef {
            apiVersion?: string;
            fieldPath: string;
        }

        export interface JaegerSpecIngressVolumesDownwardAPIItemsResourceFieldRef {
            containerName?: string;
            divisor?: string;
            resource: string;
        }

        export interface JaegerSpecIngressVolumesEmptyDir {
            medium?: string;
            sizeLimit?: string;
        }

        export interface JaegerSpecIngressVolumesFc {
            fsType?: string;
            lun?: number;
            readOnly?: boolean;
            targetWWNs?: string[];
            wwids?: string[];
        }

        export interface JaegerSpecIngressVolumesFlexVolume {
            driver: string;
            fsType?: string;
            options?: {[key: string]: string};
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesFlexVolumeSecretRef;
        }

        export interface JaegerSpecIngressVolumesFlexVolumeSecretRef {
            name?: string;
        }

        export interface JaegerSpecIngressVolumesFlocker {
            datasetName?: string;
            datasetUUID?: string;
        }

        export interface JaegerSpecIngressVolumesGcePersistentDisk {
            fsType?: string;
            partition?: number;
            pdName: string;
            readOnly?: boolean;
        }

        export interface JaegerSpecIngressVolumesGitRepo {
            directory?: string;
            repository: string;
            revision?: string;
        }

        export interface JaegerSpecIngressVolumesGlusterfs {
            endpoints: string;
            path: string;
            readOnly?: boolean;
        }

        export interface JaegerSpecIngressVolumesHostPath {
            path: string;
            type?: string;
        }

        export interface JaegerSpecIngressVolumesIscsi {
            chapAuthDiscovery?: boolean;
            chapAuthSession?: boolean;
            fsType?: string;
            initiatorName?: string;
            iqn: string;
            iscsiInterface?: string;
            lun: number;
            portals?: string[];
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesIscsiSecretRef;
            targetPortal: string;
        }

        export interface JaegerSpecIngressVolumesIscsiSecretRef {
            name?: string;
        }

        export interface JaegerSpecIngressVolumesNfs {
            path: string;
            readOnly?: boolean;
            server: string;
        }

        export interface JaegerSpecIngressVolumesPersistentVolumeClaim {
            claimName: string;
            readOnly?: boolean;
        }

        export interface JaegerSpecIngressVolumesPhotonPersistentDisk {
            fsType?: string;
            pdID: string;
        }

        export interface JaegerSpecIngressVolumesPortworxVolume {
            fsType?: string;
            readOnly?: boolean;
            volumeID: string;
        }

        export interface JaegerSpecIngressVolumesProjected {
            defaultMode?: number;
            sources: outputs.jaegertracing.v1.JaegerSpecIngressVolumesProjectedSources[];
        }

        export interface JaegerSpecIngressVolumesProjectedSources {
            configMap?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesProjectedSourcesConfigMap;
            downwardAPI?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesProjectedSourcesDownwardAPI;
            secret?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesProjectedSourcesSecret;
            serviceAccountToken?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesProjectedSourcesServiceAccountToken;
        }

        export interface JaegerSpecIngressVolumesProjectedSourcesConfigMap {
            items?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesProjectedSourcesConfigMapItems[];
            name?: string;
            optional?: boolean;
        }

        export interface JaegerSpecIngressVolumesProjectedSourcesConfigMapItems {
            key: string;
            mode?: number;
            path: string;
        }

        export interface JaegerSpecIngressVolumesProjectedSourcesDownwardAPI {
            items?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesProjectedSourcesDownwardAPIItems[];
        }

        export interface JaegerSpecIngressVolumesProjectedSourcesDownwardAPIItems {
            fieldRef?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesProjectedSourcesDownwardAPIItemsFieldRef;
            mode?: number;
            path: string;
            resourceFieldRef?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef;
        }

        export interface JaegerSpecIngressVolumesProjectedSourcesDownwardAPIItemsFieldRef {
            apiVersion?: string;
            fieldPath: string;
        }

        export interface JaegerSpecIngressVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef {
            containerName?: string;
            divisor?: string;
            resource: string;
        }

        export interface JaegerSpecIngressVolumesProjectedSourcesSecret {
            items?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesProjectedSourcesSecretItems[];
            name?: string;
            optional?: boolean;
        }

        export interface JaegerSpecIngressVolumesProjectedSourcesSecretItems {
            key: string;
            mode?: number;
            path: string;
        }

        export interface JaegerSpecIngressVolumesProjectedSourcesServiceAccountToken {
            audience?: string;
            expirationSeconds?: number;
            path: string;
        }

        export interface JaegerSpecIngressVolumesQuobyte {
            group?: string;
            readOnly?: boolean;
            registry: string;
            tenant?: string;
            user?: string;
            volume: string;
        }

        export interface JaegerSpecIngressVolumesRbd {
            fsType?: string;
            image: string;
            keyring?: string;
            monitors: string[];
            pool?: string;
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesRbdSecretRef;
            user?: string;
        }

        export interface JaegerSpecIngressVolumesRbdSecretRef {
            name?: string;
        }

        export interface JaegerSpecIngressVolumesScaleIO {
            fsType?: string;
            gateway: string;
            protectionDomain?: string;
            readOnly?: boolean;
            secretRef: outputs.jaegertracing.v1.JaegerSpecIngressVolumesScaleIOSecretRef;
            sslEnabled?: boolean;
            storageMode?: string;
            storagePool?: string;
            system: string;
            volumeName?: string;
        }

        export interface JaegerSpecIngressVolumesScaleIOSecretRef {
            name?: string;
        }

        export interface JaegerSpecIngressVolumesSecret {
            defaultMode?: number;
            items?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesSecretItems[];
            optional?: boolean;
            secretName?: string;
        }

        export interface JaegerSpecIngressVolumesSecretItems {
            key: string;
            mode?: number;
            path: string;
        }

        export interface JaegerSpecIngressVolumesStorageos {
            fsType?: string;
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecIngressVolumesStorageosSecretRef;
            volumeName?: string;
            volumeNamespace?: string;
        }

        export interface JaegerSpecIngressVolumesStorageosSecretRef {
            name?: string;
        }

        export interface JaegerSpecIngressVolumesVsphereVolume {
            fsType?: string;
            storagePolicyID?: string;
            storagePolicyName?: string;
            volumePath: string;
        }

        export interface JaegerSpecQuery {
            affinity?: outputs.jaegertracing.v1.JaegerSpecQueryAffinity;
            annotations?: {[key: string]: string};
            image?: string;
            labels?: {[key: string]: string};
            options?: {[key: string]: any};
            replicas?: number;
            resources?: outputs.jaegertracing.v1.JaegerSpecQueryResources;
            securityContext?: outputs.jaegertracing.v1.JaegerSpecQuerySecurityContext;
            serviceAccount?: string;
            serviceType?: string;
            tolerations?: outputs.jaegertracing.v1.JaegerSpecQueryTolerations[];
            volumeMounts?: outputs.jaegertracing.v1.JaegerSpecQueryVolumeMounts[];
            volumes?: outputs.jaegertracing.v1.JaegerSpecQueryVolumes[];
        }

        export interface JaegerSpecQueryAffinity {
            nodeAffinity?: outputs.jaegertracing.v1.JaegerSpecQueryAffinityNodeAffinity;
            podAffinity?: outputs.jaegertracing.v1.JaegerSpecQueryAffinityPodAffinity;
            podAntiAffinity?: outputs.jaegertracing.v1.JaegerSpecQueryAffinityPodAntiAffinity;
        }

        export interface JaegerSpecQueryAffinityNodeAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecQueryAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
            requiredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecQueryAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
        }

        export interface JaegerSpecQueryAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference: outputs.jaegertracing.v1.JaegerSpecQueryAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
            weight: number;
        }

        export interface JaegerSpecQueryAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecQueryAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];
            matchFields?: outputs.jaegertracing.v1.JaegerSpecQueryAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];
        }

        export interface JaegerSpecQueryAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecQueryAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecQueryAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            nodeSelectorTerms: outputs.jaegertracing.v1.JaegerSpecQueryAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];
        }

        export interface JaegerSpecQueryAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecQueryAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];
            matchFields?: outputs.jaegertracing.v1.JaegerSpecQueryAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];
        }

        export interface JaegerSpecQueryAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecQueryAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecQueryAffinityPodAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecQueryAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
            requiredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecQueryAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
        }

        export interface JaegerSpecQueryAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: outputs.jaegertracing.v1.JaegerSpecQueryAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
            weight: number;
        }

        export interface JaegerSpecQueryAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: outputs.jaegertracing.v1.JaegerSpecQueryAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
            namespaces?: string[];
            topologyKey: string;
        }

        export interface JaegerSpecQueryAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecQueryAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];
            matchLabels?: {[key: string]: string};
        }

        export interface JaegerSpecQueryAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecQueryAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: outputs.jaegertracing.v1.JaegerSpecQueryAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
            namespaces?: string[];
            topologyKey: string;
        }

        export interface JaegerSpecQueryAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecQueryAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];
            matchLabels?: {[key: string]: string};
        }

        export interface JaegerSpecQueryAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecQueryAffinityPodAntiAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecQueryAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
            requiredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecQueryAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
        }

        export interface JaegerSpecQueryAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: outputs.jaegertracing.v1.JaegerSpecQueryAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
            weight: number;
        }

        export interface JaegerSpecQueryAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: outputs.jaegertracing.v1.JaegerSpecQueryAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
            namespaces?: string[];
            topologyKey: string;
        }

        export interface JaegerSpecQueryAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecQueryAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];
            matchLabels?: {[key: string]: string};
        }

        export interface JaegerSpecQueryAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecQueryAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: outputs.jaegertracing.v1.JaegerSpecQueryAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
            namespaces?: string[];
            topologyKey: string;
        }

        export interface JaegerSpecQueryAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecQueryAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];
            matchLabels?: {[key: string]: string};
        }

        export interface JaegerSpecQueryAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecQueryResources {
            limits?: {[key: string]: string};
            requests?: {[key: string]: string};
        }

        export interface JaegerSpecQuerySecurityContext {
            fsGroup?: number;
            fsGroupChangePolicy?: string;
            runAsGroup?: number;
            runAsNonRoot?: boolean;
            runAsUser?: number;
            seLinuxOptions?: outputs.jaegertracing.v1.JaegerSpecQuerySecurityContextSeLinuxOptions;
            supplementalGroups?: number[];
            sysctls?: outputs.jaegertracing.v1.JaegerSpecQuerySecurityContextSysctls[];
            windowsOptions?: outputs.jaegertracing.v1.JaegerSpecQuerySecurityContextWindowsOptions;
        }

        export interface JaegerSpecQuerySecurityContextSeLinuxOptions {
            level?: string;
            role?: string;
            type?: string;
            user?: string;
        }

        export interface JaegerSpecQuerySecurityContextSysctls {
            name: string;
            value: string;
        }

        export interface JaegerSpecQuerySecurityContextWindowsOptions {
            gmsaCredentialSpec?: string;
            gmsaCredentialSpecName?: string;
            runAsUserName?: string;
        }

        export interface JaegerSpecQueryTolerations {
            effect?: string;
            key?: string;
            operator?: string;
            tolerationSeconds?: number;
            value?: string;
        }

        export interface JaegerSpecQueryVolumeMounts {
            mountPath: string;
            mountPropagation?: string;
            name: string;
            readOnly?: boolean;
            subPath?: string;
            subPathExpr?: string;
        }

        export interface JaegerSpecQueryVolumes {
            awsElasticBlockStore?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesAwsElasticBlockStore;
            azureDisk?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesAzureDisk;
            azureFile?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesAzureFile;
            cephfs?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesCephfs;
            cinder?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesCinder;
            configMap?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesConfigMap;
            csi?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesCsi;
            downwardAPI?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesDownwardAPI;
            emptyDir?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesEmptyDir;
            fc?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesFc;
            flexVolume?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesFlexVolume;
            flocker?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesFlocker;
            gcePersistentDisk?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesGcePersistentDisk;
            gitRepo?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesGitRepo;
            glusterfs?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesGlusterfs;
            hostPath?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesHostPath;
            iscsi?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesIscsi;
            name: string;
            nfs?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesNfs;
            persistentVolumeClaim?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesPersistentVolumeClaim;
            photonPersistentDisk?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesPhotonPersistentDisk;
            portworxVolume?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesPortworxVolume;
            projected?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesProjected;
            quobyte?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesQuobyte;
            rbd?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesRbd;
            scaleIO?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesScaleIO;
            secret?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesSecret;
            storageos?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesStorageos;
            vsphereVolume?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesVsphereVolume;
        }

        export interface JaegerSpecQueryVolumesAwsElasticBlockStore {
            fsType?: string;
            partition?: number;
            readOnly?: boolean;
            volumeID: string;
        }

        export interface JaegerSpecQueryVolumesAzureDisk {
            cachingMode?: string;
            diskName: string;
            diskURI: string;
            fsType?: string;
            kind?: string;
            readOnly?: boolean;
        }

        export interface JaegerSpecQueryVolumesAzureFile {
            readOnly?: boolean;
            secretName: string;
            shareName: string;
        }

        export interface JaegerSpecQueryVolumesCephfs {
            monitors: string[];
            path?: string;
            readOnly?: boolean;
            secretFile?: string;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesCephfsSecretRef;
            user?: string;
        }

        export interface JaegerSpecQueryVolumesCephfsSecretRef {
            name?: string;
        }

        export interface JaegerSpecQueryVolumesCinder {
            fsType?: string;
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesCinderSecretRef;
            volumeID: string;
        }

        export interface JaegerSpecQueryVolumesCinderSecretRef {
            name?: string;
        }

        export interface JaegerSpecQueryVolumesConfigMap {
            defaultMode?: number;
            items?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesConfigMapItems[];
            name?: string;
            optional?: boolean;
        }

        export interface JaegerSpecQueryVolumesConfigMapItems {
            key: string;
            mode?: number;
            path: string;
        }

        export interface JaegerSpecQueryVolumesCsi {
            driver: string;
            fsType?: string;
            nodePublishSecretRef?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesCsiNodePublishSecretRef;
            readOnly?: boolean;
            volumeAttributes?: {[key: string]: string};
        }

        export interface JaegerSpecQueryVolumesCsiNodePublishSecretRef {
            name?: string;
        }

        export interface JaegerSpecQueryVolumesDownwardAPI {
            defaultMode?: number;
            items?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesDownwardAPIItems[];
        }

        export interface JaegerSpecQueryVolumesDownwardAPIItems {
            fieldRef?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesDownwardAPIItemsFieldRef;
            mode?: number;
            path: string;
            resourceFieldRef?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesDownwardAPIItemsResourceFieldRef;
        }

        export interface JaegerSpecQueryVolumesDownwardAPIItemsFieldRef {
            apiVersion?: string;
            fieldPath: string;
        }

        export interface JaegerSpecQueryVolumesDownwardAPIItemsResourceFieldRef {
            containerName?: string;
            divisor?: string;
            resource: string;
        }

        export interface JaegerSpecQueryVolumesEmptyDir {
            medium?: string;
            sizeLimit?: string;
        }

        export interface JaegerSpecQueryVolumesFc {
            fsType?: string;
            lun?: number;
            readOnly?: boolean;
            targetWWNs?: string[];
            wwids?: string[];
        }

        export interface JaegerSpecQueryVolumesFlexVolume {
            driver: string;
            fsType?: string;
            options?: {[key: string]: string};
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesFlexVolumeSecretRef;
        }

        export interface JaegerSpecQueryVolumesFlexVolumeSecretRef {
            name?: string;
        }

        export interface JaegerSpecQueryVolumesFlocker {
            datasetName?: string;
            datasetUUID?: string;
        }

        export interface JaegerSpecQueryVolumesGcePersistentDisk {
            fsType?: string;
            partition?: number;
            pdName: string;
            readOnly?: boolean;
        }

        export interface JaegerSpecQueryVolumesGitRepo {
            directory?: string;
            repository: string;
            revision?: string;
        }

        export interface JaegerSpecQueryVolumesGlusterfs {
            endpoints: string;
            path: string;
            readOnly?: boolean;
        }

        export interface JaegerSpecQueryVolumesHostPath {
            path: string;
            type?: string;
        }

        export interface JaegerSpecQueryVolumesIscsi {
            chapAuthDiscovery?: boolean;
            chapAuthSession?: boolean;
            fsType?: string;
            initiatorName?: string;
            iqn: string;
            iscsiInterface?: string;
            lun: number;
            portals?: string[];
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesIscsiSecretRef;
            targetPortal: string;
        }

        export interface JaegerSpecQueryVolumesIscsiSecretRef {
            name?: string;
        }

        export interface JaegerSpecQueryVolumesNfs {
            path: string;
            readOnly?: boolean;
            server: string;
        }

        export interface JaegerSpecQueryVolumesPersistentVolumeClaim {
            claimName: string;
            readOnly?: boolean;
        }

        export interface JaegerSpecQueryVolumesPhotonPersistentDisk {
            fsType?: string;
            pdID: string;
        }

        export interface JaegerSpecQueryVolumesPortworxVolume {
            fsType?: string;
            readOnly?: boolean;
            volumeID: string;
        }

        export interface JaegerSpecQueryVolumesProjected {
            defaultMode?: number;
            sources: outputs.jaegertracing.v1.JaegerSpecQueryVolumesProjectedSources[];
        }

        export interface JaegerSpecQueryVolumesProjectedSources {
            configMap?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesProjectedSourcesConfigMap;
            downwardAPI?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesProjectedSourcesDownwardAPI;
            secret?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesProjectedSourcesSecret;
            serviceAccountToken?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesProjectedSourcesServiceAccountToken;
        }

        export interface JaegerSpecQueryVolumesProjectedSourcesConfigMap {
            items?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesProjectedSourcesConfigMapItems[];
            name?: string;
            optional?: boolean;
        }

        export interface JaegerSpecQueryVolumesProjectedSourcesConfigMapItems {
            key: string;
            mode?: number;
            path: string;
        }

        export interface JaegerSpecQueryVolumesProjectedSourcesDownwardAPI {
            items?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesProjectedSourcesDownwardAPIItems[];
        }

        export interface JaegerSpecQueryVolumesProjectedSourcesDownwardAPIItems {
            fieldRef?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesProjectedSourcesDownwardAPIItemsFieldRef;
            mode?: number;
            path: string;
            resourceFieldRef?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef;
        }

        export interface JaegerSpecQueryVolumesProjectedSourcesDownwardAPIItemsFieldRef {
            apiVersion?: string;
            fieldPath: string;
        }

        export interface JaegerSpecQueryVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef {
            containerName?: string;
            divisor?: string;
            resource: string;
        }

        export interface JaegerSpecQueryVolumesProjectedSourcesSecret {
            items?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesProjectedSourcesSecretItems[];
            name?: string;
            optional?: boolean;
        }

        export interface JaegerSpecQueryVolumesProjectedSourcesSecretItems {
            key: string;
            mode?: number;
            path: string;
        }

        export interface JaegerSpecQueryVolumesProjectedSourcesServiceAccountToken {
            audience?: string;
            expirationSeconds?: number;
            path: string;
        }

        export interface JaegerSpecQueryVolumesQuobyte {
            group?: string;
            readOnly?: boolean;
            registry: string;
            tenant?: string;
            user?: string;
            volume: string;
        }

        export interface JaegerSpecQueryVolumesRbd {
            fsType?: string;
            image: string;
            keyring?: string;
            monitors: string[];
            pool?: string;
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesRbdSecretRef;
            user?: string;
        }

        export interface JaegerSpecQueryVolumesRbdSecretRef {
            name?: string;
        }

        export interface JaegerSpecQueryVolumesScaleIO {
            fsType?: string;
            gateway: string;
            protectionDomain?: string;
            readOnly?: boolean;
            secretRef: outputs.jaegertracing.v1.JaegerSpecQueryVolumesScaleIOSecretRef;
            sslEnabled?: boolean;
            storageMode?: string;
            storagePool?: string;
            system: string;
            volumeName?: string;
        }

        export interface JaegerSpecQueryVolumesScaleIOSecretRef {
            name?: string;
        }

        export interface JaegerSpecQueryVolumesSecret {
            defaultMode?: number;
            items?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesSecretItems[];
            optional?: boolean;
            secretName?: string;
        }

        export interface JaegerSpecQueryVolumesSecretItems {
            key: string;
            mode?: number;
            path: string;
        }

        export interface JaegerSpecQueryVolumesStorageos {
            fsType?: string;
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecQueryVolumesStorageosSecretRef;
            volumeName?: string;
            volumeNamespace?: string;
        }

        export interface JaegerSpecQueryVolumesStorageosSecretRef {
            name?: string;
        }

        export interface JaegerSpecQueryVolumesVsphereVolume {
            fsType?: string;
            storagePolicyID?: string;
            storagePolicyName?: string;
            volumePath: string;
        }

        export interface JaegerSpecResources {
            limits?: {[key: string]: string};
            requests?: {[key: string]: string};
        }

        export interface JaegerSpecSampling {
            options?: {[key: string]: any};
        }

        export interface JaegerSpecSecurityContext {
            fsGroup?: number;
            fsGroupChangePolicy?: string;
            runAsGroup?: number;
            runAsNonRoot?: boolean;
            runAsUser?: number;
            seLinuxOptions?: outputs.jaegertracing.v1.JaegerSpecSecurityContextSeLinuxOptions;
            supplementalGroups?: number[];
            sysctls?: outputs.jaegertracing.v1.JaegerSpecSecurityContextSysctls[];
            windowsOptions?: outputs.jaegertracing.v1.JaegerSpecSecurityContextWindowsOptions;
        }

        export interface JaegerSpecSecurityContextSeLinuxOptions {
            level?: string;
            role?: string;
            type?: string;
            user?: string;
        }

        export interface JaegerSpecSecurityContextSysctls {
            name: string;
            value: string;
        }

        export interface JaegerSpecSecurityContextWindowsOptions {
            gmsaCredentialSpec?: string;
            gmsaCredentialSpecName?: string;
            runAsUserName?: string;
        }

        export interface JaegerSpecStorage {
            cassandraCreateSchema?: outputs.jaegertracing.v1.JaegerSpecStorageCassandraCreateSchema;
            dependencies?: outputs.jaegertracing.v1.JaegerSpecStorageDependencies;
            elasticsearch?: outputs.jaegertracing.v1.JaegerSpecStorageElasticsearch;
            esIndexCleaner?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleaner;
            esRollover?: outputs.jaegertracing.v1.JaegerSpecStorageEsRollover;
            options?: {[key: string]: any};
            secretName?: string;
            type?: string;
        }

        export interface JaegerSpecStorageCassandraCreateSchema {
            datacenter?: string;
            enabled?: boolean;
            image?: string;
            mode?: string;
            timeout?: string;
            traceTTL?: string;
            ttlSecondsAfterFinished?: number;
        }

        export interface JaegerSpecStorageDependencies {
            affinity?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinity;
            annotations?: {[key: string]: string};
            cassandraClientAuthEnabled?: boolean;
            elasticsearchClientNodeOnly?: boolean;
            elasticsearchNodesWanOnly?: boolean;
            enabled?: boolean;
            image?: string;
            javaOpts?: string;
            labels?: {[key: string]: string};
            resources?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesResources;
            schedule?: string;
            securityContext?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesSecurityContext;
            serviceAccount?: string;
            sparkMaster?: string;
            successfulJobsHistoryLimit?: number;
            tolerations?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesTolerations[];
            ttlSecondsAfterFinished?: number;
            volumeMounts?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumeMounts[];
            volumes?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumes[];
        }

        export interface JaegerSpecStorageDependenciesAffinity {
            nodeAffinity?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityNodeAffinity;
            podAffinity?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityPodAffinity;
            podAntiAffinity?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityPodAntiAffinity;
        }

        export interface JaegerSpecStorageDependenciesAffinityNodeAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
            requiredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
        }

        export interface JaegerSpecStorageDependenciesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
            weight: number;
        }

        export interface JaegerSpecStorageDependenciesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];
            matchFields?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];
        }

        export interface JaegerSpecStorageDependenciesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecStorageDependenciesAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecStorageDependenciesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            nodeSelectorTerms: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];
        }

        export interface JaegerSpecStorageDependenciesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];
            matchFields?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];
        }

        export interface JaegerSpecStorageDependenciesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecStorageDependenciesAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecStorageDependenciesAffinityPodAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
            requiredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
        }

        export interface JaegerSpecStorageDependenciesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
            weight: number;
        }

        export interface JaegerSpecStorageDependenciesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
            namespaces?: string[];
            topologyKey: string;
        }

        export interface JaegerSpecStorageDependenciesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];
            matchLabels?: {[key: string]: string};
        }

        export interface JaegerSpecStorageDependenciesAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecStorageDependenciesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
            namespaces?: string[];
            topologyKey: string;
        }

        export interface JaegerSpecStorageDependenciesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];
            matchLabels?: {[key: string]: string};
        }

        export interface JaegerSpecStorageDependenciesAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecStorageDependenciesAffinityPodAntiAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
            requiredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
        }

        export interface JaegerSpecStorageDependenciesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
            weight: number;
        }

        export interface JaegerSpecStorageDependenciesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
            namespaces?: string[];
            topologyKey: string;
        }

        export interface JaegerSpecStorageDependenciesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];
            matchLabels?: {[key: string]: string};
        }

        export interface JaegerSpecStorageDependenciesAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecStorageDependenciesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
            namespaces?: string[];
            topologyKey: string;
        }

        export interface JaegerSpecStorageDependenciesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];
            matchLabels?: {[key: string]: string};
        }

        export interface JaegerSpecStorageDependenciesAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecStorageDependenciesResources {
            limits?: {[key: string]: string};
            requests?: {[key: string]: string};
        }

        export interface JaegerSpecStorageDependenciesSecurityContext {
            fsGroup?: number;
            fsGroupChangePolicy?: string;
            runAsGroup?: number;
            runAsNonRoot?: boolean;
            runAsUser?: number;
            seLinuxOptions?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesSecurityContextSeLinuxOptions;
            supplementalGroups?: number[];
            sysctls?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesSecurityContextSysctls[];
            windowsOptions?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesSecurityContextWindowsOptions;
        }

        export interface JaegerSpecStorageDependenciesSecurityContextSeLinuxOptions {
            level?: string;
            role?: string;
            type?: string;
            user?: string;
        }

        export interface JaegerSpecStorageDependenciesSecurityContextSysctls {
            name: string;
            value: string;
        }

        export interface JaegerSpecStorageDependenciesSecurityContextWindowsOptions {
            gmsaCredentialSpec?: string;
            gmsaCredentialSpecName?: string;
            runAsUserName?: string;
        }

        export interface JaegerSpecStorageDependenciesTolerations {
            effect?: string;
            key?: string;
            operator?: string;
            tolerationSeconds?: number;
            value?: string;
        }

        export interface JaegerSpecStorageDependenciesVolumeMounts {
            mountPath: string;
            mountPropagation?: string;
            name: string;
            readOnly?: boolean;
            subPath?: string;
            subPathExpr?: string;
        }

        export interface JaegerSpecStorageDependenciesVolumes {
            awsElasticBlockStore?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesAwsElasticBlockStore;
            azureDisk?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesAzureDisk;
            azureFile?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesAzureFile;
            cephfs?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesCephfs;
            cinder?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesCinder;
            configMap?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesConfigMap;
            csi?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesCsi;
            downwardAPI?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesDownwardAPI;
            emptyDir?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesEmptyDir;
            fc?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesFc;
            flexVolume?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesFlexVolume;
            flocker?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesFlocker;
            gcePersistentDisk?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesGcePersistentDisk;
            gitRepo?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesGitRepo;
            glusterfs?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesGlusterfs;
            hostPath?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesHostPath;
            iscsi?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesIscsi;
            name: string;
            nfs?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesNfs;
            persistentVolumeClaim?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesPersistentVolumeClaim;
            photonPersistentDisk?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesPhotonPersistentDisk;
            portworxVolume?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesPortworxVolume;
            projected?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesProjected;
            quobyte?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesQuobyte;
            rbd?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesRbd;
            scaleIO?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesScaleIO;
            secret?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesSecret;
            storageos?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesStorageos;
            vsphereVolume?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesVsphereVolume;
        }

        export interface JaegerSpecStorageDependenciesVolumesAwsElasticBlockStore {
            fsType?: string;
            partition?: number;
            readOnly?: boolean;
            volumeID: string;
        }

        export interface JaegerSpecStorageDependenciesVolumesAzureDisk {
            cachingMode?: string;
            diskName: string;
            diskURI: string;
            fsType?: string;
            kind?: string;
            readOnly?: boolean;
        }

        export interface JaegerSpecStorageDependenciesVolumesAzureFile {
            readOnly?: boolean;
            secretName: string;
            shareName: string;
        }

        export interface JaegerSpecStorageDependenciesVolumesCephfs {
            monitors: string[];
            path?: string;
            readOnly?: boolean;
            secretFile?: string;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesCephfsSecretRef;
            user?: string;
        }

        export interface JaegerSpecStorageDependenciesVolumesCephfsSecretRef {
            name?: string;
        }

        export interface JaegerSpecStorageDependenciesVolumesCinder {
            fsType?: string;
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesCinderSecretRef;
            volumeID: string;
        }

        export interface JaegerSpecStorageDependenciesVolumesCinderSecretRef {
            name?: string;
        }

        export interface JaegerSpecStorageDependenciesVolumesConfigMap {
            defaultMode?: number;
            items?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesConfigMapItems[];
            name?: string;
            optional?: boolean;
        }

        export interface JaegerSpecStorageDependenciesVolumesConfigMapItems {
            key: string;
            mode?: number;
            path: string;
        }

        export interface JaegerSpecStorageDependenciesVolumesCsi {
            driver: string;
            fsType?: string;
            nodePublishSecretRef?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesCsiNodePublishSecretRef;
            readOnly?: boolean;
            volumeAttributes?: {[key: string]: string};
        }

        export interface JaegerSpecStorageDependenciesVolumesCsiNodePublishSecretRef {
            name?: string;
        }

        export interface JaegerSpecStorageDependenciesVolumesDownwardAPI {
            defaultMode?: number;
            items?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesDownwardAPIItems[];
        }

        export interface JaegerSpecStorageDependenciesVolumesDownwardAPIItems {
            fieldRef?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesDownwardAPIItemsFieldRef;
            mode?: number;
            path: string;
            resourceFieldRef?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesDownwardAPIItemsResourceFieldRef;
        }

        export interface JaegerSpecStorageDependenciesVolumesDownwardAPIItemsFieldRef {
            apiVersion?: string;
            fieldPath: string;
        }

        export interface JaegerSpecStorageDependenciesVolumesDownwardAPIItemsResourceFieldRef {
            containerName?: string;
            divisor?: string;
            resource: string;
        }

        export interface JaegerSpecStorageDependenciesVolumesEmptyDir {
            medium?: string;
            sizeLimit?: string;
        }

        export interface JaegerSpecStorageDependenciesVolumesFc {
            fsType?: string;
            lun?: number;
            readOnly?: boolean;
            targetWWNs?: string[];
            wwids?: string[];
        }

        export interface JaegerSpecStorageDependenciesVolumesFlexVolume {
            driver: string;
            fsType?: string;
            options?: {[key: string]: string};
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesFlexVolumeSecretRef;
        }

        export interface JaegerSpecStorageDependenciesVolumesFlexVolumeSecretRef {
            name?: string;
        }

        export interface JaegerSpecStorageDependenciesVolumesFlocker {
            datasetName?: string;
            datasetUUID?: string;
        }

        export interface JaegerSpecStorageDependenciesVolumesGcePersistentDisk {
            fsType?: string;
            partition?: number;
            pdName: string;
            readOnly?: boolean;
        }

        export interface JaegerSpecStorageDependenciesVolumesGitRepo {
            directory?: string;
            repository: string;
            revision?: string;
        }

        export interface JaegerSpecStorageDependenciesVolumesGlusterfs {
            endpoints: string;
            path: string;
            readOnly?: boolean;
        }

        export interface JaegerSpecStorageDependenciesVolumesHostPath {
            path: string;
            type?: string;
        }

        export interface JaegerSpecStorageDependenciesVolumesIscsi {
            chapAuthDiscovery?: boolean;
            chapAuthSession?: boolean;
            fsType?: string;
            initiatorName?: string;
            iqn: string;
            iscsiInterface?: string;
            lun: number;
            portals?: string[];
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesIscsiSecretRef;
            targetPortal: string;
        }

        export interface JaegerSpecStorageDependenciesVolumesIscsiSecretRef {
            name?: string;
        }

        export interface JaegerSpecStorageDependenciesVolumesNfs {
            path: string;
            readOnly?: boolean;
            server: string;
        }

        export interface JaegerSpecStorageDependenciesVolumesPersistentVolumeClaim {
            claimName: string;
            readOnly?: boolean;
        }

        export interface JaegerSpecStorageDependenciesVolumesPhotonPersistentDisk {
            fsType?: string;
            pdID: string;
        }

        export interface JaegerSpecStorageDependenciesVolumesPortworxVolume {
            fsType?: string;
            readOnly?: boolean;
            volumeID: string;
        }

        export interface JaegerSpecStorageDependenciesVolumesProjected {
            defaultMode?: number;
            sources: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesProjectedSources[];
        }

        export interface JaegerSpecStorageDependenciesVolumesProjectedSources {
            configMap?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesProjectedSourcesConfigMap;
            downwardAPI?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesProjectedSourcesDownwardAPI;
            secret?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesProjectedSourcesSecret;
            serviceAccountToken?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesProjectedSourcesServiceAccountToken;
        }

        export interface JaegerSpecStorageDependenciesVolumesProjectedSourcesConfigMap {
            items?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesProjectedSourcesConfigMapItems[];
            name?: string;
            optional?: boolean;
        }

        export interface JaegerSpecStorageDependenciesVolumesProjectedSourcesConfigMapItems {
            key: string;
            mode?: number;
            path: string;
        }

        export interface JaegerSpecStorageDependenciesVolumesProjectedSourcesDownwardAPI {
            items?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesProjectedSourcesDownwardAPIItems[];
        }

        export interface JaegerSpecStorageDependenciesVolumesProjectedSourcesDownwardAPIItems {
            fieldRef?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesProjectedSourcesDownwardAPIItemsFieldRef;
            mode?: number;
            path: string;
            resourceFieldRef?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef;
        }

        export interface JaegerSpecStorageDependenciesVolumesProjectedSourcesDownwardAPIItemsFieldRef {
            apiVersion?: string;
            fieldPath: string;
        }

        export interface JaegerSpecStorageDependenciesVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef {
            containerName?: string;
            divisor?: string;
            resource: string;
        }

        export interface JaegerSpecStorageDependenciesVolumesProjectedSourcesSecret {
            items?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesProjectedSourcesSecretItems[];
            name?: string;
            optional?: boolean;
        }

        export interface JaegerSpecStorageDependenciesVolumesProjectedSourcesSecretItems {
            key: string;
            mode?: number;
            path: string;
        }

        export interface JaegerSpecStorageDependenciesVolumesProjectedSourcesServiceAccountToken {
            audience?: string;
            expirationSeconds?: number;
            path: string;
        }

        export interface JaegerSpecStorageDependenciesVolumesQuobyte {
            group?: string;
            readOnly?: boolean;
            registry: string;
            tenant?: string;
            user?: string;
            volume: string;
        }

        export interface JaegerSpecStorageDependenciesVolumesRbd {
            fsType?: string;
            image: string;
            keyring?: string;
            monitors: string[];
            pool?: string;
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesRbdSecretRef;
            user?: string;
        }

        export interface JaegerSpecStorageDependenciesVolumesRbdSecretRef {
            name?: string;
        }

        export interface JaegerSpecStorageDependenciesVolumesScaleIO {
            fsType?: string;
            gateway: string;
            protectionDomain?: string;
            readOnly?: boolean;
            secretRef: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesScaleIOSecretRef;
            sslEnabled?: boolean;
            storageMode?: string;
            storagePool?: string;
            system: string;
            volumeName?: string;
        }

        export interface JaegerSpecStorageDependenciesVolumesScaleIOSecretRef {
            name?: string;
        }

        export interface JaegerSpecStorageDependenciesVolumesSecret {
            defaultMode?: number;
            items?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesSecretItems[];
            optional?: boolean;
            secretName?: string;
        }

        export interface JaegerSpecStorageDependenciesVolumesSecretItems {
            key: string;
            mode?: number;
            path: string;
        }

        export interface JaegerSpecStorageDependenciesVolumesStorageos {
            fsType?: string;
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecStorageDependenciesVolumesStorageosSecretRef;
            volumeName?: string;
            volumeNamespace?: string;
        }

        export interface JaegerSpecStorageDependenciesVolumesStorageosSecretRef {
            name?: string;
        }

        export interface JaegerSpecStorageDependenciesVolumesVsphereVolume {
            fsType?: string;
            storagePolicyID?: string;
            storagePolicyName?: string;
            volumePath: string;
        }

        export interface JaegerSpecStorageElasticsearch {
            image?: string;
            nodeCount?: number;
            nodeSelector?: {[key: string]: string};
            redundancyPolicy?: string;
            resources?: outputs.jaegertracing.v1.JaegerSpecStorageElasticsearchResources;
            storage?: outputs.jaegertracing.v1.JaegerSpecStorageElasticsearchStorage;
        }

        export interface JaegerSpecStorageElasticsearchResources {
            limits?: {[key: string]: string};
            requests?: {[key: string]: string};
        }

        export interface JaegerSpecStorageElasticsearchStorage {
            size?: string;
            storageClassName?: string;
        }

        export interface JaegerSpecStorageEsIndexCleaner {
            affinity?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinity;
            annotations?: {[key: string]: string};
            enabled?: boolean;
            image?: string;
            labels?: {[key: string]: string};
            numberOfDays?: number;
            resources?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerResources;
            schedule?: string;
            securityContext?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerSecurityContext;
            serviceAccount?: string;
            successfulJobsHistoryLimit?: number;
            tolerations?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerTolerations[];
            ttlSecondsAfterFinished?: number;
            volumeMounts?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumeMounts[];
            volumes?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumes[];
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinity {
            nodeAffinity?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityNodeAffinity;
            podAffinity?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityPodAffinity;
            podAntiAffinity?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityPodAntiAffinity;
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityNodeAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
            requiredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
            weight: number;
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];
            matchFields?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            nodeSelectorTerms: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];
            matchFields?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityPodAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
            requiredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
            weight: number;
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
            namespaces?: string[];
            topologyKey: string;
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];
            matchLabels?: {[key: string]: string};
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
            namespaces?: string[];
            topologyKey: string;
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];
            matchLabels?: {[key: string]: string};
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityPodAntiAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
            requiredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
            weight: number;
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
            namespaces?: string[];
            topologyKey: string;
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];
            matchLabels?: {[key: string]: string};
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
            namespaces?: string[];
            topologyKey: string;
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];
            matchLabels?: {[key: string]: string};
        }

        export interface JaegerSpecStorageEsIndexCleanerAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecStorageEsIndexCleanerResources {
            limits?: {[key: string]: string};
            requests?: {[key: string]: string};
        }

        export interface JaegerSpecStorageEsIndexCleanerSecurityContext {
            fsGroup?: number;
            fsGroupChangePolicy?: string;
            runAsGroup?: number;
            runAsNonRoot?: boolean;
            runAsUser?: number;
            seLinuxOptions?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerSecurityContextSeLinuxOptions;
            supplementalGroups?: number[];
            sysctls?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerSecurityContextSysctls[];
            windowsOptions?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerSecurityContextWindowsOptions;
        }

        export interface JaegerSpecStorageEsIndexCleanerSecurityContextSeLinuxOptions {
            level?: string;
            role?: string;
            type?: string;
            user?: string;
        }

        export interface JaegerSpecStorageEsIndexCleanerSecurityContextSysctls {
            name: string;
            value: string;
        }

        export interface JaegerSpecStorageEsIndexCleanerSecurityContextWindowsOptions {
            gmsaCredentialSpec?: string;
            gmsaCredentialSpecName?: string;
            runAsUserName?: string;
        }

        export interface JaegerSpecStorageEsIndexCleanerTolerations {
            effect?: string;
            key?: string;
            operator?: string;
            tolerationSeconds?: number;
            value?: string;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumeMounts {
            mountPath: string;
            mountPropagation?: string;
            name: string;
            readOnly?: boolean;
            subPath?: string;
            subPathExpr?: string;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumes {
            awsElasticBlockStore?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesAwsElasticBlockStore;
            azureDisk?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesAzureDisk;
            azureFile?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesAzureFile;
            cephfs?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesCephfs;
            cinder?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesCinder;
            configMap?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesConfigMap;
            csi?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesCsi;
            downwardAPI?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesDownwardAPI;
            emptyDir?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesEmptyDir;
            fc?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesFc;
            flexVolume?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesFlexVolume;
            flocker?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesFlocker;
            gcePersistentDisk?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesGcePersistentDisk;
            gitRepo?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesGitRepo;
            glusterfs?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesGlusterfs;
            hostPath?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesHostPath;
            iscsi?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesIscsi;
            name: string;
            nfs?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesNfs;
            persistentVolumeClaim?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesPersistentVolumeClaim;
            photonPersistentDisk?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesPhotonPersistentDisk;
            portworxVolume?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesPortworxVolume;
            projected?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesProjected;
            quobyte?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesQuobyte;
            rbd?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesRbd;
            scaleIO?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesScaleIO;
            secret?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesSecret;
            storageos?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesStorageos;
            vsphereVolume?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesVsphereVolume;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesAwsElasticBlockStore {
            fsType?: string;
            partition?: number;
            readOnly?: boolean;
            volumeID: string;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesAzureDisk {
            cachingMode?: string;
            diskName: string;
            diskURI: string;
            fsType?: string;
            kind?: string;
            readOnly?: boolean;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesAzureFile {
            readOnly?: boolean;
            secretName: string;
            shareName: string;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesCephfs {
            monitors: string[];
            path?: string;
            readOnly?: boolean;
            secretFile?: string;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesCephfsSecretRef;
            user?: string;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesCephfsSecretRef {
            name?: string;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesCinder {
            fsType?: string;
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesCinderSecretRef;
            volumeID: string;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesCinderSecretRef {
            name?: string;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesConfigMap {
            defaultMode?: number;
            items?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesConfigMapItems[];
            name?: string;
            optional?: boolean;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesConfigMapItems {
            key: string;
            mode?: number;
            path: string;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesCsi {
            driver: string;
            fsType?: string;
            nodePublishSecretRef?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesCsiNodePublishSecretRef;
            readOnly?: boolean;
            volumeAttributes?: {[key: string]: string};
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesCsiNodePublishSecretRef {
            name?: string;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesDownwardAPI {
            defaultMode?: number;
            items?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesDownwardAPIItems[];
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesDownwardAPIItems {
            fieldRef?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesDownwardAPIItemsFieldRef;
            mode?: number;
            path: string;
            resourceFieldRef?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesDownwardAPIItemsResourceFieldRef;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesDownwardAPIItemsFieldRef {
            apiVersion?: string;
            fieldPath: string;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesDownwardAPIItemsResourceFieldRef {
            containerName?: string;
            divisor?: string;
            resource: string;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesEmptyDir {
            medium?: string;
            sizeLimit?: string;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesFc {
            fsType?: string;
            lun?: number;
            readOnly?: boolean;
            targetWWNs?: string[];
            wwids?: string[];
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesFlexVolume {
            driver: string;
            fsType?: string;
            options?: {[key: string]: string};
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesFlexVolumeSecretRef;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesFlexVolumeSecretRef {
            name?: string;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesFlocker {
            datasetName?: string;
            datasetUUID?: string;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesGcePersistentDisk {
            fsType?: string;
            partition?: number;
            pdName: string;
            readOnly?: boolean;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesGitRepo {
            directory?: string;
            repository: string;
            revision?: string;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesGlusterfs {
            endpoints: string;
            path: string;
            readOnly?: boolean;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesHostPath {
            path: string;
            type?: string;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesIscsi {
            chapAuthDiscovery?: boolean;
            chapAuthSession?: boolean;
            fsType?: string;
            initiatorName?: string;
            iqn: string;
            iscsiInterface?: string;
            lun: number;
            portals?: string[];
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesIscsiSecretRef;
            targetPortal: string;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesIscsiSecretRef {
            name?: string;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesNfs {
            path: string;
            readOnly?: boolean;
            server: string;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesPersistentVolumeClaim {
            claimName: string;
            readOnly?: boolean;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesPhotonPersistentDisk {
            fsType?: string;
            pdID: string;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesPortworxVolume {
            fsType?: string;
            readOnly?: boolean;
            volumeID: string;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesProjected {
            defaultMode?: number;
            sources: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesProjectedSources[];
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesProjectedSources {
            configMap?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesProjectedSourcesConfigMap;
            downwardAPI?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesProjectedSourcesDownwardAPI;
            secret?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesProjectedSourcesSecret;
            serviceAccountToken?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesProjectedSourcesServiceAccountToken;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesProjectedSourcesConfigMap {
            items?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesProjectedSourcesConfigMapItems[];
            name?: string;
            optional?: boolean;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesProjectedSourcesConfigMapItems {
            key: string;
            mode?: number;
            path: string;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesProjectedSourcesDownwardAPI {
            items?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesProjectedSourcesDownwardAPIItems[];
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesProjectedSourcesDownwardAPIItems {
            fieldRef?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesProjectedSourcesDownwardAPIItemsFieldRef;
            mode?: number;
            path: string;
            resourceFieldRef?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesProjectedSourcesDownwardAPIItemsFieldRef {
            apiVersion?: string;
            fieldPath: string;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef {
            containerName?: string;
            divisor?: string;
            resource: string;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesProjectedSourcesSecret {
            items?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesProjectedSourcesSecretItems[];
            name?: string;
            optional?: boolean;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesProjectedSourcesSecretItems {
            key: string;
            mode?: number;
            path: string;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesProjectedSourcesServiceAccountToken {
            audience?: string;
            expirationSeconds?: number;
            path: string;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesQuobyte {
            group?: string;
            readOnly?: boolean;
            registry: string;
            tenant?: string;
            user?: string;
            volume: string;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesRbd {
            fsType?: string;
            image: string;
            keyring?: string;
            monitors: string[];
            pool?: string;
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesRbdSecretRef;
            user?: string;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesRbdSecretRef {
            name?: string;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesScaleIO {
            fsType?: string;
            gateway: string;
            protectionDomain?: string;
            readOnly?: boolean;
            secretRef: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesScaleIOSecretRef;
            sslEnabled?: boolean;
            storageMode?: string;
            storagePool?: string;
            system: string;
            volumeName?: string;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesScaleIOSecretRef {
            name?: string;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesSecret {
            defaultMode?: number;
            items?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesSecretItems[];
            optional?: boolean;
            secretName?: string;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesSecretItems {
            key: string;
            mode?: number;
            path: string;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesStorageos {
            fsType?: string;
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecStorageEsIndexCleanerVolumesStorageosSecretRef;
            volumeName?: string;
            volumeNamespace?: string;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesStorageosSecretRef {
            name?: string;
        }

        export interface JaegerSpecStorageEsIndexCleanerVolumesVsphereVolume {
            fsType?: string;
            storagePolicyID?: string;
            storagePolicyName?: string;
            volumePath: string;
        }

        export interface JaegerSpecStorageEsRollover {
            affinity?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinity;
            annotations?: {[key: string]: string};
            conditions?: string;
            image?: string;
            labels?: {[key: string]: string};
            readTTL?: string;
            resources?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverResources;
            schedule?: string;
            securityContext?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverSecurityContext;
            serviceAccount?: string;
            successfulJobsHistoryLimit?: number;
            tolerations?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverTolerations[];
            ttlSecondsAfterFinished?: number;
            volumeMounts?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumeMounts[];
            volumes?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumes[];
        }

        export interface JaegerSpecStorageEsRolloverAffinity {
            nodeAffinity?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityNodeAffinity;
            podAffinity?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityPodAffinity;
            podAntiAffinity?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityPodAntiAffinity;
        }

        export interface JaegerSpecStorageEsRolloverAffinityNodeAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
            requiredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
        }

        export interface JaegerSpecStorageEsRolloverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
            weight: number;
        }

        export interface JaegerSpecStorageEsRolloverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];
            matchFields?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];
        }

        export interface JaegerSpecStorageEsRolloverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecStorageEsRolloverAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecStorageEsRolloverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            nodeSelectorTerms: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];
        }

        export interface JaegerSpecStorageEsRolloverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];
            matchFields?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];
        }

        export interface JaegerSpecStorageEsRolloverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecStorageEsRolloverAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecStorageEsRolloverAffinityPodAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
            requiredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
        }

        export interface JaegerSpecStorageEsRolloverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
            weight: number;
        }

        export interface JaegerSpecStorageEsRolloverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
            namespaces?: string[];
            topologyKey: string;
        }

        export interface JaegerSpecStorageEsRolloverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];
            matchLabels?: {[key: string]: string};
        }

        export interface JaegerSpecStorageEsRolloverAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecStorageEsRolloverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
            namespaces?: string[];
            topologyKey: string;
        }

        export interface JaegerSpecStorageEsRolloverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];
            matchLabels?: {[key: string]: string};
        }

        export interface JaegerSpecStorageEsRolloverAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecStorageEsRolloverAffinityPodAntiAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
            requiredDuringSchedulingIgnoredDuringExecution?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
        }

        export interface JaegerSpecStorageEsRolloverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
            weight: number;
        }

        export interface JaegerSpecStorageEsRolloverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
            namespaces?: string[];
            topologyKey: string;
        }

        export interface JaegerSpecStorageEsRolloverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];
            matchLabels?: {[key: string]: string};
        }

        export interface JaegerSpecStorageEsRolloverAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecStorageEsRolloverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
            namespaces?: string[];
            topologyKey: string;
        }

        export interface JaegerSpecStorageEsRolloverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];
            matchLabels?: {[key: string]: string};
        }

        export interface JaegerSpecStorageEsRolloverAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: string;
            operator: string;
            values?: string[];
        }

        export interface JaegerSpecStorageEsRolloverResources {
            limits?: {[key: string]: string};
            requests?: {[key: string]: string};
        }

        export interface JaegerSpecStorageEsRolloverSecurityContext {
            fsGroup?: number;
            fsGroupChangePolicy?: string;
            runAsGroup?: number;
            runAsNonRoot?: boolean;
            runAsUser?: number;
            seLinuxOptions?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverSecurityContextSeLinuxOptions;
            supplementalGroups?: number[];
            sysctls?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverSecurityContextSysctls[];
            windowsOptions?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverSecurityContextWindowsOptions;
        }

        export interface JaegerSpecStorageEsRolloverSecurityContextSeLinuxOptions {
            level?: string;
            role?: string;
            type?: string;
            user?: string;
        }

        export interface JaegerSpecStorageEsRolloverSecurityContextSysctls {
            name: string;
            value: string;
        }

        export interface JaegerSpecStorageEsRolloverSecurityContextWindowsOptions {
            gmsaCredentialSpec?: string;
            gmsaCredentialSpecName?: string;
            runAsUserName?: string;
        }

        export interface JaegerSpecStorageEsRolloverTolerations {
            effect?: string;
            key?: string;
            operator?: string;
            tolerationSeconds?: number;
            value?: string;
        }

        export interface JaegerSpecStorageEsRolloverVolumeMounts {
            mountPath: string;
            mountPropagation?: string;
            name: string;
            readOnly?: boolean;
            subPath?: string;
            subPathExpr?: string;
        }

        export interface JaegerSpecStorageEsRolloverVolumes {
            awsElasticBlockStore?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesAwsElasticBlockStore;
            azureDisk?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesAzureDisk;
            azureFile?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesAzureFile;
            cephfs?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesCephfs;
            cinder?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesCinder;
            configMap?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesConfigMap;
            csi?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesCsi;
            downwardAPI?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesDownwardAPI;
            emptyDir?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesEmptyDir;
            fc?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesFc;
            flexVolume?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesFlexVolume;
            flocker?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesFlocker;
            gcePersistentDisk?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesGcePersistentDisk;
            gitRepo?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesGitRepo;
            glusterfs?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesGlusterfs;
            hostPath?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesHostPath;
            iscsi?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesIscsi;
            name: string;
            nfs?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesNfs;
            persistentVolumeClaim?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesPersistentVolumeClaim;
            photonPersistentDisk?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesPhotonPersistentDisk;
            portworxVolume?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesPortworxVolume;
            projected?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesProjected;
            quobyte?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesQuobyte;
            rbd?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesRbd;
            scaleIO?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesScaleIO;
            secret?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesSecret;
            storageos?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesStorageos;
            vsphereVolume?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesVsphereVolume;
        }

        export interface JaegerSpecStorageEsRolloverVolumesAwsElasticBlockStore {
            fsType?: string;
            partition?: number;
            readOnly?: boolean;
            volumeID: string;
        }

        export interface JaegerSpecStorageEsRolloverVolumesAzureDisk {
            cachingMode?: string;
            diskName: string;
            diskURI: string;
            fsType?: string;
            kind?: string;
            readOnly?: boolean;
        }

        export interface JaegerSpecStorageEsRolloverVolumesAzureFile {
            readOnly?: boolean;
            secretName: string;
            shareName: string;
        }

        export interface JaegerSpecStorageEsRolloverVolumesCephfs {
            monitors: string[];
            path?: string;
            readOnly?: boolean;
            secretFile?: string;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesCephfsSecretRef;
            user?: string;
        }

        export interface JaegerSpecStorageEsRolloverVolumesCephfsSecretRef {
            name?: string;
        }

        export interface JaegerSpecStorageEsRolloverVolumesCinder {
            fsType?: string;
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesCinderSecretRef;
            volumeID: string;
        }

        export interface JaegerSpecStorageEsRolloverVolumesCinderSecretRef {
            name?: string;
        }

        export interface JaegerSpecStorageEsRolloverVolumesConfigMap {
            defaultMode?: number;
            items?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesConfigMapItems[];
            name?: string;
            optional?: boolean;
        }

        export interface JaegerSpecStorageEsRolloverVolumesConfigMapItems {
            key: string;
            mode?: number;
            path: string;
        }

        export interface JaegerSpecStorageEsRolloverVolumesCsi {
            driver: string;
            fsType?: string;
            nodePublishSecretRef?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesCsiNodePublishSecretRef;
            readOnly?: boolean;
            volumeAttributes?: {[key: string]: string};
        }

        export interface JaegerSpecStorageEsRolloverVolumesCsiNodePublishSecretRef {
            name?: string;
        }

        export interface JaegerSpecStorageEsRolloverVolumesDownwardAPI {
            defaultMode?: number;
            items?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesDownwardAPIItems[];
        }

        export interface JaegerSpecStorageEsRolloverVolumesDownwardAPIItems {
            fieldRef?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesDownwardAPIItemsFieldRef;
            mode?: number;
            path: string;
            resourceFieldRef?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesDownwardAPIItemsResourceFieldRef;
        }

        export interface JaegerSpecStorageEsRolloverVolumesDownwardAPIItemsFieldRef {
            apiVersion?: string;
            fieldPath: string;
        }

        export interface JaegerSpecStorageEsRolloverVolumesDownwardAPIItemsResourceFieldRef {
            containerName?: string;
            divisor?: string;
            resource: string;
        }

        export interface JaegerSpecStorageEsRolloverVolumesEmptyDir {
            medium?: string;
            sizeLimit?: string;
        }

        export interface JaegerSpecStorageEsRolloverVolumesFc {
            fsType?: string;
            lun?: number;
            readOnly?: boolean;
            targetWWNs?: string[];
            wwids?: string[];
        }

        export interface JaegerSpecStorageEsRolloverVolumesFlexVolume {
            driver: string;
            fsType?: string;
            options?: {[key: string]: string};
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesFlexVolumeSecretRef;
        }

        export interface JaegerSpecStorageEsRolloverVolumesFlexVolumeSecretRef {
            name?: string;
        }

        export interface JaegerSpecStorageEsRolloverVolumesFlocker {
            datasetName?: string;
            datasetUUID?: string;
        }

        export interface JaegerSpecStorageEsRolloverVolumesGcePersistentDisk {
            fsType?: string;
            partition?: number;
            pdName: string;
            readOnly?: boolean;
        }

        export interface JaegerSpecStorageEsRolloverVolumesGitRepo {
            directory?: string;
            repository: string;
            revision?: string;
        }

        export interface JaegerSpecStorageEsRolloverVolumesGlusterfs {
            endpoints: string;
            path: string;
            readOnly?: boolean;
        }

        export interface JaegerSpecStorageEsRolloverVolumesHostPath {
            path: string;
            type?: string;
        }

        export interface JaegerSpecStorageEsRolloverVolumesIscsi {
            chapAuthDiscovery?: boolean;
            chapAuthSession?: boolean;
            fsType?: string;
            initiatorName?: string;
            iqn: string;
            iscsiInterface?: string;
            lun: number;
            portals?: string[];
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesIscsiSecretRef;
            targetPortal: string;
        }

        export interface JaegerSpecStorageEsRolloverVolumesIscsiSecretRef {
            name?: string;
        }

        export interface JaegerSpecStorageEsRolloverVolumesNfs {
            path: string;
            readOnly?: boolean;
            server: string;
        }

        export interface JaegerSpecStorageEsRolloverVolumesPersistentVolumeClaim {
            claimName: string;
            readOnly?: boolean;
        }

        export interface JaegerSpecStorageEsRolloverVolumesPhotonPersistentDisk {
            fsType?: string;
            pdID: string;
        }

        export interface JaegerSpecStorageEsRolloverVolumesPortworxVolume {
            fsType?: string;
            readOnly?: boolean;
            volumeID: string;
        }

        export interface JaegerSpecStorageEsRolloverVolumesProjected {
            defaultMode?: number;
            sources: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesProjectedSources[];
        }

        export interface JaegerSpecStorageEsRolloverVolumesProjectedSources {
            configMap?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesProjectedSourcesConfigMap;
            downwardAPI?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesProjectedSourcesDownwardAPI;
            secret?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesProjectedSourcesSecret;
            serviceAccountToken?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesProjectedSourcesServiceAccountToken;
        }

        export interface JaegerSpecStorageEsRolloverVolumesProjectedSourcesConfigMap {
            items?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesProjectedSourcesConfigMapItems[];
            name?: string;
            optional?: boolean;
        }

        export interface JaegerSpecStorageEsRolloverVolumesProjectedSourcesConfigMapItems {
            key: string;
            mode?: number;
            path: string;
        }

        export interface JaegerSpecStorageEsRolloverVolumesProjectedSourcesDownwardAPI {
            items?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesProjectedSourcesDownwardAPIItems[];
        }

        export interface JaegerSpecStorageEsRolloverVolumesProjectedSourcesDownwardAPIItems {
            fieldRef?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesProjectedSourcesDownwardAPIItemsFieldRef;
            mode?: number;
            path: string;
            resourceFieldRef?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef;
        }

        export interface JaegerSpecStorageEsRolloverVolumesProjectedSourcesDownwardAPIItemsFieldRef {
            apiVersion?: string;
            fieldPath: string;
        }

        export interface JaegerSpecStorageEsRolloverVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef {
            containerName?: string;
            divisor?: string;
            resource: string;
        }

        export interface JaegerSpecStorageEsRolloverVolumesProjectedSourcesSecret {
            items?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesProjectedSourcesSecretItems[];
            name?: string;
            optional?: boolean;
        }

        export interface JaegerSpecStorageEsRolloverVolumesProjectedSourcesSecretItems {
            key: string;
            mode?: number;
            path: string;
        }

        export interface JaegerSpecStorageEsRolloverVolumesProjectedSourcesServiceAccountToken {
            audience?: string;
            expirationSeconds?: number;
            path: string;
        }

        export interface JaegerSpecStorageEsRolloverVolumesQuobyte {
            group?: string;
            readOnly?: boolean;
            registry: string;
            tenant?: string;
            user?: string;
            volume: string;
        }

        export interface JaegerSpecStorageEsRolloverVolumesRbd {
            fsType?: string;
            image: string;
            keyring?: string;
            monitors: string[];
            pool?: string;
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesRbdSecretRef;
            user?: string;
        }

        export interface JaegerSpecStorageEsRolloverVolumesRbdSecretRef {
            name?: string;
        }

        export interface JaegerSpecStorageEsRolloverVolumesScaleIO {
            fsType?: string;
            gateway: string;
            protectionDomain?: string;
            readOnly?: boolean;
            secretRef: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesScaleIOSecretRef;
            sslEnabled?: boolean;
            storageMode?: string;
            storagePool?: string;
            system: string;
            volumeName?: string;
        }

        export interface JaegerSpecStorageEsRolloverVolumesScaleIOSecretRef {
            name?: string;
        }

        export interface JaegerSpecStorageEsRolloverVolumesSecret {
            defaultMode?: number;
            items?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesSecretItems[];
            optional?: boolean;
            secretName?: string;
        }

        export interface JaegerSpecStorageEsRolloverVolumesSecretItems {
            key: string;
            mode?: number;
            path: string;
        }

        export interface JaegerSpecStorageEsRolloverVolumesStorageos {
            fsType?: string;
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecStorageEsRolloverVolumesStorageosSecretRef;
            volumeName?: string;
            volumeNamespace?: string;
        }

        export interface JaegerSpecStorageEsRolloverVolumesStorageosSecretRef {
            name?: string;
        }

        export interface JaegerSpecStorageEsRolloverVolumesVsphereVolume {
            fsType?: string;
            storagePolicyID?: string;
            storagePolicyName?: string;
            volumePath: string;
        }

        export interface JaegerSpecTolerations {
            effect?: string;
            key?: string;
            operator?: string;
            tolerationSeconds?: number;
            value?: string;
        }

        export interface JaegerSpecUi {
            options?: {[key: string]: any};
        }

        export interface JaegerSpecVolumeMounts {
            mountPath: string;
            mountPropagation?: string;
            name: string;
            readOnly?: boolean;
            subPath?: string;
            subPathExpr?: string;
        }

        export interface JaegerSpecVolumes {
            awsElasticBlockStore?: outputs.jaegertracing.v1.JaegerSpecVolumesAwsElasticBlockStore;
            azureDisk?: outputs.jaegertracing.v1.JaegerSpecVolumesAzureDisk;
            azureFile?: outputs.jaegertracing.v1.JaegerSpecVolumesAzureFile;
            cephfs?: outputs.jaegertracing.v1.JaegerSpecVolumesCephfs;
            cinder?: outputs.jaegertracing.v1.JaegerSpecVolumesCinder;
            configMap?: outputs.jaegertracing.v1.JaegerSpecVolumesConfigMap;
            csi?: outputs.jaegertracing.v1.JaegerSpecVolumesCsi;
            downwardAPI?: outputs.jaegertracing.v1.JaegerSpecVolumesDownwardAPI;
            emptyDir?: outputs.jaegertracing.v1.JaegerSpecVolumesEmptyDir;
            fc?: outputs.jaegertracing.v1.JaegerSpecVolumesFc;
            flexVolume?: outputs.jaegertracing.v1.JaegerSpecVolumesFlexVolume;
            flocker?: outputs.jaegertracing.v1.JaegerSpecVolumesFlocker;
            gcePersistentDisk?: outputs.jaegertracing.v1.JaegerSpecVolumesGcePersistentDisk;
            gitRepo?: outputs.jaegertracing.v1.JaegerSpecVolumesGitRepo;
            glusterfs?: outputs.jaegertracing.v1.JaegerSpecVolumesGlusterfs;
            hostPath?: outputs.jaegertracing.v1.JaegerSpecVolumesHostPath;
            iscsi?: outputs.jaegertracing.v1.JaegerSpecVolumesIscsi;
            name: string;
            nfs?: outputs.jaegertracing.v1.JaegerSpecVolumesNfs;
            persistentVolumeClaim?: outputs.jaegertracing.v1.JaegerSpecVolumesPersistentVolumeClaim;
            photonPersistentDisk?: outputs.jaegertracing.v1.JaegerSpecVolumesPhotonPersistentDisk;
            portworxVolume?: outputs.jaegertracing.v1.JaegerSpecVolumesPortworxVolume;
            projected?: outputs.jaegertracing.v1.JaegerSpecVolumesProjected;
            quobyte?: outputs.jaegertracing.v1.JaegerSpecVolumesQuobyte;
            rbd?: outputs.jaegertracing.v1.JaegerSpecVolumesRbd;
            scaleIO?: outputs.jaegertracing.v1.JaegerSpecVolumesScaleIO;
            secret?: outputs.jaegertracing.v1.JaegerSpecVolumesSecret;
            storageos?: outputs.jaegertracing.v1.JaegerSpecVolumesStorageos;
            vsphereVolume?: outputs.jaegertracing.v1.JaegerSpecVolumesVsphereVolume;
        }

        export interface JaegerSpecVolumesAwsElasticBlockStore {
            fsType?: string;
            partition?: number;
            readOnly?: boolean;
            volumeID: string;
        }

        export interface JaegerSpecVolumesAzureDisk {
            cachingMode?: string;
            diskName: string;
            diskURI: string;
            fsType?: string;
            kind?: string;
            readOnly?: boolean;
        }

        export interface JaegerSpecVolumesAzureFile {
            readOnly?: boolean;
            secretName: string;
            shareName: string;
        }

        export interface JaegerSpecVolumesCephfs {
            monitors: string[];
            path?: string;
            readOnly?: boolean;
            secretFile?: string;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecVolumesCephfsSecretRef;
            user?: string;
        }

        export interface JaegerSpecVolumesCephfsSecretRef {
            name?: string;
        }

        export interface JaegerSpecVolumesCinder {
            fsType?: string;
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecVolumesCinderSecretRef;
            volumeID: string;
        }

        export interface JaegerSpecVolumesCinderSecretRef {
            name?: string;
        }

        export interface JaegerSpecVolumesConfigMap {
            defaultMode?: number;
            items?: outputs.jaegertracing.v1.JaegerSpecVolumesConfigMapItems[];
            name?: string;
            optional?: boolean;
        }

        export interface JaegerSpecVolumesConfigMapItems {
            key: string;
            mode?: number;
            path: string;
        }

        export interface JaegerSpecVolumesCsi {
            driver: string;
            fsType?: string;
            nodePublishSecretRef?: outputs.jaegertracing.v1.JaegerSpecVolumesCsiNodePublishSecretRef;
            readOnly?: boolean;
            volumeAttributes?: {[key: string]: string};
        }

        export interface JaegerSpecVolumesCsiNodePublishSecretRef {
            name?: string;
        }

        export interface JaegerSpecVolumesDownwardAPI {
            defaultMode?: number;
            items?: outputs.jaegertracing.v1.JaegerSpecVolumesDownwardAPIItems[];
        }

        export interface JaegerSpecVolumesDownwardAPIItems {
            fieldRef?: outputs.jaegertracing.v1.JaegerSpecVolumesDownwardAPIItemsFieldRef;
            mode?: number;
            path: string;
            resourceFieldRef?: outputs.jaegertracing.v1.JaegerSpecVolumesDownwardAPIItemsResourceFieldRef;
        }

        export interface JaegerSpecVolumesDownwardAPIItemsFieldRef {
            apiVersion?: string;
            fieldPath: string;
        }

        export interface JaegerSpecVolumesDownwardAPIItemsResourceFieldRef {
            containerName?: string;
            divisor?: string;
            resource: string;
        }

        export interface JaegerSpecVolumesEmptyDir {
            medium?: string;
            sizeLimit?: string;
        }

        export interface JaegerSpecVolumesFc {
            fsType?: string;
            lun?: number;
            readOnly?: boolean;
            targetWWNs?: string[];
            wwids?: string[];
        }

        export interface JaegerSpecVolumesFlexVolume {
            driver: string;
            fsType?: string;
            options?: {[key: string]: string};
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecVolumesFlexVolumeSecretRef;
        }

        export interface JaegerSpecVolumesFlexVolumeSecretRef {
            name?: string;
        }

        export interface JaegerSpecVolumesFlocker {
            datasetName?: string;
            datasetUUID?: string;
        }

        export interface JaegerSpecVolumesGcePersistentDisk {
            fsType?: string;
            partition?: number;
            pdName: string;
            readOnly?: boolean;
        }

        export interface JaegerSpecVolumesGitRepo {
            directory?: string;
            repository: string;
            revision?: string;
        }

        export interface JaegerSpecVolumesGlusterfs {
            endpoints: string;
            path: string;
            readOnly?: boolean;
        }

        export interface JaegerSpecVolumesHostPath {
            path: string;
            type?: string;
        }

        export interface JaegerSpecVolumesIscsi {
            chapAuthDiscovery?: boolean;
            chapAuthSession?: boolean;
            fsType?: string;
            initiatorName?: string;
            iqn: string;
            iscsiInterface?: string;
            lun: number;
            portals?: string[];
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecVolumesIscsiSecretRef;
            targetPortal: string;
        }

        export interface JaegerSpecVolumesIscsiSecretRef {
            name?: string;
        }

        export interface JaegerSpecVolumesNfs {
            path: string;
            readOnly?: boolean;
            server: string;
        }

        export interface JaegerSpecVolumesPersistentVolumeClaim {
            claimName: string;
            readOnly?: boolean;
        }

        export interface JaegerSpecVolumesPhotonPersistentDisk {
            fsType?: string;
            pdID: string;
        }

        export interface JaegerSpecVolumesPortworxVolume {
            fsType?: string;
            readOnly?: boolean;
            volumeID: string;
        }

        export interface JaegerSpecVolumesProjected {
            defaultMode?: number;
            sources: outputs.jaegertracing.v1.JaegerSpecVolumesProjectedSources[];
        }

        export interface JaegerSpecVolumesProjectedSources {
            configMap?: outputs.jaegertracing.v1.JaegerSpecVolumesProjectedSourcesConfigMap;
            downwardAPI?: outputs.jaegertracing.v1.JaegerSpecVolumesProjectedSourcesDownwardAPI;
            secret?: outputs.jaegertracing.v1.JaegerSpecVolumesProjectedSourcesSecret;
            serviceAccountToken?: outputs.jaegertracing.v1.JaegerSpecVolumesProjectedSourcesServiceAccountToken;
        }

        export interface JaegerSpecVolumesProjectedSourcesConfigMap {
            items?: outputs.jaegertracing.v1.JaegerSpecVolumesProjectedSourcesConfigMapItems[];
            name?: string;
            optional?: boolean;
        }

        export interface JaegerSpecVolumesProjectedSourcesConfigMapItems {
            key: string;
            mode?: number;
            path: string;
        }

        export interface JaegerSpecVolumesProjectedSourcesDownwardAPI {
            items?: outputs.jaegertracing.v1.JaegerSpecVolumesProjectedSourcesDownwardAPIItems[];
        }

        export interface JaegerSpecVolumesProjectedSourcesDownwardAPIItems {
            fieldRef?: outputs.jaegertracing.v1.JaegerSpecVolumesProjectedSourcesDownwardAPIItemsFieldRef;
            mode?: number;
            path: string;
            resourceFieldRef?: outputs.jaegertracing.v1.JaegerSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef;
        }

        export interface JaegerSpecVolumesProjectedSourcesDownwardAPIItemsFieldRef {
            apiVersion?: string;
            fieldPath: string;
        }

        export interface JaegerSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef {
            containerName?: string;
            divisor?: string;
            resource: string;
        }

        export interface JaegerSpecVolumesProjectedSourcesSecret {
            items?: outputs.jaegertracing.v1.JaegerSpecVolumesProjectedSourcesSecretItems[];
            name?: string;
            optional?: boolean;
        }

        export interface JaegerSpecVolumesProjectedSourcesSecretItems {
            key: string;
            mode?: number;
            path: string;
        }

        export interface JaegerSpecVolumesProjectedSourcesServiceAccountToken {
            audience?: string;
            expirationSeconds?: number;
            path: string;
        }

        export interface JaegerSpecVolumesQuobyte {
            group?: string;
            readOnly?: boolean;
            registry: string;
            tenant?: string;
            user?: string;
            volume: string;
        }

        export interface JaegerSpecVolumesRbd {
            fsType?: string;
            image: string;
            keyring?: string;
            monitors: string[];
            pool?: string;
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecVolumesRbdSecretRef;
            user?: string;
        }

        export interface JaegerSpecVolumesRbdSecretRef {
            name?: string;
        }

        export interface JaegerSpecVolumesScaleIO {
            fsType?: string;
            gateway: string;
            protectionDomain?: string;
            readOnly?: boolean;
            secretRef: outputs.jaegertracing.v1.JaegerSpecVolumesScaleIOSecretRef;
            sslEnabled?: boolean;
            storageMode?: string;
            storagePool?: string;
            system: string;
            volumeName?: string;
        }

        export interface JaegerSpecVolumesScaleIOSecretRef {
            name?: string;
        }

        export interface JaegerSpecVolumesSecret {
            defaultMode?: number;
            items?: outputs.jaegertracing.v1.JaegerSpecVolumesSecretItems[];
            optional?: boolean;
            secretName?: string;
        }

        export interface JaegerSpecVolumesSecretItems {
            key: string;
            mode?: number;
            path: string;
        }

        export interface JaegerSpecVolumesStorageos {
            fsType?: string;
            readOnly?: boolean;
            secretRef?: outputs.jaegertracing.v1.JaegerSpecVolumesStorageosSecretRef;
            volumeName?: string;
            volumeNamespace?: string;
        }

        export interface JaegerSpecVolumesStorageosSecretRef {
            name?: string;
        }

        export interface JaegerSpecVolumesVsphereVolume {
            fsType?: string;
            storagePolicyID?: string;
            storagePolicyName?: string;
            volumePath: string;
        }

        export interface JaegerStatus {
            phase: string;
            version: string;
        }
    }
}
