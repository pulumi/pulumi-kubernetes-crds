# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from ... import _utilities, _tables

__all__ = [
    'KubernetesApplicationResourceSpecArgs',
    'KubernetesApplicationResourceSpecSecretsArgs',
    'KubernetesApplicationResourceSpecTargetRefArgs',
    'KubernetesApplicationResourceStatusArgs',
    'KubernetesApplicationResourceStatusConditionedStatusArgs',
    'KubernetesApplicationResourceStatusConditionedStatusConditionsArgs',
    'KubernetesApplicationResourceStatusRemoteArgs',
    'KubernetesApplicationSpecArgs',
    'KubernetesApplicationSpecResourceSelectorArgs',
    'KubernetesApplicationSpecResourceSelectorMatchExpressionsArgs',
    'KubernetesApplicationSpecResourceTemplatesArgs',
    'KubernetesApplicationSpecResourceTemplatesSpecArgs',
    'KubernetesApplicationSpecResourceTemplatesSpecSecretsArgs',
    'KubernetesApplicationSpecResourceTemplatesSpecTargetRefArgs',
    'KubernetesApplicationSpecTargetRefArgs',
    'KubernetesApplicationSpecTargetSelectorArgs',
    'KubernetesApplicationSpecTargetSelectorMatchExpressionsArgs',
    'KubernetesApplicationStatusArgs',
    'KubernetesApplicationStatusConditionedStatusArgs',
    'KubernetesApplicationStatusConditionedStatusConditionsArgs',
    'KubernetesTargetSpecArgs',
    'KubernetesTargetSpecClusterRefArgs',
    'KubernetesTargetSpecConnectionSecretRefArgs',
    'KubernetesTargetStatusArgs',
    'KubernetesTargetStatusConditionsArgs',
]

@pulumi.input_type
class KubernetesApplicationResourceSpecArgs:
    def __init__(__self__, *,
                 template: pulumi.Input[Mapping[str, Any]],
                 secrets: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesApplicationResourceSpecSecretsArgs']]]] = None,
                 target_ref: Optional[pulumi.Input['KubernetesApplicationResourceSpecTargetRefArgs']] = None):
        """
        KubernetesApplicationResourceSpec specifies the desired state of a KubernetesApplicationResource.
        :param pulumi.Input[Mapping[str, Any]] template: A Template for a Kubernetes resource to be submitted to the KubernetesCluster to which this application resource is scheduled. The resource must be understood by the KubernetesCluster. Crossplane requires only that the resource contains standard Kubernetes type and object metadata.
        :param pulumi.Input[Sequence[pulumi.Input['KubernetesApplicationResourceSpecSecretsArgs']]] secrets: Secrets upon which this application resource depends. These secrets will be propagated to the Kubernetes cluster to which this application is scheduled.
        :param pulumi.Input['KubernetesApplicationResourceSpecTargetRefArgs'] target_ref: Target to which this application has been scheduled.
        """
        pulumi.set(__self__, "template", template)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)
        if target_ref is not None:
            pulumi.set(__self__, "target_ref", target_ref)

    @property
    @pulumi.getter
    def template(self) -> pulumi.Input[Mapping[str, Any]]:
        """
        A Template for a Kubernetes resource to be submitted to the KubernetesCluster to which this application resource is scheduled. The resource must be understood by the KubernetesCluster. Crossplane requires only that the resource contains standard Kubernetes type and object metadata.
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: pulumi.Input[Mapping[str, Any]]):
        pulumi.set(self, "template", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesApplicationResourceSpecSecretsArgs']]]]:
        """
        Secrets upon which this application resource depends. These secrets will be propagated to the Kubernetes cluster to which this application is scheduled.
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesApplicationResourceSpecSecretsArgs']]]]):
        pulumi.set(self, "secrets", value)

    @property
    @pulumi.getter(name="targetRef")
    def target_ref(self) -> Optional[pulumi.Input['KubernetesApplicationResourceSpecTargetRefArgs']]:
        """
        Target to which this application has been scheduled.
        """
        return pulumi.get(self, "target_ref")

    @target_ref.setter
    def target_ref(self, value: Optional[pulumi.Input['KubernetesApplicationResourceSpecTargetRefArgs']]):
        pulumi.set(self, "target_ref", value)


@pulumi.input_type
class KubernetesApplicationResourceSpecSecretsArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class KubernetesApplicationResourceSpecTargetRefArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        Target to which this application has been scheduled.
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class KubernetesApplicationResourceStatusArgs:
    def __init__(__self__, *,
                 conditioned_status: Optional[pulumi.Input['KubernetesApplicationResourceStatusConditionedStatusArgs']] = None,
                 remote: Optional[pulumi.Input['KubernetesApplicationResourceStatusRemoteArgs']] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        KubernetesApplicationResourceStatus represents the observed state of a KubernetesApplicationResource.
        :param pulumi.Input['KubernetesApplicationResourceStatusConditionedStatusArgs'] conditioned_status: A ConditionedStatus reflects the observed status of a resource. Only one condition of each type may exist.
        :param pulumi.Input['KubernetesApplicationResourceStatusRemoteArgs'] remote: Remote status of the resource templated by this application resource.
        :param pulumi.Input[str] state: State of the application.
        """
        if conditioned_status is not None:
            pulumi.set(__self__, "conditioned_status", conditioned_status)
        if remote is not None:
            pulumi.set(__self__, "remote", remote)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="conditionedStatus")
    def conditioned_status(self) -> Optional[pulumi.Input['KubernetesApplicationResourceStatusConditionedStatusArgs']]:
        """
        A ConditionedStatus reflects the observed status of a resource. Only one condition of each type may exist.
        """
        return pulumi.get(self, "conditioned_status")

    @conditioned_status.setter
    def conditioned_status(self, value: Optional[pulumi.Input['KubernetesApplicationResourceStatusConditionedStatusArgs']]):
        pulumi.set(self, "conditioned_status", value)

    @property
    @pulumi.getter
    def remote(self) -> Optional[pulumi.Input['KubernetesApplicationResourceStatusRemoteArgs']]:
        """
        Remote status of the resource templated by this application resource.
        """
        return pulumi.get(self, "remote")

    @remote.setter
    def remote(self, value: Optional[pulumi.Input['KubernetesApplicationResourceStatusRemoteArgs']]):
        pulumi.set(self, "remote", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        State of the application.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


@pulumi.input_type
class KubernetesApplicationResourceStatusConditionedStatusArgs:
    def __init__(__self__, *,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesApplicationResourceStatusConditionedStatusConditionsArgs']]]] = None):
        """
        A ConditionedStatus reflects the observed status of a resource. Only one condition of each type may exist.
        :param pulumi.Input[Sequence[pulumi.Input['KubernetesApplicationResourceStatusConditionedStatusConditionsArgs']]] conditions: Conditions of the resource.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesApplicationResourceStatusConditionedStatusConditionsArgs']]]]:
        """
        Conditions of the resource.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesApplicationResourceStatusConditionedStatusConditionsArgs']]]]):
        pulumi.set(self, "conditions", value)


@pulumi.input_type
class KubernetesApplicationResourceStatusConditionedStatusConditionsArgs:
    def __init__(__self__, *,
                 last_transition_time: pulumi.Input[str],
                 reason: pulumi.Input[str],
                 status: pulumi.Input[str],
                 type: pulumi.Input[str],
                 message: Optional[pulumi.Input[str]] = None):
        """
        A Condition that may apply to a resource.
        :param pulumi.Input[str] last_transition_time: LastTransitionTime is the last time this condition transitioned from one status to another.
        :param pulumi.Input[str] reason: A Reason for this condition's last transition from one status to another.
        :param pulumi.Input[str] status: Status of this condition; is it currently True, False, or Unknown?
        :param pulumi.Input[str] type: Type of this condition. At most one of each condition type may apply to a resource at any point in time.
        :param pulumi.Input[str] message: A Message containing details about this condition's last transition from one status to another, if any.
        """
        pulumi.set(__self__, "last_transition_time", last_transition_time)
        pulumi.set(__self__, "reason", reason)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> pulumi.Input[str]:
        """
        LastTransitionTime is the last time this condition transitioned from one status to another.
        """
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def reason(self) -> pulumi.Input[str]:
        """
        A Reason for this condition's last transition from one status to another.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: pulumi.Input[str]):
        pulumi.set(self, "reason", value)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        """
        Status of this condition; is it currently True, False, or Unknown?
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of this condition. At most one of each condition type may apply to a resource at any point in time.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        A Message containing details about this condition's last transition from one status to another, if any.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)


@pulumi.input_type
class KubernetesApplicationResourceStatusRemoteArgs:
    def __init__(__self__, *,
                 raw: Optional[pulumi.Input[str]] = None):
        """
        Remote status of the resource templated by this application resource.
        :param pulumi.Input[str] raw: Raw JSON representation of the remote status as a byte array.
        """
        if raw is not None:
            pulumi.set(__self__, "raw", raw)

    @property
    @pulumi.getter
    def raw(self) -> Optional[pulumi.Input[str]]:
        """
        Raw JSON representation of the remote status as a byte array.
        """
        return pulumi.get(self, "raw")

    @raw.setter
    def raw(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "raw", value)


@pulumi.input_type
class KubernetesApplicationSpecArgs:
    def __init__(__self__, *,
                 resource_selector: pulumi.Input['KubernetesApplicationSpecResourceSelectorArgs'],
                 resource_templates: pulumi.Input[Sequence[pulumi.Input['KubernetesApplicationSpecResourceTemplatesArgs']]],
                 target_ref: Optional[pulumi.Input['KubernetesApplicationSpecTargetRefArgs']] = None,
                 target_selector: Optional[pulumi.Input['KubernetesApplicationSpecTargetSelectorArgs']] = None):
        """
        A KubernetesApplicationSpec specifies the resources of a Kubernetes application.
        :param pulumi.Input['KubernetesApplicationSpecResourceSelectorArgs'] resource_selector: ResourceSelector selects the KubernetesApplicationResources that are managed by this KubernetesApplication. Note that a KubernetesApplication will never adopt orphaned KubernetesApplicationResources, and thus this selector serves only to help match a KubernetesApplication to its KubernetesApplicationResources.
        :param pulumi.Input[Sequence[pulumi.Input['KubernetesApplicationSpecResourceTemplatesArgs']]] resource_templates: ResourceTemplates specifies a set of Kubernetes application resources managed by this application.
        :param pulumi.Input['KubernetesApplicationSpecTargetRefArgs'] target_ref: Target to which this application has been scheduled.
        :param pulumi.Input['KubernetesApplicationSpecTargetSelectorArgs'] target_selector: TargetSelector selects the targets to which this application may be scheduled. Leave both match labels and expressions empty to match any target.
        """
        pulumi.set(__self__, "resource_selector", resource_selector)
        pulumi.set(__self__, "resource_templates", resource_templates)
        if target_ref is not None:
            pulumi.set(__self__, "target_ref", target_ref)
        if target_selector is not None:
            pulumi.set(__self__, "target_selector", target_selector)

    @property
    @pulumi.getter(name="resourceSelector")
    def resource_selector(self) -> pulumi.Input['KubernetesApplicationSpecResourceSelectorArgs']:
        """
        ResourceSelector selects the KubernetesApplicationResources that are managed by this KubernetesApplication. Note that a KubernetesApplication will never adopt orphaned KubernetesApplicationResources, and thus this selector serves only to help match a KubernetesApplication to its KubernetesApplicationResources.
        """
        return pulumi.get(self, "resource_selector")

    @resource_selector.setter
    def resource_selector(self, value: pulumi.Input['KubernetesApplicationSpecResourceSelectorArgs']):
        pulumi.set(self, "resource_selector", value)

    @property
    @pulumi.getter(name="resourceTemplates")
    def resource_templates(self) -> pulumi.Input[Sequence[pulumi.Input['KubernetesApplicationSpecResourceTemplatesArgs']]]:
        """
        ResourceTemplates specifies a set of Kubernetes application resources managed by this application.
        """
        return pulumi.get(self, "resource_templates")

    @resource_templates.setter
    def resource_templates(self, value: pulumi.Input[Sequence[pulumi.Input['KubernetesApplicationSpecResourceTemplatesArgs']]]):
        pulumi.set(self, "resource_templates", value)

    @property
    @pulumi.getter(name="targetRef")
    def target_ref(self) -> Optional[pulumi.Input['KubernetesApplicationSpecTargetRefArgs']]:
        """
        Target to which this application has been scheduled.
        """
        return pulumi.get(self, "target_ref")

    @target_ref.setter
    def target_ref(self, value: Optional[pulumi.Input['KubernetesApplicationSpecTargetRefArgs']]):
        pulumi.set(self, "target_ref", value)

    @property
    @pulumi.getter(name="targetSelector")
    def target_selector(self) -> Optional[pulumi.Input['KubernetesApplicationSpecTargetSelectorArgs']]:
        """
        TargetSelector selects the targets to which this application may be scheduled. Leave both match labels and expressions empty to match any target.
        """
        return pulumi.get(self, "target_selector")

    @target_selector.setter
    def target_selector(self, value: Optional[pulumi.Input['KubernetesApplicationSpecTargetSelectorArgs']]):
        pulumi.set(self, "target_selector", value)


@pulumi.input_type
class KubernetesApplicationSpecResourceSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesApplicationSpecResourceSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        ResourceSelector selects the KubernetesApplicationResources that are managed by this KubernetesApplication. Note that a KubernetesApplication will never adopt orphaned KubernetesApplicationResources, and thus this selector serves only to help match a KubernetesApplication to its KubernetesApplicationResources.
        :param pulumi.Input[Sequence[pulumi.Input['KubernetesApplicationSpecResourceSelectorMatchExpressionsArgs']]] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesApplicationSpecResourceSelectorMatchExpressionsArgs']]]]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesApplicationSpecResourceSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KubernetesApplicationSpecResourceSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param pulumi.Input[str] key: key is the label key that the selector applies to.
        :param pulumi.Input[str] operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KubernetesApplicationSpecResourceTemplatesArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 spec: Optional[pulumi.Input['KubernetesApplicationSpecResourceTemplatesSpecArgs']] = None):
        """
        A KubernetesApplicationResourceTemplate is used to instantiate new KubernetesApplicationResources.
        :param pulumi.Input['KubernetesApplicationSpecResourceTemplatesSpecArgs'] spec: KubernetesApplicationResourceSpec specifies the desired state of a KubernetesApplicationResource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter
    def spec(self) -> Optional[pulumi.Input['KubernetesApplicationSpecResourceTemplatesSpecArgs']]:
        """
        KubernetesApplicationResourceSpec specifies the desired state of a KubernetesApplicationResource.
        """
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: Optional[pulumi.Input['KubernetesApplicationSpecResourceTemplatesSpecArgs']]):
        pulumi.set(self, "spec", value)


@pulumi.input_type
class KubernetesApplicationSpecResourceTemplatesSpecArgs:
    def __init__(__self__, *,
                 template: pulumi.Input[Mapping[str, Any]],
                 secrets: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesApplicationSpecResourceTemplatesSpecSecretsArgs']]]] = None,
                 target_ref: Optional[pulumi.Input['KubernetesApplicationSpecResourceTemplatesSpecTargetRefArgs']] = None):
        """
        KubernetesApplicationResourceSpec specifies the desired state of a KubernetesApplicationResource.
        :param pulumi.Input[Mapping[str, Any]] template: A Template for a Kubernetes resource to be submitted to the KubernetesCluster to which this application resource is scheduled. The resource must be understood by the KubernetesCluster. Crossplane requires only that the resource contains standard Kubernetes type and object metadata.
        :param pulumi.Input[Sequence[pulumi.Input['KubernetesApplicationSpecResourceTemplatesSpecSecretsArgs']]] secrets: Secrets upon which this application resource depends. These secrets will be propagated to the Kubernetes cluster to which this application is scheduled.
        :param pulumi.Input['KubernetesApplicationSpecResourceTemplatesSpecTargetRefArgs'] target_ref: Target to which this application has been scheduled.
        """
        pulumi.set(__self__, "template", template)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)
        if target_ref is not None:
            pulumi.set(__self__, "target_ref", target_ref)

    @property
    @pulumi.getter
    def template(self) -> pulumi.Input[Mapping[str, Any]]:
        """
        A Template for a Kubernetes resource to be submitted to the KubernetesCluster to which this application resource is scheduled. The resource must be understood by the KubernetesCluster. Crossplane requires only that the resource contains standard Kubernetes type and object metadata.
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: pulumi.Input[Mapping[str, Any]]):
        pulumi.set(self, "template", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesApplicationSpecResourceTemplatesSpecSecretsArgs']]]]:
        """
        Secrets upon which this application resource depends. These secrets will be propagated to the Kubernetes cluster to which this application is scheduled.
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesApplicationSpecResourceTemplatesSpecSecretsArgs']]]]):
        pulumi.set(self, "secrets", value)

    @property
    @pulumi.getter(name="targetRef")
    def target_ref(self) -> Optional[pulumi.Input['KubernetesApplicationSpecResourceTemplatesSpecTargetRefArgs']]:
        """
        Target to which this application has been scheduled.
        """
        return pulumi.get(self, "target_ref")

    @target_ref.setter
    def target_ref(self, value: Optional[pulumi.Input['KubernetesApplicationSpecResourceTemplatesSpecTargetRefArgs']]):
        pulumi.set(self, "target_ref", value)


@pulumi.input_type
class KubernetesApplicationSpecResourceTemplatesSpecSecretsArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class KubernetesApplicationSpecResourceTemplatesSpecTargetRefArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        Target to which this application has been scheduled.
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class KubernetesApplicationSpecTargetRefArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        Target to which this application has been scheduled.
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class KubernetesApplicationSpecTargetSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesApplicationSpecTargetSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        TargetSelector selects the targets to which this application may be scheduled. Leave both match labels and expressions empty to match any target.
        :param pulumi.Input[Sequence[pulumi.Input['KubernetesApplicationSpecTargetSelectorMatchExpressionsArgs']]] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesApplicationSpecTargetSelectorMatchExpressionsArgs']]]]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesApplicationSpecTargetSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KubernetesApplicationSpecTargetSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param pulumi.Input[str] key: key is the label key that the selector applies to.
        :param pulumi.Input[str] operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KubernetesApplicationStatusArgs:
    def __init__(__self__, *,
                 conditioned_status: Optional[pulumi.Input['KubernetesApplicationStatusConditionedStatusArgs']] = None,
                 desired_resources: Optional[pulumi.Input[int]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 submitted_resources: Optional[pulumi.Input[int]] = None):
        """
        KubernetesApplicationStatus represents the observed state of a KubernetesApplication.
        :param pulumi.Input['KubernetesApplicationStatusConditionedStatusArgs'] conditioned_status: A ConditionedStatus reflects the observed status of a resource. Only one condition of each type may exist.
        :param pulumi.Input[int] desired_resources: Desired resources of this application, i.e. the number of resources that match this application's resource selector.
        :param pulumi.Input[str] state: State of the application.
        :param pulumi.Input[int] submitted_resources: Submitted resources of this workload, i.e. the subset of desired resources that have been successfully submitted to their scheduled Kubernetes cluster.
        """
        if conditioned_status is not None:
            pulumi.set(__self__, "conditioned_status", conditioned_status)
        if desired_resources is not None:
            pulumi.set(__self__, "desired_resources", desired_resources)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if submitted_resources is not None:
            pulumi.set(__self__, "submitted_resources", submitted_resources)

    @property
    @pulumi.getter(name="conditionedStatus")
    def conditioned_status(self) -> Optional[pulumi.Input['KubernetesApplicationStatusConditionedStatusArgs']]:
        """
        A ConditionedStatus reflects the observed status of a resource. Only one condition of each type may exist.
        """
        return pulumi.get(self, "conditioned_status")

    @conditioned_status.setter
    def conditioned_status(self, value: Optional[pulumi.Input['KubernetesApplicationStatusConditionedStatusArgs']]):
        pulumi.set(self, "conditioned_status", value)

    @property
    @pulumi.getter(name="desiredResources")
    def desired_resources(self) -> Optional[pulumi.Input[int]]:
        """
        Desired resources of this application, i.e. the number of resources that match this application's resource selector.
        """
        return pulumi.get(self, "desired_resources")

    @desired_resources.setter
    def desired_resources(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "desired_resources", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        State of the application.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="submittedResources")
    def submitted_resources(self) -> Optional[pulumi.Input[int]]:
        """
        Submitted resources of this workload, i.e. the subset of desired resources that have been successfully submitted to their scheduled Kubernetes cluster.
        """
        return pulumi.get(self, "submitted_resources")

    @submitted_resources.setter
    def submitted_resources(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "submitted_resources", value)


@pulumi.input_type
class KubernetesApplicationStatusConditionedStatusArgs:
    def __init__(__self__, *,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesApplicationStatusConditionedStatusConditionsArgs']]]] = None):
        """
        A ConditionedStatus reflects the observed status of a resource. Only one condition of each type may exist.
        :param pulumi.Input[Sequence[pulumi.Input['KubernetesApplicationStatusConditionedStatusConditionsArgs']]] conditions: Conditions of the resource.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesApplicationStatusConditionedStatusConditionsArgs']]]]:
        """
        Conditions of the resource.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesApplicationStatusConditionedStatusConditionsArgs']]]]):
        pulumi.set(self, "conditions", value)


@pulumi.input_type
class KubernetesApplicationStatusConditionedStatusConditionsArgs:
    def __init__(__self__, *,
                 last_transition_time: pulumi.Input[str],
                 reason: pulumi.Input[str],
                 status: pulumi.Input[str],
                 type: pulumi.Input[str],
                 message: Optional[pulumi.Input[str]] = None):
        """
        A Condition that may apply to a resource.
        :param pulumi.Input[str] last_transition_time: LastTransitionTime is the last time this condition transitioned from one status to another.
        :param pulumi.Input[str] reason: A Reason for this condition's last transition from one status to another.
        :param pulumi.Input[str] status: Status of this condition; is it currently True, False, or Unknown?
        :param pulumi.Input[str] type: Type of this condition. At most one of each condition type may apply to a resource at any point in time.
        :param pulumi.Input[str] message: A Message containing details about this condition's last transition from one status to another, if any.
        """
        pulumi.set(__self__, "last_transition_time", last_transition_time)
        pulumi.set(__self__, "reason", reason)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> pulumi.Input[str]:
        """
        LastTransitionTime is the last time this condition transitioned from one status to another.
        """
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def reason(self) -> pulumi.Input[str]:
        """
        A Reason for this condition's last transition from one status to another.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: pulumi.Input[str]):
        pulumi.set(self, "reason", value)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        """
        Status of this condition; is it currently True, False, or Unknown?
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of this condition. At most one of each condition type may apply to a resource at any point in time.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        A Message containing details about this condition's last transition from one status to another, if any.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)


@pulumi.input_type
class KubernetesTargetSpecArgs:
    def __init__(__self__, *,
                 cluster_ref: Optional[pulumi.Input['KubernetesTargetSpecClusterRefArgs']] = None,
                 connection_secret_ref: Optional[pulumi.Input['KubernetesTargetSpecConnectionSecretRefArgs']] = None):
        """
        A TargetSpec defines the common fields of objects used for exposing infrastructure to workloads that can be scheduled to.
        :param pulumi.Input['KubernetesTargetSpecClusterRefArgs'] cluster_ref: A ResourceReference specifies an existing managed resource, in any namespace, which this target should attempt to propagate a connection secret from.
        :param pulumi.Input['KubernetesTargetSpecConnectionSecretRefArgs'] connection_secret_ref: WriteConnectionSecretToReference specifies the name of a Secret, in the same namespace as this target, to which any connection details for this target should be written or already exist. Connection secrets referenced by a target should contain information for connecting to a resource that allows for scheduling of workloads.
        """
        if cluster_ref is not None:
            pulumi.set(__self__, "cluster_ref", cluster_ref)
        if connection_secret_ref is not None:
            pulumi.set(__self__, "connection_secret_ref", connection_secret_ref)

    @property
    @pulumi.getter(name="clusterRef")
    def cluster_ref(self) -> Optional[pulumi.Input['KubernetesTargetSpecClusterRefArgs']]:
        """
        A ResourceReference specifies an existing managed resource, in any namespace, which this target should attempt to propagate a connection secret from.
        """
        return pulumi.get(self, "cluster_ref")

    @cluster_ref.setter
    def cluster_ref(self, value: Optional[pulumi.Input['KubernetesTargetSpecClusterRefArgs']]):
        pulumi.set(self, "cluster_ref", value)

    @property
    @pulumi.getter(name="connectionSecretRef")
    def connection_secret_ref(self) -> Optional[pulumi.Input['KubernetesTargetSpecConnectionSecretRefArgs']]:
        """
        WriteConnectionSecretToReference specifies the name of a Secret, in the same namespace as this target, to which any connection details for this target should be written or already exist. Connection secrets referenced by a target should contain information for connecting to a resource that allows for scheduling of workloads.
        """
        return pulumi.get(self, "connection_secret_ref")

    @connection_secret_ref.setter
    def connection_secret_ref(self, value: Optional[pulumi.Input['KubernetesTargetSpecConnectionSecretRefArgs']]):
        pulumi.set(self, "connection_secret_ref", value)


@pulumi.input_type
class KubernetesTargetSpecClusterRefArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 field_path: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 resource_version: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        A ResourceReference specifies an existing managed resource, in any namespace, which this target should attempt to propagate a connection secret from.
        :param pulumi.Input[str] api_version: API version of the referent.
        :param pulumi.Input[str] field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param pulumi.Input[str] kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param pulumi.Input[str] namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param pulumi.Input[str] resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param pulumi.Input[str] uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[pulumi.Input[str]]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_path", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @resource_version.setter
    def resource_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_version", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class KubernetesTargetSpecConnectionSecretRefArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        WriteConnectionSecretToReference specifies the name of a Secret, in the same namespace as this target, to which any connection details for this target should be written or already exist. Connection secrets referenced by a target should contain information for connecting to a resource that allows for scheduling of workloads.
        :param pulumi.Input[str] name: Name of the secret.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the secret.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class KubernetesTargetStatusArgs:
    def __init__(__self__, *,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesTargetStatusConditionsArgs']]]] = None):
        """
        A TargetStatus defines the observed status a target.
        :param pulumi.Input[Sequence[pulumi.Input['KubernetesTargetStatusConditionsArgs']]] conditions: Conditions of the resource.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesTargetStatusConditionsArgs']]]]:
        """
        Conditions of the resource.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesTargetStatusConditionsArgs']]]]):
        pulumi.set(self, "conditions", value)


@pulumi.input_type
class KubernetesTargetStatusConditionsArgs:
    def __init__(__self__, *,
                 last_transition_time: pulumi.Input[str],
                 reason: pulumi.Input[str],
                 status: pulumi.Input[str],
                 type: pulumi.Input[str],
                 message: Optional[pulumi.Input[str]] = None):
        """
        A Condition that may apply to a resource.
        :param pulumi.Input[str] last_transition_time: LastTransitionTime is the last time this condition transitioned from one status to another.
        :param pulumi.Input[str] reason: A Reason for this condition's last transition from one status to another.
        :param pulumi.Input[str] status: Status of this condition; is it currently True, False, or Unknown?
        :param pulumi.Input[str] type: Type of this condition. At most one of each condition type may apply to a resource at any point in time.
        :param pulumi.Input[str] message: A Message containing details about this condition's last transition from one status to another, if any.
        """
        pulumi.set(__self__, "last_transition_time", last_transition_time)
        pulumi.set(__self__, "reason", reason)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> pulumi.Input[str]:
        """
        LastTransitionTime is the last time this condition transitioned from one status to another.
        """
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def reason(self) -> pulumi.Input[str]:
        """
        A Reason for this condition's last transition from one status to another.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: pulumi.Input[str]):
        pulumi.set(self, "reason", value)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        """
        Status of this condition; is it currently True, False, or Unknown?
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of this condition. At most one of each condition type may apply to a resource at any point in time.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        A Message containing details about this condition's last transition from one status to another, if any.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)


