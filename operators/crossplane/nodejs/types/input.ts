// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

import {ObjectMeta} from "../meta/v1";

export namespace apiextensions {
    export namespace v1alpha1 {
        /**
         * CompositionSpec specifies the desired state of the definition.
         */
        export interface CompositionSpec {
            /**
             * From refers to the type that this composition is compatible. The values for the underlying resources will be fetched from the instances of the From.
             */
            from: pulumi.Input<inputs.apiextensions.v1alpha1.CompositionSpecFrom>;
            /**
             * ReclaimPolicy specifies what will happen to composite resource dynamically provisioned using this composition when their namespaced referrer is deleted. The "Delete" policy causes the composite resource to be deleted when its namespaced referrer is deleted. The "Retain" policy causes the composite resource to be retained, in binding phase "Released", when its namespaced referrer is deleted. The "Retain" policy is used when no policy is specified, however the "Delete" policy is set at dynamic provisioning time if no policy is set.
             */
            reclaimPolicy?: pulumi.Input<string>;
            /**
             * To is the list of target resources that make up the composition.
             */
            to: pulumi.Input<pulumi.Input<inputs.apiextensions.v1alpha1.CompositionSpecTo>[]>;
            /**
             * WriteConnectionSecretsToNamespace specifies the namespace in which the connection secrets of composite resource dynamically provisioned using this composition will be created.
             */
            writeConnectionSecretsToNamespace: pulumi.Input<string>;
        }

        /**
         * From refers to the type that this composition is compatible. The values for the underlying resources will be fetched from the instances of the From.
         */
        export interface CompositionSpecFrom {
            /**
             * APIVersion of the type.
             */
            apiVersion: pulumi.Input<string>;
            /**
             * Kind of the type.
             */
            kind: pulumi.Input<string>;
        }

        /**
         * ComposedTemplate is used to provide information about how the composed resource should be processed.
         */
        export interface CompositionSpecTo {
            /**
             * Base is the target resource that the patches will be applied on.
             */
            base: pulumi.Input<{[key: string]: any}>;
            /**
             * ConnectionDetails lists the propagation secret keys from this target resource to the composition instance connection secret.
             */
            connectionDetails?: pulumi.Input<pulumi.Input<inputs.apiextensions.v1alpha1.CompositionSpecToConnectionDetails>[]>;
            /**
             * Patches will be applied as overlay to the base resource.
             */
            patches?: pulumi.Input<pulumi.Input<inputs.apiextensions.v1alpha1.CompositionSpecToPatches>[]>;
        }

        /**
         * ConnectionDetail includes the information about the propagation of the connection information from one secret to another.
         */
        export interface CompositionSpecToConnectionDetails {
            /**
             * FromConnectionSecretKey is the key that will be used to fetch the value from the given target resource.
             */
            fromConnectionSecretKey: pulumi.Input<string>;
            /**
             * Name of the connection secret key that will be propagated to the connection secret of the composition instance. Leave empty if you'd like to use the same key name.
             */
            name?: pulumi.Input<string>;
        }

        /**
         * Patch is used to patch the field on the base resource at ToFieldPath after piping the value that is at FromFieldPath of the target resource through transformers.
         */
        export interface CompositionSpecToPatches {
            /**
             * FromFieldPath is the path of the field on the upstream resource whose value to be used as input.
             */
            fromFieldPath: pulumi.Input<string>;
            /**
             * ToFieldPath is the path of the field on the base resource whose value will be changed with the result of transforms. Leave empty if you'd like to propagate to the same path on the target resource.
             */
            toFieldPath?: pulumi.Input<string>;
            /**
             * Transforms are the list of functions that are used as a FIFO pipe for the input to be transformed.
             */
            transforms?: pulumi.Input<pulumi.Input<inputs.apiextensions.v1alpha1.CompositionSpecToPatchesTransforms>[]>;
        }

        /**
         * Transform is a unit of process whose input is transformed into an output with the supplied configuration.
         */
        export interface CompositionSpecToPatchesTransforms {
            /**
             * Map uses the input as a key in the given map and returns the value.
             */
            map?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Math is used to transform the input via mathematical operations such as multiplication.
             */
            math?: pulumi.Input<inputs.apiextensions.v1alpha1.CompositionSpecToPatchesTransformsMath>;
            /**
             * String is used to transform the input into a string or a different kind of string. Note that the input does not necessarily need to be a string.
             */
            string?: pulumi.Input<inputs.apiextensions.v1alpha1.CompositionSpecToPatchesTransformsString>;
            /**
             * Type of the transform to be run.
             */
            type: pulumi.Input<string>;
        }

        /**
         * Math is used to transform the input via mathematical operations such as multiplication.
         */
        export interface CompositionSpecToPatchesTransformsMath {
            /**
             * Multiply the value.
             */
            multiply?: pulumi.Input<number>;
        }

        /**
         * String is used to transform the input into a string or a different kind of string. Note that the input does not necessarily need to be a string.
         */
        export interface CompositionSpecToPatchesTransformsString {
            /**
             * Format the input using a Go format string. See https://golang.org/pkg/fmt/ for details.
             */
            fmt: pulumi.Input<string>;
        }

        /**
         * CompositionStatus shows the observed state of the composition.
         */
        export interface CompositionStatus {
            /**
             * Conditions of the resource.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.apiextensions.v1alpha1.CompositionStatusConditions>[]>;
        }

        /**
         * A Condition that may apply to a resource.
         */
        export interface CompositionStatusConditions {
            /**
             * LastTransitionTime is the last time this condition transitioned from one status to another.
             */
            lastTransitionTime: pulumi.Input<string>;
            /**
             * A Message containing details about this condition's last transition from one status to another, if any.
             */
            message?: pulumi.Input<string>;
            /**
             * A Reason for this condition's last transition from one status to another.
             */
            reason: pulumi.Input<string>;
            /**
             * Status of this condition; is it currently True, False, or Unknown?
             */
            status: pulumi.Input<string>;
            /**
             * Type of this condition. At most one of each condition type may apply to a resource at any point in time.
             */
            type: pulumi.Input<string>;
        }

        /**
         * InfrastructureDefinitionSpec specifies the desired state of the definition.
         */
        export interface InfrastructureDefinitionSpec {
            /**
             * ConnectionSecretKeys is the list of keys that will be exposed to the end user of the defined kind.
             */
            connectionSecretKeys?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * CRDSpecTemplate is the base CRD template. The final CRD will have additional fields to the base template to accommodate Crossplane machinery.
             */
            crdSpecTemplate?: pulumi.Input<inputs.apiextensions.v1alpha1.InfrastructureDefinitionSpecCrdSpecTemplate>;
        }

        /**
         * CRDSpecTemplate is the base CRD template. The final CRD will have additional fields to the base template to accommodate Crossplane machinery.
         */
        export interface InfrastructureDefinitionSpecCrdSpecTemplate {
            /**
             * additionalPrinterColumns specifies additional columns returned in Table output. See https://kubernetes.io/docs/reference/using-api/api-concepts/#receiving-resources-as-tables for details. If present, this field configures columns for all versions. Top-level and per-version columns are mutually exclusive. If no top-level or per-version columns are specified, a single column displaying the age of the custom resource is used.
             */
            additionalPrinterColumns?: pulumi.Input<pulumi.Input<inputs.apiextensions.v1alpha1.InfrastructureDefinitionSpecCrdSpecTemplateAdditionalPrinterColumns>[]>;
            /**
             * group is the API group of the defined custom resource. The custom resources are served under `/apis/<group>/...`. Must match the name of the CustomResourceDefinition (in the form `<names.plural>.<group>`).
             */
            group: pulumi.Input<string>;
            /**
             * names specify the resource and kind names for the custom resource.
             */
            names: pulumi.Input<inputs.apiextensions.v1alpha1.InfrastructureDefinitionSpecCrdSpecTemplateNames>;
            /**
             * validation describes the schema used for validation and pruning of the custom resource. If present, this validation schema is used to validate all versions. Top-level and per-version schemas are mutually exclusive.
             */
            validation?: pulumi.Input<inputs.apiextensions.v1alpha1.InfrastructureDefinitionSpecCrdSpecTemplateValidation>;
            /**
             * version is the API version of the defined custom resource. The custom resources are served under `/apis/<group>/<version>/...`. Must match the name of the first item in the `versions` list if `version` and `versions` are both specified. Optional if `versions` is specified. Deprecated: use `versions` instead.
             */
            version?: pulumi.Input<string>;
        }

        /**
         * CustomResourceColumnDefinition specifies a column for server side printing.
         */
        export interface InfrastructureDefinitionSpecCrdSpecTemplateAdditionalPrinterColumns {
            /**
             * JSONPath is a simple JSON path (i.e. with array notation) which is evaluated against each custom resource to produce the value for this column.
             */
            JSONPath: pulumi.Input<string>;
            /**
             * description is a human readable description of this column.
             */
            description?: pulumi.Input<string>;
            /**
             * format is an optional OpenAPI type definition for this column. The 'name' format is applied to the primary identifier column to assist in clients identifying column is the resource name. See https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#data-types for details.
             */
            format?: pulumi.Input<string>;
            /**
             * name is a human readable name for the column.
             */
            name: pulumi.Input<string>;
            /**
             * priority is an integer defining the relative importance of this column compared to others. Lower numbers are considered higher priority. Columns that may be omitted in limited space scenarios should be given a priority greater than 0.
             */
            priority?: pulumi.Input<number>;
            /**
             * type is an OpenAPI type definition for this column. See https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#data-types for details.
             */
            type: pulumi.Input<string>;
        }

        /**
         * names specify the resource and kind names for the custom resource.
         */
        export interface InfrastructureDefinitionSpecCrdSpecTemplateNames {
            /**
             * categories is a list of grouped resources this custom resource belongs to (e.g. 'all'). This is published in API discovery documents, and used by clients to support invocations like `kubectl get all`.
             */
            categories?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * kind is the serialized kind of the resource. It is normally CamelCase and singular. Custom resource instances will use this value as the `kind` attribute in API calls.
             */
            kind: pulumi.Input<string>;
            /**
             * listKind is the serialized kind of the list for this resource. Defaults to "`kind`List".
             */
            listKind?: pulumi.Input<string>;
            /**
             * plural is the plural name of the resource to serve. The custom resources are served under `/apis/<group>/<version>/.../<plural>`. Must match the name of the CustomResourceDefinition (in the form `<names.plural>.<group>`). Must be all lowercase.
             */
            plural: pulumi.Input<string>;
            /**
             * shortNames are short names for the resource, exposed in API discovery documents, and used by clients to support invocations like `kubectl get <shortname>`. It must be all lowercase.
             */
            shortNames?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * singular is the singular name of the resource. It must be all lowercase. Defaults to lowercased `kind`.
             */
            singular?: pulumi.Input<string>;
        }

        /**
         * validation describes the schema used for validation and pruning of the custom resource. If present, this validation schema is used to validate all versions. Top-level and per-version schemas are mutually exclusive.
         */
        export interface InfrastructureDefinitionSpecCrdSpecTemplateValidation {
            /**
             * openAPIV3Schema is the OpenAPI v3 schema to use for validation and pruning.
             */
            openAPIV3Schema?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * InfrastructureDefinitionStatus shows the observed state of the definition.
         */
        export interface InfrastructureDefinitionStatus {
            /**
             * Conditions of the resource.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.apiextensions.v1alpha1.InfrastructureDefinitionStatusConditions>[]>;
        }

        /**
         * A Condition that may apply to a resource.
         */
        export interface InfrastructureDefinitionStatusConditions {
            /**
             * LastTransitionTime is the last time this condition transitioned from one status to another.
             */
            lastTransitionTime: pulumi.Input<string>;
            /**
             * A Message containing details about this condition's last transition from one status to another, if any.
             */
            message?: pulumi.Input<string>;
            /**
             * A Reason for this condition's last transition from one status to another.
             */
            reason: pulumi.Input<string>;
            /**
             * Status of this condition; is it currently True, False, or Unknown?
             */
            status: pulumi.Input<string>;
            /**
             * Type of this condition. At most one of each condition type may apply to a resource at any point in time.
             */
            type: pulumi.Input<string>;
        }

        /**
         * InfrastructurePublicationSpec specifies the desired state of the definition.
         */
        export interface InfrastructurePublicationSpec {
            /**
             * InfrastructureDefinitionReference references the InfrastructureDefinition that should be published.
             */
            infrastructureDefinitionRef: pulumi.Input<inputs.apiextensions.v1alpha1.InfrastructurePublicationSpecInfrastructureDefinitionRef>;
        }

        /**
         * InfrastructureDefinitionReference references the InfrastructureDefinition that should be published.
         */
        export interface InfrastructurePublicationSpecInfrastructureDefinitionRef {
            /**
             * Name of the referenced object.
             */
            name: pulumi.Input<string>;
        }

        /**
         * InfrastructurePublicationStatus shows the observed state of the definition.
         */
        export interface InfrastructurePublicationStatus {
            /**
             * Conditions of the resource.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.apiextensions.v1alpha1.InfrastructurePublicationStatusConditions>[]>;
        }

        /**
         * A Condition that may apply to a resource.
         */
        export interface InfrastructurePublicationStatusConditions {
            /**
             * LastTransitionTime is the last time this condition transitioned from one status to another.
             */
            lastTransitionTime: pulumi.Input<string>;
            /**
             * A Message containing details about this condition's last transition from one status to another, if any.
             */
            message?: pulumi.Input<string>;
            /**
             * A Reason for this condition's last transition from one status to another.
             */
            reason: pulumi.Input<string>;
            /**
             * Status of this condition; is it currently True, False, or Unknown?
             */
            status: pulumi.Input<string>;
            /**
             * Type of this condition. At most one of each condition type may apply to a resource at any point in time.
             */
            type: pulumi.Input<string>;
        }
    }
}

export namespace cache {
    export namespace v1alpha1 {
        /**
         * RedisClusterSpec specifies the desired state of a RedisCluster.
         */
        export interface RedisClusterSpec {
            /**
             * A ClassReference specifies a resource class that will be used to dynamically provision a managed resource when the resource claim is created.
             */
            classRef?: pulumi.Input<inputs.cache.v1alpha1.RedisClusterSpecClassRef>;
            /**
             * A ClassSelector specifies labels that will be used to select a resource class for this claim. If multiple classes match the labels one will be chosen at random.
             */
            classSelector?: pulumi.Input<inputs.cache.v1alpha1.RedisClusterSpecClassSelector>;
            /**
             * EngineVersion specifies the desired Redis version.
             */
            engineVersion?: pulumi.Input<string>;
            /**
             * A ResourceReference specifies an existing managed resource, in any namespace, to which this resource claim should attempt to bind. Omit the resource reference to enable dynamic provisioning using a resource class; the resource reference will be automatically populated by Crossplane.
             */
            resourceRef?: pulumi.Input<inputs.cache.v1alpha1.RedisClusterSpecResourceRef>;
            /**
             * WriteConnectionSecretToReference specifies the name of a Secret, in the same namespace as this resource claim, to which any connection details for this resource claim should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource bound to this resource claim.
             */
            writeConnectionSecretToRef?: pulumi.Input<inputs.cache.v1alpha1.RedisClusterSpecWriteConnectionSecretToRef>;
        }

        /**
         * A ClassReference specifies a resource class that will be used to dynamically provision a managed resource when the resource claim is created.
         */
        export interface RedisClusterSpecClassRef {
            /**
             * API version of the referent.
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: pulumi.Input<string>;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<string>;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: pulumi.Input<string>;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: pulumi.Input<string>;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: pulumi.Input<string>;
        }

        /**
         * A ClassSelector specifies labels that will be used to select a resource class for this claim. If multiple classes match the labels one will be chosen at random.
         */
        export interface RedisClusterSpecClassSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.cache.v1alpha1.RedisClusterSpecClassSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
         */
        export interface RedisClusterSpecClassSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A ResourceReference specifies an existing managed resource, in any namespace, to which this resource claim should attempt to bind. Omit the resource reference to enable dynamic provisioning using a resource class; the resource reference will be automatically populated by Crossplane.
         */
        export interface RedisClusterSpecResourceRef {
            /**
             * API version of the referent.
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: pulumi.Input<string>;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<string>;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: pulumi.Input<string>;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: pulumi.Input<string>;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: pulumi.Input<string>;
        }

        /**
         * WriteConnectionSecretToReference specifies the name of a Secret, in the same namespace as this resource claim, to which any connection details for this resource claim should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource bound to this resource claim.
         */
        export interface RedisClusterSpecWriteConnectionSecretToRef {
            /**
             * Name of the secret.
             */
            name: pulumi.Input<string>;
        }

        /**
         * A ResourceClaimStatus represents the observed status of a resource claim.
         */
        export interface RedisClusterStatus {
            /**
             * Phase represents the binding phase of a managed resource or claim. Unbindable resources cannot be bound, typically because they are currently unavailable, or still being created. Unbound resource are available for binding, and Bound resources have successfully bound to another resource.
             */
            bindingPhase?: pulumi.Input<string>;
            /**
             * Conditions of the resource.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.cache.v1alpha1.RedisClusterStatusConditions>[]>;
        }

        /**
         * A Condition that may apply to a resource.
         */
        export interface RedisClusterStatusConditions {
            /**
             * LastTransitionTime is the last time this condition transitioned from one status to another.
             */
            lastTransitionTime: pulumi.Input<string>;
            /**
             * A Message containing details about this condition's last transition from one status to another, if any.
             */
            message?: pulumi.Input<string>;
            /**
             * A Reason for this condition's last transition from one status to another.
             */
            reason: pulumi.Input<string>;
            /**
             * Status of this condition; is it currently True, False, or Unknown?
             */
            status: pulumi.Input<string>;
            /**
             * Type of this condition. At most one of each condition type may apply to a resource at any point in time.
             */
            type: pulumi.Input<string>;
        }
    }
}

export namespace compute {
    export namespace v1alpha1 {
        /**
         * KubernetesClusterSpec specifies the desired state of a KubernetesCluster.
         */
        export interface KubernetesClusterSpec {
            /**
             * A ClassReference specifies a resource class that will be used to dynamically provision a managed resource when the resource claim is created.
             */
            classRef?: pulumi.Input<inputs.compute.v1alpha1.KubernetesClusterSpecClassRef>;
            /**
             * A ClassSelector specifies labels that will be used to select a resource class for this claim. If multiple classes match the labels one will be chosen at random.
             */
            classSelector?: pulumi.Input<inputs.compute.v1alpha1.KubernetesClusterSpecClassSelector>;
            /**
             * ClusterVersion specifies the desired Kubernetes version, e.g. 1.15.
             */
            clusterVersion?: pulumi.Input<string>;
            /**
             * A ResourceReference specifies an existing managed resource, in any namespace, to which this resource claim should attempt to bind. Omit the resource reference to enable dynamic provisioning using a resource class; the resource reference will be automatically populated by Crossplane.
             */
            resourceRef?: pulumi.Input<inputs.compute.v1alpha1.KubernetesClusterSpecResourceRef>;
            /**
             * WriteConnectionSecretToReference specifies the name of a Secret, in the same namespace as this resource claim, to which any connection details for this resource claim should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource bound to this resource claim.
             */
            writeConnectionSecretToRef?: pulumi.Input<inputs.compute.v1alpha1.KubernetesClusterSpecWriteConnectionSecretToRef>;
        }

        /**
         * A ClassReference specifies a resource class that will be used to dynamically provision a managed resource when the resource claim is created.
         */
        export interface KubernetesClusterSpecClassRef {
            /**
             * API version of the referent.
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: pulumi.Input<string>;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<string>;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: pulumi.Input<string>;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: pulumi.Input<string>;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: pulumi.Input<string>;
        }

        /**
         * A ClassSelector specifies labels that will be used to select a resource class for this claim. If multiple classes match the labels one will be chosen at random.
         */
        export interface KubernetesClusterSpecClassSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.compute.v1alpha1.KubernetesClusterSpecClassSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
         */
        export interface KubernetesClusterSpecClassSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A ResourceReference specifies an existing managed resource, in any namespace, to which this resource claim should attempt to bind. Omit the resource reference to enable dynamic provisioning using a resource class; the resource reference will be automatically populated by Crossplane.
         */
        export interface KubernetesClusterSpecResourceRef {
            /**
             * API version of the referent.
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: pulumi.Input<string>;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<string>;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: pulumi.Input<string>;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: pulumi.Input<string>;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: pulumi.Input<string>;
        }

        /**
         * WriteConnectionSecretToReference specifies the name of a Secret, in the same namespace as this resource claim, to which any connection details for this resource claim should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource bound to this resource claim.
         */
        export interface KubernetesClusterSpecWriteConnectionSecretToRef {
            /**
             * Name of the secret.
             */
            name: pulumi.Input<string>;
        }

        /**
         * A ResourceClaimStatus represents the observed status of a resource claim.
         */
        export interface KubernetesClusterStatus {
            /**
             * Phase represents the binding phase of a managed resource or claim. Unbindable resources cannot be bound, typically because they are currently unavailable, or still being created. Unbound resource are available for binding, and Bound resources have successfully bound to another resource.
             */
            bindingPhase?: pulumi.Input<string>;
            /**
             * Conditions of the resource.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.compute.v1alpha1.KubernetesClusterStatusConditions>[]>;
        }

        /**
         * A Condition that may apply to a resource.
         */
        export interface KubernetesClusterStatusConditions {
            /**
             * LastTransitionTime is the last time this condition transitioned from one status to another.
             */
            lastTransitionTime: pulumi.Input<string>;
            /**
             * A Message containing details about this condition's last transition from one status to another, if any.
             */
            message?: pulumi.Input<string>;
            /**
             * A Reason for this condition's last transition from one status to another.
             */
            reason: pulumi.Input<string>;
            /**
             * Status of this condition; is it currently True, False, or Unknown?
             */
            status: pulumi.Input<string>;
            /**
             * Type of this condition. At most one of each condition type may apply to a resource at any point in time.
             */
            type: pulumi.Input<string>;
        }

        /**
         * MachineInstanceSpec specifies the desired state of a MachineInstance.
         */
        export interface MachineInstanceSpec {
            /**
             * A ClassReference specifies a resource class that will be used to dynamically provision a managed resource when the resource claim is created.
             */
            classRef?: pulumi.Input<inputs.compute.v1alpha1.MachineInstanceSpecClassRef>;
            /**
             * A ClassSelector specifies labels that will be used to select a resource class for this claim. If multiple classes match the labels one will be chosen at random.
             */
            classSelector?: pulumi.Input<inputs.compute.v1alpha1.MachineInstanceSpecClassSelector>;
            /**
             * A ResourceReference specifies an existing managed resource, in any namespace, to which this resource claim should attempt to bind. Omit the resource reference to enable dynamic provisioning using a resource class; the resource reference will be automatically populated by Crossplane.
             */
            resourceRef?: pulumi.Input<inputs.compute.v1alpha1.MachineInstanceSpecResourceRef>;
            /**
             * WriteConnectionSecretToReference specifies the name of a Secret, in the same namespace as this resource claim, to which any connection details for this resource claim should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource bound to this resource claim.
             */
            writeConnectionSecretToRef?: pulumi.Input<inputs.compute.v1alpha1.MachineInstanceSpecWriteConnectionSecretToRef>;
        }

        /**
         * A ClassReference specifies a resource class that will be used to dynamically provision a managed resource when the resource claim is created.
         */
        export interface MachineInstanceSpecClassRef {
            /**
             * API version of the referent.
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: pulumi.Input<string>;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<string>;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: pulumi.Input<string>;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: pulumi.Input<string>;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: pulumi.Input<string>;
        }

        /**
         * A ClassSelector specifies labels that will be used to select a resource class for this claim. If multiple classes match the labels one will be chosen at random.
         */
        export interface MachineInstanceSpecClassSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.compute.v1alpha1.MachineInstanceSpecClassSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
         */
        export interface MachineInstanceSpecClassSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A ResourceReference specifies an existing managed resource, in any namespace, to which this resource claim should attempt to bind. Omit the resource reference to enable dynamic provisioning using a resource class; the resource reference will be automatically populated by Crossplane.
         */
        export interface MachineInstanceSpecResourceRef {
            /**
             * API version of the referent.
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: pulumi.Input<string>;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<string>;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: pulumi.Input<string>;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: pulumi.Input<string>;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: pulumi.Input<string>;
        }

        /**
         * WriteConnectionSecretToReference specifies the name of a Secret, in the same namespace as this resource claim, to which any connection details for this resource claim should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource bound to this resource claim.
         */
        export interface MachineInstanceSpecWriteConnectionSecretToRef {
            /**
             * Name of the secret.
             */
            name: pulumi.Input<string>;
        }

        /**
         * A ResourceClaimStatus represents the observed status of a resource claim.
         */
        export interface MachineInstanceStatus {
            /**
             * Phase represents the binding phase of a managed resource or claim. Unbindable resources cannot be bound, typically because they are currently unavailable, or still being created. Unbound resource are available for binding, and Bound resources have successfully bound to another resource.
             */
            bindingPhase?: pulumi.Input<string>;
            /**
             * Conditions of the resource.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.compute.v1alpha1.MachineInstanceStatusConditions>[]>;
        }

        /**
         * A Condition that may apply to a resource.
         */
        export interface MachineInstanceStatusConditions {
            /**
             * LastTransitionTime is the last time this condition transitioned from one status to another.
             */
            lastTransitionTime: pulumi.Input<string>;
            /**
             * A Message containing details about this condition's last transition from one status to another, if any.
             */
            message?: pulumi.Input<string>;
            /**
             * A Reason for this condition's last transition from one status to another.
             */
            reason: pulumi.Input<string>;
            /**
             * Status of this condition; is it currently True, False, or Unknown?
             */
            status: pulumi.Input<string>;
            /**
             * Type of this condition. At most one of each condition type may apply to a resource at any point in time.
             */
            type: pulumi.Input<string>;
        }
    }
}

export namespace core {
    export namespace v1alpha2 {
        /**
         * An ApplicationConfigurationSpec defines the desired state of a ApplicationConfiguration.
         */
        export interface ApplicationConfigurationSpec {
            /**
             * Components of which this ApplicationConfiguration consists. Each component will be used to instantiate a workload.
             */
            components: pulumi.Input<pulumi.Input<inputs.core.v1alpha2.ApplicationConfigurationSpecComponents>[]>;
        }

        /**
         * An ApplicationConfigurationComponent specifies a component of an ApplicationConfiguration. Each component is used to instantiate a workload.
         */
        export interface ApplicationConfigurationSpecComponents {
            /**
             * ComponentName specifies a component of which an ApplicationConfiguration should consist. The named component must exist.
             */
            componentName: pulumi.Input<string>;
            /**
             * ParameterValues specify values for the the specified component's parameters. Any parameter required by the component must be specified.
             */
            parameterValues?: pulumi.Input<pulumi.Input<inputs.core.v1alpha2.ApplicationConfigurationSpecComponentsParameterValues>[]>;
            /**
             * Scopes in which the specified component should exist.
             */
            scopes?: pulumi.Input<pulumi.Input<inputs.core.v1alpha2.ApplicationConfigurationSpecComponentsScopes>[]>;
            /**
             * Traits of the specified component.
             */
            traits?: pulumi.Input<pulumi.Input<inputs.core.v1alpha2.ApplicationConfigurationSpecComponentsTraits>[]>;
        }

        /**
         * A ComponentParameterValue specifies a value for a named parameter. The associated component must publish a parameter with this name.
         */
        export interface ApplicationConfigurationSpecComponentsParameterValues {
            /**
             * Name of the component parameter to set.
             */
            name: pulumi.Input<string>;
            /**
             * Value to set.
             */
            value: pulumi.Input<inputs.core.v1alpha2.ApplicationConfigurationSpecComponentsParameterValuesValue>;
        }

        export interface ApplicationConfigurationSpecComponentsParameterValuesValue {
        }

        /**
         * A ComponentScope specifies a scope in which a component should exist.
         */
        export interface ApplicationConfigurationSpecComponentsScopes {
            /**
             * A ScopeReference must refer to an OAM scope resource.
             */
            scopeRef: pulumi.Input<inputs.core.v1alpha2.ApplicationConfigurationSpecComponentsScopesScopeRef>;
        }

        /**
         * A ScopeReference must refer to an OAM scope resource.
         */
        export interface ApplicationConfigurationSpecComponentsScopesScopeRef {
            /**
             * APIVersion of the referenced object.
             */
            apiVersion: pulumi.Input<string>;
            /**
             * Kind of the referenced object.
             */
            kind: pulumi.Input<string>;
            /**
             * Name of the referenced object.
             */
            name: pulumi.Input<string>;
            /**
             * UID of the referenced object.
             */
            uid?: pulumi.Input<string>;
        }

        /**
         * A ComponentTrait specifies a trait that should be applied to a component.
         */
        export interface ApplicationConfigurationSpecComponentsTraits {
            /**
             * A Trait that will be created for the component
             */
            trait: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * An ApplicationConfigurationStatus represents the observed state of a ApplicationConfiguration.
         */
        export interface ApplicationConfigurationStatus {
            /**
             * Conditions of the resource.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.core.v1alpha2.ApplicationConfigurationStatusConditions>[]>;
            /**
             * Workloads created by this ApplicationConfiguration.
             */
            workloads?: pulumi.Input<pulumi.Input<inputs.core.v1alpha2.ApplicationConfigurationStatusWorkloads>[]>;
        }

        /**
         * A Condition that may apply to a resource.
         */
        export interface ApplicationConfigurationStatusConditions {
            /**
             * LastTransitionTime is the last time this condition transitioned from one status to another.
             */
            lastTransitionTime: pulumi.Input<string>;
            /**
             * A Message containing details about this condition's last transition from one status to another, if any.
             */
            message?: pulumi.Input<string>;
            /**
             * A Reason for this condition's last transition from one status to another.
             */
            reason: pulumi.Input<string>;
            /**
             * Status of this condition; is it currently True, False, or Unknown?
             */
            status: pulumi.Input<string>;
            /**
             * Type of this condition. At most one of each condition type may apply to a resource at any point in time.
             */
            type: pulumi.Input<string>;
        }

        /**
         * A WorkloadStatus represents the status of a workload.
         */
        export interface ApplicationConfigurationStatusWorkloads {
            /**
             * ComponentName that produced this workload.
             */
            componentName?: pulumi.Input<string>;
            /**
             * Traits associated with this workload.
             */
            traits?: pulumi.Input<pulumi.Input<inputs.core.v1alpha2.ApplicationConfigurationStatusWorkloadsTraits>[]>;
            /**
             * Reference to a workload created by an ApplicationConfiguration.
             */
            workloadRef?: pulumi.Input<inputs.core.v1alpha2.ApplicationConfigurationStatusWorkloadsWorkloadRef>;
        }

        /**
         * A WorkloadTrait represents a trait associated with a workload.
         */
        export interface ApplicationConfigurationStatusWorkloadsTraits {
            /**
             * Reference to a trait created by an ApplicationConfiguration.
             */
            traitRef: pulumi.Input<inputs.core.v1alpha2.ApplicationConfigurationStatusWorkloadsTraitsTraitRef>;
        }

        /**
         * Reference to a trait created by an ApplicationConfiguration.
         */
        export interface ApplicationConfigurationStatusWorkloadsTraitsTraitRef {
            /**
             * APIVersion of the referenced object.
             */
            apiVersion: pulumi.Input<string>;
            /**
             * Kind of the referenced object.
             */
            kind: pulumi.Input<string>;
            /**
             * Name of the referenced object.
             */
            name: pulumi.Input<string>;
            /**
             * UID of the referenced object.
             */
            uid?: pulumi.Input<string>;
        }

        /**
         * Reference to a workload created by an ApplicationConfiguration.
         */
        export interface ApplicationConfigurationStatusWorkloadsWorkloadRef {
            /**
             * APIVersion of the referenced object.
             */
            apiVersion: pulumi.Input<string>;
            /**
             * Kind of the referenced object.
             */
            kind: pulumi.Input<string>;
            /**
             * Name of the referenced object.
             */
            name: pulumi.Input<string>;
            /**
             * UID of the referenced object.
             */
            uid?: pulumi.Input<string>;
        }

        /**
         * A ComponentSpec defines the desired state of a Component.
         */
        export interface ComponentSpec {
            /**
             * Parameters exposed by this component. ApplicationConfigurations that reference this component may specify values for these parameters, which will in turn be injected into the embedded workload.
             */
            parameters?: pulumi.Input<pulumi.Input<inputs.core.v1alpha2.ComponentSpecParameters>[]>;
            /**
             * A Workload that will be created for each ApplicationConfiguration that includes this Component. Workloads must be defined by a WorkloadDefinition.
             */
            workload: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * A ComponentParameter defines a configurable parameter of a component.
         */
        export interface ComponentSpecParameters {
            /**
             * Description of this parameter.
             */
            description?: pulumi.Input<string>;
            /**
             * FieldPaths specifies an array of fields within this Component's workload that will be overwritten by the value of this parameter. The type of the parameter (e.g. int, string) is inferred from the type of these fields; All fields must be of the same type. Fields are specified as JSON field paths without a leading dot, for example 'spec.replicas'.
             */
            fieldPaths: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Name of this parameter. OAM ApplicationConfigurations will specify parameter values using this name.
             */
            name: pulumi.Input<string>;
            /**
             * Required specifies whether or not a value for this parameter must be supplied when authoring an ApplicationConfiguration.
             */
            required?: pulumi.Input<boolean>;
        }

        /**
         * A ComponentStatus represents the observed state of a Component.
         */
        export interface ComponentStatus {
            /**
             * Conditions of the resource.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.core.v1alpha2.ComponentStatusConditions>[]>;
        }

        /**
         * A Condition that may apply to a resource.
         */
        export interface ComponentStatusConditions {
            /**
             * LastTransitionTime is the last time this condition transitioned from one status to another.
             */
            lastTransitionTime: pulumi.Input<string>;
            /**
             * A Message containing details about this condition's last transition from one status to another, if any.
             */
            message?: pulumi.Input<string>;
            /**
             * A Reason for this condition's last transition from one status to another.
             */
            reason: pulumi.Input<string>;
            /**
             * Status of this condition; is it currently True, False, or Unknown?
             */
            status: pulumi.Input<string>;
            /**
             * Type of this condition. At most one of each condition type may apply to a resource at any point in time.
             */
            type: pulumi.Input<string>;
        }

        /**
         * A ContainerizedWorkloadSpec defines the desired state of a ContainerizedWorkload.
         */
        export interface ContainerizedWorkloadSpec {
            /**
             * CPUArchitecture required by this workload.
             */
            arch?: pulumi.Input<string>;
            /**
             * Containers of which this workload consists.
             */
            containers: pulumi.Input<pulumi.Input<inputs.core.v1alpha2.ContainerizedWorkloadSpecContainers>[]>;
            /**
             * OperatingSystem required by this workload.
             */
            osType?: pulumi.Input<string>;
        }

        /**
         * A Container represents an Open Containers Initiative (OCI) container.
         */
        export interface ContainerizedWorkloadSpecContainers {
            /**
             * Arguments to be passed to the command run by this container.
             */
            args?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Command to be run by this container.
             */
            command?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ConfigFiles that should be written within this container.
             */
            config?: pulumi.Input<pulumi.Input<inputs.core.v1alpha2.ContainerizedWorkloadSpecContainersConfig>[]>;
            /**
             * Environment variables that should be set within this container.
             */
            env?: pulumi.Input<pulumi.Input<inputs.core.v1alpha2.ContainerizedWorkloadSpecContainersEnv>[]>;
            /**
             * Image this container should run. Must be a path-like or URI-like representation of an OCI image. May be prefixed with a registry address and should be suffixed with a tag.
             */
            image: pulumi.Input<string>;
            /**
             * ImagePullSecret specifies the name of a Secret from which the credentials required to pull this container's image can be loaded.
             */
            imagePullSecret?: pulumi.Input<string>;
            /**
             * A LivenessProbe assesses whether this container is alive. Containers that fail liveness probes will be restarted.
             */
            livenessProbe?: pulumi.Input<inputs.core.v1alpha2.ContainerizedWorkloadSpecContainersLivenessProbe>;
            /**
             * Name of this container. Must be unique within its workload.
             */
            name: pulumi.Input<string>;
            /**
             * Ports exposed by this container.
             */
            ports?: pulumi.Input<pulumi.Input<inputs.core.v1alpha2.ContainerizedWorkloadSpecContainersPorts>[]>;
            /**
             * A ReadinessProbe assesses whether this container is ready to serve requests. Containers that fail readiness probes will be withdrawn from service.
             */
            readinessProbe?: pulumi.Input<inputs.core.v1alpha2.ContainerizedWorkloadSpecContainersReadinessProbe>;
            /**
             * Resources required by this container
             */
            resources?: pulumi.Input<inputs.core.v1alpha2.ContainerizedWorkloadSpecContainersResources>;
        }

        /**
         * A ContainerConfigFile specifies a configuration file that should be written within a container.
         */
        export interface ContainerizedWorkloadSpecContainersConfig {
            /**
             * FromSecret is a secret key reference which can be used to assign a value to be written to the configuration file at the given path in the container.
             */
            fromSecret?: pulumi.Input<inputs.core.v1alpha2.ContainerizedWorkloadSpecContainersConfigFromSecret>;
            /**
             * Path within the container at which the configuration file should be written.
             */
            path: pulumi.Input<string>;
            /**
             * Value that should be written to the configuration file.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * FromSecret is a secret key reference which can be used to assign a value to be written to the configuration file at the given path in the container.
         */
        export interface ContainerizedWorkloadSpecContainersConfigFromSecret {
            /**
             * The key to select.
             */
            key: pulumi.Input<string>;
            /**
             * The name of the secret.
             */
            name: pulumi.Input<string>;
        }

        /**
         * A ContainerEnvVar specifies an environment variable that should be set within a container.
         */
        export interface ContainerizedWorkloadSpecContainersEnv {
            /**
             * FromSecret is a secret key reference which can be used to assign a value to the environment variable.
             */
            fromSecret?: pulumi.Input<inputs.core.v1alpha2.ContainerizedWorkloadSpecContainersEnvFromSecret>;
            /**
             * Name of the environment variable. Must be composed of valid Unicode letter and number characters, as well as _ and -.
             */
            name: pulumi.Input<string>;
            /**
             * Value of the environment variable.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * FromSecret is a secret key reference which can be used to assign a value to the environment variable.
         */
        export interface ContainerizedWorkloadSpecContainersEnvFromSecret {
            /**
             * The key to select.
             */
            key: pulumi.Input<string>;
            /**
             * The name of the secret.
             */
            name: pulumi.Input<string>;
        }

        /**
         * A LivenessProbe assesses whether this container is alive. Containers that fail liveness probes will be restarted.
         */
        export interface ContainerizedWorkloadSpecContainersLivenessProbe {
            /**
             * Exec probes a container's health by executing a command.
             */
            exec?: pulumi.Input<inputs.core.v1alpha2.ContainerizedWorkloadSpecContainersLivenessProbeExec>;
            /**
             * FailureThreshold specifies how many consecutive probes must fail in order for the container to be considered healthy.
             */
            failureThreshold?: pulumi.Input<number>;
            /**
             * HTTPGet probes a container's health by sending an HTTP GET request.
             */
            httpGet?: pulumi.Input<inputs.core.v1alpha2.ContainerizedWorkloadSpecContainersLivenessProbeHttpGet>;
            /**
             * InitialDelaySeconds after a container starts before the first probe.
             */
            initialDelaySeconds?: pulumi.Input<number>;
            /**
             * PeriodSeconds between probes.
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * SuccessThreshold specifies how many consecutive probes must success in order for the container to be considered healthy.
             */
            successThreshold?: pulumi.Input<number>;
            /**
             * TCPSocketProbe probes a container's health by connecting to a TCP socket.
             */
            tcpSocket?: pulumi.Input<inputs.core.v1alpha2.ContainerizedWorkloadSpecContainersLivenessProbeTcpSocket>;
            /**
             * TimeoutSeconds after which the probe times out.
             */
            timeoutSeconds?: pulumi.Input<number>;
        }

        /**
         * Exec probes a container's health by executing a command.
         */
        export interface ContainerizedWorkloadSpecContainersLivenessProbeExec {
            /**
             * Command to be run by this probe.
             */
            command: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * HTTPGet probes a container's health by sending an HTTP GET request.
         */
        export interface ContainerizedWorkloadSpecContainersLivenessProbeHttpGet {
            /**
             * HTTPHeaders to send with the GET request.
             */
            httpHeaders?: pulumi.Input<pulumi.Input<inputs.core.v1alpha2.ContainerizedWorkloadSpecContainersLivenessProbeHttpGetHttpHeaders>[]>;
            /**
             * Path to probe, e.g. '/healthz'.
             */
            path: pulumi.Input<string>;
            /**
             * Port to probe.
             */
            port: pulumi.Input<number>;
        }

        /**
         * A HTTPHeader to be passed when probing a container.
         */
        export interface ContainerizedWorkloadSpecContainersLivenessProbeHttpGetHttpHeaders {
            /**
             * Name of this HTTP header. Must be unique per probe.
             */
            name: pulumi.Input<string>;
            /**
             * Value of this HTTP header.
             */
            value: pulumi.Input<string>;
        }

        /**
         * TCPSocketProbe probes a container's health by connecting to a TCP socket.
         */
        export interface ContainerizedWorkloadSpecContainersLivenessProbeTcpSocket {
            /**
             * Port this probe should connect to.
             */
            port: pulumi.Input<number>;
        }

        /**
         * A ContainerPort specifies a port that is exposed by a container.
         */
        export interface ContainerizedWorkloadSpecContainersPorts {
            /**
             * Port number. Must be unique within its container.
             */
            containerPort: pulumi.Input<number>;
            /**
             * Name of this port. Must be unique within its container. Must be lowercase alphabetical characters.
             */
            name: pulumi.Input<string>;
            /**
             * Protocol used by the server listening on this port.
             */
            protocol?: pulumi.Input<string>;
        }

        /**
         * A ReadinessProbe assesses whether this container is ready to serve requests. Containers that fail readiness probes will be withdrawn from service.
         */
        export interface ContainerizedWorkloadSpecContainersReadinessProbe {
            /**
             * Exec probes a container's health by executing a command.
             */
            exec?: pulumi.Input<inputs.core.v1alpha2.ContainerizedWorkloadSpecContainersReadinessProbeExec>;
            /**
             * FailureThreshold specifies how many consecutive probes must fail in order for the container to be considered healthy.
             */
            failureThreshold?: pulumi.Input<number>;
            /**
             * HTTPGet probes a container's health by sending an HTTP GET request.
             */
            httpGet?: pulumi.Input<inputs.core.v1alpha2.ContainerizedWorkloadSpecContainersReadinessProbeHttpGet>;
            /**
             * InitialDelaySeconds after a container starts before the first probe.
             */
            initialDelaySeconds?: pulumi.Input<number>;
            /**
             * PeriodSeconds between probes.
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * SuccessThreshold specifies how many consecutive probes must success in order for the container to be considered healthy.
             */
            successThreshold?: pulumi.Input<number>;
            /**
             * TCPSocketProbe probes a container's health by connecting to a TCP socket.
             */
            tcpSocket?: pulumi.Input<inputs.core.v1alpha2.ContainerizedWorkloadSpecContainersReadinessProbeTcpSocket>;
            /**
             * TimeoutSeconds after which the probe times out.
             */
            timeoutSeconds?: pulumi.Input<number>;
        }

        /**
         * Exec probes a container's health by executing a command.
         */
        export interface ContainerizedWorkloadSpecContainersReadinessProbeExec {
            /**
             * Command to be run by this probe.
             */
            command: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * HTTPGet probes a container's health by sending an HTTP GET request.
         */
        export interface ContainerizedWorkloadSpecContainersReadinessProbeHttpGet {
            /**
             * HTTPHeaders to send with the GET request.
             */
            httpHeaders?: pulumi.Input<pulumi.Input<inputs.core.v1alpha2.ContainerizedWorkloadSpecContainersReadinessProbeHttpGetHttpHeaders>[]>;
            /**
             * Path to probe, e.g. '/healthz'.
             */
            path: pulumi.Input<string>;
            /**
             * Port to probe.
             */
            port: pulumi.Input<number>;
        }

        /**
         * A HTTPHeader to be passed when probing a container.
         */
        export interface ContainerizedWorkloadSpecContainersReadinessProbeHttpGetHttpHeaders {
            /**
             * Name of this HTTP header. Must be unique per probe.
             */
            name: pulumi.Input<string>;
            /**
             * Value of this HTTP header.
             */
            value: pulumi.Input<string>;
        }

        /**
         * TCPSocketProbe probes a container's health by connecting to a TCP socket.
         */
        export interface ContainerizedWorkloadSpecContainersReadinessProbeTcpSocket {
            /**
             * Port this probe should connect to.
             */
            port: pulumi.Input<number>;
        }

        /**
         * Resources required by this container
         */
        export interface ContainerizedWorkloadSpecContainersResources {
            /**
             * CPU required by this container.
             */
            cpu: pulumi.Input<inputs.core.v1alpha2.ContainerizedWorkloadSpecContainersResourcesCpu>;
            /**
             * Extended resources required by this container.
             */
            extended?: pulumi.Input<pulumi.Input<inputs.core.v1alpha2.ContainerizedWorkloadSpecContainersResourcesExtended>[]>;
            /**
             * GPU required by this container.
             */
            gpu?: pulumi.Input<inputs.core.v1alpha2.ContainerizedWorkloadSpecContainersResourcesGpu>;
            /**
             * Memory required by this container.
             */
            memory: pulumi.Input<inputs.core.v1alpha2.ContainerizedWorkloadSpecContainersResourcesMemory>;
            /**
             * Volumes required by this container.
             */
            volumes?: pulumi.Input<pulumi.Input<inputs.core.v1alpha2.ContainerizedWorkloadSpecContainersResourcesVolumes>[]>;
        }

        /**
         * CPU required by this container.
         */
        export interface ContainerizedWorkloadSpecContainersResourcesCpu {
            /**
             * Required CPU count. 1.0 represents one CPU core.
             */
            required: pulumi.Input<string>;
        }

        /**
         * ExtendedResource required by a container.
         */
        export interface ContainerizedWorkloadSpecContainersResourcesExtended {
            /**
             * Name of the external resource. Resource names are specified in kind.group/version format, e.g. motionsensor.ext.example.com/v1.
             */
            name: pulumi.Input<string>;
            /**
             * Required extended resource(s), e.g. 8 or "very-cool-widget"
             */
            required: pulumi.Input<inputs.core.v1alpha2.ContainerizedWorkloadSpecContainersResourcesExtendedRequired>;
        }

        export interface ContainerizedWorkloadSpecContainersResourcesExtendedRequired {
        }

        /**
         * GPU required by this container.
         */
        export interface ContainerizedWorkloadSpecContainersResourcesGpu {
            /**
             * Required GPU count.
             */
            required: pulumi.Input<string>;
        }

        /**
         * Memory required by this container.
         */
        export interface ContainerizedWorkloadSpecContainersResourcesMemory {
            /**
             * Required memory.
             */
            required: pulumi.Input<string>;
        }

        /**
         * VolumeResource required by a container.
         */
        export interface ContainerizedWorkloadSpecContainersResourcesVolumes {
            /**
             * AccessMode of this volume; RO (read only) or RW (read and write).
             */
            accessMode?: pulumi.Input<string>;
            /**
             * Disk requirements of this volume.
             */
            disk?: pulumi.Input<inputs.core.v1alpha2.ContainerizedWorkloadSpecContainersResourcesVolumesDisk>;
            /**
             * MouthPath at which this volume will be mounted within its container.
             */
            mountPath: pulumi.Input<string>;
            /**
             * Name of this volume. Must be unique within its container.
             */
            name: pulumi.Input<string>;
            /**
             * SharingPolicy of this volume; Exclusive or Shared.
             */
            sharingPolicy?: pulumi.Input<string>;
        }

        /**
         * Disk requirements of this volume.
         */
        export interface ContainerizedWorkloadSpecContainersResourcesVolumesDisk {
            /**
             * Ephemeral specifies whether an external disk needs to be mounted.
             */
            ephemeral?: pulumi.Input<boolean>;
            /**
             * Required disk space.
             */
            required: pulumi.Input<string>;
        }

        /**
         * A ContainerizedWorkloadStatus represents the observed state of a ContainerizedWorkload.
         */
        export interface ContainerizedWorkloadStatus {
            /**
             * Conditions of the resource.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.core.v1alpha2.ContainerizedWorkloadStatusConditions>[]>;
            /**
             * Resources managed by this containerised workload.
             */
            resources?: pulumi.Input<pulumi.Input<inputs.core.v1alpha2.ContainerizedWorkloadStatusResources>[]>;
        }

        /**
         * A Condition that may apply to a resource.
         */
        export interface ContainerizedWorkloadStatusConditions {
            /**
             * LastTransitionTime is the last time this condition transitioned from one status to another.
             */
            lastTransitionTime: pulumi.Input<string>;
            /**
             * A Message containing details about this condition's last transition from one status to another, if any.
             */
            message?: pulumi.Input<string>;
            /**
             * A Reason for this condition's last transition from one status to another.
             */
            reason: pulumi.Input<string>;
            /**
             * Status of this condition; is it currently True, False, or Unknown?
             */
            status: pulumi.Input<string>;
            /**
             * Type of this condition. At most one of each condition type may apply to a resource at any point in time.
             */
            type: pulumi.Input<string>;
        }

        /**
         * A TypedReference refers to an object by Name, Kind, and APIVersion. It is commonly used to reference cluster-scoped objects or objects where the namespace is already known.
         */
        export interface ContainerizedWorkloadStatusResources {
            /**
             * APIVersion of the referenced object.
             */
            apiVersion: pulumi.Input<string>;
            /**
             * Kind of the referenced object.
             */
            kind: pulumi.Input<string>;
            /**
             * Name of the referenced object.
             */
            name: pulumi.Input<string>;
            /**
             * UID of the referenced object.
             */
            uid?: pulumi.Input<string>;
        }

        /**
         * A ManualScalerTraitSpec defines the desired state of a ManualScalerTrait.
         */
        export interface ManualScalerTraitSpec {
            /**
             * ReplicaCount of the workload this trait applies to.
             */
            replicaCount: pulumi.Input<number>;
            /**
             * WorkloadReference to the workload this trait applies to.
             */
            workloadRef: pulumi.Input<inputs.core.v1alpha2.ManualScalerTraitSpecWorkloadRef>;
        }

        /**
         * WorkloadReference to the workload this trait applies to.
         */
        export interface ManualScalerTraitSpecWorkloadRef {
            /**
             * APIVersion of the referenced object.
             */
            apiVersion: pulumi.Input<string>;
            /**
             * Kind of the referenced object.
             */
            kind: pulumi.Input<string>;
            /**
             * Name of the referenced object.
             */
            name: pulumi.Input<string>;
            /**
             * UID of the referenced object.
             */
            uid?: pulumi.Input<string>;
        }

        /**
         * A ManualScalerTraitStatus represents the observed state of a ManualScalerTrait.
         */
        export interface ManualScalerTraitStatus {
            /**
             * Conditions of the resource.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.core.v1alpha2.ManualScalerTraitStatusConditions>[]>;
        }

        /**
         * A Condition that may apply to a resource.
         */
        export interface ManualScalerTraitStatusConditions {
            /**
             * LastTransitionTime is the last time this condition transitioned from one status to another.
             */
            lastTransitionTime: pulumi.Input<string>;
            /**
             * A Message containing details about this condition's last transition from one status to another, if any.
             */
            message?: pulumi.Input<string>;
            /**
             * A Reason for this condition's last transition from one status to another.
             */
            reason: pulumi.Input<string>;
            /**
             * Status of this condition; is it currently True, False, or Unknown?
             */
            status: pulumi.Input<string>;
            /**
             * Type of this condition. At most one of each condition type may apply to a resource at any point in time.
             */
            type: pulumi.Input<string>;
        }

        /**
         * A ScopeDefinitionSpec defines the desired state of a ScopeDefinition.
         */
        export interface ScopeDefinitionSpec {
            /**
             * AllowComponentOverlap specifies whether an OAM component may exist in multiple instances of this kind of scope.
             */
            allowComponentOverlap: pulumi.Input<boolean>;
            /**
             * Reference to the CustomResourceDefinition that defines this scope kind.
             */
            definitionRef: pulumi.Input<inputs.core.v1alpha2.ScopeDefinitionSpecDefinitionRef>;
        }

        /**
         * Reference to the CustomResourceDefinition that defines this scope kind.
         */
        export interface ScopeDefinitionSpecDefinitionRef {
            /**
             * Name of the referenced CustomResourceDefinition.
             */
            name: pulumi.Input<string>;
        }

        /**
         * A TraitDefinitionSpec defines the desired state of a TraitDefinition.
         */
        export interface TraitDefinitionSpec {
            /**
             * AppliesToWorkloads specifies the list of workload kinds this trait applies to. Workload kinds are specified in kind.group/version format, e.g. server.core.oam.dev/v1alpha2. Traits that omit this field apply to all workload kinds.
             */
            appliesToWorkloads?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Reference to the CustomResourceDefinition that defines this trait kind.
             */
            definitionRef: pulumi.Input<inputs.core.v1alpha2.TraitDefinitionSpecDefinitionRef>;
        }

        /**
         * Reference to the CustomResourceDefinition that defines this trait kind.
         */
        export interface TraitDefinitionSpecDefinitionRef {
            /**
             * Name of the referenced CustomResourceDefinition.
             */
            name: pulumi.Input<string>;
        }

        /**
         * A WorkloadDefinitionSpec defines the desired state of a WorkloadDefinition.
         */
        export interface WorkloadDefinitionSpec {
            /**
             * Reference to the CustomResourceDefinition that defines this workload kind.
             */
            definitionRef: pulumi.Input<inputs.core.v1alpha2.WorkloadDefinitionSpecDefinitionRef>;
        }

        /**
         * Reference to the CustomResourceDefinition that defines this workload kind.
         */
        export interface WorkloadDefinitionSpecDefinitionRef {
            /**
             * Name of the referenced CustomResourceDefinition.
             */
            name: pulumi.Input<string>;
        }
    }
}

export namespace database {
    export namespace v1alpha1 {
        /**
         * MySQLInstanceSpec specifies the desired state of a MySQLInstance.
         */
        export interface MySQLInstanceSpec {
            /**
             * A ClassReference specifies a resource class that will be used to dynamically provision a managed resource when the resource claim is created.
             */
            classRef?: pulumi.Input<inputs.database.v1alpha1.MySQLInstanceSpecClassRef>;
            /**
             * A ClassSelector specifies labels that will be used to select a resource class for this claim. If multiple classes match the labels one will be chosen at random.
             */
            classSelector?: pulumi.Input<inputs.database.v1alpha1.MySQLInstanceSpecClassSelector>;
            /**
             * EngineVersion specifies the desired MySQL engine version, e.g. 5.7.
             */
            engineVersion?: pulumi.Input<string>;
            /**
             * A ResourceReference specifies an existing managed resource, in any namespace, to which this resource claim should attempt to bind. Omit the resource reference to enable dynamic provisioning using a resource class; the resource reference will be automatically populated by Crossplane.
             */
            resourceRef?: pulumi.Input<inputs.database.v1alpha1.MySQLInstanceSpecResourceRef>;
            /**
             * WriteConnectionSecretToReference specifies the name of a Secret, in the same namespace as this resource claim, to which any connection details for this resource claim should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource bound to this resource claim.
             */
            writeConnectionSecretToRef?: pulumi.Input<inputs.database.v1alpha1.MySQLInstanceSpecWriteConnectionSecretToRef>;
        }

        /**
         * A ClassReference specifies a resource class that will be used to dynamically provision a managed resource when the resource claim is created.
         */
        export interface MySQLInstanceSpecClassRef {
            /**
             * API version of the referent.
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: pulumi.Input<string>;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<string>;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: pulumi.Input<string>;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: pulumi.Input<string>;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: pulumi.Input<string>;
        }

        /**
         * A ClassSelector specifies labels that will be used to select a resource class for this claim. If multiple classes match the labels one will be chosen at random.
         */
        export interface MySQLInstanceSpecClassSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.database.v1alpha1.MySQLInstanceSpecClassSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
         */
        export interface MySQLInstanceSpecClassSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A ResourceReference specifies an existing managed resource, in any namespace, to which this resource claim should attempt to bind. Omit the resource reference to enable dynamic provisioning using a resource class; the resource reference will be automatically populated by Crossplane.
         */
        export interface MySQLInstanceSpecResourceRef {
            /**
             * API version of the referent.
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: pulumi.Input<string>;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<string>;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: pulumi.Input<string>;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: pulumi.Input<string>;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: pulumi.Input<string>;
        }

        /**
         * WriteConnectionSecretToReference specifies the name of a Secret, in the same namespace as this resource claim, to which any connection details for this resource claim should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource bound to this resource claim.
         */
        export interface MySQLInstanceSpecWriteConnectionSecretToRef {
            /**
             * Name of the secret.
             */
            name: pulumi.Input<string>;
        }

        /**
         * A ResourceClaimStatus represents the observed status of a resource claim.
         */
        export interface MySQLInstanceStatus {
            /**
             * Phase represents the binding phase of a managed resource or claim. Unbindable resources cannot be bound, typically because they are currently unavailable, or still being created. Unbound resource are available for binding, and Bound resources have successfully bound to another resource.
             */
            bindingPhase?: pulumi.Input<string>;
            /**
             * Conditions of the resource.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.database.v1alpha1.MySQLInstanceStatusConditions>[]>;
        }

        /**
         * A Condition that may apply to a resource.
         */
        export interface MySQLInstanceStatusConditions {
            /**
             * LastTransitionTime is the last time this condition transitioned from one status to another.
             */
            lastTransitionTime: pulumi.Input<string>;
            /**
             * A Message containing details about this condition's last transition from one status to another, if any.
             */
            message?: pulumi.Input<string>;
            /**
             * A Reason for this condition's last transition from one status to another.
             */
            reason: pulumi.Input<string>;
            /**
             * Status of this condition; is it currently True, False, or Unknown?
             */
            status: pulumi.Input<string>;
            /**
             * Type of this condition. At most one of each condition type may apply to a resource at any point in time.
             */
            type: pulumi.Input<string>;
        }

        /**
         * NoSQLInstanceSpec specifies the desired state of a NoSQLInstance.
         */
        export interface NoSQLInstanceSpec {
            /**
             * A ClassReference specifies a resource class that will be used to dynamically provision a managed resource when the resource claim is created.
             */
            classRef?: pulumi.Input<inputs.database.v1alpha1.NoSQLInstanceSpecClassRef>;
            /**
             * A ClassSelector specifies labels that will be used to select a resource class for this claim. If multiple classes match the labels one will be chosen at random.
             */
            classSelector?: pulumi.Input<inputs.database.v1alpha1.NoSQLInstanceSpecClassSelector>;
            /**
             * A ResourceReference specifies an existing managed resource, in any namespace, to which this resource claim should attempt to bind. Omit the resource reference to enable dynamic provisioning using a resource class; the resource reference will be automatically populated by Crossplane.
             */
            resourceRef?: pulumi.Input<inputs.database.v1alpha1.NoSQLInstanceSpecResourceRef>;
            /**
             * WriteConnectionSecretToReference specifies the name of a Secret, in the same namespace as this resource claim, to which any connection details for this resource claim should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource bound to this resource claim.
             */
            writeConnectionSecretToRef?: pulumi.Input<inputs.database.v1alpha1.NoSQLInstanceSpecWriteConnectionSecretToRef>;
        }

        /**
         * A ClassReference specifies a resource class that will be used to dynamically provision a managed resource when the resource claim is created.
         */
        export interface NoSQLInstanceSpecClassRef {
            /**
             * API version of the referent.
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: pulumi.Input<string>;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<string>;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: pulumi.Input<string>;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: pulumi.Input<string>;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: pulumi.Input<string>;
        }

        /**
         * A ClassSelector specifies labels that will be used to select a resource class for this claim. If multiple classes match the labels one will be chosen at random.
         */
        export interface NoSQLInstanceSpecClassSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.database.v1alpha1.NoSQLInstanceSpecClassSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
         */
        export interface NoSQLInstanceSpecClassSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A ResourceReference specifies an existing managed resource, in any namespace, to which this resource claim should attempt to bind. Omit the resource reference to enable dynamic provisioning using a resource class; the resource reference will be automatically populated by Crossplane.
         */
        export interface NoSQLInstanceSpecResourceRef {
            /**
             * API version of the referent.
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: pulumi.Input<string>;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<string>;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: pulumi.Input<string>;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: pulumi.Input<string>;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: pulumi.Input<string>;
        }

        /**
         * WriteConnectionSecretToReference specifies the name of a Secret, in the same namespace as this resource claim, to which any connection details for this resource claim should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource bound to this resource claim.
         */
        export interface NoSQLInstanceSpecWriteConnectionSecretToRef {
            /**
             * Name of the secret.
             */
            name: pulumi.Input<string>;
        }

        /**
         * A ResourceClaimStatus represents the observed status of a resource claim.
         */
        export interface NoSQLInstanceStatus {
            /**
             * Phase represents the binding phase of a managed resource or claim. Unbindable resources cannot be bound, typically because they are currently unavailable, or still being created. Unbound resource are available for binding, and Bound resources have successfully bound to another resource.
             */
            bindingPhase?: pulumi.Input<string>;
            /**
             * Conditions of the resource.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.database.v1alpha1.NoSQLInstanceStatusConditions>[]>;
        }

        /**
         * A Condition that may apply to a resource.
         */
        export interface NoSQLInstanceStatusConditions {
            /**
             * LastTransitionTime is the last time this condition transitioned from one status to another.
             */
            lastTransitionTime: pulumi.Input<string>;
            /**
             * A Message containing details about this condition's last transition from one status to another, if any.
             */
            message?: pulumi.Input<string>;
            /**
             * A Reason for this condition's last transition from one status to another.
             */
            reason: pulumi.Input<string>;
            /**
             * Status of this condition; is it currently True, False, or Unknown?
             */
            status: pulumi.Input<string>;
            /**
             * Type of this condition. At most one of each condition type may apply to a resource at any point in time.
             */
            type: pulumi.Input<string>;
        }

        /**
         * PostgreSQLInstanceSpec specifies the desired state of a PostgreSQLInstance. PostgreSQLInstance.
         */
        export interface PostgreSQLInstanceSpec {
            /**
             * A ClassReference specifies a resource class that will be used to dynamically provision a managed resource when the resource claim is created.
             */
            classRef?: pulumi.Input<inputs.database.v1alpha1.PostgreSQLInstanceSpecClassRef>;
            /**
             * A ClassSelector specifies labels that will be used to select a resource class for this claim. If multiple classes match the labels one will be chosen at random.
             */
            classSelector?: pulumi.Input<inputs.database.v1alpha1.PostgreSQLInstanceSpecClassSelector>;
            /**
             * EngineVersion specifies the desired PostgreSQL engine version. Allowed Versions: 9.6 and 11.
             */
            engineVersion?: pulumi.Input<string>;
            /**
             * A ResourceReference specifies an existing managed resource, in any namespace, to which this resource claim should attempt to bind. Omit the resource reference to enable dynamic provisioning using a resource class; the resource reference will be automatically populated by Crossplane.
             */
            resourceRef?: pulumi.Input<inputs.database.v1alpha1.PostgreSQLInstanceSpecResourceRef>;
            /**
             * WriteConnectionSecretToReference specifies the name of a Secret, in the same namespace as this resource claim, to which any connection details for this resource claim should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource bound to this resource claim.
             */
            writeConnectionSecretToRef?: pulumi.Input<inputs.database.v1alpha1.PostgreSQLInstanceSpecWriteConnectionSecretToRef>;
        }

        /**
         * A ClassReference specifies a resource class that will be used to dynamically provision a managed resource when the resource claim is created.
         */
        export interface PostgreSQLInstanceSpecClassRef {
            /**
             * API version of the referent.
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: pulumi.Input<string>;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<string>;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: pulumi.Input<string>;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: pulumi.Input<string>;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: pulumi.Input<string>;
        }

        /**
         * A ClassSelector specifies labels that will be used to select a resource class for this claim. If multiple classes match the labels one will be chosen at random.
         */
        export interface PostgreSQLInstanceSpecClassSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.database.v1alpha1.PostgreSQLInstanceSpecClassSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
         */
        export interface PostgreSQLInstanceSpecClassSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A ResourceReference specifies an existing managed resource, in any namespace, to which this resource claim should attempt to bind. Omit the resource reference to enable dynamic provisioning using a resource class; the resource reference will be automatically populated by Crossplane.
         */
        export interface PostgreSQLInstanceSpecResourceRef {
            /**
             * API version of the referent.
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: pulumi.Input<string>;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<string>;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: pulumi.Input<string>;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: pulumi.Input<string>;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: pulumi.Input<string>;
        }

        /**
         * WriteConnectionSecretToReference specifies the name of a Secret, in the same namespace as this resource claim, to which any connection details for this resource claim should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource bound to this resource claim.
         */
        export interface PostgreSQLInstanceSpecWriteConnectionSecretToRef {
            /**
             * Name of the secret.
             */
            name: pulumi.Input<string>;
        }

        /**
         * A ResourceClaimStatus represents the observed status of a resource claim.
         */
        export interface PostgreSQLInstanceStatus {
            /**
             * Phase represents the binding phase of a managed resource or claim. Unbindable resources cannot be bound, typically because they are currently unavailable, or still being created. Unbound resource are available for binding, and Bound resources have successfully bound to another resource.
             */
            bindingPhase?: pulumi.Input<string>;
            /**
             * Conditions of the resource.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.database.v1alpha1.PostgreSQLInstanceStatusConditions>[]>;
        }

        /**
         * A Condition that may apply to a resource.
         */
        export interface PostgreSQLInstanceStatusConditions {
            /**
             * LastTransitionTime is the last time this condition transitioned from one status to another.
             */
            lastTransitionTime: pulumi.Input<string>;
            /**
             * A Message containing details about this condition's last transition from one status to another, if any.
             */
            message?: pulumi.Input<string>;
            /**
             * A Reason for this condition's last transition from one status to another.
             */
            reason: pulumi.Input<string>;
            /**
             * Status of this condition; is it currently True, False, or Unknown?
             */
            status: pulumi.Input<string>;
            /**
             * Type of this condition. At most one of each condition type may apply to a resource at any point in time.
             */
            type: pulumi.Input<string>;
        }
    }
}

export namespace kubernetes {
    export namespace v1alpha1 {
        /**
         * A ProviderSpec defines the desired state of a Provider.
         */
        export interface ProviderSpec {
            /**
             * A Secret containing connection credentials for a Kubernetes cluster client that will be used to authenticate to this Kubernetes Provider. This will typically be the connection secret of a KubernetesCluster claim, or the secret created by a Kubernetes service account, but could also be manually configured to connect to a preexisting cluster.
             */
            credentialsSecretRef: pulumi.Input<inputs.kubernetes.v1alpha1.ProviderSpecCredentialsSecretRef>;
        }

        /**
         * A Secret containing connection credentials for a Kubernetes cluster client that will be used to authenticate to this Kubernetes Provider. This will typically be the connection secret of a KubernetesCluster claim, or the secret created by a Kubernetes service account, but could also be manually configured to connect to a preexisting cluster.
         */
        export interface ProviderSpecCredentialsSecretRef {
            /**
             * Name of the secret.
             */
            name: pulumi.Input<string>;
            /**
             * Namespace of the secret.
             */
            namespace: pulumi.Input<string>;
        }
    }
}

export namespace packages {
    export namespace v1alpha1 {
        export interface ClusterPackageInstallSpec {
            crd?: pulumi.Input<string>;
            imagePullPolicy?: pulumi.Input<string>;
            imagePullSecrets?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.ClusterPackageInstallSpecImagePullSecrets>[]>;
            package?: pulumi.Input<string>;
            serviceAccount?: pulumi.Input<inputs.packages.v1alpha1.ClusterPackageInstallSpecServiceAccount>;
            source?: pulumi.Input<string>;
        }

        export interface ClusterPackageInstallSpecImagePullSecrets {
            name?: pulumi.Input<string>;
        }

        export interface ClusterPackageInstallSpecServiceAccount {
            annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface ClusterPackageInstallStatus {
            conditionedStatus?: pulumi.Input<inputs.packages.v1alpha1.ClusterPackageInstallStatusConditionedStatus>;
            installJob?: pulumi.Input<inputs.packages.v1alpha1.ClusterPackageInstallStatusInstallJob>;
            packageRecord?: pulumi.Input<inputs.packages.v1alpha1.ClusterPackageInstallStatusPackageRecord>;
        }

        export interface ClusterPackageInstallStatusConditionedStatus {
            conditions?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.ClusterPackageInstallStatusConditionedStatusConditions>[]>;
        }

        export interface ClusterPackageInstallStatusConditionedStatusConditions {
            lastTransitionTime: pulumi.Input<string>;
            message?: pulumi.Input<string>;
            reason: pulumi.Input<string>;
            status: pulumi.Input<string>;
            type: pulumi.Input<string>;
        }

        export interface ClusterPackageInstallStatusInstallJob {
            apiVersion?: pulumi.Input<string>;
            fieldPath?: pulumi.Input<string>;
            kind?: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            namespace?: pulumi.Input<string>;
            resourceVersion?: pulumi.Input<string>;
            uid?: pulumi.Input<string>;
        }

        export interface ClusterPackageInstallStatusPackageRecord {
            apiVersion?: pulumi.Input<string>;
            fieldPath?: pulumi.Input<string>;
            kind?: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            namespace?: pulumi.Input<string>;
            resourceVersion?: pulumi.Input<string>;
            uid?: pulumi.Input<string>;
        }

        export interface PackageInstallSpec {
            crd?: pulumi.Input<string>;
            imagePullPolicy?: pulumi.Input<string>;
            imagePullSecrets?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageInstallSpecImagePullSecrets>[]>;
            package?: pulumi.Input<string>;
            serviceAccount?: pulumi.Input<inputs.packages.v1alpha1.PackageInstallSpecServiceAccount>;
            source?: pulumi.Input<string>;
        }

        export interface PackageInstallSpecImagePullSecrets {
            name?: pulumi.Input<string>;
        }

        export interface PackageInstallSpecServiceAccount {
            annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface PackageInstallStatus {
            conditionedStatus?: pulumi.Input<inputs.packages.v1alpha1.PackageInstallStatusConditionedStatus>;
            installJob?: pulumi.Input<inputs.packages.v1alpha1.PackageInstallStatusInstallJob>;
            packageRecord?: pulumi.Input<inputs.packages.v1alpha1.PackageInstallStatusPackageRecord>;
        }

        export interface PackageInstallStatusConditionedStatus {
            conditions?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageInstallStatusConditionedStatusConditions>[]>;
        }

        export interface PackageInstallStatusConditionedStatusConditions {
            lastTransitionTime: pulumi.Input<string>;
            message?: pulumi.Input<string>;
            reason: pulumi.Input<string>;
            status: pulumi.Input<string>;
            type: pulumi.Input<string>;
        }

        export interface PackageInstallStatusInstallJob {
            apiVersion?: pulumi.Input<string>;
            fieldPath?: pulumi.Input<string>;
            kind?: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            namespace?: pulumi.Input<string>;
            resourceVersion?: pulumi.Input<string>;
            uid?: pulumi.Input<string>;
        }

        export interface PackageInstallStatusPackageRecord {
            apiVersion?: pulumi.Input<string>;
            fieldPath?: pulumi.Input<string>;
            kind?: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            namespace?: pulumi.Input<string>;
            resourceVersion?: pulumi.Input<string>;
            uid?: pulumi.Input<string>;
        }

        export interface PackageSpec {
            category?: pulumi.Input<string>;
            company?: pulumi.Input<string>;
            controller?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecController>;
            customresourcedefinitions?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecCustomresourcedefinitions>[]>;
            dependsOn?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecDependsOn>[]>;
            icons?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecIcons>[]>;
            keywords?: pulumi.Input<pulumi.Input<string>[]>;
            license?: pulumi.Input<string>;
            maintainers?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecMaintainers>[]>;
            overview?: pulumi.Input<string>;
            overviewShort?: pulumi.Input<string>;
            owners?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecOwners>[]>;
            packageType?: pulumi.Input<string>;
            permissionScope?: pulumi.Input<string>;
            permissions?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecPermissions>;
            readme?: pulumi.Input<string>;
            source?: pulumi.Input<string>;
            title?: pulumi.Input<string>;
            version?: pulumi.Input<string>;
            website?: pulumi.Input<string>;
        }

        export interface PackageSpecController {
            deployment?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeployment>;
            serviceAccount?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerServiceAccount>;
        }

        export interface PackageSpecControllerDeployment {
            name: pulumi.Input<string>;
            spec: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpec>;
        }

        export interface PackageSpecControllerDeploymentSpec {
            minReadySeconds?: pulumi.Input<number>;
            paused?: pulumi.Input<boolean>;
            progressDeadlineSeconds?: pulumi.Input<number>;
            replicas?: pulumi.Input<number>;
            revisionHistoryLimit?: pulumi.Input<number>;
            selector: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecSelector>;
            strategy?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecStrategy>;
            template: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplate>;
        }

        export interface PackageSpecControllerDeploymentSpecSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface PackageSpecControllerDeploymentSpecSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface PackageSpecControllerDeploymentSpecStrategy {
            rollingUpdate?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecStrategyRollingUpdate>;
            type?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecStrategyRollingUpdate {
            maxSurge?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecStrategyRollingUpdateMaxSurge>;
            maxUnavailable?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecStrategyRollingUpdateMaxUnavailable>;
        }

        export interface PackageSpecControllerDeploymentSpecStrategyRollingUpdateMaxSurge {
        }

        export interface PackageSpecControllerDeploymentSpecStrategyRollingUpdateMaxUnavailable {
        }

        export interface PackageSpecControllerDeploymentSpecTemplate {
            metadata?: pulumi.Input<{[key: string]: any}>;
            spec?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpec>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpec {
            activeDeadlineSeconds?: pulumi.Input<number>;
            affinity?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecAffinity>;
            automountServiceAccountToken?: pulumi.Input<boolean>;
            containers: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainers>[]>;
            dnsConfig?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecDnsConfig>;
            dnsPolicy?: pulumi.Input<string>;
            enableServiceLinks?: pulumi.Input<boolean>;
            ephemeralContainers?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainers>[]>;
            hostAliases?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecHostAliases>[]>;
            hostIPC?: pulumi.Input<boolean>;
            hostNetwork?: pulumi.Input<boolean>;
            hostPID?: pulumi.Input<boolean>;
            hostname?: pulumi.Input<string>;
            imagePullSecrets?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecImagePullSecrets>[]>;
            initContainers?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainers>[]>;
            nodeName?: pulumi.Input<string>;
            nodeSelector?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            overhead?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            preemptionPolicy?: pulumi.Input<string>;
            priority?: pulumi.Input<number>;
            priorityClassName?: pulumi.Input<string>;
            readinessGates?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecReadinessGates>[]>;
            restartPolicy?: pulumi.Input<string>;
            runtimeClassName?: pulumi.Input<string>;
            schedulerName?: pulumi.Input<string>;
            securityContext?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecSecurityContext>;
            serviceAccount?: pulumi.Input<string>;
            serviceAccountName?: pulumi.Input<string>;
            shareProcessNamespace?: pulumi.Input<boolean>;
            subdomain?: pulumi.Input<string>;
            terminationGracePeriodSeconds?: pulumi.Input<number>;
            tolerations?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecTolerations>[]>;
            topologySpreadConstraints?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecTopologySpreadConstraints>[]>;
            volumes?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumes>[]>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecAffinity {
            nodeAffinity?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecAffinityNodeAffinity>;
            podAffinity?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecAffinityPodAffinity>;
            podAntiAffinity?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecAffinityPodAntiAffinity>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecAffinityNodeAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference>;
            weight: pulumi.Input<number>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>[]>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            nodeSelectorTerms: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>[]>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>[]>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecAffinityPodAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight: pulumi.Input<number>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecAffinityPodAntiAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight: pulumi.Input<number>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainers {
            args?: pulumi.Input<pulumi.Input<string>[]>;
            command?: pulumi.Input<pulumi.Input<string>[]>;
            env?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersEnv>[]>;
            envFrom?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersEnvFrom>[]>;
            image?: pulumi.Input<string>;
            imagePullPolicy?: pulumi.Input<string>;
            lifecycle?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersLifecycle>;
            livenessProbe?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersLivenessProbe>;
            name: pulumi.Input<string>;
            ports?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersPorts>[]>;
            readinessProbe?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersReadinessProbe>;
            resources?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersResources>;
            securityContext?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersSecurityContext>;
            startupProbe?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersStartupProbe>;
            stdin?: pulumi.Input<boolean>;
            stdinOnce?: pulumi.Input<boolean>;
            terminationMessagePath?: pulumi.Input<string>;
            terminationMessagePolicy?: pulumi.Input<string>;
            tty?: pulumi.Input<boolean>;
            volumeDevices?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersVolumeDevices>[]>;
            volumeMounts?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersVolumeMounts>[]>;
            workingDir?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersEnv {
            name: pulumi.Input<string>;
            value?: pulumi.Input<string>;
            valueFrom?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersEnvValueFrom>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersEnvFrom {
            configMapRef?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersEnvFromConfigMapRef>;
            prefix?: pulumi.Input<string>;
            secretRef?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersEnvFromSecretRef>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersEnvFromConfigMapRef {
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersEnvFromSecretRef {
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersEnvValueFrom {
            configMapKeyRef?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef>;
            fieldRef?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersEnvValueFromFieldRef>;
            resourceFieldRef?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersEnvValueFromResourceFieldRef>;
            secretKeyRef?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersEnvValueFromSecretKeyRef>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef {
            key: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersEnvValueFromFieldRef {
            apiVersion?: pulumi.Input<string>;
            fieldPath: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersEnvValueFromResourceFieldRef {
            containerName?: pulumi.Input<string>;
            divisor?: pulumi.Input<string>;
            resource: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersEnvValueFromSecretKeyRef {
            key: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersLifecycle {
            postStart?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePostStart>;
            preStop?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePreStop>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePostStart {
            exec?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePostStartExec>;
            httpGet?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePostStartHttpGet>;
            tcpSocket?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePostStartTcpSocket>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePostStartExec {
            command?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePostStartHttpGet {
            host?: pulumi.Input<string>;
            httpHeaders?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders>[]>;
            path?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePostStartHttpGetPort>;
            scheme?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders {
            name: pulumi.Input<string>;
            value: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePostStartHttpGetPort {
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePostStartTcpSocket {
            host?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort {
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePreStop {
            exec?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePreStopExec>;
            httpGet?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePreStopHttpGet>;
            tcpSocket?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePreStopTcpSocket>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePreStopExec {
            command?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePreStopHttpGet {
            host?: pulumi.Input<string>;
            httpHeaders?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders>[]>;
            path?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePreStopHttpGetPort>;
            scheme?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders {
            name: pulumi.Input<string>;
            value: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePreStopHttpGetPort {
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePreStopTcpSocket {
            host?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort {
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersLivenessProbe {
            exec?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersLivenessProbeExec>;
            failureThreshold?: pulumi.Input<number>;
            httpGet?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersLivenessProbeHttpGet>;
            initialDelaySeconds?: pulumi.Input<number>;
            periodSeconds?: pulumi.Input<number>;
            successThreshold?: pulumi.Input<number>;
            tcpSocket?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersLivenessProbeTcpSocket>;
            timeoutSeconds?: pulumi.Input<number>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersLivenessProbeExec {
            command?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersLivenessProbeHttpGet {
            host?: pulumi.Input<string>;
            httpHeaders?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders>[]>;
            path?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersLivenessProbeHttpGetPort>;
            scheme?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders {
            name: pulumi.Input<string>;
            value: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersLivenessProbeHttpGetPort {
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersLivenessProbeTcpSocket {
            host?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersLivenessProbeTcpSocketPort>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersLivenessProbeTcpSocketPort {
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersPorts {
            containerPort: pulumi.Input<number>;
            hostIP?: pulumi.Input<string>;
            hostPort?: pulumi.Input<number>;
            name?: pulumi.Input<string>;
            protocol?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersReadinessProbe {
            exec?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersReadinessProbeExec>;
            failureThreshold?: pulumi.Input<number>;
            httpGet?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersReadinessProbeHttpGet>;
            initialDelaySeconds?: pulumi.Input<number>;
            periodSeconds?: pulumi.Input<number>;
            successThreshold?: pulumi.Input<number>;
            tcpSocket?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersReadinessProbeTcpSocket>;
            timeoutSeconds?: pulumi.Input<number>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersReadinessProbeExec {
            command?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersReadinessProbeHttpGet {
            host?: pulumi.Input<string>;
            httpHeaders?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders>[]>;
            path?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersReadinessProbeHttpGetPort>;
            scheme?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders {
            name: pulumi.Input<string>;
            value: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersReadinessProbeHttpGetPort {
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersReadinessProbeTcpSocket {
            host?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersReadinessProbeTcpSocketPort>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersReadinessProbeTcpSocketPort {
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersResources {
            limits?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            requests?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersSecurityContext {
            allowPrivilegeEscalation?: pulumi.Input<boolean>;
            capabilities?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersSecurityContextCapabilities>;
            privileged?: pulumi.Input<boolean>;
            procMount?: pulumi.Input<string>;
            readOnlyRootFilesystem?: pulumi.Input<boolean>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersSecurityContextSeLinuxOptions>;
            windowsOptions?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersSecurityContextWindowsOptions>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersSecurityContextCapabilities {
            add?: pulumi.Input<pulumi.Input<string>[]>;
            drop?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
            runAsUserName?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersStartupProbe {
            exec?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersStartupProbeExec>;
            failureThreshold?: pulumi.Input<number>;
            httpGet?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersStartupProbeHttpGet>;
            initialDelaySeconds?: pulumi.Input<number>;
            periodSeconds?: pulumi.Input<number>;
            successThreshold?: pulumi.Input<number>;
            tcpSocket?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersStartupProbeTcpSocket>;
            timeoutSeconds?: pulumi.Input<number>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersStartupProbeExec {
            command?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersStartupProbeHttpGet {
            host?: pulumi.Input<string>;
            httpHeaders?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders>[]>;
            path?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersStartupProbeHttpGetPort>;
            scheme?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders {
            name: pulumi.Input<string>;
            value: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersStartupProbeHttpGetPort {
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersStartupProbeTcpSocket {
            host?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecContainersStartupProbeTcpSocketPort>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersStartupProbeTcpSocketPort {
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersVolumeDevices {
            devicePath: pulumi.Input<string>;
            name: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecContainersVolumeMounts {
            mountPath: pulumi.Input<string>;
            mountPropagation?: pulumi.Input<string>;
            name: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            subPath?: pulumi.Input<string>;
            subPathExpr?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecDnsConfig {
            nameservers?: pulumi.Input<pulumi.Input<string>[]>;
            options?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecDnsConfigOptions>[]>;
            searches?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecDnsConfigOptions {
            name?: pulumi.Input<string>;
            value?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainers {
            args?: pulumi.Input<pulumi.Input<string>[]>;
            command?: pulumi.Input<pulumi.Input<string>[]>;
            env?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersEnv>[]>;
            envFrom?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersEnvFrom>[]>;
            image?: pulumi.Input<string>;
            imagePullPolicy?: pulumi.Input<string>;
            lifecycle?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecycle>;
            livenessProbe?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbe>;
            name: pulumi.Input<string>;
            ports?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersPorts>[]>;
            readinessProbe?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbe>;
            resources?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersResources>;
            securityContext?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersSecurityContext>;
            startupProbe?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersStartupProbe>;
            stdin?: pulumi.Input<boolean>;
            stdinOnce?: pulumi.Input<boolean>;
            targetContainerName?: pulumi.Input<string>;
            terminationMessagePath?: pulumi.Input<string>;
            terminationMessagePolicy?: pulumi.Input<string>;
            tty?: pulumi.Input<boolean>;
            volumeDevices?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersVolumeDevices>[]>;
            volumeMounts?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersVolumeMounts>[]>;
            workingDir?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersEnv {
            name: pulumi.Input<string>;
            value?: pulumi.Input<string>;
            valueFrom?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFrom>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersEnvFrom {
            configMapRef?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef>;
            prefix?: pulumi.Input<string>;
            secretRef?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersEnvFromSecretRef>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef {
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersEnvFromSecretRef {
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFrom {
            configMapKeyRef?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef>;
            fieldRef?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef>;
            resourceFieldRef?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef>;
            secretKeyRef?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef {
            key: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef {
            apiVersion?: pulumi.Input<string>;
            fieldPath: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef {
            containerName?: pulumi.Input<string>;
            divisor?: pulumi.Input<string>;
            resource: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef {
            key: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecycle {
            postStart?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStart>;
            preStop?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStop>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStart {
            exec?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartExec>;
            httpGet?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet>;
            tcpSocket?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartExec {
            command?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet {
            host?: pulumi.Input<string>;
            httpHeaders?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders>[]>;
            path?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort>;
            scheme?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders {
            name: pulumi.Input<string>;
            value: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort {
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket {
            host?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort {
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStop {
            exec?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopExec>;
            httpGet?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet>;
            tcpSocket?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopExec {
            command?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet {
            host?: pulumi.Input<string>;
            httpHeaders?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders>[]>;
            path?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort>;
            scheme?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders {
            name: pulumi.Input<string>;
            value: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort {
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket {
            host?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort {
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbe {
            exec?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeExec>;
            failureThreshold?: pulumi.Input<number>;
            httpGet?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet>;
            initialDelaySeconds?: pulumi.Input<number>;
            periodSeconds?: pulumi.Input<number>;
            successThreshold?: pulumi.Input<number>;
            tcpSocket?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket>;
            timeoutSeconds?: pulumi.Input<number>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeExec {
            command?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet {
            host?: pulumi.Input<string>;
            httpHeaders?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders>[]>;
            path?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort>;
            scheme?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders {
            name: pulumi.Input<string>;
            value: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort {
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket {
            host?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort {
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersPorts {
            containerPort: pulumi.Input<number>;
            hostIP?: pulumi.Input<string>;
            hostPort?: pulumi.Input<number>;
            name?: pulumi.Input<string>;
            protocol?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbe {
            exec?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeExec>;
            failureThreshold?: pulumi.Input<number>;
            httpGet?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet>;
            initialDelaySeconds?: pulumi.Input<number>;
            periodSeconds?: pulumi.Input<number>;
            successThreshold?: pulumi.Input<number>;
            tcpSocket?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket>;
            timeoutSeconds?: pulumi.Input<number>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeExec {
            command?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet {
            host?: pulumi.Input<string>;
            httpHeaders?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders>[]>;
            path?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort>;
            scheme?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders {
            name: pulumi.Input<string>;
            value: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort {
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket {
            host?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort {
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersResources {
            limits?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            requests?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersSecurityContext {
            allowPrivilegeEscalation?: pulumi.Input<boolean>;
            capabilities?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextCapabilities>;
            privileged?: pulumi.Input<boolean>;
            procMount?: pulumi.Input<string>;
            readOnlyRootFilesystem?: pulumi.Input<boolean>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions>;
            windowsOptions?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextCapabilities {
            add?: pulumi.Input<pulumi.Input<string>[]>;
            drop?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
            runAsUserName?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersStartupProbe {
            exec?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeExec>;
            failureThreshold?: pulumi.Input<number>;
            httpGet?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeHttpGet>;
            initialDelaySeconds?: pulumi.Input<number>;
            periodSeconds?: pulumi.Input<number>;
            successThreshold?: pulumi.Input<number>;
            tcpSocket?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket>;
            timeoutSeconds?: pulumi.Input<number>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeExec {
            command?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeHttpGet {
            host?: pulumi.Input<string>;
            httpHeaders?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders>[]>;
            path?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort>;
            scheme?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders {
            name: pulumi.Input<string>;
            value: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort {
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket {
            host?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort {
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersVolumeDevices {
            devicePath: pulumi.Input<string>;
            name: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecEphemeralContainersVolumeMounts {
            mountPath: pulumi.Input<string>;
            mountPropagation?: pulumi.Input<string>;
            name: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            subPath?: pulumi.Input<string>;
            subPathExpr?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecHostAliases {
            hostnames?: pulumi.Input<pulumi.Input<string>[]>;
            ip?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecImagePullSecrets {
            name?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainers {
            args?: pulumi.Input<pulumi.Input<string>[]>;
            command?: pulumi.Input<pulumi.Input<string>[]>;
            env?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersEnv>[]>;
            envFrom?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersEnvFrom>[]>;
            image?: pulumi.Input<string>;
            imagePullPolicy?: pulumi.Input<string>;
            lifecycle?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLifecycle>;
            livenessProbe?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLivenessProbe>;
            name: pulumi.Input<string>;
            ports?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersPorts>[]>;
            readinessProbe?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersReadinessProbe>;
            resources?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersResources>;
            securityContext?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersSecurityContext>;
            startupProbe?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersStartupProbe>;
            stdin?: pulumi.Input<boolean>;
            stdinOnce?: pulumi.Input<boolean>;
            terminationMessagePath?: pulumi.Input<string>;
            terminationMessagePolicy?: pulumi.Input<string>;
            tty?: pulumi.Input<boolean>;
            volumeDevices?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersVolumeDevices>[]>;
            volumeMounts?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersVolumeMounts>[]>;
            workingDir?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersEnv {
            name: pulumi.Input<string>;
            value?: pulumi.Input<string>;
            valueFrom?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersEnvValueFrom>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersEnvFrom {
            configMapRef?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersEnvFromConfigMapRef>;
            prefix?: pulumi.Input<string>;
            secretRef?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersEnvFromSecretRef>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersEnvFromConfigMapRef {
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersEnvFromSecretRef {
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersEnvValueFrom {
            configMapKeyRef?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef>;
            fieldRef?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersEnvValueFromFieldRef>;
            resourceFieldRef?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef>;
            secretKeyRef?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef {
            key: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersEnvValueFromFieldRef {
            apiVersion?: pulumi.Input<string>;
            fieldPath: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef {
            containerName?: pulumi.Input<string>;
            divisor?: pulumi.Input<string>;
            resource: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef {
            key: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLifecycle {
            postStart?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePostStart>;
            preStop?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePreStop>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePostStart {
            exec?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartExec>;
            httpGet?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartHttpGet>;
            tcpSocket?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartExec {
            command?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartHttpGet {
            host?: pulumi.Input<string>;
            httpHeaders?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders>[]>;
            path?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort>;
            scheme?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders {
            name: pulumi.Input<string>;
            value: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort {
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket {
            host?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort {
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePreStop {
            exec?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopExec>;
            httpGet?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopHttpGet>;
            tcpSocket?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopExec {
            command?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopHttpGet {
            host?: pulumi.Input<string>;
            httpHeaders?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders>[]>;
            path?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort>;
            scheme?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders {
            name: pulumi.Input<string>;
            value: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort {
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket {
            host?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort {
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLivenessProbe {
            exec?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLivenessProbeExec>;
            failureThreshold?: pulumi.Input<number>;
            httpGet?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLivenessProbeHttpGet>;
            initialDelaySeconds?: pulumi.Input<number>;
            periodSeconds?: pulumi.Input<number>;
            successThreshold?: pulumi.Input<number>;
            tcpSocket?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLivenessProbeTcpSocket>;
            timeoutSeconds?: pulumi.Input<number>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLivenessProbeExec {
            command?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLivenessProbeHttpGet {
            host?: pulumi.Input<string>;
            httpHeaders?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders>[]>;
            path?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLivenessProbeHttpGetPort>;
            scheme?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders {
            name: pulumi.Input<string>;
            value: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLivenessProbeHttpGetPort {
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLivenessProbeTcpSocket {
            host?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort {
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersPorts {
            containerPort: pulumi.Input<number>;
            hostIP?: pulumi.Input<string>;
            hostPort?: pulumi.Input<number>;
            name?: pulumi.Input<string>;
            protocol?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersReadinessProbe {
            exec?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersReadinessProbeExec>;
            failureThreshold?: pulumi.Input<number>;
            httpGet?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersReadinessProbeHttpGet>;
            initialDelaySeconds?: pulumi.Input<number>;
            periodSeconds?: pulumi.Input<number>;
            successThreshold?: pulumi.Input<number>;
            tcpSocket?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersReadinessProbeTcpSocket>;
            timeoutSeconds?: pulumi.Input<number>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersReadinessProbeExec {
            command?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersReadinessProbeHttpGet {
            host?: pulumi.Input<string>;
            httpHeaders?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders>[]>;
            path?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersReadinessProbeHttpGetPort>;
            scheme?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders {
            name: pulumi.Input<string>;
            value: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersReadinessProbeHttpGetPort {
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersReadinessProbeTcpSocket {
            host?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort {
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersResources {
            limits?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            requests?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersSecurityContext {
            allowPrivilegeEscalation?: pulumi.Input<boolean>;
            capabilities?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersSecurityContextCapabilities>;
            privileged?: pulumi.Input<boolean>;
            procMount?: pulumi.Input<string>;
            readOnlyRootFilesystem?: pulumi.Input<boolean>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions>;
            windowsOptions?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersSecurityContextWindowsOptions>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersSecurityContextCapabilities {
            add?: pulumi.Input<pulumi.Input<string>[]>;
            drop?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
            runAsUserName?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersStartupProbe {
            exec?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersStartupProbeExec>;
            failureThreshold?: pulumi.Input<number>;
            httpGet?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersStartupProbeHttpGet>;
            initialDelaySeconds?: pulumi.Input<number>;
            periodSeconds?: pulumi.Input<number>;
            successThreshold?: pulumi.Input<number>;
            tcpSocket?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersStartupProbeTcpSocket>;
            timeoutSeconds?: pulumi.Input<number>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersStartupProbeExec {
            command?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersStartupProbeHttpGet {
            host?: pulumi.Input<string>;
            httpHeaders?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders>[]>;
            path?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersStartupProbeHttpGetPort>;
            scheme?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders {
            name: pulumi.Input<string>;
            value: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersStartupProbeHttpGetPort {
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersStartupProbeTcpSocket {
            host?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecInitContainersStartupProbeTcpSocketPort>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersStartupProbeTcpSocketPort {
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersVolumeDevices {
            devicePath: pulumi.Input<string>;
            name: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecInitContainersVolumeMounts {
            mountPath: pulumi.Input<string>;
            mountPropagation?: pulumi.Input<string>;
            name: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            subPath?: pulumi.Input<string>;
            subPathExpr?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecReadinessGates {
            conditionType: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecSecurityContext {
            fsGroup?: pulumi.Input<number>;
            fsGroupChangePolicy?: pulumi.Input<string>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecSecurityContextSeLinuxOptions>;
            supplementalGroups?: pulumi.Input<pulumi.Input<number>[]>;
            sysctls?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecSecurityContextSysctls>[]>;
            windowsOptions?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecSecurityContextWindowsOptions>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecSecurityContextSysctls {
            name: pulumi.Input<string>;
            value: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
            runAsUserName?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecTolerations {
            effect?: pulumi.Input<string>;
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            tolerationSeconds?: pulumi.Input<number>;
            value?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecTopologySpreadConstraints {
            labelSelector?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecTopologySpreadConstraintsLabelSelector>;
            maxSkew: pulumi.Input<number>;
            topologyKey: pulumi.Input<string>;
            whenUnsatisfiable: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecTopologySpreadConstraintsLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumes {
            awsElasticBlockStore?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesAwsElasticBlockStore>;
            azureDisk?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesAzureDisk>;
            azureFile?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesAzureFile>;
            cephfs?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesCephfs>;
            cinder?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesCinder>;
            configMap?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesConfigMap>;
            csi?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesCsi>;
            downwardAPI?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesDownwardAPI>;
            emptyDir?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesEmptyDir>;
            fc?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesFc>;
            flexVolume?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesFlexVolume>;
            flocker?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesFlocker>;
            gcePersistentDisk?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesGcePersistentDisk>;
            gitRepo?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesGitRepo>;
            glusterfs?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesGlusterfs>;
            hostPath?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesHostPath>;
            iscsi?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesIscsi>;
            name: pulumi.Input<string>;
            nfs?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesNfs>;
            persistentVolumeClaim?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesPersistentVolumeClaim>;
            photonPersistentDisk?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesPhotonPersistentDisk>;
            portworxVolume?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesPortworxVolume>;
            projected?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesProjected>;
            quobyte?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesQuobyte>;
            rbd?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesRbd>;
            scaleIO?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesScaleIO>;
            secret?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesSecret>;
            storageos?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesStorageos>;
            vsphereVolume?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesVsphereVolume>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesAwsElasticBlockStore {
            fsType?: pulumi.Input<string>;
            partition?: pulumi.Input<number>;
            readOnly?: pulumi.Input<boolean>;
            volumeID: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesAzureDisk {
            cachingMode?: pulumi.Input<string>;
            diskName: pulumi.Input<string>;
            diskURI: pulumi.Input<string>;
            fsType?: pulumi.Input<string>;
            kind?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesAzureFile {
            readOnly?: pulumi.Input<boolean>;
            secretName: pulumi.Input<string>;
            shareName: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesCephfs {
            monitors: pulumi.Input<pulumi.Input<string>[]>;
            path?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretFile?: pulumi.Input<string>;
            secretRef?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesCephfsSecretRef>;
            user?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesCephfsSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesCinder {
            fsType?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesCinderSecretRef>;
            volumeID: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesCinderSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesConfigMap {
            defaultMode?: pulumi.Input<number>;
            items?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesConfigMapItems>[]>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesConfigMapItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesCsi {
            driver: pulumi.Input<string>;
            fsType?: pulumi.Input<string>;
            nodePublishSecretRef?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesCsiNodePublishSecretRef>;
            readOnly?: pulumi.Input<boolean>;
            volumeAttributes?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesCsiNodePublishSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesDownwardAPI {
            defaultMode?: pulumi.Input<number>;
            items?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesDownwardAPIItems>[]>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesDownwardAPIItems {
            fieldRef?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesDownwardAPIItemsFieldRef>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
            resourceFieldRef?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesDownwardAPIItemsResourceFieldRef>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesDownwardAPIItemsFieldRef {
            apiVersion?: pulumi.Input<string>;
            fieldPath: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesDownwardAPIItemsResourceFieldRef {
            containerName?: pulumi.Input<string>;
            divisor?: pulumi.Input<string>;
            resource: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesEmptyDir {
            medium?: pulumi.Input<string>;
            sizeLimit?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesFc {
            fsType?: pulumi.Input<string>;
            lun?: pulumi.Input<number>;
            readOnly?: pulumi.Input<boolean>;
            targetWWNs?: pulumi.Input<pulumi.Input<string>[]>;
            wwids?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesFlexVolume {
            driver: pulumi.Input<string>;
            fsType?: pulumi.Input<string>;
            options?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesFlexVolumeSecretRef>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesFlexVolumeSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesFlocker {
            datasetName?: pulumi.Input<string>;
            datasetUUID?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesGcePersistentDisk {
            fsType?: pulumi.Input<string>;
            partition?: pulumi.Input<number>;
            pdName: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesGitRepo {
            directory?: pulumi.Input<string>;
            repository: pulumi.Input<string>;
            revision?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesGlusterfs {
            endpoints: pulumi.Input<string>;
            path: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesHostPath {
            path: pulumi.Input<string>;
            type?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesIscsi {
            chapAuthDiscovery?: pulumi.Input<boolean>;
            chapAuthSession?: pulumi.Input<boolean>;
            fsType?: pulumi.Input<string>;
            initiatorName?: pulumi.Input<string>;
            iqn: pulumi.Input<string>;
            iscsiInterface?: pulumi.Input<string>;
            lun: pulumi.Input<number>;
            portals?: pulumi.Input<pulumi.Input<string>[]>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesIscsiSecretRef>;
            targetPortal: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesIscsiSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesNfs {
            path: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            server: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesPersistentVolumeClaim {
            claimName: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesPhotonPersistentDisk {
            fsType?: pulumi.Input<string>;
            pdID: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesPortworxVolume {
            fsType?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            volumeID: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesProjected {
            defaultMode?: pulumi.Input<number>;
            sources: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesProjectedSources>[]>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesProjectedSources {
            configMap?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesProjectedSourcesConfigMap>;
            downwardAPI?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardAPI>;
            secret?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesProjectedSourcesSecret>;
            serviceAccountToken?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesProjectedSourcesConfigMap {
            items?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesProjectedSourcesConfigMapItems>[]>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesProjectedSourcesConfigMapItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardAPI {
            items?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardAPIItems>[]>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardAPIItems {
            fieldRef?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardAPIItemsFieldRef>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
            resourceFieldRef?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardAPIItemsFieldRef {
            apiVersion?: pulumi.Input<string>;
            fieldPath: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef {
            containerName?: pulumi.Input<string>;
            divisor?: pulumi.Input<string>;
            resource: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesProjectedSourcesSecret {
            items?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesProjectedSourcesSecretItems>[]>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesProjectedSourcesSecretItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken {
            audience?: pulumi.Input<string>;
            expirationSeconds?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesQuobyte {
            group?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            registry: pulumi.Input<string>;
            tenant?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
            volume: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesRbd {
            fsType?: pulumi.Input<string>;
            image: pulumi.Input<string>;
            keyring?: pulumi.Input<string>;
            monitors: pulumi.Input<pulumi.Input<string>[]>;
            pool?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesRbdSecretRef>;
            user?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesRbdSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesScaleIO {
            fsType?: pulumi.Input<string>;
            gateway: pulumi.Input<string>;
            protectionDomain?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesScaleIOSecretRef>;
            sslEnabled?: pulumi.Input<boolean>;
            storageMode?: pulumi.Input<string>;
            storagePool?: pulumi.Input<string>;
            system: pulumi.Input<string>;
            volumeName?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesScaleIOSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesSecret {
            defaultMode?: pulumi.Input<number>;
            items?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesSecretItems>[]>;
            optional?: pulumi.Input<boolean>;
            secretName?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesSecretItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesStorageos {
            fsType?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecControllerDeploymentSpecTemplateSpecVolumesStorageosSecretRef>;
            volumeName?: pulumi.Input<string>;
            volumeNamespace?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesStorageosSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface PackageSpecControllerDeploymentSpecTemplateSpecVolumesVsphereVolume {
            fsType?: pulumi.Input<string>;
            storagePolicyID?: pulumi.Input<string>;
            storagePolicyName?: pulumi.Input<string>;
            volumePath: pulumi.Input<string>;
        }

        export interface PackageSpecControllerServiceAccount {
            annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface PackageSpecCustomresourcedefinitions {
            apiVersion?: pulumi.Input<string>;
            kind?: pulumi.Input<string>;
        }

        export interface PackageSpecDependsOn {
            crd?: pulumi.Input<string>;
            imagePullPolicy?: pulumi.Input<string>;
            imagePullSecrets?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecDependsOnImagePullSecrets>[]>;
            package?: pulumi.Input<string>;
            serviceAccount?: pulumi.Input<inputs.packages.v1alpha1.PackageSpecDependsOnServiceAccount>;
            source?: pulumi.Input<string>;
        }

        export interface PackageSpecDependsOnImagePullSecrets {
            name?: pulumi.Input<string>;
        }

        export interface PackageSpecDependsOnServiceAccount {
            annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface PackageSpecIcons {
            base64Data: pulumi.Input<string>;
            mediatype: pulumi.Input<string>;
        }

        export interface PackageSpecMaintainers {
            email?: pulumi.Input<string>;
            name?: pulumi.Input<string>;
        }

        export interface PackageSpecOwners {
            email?: pulumi.Input<string>;
            name?: pulumi.Input<string>;
        }

        export interface PackageSpecPermissions {
            rules?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageSpecPermissionsRules>[]>;
        }

        export interface PackageSpecPermissionsRules {
            apiGroups?: pulumi.Input<pulumi.Input<string>[]>;
            nonResourceURLs?: pulumi.Input<pulumi.Input<string>[]>;
            resourceNames?: pulumi.Input<pulumi.Input<string>[]>;
            resources?: pulumi.Input<pulumi.Input<string>[]>;
            verbs: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface PackageStatus {
            conditionedStatus?: pulumi.Input<inputs.packages.v1alpha1.PackageStatusConditionedStatus>;
            controllerRef?: pulumi.Input<inputs.packages.v1alpha1.PackageStatusControllerRef>;
        }

        export interface PackageStatusConditionedStatus {
            conditions?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.PackageStatusConditionedStatusConditions>[]>;
        }

        export interface PackageStatusConditionedStatusConditions {
            lastTransitionTime: pulumi.Input<string>;
            message?: pulumi.Input<string>;
            reason: pulumi.Input<string>;
            status: pulumi.Input<string>;
            type: pulumi.Input<string>;
        }

        export interface PackageStatusControllerRef {
            apiVersion?: pulumi.Input<string>;
            fieldPath?: pulumi.Input<string>;
            kind?: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            namespace?: pulumi.Input<string>;
            resourceVersion?: pulumi.Input<string>;
            uid?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpec {
            behavior?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecBehavior>;
            category?: pulumi.Input<string>;
            company?: pulumi.Input<string>;
            controller?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecController>;
            customresourcedefinitions?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecCustomresourcedefinitions>[]>;
            dependsOn?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecDependsOn>[]>;
            icons?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecIcons>[]>;
            keywords?: pulumi.Input<pulumi.Input<string>[]>;
            license?: pulumi.Input<string>;
            maintainers?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecMaintainers>[]>;
            overview?: pulumi.Input<string>;
            overviewShort?: pulumi.Input<string>;
            owners?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecOwners>[]>;
            packageType?: pulumi.Input<string>;
            permissionScope?: pulumi.Input<string>;
            permissions?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecPermissions>;
            readme?: pulumi.Input<string>;
            source?: pulumi.Input<string>;
            title?: pulumi.Input<string>;
            version?: pulumi.Input<string>;
            website?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecBehavior {
            crd?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecBehaviorCrd>;
            engine?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecBehaviorEngine>;
            source?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecBehaviorSource>;
        }

        export interface StackDefinitionSpecBehaviorCrd {
            apiVersion: pulumi.Input<string>;
            kind: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecBehaviorEngine {
            controllerImage?: pulumi.Input<string>;
            kustomize?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecBehaviorEngineKustomize>;
            type: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecBehaviorEngineKustomize {
            kustomization?: pulumi.Input<{[key: string]: any}>;
            overlays?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecBehaviorEngineKustomizeOverlays>[]>;
        }

        export interface StackDefinitionSpecBehaviorEngineKustomizeOverlays {
            apiVersion: pulumi.Input<string>;
            bindings: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecBehaviorEngineKustomizeOverlaysBindings>[]>;
            kind: pulumi.Input<string>;
            name: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecBehaviorEngineKustomizeOverlaysBindings {
            from: pulumi.Input<string>;
            to: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecBehaviorSource {
            image?: pulumi.Input<string>;
            path: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecController {
            deployment?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeployment>;
            serviceAccount?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerServiceAccount>;
        }

        export interface StackDefinitionSpecControllerDeployment {
            name: pulumi.Input<string>;
            spec: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpec>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpec {
            minReadySeconds?: pulumi.Input<number>;
            paused?: pulumi.Input<boolean>;
            progressDeadlineSeconds?: pulumi.Input<number>;
            replicas?: pulumi.Input<number>;
            revisionHistoryLimit?: pulumi.Input<number>;
            selector: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecSelector>;
            strategy?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecStrategy>;
            template: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplate>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecStrategy {
            rollingUpdate?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecStrategyRollingUpdate>;
            type?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecStrategyRollingUpdate {
            maxSurge?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecStrategyRollingUpdateMaxSurge>;
            maxUnavailable?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecStrategyRollingUpdateMaxUnavailable>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecStrategyRollingUpdateMaxSurge {
        }

        export interface StackDefinitionSpecControllerDeploymentSpecStrategyRollingUpdateMaxUnavailable {
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplate {
            metadata?: pulumi.Input<{[key: string]: any}>;
            spec?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpec>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpec {
            activeDeadlineSeconds?: pulumi.Input<number>;
            affinity?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinity>;
            automountServiceAccountToken?: pulumi.Input<boolean>;
            containers: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainers>[]>;
            dnsConfig?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecDnsConfig>;
            dnsPolicy?: pulumi.Input<string>;
            enableServiceLinks?: pulumi.Input<boolean>;
            ephemeralContainers?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainers>[]>;
            hostAliases?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecHostAliases>[]>;
            hostIPC?: pulumi.Input<boolean>;
            hostNetwork?: pulumi.Input<boolean>;
            hostPID?: pulumi.Input<boolean>;
            hostname?: pulumi.Input<string>;
            imagePullSecrets?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecImagePullSecrets>[]>;
            initContainers?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainers>[]>;
            nodeName?: pulumi.Input<string>;
            nodeSelector?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            overhead?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            preemptionPolicy?: pulumi.Input<string>;
            priority?: pulumi.Input<number>;
            priorityClassName?: pulumi.Input<string>;
            readinessGates?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecReadinessGates>[]>;
            restartPolicy?: pulumi.Input<string>;
            runtimeClassName?: pulumi.Input<string>;
            schedulerName?: pulumi.Input<string>;
            securityContext?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecSecurityContext>;
            serviceAccount?: pulumi.Input<string>;
            serviceAccountName?: pulumi.Input<string>;
            shareProcessNamespace?: pulumi.Input<boolean>;
            subdomain?: pulumi.Input<string>;
            terminationGracePeriodSeconds?: pulumi.Input<number>;
            tolerations?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecTolerations>[]>;
            topologySpreadConstraints?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecTopologySpreadConstraints>[]>;
            volumes?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumes>[]>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinity {
            nodeAffinity?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityNodeAffinity>;
            podAffinity?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityPodAffinity>;
            podAntiAffinity?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityPodAntiAffinity>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityNodeAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference>;
            weight: pulumi.Input<number>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>[]>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            nodeSelectorTerms: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>[]>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>[]>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityPodAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight: pulumi.Input<number>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityPodAntiAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight: pulumi.Input<number>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainers {
            args?: pulumi.Input<pulumi.Input<string>[]>;
            command?: pulumi.Input<pulumi.Input<string>[]>;
            env?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersEnv>[]>;
            envFrom?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersEnvFrom>[]>;
            image?: pulumi.Input<string>;
            imagePullPolicy?: pulumi.Input<string>;
            lifecycle?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLifecycle>;
            livenessProbe?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLivenessProbe>;
            name: pulumi.Input<string>;
            ports?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersPorts>[]>;
            readinessProbe?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersReadinessProbe>;
            resources?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersResources>;
            securityContext?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersSecurityContext>;
            startupProbe?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersStartupProbe>;
            stdin?: pulumi.Input<boolean>;
            stdinOnce?: pulumi.Input<boolean>;
            terminationMessagePath?: pulumi.Input<string>;
            terminationMessagePolicy?: pulumi.Input<string>;
            tty?: pulumi.Input<boolean>;
            volumeDevices?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersVolumeDevices>[]>;
            volumeMounts?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersVolumeMounts>[]>;
            workingDir?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersEnv {
            name: pulumi.Input<string>;
            value?: pulumi.Input<string>;
            valueFrom?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersEnvValueFrom>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersEnvFrom {
            configMapRef?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersEnvFromConfigMapRef>;
            prefix?: pulumi.Input<string>;
            secretRef?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersEnvFromSecretRef>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersEnvFromConfigMapRef {
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersEnvFromSecretRef {
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersEnvValueFrom {
            configMapKeyRef?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef>;
            fieldRef?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersEnvValueFromFieldRef>;
            resourceFieldRef?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersEnvValueFromResourceFieldRef>;
            secretKeyRef?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersEnvValueFromSecretKeyRef>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersEnvValueFromConfigMapKeyRef {
            key: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersEnvValueFromFieldRef {
            apiVersion?: pulumi.Input<string>;
            fieldPath: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersEnvValueFromResourceFieldRef {
            containerName?: pulumi.Input<string>;
            divisor?: pulumi.Input<string>;
            resource: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersEnvValueFromSecretKeyRef {
            key: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLifecycle {
            postStart?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePostStart>;
            preStop?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePreStop>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePostStart {
            exec?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePostStartExec>;
            httpGet?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePostStartHttpGet>;
            tcpSocket?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePostStartTcpSocket>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePostStartExec {
            command?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePostStartHttpGet {
            host?: pulumi.Input<string>;
            httpHeaders?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders>[]>;
            path?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePostStartHttpGetPort>;
            scheme?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePostStartHttpGetHttpHeaders {
            name: pulumi.Input<string>;
            value: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePostStartHttpGetPort {
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePostStartTcpSocket {
            host?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePostStartTcpSocketPort {
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePreStop {
            exec?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePreStopExec>;
            httpGet?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePreStopHttpGet>;
            tcpSocket?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePreStopTcpSocket>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePreStopExec {
            command?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePreStopHttpGet {
            host?: pulumi.Input<string>;
            httpHeaders?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders>[]>;
            path?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePreStopHttpGetPort>;
            scheme?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePreStopHttpGetHttpHeaders {
            name: pulumi.Input<string>;
            value: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePreStopHttpGetPort {
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePreStopTcpSocket {
            host?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLifecyclePreStopTcpSocketPort {
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLivenessProbe {
            exec?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLivenessProbeExec>;
            failureThreshold?: pulumi.Input<number>;
            httpGet?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLivenessProbeHttpGet>;
            initialDelaySeconds?: pulumi.Input<number>;
            periodSeconds?: pulumi.Input<number>;
            successThreshold?: pulumi.Input<number>;
            tcpSocket?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLivenessProbeTcpSocket>;
            timeoutSeconds?: pulumi.Input<number>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLivenessProbeExec {
            command?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLivenessProbeHttpGet {
            host?: pulumi.Input<string>;
            httpHeaders?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders>[]>;
            path?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLivenessProbeHttpGetPort>;
            scheme?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLivenessProbeHttpGetHttpHeaders {
            name: pulumi.Input<string>;
            value: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLivenessProbeHttpGetPort {
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLivenessProbeTcpSocket {
            host?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLivenessProbeTcpSocketPort>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersLivenessProbeTcpSocketPort {
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersPorts {
            containerPort: pulumi.Input<number>;
            hostIP?: pulumi.Input<string>;
            hostPort?: pulumi.Input<number>;
            name?: pulumi.Input<string>;
            protocol?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersReadinessProbe {
            exec?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersReadinessProbeExec>;
            failureThreshold?: pulumi.Input<number>;
            httpGet?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersReadinessProbeHttpGet>;
            initialDelaySeconds?: pulumi.Input<number>;
            periodSeconds?: pulumi.Input<number>;
            successThreshold?: pulumi.Input<number>;
            tcpSocket?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersReadinessProbeTcpSocket>;
            timeoutSeconds?: pulumi.Input<number>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersReadinessProbeExec {
            command?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersReadinessProbeHttpGet {
            host?: pulumi.Input<string>;
            httpHeaders?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders>[]>;
            path?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersReadinessProbeHttpGetPort>;
            scheme?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersReadinessProbeHttpGetHttpHeaders {
            name: pulumi.Input<string>;
            value: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersReadinessProbeHttpGetPort {
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersReadinessProbeTcpSocket {
            host?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersReadinessProbeTcpSocketPort>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersReadinessProbeTcpSocketPort {
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersResources {
            limits?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            requests?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersSecurityContext {
            allowPrivilegeEscalation?: pulumi.Input<boolean>;
            capabilities?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersSecurityContextCapabilities>;
            privileged?: pulumi.Input<boolean>;
            procMount?: pulumi.Input<string>;
            readOnlyRootFilesystem?: pulumi.Input<boolean>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersSecurityContextSeLinuxOptions>;
            windowsOptions?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersSecurityContextWindowsOptions>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersSecurityContextCapabilities {
            add?: pulumi.Input<pulumi.Input<string>[]>;
            drop?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
            runAsUserName?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersStartupProbe {
            exec?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersStartupProbeExec>;
            failureThreshold?: pulumi.Input<number>;
            httpGet?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersStartupProbeHttpGet>;
            initialDelaySeconds?: pulumi.Input<number>;
            periodSeconds?: pulumi.Input<number>;
            successThreshold?: pulumi.Input<number>;
            tcpSocket?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersStartupProbeTcpSocket>;
            timeoutSeconds?: pulumi.Input<number>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersStartupProbeExec {
            command?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersStartupProbeHttpGet {
            host?: pulumi.Input<string>;
            httpHeaders?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders>[]>;
            path?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersStartupProbeHttpGetPort>;
            scheme?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersStartupProbeHttpGetHttpHeaders {
            name: pulumi.Input<string>;
            value: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersStartupProbeHttpGetPort {
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersStartupProbeTcpSocket {
            host?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersStartupProbeTcpSocketPort>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersStartupProbeTcpSocketPort {
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersVolumeDevices {
            devicePath: pulumi.Input<string>;
            name: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecContainersVolumeMounts {
            mountPath: pulumi.Input<string>;
            mountPropagation?: pulumi.Input<string>;
            name: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            subPath?: pulumi.Input<string>;
            subPathExpr?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecDnsConfig {
            nameservers?: pulumi.Input<pulumi.Input<string>[]>;
            options?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecDnsConfigOptions>[]>;
            searches?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecDnsConfigOptions {
            name?: pulumi.Input<string>;
            value?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainers {
            args?: pulumi.Input<pulumi.Input<string>[]>;
            command?: pulumi.Input<pulumi.Input<string>[]>;
            env?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersEnv>[]>;
            envFrom?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersEnvFrom>[]>;
            image?: pulumi.Input<string>;
            imagePullPolicy?: pulumi.Input<string>;
            lifecycle?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecycle>;
            livenessProbe?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbe>;
            name: pulumi.Input<string>;
            ports?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersPorts>[]>;
            readinessProbe?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbe>;
            resources?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersResources>;
            securityContext?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersSecurityContext>;
            startupProbe?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersStartupProbe>;
            stdin?: pulumi.Input<boolean>;
            stdinOnce?: pulumi.Input<boolean>;
            targetContainerName?: pulumi.Input<string>;
            terminationMessagePath?: pulumi.Input<string>;
            terminationMessagePolicy?: pulumi.Input<string>;
            tty?: pulumi.Input<boolean>;
            volumeDevices?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersVolumeDevices>[]>;
            volumeMounts?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersVolumeMounts>[]>;
            workingDir?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersEnv {
            name: pulumi.Input<string>;
            value?: pulumi.Input<string>;
            valueFrom?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFrom>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersEnvFrom {
            configMapRef?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef>;
            prefix?: pulumi.Input<string>;
            secretRef?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersEnvFromSecretRef>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersEnvFromConfigMapRef {
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersEnvFromSecretRef {
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFrom {
            configMapKeyRef?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef>;
            fieldRef?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef>;
            resourceFieldRef?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef>;
            secretKeyRef?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromConfigMapKeyRef {
            key: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromFieldRef {
            apiVersion?: pulumi.Input<string>;
            fieldPath: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromResourceFieldRef {
            containerName?: pulumi.Input<string>;
            divisor?: pulumi.Input<string>;
            resource: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersEnvValueFromSecretKeyRef {
            key: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecycle {
            postStart?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStart>;
            preStop?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStop>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStart {
            exec?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartExec>;
            httpGet?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet>;
            tcpSocket?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartExec {
            command?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGet {
            host?: pulumi.Input<string>;
            httpHeaders?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders>[]>;
            path?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort>;
            scheme?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetHttpHeaders {
            name: pulumi.Input<string>;
            value: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartHttpGetPort {
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocket {
            host?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePostStartTcpSocketPort {
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStop {
            exec?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopExec>;
            httpGet?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet>;
            tcpSocket?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopExec {
            command?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGet {
            host?: pulumi.Input<string>;
            httpHeaders?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders>[]>;
            path?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort>;
            scheme?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetHttpHeaders {
            name: pulumi.Input<string>;
            value: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopHttpGetPort {
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocket {
            host?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLifecyclePreStopTcpSocketPort {
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbe {
            exec?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeExec>;
            failureThreshold?: pulumi.Input<number>;
            httpGet?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet>;
            initialDelaySeconds?: pulumi.Input<number>;
            periodSeconds?: pulumi.Input<number>;
            successThreshold?: pulumi.Input<number>;
            tcpSocket?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket>;
            timeoutSeconds?: pulumi.Input<number>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeExec {
            command?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeHttpGet {
            host?: pulumi.Input<string>;
            httpHeaders?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders>[]>;
            path?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort>;
            scheme?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetHttpHeaders {
            name: pulumi.Input<string>;
            value: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeHttpGetPort {
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocket {
            host?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersLivenessProbeTcpSocketPort {
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersPorts {
            containerPort: pulumi.Input<number>;
            hostIP?: pulumi.Input<string>;
            hostPort?: pulumi.Input<number>;
            name?: pulumi.Input<string>;
            protocol?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbe {
            exec?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeExec>;
            failureThreshold?: pulumi.Input<number>;
            httpGet?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet>;
            initialDelaySeconds?: pulumi.Input<number>;
            periodSeconds?: pulumi.Input<number>;
            successThreshold?: pulumi.Input<number>;
            tcpSocket?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket>;
            timeoutSeconds?: pulumi.Input<number>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeExec {
            command?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeHttpGet {
            host?: pulumi.Input<string>;
            httpHeaders?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders>[]>;
            path?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort>;
            scheme?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetHttpHeaders {
            name: pulumi.Input<string>;
            value: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeHttpGetPort {
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocket {
            host?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersReadinessProbeTcpSocketPort {
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersResources {
            limits?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            requests?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersSecurityContext {
            allowPrivilegeEscalation?: pulumi.Input<boolean>;
            capabilities?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextCapabilities>;
            privileged?: pulumi.Input<boolean>;
            procMount?: pulumi.Input<string>;
            readOnlyRootFilesystem?: pulumi.Input<boolean>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions>;
            windowsOptions?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextCapabilities {
            add?: pulumi.Input<pulumi.Input<string>[]>;
            drop?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
            runAsUserName?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersStartupProbe {
            exec?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeExec>;
            failureThreshold?: pulumi.Input<number>;
            httpGet?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeHttpGet>;
            initialDelaySeconds?: pulumi.Input<number>;
            periodSeconds?: pulumi.Input<number>;
            successThreshold?: pulumi.Input<number>;
            tcpSocket?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket>;
            timeoutSeconds?: pulumi.Input<number>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeExec {
            command?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeHttpGet {
            host?: pulumi.Input<string>;
            httpHeaders?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders>[]>;
            path?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort>;
            scheme?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeHttpGetHttpHeaders {
            name: pulumi.Input<string>;
            value: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeHttpGetPort {
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeTcpSocket {
            host?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersStartupProbeTcpSocketPort {
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersVolumeDevices {
            devicePath: pulumi.Input<string>;
            name: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecEphemeralContainersVolumeMounts {
            mountPath: pulumi.Input<string>;
            mountPropagation?: pulumi.Input<string>;
            name: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            subPath?: pulumi.Input<string>;
            subPathExpr?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecHostAliases {
            hostnames?: pulumi.Input<pulumi.Input<string>[]>;
            ip?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecImagePullSecrets {
            name?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainers {
            args?: pulumi.Input<pulumi.Input<string>[]>;
            command?: pulumi.Input<pulumi.Input<string>[]>;
            env?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersEnv>[]>;
            envFrom?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersEnvFrom>[]>;
            image?: pulumi.Input<string>;
            imagePullPolicy?: pulumi.Input<string>;
            lifecycle?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLifecycle>;
            livenessProbe?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLivenessProbe>;
            name: pulumi.Input<string>;
            ports?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersPorts>[]>;
            readinessProbe?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersReadinessProbe>;
            resources?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersResources>;
            securityContext?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersSecurityContext>;
            startupProbe?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersStartupProbe>;
            stdin?: pulumi.Input<boolean>;
            stdinOnce?: pulumi.Input<boolean>;
            terminationMessagePath?: pulumi.Input<string>;
            terminationMessagePolicy?: pulumi.Input<string>;
            tty?: pulumi.Input<boolean>;
            volumeDevices?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersVolumeDevices>[]>;
            volumeMounts?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersVolumeMounts>[]>;
            workingDir?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersEnv {
            name: pulumi.Input<string>;
            value?: pulumi.Input<string>;
            valueFrom?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersEnvValueFrom>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersEnvFrom {
            configMapRef?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersEnvFromConfigMapRef>;
            prefix?: pulumi.Input<string>;
            secretRef?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersEnvFromSecretRef>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersEnvFromConfigMapRef {
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersEnvFromSecretRef {
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersEnvValueFrom {
            configMapKeyRef?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef>;
            fieldRef?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersEnvValueFromFieldRef>;
            resourceFieldRef?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef>;
            secretKeyRef?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersEnvValueFromConfigMapKeyRef {
            key: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersEnvValueFromFieldRef {
            apiVersion?: pulumi.Input<string>;
            fieldPath: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersEnvValueFromResourceFieldRef {
            containerName?: pulumi.Input<string>;
            divisor?: pulumi.Input<string>;
            resource: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersEnvValueFromSecretKeyRef {
            key: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLifecycle {
            postStart?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePostStart>;
            preStop?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePreStop>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePostStart {
            exec?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartExec>;
            httpGet?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartHttpGet>;
            tcpSocket?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartExec {
            command?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartHttpGet {
            host?: pulumi.Input<string>;
            httpHeaders?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders>[]>;
            path?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort>;
            scheme?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders {
            name: pulumi.Input<string>;
            value: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartHttpGetPort {
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartTcpSocket {
            host?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePostStartTcpSocketPort {
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePreStop {
            exec?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopExec>;
            httpGet?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopHttpGet>;
            tcpSocket?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopExec {
            command?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopHttpGet {
            host?: pulumi.Input<string>;
            httpHeaders?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders>[]>;
            path?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort>;
            scheme?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders {
            name: pulumi.Input<string>;
            value: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopHttpGetPort {
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopTcpSocket {
            host?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLifecyclePreStopTcpSocketPort {
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLivenessProbe {
            exec?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLivenessProbeExec>;
            failureThreshold?: pulumi.Input<number>;
            httpGet?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLivenessProbeHttpGet>;
            initialDelaySeconds?: pulumi.Input<number>;
            periodSeconds?: pulumi.Input<number>;
            successThreshold?: pulumi.Input<number>;
            tcpSocket?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLivenessProbeTcpSocket>;
            timeoutSeconds?: pulumi.Input<number>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLivenessProbeExec {
            command?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLivenessProbeHttpGet {
            host?: pulumi.Input<string>;
            httpHeaders?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders>[]>;
            path?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLivenessProbeHttpGetPort>;
            scheme?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders {
            name: pulumi.Input<string>;
            value: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLivenessProbeHttpGetPort {
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLivenessProbeTcpSocket {
            host?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersLivenessProbeTcpSocketPort {
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersPorts {
            containerPort: pulumi.Input<number>;
            hostIP?: pulumi.Input<string>;
            hostPort?: pulumi.Input<number>;
            name?: pulumi.Input<string>;
            protocol?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersReadinessProbe {
            exec?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersReadinessProbeExec>;
            failureThreshold?: pulumi.Input<number>;
            httpGet?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersReadinessProbeHttpGet>;
            initialDelaySeconds?: pulumi.Input<number>;
            periodSeconds?: pulumi.Input<number>;
            successThreshold?: pulumi.Input<number>;
            tcpSocket?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersReadinessProbeTcpSocket>;
            timeoutSeconds?: pulumi.Input<number>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersReadinessProbeExec {
            command?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersReadinessProbeHttpGet {
            host?: pulumi.Input<string>;
            httpHeaders?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders>[]>;
            path?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersReadinessProbeHttpGetPort>;
            scheme?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders {
            name: pulumi.Input<string>;
            value: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersReadinessProbeHttpGetPort {
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersReadinessProbeTcpSocket {
            host?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersReadinessProbeTcpSocketPort {
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersResources {
            limits?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            requests?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersSecurityContext {
            allowPrivilegeEscalation?: pulumi.Input<boolean>;
            capabilities?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersSecurityContextCapabilities>;
            privileged?: pulumi.Input<boolean>;
            procMount?: pulumi.Input<string>;
            readOnlyRootFilesystem?: pulumi.Input<boolean>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions>;
            windowsOptions?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersSecurityContextWindowsOptions>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersSecurityContextCapabilities {
            add?: pulumi.Input<pulumi.Input<string>[]>;
            drop?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
            runAsUserName?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersStartupProbe {
            exec?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersStartupProbeExec>;
            failureThreshold?: pulumi.Input<number>;
            httpGet?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersStartupProbeHttpGet>;
            initialDelaySeconds?: pulumi.Input<number>;
            periodSeconds?: pulumi.Input<number>;
            successThreshold?: pulumi.Input<number>;
            tcpSocket?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersStartupProbeTcpSocket>;
            timeoutSeconds?: pulumi.Input<number>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersStartupProbeExec {
            command?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersStartupProbeHttpGet {
            host?: pulumi.Input<string>;
            httpHeaders?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders>[]>;
            path?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersStartupProbeHttpGetPort>;
            scheme?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersStartupProbeHttpGetHttpHeaders {
            name: pulumi.Input<string>;
            value: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersStartupProbeHttpGetPort {
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersStartupProbeTcpSocket {
            host?: pulumi.Input<string>;
            port: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersStartupProbeTcpSocketPort>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersStartupProbeTcpSocketPort {
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersVolumeDevices {
            devicePath: pulumi.Input<string>;
            name: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecInitContainersVolumeMounts {
            mountPath: pulumi.Input<string>;
            mountPropagation?: pulumi.Input<string>;
            name: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            subPath?: pulumi.Input<string>;
            subPathExpr?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecReadinessGates {
            conditionType: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecSecurityContext {
            fsGroup?: pulumi.Input<number>;
            fsGroupChangePolicy?: pulumi.Input<string>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecSecurityContextSeLinuxOptions>;
            supplementalGroups?: pulumi.Input<pulumi.Input<number>[]>;
            sysctls?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecSecurityContextSysctls>[]>;
            windowsOptions?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecSecurityContextWindowsOptions>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecSecurityContextSysctls {
            name: pulumi.Input<string>;
            value: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
            runAsUserName?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecTolerations {
            effect?: pulumi.Input<string>;
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            tolerationSeconds?: pulumi.Input<number>;
            value?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecTopologySpreadConstraints {
            labelSelector?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecTopologySpreadConstraintsLabelSelector>;
            maxSkew: pulumi.Input<number>;
            topologyKey: pulumi.Input<string>;
            whenUnsatisfiable: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecTopologySpreadConstraintsLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions {
            key: pulumi.Input<string>;
            operator: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumes {
            awsElasticBlockStore?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesAwsElasticBlockStore>;
            azureDisk?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesAzureDisk>;
            azureFile?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesAzureFile>;
            cephfs?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesCephfs>;
            cinder?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesCinder>;
            configMap?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesConfigMap>;
            csi?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesCsi>;
            downwardAPI?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesDownwardAPI>;
            emptyDir?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesEmptyDir>;
            fc?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesFc>;
            flexVolume?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesFlexVolume>;
            flocker?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesFlocker>;
            gcePersistentDisk?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesGcePersistentDisk>;
            gitRepo?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesGitRepo>;
            glusterfs?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesGlusterfs>;
            hostPath?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesHostPath>;
            iscsi?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesIscsi>;
            name: pulumi.Input<string>;
            nfs?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesNfs>;
            persistentVolumeClaim?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesPersistentVolumeClaim>;
            photonPersistentDisk?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesPhotonPersistentDisk>;
            portworxVolume?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesPortworxVolume>;
            projected?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesProjected>;
            quobyte?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesQuobyte>;
            rbd?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesRbd>;
            scaleIO?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesScaleIO>;
            secret?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesSecret>;
            storageos?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesStorageos>;
            vsphereVolume?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesVsphereVolume>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesAwsElasticBlockStore {
            fsType?: pulumi.Input<string>;
            partition?: pulumi.Input<number>;
            readOnly?: pulumi.Input<boolean>;
            volumeID: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesAzureDisk {
            cachingMode?: pulumi.Input<string>;
            diskName: pulumi.Input<string>;
            diskURI: pulumi.Input<string>;
            fsType?: pulumi.Input<string>;
            kind?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesAzureFile {
            readOnly?: pulumi.Input<boolean>;
            secretName: pulumi.Input<string>;
            shareName: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesCephfs {
            monitors: pulumi.Input<pulumi.Input<string>[]>;
            path?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretFile?: pulumi.Input<string>;
            secretRef?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesCephfsSecretRef>;
            user?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesCephfsSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesCinder {
            fsType?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesCinderSecretRef>;
            volumeID: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesCinderSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesConfigMap {
            defaultMode?: pulumi.Input<number>;
            items?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesConfigMapItems>[]>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesConfigMapItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesCsi {
            driver: pulumi.Input<string>;
            fsType?: pulumi.Input<string>;
            nodePublishSecretRef?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesCsiNodePublishSecretRef>;
            readOnly?: pulumi.Input<boolean>;
            volumeAttributes?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesCsiNodePublishSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesDownwardAPI {
            defaultMode?: pulumi.Input<number>;
            items?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesDownwardAPIItems>[]>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesDownwardAPIItems {
            fieldRef?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesDownwardAPIItemsFieldRef>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
            resourceFieldRef?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesDownwardAPIItemsResourceFieldRef>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesDownwardAPIItemsFieldRef {
            apiVersion?: pulumi.Input<string>;
            fieldPath: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesDownwardAPIItemsResourceFieldRef {
            containerName?: pulumi.Input<string>;
            divisor?: pulumi.Input<string>;
            resource: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesEmptyDir {
            medium?: pulumi.Input<string>;
            sizeLimit?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesFc {
            fsType?: pulumi.Input<string>;
            lun?: pulumi.Input<number>;
            readOnly?: pulumi.Input<boolean>;
            targetWWNs?: pulumi.Input<pulumi.Input<string>[]>;
            wwids?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesFlexVolume {
            driver: pulumi.Input<string>;
            fsType?: pulumi.Input<string>;
            options?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesFlexVolumeSecretRef>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesFlexVolumeSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesFlocker {
            datasetName?: pulumi.Input<string>;
            datasetUUID?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesGcePersistentDisk {
            fsType?: pulumi.Input<string>;
            partition?: pulumi.Input<number>;
            pdName: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesGitRepo {
            directory?: pulumi.Input<string>;
            repository: pulumi.Input<string>;
            revision?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesGlusterfs {
            endpoints: pulumi.Input<string>;
            path: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesHostPath {
            path: pulumi.Input<string>;
            type?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesIscsi {
            chapAuthDiscovery?: pulumi.Input<boolean>;
            chapAuthSession?: pulumi.Input<boolean>;
            fsType?: pulumi.Input<string>;
            initiatorName?: pulumi.Input<string>;
            iqn: pulumi.Input<string>;
            iscsiInterface?: pulumi.Input<string>;
            lun: pulumi.Input<number>;
            portals?: pulumi.Input<pulumi.Input<string>[]>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesIscsiSecretRef>;
            targetPortal: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesIscsiSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesNfs {
            path: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            server: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesPersistentVolumeClaim {
            claimName: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesPhotonPersistentDisk {
            fsType?: pulumi.Input<string>;
            pdID: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesPortworxVolume {
            fsType?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            volumeID: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesProjected {
            defaultMode?: pulumi.Input<number>;
            sources: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesProjectedSources>[]>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesProjectedSources {
            configMap?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesProjectedSourcesConfigMap>;
            downwardAPI?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardAPI>;
            secret?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesProjectedSourcesSecret>;
            serviceAccountToken?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesProjectedSourcesConfigMap {
            items?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesProjectedSourcesConfigMapItems>[]>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesProjectedSourcesConfigMapItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardAPI {
            items?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardAPIItems>[]>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardAPIItems {
            fieldRef?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardAPIItemsFieldRef>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
            resourceFieldRef?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardAPIItemsFieldRef {
            apiVersion?: pulumi.Input<string>;
            fieldPath: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef {
            containerName?: pulumi.Input<string>;
            divisor?: pulumi.Input<string>;
            resource: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesProjectedSourcesSecret {
            items?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesProjectedSourcesSecretItems>[]>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesProjectedSourcesSecretItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesProjectedSourcesServiceAccountToken {
            audience?: pulumi.Input<string>;
            expirationSeconds?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesQuobyte {
            group?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            registry: pulumi.Input<string>;
            tenant?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
            volume: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesRbd {
            fsType?: pulumi.Input<string>;
            image: pulumi.Input<string>;
            keyring?: pulumi.Input<string>;
            monitors: pulumi.Input<pulumi.Input<string>[]>;
            pool?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesRbdSecretRef>;
            user?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesRbdSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesScaleIO {
            fsType?: pulumi.Input<string>;
            gateway: pulumi.Input<string>;
            protectionDomain?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesScaleIOSecretRef>;
            sslEnabled?: pulumi.Input<boolean>;
            storageMode?: pulumi.Input<string>;
            storagePool?: pulumi.Input<string>;
            system: pulumi.Input<string>;
            volumeName?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesScaleIOSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesSecret {
            defaultMode?: pulumi.Input<number>;
            items?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesSecretItems>[]>;
            optional?: pulumi.Input<boolean>;
            secretName?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesSecretItems {
            key: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesStorageos {
            fsType?: pulumi.Input<string>;
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesStorageosSecretRef>;
            volumeName?: pulumi.Input<string>;
            volumeNamespace?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesStorageosSecretRef {
            name?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerDeploymentSpecTemplateSpecVolumesVsphereVolume {
            fsType?: pulumi.Input<string>;
            storagePolicyID?: pulumi.Input<string>;
            storagePolicyName?: pulumi.Input<string>;
            volumePath: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecControllerServiceAccount {
            annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface StackDefinitionSpecCustomresourcedefinitions {
            apiVersion?: pulumi.Input<string>;
            kind?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecDependsOn {
            crd?: pulumi.Input<string>;
            imagePullPolicy?: pulumi.Input<string>;
            imagePullSecrets?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecDependsOnImagePullSecrets>[]>;
            package?: pulumi.Input<string>;
            serviceAccount?: pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecDependsOnServiceAccount>;
            source?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecDependsOnImagePullSecrets {
            name?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecDependsOnServiceAccount {
            annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        export interface StackDefinitionSpecIcons {
            base64Data: pulumi.Input<string>;
            mediatype: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecMaintainers {
            email?: pulumi.Input<string>;
            name?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecOwners {
            email?: pulumi.Input<string>;
            name?: pulumi.Input<string>;
        }

        export interface StackDefinitionSpecPermissions {
            rules?: pulumi.Input<pulumi.Input<inputs.packages.v1alpha1.StackDefinitionSpecPermissionsRules>[]>;
        }

        export interface StackDefinitionSpecPermissionsRules {
            apiGroups?: pulumi.Input<pulumi.Input<string>[]>;
            nonResourceURLs?: pulumi.Input<pulumi.Input<string>[]>;
            resourceNames?: pulumi.Input<pulumi.Input<string>[]>;
            resources?: pulumi.Input<pulumi.Input<string>[]>;
            verbs: pulumi.Input<pulumi.Input<string>[]>;
        }

    }
}

export namespace storage {
    export namespace v1alpha1 {
        /**
         * BucketSpec specifies the desired state of a Bucket.
         */
        export interface BucketSpec {
            /**
             * A ClassReference specifies a resource class that will be used to dynamically provision a managed resource when the resource claim is created.
             */
            classRef?: pulumi.Input<inputs.storage.v1alpha1.BucketSpecClassRef>;
            /**
             * A ClassSelector specifies labels that will be used to select a resource class for this claim. If multiple classes match the labels one will be chosen at random.
             */
            classSelector?: pulumi.Input<inputs.storage.v1alpha1.BucketSpecClassSelector>;
            /**
             * LocalPermission specifies permissions granted to a provider specific service account for this bucket, e.g. Read, ReadWrite, or Write.
             */
            localPermission?: pulumi.Input<string>;
            /**
             * PredefinedACL specifies a predefined ACL (e.g. Private, ReadWrite, etc) to be applied to the bucket.
             */
            predefinedACL?: pulumi.Input<string>;
            /**
             * A ResourceReference specifies an existing managed resource, in any namespace, to which this resource claim should attempt to bind. Omit the resource reference to enable dynamic provisioning using a resource class; the resource reference will be automatically populated by Crossplane.
             */
            resourceRef?: pulumi.Input<inputs.storage.v1alpha1.BucketSpecResourceRef>;
            /**
             * WriteConnectionSecretToReference specifies the name of a Secret, in the same namespace as this resource claim, to which any connection details for this resource claim should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource bound to this resource claim.
             */
            writeConnectionSecretToRef?: pulumi.Input<inputs.storage.v1alpha1.BucketSpecWriteConnectionSecretToRef>;
        }

        /**
         * A ClassReference specifies a resource class that will be used to dynamically provision a managed resource when the resource claim is created.
         */
        export interface BucketSpecClassRef {
            /**
             * API version of the referent.
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: pulumi.Input<string>;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<string>;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: pulumi.Input<string>;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: pulumi.Input<string>;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: pulumi.Input<string>;
        }

        /**
         * A ClassSelector specifies labels that will be used to select a resource class for this claim. If multiple classes match the labels one will be chosen at random.
         */
        export interface BucketSpecClassSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.storage.v1alpha1.BucketSpecClassSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
         */
        export interface BucketSpecClassSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A ResourceReference specifies an existing managed resource, in any namespace, to which this resource claim should attempt to bind. Omit the resource reference to enable dynamic provisioning using a resource class; the resource reference will be automatically populated by Crossplane.
         */
        export interface BucketSpecResourceRef {
            /**
             * API version of the referent.
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: pulumi.Input<string>;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<string>;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: pulumi.Input<string>;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: pulumi.Input<string>;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: pulumi.Input<string>;
        }

        /**
         * WriteConnectionSecretToReference specifies the name of a Secret, in the same namespace as this resource claim, to which any connection details for this resource claim should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource bound to this resource claim.
         */
        export interface BucketSpecWriteConnectionSecretToRef {
            /**
             * Name of the secret.
             */
            name: pulumi.Input<string>;
        }

        /**
         * A ResourceClaimStatus represents the observed status of a resource claim.
         */
        export interface BucketStatus {
            /**
             * Phase represents the binding phase of a managed resource or claim. Unbindable resources cannot be bound, typically because they are currently unavailable, or still being created. Unbound resource are available for binding, and Bound resources have successfully bound to another resource.
             */
            bindingPhase?: pulumi.Input<string>;
            /**
             * Conditions of the resource.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.storage.v1alpha1.BucketStatusConditions>[]>;
        }

        /**
         * A Condition that may apply to a resource.
         */
        export interface BucketStatusConditions {
            /**
             * LastTransitionTime is the last time this condition transitioned from one status to another.
             */
            lastTransitionTime: pulumi.Input<string>;
            /**
             * A Message containing details about this condition's last transition from one status to another, if any.
             */
            message?: pulumi.Input<string>;
            /**
             * A Reason for this condition's last transition from one status to another.
             */
            reason: pulumi.Input<string>;
            /**
             * Status of this condition; is it currently True, False, or Unknown?
             */
            status: pulumi.Input<string>;
            /**
             * Type of this condition. At most one of each condition type may apply to a resource at any point in time.
             */
            type: pulumi.Input<string>;
        }
    }
}

export namespace workload {
    export namespace v1alpha1 {
        /**
         * KubernetesApplicationResourceSpec specifies the desired state of a KubernetesApplicationResource.
         */
        export interface KubernetesApplicationResourceSpec {
            /**
             * Secrets upon which this application resource depends. These secrets will be propagated to the Kubernetes cluster to which this application is scheduled.
             */
            secrets?: pulumi.Input<pulumi.Input<inputs.workload.v1alpha1.KubernetesApplicationResourceSpecSecrets>[]>;
            /**
             * Target to which this application has been scheduled.
             */
            targetRef?: pulumi.Input<inputs.workload.v1alpha1.KubernetesApplicationResourceSpecTargetRef>;
            /**
             * A Template for a Kubernetes resource to be submitted to the KubernetesCluster to which this application resource is scheduled. The resource must be understood by the KubernetesCluster. Crossplane requires only that the resource contains standard Kubernetes type and object metadata.
             */
            template: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
         */
        export interface KubernetesApplicationResourceSpecSecrets {
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
             */
            name?: pulumi.Input<string>;
        }

        /**
         * Target to which this application has been scheduled.
         */
        export interface KubernetesApplicationResourceSpecTargetRef {
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name: pulumi.Input<string>;
        }

        /**
         * KubernetesApplicationResourceStatus represents the observed state of a KubernetesApplicationResource.
         */
        export interface KubernetesApplicationResourceStatus {
            /**
             * A ConditionedStatus reflects the observed status of a resource. Only one condition of each type may exist.
             */
            conditionedStatus?: pulumi.Input<inputs.workload.v1alpha1.KubernetesApplicationResourceStatusConditionedStatus>;
            /**
             * Remote status of the resource templated by this application resource.
             */
            remote?: pulumi.Input<inputs.workload.v1alpha1.KubernetesApplicationResourceStatusRemote>;
            /**
             * State of the application.
             */
            state?: pulumi.Input<string>;
        }

        /**
         * A ConditionedStatus reflects the observed status of a resource. Only one condition of each type may exist.
         */
        export interface KubernetesApplicationResourceStatusConditionedStatus {
            /**
             * Conditions of the resource.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.workload.v1alpha1.KubernetesApplicationResourceStatusConditionedStatusConditions>[]>;
        }

        /**
         * A Condition that may apply to a resource.
         */
        export interface KubernetesApplicationResourceStatusConditionedStatusConditions {
            /**
             * LastTransitionTime is the last time this condition transitioned from one status to another.
             */
            lastTransitionTime: pulumi.Input<string>;
            /**
             * A Message containing details about this condition's last transition from one status to another, if any.
             */
            message?: pulumi.Input<string>;
            /**
             * A Reason for this condition's last transition from one status to another.
             */
            reason: pulumi.Input<string>;
            /**
             * Status of this condition; is it currently True, False, or Unknown?
             */
            status: pulumi.Input<string>;
            /**
             * Type of this condition. At most one of each condition type may apply to a resource at any point in time.
             */
            type: pulumi.Input<string>;
        }

        /**
         * Remote status of the resource templated by this application resource.
         */
        export interface KubernetesApplicationResourceStatusRemote {
            /**
             * Raw JSON representation of the remote status as a byte array.
             */
            raw?: pulumi.Input<string>;
        }

        /**
         * A KubernetesApplicationSpec specifies the resources of a Kubernetes application.
         */
        export interface KubernetesApplicationSpec {
            /**
             * ResourceSelector selects the KubernetesApplicationResources that are managed by this KubernetesApplication. Note that a KubernetesApplication will never adopt orphaned KubernetesApplicationResources, and thus this selector serves only to help match a KubernetesApplication to its KubernetesApplicationResources.
             */
            resourceSelector: pulumi.Input<inputs.workload.v1alpha1.KubernetesApplicationSpecResourceSelector>;
            /**
             * ResourceTemplates specifies a set of Kubernetes application resources managed by this application.
             */
            resourceTemplates: pulumi.Input<pulumi.Input<inputs.workload.v1alpha1.KubernetesApplicationSpecResourceTemplates>[]>;
            /**
             * Target to which this application has been scheduled.
             */
            targetRef?: pulumi.Input<inputs.workload.v1alpha1.KubernetesApplicationSpecTargetRef>;
            /**
             * TargetSelector selects the targets to which this application may be scheduled. Leave both match labels and expressions empty to match any target.
             */
            targetSelector?: pulumi.Input<inputs.workload.v1alpha1.KubernetesApplicationSpecTargetSelector>;
        }

        /**
         * ResourceSelector selects the KubernetesApplicationResources that are managed by this KubernetesApplication. Note that a KubernetesApplication will never adopt orphaned KubernetesApplicationResources, and thus this selector serves only to help match a KubernetesApplication to its KubernetesApplicationResources.
         */
        export interface KubernetesApplicationSpecResourceSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.workload.v1alpha1.KubernetesApplicationSpecResourceSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
         */
        export interface KubernetesApplicationSpecResourceSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A KubernetesApplicationResourceTemplate is used to instantiate new KubernetesApplicationResources.
         */
        export interface KubernetesApplicationSpecResourceTemplates {
            metadata?: pulumi.Input<{[key: string]: any}>;
            /**
             * KubernetesApplicationResourceSpec specifies the desired state of a KubernetesApplicationResource.
             */
            spec?: pulumi.Input<inputs.workload.v1alpha1.KubernetesApplicationSpecResourceTemplatesSpec>;
        }

        /**
         * KubernetesApplicationResourceSpec specifies the desired state of a KubernetesApplicationResource.
         */
        export interface KubernetesApplicationSpecResourceTemplatesSpec {
            /**
             * Secrets upon which this application resource depends. These secrets will be propagated to the Kubernetes cluster to which this application is scheduled.
             */
            secrets?: pulumi.Input<pulumi.Input<inputs.workload.v1alpha1.KubernetesApplicationSpecResourceTemplatesSpecSecrets>[]>;
            /**
             * Target to which this application has been scheduled.
             */
            targetRef?: pulumi.Input<inputs.workload.v1alpha1.KubernetesApplicationSpecResourceTemplatesSpecTargetRef>;
            /**
             * A Template for a Kubernetes resource to be submitted to the KubernetesCluster to which this application resource is scheduled. The resource must be understood by the KubernetesCluster. Crossplane requires only that the resource contains standard Kubernetes type and object metadata.
             */
            template: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
         */
        export interface KubernetesApplicationSpecResourceTemplatesSpecSecrets {
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
             */
            name?: pulumi.Input<string>;
        }

        /**
         * Target to which this application has been scheduled.
         */
        export interface KubernetesApplicationSpecResourceTemplatesSpecTargetRef {
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name: pulumi.Input<string>;
        }

        /**
         * Target to which this application has been scheduled.
         */
        export interface KubernetesApplicationSpecTargetRef {
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name: pulumi.Input<string>;
        }

        /**
         * TargetSelector selects the targets to which this application may be scheduled. Leave both match labels and expressions empty to match any target.
         */
        export interface KubernetesApplicationSpecTargetSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.workload.v1alpha1.KubernetesApplicationSpecTargetSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
         */
        export interface KubernetesApplicationSpecTargetSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * KubernetesApplicationStatus represents the observed state of a KubernetesApplication.
         */
        export interface KubernetesApplicationStatus {
            /**
             * A ConditionedStatus reflects the observed status of a resource. Only one condition of each type may exist.
             */
            conditionedStatus?: pulumi.Input<inputs.workload.v1alpha1.KubernetesApplicationStatusConditionedStatus>;
            /**
             * Desired resources of this application, i.e. the number of resources that match this application's resource selector.
             */
            desiredResources?: pulumi.Input<number>;
            /**
             * State of the application.
             */
            state?: pulumi.Input<string>;
            /**
             * Submitted resources of this workload, i.e. the subset of desired resources that have been successfully submitted to their scheduled Kubernetes cluster.
             */
            submittedResources?: pulumi.Input<number>;
        }

        /**
         * A ConditionedStatus reflects the observed status of a resource. Only one condition of each type may exist.
         */
        export interface KubernetesApplicationStatusConditionedStatus {
            /**
             * Conditions of the resource.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.workload.v1alpha1.KubernetesApplicationStatusConditionedStatusConditions>[]>;
        }

        /**
         * A Condition that may apply to a resource.
         */
        export interface KubernetesApplicationStatusConditionedStatusConditions {
            /**
             * LastTransitionTime is the last time this condition transitioned from one status to another.
             */
            lastTransitionTime: pulumi.Input<string>;
            /**
             * A Message containing details about this condition's last transition from one status to another, if any.
             */
            message?: pulumi.Input<string>;
            /**
             * A Reason for this condition's last transition from one status to another.
             */
            reason: pulumi.Input<string>;
            /**
             * Status of this condition; is it currently True, False, or Unknown?
             */
            status: pulumi.Input<string>;
            /**
             * Type of this condition. At most one of each condition type may apply to a resource at any point in time.
             */
            type: pulumi.Input<string>;
        }

        /**
         * A TargetSpec defines the common fields of objects used for exposing infrastructure to workloads that can be scheduled to.
         */
        export interface KubernetesTargetSpec {
            /**
             * A ResourceReference specifies an existing managed resource, in any namespace, which this target should attempt to propagate a connection secret from.
             */
            clusterRef?: pulumi.Input<inputs.workload.v1alpha1.KubernetesTargetSpecClusterRef>;
            /**
             * WriteConnectionSecretToReference specifies the name of a Secret, in the same namespace as this target, to which any connection details for this target should be written or already exist. Connection secrets referenced by a target should contain information for connecting to a resource that allows for scheduling of workloads.
             */
            connectionSecretRef?: pulumi.Input<inputs.workload.v1alpha1.KubernetesTargetSpecConnectionSecretRef>;
        }

        /**
         * A ResourceReference specifies an existing managed resource, in any namespace, which this target should attempt to propagate a connection secret from.
         */
        export interface KubernetesTargetSpecClusterRef {
            /**
             * API version of the referent.
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
             */
            fieldPath?: pulumi.Input<string>;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<string>;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
             */
            namespace?: pulumi.Input<string>;
            /**
             * Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: pulumi.Input<string>;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
             */
            uid?: pulumi.Input<string>;
        }

        /**
         * WriteConnectionSecretToReference specifies the name of a Secret, in the same namespace as this target, to which any connection details for this target should be written or already exist. Connection secrets referenced by a target should contain information for connecting to a resource that allows for scheduling of workloads.
         */
        export interface KubernetesTargetSpecConnectionSecretRef {
            /**
             * Name of the secret.
             */
            name: pulumi.Input<string>;
        }

        /**
         * A TargetStatus defines the observed status a target.
         */
        export interface KubernetesTargetStatus {
            /**
             * Conditions of the resource.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.workload.v1alpha1.KubernetesTargetStatusConditions>[]>;
        }

        /**
         * A Condition that may apply to a resource.
         */
        export interface KubernetesTargetStatusConditions {
            /**
             * LastTransitionTime is the last time this condition transitioned from one status to another.
             */
            lastTransitionTime: pulumi.Input<string>;
            /**
             * A Message containing details about this condition's last transition from one status to another, if any.
             */
            message?: pulumi.Input<string>;
            /**
             * A Reason for this condition's last transition from one status to another.
             */
            reason: pulumi.Input<string>;
            /**
             * Status of this condition; is it currently True, False, or Unknown?
             */
            status: pulumi.Input<string>;
            /**
             * Type of this condition. At most one of each condition type may apply to a resource at any point in time.
             */
            type: pulumi.Input<string>;
        }
    }
}
