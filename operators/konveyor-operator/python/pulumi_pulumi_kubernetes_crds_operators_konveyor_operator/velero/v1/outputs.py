# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from ... import _utilities, _tables
from . import outputs

__all__ = [
    'BackupSpec',
    'BackupSpecHooks',
    'BackupSpecHooksResources',
    'BackupSpecHooksResourcesLabelSelector',
    'BackupSpecHooksResourcesLabelSelectorMatchExpressions',
    'BackupSpecHooksResourcesPost',
    'BackupSpecHooksResourcesPostExec',
    'BackupSpecHooksResourcesPre',
    'BackupSpecHooksResourcesPreExec',
    'BackupSpecLabelSelector',
    'BackupSpecLabelSelectorMatchExpressions',
    'BackupStatus',
    'BackupStorageLocationSpec',
    'BackupStorageLocationSpecObjectStorage',
    'BackupStorageLocationStatus',
    'DeleteBackupRequestSpec',
    'DeleteBackupRequestStatus',
    'DownloadRequestSpec',
    'DownloadRequestSpecTarget',
    'DownloadRequestStatus',
    'PodVolumeBackupSpec',
    'PodVolumeBackupSpecPod',
    'PodVolumeBackupStatus',
    'PodVolumeBackupStatusProgress',
    'PodVolumeRestoreSpec',
    'PodVolumeRestoreSpecPod',
    'PodVolumeRestoreStatus',
    'PodVolumeRestoreStatusProgress',
    'ResticRepositorySpec',
    'ResticRepositoryStatus',
    'RestoreSpec',
    'RestoreSpecLabelSelector',
    'RestoreSpecLabelSelectorMatchExpressions',
    'RestoreStatus',
    'RestoreStatusPodVolumeRestoreErrors',
    'RestoreStatusPodVolumeRestoreVerifyErrors',
    'ScheduleSpec',
    'ScheduleSpecTemplate',
    'ScheduleSpecTemplateHooks',
    'ScheduleSpecTemplateHooksResources',
    'ScheduleSpecTemplateHooksResourcesLabelSelector',
    'ScheduleSpecTemplateHooksResourcesLabelSelectorMatchExpressions',
    'ScheduleSpecTemplateHooksResourcesPost',
    'ScheduleSpecTemplateHooksResourcesPostExec',
    'ScheduleSpecTemplateHooksResourcesPre',
    'ScheduleSpecTemplateHooksResourcesPreExec',
    'ScheduleSpecTemplateLabelSelector',
    'ScheduleSpecTemplateLabelSelectorMatchExpressions',
    'ScheduleStatus',
    'ServerStatusRequestStatus',
    'ServerStatusRequestStatusPlugins',
    'VolumeSnapshotLocationSpec',
    'VolumeSnapshotLocationStatus',
]

@pulumi.output_type
class BackupSpec(dict):
    """
    BackupSpec defines the specification for a Velero backup.
    """
    def __init__(__self__, *,
                 excluded_namespaces: Optional[Sequence[str]] = None,
                 excluded_resources: Optional[Sequence[str]] = None,
                 hooks: Optional['outputs.BackupSpecHooks'] = None,
                 include_cluster_resources: Optional[bool] = None,
                 included_namespaces: Optional[Sequence[str]] = None,
                 included_resources: Optional[Sequence[str]] = None,
                 label_selector: Optional['outputs.BackupSpecLabelSelector'] = None,
                 snapshot_volumes: Optional[bool] = None,
                 storage_location: Optional[str] = None,
                 ttl: Optional[str] = None,
                 volume_snapshot_locations: Optional[Sequence[str]] = None):
        """
        BackupSpec defines the specification for a Velero backup.
        :param Sequence[str] excluded_namespaces: ExcludedNamespaces contains a list of namespaces that are not included in the backup.
        :param Sequence[str] excluded_resources: ExcludedResources is a slice of resource names that are not included in the backup.
        :param 'BackupSpecHooksArgs' hooks: Hooks represent custom behaviors that should be executed at different phases of the backup.
        :param bool include_cluster_resources: IncludeClusterResources specifies whether cluster-scoped resources should be included for consideration in the backup.
        :param Sequence[str] included_namespaces: IncludedNamespaces is a slice of namespace names to include objects from. If empty, all namespaces are included.
        :param Sequence[str] included_resources: IncludedResources is a slice of resource names to include in the backup. If empty, all resources are included.
        :param 'BackupSpecLabelSelectorArgs' label_selector: LabelSelector is a metav1.LabelSelector to filter with when adding individual objects to the backup. If empty or nil, all objects are included. Optional.
        :param bool snapshot_volumes: SnapshotVolumes specifies whether to take cloud snapshots of any PV's referenced in the set of objects included in the Backup.
        :param str storage_location: StorageLocation is a string containing the name of a BackupStorageLocation where the backup should be stored.
        :param str ttl: TTL is a time.Duration-parseable string describing how long the Backup should be retained for.
        :param Sequence[str] volume_snapshot_locations: VolumeSnapshotLocations is a list containing names of VolumeSnapshotLocations associated with this backup.
        """
        if excluded_namespaces is not None:
            pulumi.set(__self__, "excluded_namespaces", excluded_namespaces)
        if excluded_resources is not None:
            pulumi.set(__self__, "excluded_resources", excluded_resources)
        if hooks is not None:
            pulumi.set(__self__, "hooks", hooks)
        if include_cluster_resources is not None:
            pulumi.set(__self__, "include_cluster_resources", include_cluster_resources)
        if included_namespaces is not None:
            pulumi.set(__self__, "included_namespaces", included_namespaces)
        if included_resources is not None:
            pulumi.set(__self__, "included_resources", included_resources)
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if snapshot_volumes is not None:
            pulumi.set(__self__, "snapshot_volumes", snapshot_volumes)
        if storage_location is not None:
            pulumi.set(__self__, "storage_location", storage_location)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if volume_snapshot_locations is not None:
            pulumi.set(__self__, "volume_snapshot_locations", volume_snapshot_locations)

    @property
    @pulumi.getter(name="excludedNamespaces")
    def excluded_namespaces(self) -> Optional[Sequence[str]]:
        """
        ExcludedNamespaces contains a list of namespaces that are not included in the backup.
        """
        return pulumi.get(self, "excluded_namespaces")

    @property
    @pulumi.getter(name="excludedResources")
    def excluded_resources(self) -> Optional[Sequence[str]]:
        """
        ExcludedResources is a slice of resource names that are not included in the backup.
        """
        return pulumi.get(self, "excluded_resources")

    @property
    @pulumi.getter
    def hooks(self) -> Optional['outputs.BackupSpecHooks']:
        """
        Hooks represent custom behaviors that should be executed at different phases of the backup.
        """
        return pulumi.get(self, "hooks")

    @property
    @pulumi.getter(name="includeClusterResources")
    def include_cluster_resources(self) -> Optional[bool]:
        """
        IncludeClusterResources specifies whether cluster-scoped resources should be included for consideration in the backup.
        """
        return pulumi.get(self, "include_cluster_resources")

    @property
    @pulumi.getter(name="includedNamespaces")
    def included_namespaces(self) -> Optional[Sequence[str]]:
        """
        IncludedNamespaces is a slice of namespace names to include objects from. If empty, all namespaces are included.
        """
        return pulumi.get(self, "included_namespaces")

    @property
    @pulumi.getter(name="includedResources")
    def included_resources(self) -> Optional[Sequence[str]]:
        """
        IncludedResources is a slice of resource names to include in the backup. If empty, all resources are included.
        """
        return pulumi.get(self, "included_resources")

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.BackupSpecLabelSelector']:
        """
        LabelSelector is a metav1.LabelSelector to filter with when adding individual objects to the backup. If empty or nil, all objects are included. Optional.
        """
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter(name="snapshotVolumes")
    def snapshot_volumes(self) -> Optional[bool]:
        """
        SnapshotVolumes specifies whether to take cloud snapshots of any PV's referenced in the set of objects included in the Backup.
        """
        return pulumi.get(self, "snapshot_volumes")

    @property
    @pulumi.getter(name="storageLocation")
    def storage_location(self) -> Optional[str]:
        """
        StorageLocation is a string containing the name of a BackupStorageLocation where the backup should be stored.
        """
        return pulumi.get(self, "storage_location")

    @property
    @pulumi.getter
    def ttl(self) -> Optional[str]:
        """
        TTL is a time.Duration-parseable string describing how long the Backup should be retained for.
        """
        return pulumi.get(self, "ttl")

    @property
    @pulumi.getter(name="volumeSnapshotLocations")
    def volume_snapshot_locations(self) -> Optional[Sequence[str]]:
        """
        VolumeSnapshotLocations is a list containing names of VolumeSnapshotLocations associated with this backup.
        """
        return pulumi.get(self, "volume_snapshot_locations")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackupSpecHooks(dict):
    """
    Hooks represent custom behaviors that should be executed at different phases of the backup.
    """
    def __init__(__self__, *,
                 resources: Optional[Sequence['outputs.BackupSpecHooksResources']] = None):
        """
        Hooks represent custom behaviors that should be executed at different phases of the backup.
        :param Sequence['BackupSpecHooksResourcesArgs'] resources: Resources are hooks that should be executed when backing up individual instances of a resource.
        """
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def resources(self) -> Optional[Sequence['outputs.BackupSpecHooksResources']]:
        """
        Resources are hooks that should be executed when backing up individual instances of a resource.
        """
        return pulumi.get(self, "resources")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackupSpecHooksResources(dict):
    """
    BackupResourceHookSpec defines one or more BackupResourceHooks that should be executed based on the rules defined for namespaces, resources, and label selector.
    """
    def __init__(__self__, *,
                 name: str,
                 excluded_namespaces: Optional[Sequence[str]] = None,
                 excluded_resources: Optional[Sequence[str]] = None,
                 included_namespaces: Optional[Sequence[str]] = None,
                 included_resources: Optional[Sequence[str]] = None,
                 label_selector: Optional['outputs.BackupSpecHooksResourcesLabelSelector'] = None,
                 post: Optional[Sequence['outputs.BackupSpecHooksResourcesPost']] = None,
                 pre: Optional[Sequence['outputs.BackupSpecHooksResourcesPre']] = None):
        """
        BackupResourceHookSpec defines one or more BackupResourceHooks that should be executed based on the rules defined for namespaces, resources, and label selector.
        :param str name: Name is the name of this hook.
        :param Sequence[str] excluded_namespaces: ExcludedNamespaces specifies the namespaces to which this hook spec does not apply.
        :param Sequence[str] excluded_resources: ExcludedResources specifies the resources to which this hook spec does not apply.
        :param Sequence[str] included_namespaces: IncludedNamespaces specifies the namespaces to which this hook spec applies. If empty, it applies to all namespaces.
        :param Sequence[str] included_resources: IncludedResources specifies the resources to which this hook spec applies. If empty, it applies to all resources.
        :param 'BackupSpecHooksResourcesLabelSelectorArgs' label_selector: LabelSelector, if specified, filters the resources to which this hook spec applies.
        :param Sequence['BackupSpecHooksResourcesPostArgs'] post: PostHooks is a list of BackupResourceHooks to execute after storing the item in the backup. These are executed after all "additional items" from item actions are processed.
        :param Sequence['BackupSpecHooksResourcesPreArgs'] pre: PreHooks is a list of BackupResourceHooks to execute prior to storing the item in the backup. These are executed before any "additional items" from item actions are processed.
        """
        pulumi.set(__self__, "name", name)
        if excluded_namespaces is not None:
            pulumi.set(__self__, "excluded_namespaces", excluded_namespaces)
        if excluded_resources is not None:
            pulumi.set(__self__, "excluded_resources", excluded_resources)
        if included_namespaces is not None:
            pulumi.set(__self__, "included_namespaces", included_namespaces)
        if included_resources is not None:
            pulumi.set(__self__, "included_resources", included_resources)
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if post is not None:
            pulumi.set(__self__, "post", post)
        if pre is not None:
            pulumi.set(__self__, "pre", pre)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name is the name of this hook.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="excludedNamespaces")
    def excluded_namespaces(self) -> Optional[Sequence[str]]:
        """
        ExcludedNamespaces specifies the namespaces to which this hook spec does not apply.
        """
        return pulumi.get(self, "excluded_namespaces")

    @property
    @pulumi.getter(name="excludedResources")
    def excluded_resources(self) -> Optional[Sequence[str]]:
        """
        ExcludedResources specifies the resources to which this hook spec does not apply.
        """
        return pulumi.get(self, "excluded_resources")

    @property
    @pulumi.getter(name="includedNamespaces")
    def included_namespaces(self) -> Optional[Sequence[str]]:
        """
        IncludedNamespaces specifies the namespaces to which this hook spec applies. If empty, it applies to all namespaces.
        """
        return pulumi.get(self, "included_namespaces")

    @property
    @pulumi.getter(name="includedResources")
    def included_resources(self) -> Optional[Sequence[str]]:
        """
        IncludedResources specifies the resources to which this hook spec applies. If empty, it applies to all resources.
        """
        return pulumi.get(self, "included_resources")

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.BackupSpecHooksResourcesLabelSelector']:
        """
        LabelSelector, if specified, filters the resources to which this hook spec applies.
        """
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def post(self) -> Optional[Sequence['outputs.BackupSpecHooksResourcesPost']]:
        """
        PostHooks is a list of BackupResourceHooks to execute after storing the item in the backup. These are executed after all "additional items" from item actions are processed.
        """
        return pulumi.get(self, "post")

    @property
    @pulumi.getter
    def pre(self) -> Optional[Sequence['outputs.BackupSpecHooksResourcesPre']]:
        """
        PreHooks is a list of BackupResourceHooks to execute prior to storing the item in the backup. These are executed before any "additional items" from item actions are processed.
        """
        return pulumi.get(self, "pre")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackupSpecHooksResourcesLabelSelector(dict):
    """
    LabelSelector, if specified, filters the resources to which this hook spec applies.
    """
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.BackupSpecHooksResourcesLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        LabelSelector, if specified, filters the resources to which this hook spec applies.
        :param Sequence['BackupSpecHooksResourcesLabelSelectorMatchExpressionsArgs'] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.BackupSpecHooksResourcesLabelSelectorMatchExpressions']]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackupSpecHooksResourcesLabelSelectorMatchExpressions(dict):
    """
    A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
    """
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Optional[Sequence[str]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param str key: key is the label key that the selector applies to.
        :param str operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param Sequence[str] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackupSpecHooksResourcesPost(dict):
    """
    BackupResourceHook defines a hook for a resource.
    """
    def __init__(__self__, *,
                 exec_: 'outputs.BackupSpecHooksResourcesPostExec'):
        """
        BackupResourceHook defines a hook for a resource.
        :param 'BackupSpecHooksResourcesPostExecArgs' exec_: Exec defines an exec hook.
        """
        pulumi.set(__self__, "exec_", exec_)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> 'outputs.BackupSpecHooksResourcesPostExec':
        """
        Exec defines an exec hook.
        """
        return pulumi.get(self, "exec_")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackupSpecHooksResourcesPostExec(dict):
    """
    Exec defines an exec hook.
    """
    def __init__(__self__, *,
                 command: Sequence[str],
                 container: Optional[str] = None,
                 on_error: Optional[str] = None,
                 timeout: Optional[str] = None):
        """
        Exec defines an exec hook.
        :param Sequence[str] command: Command is the command and arguments to execute.
        :param str container: Container is the container in the pod where the command should be executed. If not specified, the pod's first container is used.
        :param str on_error: OnError specifies how Velero should behave if it encounters an error executing this hook.
        :param str timeout: Timeout defines the maximum amount of time Velero should wait for the hook to complete before considering the execution a failure.
        """
        pulumi.set(__self__, "command", command)
        if container is not None:
            pulumi.set(__self__, "container", container)
        if on_error is not None:
            pulumi.set(__self__, "on_error", on_error)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def command(self) -> Sequence[str]:
        """
        Command is the command and arguments to execute.
        """
        return pulumi.get(self, "command")

    @property
    @pulumi.getter
    def container(self) -> Optional[str]:
        """
        Container is the container in the pod where the command should be executed. If not specified, the pod's first container is used.
        """
        return pulumi.get(self, "container")

    @property
    @pulumi.getter(name="onError")
    def on_error(self) -> Optional[str]:
        """
        OnError specifies how Velero should behave if it encounters an error executing this hook.
        """
        return pulumi.get(self, "on_error")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[str]:
        """
        Timeout defines the maximum amount of time Velero should wait for the hook to complete before considering the execution a failure.
        """
        return pulumi.get(self, "timeout")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackupSpecHooksResourcesPre(dict):
    """
    BackupResourceHook defines a hook for a resource.
    """
    def __init__(__self__, *,
                 exec_: 'outputs.BackupSpecHooksResourcesPreExec'):
        """
        BackupResourceHook defines a hook for a resource.
        :param 'BackupSpecHooksResourcesPreExecArgs' exec_: Exec defines an exec hook.
        """
        pulumi.set(__self__, "exec_", exec_)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> 'outputs.BackupSpecHooksResourcesPreExec':
        """
        Exec defines an exec hook.
        """
        return pulumi.get(self, "exec_")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackupSpecHooksResourcesPreExec(dict):
    """
    Exec defines an exec hook.
    """
    def __init__(__self__, *,
                 command: Sequence[str],
                 container: Optional[str] = None,
                 on_error: Optional[str] = None,
                 timeout: Optional[str] = None):
        """
        Exec defines an exec hook.
        :param Sequence[str] command: Command is the command and arguments to execute.
        :param str container: Container is the container in the pod where the command should be executed. If not specified, the pod's first container is used.
        :param str on_error: OnError specifies how Velero should behave if it encounters an error executing this hook.
        :param str timeout: Timeout defines the maximum amount of time Velero should wait for the hook to complete before considering the execution a failure.
        """
        pulumi.set(__self__, "command", command)
        if container is not None:
            pulumi.set(__self__, "container", container)
        if on_error is not None:
            pulumi.set(__self__, "on_error", on_error)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def command(self) -> Sequence[str]:
        """
        Command is the command and arguments to execute.
        """
        return pulumi.get(self, "command")

    @property
    @pulumi.getter
    def container(self) -> Optional[str]:
        """
        Container is the container in the pod where the command should be executed. If not specified, the pod's first container is used.
        """
        return pulumi.get(self, "container")

    @property
    @pulumi.getter(name="onError")
    def on_error(self) -> Optional[str]:
        """
        OnError specifies how Velero should behave if it encounters an error executing this hook.
        """
        return pulumi.get(self, "on_error")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[str]:
        """
        Timeout defines the maximum amount of time Velero should wait for the hook to complete before considering the execution a failure.
        """
        return pulumi.get(self, "timeout")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackupSpecLabelSelector(dict):
    """
    LabelSelector is a metav1.LabelSelector to filter with when adding individual objects to the backup. If empty or nil, all objects are included. Optional.
    """
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.BackupSpecLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        LabelSelector is a metav1.LabelSelector to filter with when adding individual objects to the backup. If empty or nil, all objects are included. Optional.
        :param Sequence['BackupSpecLabelSelectorMatchExpressionsArgs'] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.BackupSpecLabelSelectorMatchExpressions']]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackupSpecLabelSelectorMatchExpressions(dict):
    """
    A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
    """
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Optional[Sequence[str]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param str key: key is the label key that the selector applies to.
        :param str operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param Sequence[str] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackupStatus(dict):
    """
    BackupStatus captures the current status of a Velero backup.
    """
    def __init__(__self__, *,
                 completion_timestamp: Optional[str] = None,
                 errors: Optional[int] = None,
                 expiration: Optional[str] = None,
                 phase: Optional[str] = None,
                 start_timestamp: Optional[str] = None,
                 validation_errors: Optional[Sequence[str]] = None,
                 version: Optional[int] = None,
                 volume_snapshots_attempted: Optional[int] = None,
                 volume_snapshots_completed: Optional[int] = None,
                 warnings: Optional[int] = None):
        """
        BackupStatus captures the current status of a Velero backup.
        :param str completion_timestamp: CompletionTimestamp records the time a backup was completed. Completion time is recorded even on failed backups. Completion time is recorded before uploading the backup object. The server's time is used for CompletionTimestamps
        :param int errors: Errors is a count of all error messages that were generated during execution of the backup.  The actual errors are in the backup's log file in object storage.
        :param str expiration: Expiration is when this Backup is eligible for garbage-collection.
        :param str phase: Phase is the current state of the Backup.
        :param str start_timestamp: StartTimestamp records the time a backup was started. Separate from CreationTimestamp, since that value changes on restores. The server's time is used for StartTimestamps
        :param Sequence[str] validation_errors: ValidationErrors is a slice of all validation errors (if applicable).
        :param int version: Version is the backup format version.
        :param int volume_snapshots_attempted: VolumeSnapshotsAttempted is the total number of attempted volume snapshots for this backup.
        :param int volume_snapshots_completed: VolumeSnapshotsCompleted is the total number of successfully completed volume snapshots for this backup.
        :param int warnings: Warnings is a count of all warning messages that were generated during execution of the backup. The actual warnings are in the backup's log file in object storage.
        """
        if completion_timestamp is not None:
            pulumi.set(__self__, "completion_timestamp", completion_timestamp)
        if errors is not None:
            pulumi.set(__self__, "errors", errors)
        if expiration is not None:
            pulumi.set(__self__, "expiration", expiration)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if start_timestamp is not None:
            pulumi.set(__self__, "start_timestamp", start_timestamp)
        if validation_errors is not None:
            pulumi.set(__self__, "validation_errors", validation_errors)
        if version is not None:
            pulumi.set(__self__, "version", version)
        if volume_snapshots_attempted is not None:
            pulumi.set(__self__, "volume_snapshots_attempted", volume_snapshots_attempted)
        if volume_snapshots_completed is not None:
            pulumi.set(__self__, "volume_snapshots_completed", volume_snapshots_completed)
        if warnings is not None:
            pulumi.set(__self__, "warnings", warnings)

    @property
    @pulumi.getter(name="completionTimestamp")
    def completion_timestamp(self) -> Optional[str]:
        """
        CompletionTimestamp records the time a backup was completed. Completion time is recorded even on failed backups. Completion time is recorded before uploading the backup object. The server's time is used for CompletionTimestamps
        """
        return pulumi.get(self, "completion_timestamp")

    @property
    @pulumi.getter
    def errors(self) -> Optional[int]:
        """
        Errors is a count of all error messages that were generated during execution of the backup.  The actual errors are in the backup's log file in object storage.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def expiration(self) -> Optional[str]:
        """
        Expiration is when this Backup is eligible for garbage-collection.
        """
        return pulumi.get(self, "expiration")

    @property
    @pulumi.getter
    def phase(self) -> Optional[str]:
        """
        Phase is the current state of the Backup.
        """
        return pulumi.get(self, "phase")

    @property
    @pulumi.getter(name="startTimestamp")
    def start_timestamp(self) -> Optional[str]:
        """
        StartTimestamp records the time a backup was started. Separate from CreationTimestamp, since that value changes on restores. The server's time is used for StartTimestamps
        """
        return pulumi.get(self, "start_timestamp")

    @property
    @pulumi.getter(name="validationErrors")
    def validation_errors(self) -> Optional[Sequence[str]]:
        """
        ValidationErrors is a slice of all validation errors (if applicable).
        """
        return pulumi.get(self, "validation_errors")

    @property
    @pulumi.getter
    def version(self) -> Optional[int]:
        """
        Version is the backup format version.
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter(name="volumeSnapshotsAttempted")
    def volume_snapshots_attempted(self) -> Optional[int]:
        """
        VolumeSnapshotsAttempted is the total number of attempted volume snapshots for this backup.
        """
        return pulumi.get(self, "volume_snapshots_attempted")

    @property
    @pulumi.getter(name="volumeSnapshotsCompleted")
    def volume_snapshots_completed(self) -> Optional[int]:
        """
        VolumeSnapshotsCompleted is the total number of successfully completed volume snapshots for this backup.
        """
        return pulumi.get(self, "volume_snapshots_completed")

    @property
    @pulumi.getter
    def warnings(self) -> Optional[int]:
        """
        Warnings is a count of all warning messages that were generated during execution of the backup. The actual warnings are in the backup's log file in object storage.
        """
        return pulumi.get(self, "warnings")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackupStorageLocationSpec(dict):
    """
    BackupStorageLocationSpec defines the specification for a Velero BackupStorageLocation.
    """
    def __init__(__self__, *,
                 object_storage: 'outputs.BackupStorageLocationSpecObjectStorage',
                 provider: str,
                 access_mode: Optional[str] = None,
                 backup_sync_period: Optional[str] = None,
                 config: Optional[Mapping[str, str]] = None):
        """
        BackupStorageLocationSpec defines the specification for a Velero BackupStorageLocation.
        :param 'BackupStorageLocationSpecObjectStorageArgs' object_storage: ObjectStorageLocation specifies the settings necessary to connect to a provider's object storage.
        :param str provider: Provider is the provider of the backup storage.
        :param str access_mode: AccessMode defines the permissions for the backup storage location.
        :param str backup_sync_period: BackupSyncPeriod defines how frequently to sync backup API objects from object storage. A value of 0 disables sync.
        :param Mapping[str, str] config: Config is for provider-specific configuration fields.
        """
        pulumi.set(__self__, "object_storage", object_storage)
        pulumi.set(__self__, "provider", provider)
        if access_mode is not None:
            pulumi.set(__self__, "access_mode", access_mode)
        if backup_sync_period is not None:
            pulumi.set(__self__, "backup_sync_period", backup_sync_period)
        if config is not None:
            pulumi.set(__self__, "config", config)

    @property
    @pulumi.getter(name="objectStorage")
    def object_storage(self) -> 'outputs.BackupStorageLocationSpecObjectStorage':
        """
        ObjectStorageLocation specifies the settings necessary to connect to a provider's object storage.
        """
        return pulumi.get(self, "object_storage")

    @property
    @pulumi.getter
    def provider(self) -> str:
        """
        Provider is the provider of the backup storage.
        """
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter(name="accessMode")
    def access_mode(self) -> Optional[str]:
        """
        AccessMode defines the permissions for the backup storage location.
        """
        return pulumi.get(self, "access_mode")

    @property
    @pulumi.getter(name="backupSyncPeriod")
    def backup_sync_period(self) -> Optional[str]:
        """
        BackupSyncPeriod defines how frequently to sync backup API objects from object storage. A value of 0 disables sync.
        """
        return pulumi.get(self, "backup_sync_period")

    @property
    @pulumi.getter
    def config(self) -> Optional[Mapping[str, str]]:
        """
        Config is for provider-specific configuration fields.
        """
        return pulumi.get(self, "config")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackupStorageLocationSpecObjectStorage(dict):
    """
    ObjectStorageLocation specifies the settings necessary to connect to a provider's object storage.
    """
    def __init__(__self__, *,
                 bucket: str,
                 prefix: Optional[str] = None):
        """
        ObjectStorageLocation specifies the settings necessary to connect to a provider's object storage.
        :param str bucket: Bucket is the bucket to use for object storage.
        :param str prefix: Prefix is the path inside a bucket to use for Velero storage. Optional.
        """
        pulumi.set(__self__, "bucket", bucket)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        Bucket is the bucket to use for object storage.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        Prefix is the path inside a bucket to use for Velero storage. Optional.
        """
        return pulumi.get(self, "prefix")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class BackupStorageLocationStatus(dict):
    """
    BackupStorageLocationStatus describes the current status of a Velero BackupStorageLocation.
    """
    def __init__(__self__, *,
                 access_mode: Optional[str] = None,
                 last_synced_revision: Optional[str] = None,
                 last_synced_time: Optional[str] = None,
                 phase: Optional[str] = None):
        """
        BackupStorageLocationStatus describes the current status of a Velero BackupStorageLocation.
        :param str access_mode: AccessMode is an unused field. 
                Deprecated: there is now an AccessMode field on the Spec and this field will be removed entirely as of v2.0.
        :param str last_synced_revision: LastSyncedRevision is the value of the `metadata/revision` file in the backup storage location the last time the BSL's contents were synced into the cluster. 
                Deprecated: this field is no longer updated or used for detecting changes to the location's contents and will be removed entirely in v2.0.
        :param str last_synced_time: LastSyncedTime is the last time the contents of the location were synced into the cluster.
        :param str phase: Phase is the current state of the BackupStorageLocation.
        """
        if access_mode is not None:
            pulumi.set(__self__, "access_mode", access_mode)
        if last_synced_revision is not None:
            pulumi.set(__self__, "last_synced_revision", last_synced_revision)
        if last_synced_time is not None:
            pulumi.set(__self__, "last_synced_time", last_synced_time)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)

    @property
    @pulumi.getter(name="accessMode")
    def access_mode(self) -> Optional[str]:
        """
        AccessMode is an unused field. 
         Deprecated: there is now an AccessMode field on the Spec and this field will be removed entirely as of v2.0.
        """
        return pulumi.get(self, "access_mode")

    @property
    @pulumi.getter(name="lastSyncedRevision")
    def last_synced_revision(self) -> Optional[str]:
        """
        LastSyncedRevision is the value of the `metadata/revision` file in the backup storage location the last time the BSL's contents were synced into the cluster. 
         Deprecated: this field is no longer updated or used for detecting changes to the location's contents and will be removed entirely in v2.0.
        """
        return pulumi.get(self, "last_synced_revision")

    @property
    @pulumi.getter(name="lastSyncedTime")
    def last_synced_time(self) -> Optional[str]:
        """
        LastSyncedTime is the last time the contents of the location were synced into the cluster.
        """
        return pulumi.get(self, "last_synced_time")

    @property
    @pulumi.getter
    def phase(self) -> Optional[str]:
        """
        Phase is the current state of the BackupStorageLocation.
        """
        return pulumi.get(self, "phase")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DeleteBackupRequestSpec(dict):
    """
    DeleteBackupRequestSpec is the specification for which backups to delete.
    """
    def __init__(__self__, *,
                 backup_name: str):
        """
        DeleteBackupRequestSpec is the specification for which backups to delete.
        """
        pulumi.set(__self__, "backup_name", backup_name)

    @property
    @pulumi.getter(name="backupName")
    def backup_name(self) -> str:
        return pulumi.get(self, "backup_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DeleteBackupRequestStatus(dict):
    """
    DeleteBackupRequestStatus is the current status of a DeleteBackupRequest.
    """
    def __init__(__self__, *,
                 errors: Optional[Sequence[str]] = None,
                 phase: Optional[str] = None):
        """
        DeleteBackupRequestStatus is the current status of a DeleteBackupRequest.
        :param Sequence[str] errors: Errors contains any errors that were encountered during the deletion process.
        :param str phase: Phase is the current state of the DeleteBackupRequest.
        """
        if errors is not None:
            pulumi.set(__self__, "errors", errors)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)

    @property
    @pulumi.getter
    def errors(self) -> Optional[Sequence[str]]:
        """
        Errors contains any errors that were encountered during the deletion process.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def phase(self) -> Optional[str]:
        """
        Phase is the current state of the DeleteBackupRequest.
        """
        return pulumi.get(self, "phase")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DownloadRequestSpec(dict):
    """
    DownloadRequestSpec is the specification for a download request.
    """
    def __init__(__self__, *,
                 target: 'outputs.DownloadRequestSpecTarget'):
        """
        DownloadRequestSpec is the specification for a download request.
        :param 'DownloadRequestSpecTargetArgs' target: Target is what to download (e.g. logs for a backup).
        """
        pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def target(self) -> 'outputs.DownloadRequestSpecTarget':
        """
        Target is what to download (e.g. logs for a backup).
        """
        return pulumi.get(self, "target")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DownloadRequestSpecTarget(dict):
    """
    Target is what to download (e.g. logs for a backup).
    """
    def __init__(__self__, *,
                 kind: str,
                 name: str):
        """
        Target is what to download (e.g. logs for a backup).
        :param str kind: Kind is the type of file to download.
        :param str name: Name is the name of the kubernetes resource with which the file is associated.
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        Kind is the type of file to download.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name is the name of the kubernetes resource with which the file is associated.
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DownloadRequestStatus(dict):
    """
    DownloadRequestStatus is the current status of a DownloadRequest.
    """
    def __init__(__self__, *,
                 download_url: Optional[str] = None,
                 expiration: Optional[str] = None,
                 phase: Optional[str] = None):
        """
        DownloadRequestStatus is the current status of a DownloadRequest.
        :param str download_url: DownloadURL contains the pre-signed URL for the target file.
        :param str expiration: Expiration is when this DownloadRequest expires and can be deleted by the system.
        :param str phase: Phase is the current state of the DownloadRequest.
        """
        if download_url is not None:
            pulumi.set(__self__, "download_url", download_url)
        if expiration is not None:
            pulumi.set(__self__, "expiration", expiration)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)

    @property
    @pulumi.getter(name="downloadURL")
    def download_url(self) -> Optional[str]:
        """
        DownloadURL contains the pre-signed URL for the target file.
        """
        return pulumi.get(self, "download_url")

    @property
    @pulumi.getter
    def expiration(self) -> Optional[str]:
        """
        Expiration is when this DownloadRequest expires and can be deleted by the system.
        """
        return pulumi.get(self, "expiration")

    @property
    @pulumi.getter
    def phase(self) -> Optional[str]:
        """
        Phase is the current state of the DownloadRequest.
        """
        return pulumi.get(self, "phase")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PodVolumeBackupSpec(dict):
    """
    PodVolumeBackupSpec is the specification for a PodVolumeBackup.
    """
    def __init__(__self__, *,
                 backup_storage_location: str,
                 node: str,
                 pod: 'outputs.PodVolumeBackupSpecPod',
                 repo_identifier: str,
                 volume: str,
                 tags: Optional[Mapping[str, str]] = None):
        """
        PodVolumeBackupSpec is the specification for a PodVolumeBackup.
        :param str backup_storage_location: BackupStorageLocation is the name of the backup storage location where the restic repository is stored.
        :param str node: Node is the name of the node that the Pod is running on.
        :param 'PodVolumeBackupSpecPodArgs' pod: Pod is a reference to the pod containing the volume to be backed up.
        :param str repo_identifier: RepoIdentifier is the restic repository identifier.
        :param str volume: Volume is the name of the volume within the Pod to be backed up.
        :param Mapping[str, str] tags: Tags are a map of key-value pairs that should be applied to the volume backup as tags.
        """
        pulumi.set(__self__, "backup_storage_location", backup_storage_location)
        pulumi.set(__self__, "node", node)
        pulumi.set(__self__, "pod", pod)
        pulumi.set(__self__, "repo_identifier", repo_identifier)
        pulumi.set(__self__, "volume", volume)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="backupStorageLocation")
    def backup_storage_location(self) -> str:
        """
        BackupStorageLocation is the name of the backup storage location where the restic repository is stored.
        """
        return pulumi.get(self, "backup_storage_location")

    @property
    @pulumi.getter
    def node(self) -> str:
        """
        Node is the name of the node that the Pod is running on.
        """
        return pulumi.get(self, "node")

    @property
    @pulumi.getter
    def pod(self) -> 'outputs.PodVolumeBackupSpecPod':
        """
        Pod is a reference to the pod containing the volume to be backed up.
        """
        return pulumi.get(self, "pod")

    @property
    @pulumi.getter(name="repoIdentifier")
    def repo_identifier(self) -> str:
        """
        RepoIdentifier is the restic repository identifier.
        """
        return pulumi.get(self, "repo_identifier")

    @property
    @pulumi.getter
    def volume(self) -> str:
        """
        Volume is the name of the volume within the Pod to be backed up.
        """
        return pulumi.get(self, "volume")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Tags are a map of key-value pairs that should be applied to the volume backup as tags.
        """
        return pulumi.get(self, "tags")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PodVolumeBackupSpecPod(dict):
    """
    Pod is a reference to the pod containing the volume to be backed up.
    """
    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 resource_version: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        Pod is a reference to the pod containing the volume to be backed up.
        :param str api_version: API version of the referent.
        :param str field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param str kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param str resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param str uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[str]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PodVolumeBackupStatus(dict):
    """
    PodVolumeBackupStatus is the current status of a PodVolumeBackup.
    """
    def __init__(__self__, *,
                 completion_timestamp: Optional[str] = None,
                 message: Optional[str] = None,
                 path: Optional[str] = None,
                 phase: Optional[str] = None,
                 progress: Optional['outputs.PodVolumeBackupStatusProgress'] = None,
                 snapshot_id: Optional[str] = None,
                 start_timestamp: Optional[str] = None):
        """
        PodVolumeBackupStatus is the current status of a PodVolumeBackup.
        :param str completion_timestamp: CompletionTimestamp records the time a backup was completed. Completion time is recorded even on failed backups. Completion time is recorded before uploading the backup object. The server's time is used for CompletionTimestamps
        :param str message: Message is a message about the pod volume backup's status.
        :param str path: Path is the full path within the controller pod being backed up.
        :param str phase: Phase is the current state of the PodVolumeBackup.
        :param 'PodVolumeBackupStatusProgressArgs' progress: Progress holds the total number of bytes of the volume and the current number of backed up bytes. This can be used to display progress information about the backup operation.
        :param str snapshot_id: SnapshotID is the identifier for the snapshot of the pod volume.
        :param str start_timestamp: StartTimestamp records the time a backup was started. Separate from CreationTimestamp, since that value changes on restores. The server's time is used for StartTimestamps
        """
        if completion_timestamp is not None:
            pulumi.set(__self__, "completion_timestamp", completion_timestamp)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if progress is not None:
            pulumi.set(__self__, "progress", progress)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if start_timestamp is not None:
            pulumi.set(__self__, "start_timestamp", start_timestamp)

    @property
    @pulumi.getter(name="completionTimestamp")
    def completion_timestamp(self) -> Optional[str]:
        """
        CompletionTimestamp records the time a backup was completed. Completion time is recorded even on failed backups. Completion time is recorded before uploading the backup object. The server's time is used for CompletionTimestamps
        """
        return pulumi.get(self, "completion_timestamp")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Message is a message about the pod volume backup's status.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path is the full path within the controller pod being backed up.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def phase(self) -> Optional[str]:
        """
        Phase is the current state of the PodVolumeBackup.
        """
        return pulumi.get(self, "phase")

    @property
    @pulumi.getter
    def progress(self) -> Optional['outputs.PodVolumeBackupStatusProgress']:
        """
        Progress holds the total number of bytes of the volume and the current number of backed up bytes. This can be used to display progress information about the backup operation.
        """
        return pulumi.get(self, "progress")

    @property
    @pulumi.getter(name="snapshotID")
    def snapshot_id(self) -> Optional[str]:
        """
        SnapshotID is the identifier for the snapshot of the pod volume.
        """
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter(name="startTimestamp")
    def start_timestamp(self) -> Optional[str]:
        """
        StartTimestamp records the time a backup was started. Separate from CreationTimestamp, since that value changes on restores. The server's time is used for StartTimestamps
        """
        return pulumi.get(self, "start_timestamp")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PodVolumeBackupStatusProgress(dict):
    """
    Progress holds the total number of bytes of the volume and the current number of backed up bytes. This can be used to display progress information about the backup operation.
    """
    def __init__(__self__, *,
                 bytes_done: Optional[int] = None,
                 total_bytes: Optional[int] = None):
        """
        Progress holds the total number of bytes of the volume and the current number of backed up bytes. This can be used to display progress information about the backup operation.
        """
        if bytes_done is not None:
            pulumi.set(__self__, "bytes_done", bytes_done)
        if total_bytes is not None:
            pulumi.set(__self__, "total_bytes", total_bytes)

    @property
    @pulumi.getter(name="bytesDone")
    def bytes_done(self) -> Optional[int]:
        return pulumi.get(self, "bytes_done")

    @property
    @pulumi.getter(name="totalBytes")
    def total_bytes(self) -> Optional[int]:
        return pulumi.get(self, "total_bytes")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PodVolumeRestoreSpec(dict):
    """
    PodVolumeRestoreSpec is the specification for a PodVolumeRestore.
    """
    def __init__(__self__, *,
                 backup_storage_location: str,
                 pod: 'outputs.PodVolumeRestoreSpecPod',
                 repo_identifier: str,
                 snapshot_id: str,
                 volume: str):
        """
        PodVolumeRestoreSpec is the specification for a PodVolumeRestore.
        :param str backup_storage_location: BackupStorageLocation is the name of the backup storage location where the restic repository is stored.
        :param 'PodVolumeRestoreSpecPodArgs' pod: Pod is a reference to the pod containing the volume to be restored.
        :param str repo_identifier: RepoIdentifier is the restic repository identifier.
        :param str snapshot_id: SnapshotID is the ID of the volume snapshot to be restored.
        :param str volume: Volume is the name of the volume within the Pod to be restored.
        """
        pulumi.set(__self__, "backup_storage_location", backup_storage_location)
        pulumi.set(__self__, "pod", pod)
        pulumi.set(__self__, "repo_identifier", repo_identifier)
        pulumi.set(__self__, "snapshot_id", snapshot_id)
        pulumi.set(__self__, "volume", volume)

    @property
    @pulumi.getter(name="backupStorageLocation")
    def backup_storage_location(self) -> str:
        """
        BackupStorageLocation is the name of the backup storage location where the restic repository is stored.
        """
        return pulumi.get(self, "backup_storage_location")

    @property
    @pulumi.getter
    def pod(self) -> 'outputs.PodVolumeRestoreSpecPod':
        """
        Pod is a reference to the pod containing the volume to be restored.
        """
        return pulumi.get(self, "pod")

    @property
    @pulumi.getter(name="repoIdentifier")
    def repo_identifier(self) -> str:
        """
        RepoIdentifier is the restic repository identifier.
        """
        return pulumi.get(self, "repo_identifier")

    @property
    @pulumi.getter(name="snapshotID")
    def snapshot_id(self) -> str:
        """
        SnapshotID is the ID of the volume snapshot to be restored.
        """
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter
    def volume(self) -> str:
        """
        Volume is the name of the volume within the Pod to be restored.
        """
        return pulumi.get(self, "volume")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PodVolumeRestoreSpecPod(dict):
    """
    Pod is a reference to the pod containing the volume to be restored.
    """
    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 resource_version: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        Pod is a reference to the pod containing the volume to be restored.
        :param str api_version: API version of the referent.
        :param str field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param str kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param str resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param str uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[str]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PodVolumeRestoreStatus(dict):
    """
    PodVolumeRestoreStatus is the current status of a PodVolumeRestore.
    """
    def __init__(__self__, *,
                 completion_timestamp: Optional[str] = None,
                 errors: Optional[int] = None,
                 message: Optional[str] = None,
                 phase: Optional[str] = None,
                 progress: Optional['outputs.PodVolumeRestoreStatusProgress'] = None,
                 restic_pod: Optional[str] = None,
                 start_timestamp: Optional[str] = None,
                 verify_errors: Optional[int] = None):
        """
        PodVolumeRestoreStatus is the current status of a PodVolumeRestore.
        :param str completion_timestamp: CompletionTimestamp records the time a restore was completed. Completion time is recorded even on failed restores. The server's time is used for CompletionTimestamps
        :param int errors: Errors is a count of all error messages that were generated during execution of the pod volume restore. The actual errors are in the restic log
        :param str message: Message is a message about the pod volume restore's status.
        :param str phase: Phase is the current state of the PodVolumeRestore.
        :param 'PodVolumeRestoreStatusProgressArgs' progress: Progress holds the total number of bytes of the snapshot and the current number of restored bytes. This can be used to display progress information about the restore operation.
        :param str restic_pod: ResticPod is the name of the restic pod which processed the restore. Any errors referenced in Errors or VerifyErrors will be logged in this pod's log.
        :param str start_timestamp: StartTimestamp records the time a restore was started. The server's time is used for StartTimestamps
        :param int verify_errors: VerifyErrors is a count of all verification-related error messages that were generated during execution of the pod volume restore. The actual errors are in the restic log
        """
        if completion_timestamp is not None:
            pulumi.set(__self__, "completion_timestamp", completion_timestamp)
        if errors is not None:
            pulumi.set(__self__, "errors", errors)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if progress is not None:
            pulumi.set(__self__, "progress", progress)
        if restic_pod is not None:
            pulumi.set(__self__, "restic_pod", restic_pod)
        if start_timestamp is not None:
            pulumi.set(__self__, "start_timestamp", start_timestamp)
        if verify_errors is not None:
            pulumi.set(__self__, "verify_errors", verify_errors)

    @property
    @pulumi.getter(name="completionTimestamp")
    def completion_timestamp(self) -> Optional[str]:
        """
        CompletionTimestamp records the time a restore was completed. Completion time is recorded even on failed restores. The server's time is used for CompletionTimestamps
        """
        return pulumi.get(self, "completion_timestamp")

    @property
    @pulumi.getter
    def errors(self) -> Optional[int]:
        """
        Errors is a count of all error messages that were generated during execution of the pod volume restore. The actual errors are in the restic log
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Message is a message about the pod volume restore's status.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def phase(self) -> Optional[str]:
        """
        Phase is the current state of the PodVolumeRestore.
        """
        return pulumi.get(self, "phase")

    @property
    @pulumi.getter
    def progress(self) -> Optional['outputs.PodVolumeRestoreStatusProgress']:
        """
        Progress holds the total number of bytes of the snapshot and the current number of restored bytes. This can be used to display progress information about the restore operation.
        """
        return pulumi.get(self, "progress")

    @property
    @pulumi.getter(name="resticPod")
    def restic_pod(self) -> Optional[str]:
        """
        ResticPod is the name of the restic pod which processed the restore. Any errors referenced in Errors or VerifyErrors will be logged in this pod's log.
        """
        return pulumi.get(self, "restic_pod")

    @property
    @pulumi.getter(name="startTimestamp")
    def start_timestamp(self) -> Optional[str]:
        """
        StartTimestamp records the time a restore was started. The server's time is used for StartTimestamps
        """
        return pulumi.get(self, "start_timestamp")

    @property
    @pulumi.getter(name="verifyErrors")
    def verify_errors(self) -> Optional[int]:
        """
        VerifyErrors is a count of all verification-related error messages that were generated during execution of the pod volume restore. The actual errors are in the restic log
        """
        return pulumi.get(self, "verify_errors")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class PodVolumeRestoreStatusProgress(dict):
    """
    Progress holds the total number of bytes of the snapshot and the current number of restored bytes. This can be used to display progress information about the restore operation.
    """
    def __init__(__self__, *,
                 bytes_done: Optional[int] = None,
                 total_bytes: Optional[int] = None):
        """
        Progress holds the total number of bytes of the snapshot and the current number of restored bytes. This can be used to display progress information about the restore operation.
        """
        if bytes_done is not None:
            pulumi.set(__self__, "bytes_done", bytes_done)
        if total_bytes is not None:
            pulumi.set(__self__, "total_bytes", total_bytes)

    @property
    @pulumi.getter(name="bytesDone")
    def bytes_done(self) -> Optional[int]:
        return pulumi.get(self, "bytes_done")

    @property
    @pulumi.getter(name="totalBytes")
    def total_bytes(self) -> Optional[int]:
        return pulumi.get(self, "total_bytes")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ResticRepositorySpec(dict):
    """
    ResticRepositorySpec is the specification for a ResticRepository.
    """
    def __init__(__self__, *,
                 backup_storage_location: str,
                 maintenance_frequency: str,
                 restic_identifier: str,
                 volume_namespace: str):
        """
        ResticRepositorySpec is the specification for a ResticRepository.
        :param str backup_storage_location: BackupStorageLocation is the name of the BackupStorageLocation that should contain this repository.
        :param str maintenance_frequency: MaintenanceFrequency is how often maintenance should be run.
        :param str restic_identifier: ResticIdentifier is the full restic-compatible string for identifying this repository.
        :param str volume_namespace: VolumeNamespace is the namespace this restic repository contains pod volume backups for.
        """
        pulumi.set(__self__, "backup_storage_location", backup_storage_location)
        pulumi.set(__self__, "maintenance_frequency", maintenance_frequency)
        pulumi.set(__self__, "restic_identifier", restic_identifier)
        pulumi.set(__self__, "volume_namespace", volume_namespace)

    @property
    @pulumi.getter(name="backupStorageLocation")
    def backup_storage_location(self) -> str:
        """
        BackupStorageLocation is the name of the BackupStorageLocation that should contain this repository.
        """
        return pulumi.get(self, "backup_storage_location")

    @property
    @pulumi.getter(name="maintenanceFrequency")
    def maintenance_frequency(self) -> str:
        """
        MaintenanceFrequency is how often maintenance should be run.
        """
        return pulumi.get(self, "maintenance_frequency")

    @property
    @pulumi.getter(name="resticIdentifier")
    def restic_identifier(self) -> str:
        """
        ResticIdentifier is the full restic-compatible string for identifying this repository.
        """
        return pulumi.get(self, "restic_identifier")

    @property
    @pulumi.getter(name="volumeNamespace")
    def volume_namespace(self) -> str:
        """
        VolumeNamespace is the namespace this restic repository contains pod volume backups for.
        """
        return pulumi.get(self, "volume_namespace")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ResticRepositoryStatus(dict):
    """
    ResticRepositoryStatus is the current status of a ResticRepository.
    """
    def __init__(__self__, *,
                 last_maintenance_time: Optional[str] = None,
                 message: Optional[str] = None,
                 phase: Optional[str] = None):
        """
        ResticRepositoryStatus is the current status of a ResticRepository.
        :param str last_maintenance_time: LastMaintenanceTime is the last time maintenance was run.
        :param str message: Message is a message about the current status of the ResticRepository.
        :param str phase: Phase is the current state of the ResticRepository.
        """
        if last_maintenance_time is not None:
            pulumi.set(__self__, "last_maintenance_time", last_maintenance_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)

    @property
    @pulumi.getter(name="lastMaintenanceTime")
    def last_maintenance_time(self) -> Optional[str]:
        """
        LastMaintenanceTime is the last time maintenance was run.
        """
        return pulumi.get(self, "last_maintenance_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Message is a message about the current status of the ResticRepository.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def phase(self) -> Optional[str]:
        """
        Phase is the current state of the ResticRepository.
        """
        return pulumi.get(self, "phase")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RestoreSpec(dict):
    """
    RestoreSpec defines the specification for a Velero restore.
    """
    def __init__(__self__, *,
                 backup_name: str,
                 excluded_namespaces: Optional[Sequence[str]] = None,
                 excluded_resources: Optional[Sequence[str]] = None,
                 include_cluster_resources: Optional[bool] = None,
                 included_namespaces: Optional[Sequence[str]] = None,
                 included_resources: Optional[Sequence[str]] = None,
                 label_selector: Optional['outputs.RestoreSpecLabelSelector'] = None,
                 namespace_mapping: Optional[Mapping[str, str]] = None,
                 restore_pvs: Optional[bool] = None,
                 schedule_name: Optional[str] = None):
        """
        RestoreSpec defines the specification for a Velero restore.
        :param str backup_name: BackupName is the unique name of the Velero backup to restore from.
        :param Sequence[str] excluded_namespaces: ExcludedNamespaces contains a list of namespaces that are not included in the restore.
        :param Sequence[str] excluded_resources: ExcludedResources is a slice of resource names that are not included in the restore.
        :param bool include_cluster_resources: IncludeClusterResources specifies whether cluster-scoped resources should be included for consideration in the restore. If null, defaults to true.
        :param Sequence[str] included_namespaces: IncludedNamespaces is a slice of namespace names to include objects from. If empty, all namespaces are included.
        :param Sequence[str] included_resources: IncludedResources is a slice of resource names to include in the restore. If empty, all resources in the backup are included.
        :param 'RestoreSpecLabelSelectorArgs' label_selector: LabelSelector is a metav1.LabelSelector to filter with when restoring individual objects from the backup. If empty or nil, all objects are included. Optional.
        :param Mapping[str, str] namespace_mapping: NamespaceMapping is a map of source namespace names to target namespace names to restore into. Any source namespaces not included in the map will be restored into namespaces of the same name.
        :param bool restore_pvs: RestorePVs specifies whether to restore all included PVs from snapshot (via the cloudprovider).
        :param str schedule_name: ScheduleName is the unique name of the Velero schedule to restore from. If specified, and BackupName is empty, Velero will restore from the most recent successful backup created from this schedule.
        """
        pulumi.set(__self__, "backup_name", backup_name)
        if excluded_namespaces is not None:
            pulumi.set(__self__, "excluded_namespaces", excluded_namespaces)
        if excluded_resources is not None:
            pulumi.set(__self__, "excluded_resources", excluded_resources)
        if include_cluster_resources is not None:
            pulumi.set(__self__, "include_cluster_resources", include_cluster_resources)
        if included_namespaces is not None:
            pulumi.set(__self__, "included_namespaces", included_namespaces)
        if included_resources is not None:
            pulumi.set(__self__, "included_resources", included_resources)
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespace_mapping is not None:
            pulumi.set(__self__, "namespace_mapping", namespace_mapping)
        if restore_pvs is not None:
            pulumi.set(__self__, "restore_pvs", restore_pvs)
        if schedule_name is not None:
            pulumi.set(__self__, "schedule_name", schedule_name)

    @property
    @pulumi.getter(name="backupName")
    def backup_name(self) -> str:
        """
        BackupName is the unique name of the Velero backup to restore from.
        """
        return pulumi.get(self, "backup_name")

    @property
    @pulumi.getter(name="excludedNamespaces")
    def excluded_namespaces(self) -> Optional[Sequence[str]]:
        """
        ExcludedNamespaces contains a list of namespaces that are not included in the restore.
        """
        return pulumi.get(self, "excluded_namespaces")

    @property
    @pulumi.getter(name="excludedResources")
    def excluded_resources(self) -> Optional[Sequence[str]]:
        """
        ExcludedResources is a slice of resource names that are not included in the restore.
        """
        return pulumi.get(self, "excluded_resources")

    @property
    @pulumi.getter(name="includeClusterResources")
    def include_cluster_resources(self) -> Optional[bool]:
        """
        IncludeClusterResources specifies whether cluster-scoped resources should be included for consideration in the restore. If null, defaults to true.
        """
        return pulumi.get(self, "include_cluster_resources")

    @property
    @pulumi.getter(name="includedNamespaces")
    def included_namespaces(self) -> Optional[Sequence[str]]:
        """
        IncludedNamespaces is a slice of namespace names to include objects from. If empty, all namespaces are included.
        """
        return pulumi.get(self, "included_namespaces")

    @property
    @pulumi.getter(name="includedResources")
    def included_resources(self) -> Optional[Sequence[str]]:
        """
        IncludedResources is a slice of resource names to include in the restore. If empty, all resources in the backup are included.
        """
        return pulumi.get(self, "included_resources")

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.RestoreSpecLabelSelector']:
        """
        LabelSelector is a metav1.LabelSelector to filter with when restoring individual objects from the backup. If empty or nil, all objects are included. Optional.
        """
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter(name="namespaceMapping")
    def namespace_mapping(self) -> Optional[Mapping[str, str]]:
        """
        NamespaceMapping is a map of source namespace names to target namespace names to restore into. Any source namespaces not included in the map will be restored into namespaces of the same name.
        """
        return pulumi.get(self, "namespace_mapping")

    @property
    @pulumi.getter(name="restorePVs")
    def restore_pvs(self) -> Optional[bool]:
        """
        RestorePVs specifies whether to restore all included PVs from snapshot (via the cloudprovider).
        """
        return pulumi.get(self, "restore_pvs")

    @property
    @pulumi.getter(name="scheduleName")
    def schedule_name(self) -> Optional[str]:
        """
        ScheduleName is the unique name of the Velero schedule to restore from. If specified, and BackupName is empty, Velero will restore from the most recent successful backup created from this schedule.
        """
        return pulumi.get(self, "schedule_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RestoreSpecLabelSelector(dict):
    """
    LabelSelector is a metav1.LabelSelector to filter with when restoring individual objects from the backup. If empty or nil, all objects are included. Optional.
    """
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.RestoreSpecLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        LabelSelector is a metav1.LabelSelector to filter with when restoring individual objects from the backup. If empty or nil, all objects are included. Optional.
        :param Sequence['RestoreSpecLabelSelectorMatchExpressionsArgs'] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.RestoreSpecLabelSelectorMatchExpressions']]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RestoreSpecLabelSelectorMatchExpressions(dict):
    """
    A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
    """
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Optional[Sequence[str]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param str key: key is the label key that the selector applies to.
        :param str operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param Sequence[str] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RestoreStatus(dict):
    """
    RestoreStatus captures the current status of a Velero restore
    """
    def __init__(__self__, *,
                 errors: Optional[int] = None,
                 failure_reason: Optional[str] = None,
                 phase: Optional[str] = None,
                 pod_volume_restore_errors: Optional[Sequence['outputs.RestoreStatusPodVolumeRestoreErrors']] = None,
                 pod_volume_restore_verify_errors: Optional[Sequence['outputs.RestoreStatusPodVolumeRestoreVerifyErrors']] = None,
                 validation_errors: Optional[Sequence[str]] = None,
                 warnings: Optional[int] = None):
        """
        RestoreStatus captures the current status of a Velero restore
        :param int errors: Errors is a count of all error messages that were generated during execution of the restore. The actual errors are stored in object storage.
        :param str failure_reason: FailureReason is an error that caused the entire restore to fail.
        :param str phase: Phase is the current state of the Restore
        :param Sequence['RestoreStatusPodVolumeRestoreErrorsArgs'] pod_volume_restore_errors: PodVolumeRestoreErrors is a slice of all PodVolumeRestores with errors (errors encountered by restic when restoring a pod) (if applicable)
        :param Sequence['RestoreStatusPodVolumeRestoreVerifyErrorsArgs'] pod_volume_restore_verify_errors: PodVolumeRestoreVerifyErrors is a slice of all PodVolumeRestore errors from restore verification (errors encountered by restic when verifying a pod restore) (if applicable)
        :param Sequence[str] validation_errors: ValidationErrors is a slice of all validation errors (if applicable)
        :param int warnings: Warnings is a count of all warning messages that were generated during execution of the restore. The actual warnings are stored in object storage.
        """
        if errors is not None:
            pulumi.set(__self__, "errors", errors)
        if failure_reason is not None:
            pulumi.set(__self__, "failure_reason", failure_reason)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if pod_volume_restore_errors is not None:
            pulumi.set(__self__, "pod_volume_restore_errors", pod_volume_restore_errors)
        if pod_volume_restore_verify_errors is not None:
            pulumi.set(__self__, "pod_volume_restore_verify_errors", pod_volume_restore_verify_errors)
        if validation_errors is not None:
            pulumi.set(__self__, "validation_errors", validation_errors)
        if warnings is not None:
            pulumi.set(__self__, "warnings", warnings)

    @property
    @pulumi.getter
    def errors(self) -> Optional[int]:
        """
        Errors is a count of all error messages that were generated during execution of the restore. The actual errors are stored in object storage.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter(name="failureReason")
    def failure_reason(self) -> Optional[str]:
        """
        FailureReason is an error that caused the entire restore to fail.
        """
        return pulumi.get(self, "failure_reason")

    @property
    @pulumi.getter
    def phase(self) -> Optional[str]:
        """
        Phase is the current state of the Restore
        """
        return pulumi.get(self, "phase")

    @property
    @pulumi.getter(name="podVolumeRestoreErrors")
    def pod_volume_restore_errors(self) -> Optional[Sequence['outputs.RestoreStatusPodVolumeRestoreErrors']]:
        """
        PodVolumeRestoreErrors is a slice of all PodVolumeRestores with errors (errors encountered by restic when restoring a pod) (if applicable)
        """
        return pulumi.get(self, "pod_volume_restore_errors")

    @property
    @pulumi.getter(name="podVolumeRestoreVerifyErrors")
    def pod_volume_restore_verify_errors(self) -> Optional[Sequence['outputs.RestoreStatusPodVolumeRestoreVerifyErrors']]:
        """
        PodVolumeRestoreVerifyErrors is a slice of all PodVolumeRestore errors from restore verification (errors encountered by restic when verifying a pod restore) (if applicable)
        """
        return pulumi.get(self, "pod_volume_restore_verify_errors")

    @property
    @pulumi.getter(name="validationErrors")
    def validation_errors(self) -> Optional[Sequence[str]]:
        """
        ValidationErrors is a slice of all validation errors (if applicable)
        """
        return pulumi.get(self, "validation_errors")

    @property
    @pulumi.getter
    def warnings(self) -> Optional[int]:
        """
        Warnings is a count of all warning messages that were generated during execution of the restore. The actual warnings are stored in object storage.
        """
        return pulumi.get(self, "warnings")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RestoreStatusPodVolumeRestoreErrors(dict):
    """
    ObjectReference contains enough information to let you inspect or modify the referred object.
    """
    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 resource_version: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        ObjectReference contains enough information to let you inspect or modify the referred object.
        :param str api_version: API version of the referent.
        :param str field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param str kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param str resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param str uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[str]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RestoreStatusPodVolumeRestoreVerifyErrors(dict):
    """
    ObjectReference contains enough information to let you inspect or modify the referred object.
    """
    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 field_path: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 resource_version: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        ObjectReference contains enough information to let you inspect or modify the referred object.
        :param str api_version: API version of the referent.
        :param str field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param str kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param str namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param str resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param str uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[str]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[str]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ScheduleSpec(dict):
    """
    ScheduleSpec defines the specification for a Velero schedule
    """
    def __init__(__self__, *,
                 schedule: str,
                 template: 'outputs.ScheduleSpecTemplate'):
        """
        ScheduleSpec defines the specification for a Velero schedule
        :param str schedule: Schedule is a Cron expression defining when to run the Backup.
        :param 'ScheduleSpecTemplateArgs' template: Template is the definition of the Backup to be run on the provided schedule
        """
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "template", template)

    @property
    @pulumi.getter
    def schedule(self) -> str:
        """
        Schedule is a Cron expression defining when to run the Backup.
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter
    def template(self) -> 'outputs.ScheduleSpecTemplate':
        """
        Template is the definition of the Backup to be run on the provided schedule
        """
        return pulumi.get(self, "template")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ScheduleSpecTemplate(dict):
    """
    Template is the definition of the Backup to be run on the provided schedule
    """
    def __init__(__self__, *,
                 excluded_namespaces: Optional[Sequence[str]] = None,
                 excluded_resources: Optional[Sequence[str]] = None,
                 hooks: Optional['outputs.ScheduleSpecTemplateHooks'] = None,
                 include_cluster_resources: Optional[bool] = None,
                 included_namespaces: Optional[Sequence[str]] = None,
                 included_resources: Optional[Sequence[str]] = None,
                 label_selector: Optional['outputs.ScheduleSpecTemplateLabelSelector'] = None,
                 snapshot_volumes: Optional[bool] = None,
                 storage_location: Optional[str] = None,
                 ttl: Optional[str] = None,
                 volume_snapshot_locations: Optional[Sequence[str]] = None):
        """
        Template is the definition of the Backup to be run on the provided schedule
        :param Sequence[str] excluded_namespaces: ExcludedNamespaces contains a list of namespaces that are not included in the backup.
        :param Sequence[str] excluded_resources: ExcludedResources is a slice of resource names that are not included in the backup.
        :param 'ScheduleSpecTemplateHooksArgs' hooks: Hooks represent custom behaviors that should be executed at different phases of the backup.
        :param bool include_cluster_resources: IncludeClusterResources specifies whether cluster-scoped resources should be included for consideration in the backup.
        :param Sequence[str] included_namespaces: IncludedNamespaces is a slice of namespace names to include objects from. If empty, all namespaces are included.
        :param Sequence[str] included_resources: IncludedResources is a slice of resource names to include in the backup. If empty, all resources are included.
        :param 'ScheduleSpecTemplateLabelSelectorArgs' label_selector: LabelSelector is a metav1.LabelSelector to filter with when adding individual objects to the backup. If empty or nil, all objects are included. Optional.
        :param bool snapshot_volumes: SnapshotVolumes specifies whether to take cloud snapshots of any PV's referenced in the set of objects included in the Backup.
        :param str storage_location: StorageLocation is a string containing the name of a BackupStorageLocation where the backup should be stored.
        :param str ttl: TTL is a time.Duration-parseable string describing how long the Backup should be retained for.
        :param Sequence[str] volume_snapshot_locations: VolumeSnapshotLocations is a list containing names of VolumeSnapshotLocations associated with this backup.
        """
        if excluded_namespaces is not None:
            pulumi.set(__self__, "excluded_namespaces", excluded_namespaces)
        if excluded_resources is not None:
            pulumi.set(__self__, "excluded_resources", excluded_resources)
        if hooks is not None:
            pulumi.set(__self__, "hooks", hooks)
        if include_cluster_resources is not None:
            pulumi.set(__self__, "include_cluster_resources", include_cluster_resources)
        if included_namespaces is not None:
            pulumi.set(__self__, "included_namespaces", included_namespaces)
        if included_resources is not None:
            pulumi.set(__self__, "included_resources", included_resources)
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if snapshot_volumes is not None:
            pulumi.set(__self__, "snapshot_volumes", snapshot_volumes)
        if storage_location is not None:
            pulumi.set(__self__, "storage_location", storage_location)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if volume_snapshot_locations is not None:
            pulumi.set(__self__, "volume_snapshot_locations", volume_snapshot_locations)

    @property
    @pulumi.getter(name="excludedNamespaces")
    def excluded_namespaces(self) -> Optional[Sequence[str]]:
        """
        ExcludedNamespaces contains a list of namespaces that are not included in the backup.
        """
        return pulumi.get(self, "excluded_namespaces")

    @property
    @pulumi.getter(name="excludedResources")
    def excluded_resources(self) -> Optional[Sequence[str]]:
        """
        ExcludedResources is a slice of resource names that are not included in the backup.
        """
        return pulumi.get(self, "excluded_resources")

    @property
    @pulumi.getter
    def hooks(self) -> Optional['outputs.ScheduleSpecTemplateHooks']:
        """
        Hooks represent custom behaviors that should be executed at different phases of the backup.
        """
        return pulumi.get(self, "hooks")

    @property
    @pulumi.getter(name="includeClusterResources")
    def include_cluster_resources(self) -> Optional[bool]:
        """
        IncludeClusterResources specifies whether cluster-scoped resources should be included for consideration in the backup.
        """
        return pulumi.get(self, "include_cluster_resources")

    @property
    @pulumi.getter(name="includedNamespaces")
    def included_namespaces(self) -> Optional[Sequence[str]]:
        """
        IncludedNamespaces is a slice of namespace names to include objects from. If empty, all namespaces are included.
        """
        return pulumi.get(self, "included_namespaces")

    @property
    @pulumi.getter(name="includedResources")
    def included_resources(self) -> Optional[Sequence[str]]:
        """
        IncludedResources is a slice of resource names to include in the backup. If empty, all resources are included.
        """
        return pulumi.get(self, "included_resources")

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.ScheduleSpecTemplateLabelSelector']:
        """
        LabelSelector is a metav1.LabelSelector to filter with when adding individual objects to the backup. If empty or nil, all objects are included. Optional.
        """
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter(name="snapshotVolumes")
    def snapshot_volumes(self) -> Optional[bool]:
        """
        SnapshotVolumes specifies whether to take cloud snapshots of any PV's referenced in the set of objects included in the Backup.
        """
        return pulumi.get(self, "snapshot_volumes")

    @property
    @pulumi.getter(name="storageLocation")
    def storage_location(self) -> Optional[str]:
        """
        StorageLocation is a string containing the name of a BackupStorageLocation where the backup should be stored.
        """
        return pulumi.get(self, "storage_location")

    @property
    @pulumi.getter
    def ttl(self) -> Optional[str]:
        """
        TTL is a time.Duration-parseable string describing how long the Backup should be retained for.
        """
        return pulumi.get(self, "ttl")

    @property
    @pulumi.getter(name="volumeSnapshotLocations")
    def volume_snapshot_locations(self) -> Optional[Sequence[str]]:
        """
        VolumeSnapshotLocations is a list containing names of VolumeSnapshotLocations associated with this backup.
        """
        return pulumi.get(self, "volume_snapshot_locations")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ScheduleSpecTemplateHooks(dict):
    """
    Hooks represent custom behaviors that should be executed at different phases of the backup.
    """
    def __init__(__self__, *,
                 resources: Optional[Sequence['outputs.ScheduleSpecTemplateHooksResources']] = None):
        """
        Hooks represent custom behaviors that should be executed at different phases of the backup.
        :param Sequence['ScheduleSpecTemplateHooksResourcesArgs'] resources: Resources are hooks that should be executed when backing up individual instances of a resource.
        """
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def resources(self) -> Optional[Sequence['outputs.ScheduleSpecTemplateHooksResources']]:
        """
        Resources are hooks that should be executed when backing up individual instances of a resource.
        """
        return pulumi.get(self, "resources")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ScheduleSpecTemplateHooksResources(dict):
    """
    BackupResourceHookSpec defines one or more BackupResourceHooks that should be executed based on the rules defined for namespaces, resources, and label selector.
    """
    def __init__(__self__, *,
                 name: str,
                 excluded_namespaces: Optional[Sequence[str]] = None,
                 excluded_resources: Optional[Sequence[str]] = None,
                 included_namespaces: Optional[Sequence[str]] = None,
                 included_resources: Optional[Sequence[str]] = None,
                 label_selector: Optional['outputs.ScheduleSpecTemplateHooksResourcesLabelSelector'] = None,
                 post: Optional[Sequence['outputs.ScheduleSpecTemplateHooksResourcesPost']] = None,
                 pre: Optional[Sequence['outputs.ScheduleSpecTemplateHooksResourcesPre']] = None):
        """
        BackupResourceHookSpec defines one or more BackupResourceHooks that should be executed based on the rules defined for namespaces, resources, and label selector.
        :param str name: Name is the name of this hook.
        :param Sequence[str] excluded_namespaces: ExcludedNamespaces specifies the namespaces to which this hook spec does not apply.
        :param Sequence[str] excluded_resources: ExcludedResources specifies the resources to which this hook spec does not apply.
        :param Sequence[str] included_namespaces: IncludedNamespaces specifies the namespaces to which this hook spec applies. If empty, it applies to all namespaces.
        :param Sequence[str] included_resources: IncludedResources specifies the resources to which this hook spec applies. If empty, it applies to all resources.
        :param 'ScheduleSpecTemplateHooksResourcesLabelSelectorArgs' label_selector: LabelSelector, if specified, filters the resources to which this hook spec applies.
        :param Sequence['ScheduleSpecTemplateHooksResourcesPostArgs'] post: PostHooks is a list of BackupResourceHooks to execute after storing the item in the backup. These are executed after all "additional items" from item actions are processed.
        :param Sequence['ScheduleSpecTemplateHooksResourcesPreArgs'] pre: PreHooks is a list of BackupResourceHooks to execute prior to storing the item in the backup. These are executed before any "additional items" from item actions are processed.
        """
        pulumi.set(__self__, "name", name)
        if excluded_namespaces is not None:
            pulumi.set(__self__, "excluded_namespaces", excluded_namespaces)
        if excluded_resources is not None:
            pulumi.set(__self__, "excluded_resources", excluded_resources)
        if included_namespaces is not None:
            pulumi.set(__self__, "included_namespaces", included_namespaces)
        if included_resources is not None:
            pulumi.set(__self__, "included_resources", included_resources)
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if post is not None:
            pulumi.set(__self__, "post", post)
        if pre is not None:
            pulumi.set(__self__, "pre", pre)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name is the name of this hook.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="excludedNamespaces")
    def excluded_namespaces(self) -> Optional[Sequence[str]]:
        """
        ExcludedNamespaces specifies the namespaces to which this hook spec does not apply.
        """
        return pulumi.get(self, "excluded_namespaces")

    @property
    @pulumi.getter(name="excludedResources")
    def excluded_resources(self) -> Optional[Sequence[str]]:
        """
        ExcludedResources specifies the resources to which this hook spec does not apply.
        """
        return pulumi.get(self, "excluded_resources")

    @property
    @pulumi.getter(name="includedNamespaces")
    def included_namespaces(self) -> Optional[Sequence[str]]:
        """
        IncludedNamespaces specifies the namespaces to which this hook spec applies. If empty, it applies to all namespaces.
        """
        return pulumi.get(self, "included_namespaces")

    @property
    @pulumi.getter(name="includedResources")
    def included_resources(self) -> Optional[Sequence[str]]:
        """
        IncludedResources specifies the resources to which this hook spec applies. If empty, it applies to all resources.
        """
        return pulumi.get(self, "included_resources")

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.ScheduleSpecTemplateHooksResourcesLabelSelector']:
        """
        LabelSelector, if specified, filters the resources to which this hook spec applies.
        """
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def post(self) -> Optional[Sequence['outputs.ScheduleSpecTemplateHooksResourcesPost']]:
        """
        PostHooks is a list of BackupResourceHooks to execute after storing the item in the backup. These are executed after all "additional items" from item actions are processed.
        """
        return pulumi.get(self, "post")

    @property
    @pulumi.getter
    def pre(self) -> Optional[Sequence['outputs.ScheduleSpecTemplateHooksResourcesPre']]:
        """
        PreHooks is a list of BackupResourceHooks to execute prior to storing the item in the backup. These are executed before any "additional items" from item actions are processed.
        """
        return pulumi.get(self, "pre")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ScheduleSpecTemplateHooksResourcesLabelSelector(dict):
    """
    LabelSelector, if specified, filters the resources to which this hook spec applies.
    """
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.ScheduleSpecTemplateHooksResourcesLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        LabelSelector, if specified, filters the resources to which this hook spec applies.
        :param Sequence['ScheduleSpecTemplateHooksResourcesLabelSelectorMatchExpressionsArgs'] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.ScheduleSpecTemplateHooksResourcesLabelSelectorMatchExpressions']]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ScheduleSpecTemplateHooksResourcesLabelSelectorMatchExpressions(dict):
    """
    A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
    """
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Optional[Sequence[str]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param str key: key is the label key that the selector applies to.
        :param str operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param Sequence[str] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ScheduleSpecTemplateHooksResourcesPost(dict):
    """
    BackupResourceHook defines a hook for a resource.
    """
    def __init__(__self__, *,
                 exec_: 'outputs.ScheduleSpecTemplateHooksResourcesPostExec'):
        """
        BackupResourceHook defines a hook for a resource.
        :param 'ScheduleSpecTemplateHooksResourcesPostExecArgs' exec_: Exec defines an exec hook.
        """
        pulumi.set(__self__, "exec_", exec_)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> 'outputs.ScheduleSpecTemplateHooksResourcesPostExec':
        """
        Exec defines an exec hook.
        """
        return pulumi.get(self, "exec_")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ScheduleSpecTemplateHooksResourcesPostExec(dict):
    """
    Exec defines an exec hook.
    """
    def __init__(__self__, *,
                 command: Sequence[str],
                 container: Optional[str] = None,
                 on_error: Optional[str] = None,
                 timeout: Optional[str] = None):
        """
        Exec defines an exec hook.
        :param Sequence[str] command: Command is the command and arguments to execute.
        :param str container: Container is the container in the pod where the command should be executed. If not specified, the pod's first container is used.
        :param str on_error: OnError specifies how Velero should behave if it encounters an error executing this hook.
        :param str timeout: Timeout defines the maximum amount of time Velero should wait for the hook to complete before considering the execution a failure.
        """
        pulumi.set(__self__, "command", command)
        if container is not None:
            pulumi.set(__self__, "container", container)
        if on_error is not None:
            pulumi.set(__self__, "on_error", on_error)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def command(self) -> Sequence[str]:
        """
        Command is the command and arguments to execute.
        """
        return pulumi.get(self, "command")

    @property
    @pulumi.getter
    def container(self) -> Optional[str]:
        """
        Container is the container in the pod where the command should be executed. If not specified, the pod's first container is used.
        """
        return pulumi.get(self, "container")

    @property
    @pulumi.getter(name="onError")
    def on_error(self) -> Optional[str]:
        """
        OnError specifies how Velero should behave if it encounters an error executing this hook.
        """
        return pulumi.get(self, "on_error")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[str]:
        """
        Timeout defines the maximum amount of time Velero should wait for the hook to complete before considering the execution a failure.
        """
        return pulumi.get(self, "timeout")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ScheduleSpecTemplateHooksResourcesPre(dict):
    """
    BackupResourceHook defines a hook for a resource.
    """
    def __init__(__self__, *,
                 exec_: 'outputs.ScheduleSpecTemplateHooksResourcesPreExec'):
        """
        BackupResourceHook defines a hook for a resource.
        :param 'ScheduleSpecTemplateHooksResourcesPreExecArgs' exec_: Exec defines an exec hook.
        """
        pulumi.set(__self__, "exec_", exec_)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> 'outputs.ScheduleSpecTemplateHooksResourcesPreExec':
        """
        Exec defines an exec hook.
        """
        return pulumi.get(self, "exec_")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ScheduleSpecTemplateHooksResourcesPreExec(dict):
    """
    Exec defines an exec hook.
    """
    def __init__(__self__, *,
                 command: Sequence[str],
                 container: Optional[str] = None,
                 on_error: Optional[str] = None,
                 timeout: Optional[str] = None):
        """
        Exec defines an exec hook.
        :param Sequence[str] command: Command is the command and arguments to execute.
        :param str container: Container is the container in the pod where the command should be executed. If not specified, the pod's first container is used.
        :param str on_error: OnError specifies how Velero should behave if it encounters an error executing this hook.
        :param str timeout: Timeout defines the maximum amount of time Velero should wait for the hook to complete before considering the execution a failure.
        """
        pulumi.set(__self__, "command", command)
        if container is not None:
            pulumi.set(__self__, "container", container)
        if on_error is not None:
            pulumi.set(__self__, "on_error", on_error)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def command(self) -> Sequence[str]:
        """
        Command is the command and arguments to execute.
        """
        return pulumi.get(self, "command")

    @property
    @pulumi.getter
    def container(self) -> Optional[str]:
        """
        Container is the container in the pod where the command should be executed. If not specified, the pod's first container is used.
        """
        return pulumi.get(self, "container")

    @property
    @pulumi.getter(name="onError")
    def on_error(self) -> Optional[str]:
        """
        OnError specifies how Velero should behave if it encounters an error executing this hook.
        """
        return pulumi.get(self, "on_error")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[str]:
        """
        Timeout defines the maximum amount of time Velero should wait for the hook to complete before considering the execution a failure.
        """
        return pulumi.get(self, "timeout")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ScheduleSpecTemplateLabelSelector(dict):
    """
    LabelSelector is a metav1.LabelSelector to filter with when adding individual objects to the backup. If empty or nil, all objects are included. Optional.
    """
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.ScheduleSpecTemplateLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        LabelSelector is a metav1.LabelSelector to filter with when adding individual objects to the backup. If empty or nil, all objects are included. Optional.
        :param Sequence['ScheduleSpecTemplateLabelSelectorMatchExpressionsArgs'] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.ScheduleSpecTemplateLabelSelectorMatchExpressions']]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ScheduleSpecTemplateLabelSelectorMatchExpressions(dict):
    """
    A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
    """
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Optional[Sequence[str]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param str key: key is the label key that the selector applies to.
        :param str operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param Sequence[str] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ScheduleStatus(dict):
    """
    ScheduleStatus captures the current state of a Velero schedule
    """
    def __init__(__self__, *,
                 last_backup: Optional[str] = None,
                 phase: Optional[str] = None,
                 validation_errors: Optional[Sequence[str]] = None):
        """
        ScheduleStatus captures the current state of a Velero schedule
        :param str last_backup: LastBackup is the last time a Backup was run for this Schedule schedule
        :param str phase: Phase is the current phase of the Schedule
        :param Sequence[str] validation_errors: ValidationErrors is a slice of all validation errors (if applicable)
        """
        if last_backup is not None:
            pulumi.set(__self__, "last_backup", last_backup)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if validation_errors is not None:
            pulumi.set(__self__, "validation_errors", validation_errors)

    @property
    @pulumi.getter(name="lastBackup")
    def last_backup(self) -> Optional[str]:
        """
        LastBackup is the last time a Backup was run for this Schedule schedule
        """
        return pulumi.get(self, "last_backup")

    @property
    @pulumi.getter
    def phase(self) -> Optional[str]:
        """
        Phase is the current phase of the Schedule
        """
        return pulumi.get(self, "phase")

    @property
    @pulumi.getter(name="validationErrors")
    def validation_errors(self) -> Optional[Sequence[str]]:
        """
        ValidationErrors is a slice of all validation errors (if applicable)
        """
        return pulumi.get(self, "validation_errors")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ServerStatusRequestStatus(dict):
    """
    ServerStatusRequestStatus is the current status of a ServerStatusRequest.
    """
    def __init__(__self__, *,
                 phase: Optional[str] = None,
                 plugins: Optional[Sequence['outputs.ServerStatusRequestStatusPlugins']] = None,
                 processed_timestamp: Optional[str] = None,
                 server_version: Optional[str] = None):
        """
        ServerStatusRequestStatus is the current status of a ServerStatusRequest.
        :param str phase: Phase is the current lifecycle phase of the ServerStatusRequest.
        :param Sequence['ServerStatusRequestStatusPluginsArgs'] plugins: Plugins list information about the plugins running on the Velero server
        :param str processed_timestamp: ProcessedTimestamp is when the ServerStatusRequest was processed by the ServerStatusRequestController.
        :param str server_version: ServerVersion is the Velero server version.
        """
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if plugins is not None:
            pulumi.set(__self__, "plugins", plugins)
        if processed_timestamp is not None:
            pulumi.set(__self__, "processed_timestamp", processed_timestamp)
        if server_version is not None:
            pulumi.set(__self__, "server_version", server_version)

    @property
    @pulumi.getter
    def phase(self) -> Optional[str]:
        """
        Phase is the current lifecycle phase of the ServerStatusRequest.
        """
        return pulumi.get(self, "phase")

    @property
    @pulumi.getter
    def plugins(self) -> Optional[Sequence['outputs.ServerStatusRequestStatusPlugins']]:
        """
        Plugins list information about the plugins running on the Velero server
        """
        return pulumi.get(self, "plugins")

    @property
    @pulumi.getter(name="processedTimestamp")
    def processed_timestamp(self) -> Optional[str]:
        """
        ProcessedTimestamp is when the ServerStatusRequest was processed by the ServerStatusRequestController.
        """
        return pulumi.get(self, "processed_timestamp")

    @property
    @pulumi.getter(name="serverVersion")
    def server_version(self) -> Optional[str]:
        """
        ServerVersion is the Velero server version.
        """
        return pulumi.get(self, "server_version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ServerStatusRequestStatusPlugins(dict):
    """
    PluginInfo contains attributes of a Velero plugin
    """
    def __init__(__self__, *,
                 kind: str,
                 name: str):
        """
        PluginInfo contains attributes of a Velero plugin
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def kind(self) -> str:
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class VolumeSnapshotLocationSpec(dict):
    """
    VolumeSnapshotLocationSpec defines the specification for a Velero VolumeSnapshotLocation.
    """
    def __init__(__self__, *,
                 provider: str,
                 config: Optional[Mapping[str, str]] = None):
        """
        VolumeSnapshotLocationSpec defines the specification for a Velero VolumeSnapshotLocation.
        :param str provider: Provider is the provider of the volume storage.
        :param Mapping[str, str] config: Config is for provider-specific configuration fields.
        """
        pulumi.set(__self__, "provider", provider)
        if config is not None:
            pulumi.set(__self__, "config", config)

    @property
    @pulumi.getter
    def provider(self) -> str:
        """
        Provider is the provider of the volume storage.
        """
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter
    def config(self) -> Optional[Mapping[str, str]]:
        """
        Config is for provider-specific configuration fields.
        """
        return pulumi.get(self, "config")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class VolumeSnapshotLocationStatus(dict):
    """
    VolumeSnapshotLocationStatus describes the current status of a Velero VolumeSnapshotLocation.
    """
    def __init__(__self__, *,
                 phase: Optional[str] = None):
        """
        VolumeSnapshotLocationStatus describes the current status of a Velero VolumeSnapshotLocation.
        :param str phase: VolumeSnapshotLocationPhase is the lifecyle phase of a Velero VolumeSnapshotLocation.
        """
        if phase is not None:
            pulumi.set(__self__, "phase", phase)

    @property
    @pulumi.getter
    def phase(self) -> Optional[str]:
        """
        VolumeSnapshotLocationPhase is the lifecyle phase of a Velero VolumeSnapshotLocation.
        """
        return pulumi.get(self, "phase")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


