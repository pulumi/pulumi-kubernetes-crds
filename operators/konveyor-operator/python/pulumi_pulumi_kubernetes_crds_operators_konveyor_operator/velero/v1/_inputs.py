# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from ... import _utilities, _tables

__all__ = [
    'BackupSpecArgs',
    'BackupSpecHooksArgs',
    'BackupSpecHooksResourcesArgs',
    'BackupSpecHooksResourcesLabelSelectorArgs',
    'BackupSpecHooksResourcesLabelSelectorMatchExpressionsArgs',
    'BackupSpecHooksResourcesPostArgs',
    'BackupSpecHooksResourcesPostExecArgs',
    'BackupSpecHooksResourcesPreArgs',
    'BackupSpecHooksResourcesPreExecArgs',
    'BackupSpecLabelSelectorArgs',
    'BackupSpecLabelSelectorMatchExpressionsArgs',
    'BackupStatusArgs',
    'BackupStatusProgressArgs',
    'BackupStorageLocationSpecArgs',
    'BackupStorageLocationSpecObjectStorageArgs',
    'BackupStorageLocationStatusArgs',
    'DeleteBackupRequestSpecArgs',
    'DeleteBackupRequestStatusArgs',
    'DownloadRequestSpecArgs',
    'DownloadRequestSpecTargetArgs',
    'DownloadRequestStatusArgs',
    'PodVolumeBackupSpecArgs',
    'PodVolumeBackupSpecPodArgs',
    'PodVolumeBackupStatusArgs',
    'PodVolumeBackupStatusProgressArgs',
    'PodVolumeRestoreSpecArgs',
    'PodVolumeRestoreSpecPodArgs',
    'PodVolumeRestoreStatusArgs',
    'PodVolumeRestoreStatusProgressArgs',
    'ResticRepositorySpecArgs',
    'ResticRepositoryStatusArgs',
    'RestoreSpecArgs',
    'RestoreSpecLabelSelectorArgs',
    'RestoreSpecLabelSelectorMatchExpressionsArgs',
    'RestoreStatusArgs',
    'RestoreStatusPodVolumeRestoreErrorsArgs',
    'RestoreStatusPodVolumeRestoreVerifyErrorsArgs',
    'ScheduleSpecArgs',
    'ScheduleSpecTemplateArgs',
    'ScheduleSpecTemplateHooksArgs',
    'ScheduleSpecTemplateHooksResourcesArgs',
    'ScheduleSpecTemplateHooksResourcesLabelSelectorArgs',
    'ScheduleSpecTemplateHooksResourcesLabelSelectorMatchExpressionsArgs',
    'ScheduleSpecTemplateHooksResourcesPostArgs',
    'ScheduleSpecTemplateHooksResourcesPostExecArgs',
    'ScheduleSpecTemplateHooksResourcesPreArgs',
    'ScheduleSpecTemplateHooksResourcesPreExecArgs',
    'ScheduleSpecTemplateLabelSelectorArgs',
    'ScheduleSpecTemplateLabelSelectorMatchExpressionsArgs',
    'ScheduleStatusArgs',
    'ServerStatusRequestStatusArgs',
    'ServerStatusRequestStatusPluginsArgs',
    'VolumeSnapshotLocationSpecArgs',
    'VolumeSnapshotLocationStatusArgs',
]

@pulumi.input_type
class BackupSpecArgs:
    def __init__(__self__, *,
                 excluded_namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 excluded_resources: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 hooks: Optional[pulumi.Input['BackupSpecHooksArgs']] = None,
                 include_cluster_resources: Optional[pulumi.Input[bool]] = None,
                 included_namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_resources: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 label_selector: Optional[pulumi.Input['BackupSpecLabelSelectorArgs']] = None,
                 snapshot_volumes: Optional[pulumi.Input[bool]] = None,
                 storage_location: Optional[pulumi.Input[str]] = None,
                 ttl: Optional[pulumi.Input[str]] = None,
                 volume_snapshot_locations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        BackupSpec defines the specification for a Velero backup.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_namespaces: ExcludedNamespaces contains a list of namespaces that are not included in the backup.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_resources: ExcludedResources is a slice of resource names that are not included in the backup.
        :param pulumi.Input['BackupSpecHooksArgs'] hooks: Hooks represent custom behaviors that should be executed at different phases of the backup.
        :param pulumi.Input[bool] include_cluster_resources: IncludeClusterResources specifies whether cluster-scoped resources should be included for consideration in the backup.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_namespaces: IncludedNamespaces is a slice of namespace names to include objects from. If empty, all namespaces are included.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_resources: IncludedResources is a slice of resource names to include in the backup. If empty, all resources are included.
        :param pulumi.Input['BackupSpecLabelSelectorArgs'] label_selector: LabelSelector is a metav1.LabelSelector to filter with when adding individual objects to the backup. If empty or nil, all objects are included. Optional.
        :param pulumi.Input[bool] snapshot_volumes: SnapshotVolumes specifies whether to take cloud snapshots of any PV's referenced in the set of objects included in the Backup.
        :param pulumi.Input[str] storage_location: StorageLocation is a string containing the name of a BackupStorageLocation where the backup should be stored.
        :param pulumi.Input[str] ttl: TTL is a time.Duration-parseable string describing how long the Backup should be retained for.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] volume_snapshot_locations: VolumeSnapshotLocations is a list containing names of VolumeSnapshotLocations associated with this backup.
        """
        if excluded_namespaces is not None:
            pulumi.set(__self__, "excluded_namespaces", excluded_namespaces)
        if excluded_resources is not None:
            pulumi.set(__self__, "excluded_resources", excluded_resources)
        if hooks is not None:
            pulumi.set(__self__, "hooks", hooks)
        if include_cluster_resources is not None:
            pulumi.set(__self__, "include_cluster_resources", include_cluster_resources)
        if included_namespaces is not None:
            pulumi.set(__self__, "included_namespaces", included_namespaces)
        if included_resources is not None:
            pulumi.set(__self__, "included_resources", included_resources)
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if snapshot_volumes is not None:
            pulumi.set(__self__, "snapshot_volumes", snapshot_volumes)
        if storage_location is not None:
            pulumi.set(__self__, "storage_location", storage_location)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if volume_snapshot_locations is not None:
            pulumi.set(__self__, "volume_snapshot_locations", volume_snapshot_locations)

    @property
    @pulumi.getter(name="excludedNamespaces")
    def excluded_namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        ExcludedNamespaces contains a list of namespaces that are not included in the backup.
        """
        return pulumi.get(self, "excluded_namespaces")

    @excluded_namespaces.setter
    def excluded_namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_namespaces", value)

    @property
    @pulumi.getter(name="excludedResources")
    def excluded_resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        ExcludedResources is a slice of resource names that are not included in the backup.
        """
        return pulumi.get(self, "excluded_resources")

    @excluded_resources.setter
    def excluded_resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_resources", value)

    @property
    @pulumi.getter
    def hooks(self) -> Optional[pulumi.Input['BackupSpecHooksArgs']]:
        """
        Hooks represent custom behaviors that should be executed at different phases of the backup.
        """
        return pulumi.get(self, "hooks")

    @hooks.setter
    def hooks(self, value: Optional[pulumi.Input['BackupSpecHooksArgs']]):
        pulumi.set(self, "hooks", value)

    @property
    @pulumi.getter(name="includeClusterResources")
    def include_cluster_resources(self) -> Optional[pulumi.Input[bool]]:
        """
        IncludeClusterResources specifies whether cluster-scoped resources should be included for consideration in the backup.
        """
        return pulumi.get(self, "include_cluster_resources")

    @include_cluster_resources.setter
    def include_cluster_resources(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_cluster_resources", value)

    @property
    @pulumi.getter(name="includedNamespaces")
    def included_namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        IncludedNamespaces is a slice of namespace names to include objects from. If empty, all namespaces are included.
        """
        return pulumi.get(self, "included_namespaces")

    @included_namespaces.setter
    def included_namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_namespaces", value)

    @property
    @pulumi.getter(name="includedResources")
    def included_resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        IncludedResources is a slice of resource names to include in the backup. If empty, all resources are included.
        """
        return pulumi.get(self, "included_resources")

    @included_resources.setter
    def included_resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_resources", value)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['BackupSpecLabelSelectorArgs']]:
        """
        LabelSelector is a metav1.LabelSelector to filter with when adding individual objects to the backup. If empty or nil, all objects are included. Optional.
        """
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['BackupSpecLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter(name="snapshotVolumes")
    def snapshot_volumes(self) -> Optional[pulumi.Input[bool]]:
        """
        SnapshotVolumes specifies whether to take cloud snapshots of any PV's referenced in the set of objects included in the Backup.
        """
        return pulumi.get(self, "snapshot_volumes")

    @snapshot_volumes.setter
    def snapshot_volumes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "snapshot_volumes", value)

    @property
    @pulumi.getter(name="storageLocation")
    def storage_location(self) -> Optional[pulumi.Input[str]]:
        """
        StorageLocation is a string containing the name of a BackupStorageLocation where the backup should be stored.
        """
        return pulumi.get(self, "storage_location")

    @storage_location.setter
    def storage_location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_location", value)

    @property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[str]]:
        """
        TTL is a time.Duration-parseable string describing how long the Backup should be retained for.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ttl", value)

    @property
    @pulumi.getter(name="volumeSnapshotLocations")
    def volume_snapshot_locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        VolumeSnapshotLocations is a list containing names of VolumeSnapshotLocations associated with this backup.
        """
        return pulumi.get(self, "volume_snapshot_locations")

    @volume_snapshot_locations.setter
    def volume_snapshot_locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "volume_snapshot_locations", value)


@pulumi.input_type
class BackupSpecHooksArgs:
    def __init__(__self__, *,
                 resources: Optional[pulumi.Input[Sequence[pulumi.Input['BackupSpecHooksResourcesArgs']]]] = None):
        """
        Hooks represent custom behaviors that should be executed at different phases of the backup.
        :param pulumi.Input[Sequence[pulumi.Input['BackupSpecHooksResourcesArgs']]] resources: Resources are hooks that should be executed when backing up individual instances of a resource.
        """
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BackupSpecHooksResourcesArgs']]]]:
        """
        Resources are hooks that should be executed when backing up individual instances of a resource.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BackupSpecHooksResourcesArgs']]]]):
        pulumi.set(self, "resources", value)


@pulumi.input_type
class BackupSpecHooksResourcesArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 excluded_namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 excluded_resources: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_resources: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 label_selector: Optional[pulumi.Input['BackupSpecHooksResourcesLabelSelectorArgs']] = None,
                 post: Optional[pulumi.Input[Sequence[pulumi.Input['BackupSpecHooksResourcesPostArgs']]]] = None,
                 pre: Optional[pulumi.Input[Sequence[pulumi.Input['BackupSpecHooksResourcesPreArgs']]]] = None):
        """
        BackupResourceHookSpec defines one or more BackupResourceHooks that should be executed based on the rules defined for namespaces, resources, and label selector.
        :param pulumi.Input[str] name: Name is the name of this hook.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_namespaces: ExcludedNamespaces specifies the namespaces to which this hook spec does not apply.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_resources: ExcludedResources specifies the resources to which this hook spec does not apply.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_namespaces: IncludedNamespaces specifies the namespaces to which this hook spec applies. If empty, it applies to all namespaces.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_resources: IncludedResources specifies the resources to which this hook spec applies. If empty, it applies to all resources.
        :param pulumi.Input['BackupSpecHooksResourcesLabelSelectorArgs'] label_selector: LabelSelector, if specified, filters the resources to which this hook spec applies.
        :param pulumi.Input[Sequence[pulumi.Input['BackupSpecHooksResourcesPostArgs']]] post: PostHooks is a list of BackupResourceHooks to execute after storing the item in the backup. These are executed after all "additional items" from item actions are processed.
        :param pulumi.Input[Sequence[pulumi.Input['BackupSpecHooksResourcesPreArgs']]] pre: PreHooks is a list of BackupResourceHooks to execute prior to storing the item in the backup. These are executed before any "additional items" from item actions are processed.
        """
        pulumi.set(__self__, "name", name)
        if excluded_namespaces is not None:
            pulumi.set(__self__, "excluded_namespaces", excluded_namespaces)
        if excluded_resources is not None:
            pulumi.set(__self__, "excluded_resources", excluded_resources)
        if included_namespaces is not None:
            pulumi.set(__self__, "included_namespaces", included_namespaces)
        if included_resources is not None:
            pulumi.set(__self__, "included_resources", included_resources)
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if post is not None:
            pulumi.set(__self__, "post", post)
        if pre is not None:
            pulumi.set(__self__, "pre", pre)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name is the name of this hook.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="excludedNamespaces")
    def excluded_namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        ExcludedNamespaces specifies the namespaces to which this hook spec does not apply.
        """
        return pulumi.get(self, "excluded_namespaces")

    @excluded_namespaces.setter
    def excluded_namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_namespaces", value)

    @property
    @pulumi.getter(name="excludedResources")
    def excluded_resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        ExcludedResources specifies the resources to which this hook spec does not apply.
        """
        return pulumi.get(self, "excluded_resources")

    @excluded_resources.setter
    def excluded_resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_resources", value)

    @property
    @pulumi.getter(name="includedNamespaces")
    def included_namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        IncludedNamespaces specifies the namespaces to which this hook spec applies. If empty, it applies to all namespaces.
        """
        return pulumi.get(self, "included_namespaces")

    @included_namespaces.setter
    def included_namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_namespaces", value)

    @property
    @pulumi.getter(name="includedResources")
    def included_resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        IncludedResources specifies the resources to which this hook spec applies. If empty, it applies to all resources.
        """
        return pulumi.get(self, "included_resources")

    @included_resources.setter
    def included_resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_resources", value)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['BackupSpecHooksResourcesLabelSelectorArgs']]:
        """
        LabelSelector, if specified, filters the resources to which this hook spec applies.
        """
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['BackupSpecHooksResourcesLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def post(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BackupSpecHooksResourcesPostArgs']]]]:
        """
        PostHooks is a list of BackupResourceHooks to execute after storing the item in the backup. These are executed after all "additional items" from item actions are processed.
        """
        return pulumi.get(self, "post")

    @post.setter
    def post(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BackupSpecHooksResourcesPostArgs']]]]):
        pulumi.set(self, "post", value)

    @property
    @pulumi.getter
    def pre(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BackupSpecHooksResourcesPreArgs']]]]:
        """
        PreHooks is a list of BackupResourceHooks to execute prior to storing the item in the backup. These are executed before any "additional items" from item actions are processed.
        """
        return pulumi.get(self, "pre")

    @pre.setter
    def pre(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BackupSpecHooksResourcesPreArgs']]]]):
        pulumi.set(self, "pre", value)


@pulumi.input_type
class BackupSpecHooksResourcesLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['BackupSpecHooksResourcesLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        LabelSelector, if specified, filters the resources to which this hook spec applies.
        :param pulumi.Input[Sequence[pulumi.Input['BackupSpecHooksResourcesLabelSelectorMatchExpressionsArgs']]] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BackupSpecHooksResourcesLabelSelectorMatchExpressionsArgs']]]]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BackupSpecHooksResourcesLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class BackupSpecHooksResourcesLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param pulumi.Input[str] key: key is the label key that the selector applies to.
        :param pulumi.Input[str] operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class BackupSpecHooksResourcesPostArgs:
    def __init__(__self__, *,
                 exec_: pulumi.Input['BackupSpecHooksResourcesPostExecArgs']):
        """
        BackupResourceHook defines a hook for a resource.
        :param pulumi.Input['BackupSpecHooksResourcesPostExecArgs'] exec_: Exec defines an exec hook.
        """
        pulumi.set(__self__, "exec_", exec_)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> pulumi.Input['BackupSpecHooksResourcesPostExecArgs']:
        """
        Exec defines an exec hook.
        """
        return pulumi.get(self, "exec_")

    @exec_.setter
    def exec_(self, value: pulumi.Input['BackupSpecHooksResourcesPostExecArgs']):
        pulumi.set(self, "exec_", value)


@pulumi.input_type
class BackupSpecHooksResourcesPostExecArgs:
    def __init__(__self__, *,
                 command: pulumi.Input[Sequence[pulumi.Input[str]]],
                 container: Optional[pulumi.Input[str]] = None,
                 on_error: Optional[pulumi.Input[str]] = None,
                 timeout: Optional[pulumi.Input[str]] = None):
        """
        Exec defines an exec hook.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] command: Command is the command and arguments to execute.
        :param pulumi.Input[str] container: Container is the container in the pod where the command should be executed. If not specified, the pod's first container is used.
        :param pulumi.Input[str] on_error: OnError specifies how Velero should behave if it encounters an error executing this hook.
        :param pulumi.Input[str] timeout: Timeout defines the maximum amount of time Velero should wait for the hook to complete before considering the execution a failure.
        """
        pulumi.set(__self__, "command", command)
        if container is not None:
            pulumi.set(__self__, "container", container)
        if on_error is not None:
            pulumi.set(__self__, "on_error", on_error)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def command(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Command is the command and arguments to execute.
        """
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "command", value)

    @property
    @pulumi.getter
    def container(self) -> Optional[pulumi.Input[str]]:
        """
        Container is the container in the pod where the command should be executed. If not specified, the pod's first container is used.
        """
        return pulumi.get(self, "container")

    @container.setter
    def container(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "container", value)

    @property
    @pulumi.getter(name="onError")
    def on_error(self) -> Optional[pulumi.Input[str]]:
        """
        OnError specifies how Velero should behave if it encounters an error executing this hook.
        """
        return pulumi.get(self, "on_error")

    @on_error.setter
    def on_error(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "on_error", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Timeout defines the maximum amount of time Velero should wait for the hook to complete before considering the execution a failure.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeout", value)


@pulumi.input_type
class BackupSpecHooksResourcesPreArgs:
    def __init__(__self__, *,
                 exec_: pulumi.Input['BackupSpecHooksResourcesPreExecArgs']):
        """
        BackupResourceHook defines a hook for a resource.
        :param pulumi.Input['BackupSpecHooksResourcesPreExecArgs'] exec_: Exec defines an exec hook.
        """
        pulumi.set(__self__, "exec_", exec_)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> pulumi.Input['BackupSpecHooksResourcesPreExecArgs']:
        """
        Exec defines an exec hook.
        """
        return pulumi.get(self, "exec_")

    @exec_.setter
    def exec_(self, value: pulumi.Input['BackupSpecHooksResourcesPreExecArgs']):
        pulumi.set(self, "exec_", value)


@pulumi.input_type
class BackupSpecHooksResourcesPreExecArgs:
    def __init__(__self__, *,
                 command: pulumi.Input[Sequence[pulumi.Input[str]]],
                 container: Optional[pulumi.Input[str]] = None,
                 on_error: Optional[pulumi.Input[str]] = None,
                 timeout: Optional[pulumi.Input[str]] = None):
        """
        Exec defines an exec hook.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] command: Command is the command and arguments to execute.
        :param pulumi.Input[str] container: Container is the container in the pod where the command should be executed. If not specified, the pod's first container is used.
        :param pulumi.Input[str] on_error: OnError specifies how Velero should behave if it encounters an error executing this hook.
        :param pulumi.Input[str] timeout: Timeout defines the maximum amount of time Velero should wait for the hook to complete before considering the execution a failure.
        """
        pulumi.set(__self__, "command", command)
        if container is not None:
            pulumi.set(__self__, "container", container)
        if on_error is not None:
            pulumi.set(__self__, "on_error", on_error)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def command(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Command is the command and arguments to execute.
        """
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "command", value)

    @property
    @pulumi.getter
    def container(self) -> Optional[pulumi.Input[str]]:
        """
        Container is the container in the pod where the command should be executed. If not specified, the pod's first container is used.
        """
        return pulumi.get(self, "container")

    @container.setter
    def container(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "container", value)

    @property
    @pulumi.getter(name="onError")
    def on_error(self) -> Optional[pulumi.Input[str]]:
        """
        OnError specifies how Velero should behave if it encounters an error executing this hook.
        """
        return pulumi.get(self, "on_error")

    @on_error.setter
    def on_error(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "on_error", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Timeout defines the maximum amount of time Velero should wait for the hook to complete before considering the execution a failure.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeout", value)


@pulumi.input_type
class BackupSpecLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['BackupSpecLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        LabelSelector is a metav1.LabelSelector to filter with when adding individual objects to the backup. If empty or nil, all objects are included. Optional.
        :param pulumi.Input[Sequence[pulumi.Input['BackupSpecLabelSelectorMatchExpressionsArgs']]] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BackupSpecLabelSelectorMatchExpressionsArgs']]]]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BackupSpecLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class BackupSpecLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param pulumi.Input[str] key: key is the label key that the selector applies to.
        :param pulumi.Input[str] operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class BackupStatusArgs:
    def __init__(__self__, *,
                 completion_timestamp: Optional[pulumi.Input[str]] = None,
                 errors: Optional[pulumi.Input[int]] = None,
                 expiration: Optional[pulumi.Input[str]] = None,
                 format_version: Optional[pulumi.Input[str]] = None,
                 phase: Optional[pulumi.Input[str]] = None,
                 progress: Optional[pulumi.Input['BackupStatusProgressArgs']] = None,
                 start_timestamp: Optional[pulumi.Input[str]] = None,
                 validation_errors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 version: Optional[pulumi.Input[int]] = None,
                 volume_snapshots_attempted: Optional[pulumi.Input[int]] = None,
                 volume_snapshots_completed: Optional[pulumi.Input[int]] = None,
                 warnings: Optional[pulumi.Input[int]] = None):
        """
        BackupStatus captures the current status of a Velero backup.
        :param pulumi.Input[str] completion_timestamp: CompletionTimestamp records the time a backup was completed. Completion time is recorded even on failed backups. Completion time is recorded before uploading the backup object. The server's time is used for CompletionTimestamps
        :param pulumi.Input[int] errors: Errors is a count of all error messages that were generated during execution of the backup.  The actual errors are in the backup's log file in object storage.
        :param pulumi.Input[str] expiration: Expiration is when this Backup is eligible for garbage-collection.
        :param pulumi.Input[str] format_version: FormatVersion is the backup format version, including major, minor, and patch version.
        :param pulumi.Input[str] phase: Phase is the current state of the Backup.
        :param pulumi.Input['BackupStatusProgressArgs'] progress: Progress contains information about the backup's execution progress. Note that this information is best-effort only -- if Velero fails to update it during a backup for any reason, it may be inaccurate/stale.
        :param pulumi.Input[str] start_timestamp: StartTimestamp records the time a backup was started. Separate from CreationTimestamp, since that value changes on restores. The server's time is used for StartTimestamps
        :param pulumi.Input[Sequence[pulumi.Input[str]]] validation_errors: ValidationErrors is a slice of all validation errors (if applicable).
        :param pulumi.Input[int] version: Version is the backup format major version. Deprecated: Please see FormatVersion
        :param pulumi.Input[int] volume_snapshots_attempted: VolumeSnapshotsAttempted is the total number of attempted volume snapshots for this backup.
        :param pulumi.Input[int] volume_snapshots_completed: VolumeSnapshotsCompleted is the total number of successfully completed volume snapshots for this backup.
        :param pulumi.Input[int] warnings: Warnings is a count of all warning messages that were generated during execution of the backup. The actual warnings are in the backup's log file in object storage.
        """
        if completion_timestamp is not None:
            pulumi.set(__self__, "completion_timestamp", completion_timestamp)
        if errors is not None:
            pulumi.set(__self__, "errors", errors)
        if expiration is not None:
            pulumi.set(__self__, "expiration", expiration)
        if format_version is not None:
            pulumi.set(__self__, "format_version", format_version)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if progress is not None:
            pulumi.set(__self__, "progress", progress)
        if start_timestamp is not None:
            pulumi.set(__self__, "start_timestamp", start_timestamp)
        if validation_errors is not None:
            pulumi.set(__self__, "validation_errors", validation_errors)
        if version is not None:
            pulumi.set(__self__, "version", version)
        if volume_snapshots_attempted is not None:
            pulumi.set(__self__, "volume_snapshots_attempted", volume_snapshots_attempted)
        if volume_snapshots_completed is not None:
            pulumi.set(__self__, "volume_snapshots_completed", volume_snapshots_completed)
        if warnings is not None:
            pulumi.set(__self__, "warnings", warnings)

    @property
    @pulumi.getter(name="completionTimestamp")
    def completion_timestamp(self) -> Optional[pulumi.Input[str]]:
        """
        CompletionTimestamp records the time a backup was completed. Completion time is recorded even on failed backups. Completion time is recorded before uploading the backup object. The server's time is used for CompletionTimestamps
        """
        return pulumi.get(self, "completion_timestamp")

    @completion_timestamp.setter
    def completion_timestamp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "completion_timestamp", value)

    @property
    @pulumi.getter
    def errors(self) -> Optional[pulumi.Input[int]]:
        """
        Errors is a count of all error messages that were generated during execution of the backup.  The actual errors are in the backup's log file in object storage.
        """
        return pulumi.get(self, "errors")

    @errors.setter
    def errors(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "errors", value)

    @property
    @pulumi.getter
    def expiration(self) -> Optional[pulumi.Input[str]]:
        """
        Expiration is when this Backup is eligible for garbage-collection.
        """
        return pulumi.get(self, "expiration")

    @expiration.setter
    def expiration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expiration", value)

    @property
    @pulumi.getter(name="formatVersion")
    def format_version(self) -> Optional[pulumi.Input[str]]:
        """
        FormatVersion is the backup format version, including major, minor, and patch version.
        """
        return pulumi.get(self, "format_version")

    @format_version.setter
    def format_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "format_version", value)

    @property
    @pulumi.getter
    def phase(self) -> Optional[pulumi.Input[str]]:
        """
        Phase is the current state of the Backup.
        """
        return pulumi.get(self, "phase")

    @phase.setter
    def phase(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "phase", value)

    @property
    @pulumi.getter
    def progress(self) -> Optional[pulumi.Input['BackupStatusProgressArgs']]:
        """
        Progress contains information about the backup's execution progress. Note that this information is best-effort only -- if Velero fails to update it during a backup for any reason, it may be inaccurate/stale.
        """
        return pulumi.get(self, "progress")

    @progress.setter
    def progress(self, value: Optional[pulumi.Input['BackupStatusProgressArgs']]):
        pulumi.set(self, "progress", value)

    @property
    @pulumi.getter(name="startTimestamp")
    def start_timestamp(self) -> Optional[pulumi.Input[str]]:
        """
        StartTimestamp records the time a backup was started. Separate from CreationTimestamp, since that value changes on restores. The server's time is used for StartTimestamps
        """
        return pulumi.get(self, "start_timestamp")

    @start_timestamp.setter
    def start_timestamp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_timestamp", value)

    @property
    @pulumi.getter(name="validationErrors")
    def validation_errors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        ValidationErrors is a slice of all validation errors (if applicable).
        """
        return pulumi.get(self, "validation_errors")

    @validation_errors.setter
    def validation_errors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "validation_errors", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[int]]:
        """
        Version is the backup format major version. Deprecated: Please see FormatVersion
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter(name="volumeSnapshotsAttempted")
    def volume_snapshots_attempted(self) -> Optional[pulumi.Input[int]]:
        """
        VolumeSnapshotsAttempted is the total number of attempted volume snapshots for this backup.
        """
        return pulumi.get(self, "volume_snapshots_attempted")

    @volume_snapshots_attempted.setter
    def volume_snapshots_attempted(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "volume_snapshots_attempted", value)

    @property
    @pulumi.getter(name="volumeSnapshotsCompleted")
    def volume_snapshots_completed(self) -> Optional[pulumi.Input[int]]:
        """
        VolumeSnapshotsCompleted is the total number of successfully completed volume snapshots for this backup.
        """
        return pulumi.get(self, "volume_snapshots_completed")

    @volume_snapshots_completed.setter
    def volume_snapshots_completed(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "volume_snapshots_completed", value)

    @property
    @pulumi.getter
    def warnings(self) -> Optional[pulumi.Input[int]]:
        """
        Warnings is a count of all warning messages that were generated during execution of the backup. The actual warnings are in the backup's log file in object storage.
        """
        return pulumi.get(self, "warnings")

    @warnings.setter
    def warnings(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "warnings", value)


@pulumi.input_type
class BackupStatusProgressArgs:
    def __init__(__self__, *,
                 items_backed_up: Optional[pulumi.Input[int]] = None,
                 total_items: Optional[pulumi.Input[int]] = None):
        """
        Progress contains information about the backup's execution progress. Note that this information is best-effort only -- if Velero fails to update it during a backup for any reason, it may be inaccurate/stale.
        :param pulumi.Input[int] items_backed_up: ItemsBackedUp is the number of items that have actually been written to the backup tarball so far.
        :param pulumi.Input[int] total_items: TotalItems is the total number of items to be backed up. This number may change throughout the execution of the backup due to plugins that return additional related items to back up, the velero.io/exclude-from-backup label, and various other filters that happen as items are processed.
        """
        if items_backed_up is not None:
            pulumi.set(__self__, "items_backed_up", items_backed_up)
        if total_items is not None:
            pulumi.set(__self__, "total_items", total_items)

    @property
    @pulumi.getter(name="itemsBackedUp")
    def items_backed_up(self) -> Optional[pulumi.Input[int]]:
        """
        ItemsBackedUp is the number of items that have actually been written to the backup tarball so far.
        """
        return pulumi.get(self, "items_backed_up")

    @items_backed_up.setter
    def items_backed_up(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "items_backed_up", value)

    @property
    @pulumi.getter(name="totalItems")
    def total_items(self) -> Optional[pulumi.Input[int]]:
        """
        TotalItems is the total number of items to be backed up. This number may change throughout the execution of the backup due to plugins that return additional related items to back up, the velero.io/exclude-from-backup label, and various other filters that happen as items are processed.
        """
        return pulumi.get(self, "total_items")

    @total_items.setter
    def total_items(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "total_items", value)


@pulumi.input_type
class BackupStorageLocationSpecArgs:
    def __init__(__self__, *,
                 object_storage: pulumi.Input['BackupStorageLocationSpecObjectStorageArgs'],
                 provider: pulumi.Input[str],
                 access_mode: Optional[pulumi.Input[str]] = None,
                 backup_sync_period: Optional[pulumi.Input[str]] = None,
                 config: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        BackupStorageLocationSpec defines the specification for a Velero BackupStorageLocation.
        :param pulumi.Input['BackupStorageLocationSpecObjectStorageArgs'] object_storage: ObjectStorageLocation specifies the settings necessary to connect to a provider's object storage.
        :param pulumi.Input[str] provider: Provider is the provider of the backup storage.
        :param pulumi.Input[str] access_mode: AccessMode defines the permissions for the backup storage location.
        :param pulumi.Input[str] backup_sync_period: BackupSyncPeriod defines how frequently to sync backup API objects from object storage. A value of 0 disables sync.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] config: Config is for provider-specific configuration fields.
        """
        pulumi.set(__self__, "object_storage", object_storage)
        pulumi.set(__self__, "provider", provider)
        if access_mode is not None:
            pulumi.set(__self__, "access_mode", access_mode)
        if backup_sync_period is not None:
            pulumi.set(__self__, "backup_sync_period", backup_sync_period)
        if config is not None:
            pulumi.set(__self__, "config", config)

    @property
    @pulumi.getter(name="objectStorage")
    def object_storage(self) -> pulumi.Input['BackupStorageLocationSpecObjectStorageArgs']:
        """
        ObjectStorageLocation specifies the settings necessary to connect to a provider's object storage.
        """
        return pulumi.get(self, "object_storage")

    @object_storage.setter
    def object_storage(self, value: pulumi.Input['BackupStorageLocationSpecObjectStorageArgs']):
        pulumi.set(self, "object_storage", value)

    @property
    @pulumi.getter
    def provider(self) -> pulumi.Input[str]:
        """
        Provider is the provider of the backup storage.
        """
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: pulumi.Input[str]):
        pulumi.set(self, "provider", value)

    @property
    @pulumi.getter(name="accessMode")
    def access_mode(self) -> Optional[pulumi.Input[str]]:
        """
        AccessMode defines the permissions for the backup storage location.
        """
        return pulumi.get(self, "access_mode")

    @access_mode.setter
    def access_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_mode", value)

    @property
    @pulumi.getter(name="backupSyncPeriod")
    def backup_sync_period(self) -> Optional[pulumi.Input[str]]:
        """
        BackupSyncPeriod defines how frequently to sync backup API objects from object storage. A value of 0 disables sync.
        """
        return pulumi.get(self, "backup_sync_period")

    @backup_sync_period.setter
    def backup_sync_period(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_sync_period", value)

    @property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Config is for provider-specific configuration fields.
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "config", value)


@pulumi.input_type
class BackupStorageLocationSpecObjectStorageArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 ca_cert: Optional[pulumi.Input[str]] = None,
                 prefix: Optional[pulumi.Input[str]] = None):
        """
        ObjectStorageLocation specifies the settings necessary to connect to a provider's object storage.
        :param pulumi.Input[str] bucket: Bucket is the bucket to use for object storage.
        :param pulumi.Input[str] ca_cert: CACert defines a CA bundle to use when verifying TLS connections to the provider.
        :param pulumi.Input[str] prefix: Prefix is the path inside a bucket to use for Velero storage. Optional.
        """
        pulumi.set(__self__, "bucket", bucket)
        if ca_cert is not None:
            pulumi.set(__self__, "ca_cert", ca_cert)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        Bucket is the bucket to use for object storage.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter(name="caCert")
    def ca_cert(self) -> Optional[pulumi.Input[str]]:
        """
        CACert defines a CA bundle to use when verifying TLS connections to the provider.
        """
        return pulumi.get(self, "ca_cert")

    @ca_cert.setter
    def ca_cert(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_cert", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Prefix is the path inside a bucket to use for Velero storage. Optional.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)


@pulumi.input_type
class BackupStorageLocationStatusArgs:
    def __init__(__self__, *,
                 access_mode: Optional[pulumi.Input[str]] = None,
                 last_synced_revision: Optional[pulumi.Input[str]] = None,
                 last_synced_time: Optional[pulumi.Input[str]] = None,
                 phase: Optional[pulumi.Input[str]] = None):
        """
        BackupStorageLocationStatus describes the current status of a Velero BackupStorageLocation.
        :param pulumi.Input[str] access_mode: AccessMode is an unused field. 
                Deprecated: there is now an AccessMode field on the Spec and this field will be removed entirely as of v2.0.
        :param pulumi.Input[str] last_synced_revision: LastSyncedRevision is the value of the `metadata/revision` file in the backup storage location the last time the BSL's contents were synced into the cluster. 
                Deprecated: this field is no longer updated or used for detecting changes to the location's contents and will be removed entirely in v2.0.
        :param pulumi.Input[str] last_synced_time: LastSyncedTime is the last time the contents of the location were synced into the cluster.
        :param pulumi.Input[str] phase: Phase is the current state of the BackupStorageLocation.
        """
        if access_mode is not None:
            pulumi.set(__self__, "access_mode", access_mode)
        if last_synced_revision is not None:
            pulumi.set(__self__, "last_synced_revision", last_synced_revision)
        if last_synced_time is not None:
            pulumi.set(__self__, "last_synced_time", last_synced_time)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)

    @property
    @pulumi.getter(name="accessMode")
    def access_mode(self) -> Optional[pulumi.Input[str]]:
        """
        AccessMode is an unused field. 
         Deprecated: there is now an AccessMode field on the Spec and this field will be removed entirely as of v2.0.
        """
        return pulumi.get(self, "access_mode")

    @access_mode.setter
    def access_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_mode", value)

    @property
    @pulumi.getter(name="lastSyncedRevision")
    def last_synced_revision(self) -> Optional[pulumi.Input[str]]:
        """
        LastSyncedRevision is the value of the `metadata/revision` file in the backup storage location the last time the BSL's contents were synced into the cluster. 
         Deprecated: this field is no longer updated or used for detecting changes to the location's contents and will be removed entirely in v2.0.
        """
        return pulumi.get(self, "last_synced_revision")

    @last_synced_revision.setter
    def last_synced_revision(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_synced_revision", value)

    @property
    @pulumi.getter(name="lastSyncedTime")
    def last_synced_time(self) -> Optional[pulumi.Input[str]]:
        """
        LastSyncedTime is the last time the contents of the location were synced into the cluster.
        """
        return pulumi.get(self, "last_synced_time")

    @last_synced_time.setter
    def last_synced_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_synced_time", value)

    @property
    @pulumi.getter
    def phase(self) -> Optional[pulumi.Input[str]]:
        """
        Phase is the current state of the BackupStorageLocation.
        """
        return pulumi.get(self, "phase")

    @phase.setter
    def phase(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "phase", value)


@pulumi.input_type
class DeleteBackupRequestSpecArgs:
    def __init__(__self__, *,
                 backup_name: pulumi.Input[str]):
        """
        DeleteBackupRequestSpec is the specification for which backups to delete.
        """
        pulumi.set(__self__, "backup_name", backup_name)

    @property
    @pulumi.getter(name="backupName")
    def backup_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "backup_name")

    @backup_name.setter
    def backup_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "backup_name", value)


@pulumi.input_type
class DeleteBackupRequestStatusArgs:
    def __init__(__self__, *,
                 errors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 phase: Optional[pulumi.Input[str]] = None):
        """
        DeleteBackupRequestStatus is the current status of a DeleteBackupRequest.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] errors: Errors contains any errors that were encountered during the deletion process.
        :param pulumi.Input[str] phase: Phase is the current state of the DeleteBackupRequest.
        """
        if errors is not None:
            pulumi.set(__self__, "errors", errors)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)

    @property
    @pulumi.getter
    def errors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Errors contains any errors that were encountered during the deletion process.
        """
        return pulumi.get(self, "errors")

    @errors.setter
    def errors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "errors", value)

    @property
    @pulumi.getter
    def phase(self) -> Optional[pulumi.Input[str]]:
        """
        Phase is the current state of the DeleteBackupRequest.
        """
        return pulumi.get(self, "phase")

    @phase.setter
    def phase(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "phase", value)


@pulumi.input_type
class DownloadRequestSpecArgs:
    def __init__(__self__, *,
                 target: pulumi.Input['DownloadRequestSpecTargetArgs']):
        """
        DownloadRequestSpec is the specification for a download request.
        :param pulumi.Input['DownloadRequestSpecTargetArgs'] target: Target is what to download (e.g. logs for a backup).
        """
        pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input['DownloadRequestSpecTargetArgs']:
        """
        Target is what to download (e.g. logs for a backup).
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input['DownloadRequestSpecTargetArgs']):
        pulumi.set(self, "target", value)


@pulumi.input_type
class DownloadRequestSpecTargetArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        Target is what to download (e.g. logs for a backup).
        :param pulumi.Input[str] kind: Kind is the type of file to download.
        :param pulumi.Input[str] name: Name is the name of the kubernetes resource with which the file is associated.
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[str]:
        """
        Kind is the type of file to download.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name is the name of the kubernetes resource with which the file is associated.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class DownloadRequestStatusArgs:
    def __init__(__self__, *,
                 download_url: Optional[pulumi.Input[str]] = None,
                 expiration: Optional[pulumi.Input[str]] = None,
                 phase: Optional[pulumi.Input[str]] = None):
        """
        DownloadRequestStatus is the current status of a DownloadRequest.
        :param pulumi.Input[str] download_url: DownloadURL contains the pre-signed URL for the target file.
        :param pulumi.Input[str] expiration: Expiration is when this DownloadRequest expires and can be deleted by the system.
        :param pulumi.Input[str] phase: Phase is the current state of the DownloadRequest.
        """
        if download_url is not None:
            pulumi.set(__self__, "download_url", download_url)
        if expiration is not None:
            pulumi.set(__self__, "expiration", expiration)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)

    @property
    @pulumi.getter(name="downloadURL")
    def download_url(self) -> Optional[pulumi.Input[str]]:
        """
        DownloadURL contains the pre-signed URL for the target file.
        """
        return pulumi.get(self, "download_url")

    @download_url.setter
    def download_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "download_url", value)

    @property
    @pulumi.getter
    def expiration(self) -> Optional[pulumi.Input[str]]:
        """
        Expiration is when this DownloadRequest expires and can be deleted by the system.
        """
        return pulumi.get(self, "expiration")

    @expiration.setter
    def expiration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expiration", value)

    @property
    @pulumi.getter
    def phase(self) -> Optional[pulumi.Input[str]]:
        """
        Phase is the current state of the DownloadRequest.
        """
        return pulumi.get(self, "phase")

    @phase.setter
    def phase(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "phase", value)


@pulumi.input_type
class PodVolumeBackupSpecArgs:
    def __init__(__self__, *,
                 backup_storage_location: pulumi.Input[str],
                 node: pulumi.Input[str],
                 pod: pulumi.Input['PodVolumeBackupSpecPodArgs'],
                 repo_identifier: pulumi.Input[str],
                 volume: pulumi.Input[str],
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        PodVolumeBackupSpec is the specification for a PodVolumeBackup.
        :param pulumi.Input[str] backup_storage_location: BackupStorageLocation is the name of the backup storage location where the restic repository is stored.
        :param pulumi.Input[str] node: Node is the name of the node that the Pod is running on.
        :param pulumi.Input['PodVolumeBackupSpecPodArgs'] pod: Pod is a reference to the pod containing the volume to be backed up.
        :param pulumi.Input[str] repo_identifier: RepoIdentifier is the restic repository identifier.
        :param pulumi.Input[str] volume: Volume is the name of the volume within the Pod to be backed up.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] tags: Tags are a map of key-value pairs that should be applied to the volume backup as tags.
        """
        pulumi.set(__self__, "backup_storage_location", backup_storage_location)
        pulumi.set(__self__, "node", node)
        pulumi.set(__self__, "pod", pod)
        pulumi.set(__self__, "repo_identifier", repo_identifier)
        pulumi.set(__self__, "volume", volume)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="backupStorageLocation")
    def backup_storage_location(self) -> pulumi.Input[str]:
        """
        BackupStorageLocation is the name of the backup storage location where the restic repository is stored.
        """
        return pulumi.get(self, "backup_storage_location")

    @backup_storage_location.setter
    def backup_storage_location(self, value: pulumi.Input[str]):
        pulumi.set(self, "backup_storage_location", value)

    @property
    @pulumi.getter
    def node(self) -> pulumi.Input[str]:
        """
        Node is the name of the node that the Pod is running on.
        """
        return pulumi.get(self, "node")

    @node.setter
    def node(self, value: pulumi.Input[str]):
        pulumi.set(self, "node", value)

    @property
    @pulumi.getter
    def pod(self) -> pulumi.Input['PodVolumeBackupSpecPodArgs']:
        """
        Pod is a reference to the pod containing the volume to be backed up.
        """
        return pulumi.get(self, "pod")

    @pod.setter
    def pod(self, value: pulumi.Input['PodVolumeBackupSpecPodArgs']):
        pulumi.set(self, "pod", value)

    @property
    @pulumi.getter(name="repoIdentifier")
    def repo_identifier(self) -> pulumi.Input[str]:
        """
        RepoIdentifier is the restic repository identifier.
        """
        return pulumi.get(self, "repo_identifier")

    @repo_identifier.setter
    def repo_identifier(self, value: pulumi.Input[str]):
        pulumi.set(self, "repo_identifier", value)

    @property
    @pulumi.getter
    def volume(self) -> pulumi.Input[str]:
        """
        Volume is the name of the volume within the Pod to be backed up.
        """
        return pulumi.get(self, "volume")

    @volume.setter
    def volume(self, value: pulumi.Input[str]):
        pulumi.set(self, "volume", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Tags are a map of key-value pairs that should be applied to the volume backup as tags.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)


@pulumi.input_type
class PodVolumeBackupSpecPodArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 field_path: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 resource_version: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        Pod is a reference to the pod containing the volume to be backed up.
        :param pulumi.Input[str] api_version: API version of the referent.
        :param pulumi.Input[str] field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param pulumi.Input[str] kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param pulumi.Input[str] namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param pulumi.Input[str] resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param pulumi.Input[str] uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[pulumi.Input[str]]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_path", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @resource_version.setter
    def resource_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_version", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class PodVolumeBackupStatusArgs:
    def __init__(__self__, *,
                 completion_timestamp: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 phase: Optional[pulumi.Input[str]] = None,
                 progress: Optional[pulumi.Input['PodVolumeBackupStatusProgressArgs']] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None,
                 start_timestamp: Optional[pulumi.Input[str]] = None):
        """
        PodVolumeBackupStatus is the current status of a PodVolumeBackup.
        :param pulumi.Input[str] completion_timestamp: CompletionTimestamp records the time a backup was completed. Completion time is recorded even on failed backups. Completion time is recorded before uploading the backup object. The server's time is used for CompletionTimestamps
        :param pulumi.Input[str] message: Message is a message about the pod volume backup's status.
        :param pulumi.Input[str] path: Path is the full path within the controller pod being backed up.
        :param pulumi.Input[str] phase: Phase is the current state of the PodVolumeBackup.
        :param pulumi.Input['PodVolumeBackupStatusProgressArgs'] progress: Progress holds the total number of bytes of the volume and the current number of backed up bytes. This can be used to display progress information about the backup operation.
        :param pulumi.Input[str] snapshot_id: SnapshotID is the identifier for the snapshot of the pod volume.
        :param pulumi.Input[str] start_timestamp: StartTimestamp records the time a backup was started. Separate from CreationTimestamp, since that value changes on restores. The server's time is used for StartTimestamps
        """
        if completion_timestamp is not None:
            pulumi.set(__self__, "completion_timestamp", completion_timestamp)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if progress is not None:
            pulumi.set(__self__, "progress", progress)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if start_timestamp is not None:
            pulumi.set(__self__, "start_timestamp", start_timestamp)

    @property
    @pulumi.getter(name="completionTimestamp")
    def completion_timestamp(self) -> Optional[pulumi.Input[str]]:
        """
        CompletionTimestamp records the time a backup was completed. Completion time is recorded even on failed backups. Completion time is recorded before uploading the backup object. The server's time is used for CompletionTimestamps
        """
        return pulumi.get(self, "completion_timestamp")

    @completion_timestamp.setter
    def completion_timestamp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "completion_timestamp", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Message is a message about the pod volume backup's status.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Path is the full path within the controller pod being backed up.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def phase(self) -> Optional[pulumi.Input[str]]:
        """
        Phase is the current state of the PodVolumeBackup.
        """
        return pulumi.get(self, "phase")

    @phase.setter
    def phase(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "phase", value)

    @property
    @pulumi.getter
    def progress(self) -> Optional[pulumi.Input['PodVolumeBackupStatusProgressArgs']]:
        """
        Progress holds the total number of bytes of the volume and the current number of backed up bytes. This can be used to display progress information about the backup operation.
        """
        return pulumi.get(self, "progress")

    @progress.setter
    def progress(self, value: Optional[pulumi.Input['PodVolumeBackupStatusProgressArgs']]):
        pulumi.set(self, "progress", value)

    @property
    @pulumi.getter(name="snapshotID")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        """
        SnapshotID is the identifier for the snapshot of the pod volume.
        """
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_id", value)

    @property
    @pulumi.getter(name="startTimestamp")
    def start_timestamp(self) -> Optional[pulumi.Input[str]]:
        """
        StartTimestamp records the time a backup was started. Separate from CreationTimestamp, since that value changes on restores. The server's time is used for StartTimestamps
        """
        return pulumi.get(self, "start_timestamp")

    @start_timestamp.setter
    def start_timestamp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_timestamp", value)


@pulumi.input_type
class PodVolumeBackupStatusProgressArgs:
    def __init__(__self__, *,
                 bytes_done: Optional[pulumi.Input[int]] = None,
                 total_bytes: Optional[pulumi.Input[int]] = None):
        """
        Progress holds the total number of bytes of the volume and the current number of backed up bytes. This can be used to display progress information about the backup operation.
        """
        if bytes_done is not None:
            pulumi.set(__self__, "bytes_done", bytes_done)
        if total_bytes is not None:
            pulumi.set(__self__, "total_bytes", total_bytes)

    @property
    @pulumi.getter(name="bytesDone")
    def bytes_done(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "bytes_done")

    @bytes_done.setter
    def bytes_done(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "bytes_done", value)

    @property
    @pulumi.getter(name="totalBytes")
    def total_bytes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "total_bytes")

    @total_bytes.setter
    def total_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "total_bytes", value)


@pulumi.input_type
class PodVolumeRestoreSpecArgs:
    def __init__(__self__, *,
                 backup_storage_location: pulumi.Input[str],
                 pod: pulumi.Input['PodVolumeRestoreSpecPodArgs'],
                 repo_identifier: pulumi.Input[str],
                 snapshot_id: pulumi.Input[str],
                 volume: pulumi.Input[str]):
        """
        PodVolumeRestoreSpec is the specification for a PodVolumeRestore.
        :param pulumi.Input[str] backup_storage_location: BackupStorageLocation is the name of the backup storage location where the restic repository is stored.
        :param pulumi.Input['PodVolumeRestoreSpecPodArgs'] pod: Pod is a reference to the pod containing the volume to be restored.
        :param pulumi.Input[str] repo_identifier: RepoIdentifier is the restic repository identifier.
        :param pulumi.Input[str] snapshot_id: SnapshotID is the ID of the volume snapshot to be restored.
        :param pulumi.Input[str] volume: Volume is the name of the volume within the Pod to be restored.
        """
        pulumi.set(__self__, "backup_storage_location", backup_storage_location)
        pulumi.set(__self__, "pod", pod)
        pulumi.set(__self__, "repo_identifier", repo_identifier)
        pulumi.set(__self__, "snapshot_id", snapshot_id)
        pulumi.set(__self__, "volume", volume)

    @property
    @pulumi.getter(name="backupStorageLocation")
    def backup_storage_location(self) -> pulumi.Input[str]:
        """
        BackupStorageLocation is the name of the backup storage location where the restic repository is stored.
        """
        return pulumi.get(self, "backup_storage_location")

    @backup_storage_location.setter
    def backup_storage_location(self, value: pulumi.Input[str]):
        pulumi.set(self, "backup_storage_location", value)

    @property
    @pulumi.getter
    def pod(self) -> pulumi.Input['PodVolumeRestoreSpecPodArgs']:
        """
        Pod is a reference to the pod containing the volume to be restored.
        """
        return pulumi.get(self, "pod")

    @pod.setter
    def pod(self, value: pulumi.Input['PodVolumeRestoreSpecPodArgs']):
        pulumi.set(self, "pod", value)

    @property
    @pulumi.getter(name="repoIdentifier")
    def repo_identifier(self) -> pulumi.Input[str]:
        """
        RepoIdentifier is the restic repository identifier.
        """
        return pulumi.get(self, "repo_identifier")

    @repo_identifier.setter
    def repo_identifier(self, value: pulumi.Input[str]):
        pulumi.set(self, "repo_identifier", value)

    @property
    @pulumi.getter(name="snapshotID")
    def snapshot_id(self) -> pulumi.Input[str]:
        """
        SnapshotID is the ID of the volume snapshot to be restored.
        """
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "snapshot_id", value)

    @property
    @pulumi.getter
    def volume(self) -> pulumi.Input[str]:
        """
        Volume is the name of the volume within the Pod to be restored.
        """
        return pulumi.get(self, "volume")

    @volume.setter
    def volume(self, value: pulumi.Input[str]):
        pulumi.set(self, "volume", value)


@pulumi.input_type
class PodVolumeRestoreSpecPodArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 field_path: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 resource_version: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        Pod is a reference to the pod containing the volume to be restored.
        :param pulumi.Input[str] api_version: API version of the referent.
        :param pulumi.Input[str] field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param pulumi.Input[str] kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param pulumi.Input[str] namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param pulumi.Input[str] resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param pulumi.Input[str] uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[pulumi.Input[str]]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_path", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @resource_version.setter
    def resource_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_version", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class PodVolumeRestoreStatusArgs:
    def __init__(__self__, *,
                 completion_timestamp: Optional[pulumi.Input[str]] = None,
                 errors: Optional[pulumi.Input[int]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 phase: Optional[pulumi.Input[str]] = None,
                 progress: Optional[pulumi.Input['PodVolumeRestoreStatusProgressArgs']] = None,
                 restic_pod: Optional[pulumi.Input[str]] = None,
                 start_timestamp: Optional[pulumi.Input[str]] = None,
                 verify_errors: Optional[pulumi.Input[int]] = None):
        """
        PodVolumeRestoreStatus is the current status of a PodVolumeRestore.
        :param pulumi.Input[str] completion_timestamp: CompletionTimestamp records the time a restore was completed. Completion time is recorded even on failed restores. The server's time is used for CompletionTimestamps
        :param pulumi.Input[int] errors: Errors is a count of all error messages that were generated during execution of the pod volume restore. The actual errors are in the restic log
        :param pulumi.Input[str] message: Message is a message about the pod volume restore's status.
        :param pulumi.Input[str] phase: Phase is the current state of the PodVolumeRestore.
        :param pulumi.Input['PodVolumeRestoreStatusProgressArgs'] progress: Progress holds the total number of bytes of the snapshot and the current number of restored bytes. This can be used to display progress information about the restore operation.
        :param pulumi.Input[str] restic_pod: ResticPod is the name of the restic pod which processed the restore. Any errors referenced in Errors or VerifyErrors will be logged in this pod's log.
        :param pulumi.Input[str] start_timestamp: StartTimestamp records the time a restore was started. The server's time is used for StartTimestamps
        :param pulumi.Input[int] verify_errors: VerifyErrors is a count of all verification-related error messages that were generated during execution of the pod volume restore. The actual errors are in the restic log
        """
        if completion_timestamp is not None:
            pulumi.set(__self__, "completion_timestamp", completion_timestamp)
        if errors is not None:
            pulumi.set(__self__, "errors", errors)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if progress is not None:
            pulumi.set(__self__, "progress", progress)
        if restic_pod is not None:
            pulumi.set(__self__, "restic_pod", restic_pod)
        if start_timestamp is not None:
            pulumi.set(__self__, "start_timestamp", start_timestamp)
        if verify_errors is not None:
            pulumi.set(__self__, "verify_errors", verify_errors)

    @property
    @pulumi.getter(name="completionTimestamp")
    def completion_timestamp(self) -> Optional[pulumi.Input[str]]:
        """
        CompletionTimestamp records the time a restore was completed. Completion time is recorded even on failed restores. The server's time is used for CompletionTimestamps
        """
        return pulumi.get(self, "completion_timestamp")

    @completion_timestamp.setter
    def completion_timestamp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "completion_timestamp", value)

    @property
    @pulumi.getter
    def errors(self) -> Optional[pulumi.Input[int]]:
        """
        Errors is a count of all error messages that were generated during execution of the pod volume restore. The actual errors are in the restic log
        """
        return pulumi.get(self, "errors")

    @errors.setter
    def errors(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "errors", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Message is a message about the pod volume restore's status.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def phase(self) -> Optional[pulumi.Input[str]]:
        """
        Phase is the current state of the PodVolumeRestore.
        """
        return pulumi.get(self, "phase")

    @phase.setter
    def phase(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "phase", value)

    @property
    @pulumi.getter
    def progress(self) -> Optional[pulumi.Input['PodVolumeRestoreStatusProgressArgs']]:
        """
        Progress holds the total number of bytes of the snapshot and the current number of restored bytes. This can be used to display progress information about the restore operation.
        """
        return pulumi.get(self, "progress")

    @progress.setter
    def progress(self, value: Optional[pulumi.Input['PodVolumeRestoreStatusProgressArgs']]):
        pulumi.set(self, "progress", value)

    @property
    @pulumi.getter(name="resticPod")
    def restic_pod(self) -> Optional[pulumi.Input[str]]:
        """
        ResticPod is the name of the restic pod which processed the restore. Any errors referenced in Errors or VerifyErrors will be logged in this pod's log.
        """
        return pulumi.get(self, "restic_pod")

    @restic_pod.setter
    def restic_pod(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "restic_pod", value)

    @property
    @pulumi.getter(name="startTimestamp")
    def start_timestamp(self) -> Optional[pulumi.Input[str]]:
        """
        StartTimestamp records the time a restore was started. The server's time is used for StartTimestamps
        """
        return pulumi.get(self, "start_timestamp")

    @start_timestamp.setter
    def start_timestamp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_timestamp", value)

    @property
    @pulumi.getter(name="verifyErrors")
    def verify_errors(self) -> Optional[pulumi.Input[int]]:
        """
        VerifyErrors is a count of all verification-related error messages that were generated during execution of the pod volume restore. The actual errors are in the restic log
        """
        return pulumi.get(self, "verify_errors")

    @verify_errors.setter
    def verify_errors(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "verify_errors", value)


@pulumi.input_type
class PodVolumeRestoreStatusProgressArgs:
    def __init__(__self__, *,
                 bytes_done: Optional[pulumi.Input[int]] = None,
                 total_bytes: Optional[pulumi.Input[int]] = None):
        """
        Progress holds the total number of bytes of the snapshot and the current number of restored bytes. This can be used to display progress information about the restore operation.
        """
        if bytes_done is not None:
            pulumi.set(__self__, "bytes_done", bytes_done)
        if total_bytes is not None:
            pulumi.set(__self__, "total_bytes", total_bytes)

    @property
    @pulumi.getter(name="bytesDone")
    def bytes_done(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "bytes_done")

    @bytes_done.setter
    def bytes_done(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "bytes_done", value)

    @property
    @pulumi.getter(name="totalBytes")
    def total_bytes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "total_bytes")

    @total_bytes.setter
    def total_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "total_bytes", value)


@pulumi.input_type
class ResticRepositorySpecArgs:
    def __init__(__self__, *,
                 backup_storage_location: pulumi.Input[str],
                 maintenance_frequency: pulumi.Input[str],
                 restic_identifier: pulumi.Input[str],
                 volume_namespace: pulumi.Input[str]):
        """
        ResticRepositorySpec is the specification for a ResticRepository.
        :param pulumi.Input[str] backup_storage_location: BackupStorageLocation is the name of the BackupStorageLocation that should contain this repository.
        :param pulumi.Input[str] maintenance_frequency: MaintenanceFrequency is how often maintenance should be run.
        :param pulumi.Input[str] restic_identifier: ResticIdentifier is the full restic-compatible string for identifying this repository.
        :param pulumi.Input[str] volume_namespace: VolumeNamespace is the namespace this restic repository contains pod volume backups for.
        """
        pulumi.set(__self__, "backup_storage_location", backup_storage_location)
        pulumi.set(__self__, "maintenance_frequency", maintenance_frequency)
        pulumi.set(__self__, "restic_identifier", restic_identifier)
        pulumi.set(__self__, "volume_namespace", volume_namespace)

    @property
    @pulumi.getter(name="backupStorageLocation")
    def backup_storage_location(self) -> pulumi.Input[str]:
        """
        BackupStorageLocation is the name of the BackupStorageLocation that should contain this repository.
        """
        return pulumi.get(self, "backup_storage_location")

    @backup_storage_location.setter
    def backup_storage_location(self, value: pulumi.Input[str]):
        pulumi.set(self, "backup_storage_location", value)

    @property
    @pulumi.getter(name="maintenanceFrequency")
    def maintenance_frequency(self) -> pulumi.Input[str]:
        """
        MaintenanceFrequency is how often maintenance should be run.
        """
        return pulumi.get(self, "maintenance_frequency")

    @maintenance_frequency.setter
    def maintenance_frequency(self, value: pulumi.Input[str]):
        pulumi.set(self, "maintenance_frequency", value)

    @property
    @pulumi.getter(name="resticIdentifier")
    def restic_identifier(self) -> pulumi.Input[str]:
        """
        ResticIdentifier is the full restic-compatible string for identifying this repository.
        """
        return pulumi.get(self, "restic_identifier")

    @restic_identifier.setter
    def restic_identifier(self, value: pulumi.Input[str]):
        pulumi.set(self, "restic_identifier", value)

    @property
    @pulumi.getter(name="volumeNamespace")
    def volume_namespace(self) -> pulumi.Input[str]:
        """
        VolumeNamespace is the namespace this restic repository contains pod volume backups for.
        """
        return pulumi.get(self, "volume_namespace")

    @volume_namespace.setter
    def volume_namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "volume_namespace", value)


@pulumi.input_type
class ResticRepositoryStatusArgs:
    def __init__(__self__, *,
                 last_maintenance_time: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 phase: Optional[pulumi.Input[str]] = None):
        """
        ResticRepositoryStatus is the current status of a ResticRepository.
        :param pulumi.Input[str] last_maintenance_time: LastMaintenanceTime is the last time maintenance was run.
        :param pulumi.Input[str] message: Message is a message about the current status of the ResticRepository.
        :param pulumi.Input[str] phase: Phase is the current state of the ResticRepository.
        """
        if last_maintenance_time is not None:
            pulumi.set(__self__, "last_maintenance_time", last_maintenance_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)

    @property
    @pulumi.getter(name="lastMaintenanceTime")
    def last_maintenance_time(self) -> Optional[pulumi.Input[str]]:
        """
        LastMaintenanceTime is the last time maintenance was run.
        """
        return pulumi.get(self, "last_maintenance_time")

    @last_maintenance_time.setter
    def last_maintenance_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_maintenance_time", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Message is a message about the current status of the ResticRepository.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def phase(self) -> Optional[pulumi.Input[str]]:
        """
        Phase is the current state of the ResticRepository.
        """
        return pulumi.get(self, "phase")

    @phase.setter
    def phase(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "phase", value)


@pulumi.input_type
class RestoreSpecArgs:
    def __init__(__self__, *,
                 backup_name: pulumi.Input[str],
                 excluded_namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 excluded_resources: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_cluster_resources: Optional[pulumi.Input[bool]] = None,
                 included_namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_resources: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 label_selector: Optional[pulumi.Input['RestoreSpecLabelSelectorArgs']] = None,
                 namespace_mapping: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 restore_pvs: Optional[pulumi.Input[bool]] = None,
                 schedule_name: Optional[pulumi.Input[str]] = None):
        """
        RestoreSpec defines the specification for a Velero restore.
        :param pulumi.Input[str] backup_name: BackupName is the unique name of the Velero backup to restore from.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_namespaces: ExcludedNamespaces contains a list of namespaces that are not included in the restore.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_resources: ExcludedResources is a slice of resource names that are not included in the restore.
        :param pulumi.Input[bool] include_cluster_resources: IncludeClusterResources specifies whether cluster-scoped resources should be included for consideration in the restore. If null, defaults to true.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_namespaces: IncludedNamespaces is a slice of namespace names to include objects from. If empty, all namespaces are included.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_resources: IncludedResources is a slice of resource names to include in the restore. If empty, all resources in the backup are included.
        :param pulumi.Input['RestoreSpecLabelSelectorArgs'] label_selector: LabelSelector is a metav1.LabelSelector to filter with when restoring individual objects from the backup. If empty or nil, all objects are included. Optional.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] namespace_mapping: NamespaceMapping is a map of source namespace names to target namespace names to restore into. Any source namespaces not included in the map will be restored into namespaces of the same name.
        :param pulumi.Input[bool] restore_pvs: RestorePVs specifies whether to restore all included PVs from snapshot (via the cloudprovider).
        :param pulumi.Input[str] schedule_name: ScheduleName is the unique name of the Velero schedule to restore from. If specified, and BackupName is empty, Velero will restore from the most recent successful backup created from this schedule.
        """
        pulumi.set(__self__, "backup_name", backup_name)
        if excluded_namespaces is not None:
            pulumi.set(__self__, "excluded_namespaces", excluded_namespaces)
        if excluded_resources is not None:
            pulumi.set(__self__, "excluded_resources", excluded_resources)
        if include_cluster_resources is not None:
            pulumi.set(__self__, "include_cluster_resources", include_cluster_resources)
        if included_namespaces is not None:
            pulumi.set(__self__, "included_namespaces", included_namespaces)
        if included_resources is not None:
            pulumi.set(__self__, "included_resources", included_resources)
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespace_mapping is not None:
            pulumi.set(__self__, "namespace_mapping", namespace_mapping)
        if restore_pvs is not None:
            pulumi.set(__self__, "restore_pvs", restore_pvs)
        if schedule_name is not None:
            pulumi.set(__self__, "schedule_name", schedule_name)

    @property
    @pulumi.getter(name="backupName")
    def backup_name(self) -> pulumi.Input[str]:
        """
        BackupName is the unique name of the Velero backup to restore from.
        """
        return pulumi.get(self, "backup_name")

    @backup_name.setter
    def backup_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "backup_name", value)

    @property
    @pulumi.getter(name="excludedNamespaces")
    def excluded_namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        ExcludedNamespaces contains a list of namespaces that are not included in the restore.
        """
        return pulumi.get(self, "excluded_namespaces")

    @excluded_namespaces.setter
    def excluded_namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_namespaces", value)

    @property
    @pulumi.getter(name="excludedResources")
    def excluded_resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        ExcludedResources is a slice of resource names that are not included in the restore.
        """
        return pulumi.get(self, "excluded_resources")

    @excluded_resources.setter
    def excluded_resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_resources", value)

    @property
    @pulumi.getter(name="includeClusterResources")
    def include_cluster_resources(self) -> Optional[pulumi.Input[bool]]:
        """
        IncludeClusterResources specifies whether cluster-scoped resources should be included for consideration in the restore. If null, defaults to true.
        """
        return pulumi.get(self, "include_cluster_resources")

    @include_cluster_resources.setter
    def include_cluster_resources(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_cluster_resources", value)

    @property
    @pulumi.getter(name="includedNamespaces")
    def included_namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        IncludedNamespaces is a slice of namespace names to include objects from. If empty, all namespaces are included.
        """
        return pulumi.get(self, "included_namespaces")

    @included_namespaces.setter
    def included_namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_namespaces", value)

    @property
    @pulumi.getter(name="includedResources")
    def included_resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        IncludedResources is a slice of resource names to include in the restore. If empty, all resources in the backup are included.
        """
        return pulumi.get(self, "included_resources")

    @included_resources.setter
    def included_resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_resources", value)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['RestoreSpecLabelSelectorArgs']]:
        """
        LabelSelector is a metav1.LabelSelector to filter with when restoring individual objects from the backup. If empty or nil, all objects are included. Optional.
        """
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['RestoreSpecLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter(name="namespaceMapping")
    def namespace_mapping(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        NamespaceMapping is a map of source namespace names to target namespace names to restore into. Any source namespaces not included in the map will be restored into namespaces of the same name.
        """
        return pulumi.get(self, "namespace_mapping")

    @namespace_mapping.setter
    def namespace_mapping(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "namespace_mapping", value)

    @property
    @pulumi.getter(name="restorePVs")
    def restore_pvs(self) -> Optional[pulumi.Input[bool]]:
        """
        RestorePVs specifies whether to restore all included PVs from snapshot (via the cloudprovider).
        """
        return pulumi.get(self, "restore_pvs")

    @restore_pvs.setter
    def restore_pvs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "restore_pvs", value)

    @property
    @pulumi.getter(name="scheduleName")
    def schedule_name(self) -> Optional[pulumi.Input[str]]:
        """
        ScheduleName is the unique name of the Velero schedule to restore from. If specified, and BackupName is empty, Velero will restore from the most recent successful backup created from this schedule.
        """
        return pulumi.get(self, "schedule_name")

    @schedule_name.setter
    def schedule_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schedule_name", value)


@pulumi.input_type
class RestoreSpecLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['RestoreSpecLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        LabelSelector is a metav1.LabelSelector to filter with when restoring individual objects from the backup. If empty or nil, all objects are included. Optional.
        :param pulumi.Input[Sequence[pulumi.Input['RestoreSpecLabelSelectorMatchExpressionsArgs']]] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RestoreSpecLabelSelectorMatchExpressionsArgs']]]]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RestoreSpecLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class RestoreSpecLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param pulumi.Input[str] key: key is the label key that the selector applies to.
        :param pulumi.Input[str] operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class RestoreStatusArgs:
    def __init__(__self__, *,
                 errors: Optional[pulumi.Input[int]] = None,
                 failure_reason: Optional[pulumi.Input[str]] = None,
                 phase: Optional[pulumi.Input[str]] = None,
                 pod_volume_restore_errors: Optional[pulumi.Input[Sequence[pulumi.Input['RestoreStatusPodVolumeRestoreErrorsArgs']]]] = None,
                 pod_volume_restore_verify_errors: Optional[pulumi.Input[Sequence[pulumi.Input['RestoreStatusPodVolumeRestoreVerifyErrorsArgs']]]] = None,
                 validation_errors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 warnings: Optional[pulumi.Input[int]] = None):
        """
        RestoreStatus captures the current status of a Velero restore
        :param pulumi.Input[int] errors: Errors is a count of all error messages that were generated during execution of the restore. The actual errors are stored in object storage.
        :param pulumi.Input[str] failure_reason: FailureReason is an error that caused the entire restore to fail.
        :param pulumi.Input[str] phase: Phase is the current state of the Restore
        :param pulumi.Input[Sequence[pulumi.Input['RestoreStatusPodVolumeRestoreErrorsArgs']]] pod_volume_restore_errors: PodVolumeRestoreErrors is a slice of all PodVolumeRestores with errors (errors encountered by restic when restoring a pod) (if applicable)
        :param pulumi.Input[Sequence[pulumi.Input['RestoreStatusPodVolumeRestoreVerifyErrorsArgs']]] pod_volume_restore_verify_errors: PodVolumeRestoreVerifyErrors is a slice of all PodVolumeRestore errors from restore verification (errors encountered by restic when verifying a pod restore) (if applicable)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] validation_errors: ValidationErrors is a slice of all validation errors (if applicable)
        :param pulumi.Input[int] warnings: Warnings is a count of all warning messages that were generated during execution of the restore. The actual warnings are stored in object storage.
        """
        if errors is not None:
            pulumi.set(__self__, "errors", errors)
        if failure_reason is not None:
            pulumi.set(__self__, "failure_reason", failure_reason)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if pod_volume_restore_errors is not None:
            pulumi.set(__self__, "pod_volume_restore_errors", pod_volume_restore_errors)
        if pod_volume_restore_verify_errors is not None:
            pulumi.set(__self__, "pod_volume_restore_verify_errors", pod_volume_restore_verify_errors)
        if validation_errors is not None:
            pulumi.set(__self__, "validation_errors", validation_errors)
        if warnings is not None:
            pulumi.set(__self__, "warnings", warnings)

    @property
    @pulumi.getter
    def errors(self) -> Optional[pulumi.Input[int]]:
        """
        Errors is a count of all error messages that were generated during execution of the restore. The actual errors are stored in object storage.
        """
        return pulumi.get(self, "errors")

    @errors.setter
    def errors(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "errors", value)

    @property
    @pulumi.getter(name="failureReason")
    def failure_reason(self) -> Optional[pulumi.Input[str]]:
        """
        FailureReason is an error that caused the entire restore to fail.
        """
        return pulumi.get(self, "failure_reason")

    @failure_reason.setter
    def failure_reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "failure_reason", value)

    @property
    @pulumi.getter
    def phase(self) -> Optional[pulumi.Input[str]]:
        """
        Phase is the current state of the Restore
        """
        return pulumi.get(self, "phase")

    @phase.setter
    def phase(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "phase", value)

    @property
    @pulumi.getter(name="podVolumeRestoreErrors")
    def pod_volume_restore_errors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RestoreStatusPodVolumeRestoreErrorsArgs']]]]:
        """
        PodVolumeRestoreErrors is a slice of all PodVolumeRestores with errors (errors encountered by restic when restoring a pod) (if applicable)
        """
        return pulumi.get(self, "pod_volume_restore_errors")

    @pod_volume_restore_errors.setter
    def pod_volume_restore_errors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RestoreStatusPodVolumeRestoreErrorsArgs']]]]):
        pulumi.set(self, "pod_volume_restore_errors", value)

    @property
    @pulumi.getter(name="podVolumeRestoreVerifyErrors")
    def pod_volume_restore_verify_errors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RestoreStatusPodVolumeRestoreVerifyErrorsArgs']]]]:
        """
        PodVolumeRestoreVerifyErrors is a slice of all PodVolumeRestore errors from restore verification (errors encountered by restic when verifying a pod restore) (if applicable)
        """
        return pulumi.get(self, "pod_volume_restore_verify_errors")

    @pod_volume_restore_verify_errors.setter
    def pod_volume_restore_verify_errors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RestoreStatusPodVolumeRestoreVerifyErrorsArgs']]]]):
        pulumi.set(self, "pod_volume_restore_verify_errors", value)

    @property
    @pulumi.getter(name="validationErrors")
    def validation_errors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        ValidationErrors is a slice of all validation errors (if applicable)
        """
        return pulumi.get(self, "validation_errors")

    @validation_errors.setter
    def validation_errors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "validation_errors", value)

    @property
    @pulumi.getter
    def warnings(self) -> Optional[pulumi.Input[int]]:
        """
        Warnings is a count of all warning messages that were generated during execution of the restore. The actual warnings are stored in object storage.
        """
        return pulumi.get(self, "warnings")

    @warnings.setter
    def warnings(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "warnings", value)


@pulumi.input_type
class RestoreStatusPodVolumeRestoreErrorsArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 field_path: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 resource_version: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        ObjectReference contains enough information to let you inspect or modify the referred object.
        :param pulumi.Input[str] api_version: API version of the referent.
        :param pulumi.Input[str] field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param pulumi.Input[str] kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param pulumi.Input[str] namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param pulumi.Input[str] resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param pulumi.Input[str] uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[pulumi.Input[str]]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_path", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @resource_version.setter
    def resource_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_version", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class RestoreStatusPodVolumeRestoreVerifyErrorsArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 field_path: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 resource_version: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None):
        """
        ObjectReference contains enough information to let you inspect or modify the referred object.
        :param pulumi.Input[str] api_version: API version of the referent.
        :param pulumi.Input[str] field_path: If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        :param pulumi.Input[str] kind: Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param pulumi.Input[str] namespace: Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        :param pulumi.Input[str] resource_version: Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        :param pulumi.Input[str] uid: UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if field_path is not None:
            pulumi.set(__self__, "field_path", field_path)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> Optional[pulumi.Input[str]]:
        """
        If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_path", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        """
        return pulumi.get(self, "resource_version")

    @resource_version.setter
    def resource_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_version", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)


@pulumi.input_type
class ScheduleSpecArgs:
    def __init__(__self__, *,
                 schedule: pulumi.Input[str],
                 template: pulumi.Input['ScheduleSpecTemplateArgs']):
        """
        ScheduleSpec defines the specification for a Velero schedule
        :param pulumi.Input[str] schedule: Schedule is a Cron expression defining when to run the Backup.
        :param pulumi.Input['ScheduleSpecTemplateArgs'] template: Template is the definition of the Backup to be run on the provided schedule
        """
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "template", template)

    @property
    @pulumi.getter
    def schedule(self) -> pulumi.Input[str]:
        """
        Schedule is a Cron expression defining when to run the Backup.
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: pulumi.Input[str]):
        pulumi.set(self, "schedule", value)

    @property
    @pulumi.getter
    def template(self) -> pulumi.Input['ScheduleSpecTemplateArgs']:
        """
        Template is the definition of the Backup to be run on the provided schedule
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: pulumi.Input['ScheduleSpecTemplateArgs']):
        pulumi.set(self, "template", value)


@pulumi.input_type
class ScheduleSpecTemplateArgs:
    def __init__(__self__, *,
                 excluded_namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 excluded_resources: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 hooks: Optional[pulumi.Input['ScheduleSpecTemplateHooksArgs']] = None,
                 include_cluster_resources: Optional[pulumi.Input[bool]] = None,
                 included_namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_resources: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 label_selector: Optional[pulumi.Input['ScheduleSpecTemplateLabelSelectorArgs']] = None,
                 snapshot_volumes: Optional[pulumi.Input[bool]] = None,
                 storage_location: Optional[pulumi.Input[str]] = None,
                 ttl: Optional[pulumi.Input[str]] = None,
                 volume_snapshot_locations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Template is the definition of the Backup to be run on the provided schedule
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_namespaces: ExcludedNamespaces contains a list of namespaces that are not included in the backup.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_resources: ExcludedResources is a slice of resource names that are not included in the backup.
        :param pulumi.Input['ScheduleSpecTemplateHooksArgs'] hooks: Hooks represent custom behaviors that should be executed at different phases of the backup.
        :param pulumi.Input[bool] include_cluster_resources: IncludeClusterResources specifies whether cluster-scoped resources should be included for consideration in the backup.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_namespaces: IncludedNamespaces is a slice of namespace names to include objects from. If empty, all namespaces are included.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_resources: IncludedResources is a slice of resource names to include in the backup. If empty, all resources are included.
        :param pulumi.Input['ScheduleSpecTemplateLabelSelectorArgs'] label_selector: LabelSelector is a metav1.LabelSelector to filter with when adding individual objects to the backup. If empty or nil, all objects are included. Optional.
        :param pulumi.Input[bool] snapshot_volumes: SnapshotVolumes specifies whether to take cloud snapshots of any PV's referenced in the set of objects included in the Backup.
        :param pulumi.Input[str] storage_location: StorageLocation is a string containing the name of a BackupStorageLocation where the backup should be stored.
        :param pulumi.Input[str] ttl: TTL is a time.Duration-parseable string describing how long the Backup should be retained for.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] volume_snapshot_locations: VolumeSnapshotLocations is a list containing names of VolumeSnapshotLocations associated with this backup.
        """
        if excluded_namespaces is not None:
            pulumi.set(__self__, "excluded_namespaces", excluded_namespaces)
        if excluded_resources is not None:
            pulumi.set(__self__, "excluded_resources", excluded_resources)
        if hooks is not None:
            pulumi.set(__self__, "hooks", hooks)
        if include_cluster_resources is not None:
            pulumi.set(__self__, "include_cluster_resources", include_cluster_resources)
        if included_namespaces is not None:
            pulumi.set(__self__, "included_namespaces", included_namespaces)
        if included_resources is not None:
            pulumi.set(__self__, "included_resources", included_resources)
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if snapshot_volumes is not None:
            pulumi.set(__self__, "snapshot_volumes", snapshot_volumes)
        if storage_location is not None:
            pulumi.set(__self__, "storage_location", storage_location)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if volume_snapshot_locations is not None:
            pulumi.set(__self__, "volume_snapshot_locations", volume_snapshot_locations)

    @property
    @pulumi.getter(name="excludedNamespaces")
    def excluded_namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        ExcludedNamespaces contains a list of namespaces that are not included in the backup.
        """
        return pulumi.get(self, "excluded_namespaces")

    @excluded_namespaces.setter
    def excluded_namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_namespaces", value)

    @property
    @pulumi.getter(name="excludedResources")
    def excluded_resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        ExcludedResources is a slice of resource names that are not included in the backup.
        """
        return pulumi.get(self, "excluded_resources")

    @excluded_resources.setter
    def excluded_resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_resources", value)

    @property
    @pulumi.getter
    def hooks(self) -> Optional[pulumi.Input['ScheduleSpecTemplateHooksArgs']]:
        """
        Hooks represent custom behaviors that should be executed at different phases of the backup.
        """
        return pulumi.get(self, "hooks")

    @hooks.setter
    def hooks(self, value: Optional[pulumi.Input['ScheduleSpecTemplateHooksArgs']]):
        pulumi.set(self, "hooks", value)

    @property
    @pulumi.getter(name="includeClusterResources")
    def include_cluster_resources(self) -> Optional[pulumi.Input[bool]]:
        """
        IncludeClusterResources specifies whether cluster-scoped resources should be included for consideration in the backup.
        """
        return pulumi.get(self, "include_cluster_resources")

    @include_cluster_resources.setter
    def include_cluster_resources(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_cluster_resources", value)

    @property
    @pulumi.getter(name="includedNamespaces")
    def included_namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        IncludedNamespaces is a slice of namespace names to include objects from. If empty, all namespaces are included.
        """
        return pulumi.get(self, "included_namespaces")

    @included_namespaces.setter
    def included_namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_namespaces", value)

    @property
    @pulumi.getter(name="includedResources")
    def included_resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        IncludedResources is a slice of resource names to include in the backup. If empty, all resources are included.
        """
        return pulumi.get(self, "included_resources")

    @included_resources.setter
    def included_resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_resources", value)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['ScheduleSpecTemplateLabelSelectorArgs']]:
        """
        LabelSelector is a metav1.LabelSelector to filter with when adding individual objects to the backup. If empty or nil, all objects are included. Optional.
        """
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['ScheduleSpecTemplateLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter(name="snapshotVolumes")
    def snapshot_volumes(self) -> Optional[pulumi.Input[bool]]:
        """
        SnapshotVolumes specifies whether to take cloud snapshots of any PV's referenced in the set of objects included in the Backup.
        """
        return pulumi.get(self, "snapshot_volumes")

    @snapshot_volumes.setter
    def snapshot_volumes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "snapshot_volumes", value)

    @property
    @pulumi.getter(name="storageLocation")
    def storage_location(self) -> Optional[pulumi.Input[str]]:
        """
        StorageLocation is a string containing the name of a BackupStorageLocation where the backup should be stored.
        """
        return pulumi.get(self, "storage_location")

    @storage_location.setter
    def storage_location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_location", value)

    @property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[str]]:
        """
        TTL is a time.Duration-parseable string describing how long the Backup should be retained for.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ttl", value)

    @property
    @pulumi.getter(name="volumeSnapshotLocations")
    def volume_snapshot_locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        VolumeSnapshotLocations is a list containing names of VolumeSnapshotLocations associated with this backup.
        """
        return pulumi.get(self, "volume_snapshot_locations")

    @volume_snapshot_locations.setter
    def volume_snapshot_locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "volume_snapshot_locations", value)


@pulumi.input_type
class ScheduleSpecTemplateHooksArgs:
    def __init__(__self__, *,
                 resources: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduleSpecTemplateHooksResourcesArgs']]]] = None):
        """
        Hooks represent custom behaviors that should be executed at different phases of the backup.
        :param pulumi.Input[Sequence[pulumi.Input['ScheduleSpecTemplateHooksResourcesArgs']]] resources: Resources are hooks that should be executed when backing up individual instances of a resource.
        """
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduleSpecTemplateHooksResourcesArgs']]]]:
        """
        Resources are hooks that should be executed when backing up individual instances of a resource.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduleSpecTemplateHooksResourcesArgs']]]]):
        pulumi.set(self, "resources", value)


@pulumi.input_type
class ScheduleSpecTemplateHooksResourcesArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 excluded_namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 excluded_resources: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_resources: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 label_selector: Optional[pulumi.Input['ScheduleSpecTemplateHooksResourcesLabelSelectorArgs']] = None,
                 post: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduleSpecTemplateHooksResourcesPostArgs']]]] = None,
                 pre: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduleSpecTemplateHooksResourcesPreArgs']]]] = None):
        """
        BackupResourceHookSpec defines one or more BackupResourceHooks that should be executed based on the rules defined for namespaces, resources, and label selector.
        :param pulumi.Input[str] name: Name is the name of this hook.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_namespaces: ExcludedNamespaces specifies the namespaces to which this hook spec does not apply.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_resources: ExcludedResources specifies the resources to which this hook spec does not apply.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_namespaces: IncludedNamespaces specifies the namespaces to which this hook spec applies. If empty, it applies to all namespaces.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_resources: IncludedResources specifies the resources to which this hook spec applies. If empty, it applies to all resources.
        :param pulumi.Input['ScheduleSpecTemplateHooksResourcesLabelSelectorArgs'] label_selector: LabelSelector, if specified, filters the resources to which this hook spec applies.
        :param pulumi.Input[Sequence[pulumi.Input['ScheduleSpecTemplateHooksResourcesPostArgs']]] post: PostHooks is a list of BackupResourceHooks to execute after storing the item in the backup. These are executed after all "additional items" from item actions are processed.
        :param pulumi.Input[Sequence[pulumi.Input['ScheduleSpecTemplateHooksResourcesPreArgs']]] pre: PreHooks is a list of BackupResourceHooks to execute prior to storing the item in the backup. These are executed before any "additional items" from item actions are processed.
        """
        pulumi.set(__self__, "name", name)
        if excluded_namespaces is not None:
            pulumi.set(__self__, "excluded_namespaces", excluded_namespaces)
        if excluded_resources is not None:
            pulumi.set(__self__, "excluded_resources", excluded_resources)
        if included_namespaces is not None:
            pulumi.set(__self__, "included_namespaces", included_namespaces)
        if included_resources is not None:
            pulumi.set(__self__, "included_resources", included_resources)
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if post is not None:
            pulumi.set(__self__, "post", post)
        if pre is not None:
            pulumi.set(__self__, "pre", pre)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name is the name of this hook.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="excludedNamespaces")
    def excluded_namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        ExcludedNamespaces specifies the namespaces to which this hook spec does not apply.
        """
        return pulumi.get(self, "excluded_namespaces")

    @excluded_namespaces.setter
    def excluded_namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_namespaces", value)

    @property
    @pulumi.getter(name="excludedResources")
    def excluded_resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        ExcludedResources specifies the resources to which this hook spec does not apply.
        """
        return pulumi.get(self, "excluded_resources")

    @excluded_resources.setter
    def excluded_resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_resources", value)

    @property
    @pulumi.getter(name="includedNamespaces")
    def included_namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        IncludedNamespaces specifies the namespaces to which this hook spec applies. If empty, it applies to all namespaces.
        """
        return pulumi.get(self, "included_namespaces")

    @included_namespaces.setter
    def included_namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_namespaces", value)

    @property
    @pulumi.getter(name="includedResources")
    def included_resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        IncludedResources specifies the resources to which this hook spec applies. If empty, it applies to all resources.
        """
        return pulumi.get(self, "included_resources")

    @included_resources.setter
    def included_resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_resources", value)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['ScheduleSpecTemplateHooksResourcesLabelSelectorArgs']]:
        """
        LabelSelector, if specified, filters the resources to which this hook spec applies.
        """
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['ScheduleSpecTemplateHooksResourcesLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def post(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduleSpecTemplateHooksResourcesPostArgs']]]]:
        """
        PostHooks is a list of BackupResourceHooks to execute after storing the item in the backup. These are executed after all "additional items" from item actions are processed.
        """
        return pulumi.get(self, "post")

    @post.setter
    def post(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduleSpecTemplateHooksResourcesPostArgs']]]]):
        pulumi.set(self, "post", value)

    @property
    @pulumi.getter
    def pre(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduleSpecTemplateHooksResourcesPreArgs']]]]:
        """
        PreHooks is a list of BackupResourceHooks to execute prior to storing the item in the backup. These are executed before any "additional items" from item actions are processed.
        """
        return pulumi.get(self, "pre")

    @pre.setter
    def pre(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduleSpecTemplateHooksResourcesPreArgs']]]]):
        pulumi.set(self, "pre", value)


@pulumi.input_type
class ScheduleSpecTemplateHooksResourcesLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduleSpecTemplateHooksResourcesLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        LabelSelector, if specified, filters the resources to which this hook spec applies.
        :param pulumi.Input[Sequence[pulumi.Input['ScheduleSpecTemplateHooksResourcesLabelSelectorMatchExpressionsArgs']]] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduleSpecTemplateHooksResourcesLabelSelectorMatchExpressionsArgs']]]]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduleSpecTemplateHooksResourcesLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class ScheduleSpecTemplateHooksResourcesLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param pulumi.Input[str] key: key is the label key that the selector applies to.
        :param pulumi.Input[str] operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class ScheduleSpecTemplateHooksResourcesPostArgs:
    def __init__(__self__, *,
                 exec_: pulumi.Input['ScheduleSpecTemplateHooksResourcesPostExecArgs']):
        """
        BackupResourceHook defines a hook for a resource.
        :param pulumi.Input['ScheduleSpecTemplateHooksResourcesPostExecArgs'] exec_: Exec defines an exec hook.
        """
        pulumi.set(__self__, "exec_", exec_)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> pulumi.Input['ScheduleSpecTemplateHooksResourcesPostExecArgs']:
        """
        Exec defines an exec hook.
        """
        return pulumi.get(self, "exec_")

    @exec_.setter
    def exec_(self, value: pulumi.Input['ScheduleSpecTemplateHooksResourcesPostExecArgs']):
        pulumi.set(self, "exec_", value)


@pulumi.input_type
class ScheduleSpecTemplateHooksResourcesPostExecArgs:
    def __init__(__self__, *,
                 command: pulumi.Input[Sequence[pulumi.Input[str]]],
                 container: Optional[pulumi.Input[str]] = None,
                 on_error: Optional[pulumi.Input[str]] = None,
                 timeout: Optional[pulumi.Input[str]] = None):
        """
        Exec defines an exec hook.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] command: Command is the command and arguments to execute.
        :param pulumi.Input[str] container: Container is the container in the pod where the command should be executed. If not specified, the pod's first container is used.
        :param pulumi.Input[str] on_error: OnError specifies how Velero should behave if it encounters an error executing this hook.
        :param pulumi.Input[str] timeout: Timeout defines the maximum amount of time Velero should wait for the hook to complete before considering the execution a failure.
        """
        pulumi.set(__self__, "command", command)
        if container is not None:
            pulumi.set(__self__, "container", container)
        if on_error is not None:
            pulumi.set(__self__, "on_error", on_error)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def command(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Command is the command and arguments to execute.
        """
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "command", value)

    @property
    @pulumi.getter
    def container(self) -> Optional[pulumi.Input[str]]:
        """
        Container is the container in the pod where the command should be executed. If not specified, the pod's first container is used.
        """
        return pulumi.get(self, "container")

    @container.setter
    def container(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "container", value)

    @property
    @pulumi.getter(name="onError")
    def on_error(self) -> Optional[pulumi.Input[str]]:
        """
        OnError specifies how Velero should behave if it encounters an error executing this hook.
        """
        return pulumi.get(self, "on_error")

    @on_error.setter
    def on_error(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "on_error", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Timeout defines the maximum amount of time Velero should wait for the hook to complete before considering the execution a failure.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeout", value)


@pulumi.input_type
class ScheduleSpecTemplateHooksResourcesPreArgs:
    def __init__(__self__, *,
                 exec_: pulumi.Input['ScheduleSpecTemplateHooksResourcesPreExecArgs']):
        """
        BackupResourceHook defines a hook for a resource.
        :param pulumi.Input['ScheduleSpecTemplateHooksResourcesPreExecArgs'] exec_: Exec defines an exec hook.
        """
        pulumi.set(__self__, "exec_", exec_)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> pulumi.Input['ScheduleSpecTemplateHooksResourcesPreExecArgs']:
        """
        Exec defines an exec hook.
        """
        return pulumi.get(self, "exec_")

    @exec_.setter
    def exec_(self, value: pulumi.Input['ScheduleSpecTemplateHooksResourcesPreExecArgs']):
        pulumi.set(self, "exec_", value)


@pulumi.input_type
class ScheduleSpecTemplateHooksResourcesPreExecArgs:
    def __init__(__self__, *,
                 command: pulumi.Input[Sequence[pulumi.Input[str]]],
                 container: Optional[pulumi.Input[str]] = None,
                 on_error: Optional[pulumi.Input[str]] = None,
                 timeout: Optional[pulumi.Input[str]] = None):
        """
        Exec defines an exec hook.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] command: Command is the command and arguments to execute.
        :param pulumi.Input[str] container: Container is the container in the pod where the command should be executed. If not specified, the pod's first container is used.
        :param pulumi.Input[str] on_error: OnError specifies how Velero should behave if it encounters an error executing this hook.
        :param pulumi.Input[str] timeout: Timeout defines the maximum amount of time Velero should wait for the hook to complete before considering the execution a failure.
        """
        pulumi.set(__self__, "command", command)
        if container is not None:
            pulumi.set(__self__, "container", container)
        if on_error is not None:
            pulumi.set(__self__, "on_error", on_error)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def command(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Command is the command and arguments to execute.
        """
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "command", value)

    @property
    @pulumi.getter
    def container(self) -> Optional[pulumi.Input[str]]:
        """
        Container is the container in the pod where the command should be executed. If not specified, the pod's first container is used.
        """
        return pulumi.get(self, "container")

    @container.setter
    def container(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "container", value)

    @property
    @pulumi.getter(name="onError")
    def on_error(self) -> Optional[pulumi.Input[str]]:
        """
        OnError specifies how Velero should behave if it encounters an error executing this hook.
        """
        return pulumi.get(self, "on_error")

    @on_error.setter
    def on_error(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "on_error", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Timeout defines the maximum amount of time Velero should wait for the hook to complete before considering the execution a failure.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeout", value)


@pulumi.input_type
class ScheduleSpecTemplateLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduleSpecTemplateLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        LabelSelector is a metav1.LabelSelector to filter with when adding individual objects to the backup. If empty or nil, all objects are included. Optional.
        :param pulumi.Input[Sequence[pulumi.Input['ScheduleSpecTemplateLabelSelectorMatchExpressionsArgs']]] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduleSpecTemplateLabelSelectorMatchExpressionsArgs']]]]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduleSpecTemplateLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class ScheduleSpecTemplateLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param pulumi.Input[str] key: key is the label key that the selector applies to.
        :param pulumi.Input[str] operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class ScheduleStatusArgs:
    def __init__(__self__, *,
                 last_backup: Optional[pulumi.Input[str]] = None,
                 phase: Optional[pulumi.Input[str]] = None,
                 validation_errors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        ScheduleStatus captures the current state of a Velero schedule
        :param pulumi.Input[str] last_backup: LastBackup is the last time a Backup was run for this Schedule schedule
        :param pulumi.Input[str] phase: Phase is the current phase of the Schedule
        :param pulumi.Input[Sequence[pulumi.Input[str]]] validation_errors: ValidationErrors is a slice of all validation errors (if applicable)
        """
        if last_backup is not None:
            pulumi.set(__self__, "last_backup", last_backup)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if validation_errors is not None:
            pulumi.set(__self__, "validation_errors", validation_errors)

    @property
    @pulumi.getter(name="lastBackup")
    def last_backup(self) -> Optional[pulumi.Input[str]]:
        """
        LastBackup is the last time a Backup was run for this Schedule schedule
        """
        return pulumi.get(self, "last_backup")

    @last_backup.setter
    def last_backup(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_backup", value)

    @property
    @pulumi.getter
    def phase(self) -> Optional[pulumi.Input[str]]:
        """
        Phase is the current phase of the Schedule
        """
        return pulumi.get(self, "phase")

    @phase.setter
    def phase(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "phase", value)

    @property
    @pulumi.getter(name="validationErrors")
    def validation_errors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        ValidationErrors is a slice of all validation errors (if applicable)
        """
        return pulumi.get(self, "validation_errors")

    @validation_errors.setter
    def validation_errors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "validation_errors", value)


@pulumi.input_type
class ServerStatusRequestStatusArgs:
    def __init__(__self__, *,
                 phase: Optional[pulumi.Input[str]] = None,
                 plugins: Optional[pulumi.Input[Sequence[pulumi.Input['ServerStatusRequestStatusPluginsArgs']]]] = None,
                 processed_timestamp: Optional[pulumi.Input[str]] = None,
                 server_version: Optional[pulumi.Input[str]] = None):
        """
        ServerStatusRequestStatus is the current status of a ServerStatusRequest.
        :param pulumi.Input[str] phase: Phase is the current lifecycle phase of the ServerStatusRequest.
        :param pulumi.Input[Sequence[pulumi.Input['ServerStatusRequestStatusPluginsArgs']]] plugins: Plugins list information about the plugins running on the Velero server
        :param pulumi.Input[str] processed_timestamp: ProcessedTimestamp is when the ServerStatusRequest was processed by the ServerStatusRequestController.
        :param pulumi.Input[str] server_version: ServerVersion is the Velero server version.
        """
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if plugins is not None:
            pulumi.set(__self__, "plugins", plugins)
        if processed_timestamp is not None:
            pulumi.set(__self__, "processed_timestamp", processed_timestamp)
        if server_version is not None:
            pulumi.set(__self__, "server_version", server_version)

    @property
    @pulumi.getter
    def phase(self) -> Optional[pulumi.Input[str]]:
        """
        Phase is the current lifecycle phase of the ServerStatusRequest.
        """
        return pulumi.get(self, "phase")

    @phase.setter
    def phase(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "phase", value)

    @property
    @pulumi.getter
    def plugins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServerStatusRequestStatusPluginsArgs']]]]:
        """
        Plugins list information about the plugins running on the Velero server
        """
        return pulumi.get(self, "plugins")

    @plugins.setter
    def plugins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServerStatusRequestStatusPluginsArgs']]]]):
        pulumi.set(self, "plugins", value)

    @property
    @pulumi.getter(name="processedTimestamp")
    def processed_timestamp(self) -> Optional[pulumi.Input[str]]:
        """
        ProcessedTimestamp is when the ServerStatusRequest was processed by the ServerStatusRequestController.
        """
        return pulumi.get(self, "processed_timestamp")

    @processed_timestamp.setter
    def processed_timestamp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "processed_timestamp", value)

    @property
    @pulumi.getter(name="serverVersion")
    def server_version(self) -> Optional[pulumi.Input[str]]:
        """
        ServerVersion is the Velero server version.
        """
        return pulumi.get(self, "server_version")

    @server_version.setter
    def server_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_version", value)


@pulumi.input_type
class ServerStatusRequestStatusPluginsArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        PluginInfo contains attributes of a Velero plugin
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[str]:
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class VolumeSnapshotLocationSpecArgs:
    def __init__(__self__, *,
                 provider: pulumi.Input[str],
                 config: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        VolumeSnapshotLocationSpec defines the specification for a Velero VolumeSnapshotLocation.
        :param pulumi.Input[str] provider: Provider is the provider of the volume storage.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] config: Config is for provider-specific configuration fields.
        """
        pulumi.set(__self__, "provider", provider)
        if config is not None:
            pulumi.set(__self__, "config", config)

    @property
    @pulumi.getter
    def provider(self) -> pulumi.Input[str]:
        """
        Provider is the provider of the volume storage.
        """
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: pulumi.Input[str]):
        pulumi.set(self, "provider", value)

    @property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Config is for provider-specific configuration fields.
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "config", value)


@pulumi.input_type
class VolumeSnapshotLocationStatusArgs:
    def __init__(__self__, *,
                 phase: Optional[pulumi.Input[str]] = None):
        """
        VolumeSnapshotLocationStatus describes the current status of a Velero VolumeSnapshotLocation.
        :param pulumi.Input[str] phase: VolumeSnapshotLocationPhase is the lifecyle phase of a Velero VolumeSnapshotLocation.
        """
        if phase is not None:
            pulumi.set(__self__, "phase", phase)

    @property
    @pulumi.getter
    def phase(self) -> Optional[pulumi.Input[str]]:
        """
        VolumeSnapshotLocationPhase is the lifecyle phase of a Velero VolumeSnapshotLocation.
        """
        return pulumi.get(self, "phase")

    @phase.setter
    def phase(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "phase", value)


