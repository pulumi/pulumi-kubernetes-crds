# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from ... import _utilities, _tables
from . import outputs

__all__ = [
    'AddressSpaceSpec',
    'AddressSpaceSpecAuthenticationService',
    'AddressSpaceSpecAuthenticationServiceOverrides',
    'AddressSpaceSpecConnectors',
    'AddressSpaceSpecConnectorsAddresses',
    'AddressSpaceSpecConnectorsCredentials',
    'AddressSpaceSpecConnectorsCredentialsPassword',
    'AddressSpaceSpecConnectorsCredentialsUsername',
    'AddressSpaceSpecConnectorsEndpointHosts',
    'AddressSpaceSpecConnectorsTls',
    'AddressSpaceSpecConnectorsTlsCaCert',
    'AddressSpaceSpecConnectorsTlsClientCert',
    'AddressSpaceSpecConnectorsTlsClientKey',
    'AddressSpaceSpecEndpoints',
    'AddressSpaceSpecEndpointsCert',
    'AddressSpaceSpecEndpointsExports',
    'AddressSpaceSpecEndpointsExpose',
    'AddressSpaceSpecNetworkPolicy',
    'AddressSpaceStatus',
    'AddressSpaceStatusConnectors',
    'AddressSpaceStatusEndpointStatuses',
    'AddressSpaceStatusRouters',
    'AddressSpec',
    'AddressSpecForwarders',
    'AddressSpecMessageTtl',
    'AddressSpecSubscription',
    'AddressStatus',
    'AddressStatusBrokerStatuses',
    'AddressStatusForwarders',
    'AddressStatusMessageTtl',
    'AddressStatusPlanStatus',
    'AddressStatusSubscription',
]

@pulumi.output_type
class AddressSpaceSpec(dict):
    def __init__(__self__, *,
                 plan: str,
                 type: str,
                 authentication_service: Optional['outputs.AddressSpaceSpecAuthenticationService'] = None,
                 connectors: Optional[Sequence['outputs.AddressSpaceSpecConnectors']] = None,
                 endpoints: Optional[Sequence['outputs.AddressSpaceSpecEndpoints']] = None,
                 network_policy: Optional['outputs.AddressSpaceSpecNetworkPolicy'] = None):
        """
        :param str plan: The name of the address space plan to apply.
        :param str type: The type of address space.
        :param 'AddressSpaceSpecAuthenticationServiceArgs' authentication_service: The authentication service to use for authenticating messaging clients.
        :param Sequence['AddressSpaceSpecConnectorsArgs'] connectors: External AMQP connections.
        :param Sequence['AddressSpaceSpecEndpointsArgs'] endpoints: Endpoints configured for this address space.
        :param 'AddressSpaceSpecNetworkPolicyArgs' network_policy: Define NetworkPolicy for this address space.
        """
        pulumi.set(__self__, "plan", plan)
        pulumi.set(__self__, "type", type)
        if authentication_service is not None:
            pulumi.set(__self__, "authentication_service", authentication_service)
        if connectors is not None:
            pulumi.set(__self__, "connectors", connectors)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if network_policy is not None:
            pulumi.set(__self__, "network_policy", network_policy)

    @property
    @pulumi.getter
    def plan(self) -> str:
        """
        The name of the address space plan to apply.
        """
        return pulumi.get(self, "plan")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of address space.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="authenticationService")
    def authentication_service(self) -> Optional['outputs.AddressSpaceSpecAuthenticationService']:
        """
        The authentication service to use for authenticating messaging clients.
        """
        return pulumi.get(self, "authentication_service")

    @property
    @pulumi.getter
    def connectors(self) -> Optional[Sequence['outputs.AddressSpaceSpecConnectors']]:
        """
        External AMQP connections.
        """
        return pulumi.get(self, "connectors")

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[Sequence['outputs.AddressSpaceSpecEndpoints']]:
        """
        Endpoints configured for this address space.
        """
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter(name="networkPolicy")
    def network_policy(self) -> Optional['outputs.AddressSpaceSpecNetworkPolicy']:
        """
        Define NetworkPolicy for this address space.
        """
        return pulumi.get(self, "network_policy")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AddressSpaceSpecAuthenticationService(dict):
    """
    The authentication service to use for authenticating messaging clients.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 overrides: Optional['outputs.AddressSpaceSpecAuthenticationServiceOverrides'] = None,
                 type: Optional[str] = None):
        """
        The authentication service to use for authenticating messaging clients.
        :param str name: The name of the authentication service.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the authentication service.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def overrides(self) -> Optional['outputs.AddressSpaceSpecAuthenticationServiceOverrides']:
        return pulumi.get(self, "overrides")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AddressSpaceSpecAuthenticationServiceOverrides(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 port: Optional[int] = None,
                 realm: Optional[str] = None):
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if realm is not None:
            pulumi.set(__self__, "realm", realm)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def realm(self) -> Optional[str]:
        return pulumi.get(self, "realm")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AddressSpaceSpecConnectors(dict):
    def __init__(__self__, *,
                 endpoint_hosts: Sequence['outputs.AddressSpaceSpecConnectorsEndpointHosts'],
                 name: str,
                 addresses: Optional[Sequence['outputs.AddressSpaceSpecConnectorsAddresses']] = None,
                 credentials: Optional['outputs.AddressSpaceSpecConnectorsCredentials'] = None,
                 idle_timeout: Optional[int] = None,
                 max_frame_size: Optional[int] = None,
                 role: Optional[str] = None,
                 tls: Optional['outputs.AddressSpaceSpecConnectorsTls'] = None):
        """
        :param Sequence['AddressSpaceSpecConnectorsEndpointHostsArgs'] endpoint_hosts: Endpoints to connect to. First entry is used as primary, additional entries are considered failovers.
        :param str name: Connector name. Used to uniquely identify a connector.
        :param Sequence['AddressSpaceSpecConnectorsAddressesArgs'] addresses: Addresses to make be accessible via this address space.
        :param 'AddressSpaceSpecConnectorsCredentialsArgs' credentials: Credentials used when connecting to endpoints.
        :param int idle_timeout: Idle timeout of AMQP connection (seconds). 0 disables the idle timeout.
        :param int max_frame_size: Max frame size of AMQP connection.
        :param str role: Role of connector. Defaults to 'route-container'.
        :param 'AddressSpaceSpecConnectorsTlsArgs' tls: TLS configuration for the connector. If not specified, TLS will not be used.
        """
        pulumi.set(__self__, "endpoint_hosts", endpoint_hosts)
        pulumi.set(__self__, "name", name)
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if idle_timeout is not None:
            pulumi.set(__self__, "idle_timeout", idle_timeout)
        if max_frame_size is not None:
            pulumi.set(__self__, "max_frame_size", max_frame_size)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter(name="endpointHosts")
    def endpoint_hosts(self) -> Sequence['outputs.AddressSpaceSpecConnectorsEndpointHosts']:
        """
        Endpoints to connect to. First entry is used as primary, additional entries are considered failovers.
        """
        return pulumi.get(self, "endpoint_hosts")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Connector name. Used to uniquely identify a connector.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def addresses(self) -> Optional[Sequence['outputs.AddressSpaceSpecConnectorsAddresses']]:
        """
        Addresses to make be accessible via this address space.
        """
        return pulumi.get(self, "addresses")

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.AddressSpaceSpecConnectorsCredentials']:
        """
        Credentials used when connecting to endpoints.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> Optional[int]:
        """
        Idle timeout of AMQP connection (seconds). 0 disables the idle timeout.
        """
        return pulumi.get(self, "idle_timeout")

    @property
    @pulumi.getter(name="maxFrameSize")
    def max_frame_size(self) -> Optional[int]:
        """
        Max frame size of AMQP connection.
        """
        return pulumi.get(self, "max_frame_size")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        """
        Role of connector. Defaults to 'route-container'.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def tls(self) -> Optional['outputs.AddressSpaceSpecConnectorsTls']:
        """
        TLS configuration for the connector. If not specified, TLS will not be used.
        """
        return pulumi.get(self, "tls")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AddressSpaceSpecConnectorsAddresses(dict):
    def __init__(__self__, *,
                 name: str,
                 pattern: str):
        """
        :param str name: Identifier of address pattern. Used to uniquely identify a pattern.
        :param str pattern: Pattern used to match addresses. The pattern will be prefixed by the connector name and a forward slash ('myconnector/'). A pattern consists of one or more tokens separated by a forward slash /. A token can be one of the following: a * character, a # character, or a sequence of characters that do not include /, *, or #. The * token matches any single token. The # token matches zero or more tokens. * has higher precedence than #, and exact match has the highest precedence.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pattern", pattern)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Identifier of address pattern. Used to uniquely identify a pattern.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def pattern(self) -> str:
        """
        Pattern used to match addresses. The pattern will be prefixed by the connector name and a forward slash ('myconnector/'). A pattern consists of one or more tokens separated by a forward slash /. A token can be one of the following: a * character, a # character, or a sequence of characters that do not include /, *, or #. The * token matches any single token. The # token matches zero or more tokens. * has higher precedence than #, and exact match has the highest precedence.
        """
        return pulumi.get(self, "pattern")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AddressSpaceSpecConnectorsCredentials(dict):
    """
    Credentials used when connecting to endpoints.
    """
    def __init__(__self__, *,
                 password: 'outputs.AddressSpaceSpecConnectorsCredentialsPassword',
                 username: 'outputs.AddressSpaceSpecConnectorsCredentialsUsername'):
        """
        Credentials used when connecting to endpoints.
        :param 'AddressSpaceSpecConnectorsCredentialsPasswordArgs' password: Password to use for connector.
        :param 'AddressSpaceSpecConnectorsCredentialsUsernameArgs' username: Username to use for connector.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> 'outputs.AddressSpaceSpecConnectorsCredentialsPassword':
        """
        Password to use for connector.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> 'outputs.AddressSpaceSpecConnectorsCredentialsUsername':
        """
        Username to use for connector.
        """
        return pulumi.get(self, "username")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AddressSpaceSpecConnectorsCredentialsPassword(dict):
    def __init__(__self__):
        pass

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AddressSpaceSpecConnectorsCredentialsUsername(dict):
    def __init__(__self__):
        pass

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AddressSpaceSpecConnectorsEndpointHosts(dict):
    def __init__(__self__, *,
                 host: str,
                 port: Optional[int] = None):
        pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AddressSpaceSpecConnectorsTls(dict):
    """
    TLS configuration for the connector. If not specified, TLS will not be used.
    """
    def __init__(__self__, *,
                 ca_cert: Optional['outputs.AddressSpaceSpecConnectorsTlsCaCert'] = None,
                 client_cert: Optional['outputs.AddressSpaceSpecConnectorsTlsClientCert'] = None,
                 client_key: Optional['outputs.AddressSpaceSpecConnectorsTlsClientKey'] = None):
        """
        TLS configuration for the connector. If not specified, TLS will not be used.
        :param 'AddressSpaceSpecConnectorsTlsCaCertArgs' ca_cert: CA certificate to be used by the connector.
        :param 'AddressSpaceSpecConnectorsTlsClientCertArgs' client_cert: Client certificate to be used by the connector.
        :param 'AddressSpaceSpecConnectorsTlsClientKeyArgs' client_key: Client key to be used by the connector.
        """
        if ca_cert is not None:
            pulumi.set(__self__, "ca_cert", ca_cert)
        if client_cert is not None:
            pulumi.set(__self__, "client_cert", client_cert)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)

    @property
    @pulumi.getter(name="caCert")
    def ca_cert(self) -> Optional['outputs.AddressSpaceSpecConnectorsTlsCaCert']:
        """
        CA certificate to be used by the connector.
        """
        return pulumi.get(self, "ca_cert")

    @property
    @pulumi.getter(name="clientCert")
    def client_cert(self) -> Optional['outputs.AddressSpaceSpecConnectorsTlsClientCert']:
        """
        Client certificate to be used by the connector.
        """
        return pulumi.get(self, "client_cert")

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional['outputs.AddressSpaceSpecConnectorsTlsClientKey']:
        """
        Client key to be used by the connector.
        """
        return pulumi.get(self, "client_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AddressSpaceSpecConnectorsTlsCaCert(dict):
    def __init__(__self__):
        pass

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AddressSpaceSpecConnectorsTlsClientCert(dict):
    def __init__(__self__):
        pass

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AddressSpaceSpecConnectorsTlsClientKey(dict):
    def __init__(__self__):
        pass

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AddressSpaceSpecEndpoints(dict):
    def __init__(__self__, *,
                 cert: Optional['outputs.AddressSpaceSpecEndpointsCert'] = None,
                 exports: Optional[Sequence['outputs.AddressSpaceSpecEndpointsExports']] = None,
                 expose: Optional['outputs.AddressSpaceSpecEndpointsExpose'] = None,
                 name: Optional[str] = None,
                 service: Optional[str] = None):
        """
        :param 'AddressSpaceSpecEndpointsCertArgs' cert: Configure certificates to be used for this endpoint.
        :param Sequence['AddressSpaceSpecEndpointsExportsArgs'] exports: Export address space information.
        :param 'AddressSpaceSpecEndpointsExposeArgs' expose: Expose configuration of this endpoint.
        :param str name: Endpoint name. Use to uniquely identify an endpoint.
        :param str service: Service referenced by this endpoint. 'console' is no longer supported.
        """
        if cert is not None:
            pulumi.set(__self__, "cert", cert)
        if exports is not None:
            pulumi.set(__self__, "exports", exports)
        if expose is not None:
            pulumi.set(__self__, "expose", expose)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def cert(self) -> Optional['outputs.AddressSpaceSpecEndpointsCert']:
        """
        Configure certificates to be used for this endpoint.
        """
        return pulumi.get(self, "cert")

    @property
    @pulumi.getter
    def exports(self) -> Optional[Sequence['outputs.AddressSpaceSpecEndpointsExports']]:
        """
        Export address space information.
        """
        return pulumi.get(self, "exports")

    @property
    @pulumi.getter
    def expose(self) -> Optional['outputs.AddressSpaceSpecEndpointsExpose']:
        """
        Expose configuration of this endpoint.
        """
        return pulumi.get(self, "expose")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Endpoint name. Use to uniquely identify an endpoint.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Service referenced by this endpoint. 'console' is no longer supported.
        """
        return pulumi.get(self, "service")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AddressSpaceSpecEndpointsCert(dict):
    """
    Configure certificates to be used for this endpoint.
    """
    def __init__(__self__, *,
                 provider: Optional[str] = None,
                 secret_name: Optional[str] = None,
                 tls_cert: Optional[str] = None,
                 tls_key: Optional[str] = None):
        """
        Configure certificates to be used for this endpoint.
        :param str provider: Certificate provider to use for this endpoint.
        :param str tls_cert: TLS certificate to use for 'certBundle' provider.
        :param str tls_key: TLS key to use for 'certBundle' provider.
        """
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)
        if tls_cert is not None:
            pulumi.set(__self__, "tls_cert", tls_cert)
        if tls_key is not None:
            pulumi.set(__self__, "tls_key", tls_key)

    @property
    @pulumi.getter
    def provider(self) -> Optional[str]:
        """
        Certificate provider to use for this endpoint.
        """
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[str]:
        return pulumi.get(self, "secret_name")

    @property
    @pulumi.getter(name="tlsCert")
    def tls_cert(self) -> Optional[str]:
        """
        TLS certificate to use for 'certBundle' provider.
        """
        return pulumi.get(self, "tls_cert")

    @property
    @pulumi.getter(name="tlsKey")
    def tls_key(self) -> Optional[str]:
        """
        TLS key to use for 'certBundle' provider.
        """
        return pulumi.get(self, "tls_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AddressSpaceSpecEndpointsExports(dict):
    def __init__(__self__, *,
                 kind: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str kind: Type of resource to export address space information into.
        :param str name: Name of resource to export address space information into.
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Type of resource to export address space information into.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of resource to export address space information into.
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AddressSpaceSpecEndpointsExpose(dict):
    def __init__(__self__, *,
                 type: Optional[Any] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[Any]:
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AddressSpaceSpecNetworkPolicy(dict):
    """
    Define NetworkPolicy for this address space.
    """
    def __init__(__self__, *,
                 egress: Optional[Sequence[Mapping[str, Any]]] = None,
                 ingress: Optional[Sequence[Mapping[str, Any]]] = None):
        """
        Define NetworkPolicy for this address space.
        """
        if egress is not None:
            pulumi.set(__self__, "egress", egress)
        if ingress is not None:
            pulumi.set(__self__, "ingress", ingress)

    @property
    @pulumi.getter
    def egress(self) -> Optional[Sequence[Mapping[str, Any]]]:
        return pulumi.get(self, "egress")

    @property
    @pulumi.getter
    def ingress(self) -> Optional[Sequence[Mapping[str, Any]]]:
        return pulumi.get(self, "ingress")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AddressSpaceStatus(dict):
    def __init__(__self__, *,
                 ca_cert: Optional[str] = None,
                 connectors: Optional[Sequence['outputs.AddressSpaceStatusConnectors']] = None,
                 endpoint_statuses: Optional[Sequence['outputs.AddressSpaceStatusEndpointStatuses']] = None,
                 is_ready: Optional[bool] = None,
                 messages: Optional[Sequence[str]] = None,
                 phase: Optional[str] = None,
                 routers: Optional[Sequence['outputs.AddressSpaceStatusRouters']] = None):
        """
        :param str ca_cert: CA certificate for endpoints.
        :param Sequence['AddressSpaceStatusConnectorsArgs'] connectors: Connector status for this address space.
        :param Sequence['AddressSpaceStatusEndpointStatusesArgs'] endpoint_statuses: Endpoint status for this address space.
        :param bool is_ready: Whether address space is ready to use or not.
        :param Sequence[str] messages: Status and error messages for address space.
        :param str phase: Phase of address space.
        :param Sequence['AddressSpaceStatusRoutersArgs'] routers: Router status for this address space.
        """
        if ca_cert is not None:
            pulumi.set(__self__, "ca_cert", ca_cert)
        if connectors is not None:
            pulumi.set(__self__, "connectors", connectors)
        if endpoint_statuses is not None:
            pulumi.set(__self__, "endpoint_statuses", endpoint_statuses)
        if is_ready is not None:
            pulumi.set(__self__, "is_ready", is_ready)
        if messages is not None:
            pulumi.set(__self__, "messages", messages)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if routers is not None:
            pulumi.set(__self__, "routers", routers)

    @property
    @pulumi.getter(name="caCert")
    def ca_cert(self) -> Optional[str]:
        """
        CA certificate for endpoints.
        """
        return pulumi.get(self, "ca_cert")

    @property
    @pulumi.getter
    def connectors(self) -> Optional[Sequence['outputs.AddressSpaceStatusConnectors']]:
        """
        Connector status for this address space.
        """
        return pulumi.get(self, "connectors")

    @property
    @pulumi.getter(name="endpointStatuses")
    def endpoint_statuses(self) -> Optional[Sequence['outputs.AddressSpaceStatusEndpointStatuses']]:
        """
        Endpoint status for this address space.
        """
        return pulumi.get(self, "endpoint_statuses")

    @property
    @pulumi.getter(name="isReady")
    def is_ready(self) -> Optional[bool]:
        """
        Whether address space is ready to use or not.
        """
        return pulumi.get(self, "is_ready")

    @property
    @pulumi.getter
    def messages(self) -> Optional[Sequence[str]]:
        """
        Status and error messages for address space.
        """
        return pulumi.get(self, "messages")

    @property
    @pulumi.getter
    def phase(self) -> Optional[str]:
        """
        Phase of address space.
        """
        return pulumi.get(self, "phase")

    @property
    @pulumi.getter
    def routers(self) -> Optional[Sequence['outputs.AddressSpaceStatusRouters']]:
        """
        Router status for this address space.
        """
        return pulumi.get(self, "routers")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AddressSpaceStatusConnectors(dict):
    def __init__(__self__, *,
                 is_ready: Optional[bool] = None,
                 messages: Optional[Sequence[str]] = None,
                 name: Optional[str] = None):
        if is_ready is not None:
            pulumi.set(__self__, "is_ready", is_ready)
        if messages is not None:
            pulumi.set(__self__, "messages", messages)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="isReady")
    def is_ready(self) -> Optional[bool]:
        return pulumi.get(self, "is_ready")

    @property
    @pulumi.getter
    def messages(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "messages")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AddressSpaceStatusEndpointStatuses(dict):
    def __init__(__self__, *,
                 external_host: Optional[str] = None,
                 external_ports: Optional[Sequence[Mapping[str, Any]]] = None,
                 messages: Optional[Sequence[str]] = None,
                 name: Optional[str] = None,
                 service_host: Optional[str] = None,
                 service_ports: Optional[Sequence[Mapping[str, Any]]] = None):
        if external_host is not None:
            pulumi.set(__self__, "external_host", external_host)
        if external_ports is not None:
            pulumi.set(__self__, "external_ports", external_ports)
        if messages is not None:
            pulumi.set(__self__, "messages", messages)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if service_host is not None:
            pulumi.set(__self__, "service_host", service_host)
        if service_ports is not None:
            pulumi.set(__self__, "service_ports", service_ports)

    @property
    @pulumi.getter(name="externalHost")
    def external_host(self) -> Optional[str]:
        return pulumi.get(self, "external_host")

    @property
    @pulumi.getter(name="externalPorts")
    def external_ports(self) -> Optional[Sequence[Mapping[str, Any]]]:
        return pulumi.get(self, "external_ports")

    @property
    @pulumi.getter
    def messages(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "messages")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serviceHost")
    def service_host(self) -> Optional[str]:
        return pulumi.get(self, "service_host")

    @property
    @pulumi.getter(name="servicePorts")
    def service_ports(self) -> Optional[Sequence[Mapping[str, Any]]]:
        return pulumi.get(self, "service_ports")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AddressSpaceStatusRouters(dict):
    def __init__(__self__, *,
                 id: str,
                 neighbors: Optional[Sequence[str]] = None,
                 undelivered: Optional[int] = None):
        pulumi.set(__self__, "id", id)
        if neighbors is not None:
            pulumi.set(__self__, "neighbors", neighbors)
        if undelivered is not None:
            pulumi.set(__self__, "undelivered", undelivered)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def neighbors(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "neighbors")

    @property
    @pulumi.getter
    def undelivered(self) -> Optional[int]:
        return pulumi.get(self, "undelivered")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AddressSpec(dict):
    def __init__(__self__, *,
                 address: str,
                 plan: str,
                 type: str,
                 forwarders: Optional[Sequence['outputs.AddressSpecForwarders']] = None,
                 message_ttl: Optional['outputs.AddressSpecMessageTtl'] = None,
                 subscription: Optional['outputs.AddressSpecSubscription'] = None,
                 topic: Optional[str] = None):
        """
        :param str address: Messaging address.
        :param str plan: Plan referenced by this address.
        :param str type: Address type for this address.
        :param Sequence['AddressSpecForwardersArgs'] forwarders: Address forwarders for this address.
        :param 'AddressSpecMessageTtlArgs' message_ttl: Further restricts message time-to-live (TTL). Applies to address types queue and topic only. The maximum and minimum values must fall with the minimum/maximum range described by the plan's TTL settings.
        :param 'AddressSpecSubscriptionArgs' subscription: Properties that can be set for subscription type addresses.
        :param str topic: Address of topic that this subscription refers to (only applicable to subscription types).
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "plan", plan)
        pulumi.set(__self__, "type", type)
        if forwarders is not None:
            pulumi.set(__self__, "forwarders", forwarders)
        if message_ttl is not None:
            pulumi.set(__self__, "message_ttl", message_ttl)
        if subscription is not None:
            pulumi.set(__self__, "subscription", subscription)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        Messaging address.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def plan(self) -> str:
        """
        Plan referenced by this address.
        """
        return pulumi.get(self, "plan")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Address type for this address.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def forwarders(self) -> Optional[Sequence['outputs.AddressSpecForwarders']]:
        """
        Address forwarders for this address.
        """
        return pulumi.get(self, "forwarders")

    @property
    @pulumi.getter(name="messageTtl")
    def message_ttl(self) -> Optional['outputs.AddressSpecMessageTtl']:
        """
        Further restricts message time-to-live (TTL). Applies to address types queue and topic only. The maximum and minimum values must fall with the minimum/maximum range described by the plan's TTL settings.
        """
        return pulumi.get(self, "message_ttl")

    @property
    @pulumi.getter
    def subscription(self) -> Optional['outputs.AddressSpecSubscription']:
        """
        Properties that can be set for subscription type addresses.
        """
        return pulumi.get(self, "subscription")

    @property
    @pulumi.getter
    def topic(self) -> Optional[str]:
        """
        Address of topic that this subscription refers to (only applicable to subscription types).
        """
        return pulumi.get(self, "topic")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AddressSpecForwarders(dict):
    def __init__(__self__, *,
                 direction: str,
                 name: str,
                 remote_address: str):
        """
        :param str name: Forwarder name.
        :param str remote_address: Remote address to forward to. Must be prefixed with connector name.
        """
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "remote_address", remote_address)

    @property
    @pulumi.getter
    def direction(self) -> str:
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Forwarder name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="remoteAddress")
    def remote_address(self) -> str:
        """
        Remote address to forward to. Must be prefixed with connector name.
        """
        return pulumi.get(self, "remote_address")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AddressSpecMessageTtl(dict):
    """
    Further restricts message time-to-live (TTL). Applies to address types queue and topic only. The maximum and minimum values must fall with the minimum/maximum range described by the plan's TTL settings.
    """
    def __init__(__self__, *,
                 maximum: Optional[int] = None,
                 minimum: Optional[int] = None):
        """
        Further restricts message time-to-live (TTL). Applies to address types queue and topic only. The maximum and minimum values must fall with the minimum/maximum range described by the plan's TTL settings.
        :param int maximum: Imposes a maximum TTL value (in milliseconds) for messages arriving at the address.  Messages arriving with TTL values greater than this value (or no TTL value) will have their expiration adjusted.
        :param int minimum: Imposes a minimum TTL value (in milliseconds) for messages arriving at the address.  Messages arriving with TTL values less than this value will have their expiration adjusted.
        """
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)

    @property
    @pulumi.getter
    def maximum(self) -> Optional[int]:
        """
        Imposes a maximum TTL value (in milliseconds) for messages arriving at the address.  Messages arriving with TTL values greater than this value (or no TTL value) will have their expiration adjusted.
        """
        return pulumi.get(self, "maximum")

    @property
    @pulumi.getter
    def minimum(self) -> Optional[int]:
        """
        Imposes a minimum TTL value (in milliseconds) for messages arriving at the address.  Messages arriving with TTL values less than this value will have their expiration adjusted.
        """
        return pulumi.get(self, "minimum")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AddressSpecSubscription(dict):
    """
    Properties that can be set for subscription type addresses.
    """
    def __init__(__self__, *,
                 max_consumers: Optional[int] = None):
        """
        Properties that can be set for subscription type addresses.
        :param int max_consumers: Maximum number of concurrent consumers that can be attached to this subscription. If unspecified, 1 consumer is allowed per subscription
        """
        if max_consumers is not None:
            pulumi.set(__self__, "max_consumers", max_consumers)

    @property
    @pulumi.getter(name="maxConsumers")
    def max_consumers(self) -> Optional[int]:
        """
        Maximum number of concurrent consumers that can be attached to this subscription. If unspecified, 1 consumer is allowed per subscription
        """
        return pulumi.get(self, "max_consumers")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AddressStatus(dict):
    def __init__(__self__, *,
                 broker_statuses: Optional[Sequence['outputs.AddressStatusBrokerStatuses']] = None,
                 forwarders: Optional[Sequence['outputs.AddressStatusForwarders']] = None,
                 is_ready: Optional[bool] = None,
                 message_ttl: Optional['outputs.AddressStatusMessageTtl'] = None,
                 messages: Optional[Sequence[str]] = None,
                 phase: Optional[str] = None,
                 plan_status: Optional['outputs.AddressStatusPlanStatus'] = None,
                 subscription: Optional['outputs.AddressStatusSubscription'] = None):
        """
        :param Sequence['AddressStatusBrokerStatusesArgs'] broker_statuses: The status of this address in brokers.
        :param Sequence['AddressStatusForwardersArgs'] forwarders: Forwarder status for this address.
        :param bool is_ready: Whether address is ready to use or not.
        :param 'AddressStatusMessageTtlArgs' message_ttl: Applied message TTL properties.
        :param Sequence[str] messages: Status and error messages for address.
        :param str phase: Phase of address.
        :param 'AddressStatusSubscriptionArgs' subscription: Applied properties for subscription type addresses.
        """
        if broker_statuses is not None:
            pulumi.set(__self__, "broker_statuses", broker_statuses)
        if forwarders is not None:
            pulumi.set(__self__, "forwarders", forwarders)
        if is_ready is not None:
            pulumi.set(__self__, "is_ready", is_ready)
        if message_ttl is not None:
            pulumi.set(__self__, "message_ttl", message_ttl)
        if messages is not None:
            pulumi.set(__self__, "messages", messages)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if plan_status is not None:
            pulumi.set(__self__, "plan_status", plan_status)
        if subscription is not None:
            pulumi.set(__self__, "subscription", subscription)

    @property
    @pulumi.getter(name="brokerStatuses")
    def broker_statuses(self) -> Optional[Sequence['outputs.AddressStatusBrokerStatuses']]:
        """
        The status of this address in brokers.
        """
        return pulumi.get(self, "broker_statuses")

    @property
    @pulumi.getter
    def forwarders(self) -> Optional[Sequence['outputs.AddressStatusForwarders']]:
        """
        Forwarder status for this address.
        """
        return pulumi.get(self, "forwarders")

    @property
    @pulumi.getter(name="isReady")
    def is_ready(self) -> Optional[bool]:
        """
        Whether address is ready to use or not.
        """
        return pulumi.get(self, "is_ready")

    @property
    @pulumi.getter(name="messageTtl")
    def message_ttl(self) -> Optional['outputs.AddressStatusMessageTtl']:
        """
        Applied message TTL properties.
        """
        return pulumi.get(self, "message_ttl")

    @property
    @pulumi.getter
    def messages(self) -> Optional[Sequence[str]]:
        """
        Status and error messages for address.
        """
        return pulumi.get(self, "messages")

    @property
    @pulumi.getter
    def phase(self) -> Optional[str]:
        """
        Phase of address.
        """
        return pulumi.get(self, "phase")

    @property
    @pulumi.getter(name="planStatus")
    def plan_status(self) -> Optional['outputs.AddressStatusPlanStatus']:
        return pulumi.get(self, "plan_status")

    @property
    @pulumi.getter
    def subscription(self) -> Optional['outputs.AddressStatusSubscription']:
        """
        Applied properties for subscription type addresses.
        """
        return pulumi.get(self, "subscription")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AddressStatusBrokerStatuses(dict):
    def __init__(__self__, *,
                 broker_id: Optional[str] = None,
                 cluster_id: Optional[str] = None,
                 state: Optional[str] = None):
        if broker_id is not None:
            pulumi.set(__self__, "broker_id", broker_id)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="brokerId")
    def broker_id(self) -> Optional[str]:
        return pulumi.get(self, "broker_id")

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[str]:
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        return pulumi.get(self, "state")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AddressStatusForwarders(dict):
    def __init__(__self__, *,
                 is_ready: Optional[bool] = None,
                 messages: Optional[Sequence[str]] = None,
                 name: Optional[str] = None):
        if is_ready is not None:
            pulumi.set(__self__, "is_ready", is_ready)
        if messages is not None:
            pulumi.set(__self__, "messages", messages)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="isReady")
    def is_ready(self) -> Optional[bool]:
        return pulumi.get(self, "is_ready")

    @property
    @pulumi.getter
    def messages(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "messages")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AddressStatusMessageTtl(dict):
    """
    Applied message TTL properties.
    """
    def __init__(__self__, *,
                 maximum: Optional[int] = None,
                 minimum: Optional[int] = None):
        """
        Applied message TTL properties.
        :param int maximum: Maximum TTL value
        :param int minimum: Minimum TTL value
        """
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)

    @property
    @pulumi.getter
    def maximum(self) -> Optional[int]:
        """
        Maximum TTL value
        """
        return pulumi.get(self, "maximum")

    @property
    @pulumi.getter
    def minimum(self) -> Optional[int]:
        """
        Minimum TTL value
        """
        return pulumi.get(self, "minimum")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AddressStatusPlanStatus(dict):
    def __init__(__self__, *,
                 name: str,
                 partitions: int,
                 resources: Mapping[str, Any]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "partitions", partitions)
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def partitions(self) -> int:
        return pulumi.get(self, "partitions")

    @property
    @pulumi.getter
    def resources(self) -> Mapping[str, Any]:
        return pulumi.get(self, "resources")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AddressStatusSubscription(dict):
    """
    Applied properties for subscription type addresses.
    """
    def __init__(__self__, *,
                 max_consumers: Optional[int] = None):
        """
        Applied properties for subscription type addresses.
        :param int max_consumers: Maximum number of concurrent consumers that can be attached to this subscription.
        """
        if max_consumers is not None:
            pulumi.set(__self__, "max_consumers", max_consumers)

    @property
    @pulumi.getter(name="maxConsumers")
    def max_consumers(self) -> Optional[int]:
        """
        Maximum number of concurrent consumers that can be attached to this subscription.
        """
        return pulumi.get(self, "max_consumers")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


