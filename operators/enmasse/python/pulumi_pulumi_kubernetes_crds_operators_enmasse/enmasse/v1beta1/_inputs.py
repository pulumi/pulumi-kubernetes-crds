# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from ... import _utilities, _tables

__all__ = [
    'AddressSpaceSpecArgs',
    'AddressSpaceSpecAuthenticationServiceArgs',
    'AddressSpaceSpecAuthenticationServiceOverridesArgs',
    'AddressSpaceSpecConnectorsArgs',
    'AddressSpaceSpecConnectorsAddressesArgs',
    'AddressSpaceSpecConnectorsCredentialsArgs',
    'AddressSpaceSpecConnectorsCredentialsPasswordArgs',
    'AddressSpaceSpecConnectorsCredentialsUsernameArgs',
    'AddressSpaceSpecConnectorsEndpointHostsArgs',
    'AddressSpaceSpecConnectorsTlsArgs',
    'AddressSpaceSpecConnectorsTlsCaCertArgs',
    'AddressSpaceSpecConnectorsTlsClientCertArgs',
    'AddressSpaceSpecConnectorsTlsClientKeyArgs',
    'AddressSpaceSpecEndpointsArgs',
    'AddressSpaceSpecEndpointsCertArgs',
    'AddressSpaceSpecEndpointsExportsArgs',
    'AddressSpaceSpecEndpointsExposeArgs',
    'AddressSpaceSpecNetworkPolicyArgs',
    'AddressSpaceStatusArgs',
    'AddressSpaceStatusConnectorsArgs',
    'AddressSpaceStatusEndpointStatusesArgs',
    'AddressSpaceStatusRoutersArgs',
    'AddressSpecArgs',
    'AddressSpecForwardersArgs',
    'AddressSpecMessageTtlArgs',
    'AddressSpecSubscriptionArgs',
    'AddressStatusArgs',
    'AddressStatusBrokerStatusesArgs',
    'AddressStatusForwardersArgs',
    'AddressStatusMessageTtlArgs',
    'AddressStatusPlanStatusArgs',
    'AddressStatusSubscriptionArgs',
]

@pulumi.input_type
class AddressSpaceSpecArgs:
    def __init__(__self__, *,
                 plan: pulumi.Input[str],
                 type: pulumi.Input[str],
                 authentication_service: Optional[pulumi.Input['AddressSpaceSpecAuthenticationServiceArgs']] = None,
                 connectors: Optional[pulumi.Input[Sequence[pulumi.Input['AddressSpaceSpecConnectorsArgs']]]] = None,
                 endpoints: Optional[pulumi.Input[Sequence[pulumi.Input['AddressSpaceSpecEndpointsArgs']]]] = None,
                 network_policy: Optional[pulumi.Input['AddressSpaceSpecNetworkPolicyArgs']] = None):
        """
        :param pulumi.Input[str] plan: The name of the address space plan to apply.
        :param pulumi.Input[str] type: The type of address space.
        :param pulumi.Input['AddressSpaceSpecAuthenticationServiceArgs'] authentication_service: The authentication service to use for authenticating messaging clients.
        :param pulumi.Input[Sequence[pulumi.Input['AddressSpaceSpecConnectorsArgs']]] connectors: External AMQP connections.
        :param pulumi.Input[Sequence[pulumi.Input['AddressSpaceSpecEndpointsArgs']]] endpoints: Endpoints configured for this address space.
        :param pulumi.Input['AddressSpaceSpecNetworkPolicyArgs'] network_policy: Define NetworkPolicy for this address space.
        """
        pulumi.set(__self__, "plan", plan)
        pulumi.set(__self__, "type", type)
        if authentication_service is not None:
            pulumi.set(__self__, "authentication_service", authentication_service)
        if connectors is not None:
            pulumi.set(__self__, "connectors", connectors)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if network_policy is not None:
            pulumi.set(__self__, "network_policy", network_policy)

    @property
    @pulumi.getter
    def plan(self) -> pulumi.Input[str]:
        """
        The name of the address space plan to apply.
        """
        return pulumi.get(self, "plan")

    @plan.setter
    def plan(self, value: pulumi.Input[str]):
        pulumi.set(self, "plan", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of address space.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="authenticationService")
    def authentication_service(self) -> Optional[pulumi.Input['AddressSpaceSpecAuthenticationServiceArgs']]:
        """
        The authentication service to use for authenticating messaging clients.
        """
        return pulumi.get(self, "authentication_service")

    @authentication_service.setter
    def authentication_service(self, value: Optional[pulumi.Input['AddressSpaceSpecAuthenticationServiceArgs']]):
        pulumi.set(self, "authentication_service", value)

    @property
    @pulumi.getter
    def connectors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AddressSpaceSpecConnectorsArgs']]]]:
        """
        External AMQP connections.
        """
        return pulumi.get(self, "connectors")

    @connectors.setter
    def connectors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AddressSpaceSpecConnectorsArgs']]]]):
        pulumi.set(self, "connectors", value)

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AddressSpaceSpecEndpointsArgs']]]]:
        """
        Endpoints configured for this address space.
        """
        return pulumi.get(self, "endpoints")

    @endpoints.setter
    def endpoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AddressSpaceSpecEndpointsArgs']]]]):
        pulumi.set(self, "endpoints", value)

    @property
    @pulumi.getter(name="networkPolicy")
    def network_policy(self) -> Optional[pulumi.Input['AddressSpaceSpecNetworkPolicyArgs']]:
        """
        Define NetworkPolicy for this address space.
        """
        return pulumi.get(self, "network_policy")

    @network_policy.setter
    def network_policy(self, value: Optional[pulumi.Input['AddressSpaceSpecNetworkPolicyArgs']]):
        pulumi.set(self, "network_policy", value)


@pulumi.input_type
class AddressSpaceSpecAuthenticationServiceArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 overrides: Optional[pulumi.Input['AddressSpaceSpecAuthenticationServiceOverridesArgs']] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        The authentication service to use for authenticating messaging clients.
        :param pulumi.Input[str] name: The name of the authentication service.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the authentication service.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def overrides(self) -> Optional[pulumi.Input['AddressSpaceSpecAuthenticationServiceOverridesArgs']]:
        return pulumi.get(self, "overrides")

    @overrides.setter
    def overrides(self, value: Optional[pulumi.Input['AddressSpaceSpecAuthenticationServiceOverridesArgs']]):
        pulumi.set(self, "overrides", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class AddressSpaceSpecAuthenticationServiceOverridesArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 realm: Optional[pulumi.Input[str]] = None):
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if realm is not None:
            pulumi.set(__self__, "realm", realm)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def realm(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "realm")

    @realm.setter
    def realm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "realm", value)


@pulumi.input_type
class AddressSpaceSpecConnectorsArgs:
    def __init__(__self__, *,
                 endpoint_hosts: pulumi.Input[Sequence[pulumi.Input['AddressSpaceSpecConnectorsEndpointHostsArgs']]],
                 name: pulumi.Input[str],
                 addresses: Optional[pulumi.Input[Sequence[pulumi.Input['AddressSpaceSpecConnectorsAddressesArgs']]]] = None,
                 credentials: Optional[pulumi.Input['AddressSpaceSpecConnectorsCredentialsArgs']] = None,
                 idle_timeout: Optional[pulumi.Input[int]] = None,
                 max_frame_size: Optional[pulumi.Input[int]] = None,
                 role: Optional[pulumi.Input[str]] = None,
                 tls: Optional[pulumi.Input['AddressSpaceSpecConnectorsTlsArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AddressSpaceSpecConnectorsEndpointHostsArgs']]] endpoint_hosts: Endpoints to connect to. First entry is used as primary, additional entries are considered failovers.
        :param pulumi.Input[str] name: Connector name. Used to uniquely identify a connector.
        :param pulumi.Input[Sequence[pulumi.Input['AddressSpaceSpecConnectorsAddressesArgs']]] addresses: Addresses to make be accessible via this address space.
        :param pulumi.Input['AddressSpaceSpecConnectorsCredentialsArgs'] credentials: Credentials used when connecting to endpoints.
        :param pulumi.Input[int] idle_timeout: Idle timeout of AMQP connection (seconds). 0 disables the idle timeout.
        :param pulumi.Input[int] max_frame_size: Max frame size of AMQP connection.
        :param pulumi.Input[str] role: Role of connector. Defaults to 'route-container'.
        :param pulumi.Input['AddressSpaceSpecConnectorsTlsArgs'] tls: TLS configuration for the connector. If not specified, TLS will not be used.
        """
        pulumi.set(__self__, "endpoint_hosts", endpoint_hosts)
        pulumi.set(__self__, "name", name)
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if idle_timeout is not None:
            pulumi.set(__self__, "idle_timeout", idle_timeout)
        if max_frame_size is not None:
            pulumi.set(__self__, "max_frame_size", max_frame_size)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter(name="endpointHosts")
    def endpoint_hosts(self) -> pulumi.Input[Sequence[pulumi.Input['AddressSpaceSpecConnectorsEndpointHostsArgs']]]:
        """
        Endpoints to connect to. First entry is used as primary, additional entries are considered failovers.
        """
        return pulumi.get(self, "endpoint_hosts")

    @endpoint_hosts.setter
    def endpoint_hosts(self, value: pulumi.Input[Sequence[pulumi.Input['AddressSpaceSpecConnectorsEndpointHostsArgs']]]):
        pulumi.set(self, "endpoint_hosts", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Connector name. Used to uniquely identify a connector.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AddressSpaceSpecConnectorsAddressesArgs']]]]:
        """
        Addresses to make be accessible via this address space.
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AddressSpaceSpecConnectorsAddressesArgs']]]]):
        pulumi.set(self, "addresses", value)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input['AddressSpaceSpecConnectorsCredentialsArgs']]:
        """
        Credentials used when connecting to endpoints.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input['AddressSpaceSpecConnectorsCredentialsArgs']]):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Idle timeout of AMQP connection (seconds). 0 disables the idle timeout.
        """
        return pulumi.get(self, "idle_timeout")

    @idle_timeout.setter
    def idle_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "idle_timeout", value)

    @property
    @pulumi.getter(name="maxFrameSize")
    def max_frame_size(self) -> Optional[pulumi.Input[int]]:
        """
        Max frame size of AMQP connection.
        """
        return pulumi.get(self, "max_frame_size")

    @max_frame_size.setter
    def max_frame_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_frame_size", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        """
        Role of connector. Defaults to 'route-container'.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input['AddressSpaceSpecConnectorsTlsArgs']]:
        """
        TLS configuration for the connector. If not specified, TLS will not be used.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input['AddressSpaceSpecConnectorsTlsArgs']]):
        pulumi.set(self, "tls", value)


@pulumi.input_type
class AddressSpaceSpecConnectorsAddressesArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 pattern: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Identifier of address pattern. Used to uniquely identify a pattern.
        :param pulumi.Input[str] pattern: Pattern used to match addresses. The pattern will be prefixed by the connector name and a forward slash ('myconnector/'). A pattern consists of one or more tokens separated by a forward slash /. A token can be one of the following: a * character, a # character, or a sequence of characters that do not include /, *, or #. The * token matches any single token. The # token matches zero or more tokens. * has higher precedence than #, and exact match has the highest precedence.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pattern", pattern)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Identifier of address pattern. Used to uniquely identify a pattern.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def pattern(self) -> pulumi.Input[str]:
        """
        Pattern used to match addresses. The pattern will be prefixed by the connector name and a forward slash ('myconnector/'). A pattern consists of one or more tokens separated by a forward slash /. A token can be one of the following: a * character, a # character, or a sequence of characters that do not include /, *, or #. The * token matches any single token. The # token matches zero or more tokens. * has higher precedence than #, and exact match has the highest precedence.
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: pulumi.Input[str]):
        pulumi.set(self, "pattern", value)


@pulumi.input_type
class AddressSpaceSpecConnectorsCredentialsArgs:
    def __init__(__self__, *,
                 password: pulumi.Input['AddressSpaceSpecConnectorsCredentialsPasswordArgs'],
                 username: pulumi.Input['AddressSpaceSpecConnectorsCredentialsUsernameArgs']):
        """
        Credentials used when connecting to endpoints.
        :param pulumi.Input['AddressSpaceSpecConnectorsCredentialsPasswordArgs'] password: Password to use for connector.
        :param pulumi.Input['AddressSpaceSpecConnectorsCredentialsUsernameArgs'] username: Username to use for connector.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input['AddressSpaceSpecConnectorsCredentialsPasswordArgs']:
        """
        Password to use for connector.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input['AddressSpaceSpecConnectorsCredentialsPasswordArgs']):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input['AddressSpaceSpecConnectorsCredentialsUsernameArgs']:
        """
        Username to use for connector.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input['AddressSpaceSpecConnectorsCredentialsUsernameArgs']):
        pulumi.set(self, "username", value)


@pulumi.input_type
class AddressSpaceSpecConnectorsCredentialsPasswordArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class AddressSpaceSpecConnectorsCredentialsUsernameArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class AddressSpaceSpecConnectorsEndpointHostsArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[str],
                 port: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


@pulumi.input_type
class AddressSpaceSpecConnectorsTlsArgs:
    def __init__(__self__, *,
                 ca_cert: Optional[pulumi.Input['AddressSpaceSpecConnectorsTlsCaCertArgs']] = None,
                 client_cert: Optional[pulumi.Input['AddressSpaceSpecConnectorsTlsClientCertArgs']] = None,
                 client_key: Optional[pulumi.Input['AddressSpaceSpecConnectorsTlsClientKeyArgs']] = None):
        """
        TLS configuration for the connector. If not specified, TLS will not be used.
        :param pulumi.Input['AddressSpaceSpecConnectorsTlsCaCertArgs'] ca_cert: CA certificate to be used by the connector.
        :param pulumi.Input['AddressSpaceSpecConnectorsTlsClientCertArgs'] client_cert: Client certificate to be used by the connector.
        :param pulumi.Input['AddressSpaceSpecConnectorsTlsClientKeyArgs'] client_key: Client key to be used by the connector.
        """
        if ca_cert is not None:
            pulumi.set(__self__, "ca_cert", ca_cert)
        if client_cert is not None:
            pulumi.set(__self__, "client_cert", client_cert)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)

    @property
    @pulumi.getter(name="caCert")
    def ca_cert(self) -> Optional[pulumi.Input['AddressSpaceSpecConnectorsTlsCaCertArgs']]:
        """
        CA certificate to be used by the connector.
        """
        return pulumi.get(self, "ca_cert")

    @ca_cert.setter
    def ca_cert(self, value: Optional[pulumi.Input['AddressSpaceSpecConnectorsTlsCaCertArgs']]):
        pulumi.set(self, "ca_cert", value)

    @property
    @pulumi.getter(name="clientCert")
    def client_cert(self) -> Optional[pulumi.Input['AddressSpaceSpecConnectorsTlsClientCertArgs']]:
        """
        Client certificate to be used by the connector.
        """
        return pulumi.get(self, "client_cert")

    @client_cert.setter
    def client_cert(self, value: Optional[pulumi.Input['AddressSpaceSpecConnectorsTlsClientCertArgs']]):
        pulumi.set(self, "client_cert", value)

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[pulumi.Input['AddressSpaceSpecConnectorsTlsClientKeyArgs']]:
        """
        Client key to be used by the connector.
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: Optional[pulumi.Input['AddressSpaceSpecConnectorsTlsClientKeyArgs']]):
        pulumi.set(self, "client_key", value)


@pulumi.input_type
class AddressSpaceSpecConnectorsTlsCaCertArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class AddressSpaceSpecConnectorsTlsClientCertArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class AddressSpaceSpecConnectorsTlsClientKeyArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class AddressSpaceSpecEndpointsArgs:
    def __init__(__self__, *,
                 cert: Optional[pulumi.Input['AddressSpaceSpecEndpointsCertArgs']] = None,
                 exports: Optional[pulumi.Input[Sequence[pulumi.Input['AddressSpaceSpecEndpointsExportsArgs']]]] = None,
                 expose: Optional[pulumi.Input['AddressSpaceSpecEndpointsExposeArgs']] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 service: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['AddressSpaceSpecEndpointsCertArgs'] cert: Configure certificates to be used for this endpoint.
        :param pulumi.Input[Sequence[pulumi.Input['AddressSpaceSpecEndpointsExportsArgs']]] exports: Export address space information.
        :param pulumi.Input['AddressSpaceSpecEndpointsExposeArgs'] expose: Expose configuration of this endpoint.
        :param pulumi.Input[str] name: Endpoint name. Use to uniquely identify an endpoint.
        :param pulumi.Input[str] service: Service referenced by this endpoint. 'console' is no longer supported.
        """
        if cert is not None:
            pulumi.set(__self__, "cert", cert)
        if exports is not None:
            pulumi.set(__self__, "exports", exports)
        if expose is not None:
            pulumi.set(__self__, "expose", expose)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def cert(self) -> Optional[pulumi.Input['AddressSpaceSpecEndpointsCertArgs']]:
        """
        Configure certificates to be used for this endpoint.
        """
        return pulumi.get(self, "cert")

    @cert.setter
    def cert(self, value: Optional[pulumi.Input['AddressSpaceSpecEndpointsCertArgs']]):
        pulumi.set(self, "cert", value)

    @property
    @pulumi.getter
    def exports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AddressSpaceSpecEndpointsExportsArgs']]]]:
        """
        Export address space information.
        """
        return pulumi.get(self, "exports")

    @exports.setter
    def exports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AddressSpaceSpecEndpointsExportsArgs']]]]):
        pulumi.set(self, "exports", value)

    @property
    @pulumi.getter
    def expose(self) -> Optional[pulumi.Input['AddressSpaceSpecEndpointsExposeArgs']]:
        """
        Expose configuration of this endpoint.
        """
        return pulumi.get(self, "expose")

    @expose.setter
    def expose(self, value: Optional[pulumi.Input['AddressSpaceSpecEndpointsExposeArgs']]):
        pulumi.set(self, "expose", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Endpoint name. Use to uniquely identify an endpoint.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[str]]:
        """
        Service referenced by this endpoint. 'console' is no longer supported.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service", value)


@pulumi.input_type
class AddressSpaceSpecEndpointsCertArgs:
    def __init__(__self__, *,
                 provider: Optional[pulumi.Input[str]] = None,
                 secret_name: Optional[pulumi.Input[str]] = None,
                 tls_cert: Optional[pulumi.Input[str]] = None,
                 tls_key: Optional[pulumi.Input[str]] = None):
        """
        Configure certificates to be used for this endpoint.
        :param pulumi.Input[str] provider: Certificate provider to use for this endpoint.
        :param pulumi.Input[str] tls_cert: TLS certificate to use for 'certBundle' provider.
        :param pulumi.Input[str] tls_key: TLS key to use for 'certBundle' provider.
        """
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)
        if tls_cert is not None:
            pulumi.set(__self__, "tls_cert", tls_cert)
        if tls_key is not None:
            pulumi.set(__self__, "tls_key", tls_key)

    @property
    @pulumi.getter
    def provider(self) -> Optional[pulumi.Input[str]]:
        """
        Certificate provider to use for this endpoint.
        """
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "provider", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_name", value)

    @property
    @pulumi.getter(name="tlsCert")
    def tls_cert(self) -> Optional[pulumi.Input[str]]:
        """
        TLS certificate to use for 'certBundle' provider.
        """
        return pulumi.get(self, "tls_cert")

    @tls_cert.setter
    def tls_cert(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tls_cert", value)

    @property
    @pulumi.getter(name="tlsKey")
    def tls_key(self) -> Optional[pulumi.Input[str]]:
        """
        TLS key to use for 'certBundle' provider.
        """
        return pulumi.get(self, "tls_key")

    @tls_key.setter
    def tls_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tls_key", value)


@pulumi.input_type
class AddressSpaceSpecEndpointsExportsArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: Type of resource to export address space information into.
        :param pulumi.Input[str] name: Name of resource to export address space information into.
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Type of resource to export address space information into.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of resource to export address space information into.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class AddressSpaceSpecEndpointsExposeArgs:
    def __init__(__self__, *,
                 type: Optional[Any] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[Any]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[Any]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class AddressSpaceSpecNetworkPolicyArgs:
    def __init__(__self__, *,
                 egress: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]] = None,
                 ingress: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]] = None):
        """
        Define NetworkPolicy for this address space.
        """
        if egress is not None:
            pulumi.set(__self__, "egress", egress)
        if ingress is not None:
            pulumi.set(__self__, "ingress", ingress)

    @property
    @pulumi.getter
    def egress(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]]:
        return pulumi.get(self, "egress")

    @egress.setter
    def egress(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]]):
        pulumi.set(self, "egress", value)

    @property
    @pulumi.getter
    def ingress(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]]:
        return pulumi.get(self, "ingress")

    @ingress.setter
    def ingress(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]]):
        pulumi.set(self, "ingress", value)


@pulumi.input_type
class AddressSpaceStatusArgs:
    def __init__(__self__, *,
                 ca_cert: Optional[pulumi.Input[str]] = None,
                 connectors: Optional[pulumi.Input[Sequence[pulumi.Input['AddressSpaceStatusConnectorsArgs']]]] = None,
                 endpoint_statuses: Optional[pulumi.Input[Sequence[pulumi.Input['AddressSpaceStatusEndpointStatusesArgs']]]] = None,
                 is_ready: Optional[pulumi.Input[bool]] = None,
                 messages: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 phase: Optional[pulumi.Input[str]] = None,
                 routers: Optional[pulumi.Input[Sequence[pulumi.Input['AddressSpaceStatusRoutersArgs']]]] = None):
        """
        :param pulumi.Input[str] ca_cert: CA certificate for endpoints.
        :param pulumi.Input[Sequence[pulumi.Input['AddressSpaceStatusConnectorsArgs']]] connectors: Connector status for this address space.
        :param pulumi.Input[Sequence[pulumi.Input['AddressSpaceStatusEndpointStatusesArgs']]] endpoint_statuses: Endpoint status for this address space.
        :param pulumi.Input[bool] is_ready: Whether address space is ready to use or not.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] messages: Status and error messages for address space.
        :param pulumi.Input[str] phase: Phase of address space.
        :param pulumi.Input[Sequence[pulumi.Input['AddressSpaceStatusRoutersArgs']]] routers: Router status for this address space.
        """
        if ca_cert is not None:
            pulumi.set(__self__, "ca_cert", ca_cert)
        if connectors is not None:
            pulumi.set(__self__, "connectors", connectors)
        if endpoint_statuses is not None:
            pulumi.set(__self__, "endpoint_statuses", endpoint_statuses)
        if is_ready is not None:
            pulumi.set(__self__, "is_ready", is_ready)
        if messages is not None:
            pulumi.set(__self__, "messages", messages)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if routers is not None:
            pulumi.set(__self__, "routers", routers)

    @property
    @pulumi.getter(name="caCert")
    def ca_cert(self) -> Optional[pulumi.Input[str]]:
        """
        CA certificate for endpoints.
        """
        return pulumi.get(self, "ca_cert")

    @ca_cert.setter
    def ca_cert(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_cert", value)

    @property
    @pulumi.getter
    def connectors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AddressSpaceStatusConnectorsArgs']]]]:
        """
        Connector status for this address space.
        """
        return pulumi.get(self, "connectors")

    @connectors.setter
    def connectors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AddressSpaceStatusConnectorsArgs']]]]):
        pulumi.set(self, "connectors", value)

    @property
    @pulumi.getter(name="endpointStatuses")
    def endpoint_statuses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AddressSpaceStatusEndpointStatusesArgs']]]]:
        """
        Endpoint status for this address space.
        """
        return pulumi.get(self, "endpoint_statuses")

    @endpoint_statuses.setter
    def endpoint_statuses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AddressSpaceStatusEndpointStatusesArgs']]]]):
        pulumi.set(self, "endpoint_statuses", value)

    @property
    @pulumi.getter(name="isReady")
    def is_ready(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether address space is ready to use or not.
        """
        return pulumi.get(self, "is_ready")

    @is_ready.setter
    def is_ready(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_ready", value)

    @property
    @pulumi.getter
    def messages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Status and error messages for address space.
        """
        return pulumi.get(self, "messages")

    @messages.setter
    def messages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "messages", value)

    @property
    @pulumi.getter
    def phase(self) -> Optional[pulumi.Input[str]]:
        """
        Phase of address space.
        """
        return pulumi.get(self, "phase")

    @phase.setter
    def phase(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "phase", value)

    @property
    @pulumi.getter
    def routers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AddressSpaceStatusRoutersArgs']]]]:
        """
        Router status for this address space.
        """
        return pulumi.get(self, "routers")

    @routers.setter
    def routers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AddressSpaceStatusRoutersArgs']]]]):
        pulumi.set(self, "routers", value)


@pulumi.input_type
class AddressSpaceStatusConnectorsArgs:
    def __init__(__self__, *,
                 is_ready: Optional[pulumi.Input[bool]] = None,
                 messages: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        if is_ready is not None:
            pulumi.set(__self__, "is_ready", is_ready)
        if messages is not None:
            pulumi.set(__self__, "messages", messages)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="isReady")
    def is_ready(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_ready")

    @is_ready.setter
    def is_ready(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_ready", value)

    @property
    @pulumi.getter
    def messages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "messages")

    @messages.setter
    def messages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "messages", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class AddressSpaceStatusEndpointStatusesArgs:
    def __init__(__self__, *,
                 external_host: Optional[pulumi.Input[str]] = None,
                 external_ports: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]] = None,
                 messages: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 service_host: Optional[pulumi.Input[str]] = None,
                 service_ports: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]] = None):
        if external_host is not None:
            pulumi.set(__self__, "external_host", external_host)
        if external_ports is not None:
            pulumi.set(__self__, "external_ports", external_ports)
        if messages is not None:
            pulumi.set(__self__, "messages", messages)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if service_host is not None:
            pulumi.set(__self__, "service_host", service_host)
        if service_ports is not None:
            pulumi.set(__self__, "service_ports", service_ports)

    @property
    @pulumi.getter(name="externalHost")
    def external_host(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "external_host")

    @external_host.setter
    def external_host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "external_host", value)

    @property
    @pulumi.getter(name="externalPorts")
    def external_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]]:
        return pulumi.get(self, "external_ports")

    @external_ports.setter
    def external_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]]):
        pulumi.set(self, "external_ports", value)

    @property
    @pulumi.getter
    def messages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "messages")

    @messages.setter
    def messages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "messages", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="serviceHost")
    def service_host(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "service_host")

    @service_host.setter
    def service_host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_host", value)

    @property
    @pulumi.getter(name="servicePorts")
    def service_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]]:
        return pulumi.get(self, "service_ports")

    @service_ports.setter
    def service_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, Any]]]]]):
        pulumi.set(self, "service_ports", value)


@pulumi.input_type
class AddressSpaceStatusRoutersArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 neighbors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 undelivered: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "id", id)
        if neighbors is not None:
            pulumi.set(__self__, "neighbors", neighbors)
        if undelivered is not None:
            pulumi.set(__self__, "undelivered", undelivered)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def neighbors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "neighbors")

    @neighbors.setter
    def neighbors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "neighbors", value)

    @property
    @pulumi.getter
    def undelivered(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "undelivered")

    @undelivered.setter
    def undelivered(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "undelivered", value)


@pulumi.input_type
class AddressSpecArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[str],
                 plan: pulumi.Input[str],
                 type: pulumi.Input[str],
                 forwarders: Optional[pulumi.Input[Sequence[pulumi.Input['AddressSpecForwardersArgs']]]] = None,
                 message_ttl: Optional[pulumi.Input['AddressSpecMessageTtlArgs']] = None,
                 subscription: Optional[pulumi.Input['AddressSpecSubscriptionArgs']] = None,
                 topic: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address: Messaging address.
        :param pulumi.Input[str] plan: Plan referenced by this address.
        :param pulumi.Input[str] type: Address type for this address.
        :param pulumi.Input[Sequence[pulumi.Input['AddressSpecForwardersArgs']]] forwarders: Address forwarders for this address.
        :param pulumi.Input['AddressSpecMessageTtlArgs'] message_ttl: Further restricts message time-to-live (TTL). Applies to address types queue and topic only. The maximum and minimum values must fall with the minimum/maximum range described by the plan's TTL settings.
        :param pulumi.Input['AddressSpecSubscriptionArgs'] subscription: Properties that can be set for subscription type addresses.
        :param pulumi.Input[str] topic: Address of topic that this subscription refers to (only applicable to subscription types).
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "plan", plan)
        pulumi.set(__self__, "type", type)
        if forwarders is not None:
            pulumi.set(__self__, "forwarders", forwarders)
        if message_ttl is not None:
            pulumi.set(__self__, "message_ttl", message_ttl)
        if subscription is not None:
            pulumi.set(__self__, "subscription", subscription)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)

    @property
    @pulumi.getter
    def address(self) -> pulumi.Input[str]:
        """
        Messaging address.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[str]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def plan(self) -> pulumi.Input[str]:
        """
        Plan referenced by this address.
        """
        return pulumi.get(self, "plan")

    @plan.setter
    def plan(self, value: pulumi.Input[str]):
        pulumi.set(self, "plan", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Address type for this address.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def forwarders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AddressSpecForwardersArgs']]]]:
        """
        Address forwarders for this address.
        """
        return pulumi.get(self, "forwarders")

    @forwarders.setter
    def forwarders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AddressSpecForwardersArgs']]]]):
        pulumi.set(self, "forwarders", value)

    @property
    @pulumi.getter(name="messageTtl")
    def message_ttl(self) -> Optional[pulumi.Input['AddressSpecMessageTtlArgs']]:
        """
        Further restricts message time-to-live (TTL). Applies to address types queue and topic only. The maximum and minimum values must fall with the minimum/maximum range described by the plan's TTL settings.
        """
        return pulumi.get(self, "message_ttl")

    @message_ttl.setter
    def message_ttl(self, value: Optional[pulumi.Input['AddressSpecMessageTtlArgs']]):
        pulumi.set(self, "message_ttl", value)

    @property
    @pulumi.getter
    def subscription(self) -> Optional[pulumi.Input['AddressSpecSubscriptionArgs']]:
        """
        Properties that can be set for subscription type addresses.
        """
        return pulumi.get(self, "subscription")

    @subscription.setter
    def subscription(self, value: Optional[pulumi.Input['AddressSpecSubscriptionArgs']]):
        pulumi.set(self, "subscription", value)

    @property
    @pulumi.getter
    def topic(self) -> Optional[pulumi.Input[str]]:
        """
        Address of topic that this subscription refers to (only applicable to subscription types).
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topic", value)


@pulumi.input_type
class AddressSpecForwardersArgs:
    def __init__(__self__, *,
                 direction: pulumi.Input[str],
                 name: pulumi.Input[str],
                 remote_address: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Forwarder name.
        :param pulumi.Input[str] remote_address: Remote address to forward to. Must be prefixed with connector name.
        """
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "remote_address", remote_address)

    @property
    @pulumi.getter
    def direction(self) -> pulumi.Input[str]:
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: pulumi.Input[str]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Forwarder name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="remoteAddress")
    def remote_address(self) -> pulumi.Input[str]:
        """
        Remote address to forward to. Must be prefixed with connector name.
        """
        return pulumi.get(self, "remote_address")

    @remote_address.setter
    def remote_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "remote_address", value)


@pulumi.input_type
class AddressSpecMessageTtlArgs:
    def __init__(__self__, *,
                 maximum: Optional[pulumi.Input[int]] = None,
                 minimum: Optional[pulumi.Input[int]] = None):
        """
        Further restricts message time-to-live (TTL). Applies to address types queue and topic only. The maximum and minimum values must fall with the minimum/maximum range described by the plan's TTL settings.
        :param pulumi.Input[int] maximum: Imposes a maximum TTL value (in milliseconds) for messages arriving at the address.  Messages arriving with TTL values greater than this value (or no TTL value) will have their expiration adjusted.
        :param pulumi.Input[int] minimum: Imposes a minimum TTL value (in milliseconds) for messages arriving at the address.  Messages arriving with TTL values less than this value will have their expiration adjusted.
        """
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)

    @property
    @pulumi.getter
    def maximum(self) -> Optional[pulumi.Input[int]]:
        """
        Imposes a maximum TTL value (in milliseconds) for messages arriving at the address.  Messages arriving with TTL values greater than this value (or no TTL value) will have their expiration adjusted.
        """
        return pulumi.get(self, "maximum")

    @maximum.setter
    def maximum(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "maximum", value)

    @property
    @pulumi.getter
    def minimum(self) -> Optional[pulumi.Input[int]]:
        """
        Imposes a minimum TTL value (in milliseconds) for messages arriving at the address.  Messages arriving with TTL values less than this value will have their expiration adjusted.
        """
        return pulumi.get(self, "minimum")

    @minimum.setter
    def minimum(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minimum", value)


@pulumi.input_type
class AddressSpecSubscriptionArgs:
    def __init__(__self__, *,
                 max_consumers: Optional[pulumi.Input[int]] = None):
        """
        Properties that can be set for subscription type addresses.
        :param pulumi.Input[int] max_consumers: Maximum number of concurrent consumers that can be attached to this subscription. If unspecified, 1 consumer is allowed per subscription
        """
        if max_consumers is not None:
            pulumi.set(__self__, "max_consumers", max_consumers)

    @property
    @pulumi.getter(name="maxConsumers")
    def max_consumers(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of concurrent consumers that can be attached to this subscription. If unspecified, 1 consumer is allowed per subscription
        """
        return pulumi.get(self, "max_consumers")

    @max_consumers.setter
    def max_consumers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_consumers", value)


@pulumi.input_type
class AddressStatusArgs:
    def __init__(__self__, *,
                 broker_statuses: Optional[pulumi.Input[Sequence[pulumi.Input['AddressStatusBrokerStatusesArgs']]]] = None,
                 forwarders: Optional[pulumi.Input[Sequence[pulumi.Input['AddressStatusForwardersArgs']]]] = None,
                 is_ready: Optional[pulumi.Input[bool]] = None,
                 message_ttl: Optional[pulumi.Input['AddressStatusMessageTtlArgs']] = None,
                 messages: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 phase: Optional[pulumi.Input[str]] = None,
                 plan_status: Optional[pulumi.Input['AddressStatusPlanStatusArgs']] = None,
                 subscription: Optional[pulumi.Input['AddressStatusSubscriptionArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AddressStatusBrokerStatusesArgs']]] broker_statuses: The status of this address in brokers.
        :param pulumi.Input[Sequence[pulumi.Input['AddressStatusForwardersArgs']]] forwarders: Forwarder status for this address.
        :param pulumi.Input[bool] is_ready: Whether address is ready to use or not.
        :param pulumi.Input['AddressStatusMessageTtlArgs'] message_ttl: Applied message TTL properties.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] messages: Status and error messages for address.
        :param pulumi.Input[str] phase: Phase of address.
        :param pulumi.Input['AddressStatusSubscriptionArgs'] subscription: Applied properties for subscription type addresses.
        """
        if broker_statuses is not None:
            pulumi.set(__self__, "broker_statuses", broker_statuses)
        if forwarders is not None:
            pulumi.set(__self__, "forwarders", forwarders)
        if is_ready is not None:
            pulumi.set(__self__, "is_ready", is_ready)
        if message_ttl is not None:
            pulumi.set(__self__, "message_ttl", message_ttl)
        if messages is not None:
            pulumi.set(__self__, "messages", messages)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if plan_status is not None:
            pulumi.set(__self__, "plan_status", plan_status)
        if subscription is not None:
            pulumi.set(__self__, "subscription", subscription)

    @property
    @pulumi.getter(name="brokerStatuses")
    def broker_statuses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AddressStatusBrokerStatusesArgs']]]]:
        """
        The status of this address in brokers.
        """
        return pulumi.get(self, "broker_statuses")

    @broker_statuses.setter
    def broker_statuses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AddressStatusBrokerStatusesArgs']]]]):
        pulumi.set(self, "broker_statuses", value)

    @property
    @pulumi.getter
    def forwarders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AddressStatusForwardersArgs']]]]:
        """
        Forwarder status for this address.
        """
        return pulumi.get(self, "forwarders")

    @forwarders.setter
    def forwarders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AddressStatusForwardersArgs']]]]):
        pulumi.set(self, "forwarders", value)

    @property
    @pulumi.getter(name="isReady")
    def is_ready(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether address is ready to use or not.
        """
        return pulumi.get(self, "is_ready")

    @is_ready.setter
    def is_ready(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_ready", value)

    @property
    @pulumi.getter(name="messageTtl")
    def message_ttl(self) -> Optional[pulumi.Input['AddressStatusMessageTtlArgs']]:
        """
        Applied message TTL properties.
        """
        return pulumi.get(self, "message_ttl")

    @message_ttl.setter
    def message_ttl(self, value: Optional[pulumi.Input['AddressStatusMessageTtlArgs']]):
        pulumi.set(self, "message_ttl", value)

    @property
    @pulumi.getter
    def messages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Status and error messages for address.
        """
        return pulumi.get(self, "messages")

    @messages.setter
    def messages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "messages", value)

    @property
    @pulumi.getter
    def phase(self) -> Optional[pulumi.Input[str]]:
        """
        Phase of address.
        """
        return pulumi.get(self, "phase")

    @phase.setter
    def phase(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "phase", value)

    @property
    @pulumi.getter(name="planStatus")
    def plan_status(self) -> Optional[pulumi.Input['AddressStatusPlanStatusArgs']]:
        return pulumi.get(self, "plan_status")

    @plan_status.setter
    def plan_status(self, value: Optional[pulumi.Input['AddressStatusPlanStatusArgs']]):
        pulumi.set(self, "plan_status", value)

    @property
    @pulumi.getter
    def subscription(self) -> Optional[pulumi.Input['AddressStatusSubscriptionArgs']]:
        """
        Applied properties for subscription type addresses.
        """
        return pulumi.get(self, "subscription")

    @subscription.setter
    def subscription(self, value: Optional[pulumi.Input['AddressStatusSubscriptionArgs']]):
        pulumi.set(self, "subscription", value)


@pulumi.input_type
class AddressStatusBrokerStatusesArgs:
    def __init__(__self__, *,
                 broker_id: Optional[pulumi.Input[str]] = None,
                 cluster_id: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        if broker_id is not None:
            pulumi.set(__self__, "broker_id", broker_id)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="brokerId")
    def broker_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "broker_id")

    @broker_id.setter
    def broker_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "broker_id", value)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


@pulumi.input_type
class AddressStatusForwardersArgs:
    def __init__(__self__, *,
                 is_ready: Optional[pulumi.Input[bool]] = None,
                 messages: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        if is_ready is not None:
            pulumi.set(__self__, "is_ready", is_ready)
        if messages is not None:
            pulumi.set(__self__, "messages", messages)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="isReady")
    def is_ready(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_ready")

    @is_ready.setter
    def is_ready(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_ready", value)

    @property
    @pulumi.getter
    def messages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "messages")

    @messages.setter
    def messages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "messages", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class AddressStatusMessageTtlArgs:
    def __init__(__self__, *,
                 maximum: Optional[pulumi.Input[int]] = None,
                 minimum: Optional[pulumi.Input[int]] = None):
        """
        Applied message TTL properties.
        :param pulumi.Input[int] maximum: Maximum TTL value
        :param pulumi.Input[int] minimum: Minimum TTL value
        """
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)

    @property
    @pulumi.getter
    def maximum(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum TTL value
        """
        return pulumi.get(self, "maximum")

    @maximum.setter
    def maximum(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "maximum", value)

    @property
    @pulumi.getter
    def minimum(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum TTL value
        """
        return pulumi.get(self, "minimum")

    @minimum.setter
    def minimum(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minimum", value)


@pulumi.input_type
class AddressStatusPlanStatusArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 partitions: pulumi.Input[int],
                 resources: pulumi.Input[Mapping[str, Any]]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "partitions", partitions)
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def partitions(self) -> pulumi.Input[int]:
        return pulumi.get(self, "partitions")

    @partitions.setter
    def partitions(self, value: pulumi.Input[int]):
        pulumi.set(self, "partitions", value)

    @property
    @pulumi.getter
    def resources(self) -> pulumi.Input[Mapping[str, Any]]:
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: pulumi.Input[Mapping[str, Any]]):
        pulumi.set(self, "resources", value)


@pulumi.input_type
class AddressStatusSubscriptionArgs:
    def __init__(__self__, *,
                 max_consumers: Optional[pulumi.Input[int]] = None):
        """
        Applied properties for subscription type addresses.
        :param pulumi.Input[int] max_consumers: Maximum number of concurrent consumers that can be attached to this subscription.
        """
        if max_consumers is not None:
            pulumi.set(__self__, "max_consumers", max_consumers)

    @property
    @pulumi.getter(name="maxConsumers")
    def max_consumers(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of concurrent consumers that can be attached to this subscription.
        """
        return pulumi.get(self, "max_consumers")

    @max_consumers.setter
    def max_consumers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_consumers", value)


