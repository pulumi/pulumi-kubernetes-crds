// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

import {ObjectMeta} from "../meta/v1";

export namespace admin {
    export namespace v1beta1 {
        export interface AuthenticationServiceSpec {
            external?: pulumi.Input<inputs.admin.v1beta1.AuthenticationServiceSpecExternal>;
            none?: pulumi.Input<inputs.admin.v1beta1.AuthenticationServiceSpecNone>;
            realm?: pulumi.Input<string>;
            standard?: pulumi.Input<inputs.admin.v1beta1.AuthenticationServiceSpecStandard>;
            type?: pulumi.Input<string>;
        }

        export interface AuthenticationServiceSpecExternal {
            allowOverride?: pulumi.Input<boolean>;
            caCertSecret?: pulumi.Input<inputs.admin.v1beta1.AuthenticationServiceSpecExternalCaCertSecret>;
            clientCertSecret?: pulumi.Input<inputs.admin.v1beta1.AuthenticationServiceSpecExternalClientCertSecret>;
            host: pulumi.Input<string>;
            port: pulumi.Input<number>;
        }

        export interface AuthenticationServiceSpecExternalCaCertSecret {
            name?: pulumi.Input<string>;
            namespace?: pulumi.Input<string>;
        }

        export interface AuthenticationServiceSpecExternalClientCertSecret {
            name?: pulumi.Input<string>;
            namespace?: pulumi.Input<string>;
        }

        export interface AuthenticationServiceSpecNone {
            certificateSecret?: pulumi.Input<inputs.admin.v1beta1.AuthenticationServiceSpecNoneCertificateSecret>;
            image?: pulumi.Input<inputs.admin.v1beta1.AuthenticationServiceSpecNoneImage>;
            replicas?: pulumi.Input<number>;
            resources?: pulumi.Input<inputs.admin.v1beta1.AuthenticationServiceSpecNoneResources>;
        }

        export interface AuthenticationServiceSpecNoneCertificateSecret {
            name?: pulumi.Input<string>;
            namespace?: pulumi.Input<string>;
        }

        export interface AuthenticationServiceSpecNoneImage {
            name?: pulumi.Input<string>;
            pullPolicy?: pulumi.Input<string>;
        }

        export interface AuthenticationServiceSpecNoneResources {
            limits?: pulumi.Input<inputs.admin.v1beta1.AuthenticationServiceSpecNoneResourcesLimits>;
            requests?: pulumi.Input<inputs.admin.v1beta1.AuthenticationServiceSpecNoneResourcesRequests>;
        }

        export interface AuthenticationServiceSpecNoneResourcesLimits {
            cpu?: pulumi.Input<string>;
            memory?: pulumi.Input<string>;
        }

        export interface AuthenticationServiceSpecNoneResourcesRequests {
            cpu?: pulumi.Input<string>;
            memory?: pulumi.Input<string>;
        }

        export interface AuthenticationServiceSpecStandard {
            certificateSecret?: pulumi.Input<inputs.admin.v1beta1.AuthenticationServiceSpecStandardCertificateSecret>;
            credentialsSecret?: pulumi.Input<inputs.admin.v1beta1.AuthenticationServiceSpecStandardCredentialsSecret>;
            datasource?: pulumi.Input<inputs.admin.v1beta1.AuthenticationServiceSpecStandardDatasource>;
            deploymentName?: pulumi.Input<string>;
            image?: pulumi.Input<inputs.admin.v1beta1.AuthenticationServiceSpecStandardImage>;
            initImage?: pulumi.Input<inputs.admin.v1beta1.AuthenticationServiceSpecStandardInitImage>;
            jvmOptions?: pulumi.Input<string>;
            replicas?: pulumi.Input<number>;
            resources?: pulumi.Input<inputs.admin.v1beta1.AuthenticationServiceSpecStandardResources>;
            routeName?: pulumi.Input<string>;
            securityContext?: pulumi.Input<{[key: string]: any}>;
            serviceName?: pulumi.Input<string>;
            storage?: pulumi.Input<inputs.admin.v1beta1.AuthenticationServiceSpecStandardStorage>;
        }

        export interface AuthenticationServiceSpecStandardCertificateSecret {
            name?: pulumi.Input<string>;
            namespace?: pulumi.Input<string>;
        }

        export interface AuthenticationServiceSpecStandardCredentialsSecret {
            name?: pulumi.Input<string>;
            namespace?: pulumi.Input<string>;
        }

        export interface AuthenticationServiceSpecStandardDatasource {
            credentialsSecret?: pulumi.Input<inputs.admin.v1beta1.AuthenticationServiceSpecStandardDatasourceCredentialsSecret>;
            database?: pulumi.Input<string>;
            host?: pulumi.Input<string>;
            port?: pulumi.Input<number>;
            type: pulumi.Input<string>;
        }

        export interface AuthenticationServiceSpecStandardDatasourceCredentialsSecret {
            name?: pulumi.Input<string>;
            namespace?: pulumi.Input<string>;
        }

        export interface AuthenticationServiceSpecStandardImage {
            name?: pulumi.Input<string>;
            pullPolicy?: pulumi.Input<string>;
        }

        export interface AuthenticationServiceSpecStandardInitImage {
            name?: pulumi.Input<string>;
            pullPolicy?: pulumi.Input<string>;
        }

        export interface AuthenticationServiceSpecStandardResources {
            limits?: pulumi.Input<inputs.admin.v1beta1.AuthenticationServiceSpecStandardResourcesLimits>;
            requests?: pulumi.Input<inputs.admin.v1beta1.AuthenticationServiceSpecStandardResourcesRequests>;
        }

        export interface AuthenticationServiceSpecStandardResourcesLimits {
            cpu?: pulumi.Input<string>;
            memory?: pulumi.Input<string>;
        }

        export interface AuthenticationServiceSpecStandardResourcesRequests {
            cpu?: pulumi.Input<string>;
            memory?: pulumi.Input<string>;
        }

        export interface AuthenticationServiceSpecStandardStorage {
            claimName?: pulumi.Input<string>;
            class?: pulumi.Input<string>;
            deleteClaim?: pulumi.Input<boolean>;
            size?: pulumi.Input<string>;
            type: pulumi.Input<string>;
        }

        export interface AuthenticationServiceStatus {
            host?: pulumi.Input<string>;
            /**
             * Status and error messages for the authentication service.
             */
            message?: pulumi.Input<string>;
            /**
             * Phase of the authentication service.
             */
            phase?: pulumi.Input<string>;
            port?: pulumi.Input<number>;
        }

        export interface BrokeredInfraConfigSpec {
            admin?: pulumi.Input<inputs.admin.v1beta1.BrokeredInfraConfigSpecAdmin>;
            broker?: pulumi.Input<inputs.admin.v1beta1.BrokeredInfraConfigSpecBroker>;
            networkPolicy?: pulumi.Input<inputs.admin.v1beta1.BrokeredInfraConfigSpecNetworkPolicy>;
            version?: pulumi.Input<string>;
        }

        export interface BrokeredInfraConfigSpecAdmin {
            podTemplate?: pulumi.Input<inputs.admin.v1beta1.BrokeredInfraConfigSpecAdminPodTemplate>;
            resources?: pulumi.Input<inputs.admin.v1beta1.BrokeredInfraConfigSpecAdminResources>;
        }

        export interface BrokeredInfraConfigSpecAdminPodTemplate {
            metadata?: pulumi.Input<inputs.admin.v1beta1.BrokeredInfraConfigSpecAdminPodTemplateMetadata>;
            spec?: pulumi.Input<inputs.admin.v1beta1.BrokeredInfraConfigSpecAdminPodTemplateSpec>;
        }

        export interface BrokeredInfraConfigSpecAdminPodTemplateMetadata {
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface BrokeredInfraConfigSpecAdminPodTemplateSpec {
            affinity?: pulumi.Input<{[key: string]: any}>;
            containers?: pulumi.Input<pulumi.Input<inputs.admin.v1beta1.BrokeredInfraConfigSpecAdminPodTemplateSpecContainers>[]>;
            priorityClassName?: pulumi.Input<string>;
            securityContext?: pulumi.Input<{[key: string]: any}>;
            tolerations?: pulumi.Input<pulumi.Input<{[key: string]: any}>[]>;
        }

        export interface BrokeredInfraConfigSpecAdminPodTemplateSpecContainers {
            resources?: pulumi.Input<{[key: string]: any}>;
        }

        export interface BrokeredInfraConfigSpecAdminResources {
            cpu?: pulumi.Input<string>;
            memory?: pulumi.Input<string>;
        }

        export interface BrokeredInfraConfigSpecBroker {
            addressFullPolicy?: pulumi.Input<string>;
            /**
             * Sets a global limit to the amount of memory the broker can use before it applies the rules determined by addressFullPolicy. Value in bytes or use a byte suffix ("B", "K", "MB", "GB")
             */
            globalMaxSize?: pulumi.Input<string>;
            javaOpts?: pulumi.Input<string>;
            podTemplate?: pulumi.Input<inputs.admin.v1beta1.BrokeredInfraConfigSpecBrokerPodTemplate>;
            resources?: pulumi.Input<inputs.admin.v1beta1.BrokeredInfraConfigSpecBrokerResources>;
            storageClassName?: pulumi.Input<string>;
            updatePersistentVolumeClaim?: pulumi.Input<boolean>;
        }

        export interface BrokeredInfraConfigSpecBrokerPodTemplate {
            metadata?: pulumi.Input<inputs.admin.v1beta1.BrokeredInfraConfigSpecBrokerPodTemplateMetadata>;
            spec?: pulumi.Input<inputs.admin.v1beta1.BrokeredInfraConfigSpecBrokerPodTemplateSpec>;
        }

        export interface BrokeredInfraConfigSpecBrokerPodTemplateMetadata {
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface BrokeredInfraConfigSpecBrokerPodTemplateSpec {
            affinity?: pulumi.Input<{[key: string]: any}>;
            priorityClassName?: pulumi.Input<string>;
            resources?: pulumi.Input<{[key: string]: any}>;
            securityContext?: pulumi.Input<{[key: string]: any}>;
            tolerations?: pulumi.Input<any[]>;
        }

        export interface BrokeredInfraConfigSpecBrokerResources {
            cpu?: pulumi.Input<string>;
            memory?: pulumi.Input<string>;
            storage?: pulumi.Input<string>;
        }

        export interface BrokeredInfraConfigSpecNetworkPolicy {
            egress?: pulumi.Input<any[]>;
            ingress?: pulumi.Input<any[]>;
        }

        export interface ConsoleServiceSpec {
            certificateSecret?: pulumi.Input<inputs.admin.v1beta1.ConsoleServiceSpecCertificateSecret>;
            consoleServer?: pulumi.Input<inputs.admin.v1beta1.ConsoleServiceSpecConsoleServer>;
            discoveryMetadataURL?: pulumi.Input<string>;
            host?: pulumi.Input<string>;
            /**
             * Enable impersonation as the mechanism for authorizing user actions. For impersonation to work, it is important to also grant the console-server permissions to impersonate users.
             */
            impersonation?: pulumi.Input<inputs.admin.v1beta1.ConsoleServiceSpecImpersonation>;
            oauthClientSecret?: pulumi.Input<inputs.admin.v1beta1.ConsoleServiceSpecOauthClientSecret>;
            oauthProxy?: pulumi.Input<inputs.admin.v1beta1.ConsoleServiceSpecOauthProxy>;
            replicas?: pulumi.Input<number>;
            scope?: pulumi.Input<string>;
            ssoCookieDomain?: pulumi.Input<string>;
            ssoCookieSecret?: pulumi.Input<inputs.admin.v1beta1.ConsoleServiceSpecSsoCookieSecret>;
        }

        export interface ConsoleServiceSpecCertificateSecret {
            name?: pulumi.Input<string>;
            namespace?: pulumi.Input<string>;
        }

        export interface ConsoleServiceSpecConsoleServer {
            /**
             * Overrides for the periodic probe of container liveness.
             */
            livenessProbe?: pulumi.Input<inputs.admin.v1beta1.ConsoleServiceSpecConsoleServerLivenessProbe>;
            /**
             * Overrides for the periodic probe of container liveness.
             */
            readinessProbe?: pulumi.Input<inputs.admin.v1beta1.ConsoleServiceSpecConsoleServerReadinessProbe>;
            resources?: pulumi.Input<inputs.admin.v1beta1.ConsoleServiceSpecConsoleServerResources>;
            session?: pulumi.Input<inputs.admin.v1beta1.ConsoleServiceSpecConsoleServerSession>;
        }

        /**
         * Overrides for the periodic probe of container liveness.
         */
        export interface ConsoleServiceSpecConsoleServerLivenessProbe {
            /**
             * Minimum consecutive failures for the probe to be considered failed after having succeeded.
             */
            failureThreshold?: pulumi.Input<number>;
            /**
             * Number of seconds after the container has started before liveness probes are initiated.
             */
            initialDelaySeconds?: pulumi.Input<number>;
            /**
             * How often (in seconds) to perform the probe.
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * Minimum consecutive successes for the probe to be considered successful after having failed.
             */
            successThreshold?: pulumi.Input<number>;
            /**
             * Number of seconds after which the probe times out.
             */
            timeoutSeconds?: pulumi.Input<number>;
        }

        /**
         * Overrides for the periodic probe of container liveness.
         */
        export interface ConsoleServiceSpecConsoleServerReadinessProbe {
            /**
             * Minimum consecutive failures for the probe to be considered failed after having succeeded.
             */
            failureThreshold?: pulumi.Input<number>;
            /**
             * Number of seconds after the container has started before liveness probes are initiated.
             */
            initialDelaySeconds?: pulumi.Input<number>;
            /**
             * How often (in seconds) to perform the probe.
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * Minimum consecutive successes for the probe to be considered successful after having failed.
             */
            successThreshold?: pulumi.Input<number>;
            /**
             * Number of seconds after which the probe times out.
             */
            timeoutSeconds?: pulumi.Input<number>;
        }

        export interface ConsoleServiceSpecConsoleServerResources {
            limits?: pulumi.Input<inputs.admin.v1beta1.ConsoleServiceSpecConsoleServerResourcesLimits>;
            requests?: pulumi.Input<inputs.admin.v1beta1.ConsoleServiceSpecConsoleServerResourcesRequests>;
        }

        export interface ConsoleServiceSpecConsoleServerResourcesLimits {
            cpu?: pulumi.Input<string>;
            memory?: pulumi.Input<string>;
        }

        export interface ConsoleServiceSpecConsoleServerResourcesRequests {
            cpu?: pulumi.Input<string>;
            memory?: pulumi.Input<string>;
        }

        export interface ConsoleServiceSpecConsoleServerSession {
            /**
             * IdleTimeout controls the maximum length of time a session can be inactive before it expires. Defaults to 5m.
             */
            idleTimeout?: pulumi.Input<string>;
            /**
             * Lifetime controls the maximum length of time that a session is valid for before it expires. Defaults to 30m.
             */
            lifetime?: pulumi.Input<string>;
        }

        /**
         * Enable impersonation as the mechanism for authorizing user actions. For impersonation to work, it is important to also grant the console-server permissions to impersonate users.
         */
        export interface ConsoleServiceSpecImpersonation {
            /**
             * Headers to use for user impersonation.
             */
            userHeader?: pulumi.Input<string>;
        }

        export interface ConsoleServiceSpecOauthClientSecret {
            name?: pulumi.Input<string>;
            namespace?: pulumi.Input<string>;
        }

        export interface ConsoleServiceSpecOauthProxy {
            /**
             * Extra arguments to pass to oauth-proxy
             */
            extraArgs?: pulumi.Input<pulumi.Input<string>[]>;
            resources?: pulumi.Input<inputs.admin.v1beta1.ConsoleServiceSpecOauthProxyResources>;
        }

        export interface ConsoleServiceSpecOauthProxyResources {
            limits?: pulumi.Input<inputs.admin.v1beta1.ConsoleServiceSpecOauthProxyResourcesLimits>;
            requests?: pulumi.Input<inputs.admin.v1beta1.ConsoleServiceSpecOauthProxyResourcesRequests>;
        }

        export interface ConsoleServiceSpecOauthProxyResourcesLimits {
            cpu?: pulumi.Input<string>;
            memory?: pulumi.Input<string>;
        }

        export interface ConsoleServiceSpecOauthProxyResourcesRequests {
            cpu?: pulumi.Input<string>;
            memory?: pulumi.Input<string>;
        }

        export interface ConsoleServiceSpecSsoCookieSecret {
            name?: pulumi.Input<string>;
            namespace?: pulumi.Input<string>;
        }

        export interface ConsoleServiceStatus {
            caCertSecret?: pulumi.Input<inputs.admin.v1beta1.ConsoleServiceStatusCaCertSecret>;
            host?: pulumi.Input<string>;
            port?: pulumi.Input<number>;
        }

        export interface ConsoleServiceStatusCaCertSecret {
            name?: pulumi.Input<string>;
        }

        export interface StandardInfraConfigSpec {
            admin?: pulumi.Input<inputs.admin.v1beta1.StandardInfraConfigSpecAdmin>;
            broker?: pulumi.Input<inputs.admin.v1beta1.StandardInfraConfigSpecBroker>;
            networkPolicy?: pulumi.Input<inputs.admin.v1beta1.StandardInfraConfigSpecNetworkPolicy>;
            router?: pulumi.Input<inputs.admin.v1beta1.StandardInfraConfigSpecRouter>;
            version?: pulumi.Input<string>;
        }

        export interface StandardInfraConfigSpecAdmin {
            podTemplate?: pulumi.Input<inputs.admin.v1beta1.StandardInfraConfigSpecAdminPodTemplate>;
            resources?: pulumi.Input<inputs.admin.v1beta1.StandardInfraConfigSpecAdminResources>;
        }

        export interface StandardInfraConfigSpecAdminPodTemplate {
            metadata?: pulumi.Input<inputs.admin.v1beta1.StandardInfraConfigSpecAdminPodTemplateMetadata>;
            spec?: pulumi.Input<inputs.admin.v1beta1.StandardInfraConfigSpecAdminPodTemplateSpec>;
        }

        export interface StandardInfraConfigSpecAdminPodTemplateMetadata {
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface StandardInfraConfigSpecAdminPodTemplateSpec {
            affinity?: pulumi.Input<{[key: string]: any}>;
            containers?: pulumi.Input<pulumi.Input<inputs.admin.v1beta1.StandardInfraConfigSpecAdminPodTemplateSpecContainers>[]>;
            priorityClassName?: pulumi.Input<string>;
            securityContext?: pulumi.Input<{[key: string]: any}>;
            tolerations?: pulumi.Input<pulumi.Input<{[key: string]: any}>[]>;
        }

        export interface StandardInfraConfigSpecAdminPodTemplateSpecContainers {
            resources?: pulumi.Input<{[key: string]: any}>;
        }

        export interface StandardInfraConfigSpecAdminResources {
            cpu?: pulumi.Input<string>;
            memory?: pulumi.Input<string>;
        }

        export interface StandardInfraConfigSpecBroker {
            addressFullPolicy?: pulumi.Input<string>;
            connectorIdleTimeout?: pulumi.Input<number>;
            connectorWorkerThreads?: pulumi.Input<number>;
            /**
             * Sets a global limit to the amount of memory the broker can use before it applies the rules determined by addressFullPolicy. Value in bytes or use a byte suffix ("B", "K", "MB", "GB")
             */
            globalMaxSize?: pulumi.Input<string>;
            javaOpts?: pulumi.Input<string>;
            maxUnavailable?: pulumi.Input<inputs.admin.v1beta1.StandardInfraConfigSpecBrokerMaxUnavailable>;
            minAvailable?: pulumi.Input<inputs.admin.v1beta1.StandardInfraConfigSpecBrokerMinAvailable>;
            podTemplate?: pulumi.Input<inputs.admin.v1beta1.StandardInfraConfigSpecBrokerPodTemplate>;
            resources?: pulumi.Input<inputs.admin.v1beta1.StandardInfraConfigSpecBrokerResources>;
            storageClassName?: pulumi.Input<string>;
            updatePersistentVolumeClaim?: pulumi.Input<boolean>;
        }

        export interface StandardInfraConfigSpecBrokerMaxUnavailable {
        }

        export interface StandardInfraConfigSpecBrokerMinAvailable {
        }

        export interface StandardInfraConfigSpecBrokerPodTemplate {
            metadata?: pulumi.Input<inputs.admin.v1beta1.StandardInfraConfigSpecBrokerPodTemplateMetadata>;
            spec?: pulumi.Input<inputs.admin.v1beta1.StandardInfraConfigSpecBrokerPodTemplateSpec>;
        }

        export interface StandardInfraConfigSpecBrokerPodTemplateMetadata {
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface StandardInfraConfigSpecBrokerPodTemplateSpec {
            affinity?: pulumi.Input<{[key: string]: any}>;
            priorityClassName?: pulumi.Input<string>;
            resources?: pulumi.Input<{[key: string]: any}>;
            securityContext?: pulumi.Input<{[key: string]: any}>;
            tolerations?: pulumi.Input<any[]>;
        }

        export interface StandardInfraConfigSpecBrokerResources {
            cpu?: pulumi.Input<string>;
            memory?: pulumi.Input<string>;
            storage?: pulumi.Input<string>;
        }

        export interface StandardInfraConfigSpecNetworkPolicy {
            egress?: pulumi.Input<any[]>;
            ingress?: pulumi.Input<any[]>;
        }

        export interface StandardInfraConfigSpecRouter {
            idleTimeout?: pulumi.Input<number>;
            linkCapacity?: pulumi.Input<number>;
            maxUnavailable?: pulumi.Input<inputs.admin.v1beta1.StandardInfraConfigSpecRouterMaxUnavailable>;
            minAvailable?: pulumi.Input<inputs.admin.v1beta1.StandardInfraConfigSpecRouterMinAvailable>;
            minReplicas?: pulumi.Input<number>;
            podTemplate?: pulumi.Input<inputs.admin.v1beta1.StandardInfraConfigSpecRouterPodTemplate>;
            policy?: pulumi.Input<inputs.admin.v1beta1.StandardInfraConfigSpecRouterPolicy>;
            resources?: pulumi.Input<inputs.admin.v1beta1.StandardInfraConfigSpecRouterResources>;
            workerThreads?: pulumi.Input<number>;
        }

        export interface StandardInfraConfigSpecRouterMaxUnavailable {
        }

        export interface StandardInfraConfigSpecRouterMinAvailable {
        }

        export interface StandardInfraConfigSpecRouterPodTemplate {
            metadata?: pulumi.Input<inputs.admin.v1beta1.StandardInfraConfigSpecRouterPodTemplateMetadata>;
            spec?: pulumi.Input<inputs.admin.v1beta1.StandardInfraConfigSpecRouterPodTemplateSpec>;
        }

        export interface StandardInfraConfigSpecRouterPodTemplateMetadata {
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface StandardInfraConfigSpecRouterPodTemplateSpec {
            affinity?: pulumi.Input<{[key: string]: any}>;
            priorityClassName?: pulumi.Input<string>;
            resources?: pulumi.Input<{[key: string]: any}>;
            securityContext?: pulumi.Input<{[key: string]: any}>;
            tolerations?: pulumi.Input<any[]>;
        }

        export interface StandardInfraConfigSpecRouterPolicy {
            maxConnections?: pulumi.Input<number>;
            maxConnectionsPerHost?: pulumi.Input<number>;
            maxConnectionsPerUser?: pulumi.Input<number>;
            maxReceiversPerConnection?: pulumi.Input<number>;
            maxSendersPerConnection?: pulumi.Input<number>;
            maxSessionsPerConnection?: pulumi.Input<number>;
        }

        export interface StandardInfraConfigSpecRouterResources {
            cpu?: pulumi.Input<string>;
            memory?: pulumi.Input<string>;
        }
    }

    export namespace v1beta2 {
        export interface AddressPlanRequiredResources {
            credit: pulumi.Input<number>;
            name: pulumi.Input<string>;
        }

        export interface AddressPlanSpec {
            addressType: pulumi.Input<string>;
            displayName?: pulumi.Input<string>;
            displayOrder?: pulumi.Input<number>;
            longDescription?: pulumi.Input<string>;
            /**
             * Restricts message time-to-live (TTL). Applies to address types queue and topic only.
             */
            messageTtl?: pulumi.Input<inputs.admin.v1beta2.AddressPlanSpecMessageTtl>;
            partitions?: pulumi.Input<number>;
            resources: pulumi.Input<inputs.admin.v1beta2.AddressPlanSpecResources>;
            shortDescription?: pulumi.Input<string>;
        }

        /**
         * Restricts message time-to-live (TTL). Applies to address types queue and topic only.
         */
        export interface AddressPlanSpecMessageTtl {
            /**
             * Imposes a maximum TTL value (in milliseconds) for messages arriving at the address.  Messages arriving with TTL values greater than this value (or no TTL value) will have their expiration adjusted.
             */
            maximum?: pulumi.Input<number>;
            /**
             * Imposes a minimum TTL value (in milliseconds) for messages arriving at the address.  Messages arriving with TTL values less than this value will have their expiration adjusted.
             */
            minimum?: pulumi.Input<number>;
        }

        export interface AddressPlanSpecResources {
            broker?: pulumi.Input<number>;
            router?: pulumi.Input<number>;
        }

        export interface AddressSpacePlanResources {
            max: pulumi.Input<number>;
            name: pulumi.Input<string>;
        }

        export interface AddressSpacePlanSpec {
            addressPlans: pulumi.Input<pulumi.Input<string>[]>;
            addressSpaceType: pulumi.Input<string>;
            displayName?: pulumi.Input<string>;
            displayOrder?: pulumi.Input<number>;
            infraConfigRef: pulumi.Input<string>;
            longDescription?: pulumi.Input<string>;
            resourceLimits: pulumi.Input<inputs.admin.v1beta2.AddressSpacePlanSpecResourceLimits>;
            shortDescription?: pulumi.Input<string>;
        }

        export interface AddressSpacePlanSpecResourceLimits {
            aggregate?: pulumi.Input<number>;
            broker?: pulumi.Input<number>;
            router?: pulumi.Input<number>;
        }
    }
}

export namespace enmasse {
    export namespace v1beta1 {
        export interface AddressSpaceSpec {
            /**
             * The authentication service to use for authenticating messaging clients.
             */
            authenticationService?: pulumi.Input<inputs.enmasse.v1beta1.AddressSpaceSpecAuthenticationService>;
            /**
             * External AMQP connections.
             */
            connectors?: pulumi.Input<pulumi.Input<inputs.enmasse.v1beta1.AddressSpaceSpecConnectors>[]>;
            /**
             * Endpoints configured for this address space.
             */
            endpoints?: pulumi.Input<pulumi.Input<inputs.enmasse.v1beta1.AddressSpaceSpecEndpoints>[]>;
            /**
             * Define NetworkPolicy for this address space.
             */
            networkPolicy?: pulumi.Input<inputs.enmasse.v1beta1.AddressSpaceSpecNetworkPolicy>;
            /**
             * The name of the address space plan to apply.
             */
            plan: pulumi.Input<string>;
            /**
             * The type of address space.
             */
            type: pulumi.Input<string>;
        }

        /**
         * The authentication service to use for authenticating messaging clients.
         */
        export interface AddressSpaceSpecAuthenticationService {
            /**
             * The name of the authentication service.
             */
            name?: pulumi.Input<string>;
            overrides?: pulumi.Input<inputs.enmasse.v1beta1.AddressSpaceSpecAuthenticationServiceOverrides>;
            type?: pulumi.Input<string>;
        }

        export interface AddressSpaceSpecAuthenticationServiceOverrides {
            host?: pulumi.Input<string>;
            port?: pulumi.Input<number>;
            realm?: pulumi.Input<string>;
        }

        export interface AddressSpaceSpecConnectors {
            /**
             * Addresses to make be accessible via this address space.
             */
            addresses?: pulumi.Input<pulumi.Input<inputs.enmasse.v1beta1.AddressSpaceSpecConnectorsAddresses>[]>;
            /**
             * Credentials used when connecting to endpoints.
             */
            credentials?: pulumi.Input<inputs.enmasse.v1beta1.AddressSpaceSpecConnectorsCredentials>;
            /**
             * Endpoints to connect to. First entry is used as primary, additional entries are considered failovers.
             */
            endpointHosts: pulumi.Input<pulumi.Input<inputs.enmasse.v1beta1.AddressSpaceSpecConnectorsEndpointHosts>[]>;
            /**
             * Idle timeout of AMQP connection (seconds). 0 disables the idle timeout.
             */
            idleTimeout?: pulumi.Input<number>;
            /**
             * Max frame size of AMQP connection.
             */
            maxFrameSize?: pulumi.Input<number>;
            /**
             * Connector name. Used to uniquely identify a connector.
             */
            name: pulumi.Input<string>;
            /**
             * Role of connector. Defaults to 'route-container'.
             */
            role?: pulumi.Input<string>;
            /**
             * TLS configuration for the connector. If not specified, TLS will not be used.
             */
            tls?: pulumi.Input<inputs.enmasse.v1beta1.AddressSpaceSpecConnectorsTls>;
        }

        export interface AddressSpaceSpecConnectorsAddresses {
            /**
             * Identifier of address pattern. Used to uniquely identify a pattern.
             */
            name: pulumi.Input<string>;
            /**
             * Pattern used to match addresses. The pattern will be prefixed by the connector name and a forward slash ('myconnector/'). A pattern consists of one or more tokens separated by a forward slash /. A token can be one of the following: a * character, a # character, or a sequence of characters that do not include /, *, or #. The * token matches any single token. The # token matches zero or more tokens. * has higher precedence than #, and exact match has the highest precedence.
             */
            pattern: pulumi.Input<string>;
        }

        /**
         * Credentials used when connecting to endpoints.
         */
        export interface AddressSpaceSpecConnectorsCredentials {
            /**
             * Password to use for connector.
             */
            password: pulumi.Input<inputs.enmasse.v1beta1.AddressSpaceSpecConnectorsCredentialsPassword>;
            /**
             * Username to use for connector.
             */
            username: pulumi.Input<inputs.enmasse.v1beta1.AddressSpaceSpecConnectorsCredentialsUsername>;
        }

        export interface AddressSpaceSpecConnectorsCredentialsPassword {
        }

        export interface AddressSpaceSpecConnectorsCredentialsUsername {
        }

        export interface AddressSpaceSpecConnectorsEndpointHosts {
            host: pulumi.Input<string>;
            port?: pulumi.Input<number>;
        }

        /**
         * TLS configuration for the connector. If not specified, TLS will not be used.
         */
        export interface AddressSpaceSpecConnectorsTls {
            /**
             * CA certificate to be used by the connector.
             */
            caCert?: pulumi.Input<inputs.enmasse.v1beta1.AddressSpaceSpecConnectorsTlsCaCert>;
            /**
             * Client certificate to be used by the connector.
             */
            clientCert?: pulumi.Input<inputs.enmasse.v1beta1.AddressSpaceSpecConnectorsTlsClientCert>;
            /**
             * Client key to be used by the connector.
             */
            clientKey?: pulumi.Input<inputs.enmasse.v1beta1.AddressSpaceSpecConnectorsTlsClientKey>;
        }

        export interface AddressSpaceSpecConnectorsTlsCaCert {
        }

        export interface AddressSpaceSpecConnectorsTlsClientCert {
        }

        export interface AddressSpaceSpecConnectorsTlsClientKey {
        }

        export interface AddressSpaceSpecEndpoints {
            /**
             * Configure certificates to be used for this endpoint.
             */
            cert?: pulumi.Input<inputs.enmasse.v1beta1.AddressSpaceSpecEndpointsCert>;
            /**
             * Export address space information.
             */
            exports?: pulumi.Input<pulumi.Input<inputs.enmasse.v1beta1.AddressSpaceSpecEndpointsExports>[]>;
            /**
             * Expose configuration of this endpoint.
             */
            expose?: pulumi.Input<inputs.enmasse.v1beta1.AddressSpaceSpecEndpointsExpose>;
            /**
             * Endpoint name. Use to uniquely identify an endpoint.
             */
            name?: pulumi.Input<string>;
            /**
             * Service referenced by this endpoint. 'console' is no longer supported.
             */
            service?: pulumi.Input<string>;
        }

        /**
         * Configure certificates to be used for this endpoint.
         */
        export interface AddressSpaceSpecEndpointsCert {
            /**
             * Certificate provider to use for this endpoint.
             */
            provider?: pulumi.Input<string>;
            secretName?: pulumi.Input<string>;
            /**
             * TLS certificate to use for 'certBundle' provider.
             */
            tlsCert?: pulumi.Input<string>;
            /**
             * TLS key to use for 'certBundle' provider.
             */
            tlsKey?: pulumi.Input<string>;
        }

        export interface AddressSpaceSpecEndpointsExports {
            /**
             * Type of resource to export address space information into.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name of resource to export address space information into.
             */
            name?: pulumi.Input<string>;
        }

        export interface AddressSpaceSpecEndpointsExpose {
            type?: any;
        }

        /**
         * Define NetworkPolicy for this address space.
         */
        export interface AddressSpaceSpecNetworkPolicy {
            egress?: pulumi.Input<pulumi.Input<{[key: string]: any}>[]>;
            ingress?: pulumi.Input<pulumi.Input<{[key: string]: any}>[]>;
        }

        export interface AddressSpaceStatus {
            /**
             * CA certificate for endpoints.
             */
            caCert?: pulumi.Input<string>;
            /**
             * Connector status for this address space.
             */
            connectors?: pulumi.Input<pulumi.Input<inputs.enmasse.v1beta1.AddressSpaceStatusConnectors>[]>;
            /**
             * Endpoint status for this address space.
             */
            endpointStatuses?: pulumi.Input<pulumi.Input<inputs.enmasse.v1beta1.AddressSpaceStatusEndpointStatuses>[]>;
            /**
             * Whether address space is ready to use or not.
             */
            isReady?: pulumi.Input<boolean>;
            /**
             * Status and error messages for address space.
             */
            messages?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Phase of address space.
             */
            phase?: pulumi.Input<string>;
            /**
             * Router status for this address space.
             */
            routers?: pulumi.Input<pulumi.Input<inputs.enmasse.v1beta1.AddressSpaceStatusRouters>[]>;
        }

        export interface AddressSpaceStatusConnectors {
            isReady?: pulumi.Input<boolean>;
            messages?: pulumi.Input<pulumi.Input<string>[]>;
            name?: pulumi.Input<string>;
        }

        export interface AddressSpaceStatusEndpointStatuses {
            externalHost?: pulumi.Input<string>;
            externalPorts?: pulumi.Input<pulumi.Input<{[key: string]: any}>[]>;
            messages?: pulumi.Input<pulumi.Input<string>[]>;
            name?: pulumi.Input<string>;
            serviceHost?: pulumi.Input<string>;
            servicePorts?: pulumi.Input<pulumi.Input<{[key: string]: any}>[]>;
        }

        export interface AddressSpaceStatusRouters {
            id: pulumi.Input<string>;
            neighbors?: pulumi.Input<pulumi.Input<string>[]>;
            undelivered?: pulumi.Input<number>;
        }

        export interface AddressSpec {
            /**
             * Messaging address.
             */
            address: pulumi.Input<string>;
            /**
             * Address forwarders for this address.
             */
            forwarders?: pulumi.Input<pulumi.Input<inputs.enmasse.v1beta1.AddressSpecForwarders>[]>;
            /**
             * Further restricts message time-to-live (TTL). Applies to address types queue and topic only. The maximum and minimum values must fall with the minimum/maximum range described by the plan's TTL settings.
             */
            messageTtl?: pulumi.Input<inputs.enmasse.v1beta1.AddressSpecMessageTtl>;
            /**
             * Plan referenced by this address.
             */
            plan: pulumi.Input<string>;
            /**
             * Properties that can be set for subscription type addresses.
             */
            subscription?: pulumi.Input<inputs.enmasse.v1beta1.AddressSpecSubscription>;
            /**
             * Address of topic that this subscription refers to (only applicable to subscription types).
             */
            topic?: pulumi.Input<string>;
            /**
             * Address type for this address.
             */
            type: pulumi.Input<string>;
        }

        export interface AddressSpecForwarders {
            direction: pulumi.Input<string>;
            /**
             * Forwarder name.
             */
            name: pulumi.Input<string>;
            /**
             * Remote address to forward to. Must be prefixed with connector name.
             */
            remoteAddress: pulumi.Input<string>;
        }

        /**
         * Further restricts message time-to-live (TTL). Applies to address types queue and topic only. The maximum and minimum values must fall with the minimum/maximum range described by the plan's TTL settings.
         */
        export interface AddressSpecMessageTtl {
            /**
             * Imposes a maximum TTL value (in milliseconds) for messages arriving at the address.  Messages arriving with TTL values greater than this value (or no TTL value) will have their expiration adjusted.
             */
            maximum?: pulumi.Input<number>;
            /**
             * Imposes a minimum TTL value (in milliseconds) for messages arriving at the address.  Messages arriving with TTL values less than this value will have their expiration adjusted.
             */
            minimum?: pulumi.Input<number>;
        }

        /**
         * Properties that can be set for subscription type addresses.
         */
        export interface AddressSpecSubscription {
            /**
             * Maximum number of concurrent consumers that can be attached to this subscription. If unspecified, 1 consumer is allowed per subscription
             */
            maxConsumers?: pulumi.Input<number>;
        }

        export interface AddressStatus {
            /**
             * The status of this address in brokers.
             */
            brokerStatuses?: pulumi.Input<pulumi.Input<inputs.enmasse.v1beta1.AddressStatusBrokerStatuses>[]>;
            /**
             * Forwarder status for this address.
             */
            forwarders?: pulumi.Input<pulumi.Input<inputs.enmasse.v1beta1.AddressStatusForwarders>[]>;
            /**
             * Whether address is ready to use or not.
             */
            isReady?: pulumi.Input<boolean>;
            /**
             * Applied message TTL properties.
             */
            messageTtl?: pulumi.Input<inputs.enmasse.v1beta1.AddressStatusMessageTtl>;
            /**
             * Status and error messages for address.
             */
            messages?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Phase of address.
             */
            phase?: pulumi.Input<string>;
            planStatus?: pulumi.Input<inputs.enmasse.v1beta1.AddressStatusPlanStatus>;
            /**
             * Applied properties for subscription type addresses.
             */
            subscription?: pulumi.Input<inputs.enmasse.v1beta1.AddressStatusSubscription>;
        }

        export interface AddressStatusBrokerStatuses {
            brokerId?: pulumi.Input<string>;
            clusterId?: pulumi.Input<string>;
            state?: pulumi.Input<string>;
        }

        export interface AddressStatusForwarders {
            isReady?: pulumi.Input<boolean>;
            messages?: pulumi.Input<pulumi.Input<string>[]>;
            name?: pulumi.Input<string>;
        }

        /**
         * Applied message TTL properties.
         */
        export interface AddressStatusMessageTtl {
            /**
             * Maximum TTL value
             */
            maximum?: pulumi.Input<number>;
            /**
             * Minimum TTL value
             */
            minimum?: pulumi.Input<number>;
        }

        export interface AddressStatusPlanStatus {
            name: pulumi.Input<string>;
            partitions: pulumi.Input<number>;
            resources: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Applied properties for subscription type addresses.
         */
        export interface AddressStatusSubscription {
            /**
             * Maximum number of concurrent consumers that can be attached to this subscription.
             */
            maxConsumers?: pulumi.Input<number>;
        }
    }
}

export namespace iot {
    export namespace v1alpha1 {
        export interface IoTConfigSpec {
            adapters?: pulumi.Input<inputs.iot.v1alpha1.IoTConfigSpecAdapters>;
            enableDefaultRoutes?: pulumi.Input<boolean>;
            imageOverrides?: pulumi.Input<{[key: string]: any}>;
            /**
             * Configure the strategy to use for connecting services using certificates. If no configuration
             * is present, and you are running on OpenShift 4, then it will automatically deploy certificates
             * using the Service CA.
             */
            interServiceCertificates?: any;
            java?: pulumi.Input<inputs.iot.v1alpha1.IoTConfigSpecJava>;
            logging?: pulumi.Input<{[key: string]: any}>;
            mesh?: pulumi.Input<inputs.iot.v1alpha1.IoTConfigSpecMesh>;
            monitoring?: pulumi.Input<{[key: string]: any}>;
            services?: pulumi.Input<inputs.iot.v1alpha1.IoTConfigSpecServices>;
            /**
             * Global TLS configuration
             */
            tls?: pulumi.Input<inputs.iot.v1alpha1.IoTConfigSpecTls>;
            tracing?: pulumi.Input<{[key: string]: any}>;
        }

        export interface IoTConfigSpecAdapters {
            defaults?: pulumi.Input<{[key: string]: any}>;
            http?: pulumi.Input<{[key: string]: any}>;
            lorawan?: pulumi.Input<{[key: string]: any}>;
            mqtt?: pulumi.Input<{[key: string]: any}>;
            sigfox?: pulumi.Input<{[key: string]: any}>;
        }

        export interface IoTConfigSpecJava {
            requireNativeTls?: pulumi.Input<boolean>;
        }

        export interface IoTConfigSpecMesh {
            services?: pulumi.Input<{[key: string]: any}>;
        }

        export interface IoTConfigSpecServices {
            authentication?: pulumi.Input<{[key: string]: any}>;
            deviceConnection?: pulumi.Input<{[key: string]: any}>;
            deviceRegistry?: pulumi.Input<{[key: string]: any}>;
            tenant?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Global TLS configuration
         */
        export interface IoTConfigSpecTls {
            versions?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface IoTConfigStatus {
            adapters?: pulumi.Input<{[key: string]: any}>;
            conditions?: pulumi.Input<pulumi.Input<inputs.iot.v1alpha1.IoTConfigStatusConditions>[]>;
            message?: pulumi.Input<string>;
            phase?: pulumi.Input<string>;
            services?: pulumi.Input<{[key: string]: any}>;
        }

        export interface IoTConfigStatusConditions {
            lastTransitionTime?: pulumi.Input<string>;
            message?: pulumi.Input<string>;
            reason?: pulumi.Input<string>;
            status?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
        }

        export interface IoTProjectSpec {
            configuration?: pulumi.Input<inputs.iot.v1alpha1.IoTProjectSpecConfiguration>;
            downstreamStrategy?: any;
        }

        export interface IoTProjectSpecConfiguration {
            adapters?: pulumi.Input<inputs.iot.v1alpha1.IoTProjectSpecConfigurationAdapters>;
            /**
             * Defaults for properties defined on the tenant and device level.
             */
            defaults?: pulumi.Input<{[key: string]: any}>;
            /**
             * Allows to disable the use of the Tenant.
             */
            enabled?: pulumi.Input<boolean>;
            /**
             * Allows arbitrary properties as extension to the ones specified by the Hono API.
             */
            ext?: pulumi.Input<{[key: string]: any}>;
            /**
             * The minimum message size in bytes. If set, then reported size of
             * telemetry, event and command messages is calculated as the minimum multiple
             * of the configured value that is greater than or equal to the messages
             * payload size.
             */
            minimumMessageSize?: pulumi.Input<number>;
            trustAnchors?: pulumi.Input<pulumi.Input<inputs.iot.v1alpha1.IoTProjectSpecConfigurationTrustAnchors>[]>;
        }

        export interface IoTProjectSpecConfigurationAdapters {
            http?: pulumi.Input<inputs.iot.v1alpha1.IoTProjectSpecConfigurationAdaptersHttp>;
            lorawan?: pulumi.Input<inputs.iot.v1alpha1.IoTProjectSpecConfigurationAdaptersLorawan>;
            mqtt?: pulumi.Input<inputs.iot.v1alpha1.IoTProjectSpecConfigurationAdaptersMqtt>;
            sigfox?: pulumi.Input<inputs.iot.v1alpha1.IoTProjectSpecConfigurationAdaptersSigfox>;
        }

        export interface IoTProjectSpecConfigurationAdaptersHttp {
            enabled?: pulumi.Input<boolean>;
            ext?: pulumi.Input<{[key: string]: any}>;
        }

        export interface IoTProjectSpecConfigurationAdaptersLorawan {
            enabled?: pulumi.Input<boolean>;
            ext?: pulumi.Input<{[key: string]: any}>;
        }

        export interface IoTProjectSpecConfigurationAdaptersMqtt {
            enabled?: pulumi.Input<boolean>;
            ext?: pulumi.Input<{[key: string]: any}>;
        }

        export interface IoTProjectSpecConfigurationAdaptersSigfox {
            enabled?: pulumi.Input<boolean>;
            ext?: pulumi.Input<{[key: string]: any}>;
        }

        export interface IoTProjectSpecConfigurationTrustAnchors {
            certificate: pulumi.Input<string>;
        }

        export interface IoTProjectStatus {
            /**
             * The input accepted from the `.spec.configuration` section, split up into the different areas.
             */
            accepted?: pulumi.Input<inputs.iot.v1alpha1.IoTProjectStatusAccepted>;
            conditions?: pulumi.Input<pulumi.Input<inputs.iot.v1alpha1.IoTProjectStatusConditions>[]>;
            message?: pulumi.Input<string>;
            phase?: pulumi.Input<string>;
            tenantName?: pulumi.Input<string>;
        }

        /**
         * The input accepted from the `.spec.configuration` section, split up into the different areas.
         */
        export interface IoTProjectStatusAccepted {
            /**
             * The accepted configuration section, ready to be used as a reply to a "Get Tenant" request.
             */
            configuration?: pulumi.Input<{[key: string]: any}>;
        }

        export interface IoTProjectStatusConditions {
            lastTransitionTime?: pulumi.Input<string>;
            message?: pulumi.Input<string>;
            reason?: pulumi.Input<string>;
            status?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
        }
    }
}

export namespace user {
    export namespace v1beta1 {
        export interface MessagingUserSpec {
            /**
             * The authentication specification.
             */
            authentication: pulumi.Input<inputs.user.v1beta1.MessagingUserSpecAuthentication>;
            /**
             * The authorization rules for the user.
             */
            authorization?: pulumi.Input<pulumi.Input<inputs.user.v1beta1.MessagingUserSpecAuthorization>[]>;
            /**
             * The username used by messaging clients.
             */
            username: pulumi.Input<string>;
        }

        /**
         * The authentication specification.
         */
        export interface MessagingUserSpecAuthentication {
            /**
             * Federated user id for the 'federated' authentication type.
             */
            federatedUserid?: pulumi.Input<string>;
            /**
             * Federated user name for the 'federated' authentication type.
             */
            federatedUsername?: pulumi.Input<string>;
            /**
             * Base64-encoded password for the 'password' authentication type.
             */
            password?: pulumi.Input<string>;
            /**
             * Federated identity provider for the 'federated' authentication type.
             */
            provider?: pulumi.Input<string>;
            /**
             * The type of authentication.
             */
            type: pulumi.Input<string>;
        }

        export interface MessagingUserSpecAuthorization {
            /**
             * The addresses the rule should apply to.
             */
            addresses?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * The operations that should apply to addresses matched by this rule.
             */
            operations?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface MessagingUserStatus {
            /**
             * Applied generation
             */
            generation?: pulumi.Input<number>;
            /**
             * Message describing the current state
             */
            message?: pulumi.Input<string>;
            /**
             * The lifecycle phase of the messaging user
             */
            phase?: pulumi.Input<string>;
        }
    }
}
