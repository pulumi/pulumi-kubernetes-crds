// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

import {ObjectMeta} from "../meta/v1";

export namespace admin {
    export namespace v1beta1 {
        export interface AuthenticationServiceSpec {
            external?: outputs.admin.v1beta1.AuthenticationServiceSpecExternal;
            none?: outputs.admin.v1beta1.AuthenticationServiceSpecNone;
            realm?: string;
            standard?: outputs.admin.v1beta1.AuthenticationServiceSpecStandard;
            type?: string;
        }

        export interface AuthenticationServiceSpecExternal {
            allowOverride?: boolean;
            caCertSecret?: outputs.admin.v1beta1.AuthenticationServiceSpecExternalCaCertSecret;
            clientCertSecret?: outputs.admin.v1beta1.AuthenticationServiceSpecExternalClientCertSecret;
            host: string;
            port: number;
        }

        export interface AuthenticationServiceSpecExternalCaCertSecret {
            name?: string;
            namespace?: string;
        }

        export interface AuthenticationServiceSpecExternalClientCertSecret {
            name?: string;
            namespace?: string;
        }

        export interface AuthenticationServiceSpecNone {
            certificateSecret?: outputs.admin.v1beta1.AuthenticationServiceSpecNoneCertificateSecret;
            image?: outputs.admin.v1beta1.AuthenticationServiceSpecNoneImage;
            replicas?: number;
            resources?: outputs.admin.v1beta1.AuthenticationServiceSpecNoneResources;
        }

        export interface AuthenticationServiceSpecNoneCertificateSecret {
            name?: string;
            namespace?: string;
        }

        export interface AuthenticationServiceSpecNoneImage {
            name?: string;
            pullPolicy?: string;
        }

        export interface AuthenticationServiceSpecNoneResources {
            limits?: outputs.admin.v1beta1.AuthenticationServiceSpecNoneResourcesLimits;
            requests?: outputs.admin.v1beta1.AuthenticationServiceSpecNoneResourcesRequests;
        }

        export interface AuthenticationServiceSpecNoneResourcesLimits {
            cpu?: string;
            memory?: string;
        }

        export interface AuthenticationServiceSpecNoneResourcesRequests {
            cpu?: string;
            memory?: string;
        }

        export interface AuthenticationServiceSpecStandard {
            certificateSecret?: outputs.admin.v1beta1.AuthenticationServiceSpecStandardCertificateSecret;
            credentialsSecret?: outputs.admin.v1beta1.AuthenticationServiceSpecStandardCredentialsSecret;
            datasource?: outputs.admin.v1beta1.AuthenticationServiceSpecStandardDatasource;
            deploymentName?: string;
            image?: outputs.admin.v1beta1.AuthenticationServiceSpecStandardImage;
            initImage?: outputs.admin.v1beta1.AuthenticationServiceSpecStandardInitImage;
            jvmOptions?: string;
            replicas?: number;
            resources?: outputs.admin.v1beta1.AuthenticationServiceSpecStandardResources;
            routeName?: string;
            securityContext?: {[key: string]: any};
            serviceName?: string;
            storage?: outputs.admin.v1beta1.AuthenticationServiceSpecStandardStorage;
        }

        export interface AuthenticationServiceSpecStandardCertificateSecret {
            name?: string;
            namespace?: string;
        }

        export interface AuthenticationServiceSpecStandardCredentialsSecret {
            name?: string;
            namespace?: string;
        }

        export interface AuthenticationServiceSpecStandardDatasource {
            credentialsSecret?: outputs.admin.v1beta1.AuthenticationServiceSpecStandardDatasourceCredentialsSecret;
            database?: string;
            host?: string;
            port?: number;
            type: string;
        }

        export interface AuthenticationServiceSpecStandardDatasourceCredentialsSecret {
            name?: string;
            namespace?: string;
        }

        export interface AuthenticationServiceSpecStandardImage {
            name?: string;
            pullPolicy?: string;
        }

        export interface AuthenticationServiceSpecStandardInitImage {
            name?: string;
            pullPolicy?: string;
        }

        export interface AuthenticationServiceSpecStandardResources {
            limits?: outputs.admin.v1beta1.AuthenticationServiceSpecStandardResourcesLimits;
            requests?: outputs.admin.v1beta1.AuthenticationServiceSpecStandardResourcesRequests;
        }

        export interface AuthenticationServiceSpecStandardResourcesLimits {
            cpu?: string;
            memory?: string;
        }

        export interface AuthenticationServiceSpecStandardResourcesRequests {
            cpu?: string;
            memory?: string;
        }

        export interface AuthenticationServiceSpecStandardStorage {
            claimName?: string;
            class?: string;
            deleteClaim?: boolean;
            size?: string;
            type: string;
        }

        export interface AuthenticationServiceStatus {
            host?: string;
            /**
             * Status and error messages for the authentication service.
             */
            message?: string;
            /**
             * Phase of the authentication service.
             */
            phase?: string;
            port?: number;
        }

        export interface BrokeredInfraConfigSpec {
            admin?: outputs.admin.v1beta1.BrokeredInfraConfigSpecAdmin;
            broker?: outputs.admin.v1beta1.BrokeredInfraConfigSpecBroker;
            networkPolicy?: outputs.admin.v1beta1.BrokeredInfraConfigSpecNetworkPolicy;
            version?: string;
        }

        export interface BrokeredInfraConfigSpecAdmin {
            podTemplate?: outputs.admin.v1beta1.BrokeredInfraConfigSpecAdminPodTemplate;
            resources?: outputs.admin.v1beta1.BrokeredInfraConfigSpecAdminResources;
        }

        export interface BrokeredInfraConfigSpecAdminPodTemplate {
            metadata?: outputs.admin.v1beta1.BrokeredInfraConfigSpecAdminPodTemplateMetadata;
            spec?: outputs.admin.v1beta1.BrokeredInfraConfigSpecAdminPodTemplateSpec;
        }

        export interface BrokeredInfraConfigSpecAdminPodTemplateMetadata {
            labels?: {[key: string]: any};
        }

        export interface BrokeredInfraConfigSpecAdminPodTemplateSpec {
            affinity?: {[key: string]: any};
            containers?: outputs.admin.v1beta1.BrokeredInfraConfigSpecAdminPodTemplateSpecContainers[];
            priorityClassName?: string;
            securityContext?: {[key: string]: any};
            tolerations?: {[key: string]: any}[];
        }

        export interface BrokeredInfraConfigSpecAdminPodTemplateSpecContainers {
            resources?: {[key: string]: any};
        }

        export interface BrokeredInfraConfigSpecAdminResources {
            cpu?: string;
            memory?: string;
        }

        export interface BrokeredInfraConfigSpecBroker {
            addressFullPolicy?: string;
            /**
             * Sets a global limit to the amount of memory the broker can use before it applies the rules determined by addressFullPolicy. Value in bytes or use a byte suffix ("B", "K", "MB", "GB")
             */
            globalMaxSize?: string;
            javaOpts?: string;
            podTemplate?: outputs.admin.v1beta1.BrokeredInfraConfigSpecBrokerPodTemplate;
            resources?: outputs.admin.v1beta1.BrokeredInfraConfigSpecBrokerResources;
            storageClassName?: string;
            updatePersistentVolumeClaim?: boolean;
        }

        export interface BrokeredInfraConfigSpecBrokerPodTemplate {
            metadata?: outputs.admin.v1beta1.BrokeredInfraConfigSpecBrokerPodTemplateMetadata;
            spec?: outputs.admin.v1beta1.BrokeredInfraConfigSpecBrokerPodTemplateSpec;
        }

        export interface BrokeredInfraConfigSpecBrokerPodTemplateMetadata {
            labels?: {[key: string]: any};
        }

        export interface BrokeredInfraConfigSpecBrokerPodTemplateSpec {
            affinity?: {[key: string]: any};
            priorityClassName?: string;
            resources?: {[key: string]: any};
            securityContext?: {[key: string]: any};
            tolerations?: any[];
        }

        export interface BrokeredInfraConfigSpecBrokerResources {
            cpu?: string;
            memory?: string;
            storage?: string;
        }

        export interface BrokeredInfraConfigSpecNetworkPolicy {
            egress?: any[];
            ingress?: any[];
        }

        export interface ConsoleServiceSpec {
            certificateSecret?: outputs.admin.v1beta1.ConsoleServiceSpecCertificateSecret;
            consoleServer?: outputs.admin.v1beta1.ConsoleServiceSpecConsoleServer;
            discoveryMetadataURL?: string;
            host?: string;
            /**
             * Enable impersonation as the mechanism for authorizing user actions. For impersonation to work, it is important to also grant the console-server permissions to impersonate users.
             */
            impersonation?: outputs.admin.v1beta1.ConsoleServiceSpecImpersonation;
            oauthClientSecret?: outputs.admin.v1beta1.ConsoleServiceSpecOauthClientSecret;
            oauthProxy?: outputs.admin.v1beta1.ConsoleServiceSpecOauthProxy;
            replicas?: number;
            scope?: string;
            ssoCookieDomain?: string;
            ssoCookieSecret?: outputs.admin.v1beta1.ConsoleServiceSpecSsoCookieSecret;
        }

        export interface ConsoleServiceSpecCertificateSecret {
            name?: string;
            namespace?: string;
        }

        export interface ConsoleServiceSpecConsoleServer {
            /**
             * Overrides for the periodic probe of container liveness.
             */
            livenessProbe?: outputs.admin.v1beta1.ConsoleServiceSpecConsoleServerLivenessProbe;
            /**
             * Overrides for the periodic probe of container liveness.
             */
            readinessProbe?: outputs.admin.v1beta1.ConsoleServiceSpecConsoleServerReadinessProbe;
            resources?: outputs.admin.v1beta1.ConsoleServiceSpecConsoleServerResources;
            session?: outputs.admin.v1beta1.ConsoleServiceSpecConsoleServerSession;
        }

        /**
         * Overrides for the periodic probe of container liveness.
         */
        export interface ConsoleServiceSpecConsoleServerLivenessProbe {
            /**
             * Minimum consecutive failures for the probe to be considered failed after having succeeded.
             */
            failureThreshold?: number;
            /**
             * Number of seconds after the container has started before liveness probes are initiated.
             */
            initialDelaySeconds?: number;
            /**
             * How often (in seconds) to perform the probe.
             */
            periodSeconds?: number;
            /**
             * Minimum consecutive successes for the probe to be considered successful after having failed.
             */
            successThreshold?: number;
            /**
             * Number of seconds after which the probe times out.
             */
            timeoutSeconds?: number;
        }

        /**
         * Overrides for the periodic probe of container liveness.
         */
        export interface ConsoleServiceSpecConsoleServerReadinessProbe {
            /**
             * Minimum consecutive failures for the probe to be considered failed after having succeeded.
             */
            failureThreshold?: number;
            /**
             * Number of seconds after the container has started before liveness probes are initiated.
             */
            initialDelaySeconds?: number;
            /**
             * How often (in seconds) to perform the probe.
             */
            periodSeconds?: number;
            /**
             * Minimum consecutive successes for the probe to be considered successful after having failed.
             */
            successThreshold?: number;
            /**
             * Number of seconds after which the probe times out.
             */
            timeoutSeconds?: number;
        }

        export interface ConsoleServiceSpecConsoleServerResources {
            limits?: outputs.admin.v1beta1.ConsoleServiceSpecConsoleServerResourcesLimits;
            requests?: outputs.admin.v1beta1.ConsoleServiceSpecConsoleServerResourcesRequests;
        }

        export interface ConsoleServiceSpecConsoleServerResourcesLimits {
            cpu?: string;
            memory?: string;
        }

        export interface ConsoleServiceSpecConsoleServerResourcesRequests {
            cpu?: string;
            memory?: string;
        }

        export interface ConsoleServiceSpecConsoleServerSession {
            /**
             * IdleTimeout controls the maximum length of time a session can be inactive before it expires. Defaults to 5m.
             */
            idleTimeout?: string;
            /**
             * Lifetime controls the maximum length of time that a session is valid for before it expires. Defaults to 30m.
             */
            lifetime?: string;
        }

        /**
         * Enable impersonation as the mechanism for authorizing user actions. For impersonation to work, it is important to also grant the console-server permissions to impersonate users.
         */
        export interface ConsoleServiceSpecImpersonation {
            /**
             * Headers to use for user impersonation.
             */
            userHeader?: string;
        }

        export interface ConsoleServiceSpecOauthClientSecret {
            name?: string;
            namespace?: string;
        }

        export interface ConsoleServiceSpecOauthProxy {
            /**
             * Extra arguments to pass to oauth-proxy
             */
            extraArgs?: string[];
            resources?: outputs.admin.v1beta1.ConsoleServiceSpecOauthProxyResources;
        }

        export interface ConsoleServiceSpecOauthProxyResources {
            limits?: outputs.admin.v1beta1.ConsoleServiceSpecOauthProxyResourcesLimits;
            requests?: outputs.admin.v1beta1.ConsoleServiceSpecOauthProxyResourcesRequests;
        }

        export interface ConsoleServiceSpecOauthProxyResourcesLimits {
            cpu?: string;
            memory?: string;
        }

        export interface ConsoleServiceSpecOauthProxyResourcesRequests {
            cpu?: string;
            memory?: string;
        }

        export interface ConsoleServiceSpecSsoCookieSecret {
            name?: string;
            namespace?: string;
        }

        export interface ConsoleServiceStatus {
            caCertSecret?: outputs.admin.v1beta1.ConsoleServiceStatusCaCertSecret;
            host?: string;
            port?: number;
        }

        export interface ConsoleServiceStatusCaCertSecret {
            name?: string;
        }

        export interface StandardInfraConfigSpec {
            admin?: outputs.admin.v1beta1.StandardInfraConfigSpecAdmin;
            broker?: outputs.admin.v1beta1.StandardInfraConfigSpecBroker;
            networkPolicy?: outputs.admin.v1beta1.StandardInfraConfigSpecNetworkPolicy;
            router?: outputs.admin.v1beta1.StandardInfraConfigSpecRouter;
            version?: string;
        }

        export interface StandardInfraConfigSpecAdmin {
            podTemplate?: outputs.admin.v1beta1.StandardInfraConfigSpecAdminPodTemplate;
            resources?: outputs.admin.v1beta1.StandardInfraConfigSpecAdminResources;
        }

        export interface StandardInfraConfigSpecAdminPodTemplate {
            metadata?: outputs.admin.v1beta1.StandardInfraConfigSpecAdminPodTemplateMetadata;
            spec?: outputs.admin.v1beta1.StandardInfraConfigSpecAdminPodTemplateSpec;
        }

        export interface StandardInfraConfigSpecAdminPodTemplateMetadata {
            labels?: {[key: string]: any};
        }

        export interface StandardInfraConfigSpecAdminPodTemplateSpec {
            affinity?: {[key: string]: any};
            containers?: outputs.admin.v1beta1.StandardInfraConfigSpecAdminPodTemplateSpecContainers[];
            priorityClassName?: string;
            securityContext?: {[key: string]: any};
            tolerations?: {[key: string]: any}[];
        }

        export interface StandardInfraConfigSpecAdminPodTemplateSpecContainers {
            resources?: {[key: string]: any};
        }

        export interface StandardInfraConfigSpecAdminResources {
            cpu?: string;
            memory?: string;
        }

        export interface StandardInfraConfigSpecBroker {
            addressFullPolicy?: string;
            connectorIdleTimeout?: number;
            connectorWorkerThreads?: number;
            /**
             * Sets a global limit to the amount of memory the broker can use before it applies the rules determined by addressFullPolicy. Value in bytes or use a byte suffix ("B", "K", "MB", "GB")
             */
            globalMaxSize?: string;
            javaOpts?: string;
            maxUnavailable?: outputs.admin.v1beta1.StandardInfraConfigSpecBrokerMaxUnavailable;
            minAvailable?: outputs.admin.v1beta1.StandardInfraConfigSpecBrokerMinAvailable;
            podTemplate?: outputs.admin.v1beta1.StandardInfraConfigSpecBrokerPodTemplate;
            resources?: outputs.admin.v1beta1.StandardInfraConfigSpecBrokerResources;
            storageClassName?: string;
            updatePersistentVolumeClaim?: boolean;
        }

        export interface StandardInfraConfigSpecBrokerMaxUnavailable {
        }

        export interface StandardInfraConfigSpecBrokerMinAvailable {
        }

        export interface StandardInfraConfigSpecBrokerPodTemplate {
            metadata?: outputs.admin.v1beta1.StandardInfraConfigSpecBrokerPodTemplateMetadata;
            spec?: outputs.admin.v1beta1.StandardInfraConfigSpecBrokerPodTemplateSpec;
        }

        export interface StandardInfraConfigSpecBrokerPodTemplateMetadata {
            labels?: {[key: string]: any};
        }

        export interface StandardInfraConfigSpecBrokerPodTemplateSpec {
            affinity?: {[key: string]: any};
            priorityClassName?: string;
            resources?: {[key: string]: any};
            securityContext?: {[key: string]: any};
            tolerations?: any[];
        }

        export interface StandardInfraConfigSpecBrokerResources {
            cpu?: string;
            memory?: string;
            storage?: string;
        }

        export interface StandardInfraConfigSpecNetworkPolicy {
            egress?: any[];
            ingress?: any[];
        }

        export interface StandardInfraConfigSpecRouter {
            idleTimeout?: number;
            linkCapacity?: number;
            maxUnavailable?: outputs.admin.v1beta1.StandardInfraConfigSpecRouterMaxUnavailable;
            minAvailable?: outputs.admin.v1beta1.StandardInfraConfigSpecRouterMinAvailable;
            minReplicas?: number;
            podTemplate?: outputs.admin.v1beta1.StandardInfraConfigSpecRouterPodTemplate;
            policy?: outputs.admin.v1beta1.StandardInfraConfigSpecRouterPolicy;
            resources?: outputs.admin.v1beta1.StandardInfraConfigSpecRouterResources;
            workerThreads?: number;
        }

        export interface StandardInfraConfigSpecRouterMaxUnavailable {
        }

        export interface StandardInfraConfigSpecRouterMinAvailable {
        }

        export interface StandardInfraConfigSpecRouterPodTemplate {
            metadata?: outputs.admin.v1beta1.StandardInfraConfigSpecRouterPodTemplateMetadata;
            spec?: outputs.admin.v1beta1.StandardInfraConfigSpecRouterPodTemplateSpec;
        }

        export interface StandardInfraConfigSpecRouterPodTemplateMetadata {
            labels?: {[key: string]: any};
        }

        export interface StandardInfraConfigSpecRouterPodTemplateSpec {
            affinity?: {[key: string]: any};
            priorityClassName?: string;
            resources?: {[key: string]: any};
            securityContext?: {[key: string]: any};
            tolerations?: any[];
        }

        export interface StandardInfraConfigSpecRouterPolicy {
            maxConnections?: number;
            maxConnectionsPerHost?: number;
            maxConnectionsPerUser?: number;
            maxReceiversPerConnection?: number;
            maxSendersPerConnection?: number;
            maxSessionsPerConnection?: number;
        }

        export interface StandardInfraConfigSpecRouterResources {
            cpu?: string;
            memory?: string;
        }
    }

    export namespace v1beta2 {
        export interface AddressPlanRequiredResources {
            credit: number;
            name: string;
        }

        export interface AddressPlanSpec {
            addressType: string;
            displayName?: string;
            displayOrder?: number;
            longDescription?: string;
            /**
             * Restricts message time-to-live (TTL). Applies to address types queue and topic only.
             */
            messageTtl?: outputs.admin.v1beta2.AddressPlanSpecMessageTtl;
            partitions?: number;
            resources: outputs.admin.v1beta2.AddressPlanSpecResources;
            shortDescription?: string;
        }

        /**
         * Restricts message time-to-live (TTL). Applies to address types queue and topic only.
         */
        export interface AddressPlanSpecMessageTtl {
            /**
             * Imposes a maximum TTL value (in milliseconds) for messages arriving at the address.  Messages arriving with TTL values greater than this value (or no TTL value) will have their expiration adjusted.
             */
            maximum?: number;
            /**
             * Imposes a minimum TTL value (in milliseconds) for messages arriving at the address.  Messages arriving with TTL values less than this value will have their expiration adjusted.
             */
            minimum?: number;
        }

        export interface AddressPlanSpecResources {
            broker?: number;
            router?: number;
        }

        export interface AddressSpacePlanResources {
            max: number;
            name: string;
        }

        export interface AddressSpacePlanSpec {
            addressPlans: string[];
            addressSpaceType: string;
            displayName?: string;
            displayOrder?: number;
            infraConfigRef: string;
            longDescription?: string;
            resourceLimits: outputs.admin.v1beta2.AddressSpacePlanSpecResourceLimits;
            shortDescription?: string;
        }

        export interface AddressSpacePlanSpecResourceLimits {
            aggregate?: number;
            broker?: number;
            router?: number;
        }
    }
}

export namespace enmasse {
    export namespace v1beta1 {
        export interface AddressSpaceSpec {
            /**
             * The authentication service to use for authenticating messaging clients.
             */
            authenticationService?: outputs.enmasse.v1beta1.AddressSpaceSpecAuthenticationService;
            /**
             * External AMQP connections.
             */
            connectors?: outputs.enmasse.v1beta1.AddressSpaceSpecConnectors[];
            /**
             * Endpoints configured for this address space.
             */
            endpoints?: outputs.enmasse.v1beta1.AddressSpaceSpecEndpoints[];
            /**
             * Define NetworkPolicy for this address space.
             */
            networkPolicy?: outputs.enmasse.v1beta1.AddressSpaceSpecNetworkPolicy;
            /**
             * The name of the address space plan to apply.
             */
            plan: string;
            /**
             * The type of address space.
             */
            type: string;
        }

        /**
         * The authentication service to use for authenticating messaging clients.
         */
        export interface AddressSpaceSpecAuthenticationService {
            /**
             * The name of the authentication service.
             */
            name?: string;
            overrides?: outputs.enmasse.v1beta1.AddressSpaceSpecAuthenticationServiceOverrides;
            type?: string;
        }

        export interface AddressSpaceSpecAuthenticationServiceOverrides {
            host?: string;
            port?: number;
            realm?: string;
        }

        export interface AddressSpaceSpecConnectors {
            /**
             * Addresses to make be accessible via this address space.
             */
            addresses?: outputs.enmasse.v1beta1.AddressSpaceSpecConnectorsAddresses[];
            /**
             * Credentials used when connecting to endpoints.
             */
            credentials?: outputs.enmasse.v1beta1.AddressSpaceSpecConnectorsCredentials;
            /**
             * Endpoints to connect to. First entry is used as primary, additional entries are considered failovers.
             */
            endpointHosts: outputs.enmasse.v1beta1.AddressSpaceSpecConnectorsEndpointHosts[];
            /**
             * Idle timeout of AMQP connection (seconds). 0 disables the idle timeout.
             */
            idleTimeout?: number;
            /**
             * Max frame size of AMQP connection.
             */
            maxFrameSize?: number;
            /**
             * Connector name. Used to uniquely identify a connector.
             */
            name: string;
            /**
             * Role of connector. Defaults to 'route-container'.
             */
            role?: string;
            /**
             * TLS configuration for the connector. If not specified, TLS will not be used.
             */
            tls?: outputs.enmasse.v1beta1.AddressSpaceSpecConnectorsTls;
        }

        export interface AddressSpaceSpecConnectorsAddresses {
            /**
             * Identifier of address pattern. Used to uniquely identify a pattern.
             */
            name: string;
            /**
             * Pattern used to match addresses. The pattern will be prefixed by the connector name and a forward slash ('myconnector/'). A pattern consists of one or more tokens separated by a forward slash /. A token can be one of the following: a * character, a # character, or a sequence of characters that do not include /, *, or #. The * token matches any single token. The # token matches zero or more tokens. * has higher precedence than #, and exact match has the highest precedence.
             */
            pattern: string;
        }

        /**
         * Credentials used when connecting to endpoints.
         */
        export interface AddressSpaceSpecConnectorsCredentials {
            /**
             * Password to use for connector.
             */
            password: outputs.enmasse.v1beta1.AddressSpaceSpecConnectorsCredentialsPassword;
            /**
             * Username to use for connector.
             */
            username: outputs.enmasse.v1beta1.AddressSpaceSpecConnectorsCredentialsUsername;
        }

        export interface AddressSpaceSpecConnectorsCredentialsPassword {
        }

        export interface AddressSpaceSpecConnectorsCredentialsUsername {
        }

        export interface AddressSpaceSpecConnectorsEndpointHosts {
            host: string;
            port?: number;
        }

        /**
         * TLS configuration for the connector. If not specified, TLS will not be used.
         */
        export interface AddressSpaceSpecConnectorsTls {
            /**
             * CA certificate to be used by the connector.
             */
            caCert?: outputs.enmasse.v1beta1.AddressSpaceSpecConnectorsTlsCaCert;
            /**
             * Client certificate to be used by the connector.
             */
            clientCert?: outputs.enmasse.v1beta1.AddressSpaceSpecConnectorsTlsClientCert;
            /**
             * Client key to be used by the connector.
             */
            clientKey?: outputs.enmasse.v1beta1.AddressSpaceSpecConnectorsTlsClientKey;
        }

        export interface AddressSpaceSpecConnectorsTlsCaCert {
        }

        export interface AddressSpaceSpecConnectorsTlsClientCert {
        }

        export interface AddressSpaceSpecConnectorsTlsClientKey {
        }

        export interface AddressSpaceSpecEndpoints {
            /**
             * Configure certificates to be used for this endpoint.
             */
            cert?: outputs.enmasse.v1beta1.AddressSpaceSpecEndpointsCert;
            /**
             * Export address space information.
             */
            exports?: outputs.enmasse.v1beta1.AddressSpaceSpecEndpointsExports[];
            /**
             * Expose configuration of this endpoint.
             */
            expose?: outputs.enmasse.v1beta1.AddressSpaceSpecEndpointsExpose;
            /**
             * Endpoint name. Use to uniquely identify an endpoint.
             */
            name?: string;
            /**
             * Service referenced by this endpoint. 'console' is no longer supported.
             */
            service?: string;
        }

        /**
         * Configure certificates to be used for this endpoint.
         */
        export interface AddressSpaceSpecEndpointsCert {
            /**
             * Certificate provider to use for this endpoint.
             */
            provider?: string;
            secretName?: string;
            /**
             * TLS certificate to use for 'certBundle' provider.
             */
            tlsCert?: string;
            /**
             * TLS key to use for 'certBundle' provider.
             */
            tlsKey?: string;
        }

        export interface AddressSpaceSpecEndpointsExports {
            /**
             * Type of resource to export address space information into.
             */
            kind?: string;
            /**
             * Name of resource to export address space information into.
             */
            name?: string;
        }

        export interface AddressSpaceSpecEndpointsExpose {
            type?: any;
        }

        /**
         * Define NetworkPolicy for this address space.
         */
        export interface AddressSpaceSpecNetworkPolicy {
            egress?: {[key: string]: any}[];
            ingress?: {[key: string]: any}[];
        }

        export interface AddressSpaceStatus {
            /**
             * CA certificate for endpoints.
             */
            caCert?: string;
            /**
             * Connector status for this address space.
             */
            connectors?: outputs.enmasse.v1beta1.AddressSpaceStatusConnectors[];
            /**
             * Endpoint status for this address space.
             */
            endpointStatuses?: outputs.enmasse.v1beta1.AddressSpaceStatusEndpointStatuses[];
            /**
             * Whether address space is ready to use or not.
             */
            isReady?: boolean;
            /**
             * Status and error messages for address space.
             */
            messages?: string[];
            /**
             * Phase of address space.
             */
            phase?: string;
            /**
             * Router status for this address space.
             */
            routers?: outputs.enmasse.v1beta1.AddressSpaceStatusRouters[];
        }

        export interface AddressSpaceStatusConnectors {
            isReady?: boolean;
            messages?: string[];
            name?: string;
        }

        export interface AddressSpaceStatusEndpointStatuses {
            externalHost?: string;
            externalPorts?: {[key: string]: any}[];
            messages?: string[];
            name?: string;
            serviceHost?: string;
            servicePorts?: {[key: string]: any}[];
        }

        export interface AddressSpaceStatusRouters {
            id: string;
            neighbors?: string[];
            undelivered?: number;
        }

        export interface AddressSpec {
            /**
             * Messaging address.
             */
            address: string;
            /**
             * Address forwarders for this address.
             */
            forwarders?: outputs.enmasse.v1beta1.AddressSpecForwarders[];
            /**
             * Further restricts message time-to-live (TTL). Applies to address types queue and topic only. The maximum and minimum values must fall with the minimum/maximum range described by the plan's TTL settings.
             */
            messageTtl?: outputs.enmasse.v1beta1.AddressSpecMessageTtl;
            /**
             * Plan referenced by this address.
             */
            plan: string;
            /**
             * Properties that can be set for subscription type addresses.
             */
            subscription?: outputs.enmasse.v1beta1.AddressSpecSubscription;
            /**
             * Address of topic that this subscription refers to (only applicable to subscription types).
             */
            topic?: string;
            /**
             * Address type for this address.
             */
            type: string;
        }

        export interface AddressSpecForwarders {
            direction: string;
            /**
             * Forwarder name.
             */
            name: string;
            /**
             * Remote address to forward to. Must be prefixed with connector name.
             */
            remoteAddress: string;
        }

        /**
         * Further restricts message time-to-live (TTL). Applies to address types queue and topic only. The maximum and minimum values must fall with the minimum/maximum range described by the plan's TTL settings.
         */
        export interface AddressSpecMessageTtl {
            /**
             * Imposes a maximum TTL value (in milliseconds) for messages arriving at the address.  Messages arriving with TTL values greater than this value (or no TTL value) will have their expiration adjusted.
             */
            maximum?: number;
            /**
             * Imposes a minimum TTL value (in milliseconds) for messages arriving at the address.  Messages arriving with TTL values less than this value will have their expiration adjusted.
             */
            minimum?: number;
        }

        /**
         * Properties that can be set for subscription type addresses.
         */
        export interface AddressSpecSubscription {
            /**
             * Maximum number of concurrent consumers that can be attached to this subscription. If unspecified, 1 consumer is allowed per subscription
             */
            maxConsumers?: number;
        }

        export interface AddressStatus {
            /**
             * The status of this address in brokers.
             */
            brokerStatuses?: outputs.enmasse.v1beta1.AddressStatusBrokerStatuses[];
            /**
             * Forwarder status for this address.
             */
            forwarders?: outputs.enmasse.v1beta1.AddressStatusForwarders[];
            /**
             * Whether address is ready to use or not.
             */
            isReady?: boolean;
            /**
             * Applied message TTL properties.
             */
            messageTtl?: outputs.enmasse.v1beta1.AddressStatusMessageTtl;
            /**
             * Status and error messages for address.
             */
            messages?: string[];
            /**
             * Phase of address.
             */
            phase?: string;
            planStatus?: outputs.enmasse.v1beta1.AddressStatusPlanStatus;
            /**
             * Applied properties for subscription type addresses.
             */
            subscription?: outputs.enmasse.v1beta1.AddressStatusSubscription;
        }

        export interface AddressStatusBrokerStatuses {
            brokerId?: string;
            clusterId?: string;
            state?: string;
        }

        export interface AddressStatusForwarders {
            isReady?: boolean;
            messages?: string[];
            name?: string;
        }

        /**
         * Applied message TTL properties.
         */
        export interface AddressStatusMessageTtl {
            /**
             * Maximum TTL value
             */
            maximum?: number;
            /**
             * Minimum TTL value
             */
            minimum?: number;
        }

        export interface AddressStatusPlanStatus {
            name: string;
            partitions: number;
            resources: {[key: string]: any};
        }

        /**
         * Applied properties for subscription type addresses.
         */
        export interface AddressStatusSubscription {
            /**
             * Maximum number of concurrent consumers that can be attached to this subscription.
             */
            maxConsumers?: number;
        }
    }
}

export namespace iot {
    export namespace v1alpha1 {
        export interface IoTConfigSpec {
            adapters?: outputs.iot.v1alpha1.IoTConfigSpecAdapters;
            enableDefaultRoutes?: boolean;
            imageOverrides?: {[key: string]: any};
            /**
             * Configure the strategy to use for connecting services using certificates. If no configuration
             * is present, and you are running on OpenShift 4, then it will automatically deploy certificates
             * using the Service CA.
             */
            interServiceCertificates?: any;
            java?: outputs.iot.v1alpha1.IoTConfigSpecJava;
            logging?: {[key: string]: any};
            mesh?: outputs.iot.v1alpha1.IoTConfigSpecMesh;
            monitoring?: {[key: string]: any};
            services?: outputs.iot.v1alpha1.IoTConfigSpecServices;
            /**
             * Global TLS configuration
             */
            tls?: outputs.iot.v1alpha1.IoTConfigSpecTls;
            tracing?: {[key: string]: any};
        }

        export interface IoTConfigSpecAdapters {
            defaults?: {[key: string]: any};
            http?: {[key: string]: any};
            lorawan?: {[key: string]: any};
            mqtt?: {[key: string]: any};
            sigfox?: {[key: string]: any};
        }

        export interface IoTConfigSpecJava {
            requireNativeTls?: boolean;
        }

        export interface IoTConfigSpecMesh {
            services?: {[key: string]: any};
        }

        export interface IoTConfigSpecServices {
            authentication?: {[key: string]: any};
            deviceConnection?: {[key: string]: any};
            deviceRegistry?: {[key: string]: any};
            tenant?: {[key: string]: any};
        }

        /**
         * Global TLS configuration
         */
        export interface IoTConfigSpecTls {
            versions?: string[];
        }

        export interface IoTConfigStatus {
            adapters?: {[key: string]: any};
            conditions?: outputs.iot.v1alpha1.IoTConfigStatusConditions[];
            message?: string;
            phase?: string;
            services?: {[key: string]: any};
        }

        export interface IoTConfigStatusConditions {
            lastTransitionTime?: string;
            message?: string;
            reason?: string;
            status?: string;
            type?: string;
        }

        export interface IoTProjectSpec {
            configuration?: outputs.iot.v1alpha1.IoTProjectSpecConfiguration;
            downstreamStrategy?: any;
        }

        export interface IoTProjectSpecConfiguration {
            adapters?: outputs.iot.v1alpha1.IoTProjectSpecConfigurationAdapters;
            /**
             * Defaults for properties defined on the tenant and device level.
             */
            defaults?: {[key: string]: any};
            /**
             * Allows to disable the use of the Tenant.
             */
            enabled?: boolean;
            /**
             * Allows arbitrary properties as extension to the ones specified by the Hono API.
             */
            ext?: {[key: string]: any};
            /**
             * The minimum message size in bytes. If set, then reported size of
             * telemetry, event and command messages is calculated as the minimum multiple
             * of the configured value that is greater than or equal to the messages
             * payload size.
             */
            minimumMessageSize?: number;
            trustAnchors?: outputs.iot.v1alpha1.IoTProjectSpecConfigurationTrustAnchors[];
        }

        export interface IoTProjectSpecConfigurationAdapters {
            http?: outputs.iot.v1alpha1.IoTProjectSpecConfigurationAdaptersHttp;
            lorawan?: outputs.iot.v1alpha1.IoTProjectSpecConfigurationAdaptersLorawan;
            mqtt?: outputs.iot.v1alpha1.IoTProjectSpecConfigurationAdaptersMqtt;
            sigfox?: outputs.iot.v1alpha1.IoTProjectSpecConfigurationAdaptersSigfox;
        }

        export interface IoTProjectSpecConfigurationAdaptersHttp {
            enabled?: boolean;
            ext?: {[key: string]: any};
        }

        export interface IoTProjectSpecConfigurationAdaptersLorawan {
            enabled?: boolean;
            ext?: {[key: string]: any};
        }

        export interface IoTProjectSpecConfigurationAdaptersMqtt {
            enabled?: boolean;
            ext?: {[key: string]: any};
        }

        export interface IoTProjectSpecConfigurationAdaptersSigfox {
            enabled?: boolean;
            ext?: {[key: string]: any};
        }

        export interface IoTProjectSpecConfigurationTrustAnchors {
            certificate: string;
        }

        export interface IoTProjectStatus {
            /**
             * The input accepted from the `.spec.configuration` section, split up into the different areas.
             */
            accepted?: outputs.iot.v1alpha1.IoTProjectStatusAccepted;
            conditions?: outputs.iot.v1alpha1.IoTProjectStatusConditions[];
            message?: string;
            phase?: string;
            tenantName?: string;
        }

        /**
         * The input accepted from the `.spec.configuration` section, split up into the different areas.
         */
        export interface IoTProjectStatusAccepted {
            /**
             * The accepted configuration section, ready to be used as a reply to a "Get Tenant" request.
             */
            configuration?: {[key: string]: any};
        }

        export interface IoTProjectStatusConditions {
            lastTransitionTime?: string;
            message?: string;
            reason?: string;
            status?: string;
            type?: string;
        }
    }
}

export namespace user {
    export namespace v1beta1 {
        export interface MessagingUserSpec {
            /**
             * The authentication specification.
             */
            authentication: outputs.user.v1beta1.MessagingUserSpecAuthentication;
            /**
             * The authorization rules for the user.
             */
            authorization?: outputs.user.v1beta1.MessagingUserSpecAuthorization[];
            /**
             * The username used by messaging clients.
             */
            username: string;
        }

        /**
         * The authentication specification.
         */
        export interface MessagingUserSpecAuthentication {
            /**
             * Federated user id for the 'federated' authentication type.
             */
            federatedUserid?: string;
            /**
             * Federated user name for the 'federated' authentication type.
             */
            federatedUsername?: string;
            /**
             * Base64-encoded password for the 'password' authentication type.
             */
            password?: string;
            /**
             * Federated identity provider for the 'federated' authentication type.
             */
            provider?: string;
            /**
             * The type of authentication.
             */
            type: string;
        }

        export interface MessagingUserSpecAuthorization {
            /**
             * The addresses the rule should apply to.
             */
            addresses?: string[];
            /**
             * The operations that should apply to addresses matched by this rule.
             */
            operations?: string[];
        }

        export interface MessagingUserStatus {
            /**
             * Applied generation
             */
            generation?: number;
            /**
             * Message describing the current state
             */
            message?: string;
            /**
             * The lifecycle phase of the messaging user
             */
            phase?: string;
        }
    }
}
