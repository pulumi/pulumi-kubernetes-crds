// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

import {ObjectMeta} from "../meta/v1";

export namespace app {
    export namespace v1alpha1 {
        /**
         * KogitoBuildSpec defines the desired state of KogitoBuild.
         */
        export interface KogitoBuildSpec {
            /**
             * Artifact contains override information for building the Maven artifact (used for Local Source builds). You might want to override this information when building from decisions, rules or process files. In this scenario the Kogito Images will generate a new Java project for you underneath. This information will be used to generate this project.
             */
            artifact?: pulumi.Input<inputs.app.v1alpha1.KogitoBuildSpecArtifact>;
            /**
             * Image used to build the Kogito Service from source (Local and Remote). The operator will use the one provided by the Kogito Team based on the "Runtime" field. Example: Domain: quay.io, Namespace: kiegroup, Name: kogito-jvm-builder, Tag: latest. On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
             */
            buildImage?: pulumi.Input<inputs.app.v1alpha1.KogitoBuildSpecBuildImage>;
            /**
             * DisableIncremental indicates that source to image builds should NOT be incremental. Defaults to false.
             */
            disableIncremental?: pulumi.Input<boolean>;
            /**
             * If set to true will print the logs for downloading/uploading of maven dependencies. Defaults to false.
             */
            enableMavenDownloadOutput?: pulumi.Input<boolean>;
            /**
             * Environment variables used during build time.
             */
            envs?: pulumi.Input<pulumi.Input<inputs.app.v1alpha1.KogitoBuildSpecEnvs>[]>;
            /**
             * Information about the git repository where the Kogito Service source code resides. Ignored for binary builds.
             */
            gitSource?: pulumi.Input<inputs.app.v1alpha1.KogitoBuildSpecGitSource>;
            /**
             * Maven Mirror URL to be used during source-to-image builds (Local and Remote) to considerably increase build speed.
             */
            mavenMirrorURL?: pulumi.Input<string>;
            /**
             * Native indicates if the Kogito Service built should be compiled to run on native mode when Runtime is Quarkus (Source to Image build only). For more information, see https://www.graalvm.org/docs/reference-manual/aot-compilation/.
             */
            native?: pulumi.Input<boolean>;
            /**
             * Resources Requirements for builder pods.
             */
            resources?: pulumi.Input<inputs.app.v1alpha1.KogitoBuildSpecResources>;
            /**
             * Which runtime Kogito service base image to use when building the Kogito service. If "BuildImage" is set, this value is ignored by the operator. Default value: quarkus.
             */
            runtime?: pulumi.Input<string>;
            /**
             * Image used as the base image for the final Kogito service. This image only has the required packages to run the application. For example: quarkus based services will have only JVM installed, native services only the packages required by the OS. The operator will use the one provided by the Kogito Team based on the "Runtime" field. Example: Domain: quay.io, Namespace: kiegroup, Name: kogito-jvm-builder, Tag: latest. On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
             */
            runtimeImage?: pulumi.Input<inputs.app.v1alpha1.KogitoBuildSpecRuntimeImage>;
            /**
             * Set this field targeting the desired KogitoRuntime when this KogitoBuild instance has a different name than the KogitoRuntime. By default this KogitoBuild instance will generate a final image named after its own name (.metadata.name). On OpenShift, an ImageStream will be created causing a redeployment on any KogitoRuntime with the same name. On Kubernetes, the final image will be pushed to the KogitoRuntime deployment. If you have multiple KogitoBuild instances (let's say BinaryBuildType and Remote Source), you might need that both target the same KogitoRuntime. Both KogitoBuilds will update the same ImageStream or generate a final image to the same KogitoRuntime deployment.
             */
            targetKogitoRuntime?: pulumi.Input<string>;
            /**
             * Sets the type of build that this instance will handle: Binary - takes an uploaded binary file already compiled and creates a Kogito service image from it. RemoteSource - pulls the source code from a Git repository, builds the binary and then the final Kogito service image. LocalSource - takes an uploaded resource file such as DRL (rules), DMN (decision) or BPMN (process), builds the binary and the final Kogito service image.
             */
            type: pulumi.Input<string>;
            /**
             * WebHooks secrets for source to image builds based on Git repositories (Remote Sources).
             */
            webHooks?: pulumi.Input<pulumi.Input<inputs.app.v1alpha1.KogitoBuildSpecWebHooks>[]>;
        }

        /**
         * Artifact contains override information for building the Maven artifact (used for Local Source builds). You might want to override this information when building from decisions, rules or process files. In this scenario the Kogito Images will generate a new Java project for you underneath. This information will be used to generate this project.
         */
        export interface KogitoBuildSpecArtifact {
            /**
             * Indicates the unique base name of the primary artifact being generated.
             */
            artifactId?: pulumi.Input<string>;
            /**
             * Indicates the unique identifier of the organization or group that created the project.
             */
            groupId?: pulumi.Input<string>;
            /**
             * Indicates the version of the artifact generated by the project.
             */
            version?: pulumi.Input<string>;
        }

        /**
         * Image used to build the Kogito Service from source (Local and Remote). The operator will use the one provided by the Kogito Team based on the "Runtime" field. Example: Domain: quay.io, Namespace: kiegroup, Name: kogito-jvm-builder, Tag: latest. On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
         */
        export interface KogitoBuildSpecBuildImage {
            domain?: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            namespace?: pulumi.Input<string>;
            tag?: pulumi.Input<string>;
        }

        /**
         * EnvVar represents an environment variable present in a Container.
         */
        export interface KogitoBuildSpecEnvs {
            /**
             * Name of the environment variable. Must be a C_IDENTIFIER.
             */
            name: pulumi.Input<string>;
            /**
             * Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
             */
            value?: pulumi.Input<string>;
            /**
             * Source for the environment variable's value. Cannot be used if value is not empty.
             */
            valueFrom?: pulumi.Input<inputs.app.v1alpha1.KogitoBuildSpecEnvsValueFrom>;
        }

        /**
         * Source for the environment variable's value. Cannot be used if value is not empty.
         */
        export interface KogitoBuildSpecEnvsValueFrom {
            /**
             * Selects a key of a ConfigMap.
             */
            configMapKeyRef?: pulumi.Input<inputs.app.v1alpha1.KogitoBuildSpecEnvsValueFromConfigMapKeyRef>;
            /**
             * Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
             */
            fieldRef?: pulumi.Input<inputs.app.v1alpha1.KogitoBuildSpecEnvsValueFromFieldRef>;
            /**
             * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
             */
            resourceFieldRef?: pulumi.Input<inputs.app.v1alpha1.KogitoBuildSpecEnvsValueFromResourceFieldRef>;
            /**
             * Selects a key of a secret in the pod's namespace
             */
            secretKeyRef?: pulumi.Input<inputs.app.v1alpha1.KogitoBuildSpecEnvsValueFromSecretKeyRef>;
        }

        /**
         * Selects a key of a ConfigMap.
         */
        export interface KogitoBuildSpecEnvsValueFromConfigMapKeyRef {
            /**
             * The key to select.
             */
            key: pulumi.Input<string>;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
             */
            name?: pulumi.Input<string>;
            /**
             * Specify whether the ConfigMap or its key must be defined
             */
            optional?: pulumi.Input<boolean>;
        }

        /**
         * Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
         */
        export interface KogitoBuildSpecEnvsValueFromFieldRef {
            /**
             * Version of the schema the FieldPath is written in terms of, defaults to "v1".
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * Path of the field to select in the specified API version.
             */
            fieldPath: pulumi.Input<string>;
        }

        /**
         * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
         */
        export interface KogitoBuildSpecEnvsValueFromResourceFieldRef {
            /**
             * Container name: required for volumes, optional for env vars
             */
            containerName?: pulumi.Input<string>;
            /**
             * Specifies the output format of the exposed resources, defaults to "1"
             */
            divisor?: pulumi.Input<inputs.app.v1alpha1.KogitoBuildSpecEnvsValueFromResourceFieldRefDivisor>;
            /**
             * Required: resource to select
             */
            resource: pulumi.Input<string>;
        }

        export interface KogitoBuildSpecEnvsValueFromResourceFieldRefDivisor {
        }

        /**
         * Selects a key of a secret in the pod's namespace
         */
        export interface KogitoBuildSpecEnvsValueFromSecretKeyRef {
            /**
             * The key of the secret to select from.  Must be a valid secret key.
             */
            key: pulumi.Input<string>;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
             */
            name?: pulumi.Input<string>;
            /**
             * Specify whether the Secret or its key must be defined
             */
            optional?: pulumi.Input<boolean>;
        }

        /**
         * Information about the git repository where the Kogito Service source code resides. Ignored for binary builds.
         */
        export interface KogitoBuildSpecGitSource {
            /**
             * Context/subdirectory where the code is located, relative to the repo root.
             */
            contextDir?: pulumi.Input<string>;
            /**
             * Branch to use in the Git repository.
             */
            reference?: pulumi.Input<string>;
            /**
             * Git URI for the s2i source.
             */
            uri: pulumi.Input<string>;
        }

        /**
         * Resources Requirements for builder pods.
         */
        export interface KogitoBuildSpecResources {
            /**
             * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
             */
            limits?: pulumi.Input<{[key: string]: pulumi.Input<inputs.app.v1alpha1.KogitoBuildSpecResourcesLimits>}>;
            /**
             * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
             */
            requests?: pulumi.Input<{[key: string]: pulumi.Input<inputs.app.v1alpha1.KogitoBuildSpecResourcesRequests>}>;
        }

        export interface KogitoBuildSpecResourcesLimits {
        }

        export interface KogitoBuildSpecResourcesRequests {
        }

        /**
         * Image used as the base image for the final Kogito service. This image only has the required packages to run the application. For example: quarkus based services will have only JVM installed, native services only the packages required by the OS. The operator will use the one provided by the Kogito Team based on the "Runtime" field. Example: Domain: quay.io, Namespace: kiegroup, Name: kogito-jvm-builder, Tag: latest. On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
         */
        export interface KogitoBuildSpecRuntimeImage {
            domain?: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            namespace?: pulumi.Input<string>;
            tag?: pulumi.Input<string>;
        }

        /**
         * WebHookSecret Secret to use for a given webHook.
         */
        export interface KogitoBuildSpecWebHooks {
            /**
             * Secret value for webHook
             */
            secret?: pulumi.Input<string>;
            /**
             * WebHook type, either GitHub or Generic.
             */
            type?: pulumi.Input<string>;
        }

        /**
         * KogitoBuildStatus defines the observed state of KogitoBuild.
         */
        export interface KogitoBuildStatus {
            /**
             * History of builds
             */
            builds: pulumi.Input<inputs.app.v1alpha1.KogitoBuildStatusBuilds>;
            /**
             * History of conditions for the resource, shows the status of the younger builder controlled by this instance
             */
            conditions: pulumi.Input<pulumi.Input<inputs.app.v1alpha1.KogitoBuildStatusConditions>[]>;
            latestBuild?: pulumi.Input<string>;
        }

        /**
         * History of builds
         */
        export interface KogitoBuildStatusBuilds {
            /**
             * Builds have been stopped from executing.
             */
            cancelled?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Builds have executed and succeeded.
             */
            complete?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Builds have been prevented from executing by an error.
             */
            error?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Builds have executed and failed.
             */
            failed?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Builds are being created.
             */
            new?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Builds are about to start running.
             */
            pending?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Builds are running.
             */
            running?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * KogitoBuildConditions describes the conditions for this build instance according to Kubernetes status interface.
         */
        export interface KogitoBuildStatusConditions {
            /**
             * LastTransitionTime ...
             */
            lastTransitionTime?: pulumi.Input<string>;
            /**
             * Message ...
             */
            message?: pulumi.Input<string>;
            /**
             * Reason of this condition
             */
            reason?: pulumi.Input<string>;
            /**
             * Status ...
             */
            status: pulumi.Input<string>;
            /**
             * Type of this condition
             */
            type: pulumi.Input<string>;
        }

        /**
         * KogitoDataIndexSpec defines the desired state of KogitoDataIndex.
         */
        export interface KogitoDataIndexSpec {
            /**
             * Additional labels to be added to the Deployment and Pods managed by the operator.
             */
            deploymentLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Environment variables to be added to the runtime container. Keys must be a C_IDENTIFIER.
             */
            envs?: pulumi.Input<pulumi.Input<inputs.app.v1alpha1.KogitoDataIndexSpecEnvs>[]>;
            /**
             * HttpPort will set the environment env HTTP_PORT to define which port service will listen internally.
             */
            httpPort?: pulumi.Input<number>;
            /**
             * Image definition for the service. Example: Domain: quay.io, Namespace: kiegroup, Name: kogito-service, Tag: latest. On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
             */
            image?: pulumi.Input<inputs.app.v1alpha1.KogitoDataIndexSpecImage>;
            /**
             * Has the data used by the service to connect to the Infinispan cluster.
             */
            infinispan?: pulumi.Input<inputs.app.v1alpha1.KogitoDataIndexSpecInfinispan>;
            /**
             * A flag indicating that image streams created by Kogito Operator should be configured to allow pulling from insecure registries. Usable just on OpenShift. Defaults to 'false'.
             */
            insecureImageRegistry?: pulumi.Input<boolean>;
            /**
             * Has the data used by the service to connect to the Kafka cluster.
             */
            kafka?: pulumi.Input<inputs.app.v1alpha1.KogitoDataIndexSpecKafka>;
            /**
             * Number of replicas that the service will have deployed in the cluster. Default value: 1.
             */
            replicas?: pulumi.Input<number>;
            /**
             * Defined compute resource requirements for the deployed service.
             */
            resources?: pulumi.Input<inputs.app.v1alpha1.KogitoDataIndexSpecResources>;
            /**
             * Additional labels to be added to the Service managed by the operator.
             */
            serviceLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * EnvVar represents an environment variable present in a Container.
         */
        export interface KogitoDataIndexSpecEnvs {
            /**
             * Name of the environment variable. Must be a C_IDENTIFIER.
             */
            name: pulumi.Input<string>;
            /**
             * Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
             */
            value?: pulumi.Input<string>;
            /**
             * Source for the environment variable's value. Cannot be used if value is not empty.
             */
            valueFrom?: pulumi.Input<inputs.app.v1alpha1.KogitoDataIndexSpecEnvsValueFrom>;
        }

        /**
         * Source for the environment variable's value. Cannot be used if value is not empty.
         */
        export interface KogitoDataIndexSpecEnvsValueFrom {
            /**
             * Selects a key of a ConfigMap.
             */
            configMapKeyRef?: pulumi.Input<inputs.app.v1alpha1.KogitoDataIndexSpecEnvsValueFromConfigMapKeyRef>;
            /**
             * Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
             */
            fieldRef?: pulumi.Input<inputs.app.v1alpha1.KogitoDataIndexSpecEnvsValueFromFieldRef>;
            /**
             * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
             */
            resourceFieldRef?: pulumi.Input<inputs.app.v1alpha1.KogitoDataIndexSpecEnvsValueFromResourceFieldRef>;
            /**
             * Selects a key of a secret in the pod's namespace
             */
            secretKeyRef?: pulumi.Input<inputs.app.v1alpha1.KogitoDataIndexSpecEnvsValueFromSecretKeyRef>;
        }

        /**
         * Selects a key of a ConfigMap.
         */
        export interface KogitoDataIndexSpecEnvsValueFromConfigMapKeyRef {
            /**
             * The key to select.
             */
            key: pulumi.Input<string>;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
             */
            name?: pulumi.Input<string>;
            /**
             * Specify whether the ConfigMap or its key must be defined
             */
            optional?: pulumi.Input<boolean>;
        }

        /**
         * Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
         */
        export interface KogitoDataIndexSpecEnvsValueFromFieldRef {
            /**
             * Version of the schema the FieldPath is written in terms of, defaults to "v1".
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * Path of the field to select in the specified API version.
             */
            fieldPath: pulumi.Input<string>;
        }

        /**
         * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
         */
        export interface KogitoDataIndexSpecEnvsValueFromResourceFieldRef {
            /**
             * Container name: required for volumes, optional for env vars
             */
            containerName?: pulumi.Input<string>;
            /**
             * Specifies the output format of the exposed resources, defaults to "1"
             */
            divisor?: pulumi.Input<inputs.app.v1alpha1.KogitoDataIndexSpecEnvsValueFromResourceFieldRefDivisor>;
            /**
             * Required: resource to select
             */
            resource: pulumi.Input<string>;
        }

        export interface KogitoDataIndexSpecEnvsValueFromResourceFieldRefDivisor {
        }

        /**
         * Selects a key of a secret in the pod's namespace
         */
        export interface KogitoDataIndexSpecEnvsValueFromSecretKeyRef {
            /**
             * The key of the secret to select from.  Must be a valid secret key.
             */
            key: pulumi.Input<string>;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
             */
            name?: pulumi.Input<string>;
            /**
             * Specify whether the Secret or its key must be defined
             */
            optional?: pulumi.Input<boolean>;
        }

        /**
         * Image definition for the service. Example: Domain: quay.io, Namespace: kiegroup, Name: kogito-service, Tag: latest. On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
         */
        export interface KogitoDataIndexSpecImage {
            domain?: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            namespace?: pulumi.Input<string>;
            tag?: pulumi.Input<string>;
        }

        /**
         * Has the data used by the service to connect to the Infinispan cluster.
         */
        export interface KogitoDataIndexSpecInfinispan {
            /**
             * Name of the Infinispan authentication realm. This sets the property infinispan.client.hotrod.auth_realm.
             */
            authRealm?: pulumi.Input<string>;
            /**
             * SecretCredentialsType is the data structure for specifying credentials within a Secret.
             */
            credentials?: pulumi.Input<inputs.app.v1alpha1.KogitoDataIndexSpecInfinispanCredentials>;
            /**
             * SaslMechanism defined for the authentication. This sets the property infinispan.client.hotrod.sasl_mechanism.
             */
            saslMechanism?: pulumi.Input<string>;
            /**
             * URI to connect to the Infinispan cluster (can it be an internal service or external URI), for example, myinfinispan-cluster:11222.
             */
            uri?: pulumi.Input<string>;
            /**
             * UseAuth is set to true if the credentials are set. This also sets the property infinispan.client.hotrod.use_auth.
             */
            useAuth?: pulumi.Input<boolean>;
            /**
             * UseKogitoInfra flags if the instance will use a provided infrastructure by KogitoInfra CR. Setting this to true will deploy a new KogitoInfra CR into the namespace that will install Infinispan via Infinispan Operator. Infinispan Operator MUST be installed in the namespace for this to work. On OpenShift, OLM should install it for you. If running on Kubernetes without OLM installed, please install Infinispan Operator first. Set this to false and fill all other properties to provide your own infrastructure.
             */
            useKogitoInfra?: pulumi.Input<boolean>;
        }

        /**
         * SecretCredentialsType is the data structure for specifying credentials within a Secret.
         */
        export interface KogitoDataIndexSpecInfinispanCredentials {
            /**
             * PasswordKey is the key pointing to a value in a Secret holding the password value.
             */
            passwordKey?: pulumi.Input<string>;
            /**
             * SecretName is the name of the secret where the credentials are set.
             */
            secretName?: pulumi.Input<string>;
            /**
             * UsernameKey is the key pointing to a value in a Secret holding the username value.
             */
            usernameKey?: pulumi.Input<string>;
        }

        /**
         * Has the data used by the service to connect to the Kafka cluster.
         */
        export interface KogitoDataIndexSpecKafka {
            /**
             * URI is the service URI to connect to the Kafka cluster, for example, my-cluster-kafka-bootstrap:9092.
             */
            externalURI?: pulumi.Input<string>;
            /**
             * Instance is the Kafka instance to be used, for example, kogito-kafka.
             */
            instance?: pulumi.Input<string>;
            /**
             * UseKogitoInfra flags if the instance will use a provided infrastructure by KogitoInfra CR. Setting this to true will configure a KogitoInfra CR to install Kafka via Strimzi Operator. Strimzi Operator MUST be installed in the namespace for this to work. On OpenShift, OLM should install it for you. If running on Kubernetes without OLM installed, please install Strimzi Operator first. Set this to false and fill other properties to provide your own infrastructure.
             */
            useKogitoInfra?: pulumi.Input<boolean>;
        }

        /**
         * Defined compute resource requirements for the deployed service.
         */
        export interface KogitoDataIndexSpecResources {
            /**
             * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
             */
            limits?: pulumi.Input<{[key: string]: pulumi.Input<inputs.app.v1alpha1.KogitoDataIndexSpecResourcesLimits>}>;
            /**
             * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
             */
            requests?: pulumi.Input<{[key: string]: pulumi.Input<inputs.app.v1alpha1.KogitoDataIndexSpecResourcesRequests>}>;
        }

        export interface KogitoDataIndexSpecResourcesLimits {
        }

        export interface KogitoDataIndexSpecResourcesRequests {
        }

        /**
         * KogitoDataIndexStatus defines the observed state of KogitoDataIndex.
         */
        export interface KogitoDataIndexStatus {
            /**
             * History of conditions for the resource
             */
            conditions: pulumi.Input<pulumi.Input<inputs.app.v1alpha1.KogitoDataIndexStatusConditions>[]>;
            /**
             * General conditions for the Kogito Service deployment.
             */
            deploymentConditions?: pulumi.Input<pulumi.Input<inputs.app.v1alpha1.KogitoDataIndexStatusDeploymentConditions>[]>;
            /**
             * URI is where the service is exposed.
             */
            externalURI?: pulumi.Input<string>;
            /**
             * Image is the resolved image for this service.
             */
            image?: pulumi.Input<string>;
        }

        /**
         * Condition is the detailed condition for the resource
         */
        export interface KogitoDataIndexStatusConditions {
            lastTransitionTime?: pulumi.Input<string>;
            message?: pulumi.Input<string>;
            /**
             * ReasonType is the type of reason
             */
            reason?: pulumi.Input<string>;
            status: pulumi.Input<string>;
            /**
             * ConditionType is the type of condition
             */
            type: pulumi.Input<string>;
        }

        /**
         * DeploymentCondition describes the state of a deployment at a certain point.
         */
        export interface KogitoDataIndexStatusDeploymentConditions {
            /**
             * Last time the condition transitioned from one status to another.
             */
            lastTransitionTime?: pulumi.Input<string>;
            /**
             * The last time this condition was updated.
             */
            lastUpdateTime?: pulumi.Input<string>;
            /**
             * A human readable message indicating details about the transition.
             */
            message?: pulumi.Input<string>;
            /**
             * The reason for the condition's last transition.
             */
            reason?: pulumi.Input<string>;
            /**
             * Status of the condition, one of True, False, Unknown.
             */
            status: pulumi.Input<string>;
            /**
             * Type of deployment condition.
             */
            type: pulumi.Input<string>;
        }

        /**
         * KogitoInfraSpec defines the desired state of KogitoInfra.
         */
        export interface KogitoInfraSpec {
            /**
             * Indicates if Infinispan should be installed or not using Infinispan Operator. Please note that the Infinispan Operator must be installed manually on environments that doesn't have OLM installed.
             */
            installInfinispan?: pulumi.Input<boolean>;
            /**
             * Indicates if Kafka should be installed or not using Strimzi (Kafka Operator). Please note that the Strimzi must be installed manually on environments that doesn't have OLM installed.
             */
            installKafka?: pulumi.Input<boolean>;
            /**
             * Whether or not to install Keycloak using Keycloak Operator. Please note that the Keycloak Operator must be installed manually on environments that doesn't have OLM installed.
             */
            installKeycloak?: pulumi.Input<boolean>;
        }

        /**
         * KogitoInfraStatus defines the observed state of KogitoInfra.
         */
        export interface KogitoInfraStatus {
            /**
             * KogitoInfraCondition ...
             */
            condition?: pulumi.Input<inputs.app.v1alpha1.KogitoInfraStatusCondition>;
            /**
             * InfinispanInstallStatus defines the Infinispan installation status.
             */
            infinispan?: pulumi.Input<inputs.app.v1alpha1.KogitoInfraStatusInfinispan>;
            /**
             * InfraComponentInstallStatusType is the base structure to define the status for an actor in the infrastructure.
             */
            kafka?: pulumi.Input<inputs.app.v1alpha1.KogitoInfraStatusKafka>;
            /**
             * InfraComponentInstallStatusType is the base structure to define the status for an actor in the infrastructure.
             */
            keycloak?: pulumi.Input<inputs.app.v1alpha1.KogitoInfraStatusKeycloak>;
        }

        /**
         * KogitoInfraCondition ...
         */
        export interface KogitoInfraStatusCondition {
            lastTransitionTime?: pulumi.Input<string>;
            message?: pulumi.Input<string>;
            status: pulumi.Input<string>;
            /**
             * KogitoInfraConditionType ...
             */
            type: pulumi.Input<string>;
        }

        /**
         * InfinispanInstallStatus defines the Infinispan installation status.
         */
        export interface KogitoInfraStatusInfinispan {
            condition?: pulumi.Input<pulumi.Input<inputs.app.v1alpha1.KogitoInfraStatusInfinispanCondition>[]>;
            credentialSecret?: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            service?: pulumi.Input<string>;
        }

        /**
         * InstallCondition defines the installation condition for the infrastructure actor.
         */
        export interface KogitoInfraStatusInfinispanCondition {
            lastTransitionTime?: pulumi.Input<string>;
            message?: pulumi.Input<string>;
            status: pulumi.Input<string>;
            /**
             * InstallConditionType defines the possibles conditions that a install might have.
             */
            type: pulumi.Input<string>;
        }

        /**
         * InfraComponentInstallStatusType is the base structure to define the status for an actor in the infrastructure.
         */
        export interface KogitoInfraStatusKafka {
            condition?: pulumi.Input<pulumi.Input<inputs.app.v1alpha1.KogitoInfraStatusKafkaCondition>[]>;
            name?: pulumi.Input<string>;
            service?: pulumi.Input<string>;
        }

        /**
         * InstallCondition defines the installation condition for the infrastructure actor.
         */
        export interface KogitoInfraStatusKafkaCondition {
            lastTransitionTime?: pulumi.Input<string>;
            message?: pulumi.Input<string>;
            status: pulumi.Input<string>;
            /**
             * InstallConditionType defines the possibles conditions that a install might have.
             */
            type: pulumi.Input<string>;
        }

        /**
         * InfraComponentInstallStatusType is the base structure to define the status for an actor in the infrastructure.
         */
        export interface KogitoInfraStatusKeycloak {
            condition?: pulumi.Input<pulumi.Input<inputs.app.v1alpha1.KogitoInfraStatusKeycloakCondition>[]>;
            name?: pulumi.Input<string>;
            service?: pulumi.Input<string>;
        }

        /**
         * InstallCondition defines the installation condition for the infrastructure actor.
         */
        export interface KogitoInfraStatusKeycloakCondition {
            lastTransitionTime?: pulumi.Input<string>;
            message?: pulumi.Input<string>;
            status: pulumi.Input<string>;
            /**
             * InstallConditionType defines the possibles conditions that a install might have.
             */
            type: pulumi.Input<string>;
        }

        /**
         * KogitoJobsServiceSpec defines the desired state of KogitoJobsService.
         */
        export interface KogitoJobsServiceSpec {
            /**
             * Retry backOff time in milliseconds between the job execution attempts, in case of execution failure. Default to service default, see: https://github.com/kiegroup/kogito-runtimes/wiki/Jobs-Service#configuration-properties
             */
            backOffRetryMillis?: pulumi.Input<number>;
            /**
             * Additional labels to be added to the Deployment and Pods managed by the operator.
             */
            deploymentLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Environment variables to be added to the runtime container. Keys must be a C_IDENTIFIER.
             */
            envs?: pulumi.Input<pulumi.Input<inputs.app.v1alpha1.KogitoJobsServiceSpecEnvs>[]>;
            /**
             * HttpPort will set the environment env HTTP_PORT to define which port service will listen internally.
             */
            httpPort?: pulumi.Input<number>;
            /**
             * Image definition for the service. Example: Domain: quay.io, Namespace: kiegroup, Name: kogito-service, Tag: latest. On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
             */
            image?: pulumi.Input<inputs.app.v1alpha1.KogitoJobsServiceSpecImage>;
            /**
             * Has the data used by the service to connect to the Infinispan cluster.
             */
            infinispan?: pulumi.Input<inputs.app.v1alpha1.KogitoJobsServiceSpecInfinispan>;
            /**
             * A flag indicating that image streams created by Kogito Operator should be configured to allow pulling from insecure registries. Usable just on OpenShift. Defaults to 'false'.
             */
            insecureImageRegistry?: pulumi.Input<boolean>;
            /**
             * Has the data used by the service to connect to the Kafka cluster.
             */
            kafka?: pulumi.Input<inputs.app.v1alpha1.KogitoJobsServiceSpecKafka>;
            /**
             * Maximum interval in milliseconds when retrying to execute jobs, in case of failures. Default to service default, see: https://github.com/kiegroup/kogito-runtimes/wiki/Jobs-Service#configuration-properties
             */
            maxIntervalLimitToRetryMillis?: pulumi.Input<number>;
            /**
             * Number of replicas that the service will have deployed in the cluster. Default value: 1.
             */
            replicas?: pulumi.Input<number>;
            /**
             * Defined compute resource requirements for the deployed service.
             */
            resources?: pulumi.Input<inputs.app.v1alpha1.KogitoJobsServiceSpecResources>;
            /**
             * Additional labels to be added to the Service managed by the operator.
             */
            serviceLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * EnvVar represents an environment variable present in a Container.
         */
        export interface KogitoJobsServiceSpecEnvs {
            /**
             * Name of the environment variable. Must be a C_IDENTIFIER.
             */
            name: pulumi.Input<string>;
            /**
             * Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
             */
            value?: pulumi.Input<string>;
            /**
             * Source for the environment variable's value. Cannot be used if value is not empty.
             */
            valueFrom?: pulumi.Input<inputs.app.v1alpha1.KogitoJobsServiceSpecEnvsValueFrom>;
        }

        /**
         * Source for the environment variable's value. Cannot be used if value is not empty.
         */
        export interface KogitoJobsServiceSpecEnvsValueFrom {
            /**
             * Selects a key of a ConfigMap.
             */
            configMapKeyRef?: pulumi.Input<inputs.app.v1alpha1.KogitoJobsServiceSpecEnvsValueFromConfigMapKeyRef>;
            /**
             * Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
             */
            fieldRef?: pulumi.Input<inputs.app.v1alpha1.KogitoJobsServiceSpecEnvsValueFromFieldRef>;
            /**
             * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
             */
            resourceFieldRef?: pulumi.Input<inputs.app.v1alpha1.KogitoJobsServiceSpecEnvsValueFromResourceFieldRef>;
            /**
             * Selects a key of a secret in the pod's namespace
             */
            secretKeyRef?: pulumi.Input<inputs.app.v1alpha1.KogitoJobsServiceSpecEnvsValueFromSecretKeyRef>;
        }

        /**
         * Selects a key of a ConfigMap.
         */
        export interface KogitoJobsServiceSpecEnvsValueFromConfigMapKeyRef {
            /**
             * The key to select.
             */
            key: pulumi.Input<string>;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
             */
            name?: pulumi.Input<string>;
            /**
             * Specify whether the ConfigMap or its key must be defined
             */
            optional?: pulumi.Input<boolean>;
        }

        /**
         * Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
         */
        export interface KogitoJobsServiceSpecEnvsValueFromFieldRef {
            /**
             * Version of the schema the FieldPath is written in terms of, defaults to "v1".
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * Path of the field to select in the specified API version.
             */
            fieldPath: pulumi.Input<string>;
        }

        /**
         * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
         */
        export interface KogitoJobsServiceSpecEnvsValueFromResourceFieldRef {
            /**
             * Container name: required for volumes, optional for env vars
             */
            containerName?: pulumi.Input<string>;
            /**
             * Specifies the output format of the exposed resources, defaults to "1"
             */
            divisor?: pulumi.Input<inputs.app.v1alpha1.KogitoJobsServiceSpecEnvsValueFromResourceFieldRefDivisor>;
            /**
             * Required: resource to select
             */
            resource: pulumi.Input<string>;
        }

        export interface KogitoJobsServiceSpecEnvsValueFromResourceFieldRefDivisor {
        }

        /**
         * Selects a key of a secret in the pod's namespace
         */
        export interface KogitoJobsServiceSpecEnvsValueFromSecretKeyRef {
            /**
             * The key of the secret to select from.  Must be a valid secret key.
             */
            key: pulumi.Input<string>;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
             */
            name?: pulumi.Input<string>;
            /**
             * Specify whether the Secret or its key must be defined
             */
            optional?: pulumi.Input<boolean>;
        }

        /**
         * Image definition for the service. Example: Domain: quay.io, Namespace: kiegroup, Name: kogito-service, Tag: latest. On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
         */
        export interface KogitoJobsServiceSpecImage {
            domain?: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            namespace?: pulumi.Input<string>;
            tag?: pulumi.Input<string>;
        }

        /**
         * Has the data used by the service to connect to the Infinispan cluster.
         */
        export interface KogitoJobsServiceSpecInfinispan {
            /**
             * Name of the Infinispan authentication realm. This sets the property infinispan.client.hotrod.auth_realm.
             */
            authRealm?: pulumi.Input<string>;
            /**
             * SecretCredentialsType is the data structure for specifying credentials within a Secret.
             */
            credentials?: pulumi.Input<inputs.app.v1alpha1.KogitoJobsServiceSpecInfinispanCredentials>;
            /**
             * SaslMechanism defined for the authentication. This sets the property infinispan.client.hotrod.sasl_mechanism.
             */
            saslMechanism?: pulumi.Input<string>;
            /**
             * URI to connect to the Infinispan cluster (can it be an internal service or external URI), for example, myinfinispan-cluster:11222.
             */
            uri?: pulumi.Input<string>;
            /**
             * UseAuth is set to true if the credentials are set. This also sets the property infinispan.client.hotrod.use_auth.
             */
            useAuth?: pulumi.Input<boolean>;
            /**
             * UseKogitoInfra flags if the instance will use a provided infrastructure by KogitoInfra CR. Setting this to true will deploy a new KogitoInfra CR into the namespace that will install Infinispan via Infinispan Operator. Infinispan Operator MUST be installed in the namespace for this to work. On OpenShift, OLM should install it for you. If running on Kubernetes without OLM installed, please install Infinispan Operator first. Set this to false and fill all other properties to provide your own infrastructure.
             */
            useKogitoInfra?: pulumi.Input<boolean>;
        }

        /**
         * SecretCredentialsType is the data structure for specifying credentials within a Secret.
         */
        export interface KogitoJobsServiceSpecInfinispanCredentials {
            /**
             * PasswordKey is the key pointing to a value in a Secret holding the password value.
             */
            passwordKey?: pulumi.Input<string>;
            /**
             * SecretName is the name of the secret where the credentials are set.
             */
            secretName?: pulumi.Input<string>;
            /**
             * UsernameKey is the key pointing to a value in a Secret holding the username value.
             */
            usernameKey?: pulumi.Input<string>;
        }

        /**
         * Has the data used by the service to connect to the Kafka cluster.
         */
        export interface KogitoJobsServiceSpecKafka {
            /**
             * URI is the service URI to connect to the Kafka cluster, for example, my-cluster-kafka-bootstrap:9092.
             */
            externalURI?: pulumi.Input<string>;
            /**
             * Instance is the Kafka instance to be used, for example, kogito-kafka.
             */
            instance?: pulumi.Input<string>;
            /**
             * UseKogitoInfra flags if the instance will use a provided infrastructure by KogitoInfra CR. Setting this to true will configure a KogitoInfra CR to install Kafka via Strimzi Operator. Strimzi Operator MUST be installed in the namespace for this to work. On OpenShift, OLM should install it for you. If running on Kubernetes without OLM installed, please install Strimzi Operator first. Set this to false and fill other properties to provide your own infrastructure.
             */
            useKogitoInfra?: pulumi.Input<boolean>;
        }

        /**
         * Defined compute resource requirements for the deployed service.
         */
        export interface KogitoJobsServiceSpecResources {
            /**
             * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
             */
            limits?: pulumi.Input<{[key: string]: pulumi.Input<inputs.app.v1alpha1.KogitoJobsServiceSpecResourcesLimits>}>;
            /**
             * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
             */
            requests?: pulumi.Input<{[key: string]: pulumi.Input<inputs.app.v1alpha1.KogitoJobsServiceSpecResourcesRequests>}>;
        }

        export interface KogitoJobsServiceSpecResourcesLimits {
        }

        export interface KogitoJobsServiceSpecResourcesRequests {
        }

        /**
         * KogitoJobsServiceStatus defines the observed state of KogitoJobsService.
         */
        export interface KogitoJobsServiceStatus {
            /**
             * History of conditions for the resource
             */
            conditions: pulumi.Input<pulumi.Input<inputs.app.v1alpha1.KogitoJobsServiceStatusConditions>[]>;
            /**
             * General conditions for the Kogito Service deployment.
             */
            deploymentConditions?: pulumi.Input<pulumi.Input<inputs.app.v1alpha1.KogitoJobsServiceStatusDeploymentConditions>[]>;
            /**
             * URI is where the service is exposed.
             */
            externalURI?: pulumi.Input<string>;
            /**
             * Image is the resolved image for this service.
             */
            image?: pulumi.Input<string>;
        }

        /**
         * Condition is the detailed condition for the resource
         */
        export interface KogitoJobsServiceStatusConditions {
            lastTransitionTime?: pulumi.Input<string>;
            message?: pulumi.Input<string>;
            /**
             * ReasonType is the type of reason
             */
            reason?: pulumi.Input<string>;
            status: pulumi.Input<string>;
            /**
             * ConditionType is the type of condition
             */
            type: pulumi.Input<string>;
        }

        /**
         * DeploymentCondition describes the state of a deployment at a certain point.
         */
        export interface KogitoJobsServiceStatusDeploymentConditions {
            /**
             * Last time the condition transitioned from one status to another.
             */
            lastTransitionTime?: pulumi.Input<string>;
            /**
             * The last time this condition was updated.
             */
            lastUpdateTime?: pulumi.Input<string>;
            /**
             * A human readable message indicating details about the transition.
             */
            message?: pulumi.Input<string>;
            /**
             * The reason for the condition's last transition.
             */
            reason?: pulumi.Input<string>;
            /**
             * Status of the condition, one of True, False, Unknown.
             */
            status: pulumi.Input<string>;
            /**
             * Type of deployment condition.
             */
            type: pulumi.Input<string>;
        }

        /**
         * KogitoMgmtConsoleSpec defines the desired state of KogitoMgmtConsole.
         */
        export interface KogitoMgmtConsoleSpec {
            /**
             * Additional labels to be added to the Deployment and Pods managed by the operator.
             */
            deploymentLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Environment variables to be added to the runtime container. Keys must be a C_IDENTIFIER.
             */
            envs?: pulumi.Input<pulumi.Input<inputs.app.v1alpha1.KogitoMgmtConsoleSpecEnvs>[]>;
            /**
             * HttpPort will set the environment env HTTP_PORT to define which port service will listen internally.
             */
            httpPort?: pulumi.Input<number>;
            /**
             * Image definition for the service. Example: Domain: quay.io, Namespace: kiegroup, Name: kogito-service, Tag: latest. On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
             */
            image?: pulumi.Input<inputs.app.v1alpha1.KogitoMgmtConsoleSpecImage>;
            /**
             * A flag indicating that image streams created by Kogito Operator should be configured to allow pulling from insecure registries. Usable just on OpenShift. Defaults to 'false'.
             */
            insecureImageRegistry?: pulumi.Input<boolean>;
            /**
             * Number of replicas that the service will have deployed in the cluster. Default value: 1.
             */
            replicas?: pulumi.Input<number>;
            /**
             * Defined compute resource requirements for the deployed service.
             */
            resources?: pulumi.Input<inputs.app.v1alpha1.KogitoMgmtConsoleSpecResources>;
            /**
             * Additional labels to be added to the Service managed by the operator.
             */
            serviceLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * EnvVar represents an environment variable present in a Container.
         */
        export interface KogitoMgmtConsoleSpecEnvs {
            /**
             * Name of the environment variable. Must be a C_IDENTIFIER.
             */
            name: pulumi.Input<string>;
            /**
             * Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
             */
            value?: pulumi.Input<string>;
            /**
             * Source for the environment variable's value. Cannot be used if value is not empty.
             */
            valueFrom?: pulumi.Input<inputs.app.v1alpha1.KogitoMgmtConsoleSpecEnvsValueFrom>;
        }

        /**
         * Source for the environment variable's value. Cannot be used if value is not empty.
         */
        export interface KogitoMgmtConsoleSpecEnvsValueFrom {
            /**
             * Selects a key of a ConfigMap.
             */
            configMapKeyRef?: pulumi.Input<inputs.app.v1alpha1.KogitoMgmtConsoleSpecEnvsValueFromConfigMapKeyRef>;
            /**
             * Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
             */
            fieldRef?: pulumi.Input<inputs.app.v1alpha1.KogitoMgmtConsoleSpecEnvsValueFromFieldRef>;
            /**
             * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
             */
            resourceFieldRef?: pulumi.Input<inputs.app.v1alpha1.KogitoMgmtConsoleSpecEnvsValueFromResourceFieldRef>;
            /**
             * Selects a key of a secret in the pod's namespace
             */
            secretKeyRef?: pulumi.Input<inputs.app.v1alpha1.KogitoMgmtConsoleSpecEnvsValueFromSecretKeyRef>;
        }

        /**
         * Selects a key of a ConfigMap.
         */
        export interface KogitoMgmtConsoleSpecEnvsValueFromConfigMapKeyRef {
            /**
             * The key to select.
             */
            key: pulumi.Input<string>;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
             */
            name?: pulumi.Input<string>;
            /**
             * Specify whether the ConfigMap or its key must be defined
             */
            optional?: pulumi.Input<boolean>;
        }

        /**
         * Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
         */
        export interface KogitoMgmtConsoleSpecEnvsValueFromFieldRef {
            /**
             * Version of the schema the FieldPath is written in terms of, defaults to "v1".
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * Path of the field to select in the specified API version.
             */
            fieldPath: pulumi.Input<string>;
        }

        /**
         * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
         */
        export interface KogitoMgmtConsoleSpecEnvsValueFromResourceFieldRef {
            /**
             * Container name: required for volumes, optional for env vars
             */
            containerName?: pulumi.Input<string>;
            /**
             * Specifies the output format of the exposed resources, defaults to "1"
             */
            divisor?: pulumi.Input<inputs.app.v1alpha1.KogitoMgmtConsoleSpecEnvsValueFromResourceFieldRefDivisor>;
            /**
             * Required: resource to select
             */
            resource: pulumi.Input<string>;
        }

        export interface KogitoMgmtConsoleSpecEnvsValueFromResourceFieldRefDivisor {
        }

        /**
         * Selects a key of a secret in the pod's namespace
         */
        export interface KogitoMgmtConsoleSpecEnvsValueFromSecretKeyRef {
            /**
             * The key of the secret to select from.  Must be a valid secret key.
             */
            key: pulumi.Input<string>;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
             */
            name?: pulumi.Input<string>;
            /**
             * Specify whether the Secret or its key must be defined
             */
            optional?: pulumi.Input<boolean>;
        }

        /**
         * Image definition for the service. Example: Domain: quay.io, Namespace: kiegroup, Name: kogito-service, Tag: latest. On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
         */
        export interface KogitoMgmtConsoleSpecImage {
            domain?: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            namespace?: pulumi.Input<string>;
            tag?: pulumi.Input<string>;
        }

        /**
         * Defined compute resource requirements for the deployed service.
         */
        export interface KogitoMgmtConsoleSpecResources {
            /**
             * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
             */
            limits?: pulumi.Input<{[key: string]: pulumi.Input<inputs.app.v1alpha1.KogitoMgmtConsoleSpecResourcesLimits>}>;
            /**
             * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
             */
            requests?: pulumi.Input<{[key: string]: pulumi.Input<inputs.app.v1alpha1.KogitoMgmtConsoleSpecResourcesRequests>}>;
        }

        export interface KogitoMgmtConsoleSpecResourcesLimits {
        }

        export interface KogitoMgmtConsoleSpecResourcesRequests {
        }

        /**
         * KogitoMgmtConsoleStatus defines the observed state of KogitoMgmtConsole.
         */
        export interface KogitoMgmtConsoleStatus {
            /**
             * History of conditions for the resource
             */
            conditions: pulumi.Input<pulumi.Input<inputs.app.v1alpha1.KogitoMgmtConsoleStatusConditions>[]>;
            /**
             * General conditions for the Kogito Service deployment.
             */
            deploymentConditions?: pulumi.Input<pulumi.Input<inputs.app.v1alpha1.KogitoMgmtConsoleStatusDeploymentConditions>[]>;
            /**
             * URI is where the service is exposed.
             */
            externalURI?: pulumi.Input<string>;
            /**
             * Image is the resolved image for this service.
             */
            image?: pulumi.Input<string>;
        }

        /**
         * Condition is the detailed condition for the resource
         */
        export interface KogitoMgmtConsoleStatusConditions {
            lastTransitionTime?: pulumi.Input<string>;
            message?: pulumi.Input<string>;
            /**
             * ReasonType is the type of reason
             */
            reason?: pulumi.Input<string>;
            status: pulumi.Input<string>;
            /**
             * ConditionType is the type of condition
             */
            type: pulumi.Input<string>;
        }

        /**
         * DeploymentCondition describes the state of a deployment at a certain point.
         */
        export interface KogitoMgmtConsoleStatusDeploymentConditions {
            /**
             * Last time the condition transitioned from one status to another.
             */
            lastTransitionTime?: pulumi.Input<string>;
            /**
             * The last time this condition was updated.
             */
            lastUpdateTime?: pulumi.Input<string>;
            /**
             * A human readable message indicating details about the transition.
             */
            message?: pulumi.Input<string>;
            /**
             * The reason for the condition's last transition.
             */
            reason?: pulumi.Input<string>;
            /**
             * Status of the condition, one of True, False, Unknown.
             */
            status: pulumi.Input<string>;
            /**
             * Type of deployment condition.
             */
            type: pulumi.Input<string>;
        }

        /**
         * KogitoRuntimeSpec defines the desired state of KogitoRuntime.
         */
        export interface KogitoRuntimeSpec {
            /**
             * Additional labels to be added to the Deployment and Pods managed by the operator.
             */
            deploymentLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Annotates the pods managed by the operator with the required metadata for Istio to setup its sidecars, enabling the mesh. Defaults to false.
             */
            enableIstio?: pulumi.Input<boolean>;
            /**
             * Environment variables to be added to the runtime container. Keys must be a C_IDENTIFIER.
             */
            envs?: pulumi.Input<pulumi.Input<inputs.app.v1alpha1.KogitoRuntimeSpecEnvs>[]>;
            /**
             * HttpPort will set the environment env HTTP_PORT to define which port service will listen internally.
             */
            httpPort?: pulumi.Input<number>;
            /**
             * Image definition for the service. Example: Domain: quay.io, Namespace: kiegroup, Name: kogito-service, Tag: latest. On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
             */
            image?: pulumi.Input<inputs.app.v1alpha1.KogitoRuntimeSpecImage>;
            /**
             * Has the data used by the service to connect to the Infinispan cluster.
             */
            infinispan?: pulumi.Input<inputs.app.v1alpha1.KogitoRuntimeSpecInfinispan>;
            /**
             * A flag indicating that image streams created by Kogito Operator should be configured to allow pulling from insecure registries. Usable just on OpenShift. Defaults to 'false'.
             */
            insecureImageRegistry?: pulumi.Input<boolean>;
            /**
             * Has the data used by the service to connect to the Kafka cluster.
             */
            kafka?: pulumi.Input<inputs.app.v1alpha1.KogitoRuntimeSpecKafka>;
            /**
             * Number of replicas that the service will have deployed in the cluster. Default value: 1.
             */
            replicas?: pulumi.Input<number>;
            /**
             * Defined compute resource requirements for the deployed service.
             */
            resources?: pulumi.Input<inputs.app.v1alpha1.KogitoRuntimeSpecResources>;
            /**
             * The name of the runtime used, either Quarkus or SpringBoot. Default value: quarkus
             */
            runtime?: pulumi.Input<string>;
            /**
             * Additional labels to be added to the Service managed by the operator.
             */
            serviceLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * EnvVar represents an environment variable present in a Container.
         */
        export interface KogitoRuntimeSpecEnvs {
            /**
             * Name of the environment variable. Must be a C_IDENTIFIER.
             */
            name: pulumi.Input<string>;
            /**
             * Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
             */
            value?: pulumi.Input<string>;
            /**
             * Source for the environment variable's value. Cannot be used if value is not empty.
             */
            valueFrom?: pulumi.Input<inputs.app.v1alpha1.KogitoRuntimeSpecEnvsValueFrom>;
        }

        /**
         * Source for the environment variable's value. Cannot be used if value is not empty.
         */
        export interface KogitoRuntimeSpecEnvsValueFrom {
            /**
             * Selects a key of a ConfigMap.
             */
            configMapKeyRef?: pulumi.Input<inputs.app.v1alpha1.KogitoRuntimeSpecEnvsValueFromConfigMapKeyRef>;
            /**
             * Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
             */
            fieldRef?: pulumi.Input<inputs.app.v1alpha1.KogitoRuntimeSpecEnvsValueFromFieldRef>;
            /**
             * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
             */
            resourceFieldRef?: pulumi.Input<inputs.app.v1alpha1.KogitoRuntimeSpecEnvsValueFromResourceFieldRef>;
            /**
             * Selects a key of a secret in the pod's namespace
             */
            secretKeyRef?: pulumi.Input<inputs.app.v1alpha1.KogitoRuntimeSpecEnvsValueFromSecretKeyRef>;
        }

        /**
         * Selects a key of a ConfigMap.
         */
        export interface KogitoRuntimeSpecEnvsValueFromConfigMapKeyRef {
            /**
             * The key to select.
             */
            key: pulumi.Input<string>;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
             */
            name?: pulumi.Input<string>;
            /**
             * Specify whether the ConfigMap or its key must be defined
             */
            optional?: pulumi.Input<boolean>;
        }

        /**
         * Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
         */
        export interface KogitoRuntimeSpecEnvsValueFromFieldRef {
            /**
             * Version of the schema the FieldPath is written in terms of, defaults to "v1".
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * Path of the field to select in the specified API version.
             */
            fieldPath: pulumi.Input<string>;
        }

        /**
         * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
         */
        export interface KogitoRuntimeSpecEnvsValueFromResourceFieldRef {
            /**
             * Container name: required for volumes, optional for env vars
             */
            containerName?: pulumi.Input<string>;
            /**
             * Specifies the output format of the exposed resources, defaults to "1"
             */
            divisor?: pulumi.Input<inputs.app.v1alpha1.KogitoRuntimeSpecEnvsValueFromResourceFieldRefDivisor>;
            /**
             * Required: resource to select
             */
            resource: pulumi.Input<string>;
        }

        export interface KogitoRuntimeSpecEnvsValueFromResourceFieldRefDivisor {
        }

        /**
         * Selects a key of a secret in the pod's namespace
         */
        export interface KogitoRuntimeSpecEnvsValueFromSecretKeyRef {
            /**
             * The key of the secret to select from.  Must be a valid secret key.
             */
            key: pulumi.Input<string>;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
             */
            name?: pulumi.Input<string>;
            /**
             * Specify whether the Secret or its key must be defined
             */
            optional?: pulumi.Input<boolean>;
        }

        /**
         * Image definition for the service. Example: Domain: quay.io, Namespace: kiegroup, Name: kogito-service, Tag: latest. On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
         */
        export interface KogitoRuntimeSpecImage {
            domain?: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            namespace?: pulumi.Input<string>;
            tag?: pulumi.Input<string>;
        }

        /**
         * Has the data used by the service to connect to the Infinispan cluster.
         */
        export interface KogitoRuntimeSpecInfinispan {
            /**
             * Name of the Infinispan authentication realm. This sets the property infinispan.client.hotrod.auth_realm.
             */
            authRealm?: pulumi.Input<string>;
            /**
             * SecretCredentialsType is the data structure for specifying credentials within a Secret.
             */
            credentials?: pulumi.Input<inputs.app.v1alpha1.KogitoRuntimeSpecInfinispanCredentials>;
            /**
             * SaslMechanism defined for the authentication. This sets the property infinispan.client.hotrod.sasl_mechanism.
             */
            saslMechanism?: pulumi.Input<string>;
            /**
             * URI to connect to the Infinispan cluster (can it be an internal service or external URI), for example, myinfinispan-cluster:11222.
             */
            uri?: pulumi.Input<string>;
            /**
             * UseAuth is set to true if the credentials are set. This also sets the property infinispan.client.hotrod.use_auth.
             */
            useAuth?: pulumi.Input<boolean>;
            /**
             * UseKogitoInfra flags if the instance will use a provided infrastructure by KogitoInfra CR. Setting this to true will deploy a new KogitoInfra CR into the namespace that will install Infinispan via Infinispan Operator. Infinispan Operator MUST be installed in the namespace for this to work. On OpenShift, OLM should install it for you. If running on Kubernetes without OLM installed, please install Infinispan Operator first. Set this to false and fill all other properties to provide your own infrastructure.
             */
            useKogitoInfra?: pulumi.Input<boolean>;
        }

        /**
         * SecretCredentialsType is the data structure for specifying credentials within a Secret.
         */
        export interface KogitoRuntimeSpecInfinispanCredentials {
            /**
             * PasswordKey is the key pointing to a value in a Secret holding the password value.
             */
            passwordKey?: pulumi.Input<string>;
            /**
             * SecretName is the name of the secret where the credentials are set.
             */
            secretName?: pulumi.Input<string>;
            /**
             * UsernameKey is the key pointing to a value in a Secret holding the username value.
             */
            usernameKey?: pulumi.Input<string>;
        }

        /**
         * Has the data used by the service to connect to the Kafka cluster.
         */
        export interface KogitoRuntimeSpecKafka {
            /**
             * URI is the service URI to connect to the Kafka cluster, for example, my-cluster-kafka-bootstrap:9092.
             */
            externalURI?: pulumi.Input<string>;
            /**
             * Instance is the Kafka instance to be used, for example, kogito-kafka.
             */
            instance?: pulumi.Input<string>;
            /**
             * UseKogitoInfra flags if the instance will use a provided infrastructure by KogitoInfra CR. Setting this to true will configure a KogitoInfra CR to install Kafka via Strimzi Operator. Strimzi Operator MUST be installed in the namespace for this to work. On OpenShift, OLM should install it for you. If running on Kubernetes without OLM installed, please install Strimzi Operator first. Set this to false and fill other properties to provide your own infrastructure.
             */
            useKogitoInfra?: pulumi.Input<boolean>;
        }

        /**
         * Defined compute resource requirements for the deployed service.
         */
        export interface KogitoRuntimeSpecResources {
            /**
             * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
             */
            limits?: pulumi.Input<{[key: string]: pulumi.Input<inputs.app.v1alpha1.KogitoRuntimeSpecResourcesLimits>}>;
            /**
             * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
             */
            requests?: pulumi.Input<{[key: string]: pulumi.Input<inputs.app.v1alpha1.KogitoRuntimeSpecResourcesRequests>}>;
        }

        export interface KogitoRuntimeSpecResourcesLimits {
        }

        export interface KogitoRuntimeSpecResourcesRequests {
        }

        /**
         * KogitoRuntimeStatus defines the observed state of KogitoRuntime.
         */
        export interface KogitoRuntimeStatus {
            /**
             * History of conditions for the resource
             */
            conditions: pulumi.Input<pulumi.Input<inputs.app.v1alpha1.KogitoRuntimeStatusConditions>[]>;
            /**
             * General conditions for the Kogito Service deployment.
             */
            deploymentConditions?: pulumi.Input<pulumi.Input<inputs.app.v1alpha1.KogitoRuntimeStatusDeploymentConditions>[]>;
            /**
             * URI is where the service is exposed.
             */
            externalURI?: pulumi.Input<string>;
            /**
             * Image is the resolved image for this service.
             */
            image?: pulumi.Input<string>;
        }

        /**
         * Condition is the detailed condition for the resource
         */
        export interface KogitoRuntimeStatusConditions {
            lastTransitionTime?: pulumi.Input<string>;
            message?: pulumi.Input<string>;
            /**
             * ReasonType is the type of reason
             */
            reason?: pulumi.Input<string>;
            status: pulumi.Input<string>;
            /**
             * ConditionType is the type of condition
             */
            type: pulumi.Input<string>;
        }

        /**
         * DeploymentCondition describes the state of a deployment at a certain point.
         */
        export interface KogitoRuntimeStatusDeploymentConditions {
            /**
             * Last time the condition transitioned from one status to another.
             */
            lastTransitionTime?: pulumi.Input<string>;
            /**
             * The last time this condition was updated.
             */
            lastUpdateTime?: pulumi.Input<string>;
            /**
             * A human readable message indicating details about the transition.
             */
            message?: pulumi.Input<string>;
            /**
             * The reason for the condition's last transition.
             */
            reason?: pulumi.Input<string>;
            /**
             * Status of the condition, one of True, False, Unknown.
             */
            status: pulumi.Input<string>;
            /**
             * Type of deployment condition.
             */
            type: pulumi.Input<string>;
        }

        /**
         * KogitoTrustySpec defines the desired state of KogitoTrusty.
         */
        export interface KogitoTrustySpec {
            /**
             * Additional labels to be added to the Deployment and Pods managed by the operator.
             */
            deploymentLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Environment variables to be added to the runtime container. Keys must be a C_IDENTIFIER.
             */
            envs?: pulumi.Input<pulumi.Input<inputs.app.v1alpha1.KogitoTrustySpecEnvs>[]>;
            /**
             * HttpPort will set the environment env HTTP_PORT to define which port service will listen internally.
             */
            httpPort?: pulumi.Input<number>;
            /**
             * Image definition for the service. Example: Domain: quay.io, Namespace: kiegroup, Name: kogito-service, Tag: latest. On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
             */
            image?: pulumi.Input<inputs.app.v1alpha1.KogitoTrustySpecImage>;
            /**
             * Has the data used by the service to connect to the Infinispan cluster.
             */
            infinispan?: pulumi.Input<inputs.app.v1alpha1.KogitoTrustySpecInfinispan>;
            /**
             * A flag indicating that image streams created by Kogito Operator should be configured to allow pulling from insecure registries. Usable just on OpenShift. Defaults to 'false'.
             */
            insecureImageRegistry?: pulumi.Input<boolean>;
            /**
             * Has the data used by the service to connect to the Kafka cluster.
             */
            kafka?: pulumi.Input<inputs.app.v1alpha1.KogitoTrustySpecKafka>;
            /**
             * Number of replicas that the service will have deployed in the cluster. Default value: 1.
             */
            replicas?: pulumi.Input<number>;
            /**
             * Defined compute resource requirements for the deployed service.
             */
            resources?: pulumi.Input<inputs.app.v1alpha1.KogitoTrustySpecResources>;
            /**
             * Additional labels to be added to the Service managed by the operator.
             */
            serviceLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * EnvVar represents an environment variable present in a Container.
         */
        export interface KogitoTrustySpecEnvs {
            /**
             * Name of the environment variable. Must be a C_IDENTIFIER.
             */
            name: pulumi.Input<string>;
            /**
             * Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
             */
            value?: pulumi.Input<string>;
            /**
             * Source for the environment variable's value. Cannot be used if value is not empty.
             */
            valueFrom?: pulumi.Input<inputs.app.v1alpha1.KogitoTrustySpecEnvsValueFrom>;
        }

        /**
         * Source for the environment variable's value. Cannot be used if value is not empty.
         */
        export interface KogitoTrustySpecEnvsValueFrom {
            /**
             * Selects a key of a ConfigMap.
             */
            configMapKeyRef?: pulumi.Input<inputs.app.v1alpha1.KogitoTrustySpecEnvsValueFromConfigMapKeyRef>;
            /**
             * Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
             */
            fieldRef?: pulumi.Input<inputs.app.v1alpha1.KogitoTrustySpecEnvsValueFromFieldRef>;
            /**
             * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
             */
            resourceFieldRef?: pulumi.Input<inputs.app.v1alpha1.KogitoTrustySpecEnvsValueFromResourceFieldRef>;
            /**
             * Selects a key of a secret in the pod's namespace
             */
            secretKeyRef?: pulumi.Input<inputs.app.v1alpha1.KogitoTrustySpecEnvsValueFromSecretKeyRef>;
        }

        /**
         * Selects a key of a ConfigMap.
         */
        export interface KogitoTrustySpecEnvsValueFromConfigMapKeyRef {
            /**
             * The key to select.
             */
            key: pulumi.Input<string>;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
             */
            name?: pulumi.Input<string>;
            /**
             * Specify whether the ConfigMap or its key must be defined
             */
            optional?: pulumi.Input<boolean>;
        }

        /**
         * Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
         */
        export interface KogitoTrustySpecEnvsValueFromFieldRef {
            /**
             * Version of the schema the FieldPath is written in terms of, defaults to "v1".
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * Path of the field to select in the specified API version.
             */
            fieldPath: pulumi.Input<string>;
        }

        /**
         * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
         */
        export interface KogitoTrustySpecEnvsValueFromResourceFieldRef {
            /**
             * Container name: required for volumes, optional for env vars
             */
            containerName?: pulumi.Input<string>;
            /**
             * Specifies the output format of the exposed resources, defaults to "1"
             */
            divisor?: pulumi.Input<inputs.app.v1alpha1.KogitoTrustySpecEnvsValueFromResourceFieldRefDivisor>;
            /**
             * Required: resource to select
             */
            resource: pulumi.Input<string>;
        }

        export interface KogitoTrustySpecEnvsValueFromResourceFieldRefDivisor {
        }

        /**
         * Selects a key of a secret in the pod's namespace
         */
        export interface KogitoTrustySpecEnvsValueFromSecretKeyRef {
            /**
             * The key of the secret to select from.  Must be a valid secret key.
             */
            key: pulumi.Input<string>;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
             */
            name?: pulumi.Input<string>;
            /**
             * Specify whether the Secret or its key must be defined
             */
            optional?: pulumi.Input<boolean>;
        }

        /**
         * Image definition for the service. Example: Domain: quay.io, Namespace: kiegroup, Name: kogito-service, Tag: latest. On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
         */
        export interface KogitoTrustySpecImage {
            domain?: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            namespace?: pulumi.Input<string>;
            tag?: pulumi.Input<string>;
        }

        /**
         * Has the data used by the service to connect to the Infinispan cluster.
         */
        export interface KogitoTrustySpecInfinispan {
            /**
             * Name of the Infinispan authentication realm. This sets the property infinispan.client.hotrod.auth_realm.
             */
            authRealm?: pulumi.Input<string>;
            /**
             * SecretCredentialsType is the data structure for specifying credentials within a Secret.
             */
            credentials?: pulumi.Input<inputs.app.v1alpha1.KogitoTrustySpecInfinispanCredentials>;
            /**
             * SaslMechanism defined for the authentication. This sets the property infinispan.client.hotrod.sasl_mechanism.
             */
            saslMechanism?: pulumi.Input<string>;
            /**
             * URI to connect to the Infinispan cluster (can it be an internal service or external URI), for example, myinfinispan-cluster:11222.
             */
            uri?: pulumi.Input<string>;
            /**
             * UseAuth is set to true if the credentials are set. This also sets the property infinispan.client.hotrod.use_auth.
             */
            useAuth?: pulumi.Input<boolean>;
            /**
             * UseKogitoInfra flags if the instance will use a provided infrastructure by KogitoInfra CR. Setting this to true will deploy a new KogitoInfra CR into the namespace that will install Infinispan via Infinispan Operator. Infinispan Operator MUST be installed in the namespace for this to work. On OpenShift, OLM should install it for you. If running on Kubernetes without OLM installed, please install Infinispan Operator first. Set this to false and fill all other properties to provide your own infrastructure.
             */
            useKogitoInfra?: pulumi.Input<boolean>;
        }

        /**
         * SecretCredentialsType is the data structure for specifying credentials within a Secret.
         */
        export interface KogitoTrustySpecInfinispanCredentials {
            /**
             * PasswordKey is the key pointing to a value in a Secret holding the password value.
             */
            passwordKey?: pulumi.Input<string>;
            /**
             * SecretName is the name of the secret where the credentials are set.
             */
            secretName?: pulumi.Input<string>;
            /**
             * UsernameKey is the key pointing to a value in a Secret holding the username value.
             */
            usernameKey?: pulumi.Input<string>;
        }

        /**
         * Has the data used by the service to connect to the Kafka cluster.
         */
        export interface KogitoTrustySpecKafka {
            /**
             * URI is the service URI to connect to the Kafka cluster, for example, my-cluster-kafka-bootstrap:9092.
             */
            externalURI?: pulumi.Input<string>;
            /**
             * Instance is the Kafka instance to be used, for example, kogito-kafka.
             */
            instance?: pulumi.Input<string>;
            /**
             * UseKogitoInfra flags if the instance will use a provided infrastructure by KogitoInfra CR. Setting this to true will configure a KogitoInfra CR to install Kafka via Strimzi Operator. Strimzi Operator MUST be installed in the namespace for this to work. On OpenShift, OLM should install it for you. If running on Kubernetes without OLM installed, please install Strimzi Operator first. Set this to false and fill other properties to provide your own infrastructure.
             */
            useKogitoInfra?: pulumi.Input<boolean>;
        }

        /**
         * Defined compute resource requirements for the deployed service.
         */
        export interface KogitoTrustySpecResources {
            /**
             * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
             */
            limits?: pulumi.Input<{[key: string]: pulumi.Input<inputs.app.v1alpha1.KogitoTrustySpecResourcesLimits>}>;
            /**
             * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
             */
            requests?: pulumi.Input<{[key: string]: pulumi.Input<inputs.app.v1alpha1.KogitoTrustySpecResourcesRequests>}>;
        }

        export interface KogitoTrustySpecResourcesLimits {
        }

        export interface KogitoTrustySpecResourcesRequests {
        }

        /**
         * KogitoTrustyStatus defines the observed state of KogitoTrusty.
         */
        export interface KogitoTrustyStatus {
            /**
             * History of conditions for the resource
             */
            conditions: pulumi.Input<pulumi.Input<inputs.app.v1alpha1.KogitoTrustyStatusConditions>[]>;
            /**
             * General conditions for the Kogito Service deployment.
             */
            deploymentConditions?: pulumi.Input<pulumi.Input<inputs.app.v1alpha1.KogitoTrustyStatusDeploymentConditions>[]>;
            /**
             * URI is where the service is exposed.
             */
            externalURI?: pulumi.Input<string>;
            /**
             * Image is the resolved image for this service.
             */
            image?: pulumi.Input<string>;
        }

        /**
         * Condition is the detailed condition for the resource
         */
        export interface KogitoTrustyStatusConditions {
            lastTransitionTime?: pulumi.Input<string>;
            message?: pulumi.Input<string>;
            /**
             * ReasonType is the type of reason
             */
            reason?: pulumi.Input<string>;
            status: pulumi.Input<string>;
            /**
             * ConditionType is the type of condition
             */
            type: pulumi.Input<string>;
        }

        /**
         * DeploymentCondition describes the state of a deployment at a certain point.
         */
        export interface KogitoTrustyStatusDeploymentConditions {
            /**
             * Last time the condition transitioned from one status to another.
             */
            lastTransitionTime?: pulumi.Input<string>;
            /**
             * The last time this condition was updated.
             */
            lastUpdateTime?: pulumi.Input<string>;
            /**
             * A human readable message indicating details about the transition.
             */
            message?: pulumi.Input<string>;
            /**
             * The reason for the condition's last transition.
             */
            reason?: pulumi.Input<string>;
            /**
             * Status of the condition, one of True, False, Unknown.
             */
            status: pulumi.Input<string>;
            /**
             * Type of deployment condition.
             */
            type: pulumi.Input<string>;
        }
    }
}
