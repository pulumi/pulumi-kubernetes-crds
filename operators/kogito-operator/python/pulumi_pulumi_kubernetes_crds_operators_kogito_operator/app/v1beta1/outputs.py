# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from ... import _utilities, _tables
from . import outputs

__all__ = [
    'KogitoBuildSpec',
    'KogitoBuildSpecArtifact',
    'KogitoBuildSpecEnv',
    'KogitoBuildSpecEnvValueFrom',
    'KogitoBuildSpecEnvValueFromConfigMapKeyRef',
    'KogitoBuildSpecEnvValueFromFieldRef',
    'KogitoBuildSpecEnvValueFromResourceFieldRef',
    'KogitoBuildSpecEnvValueFromResourceFieldRefDivisor',
    'KogitoBuildSpecEnvValueFromSecretKeyRef',
    'KogitoBuildSpecGitSource',
    'KogitoBuildSpecResources',
    'KogitoBuildSpecResourcesLimits',
    'KogitoBuildSpecResourcesRequests',
    'KogitoBuildSpecWebHooks',
    'KogitoBuildStatus',
    'KogitoBuildStatusBuilds',
    'KogitoBuildStatusConditions',
    'KogitoInfraSpec',
    'KogitoInfraSpecResource',
    'KogitoInfraStatus',
    'KogitoInfraStatusCondition',
    'KogitoInfraStatusEnv',
    'KogitoInfraStatusEnvValueFrom',
    'KogitoInfraStatusEnvValueFromConfigMapKeyRef',
    'KogitoInfraStatusEnvValueFromFieldRef',
    'KogitoInfraStatusEnvValueFromResourceFieldRef',
    'KogitoInfraStatusEnvValueFromResourceFieldRefDivisor',
    'KogitoInfraStatusEnvValueFromSecretKeyRef',
    'KogitoInfraStatusVolumes',
    'KogitoInfraStatusVolumesMount',
    'KogitoInfraStatusVolumesVolume',
    'KogitoInfraStatusVolumesVolumeConfigMap',
    'KogitoInfraStatusVolumesVolumeConfigMapItems',
    'KogitoInfraStatusVolumesVolumeSecret',
    'KogitoInfraStatusVolumesVolumeSecretItems',
    'KogitoRuntimeSpec',
    'KogitoRuntimeSpecEnv',
    'KogitoRuntimeSpecEnvValueFrom',
    'KogitoRuntimeSpecEnvValueFromConfigMapKeyRef',
    'KogitoRuntimeSpecEnvValueFromFieldRef',
    'KogitoRuntimeSpecEnvValueFromResourceFieldRef',
    'KogitoRuntimeSpecEnvValueFromResourceFieldRefDivisor',
    'KogitoRuntimeSpecEnvValueFromSecretKeyRef',
    'KogitoRuntimeSpecMonitoring',
    'KogitoRuntimeSpecResources',
    'KogitoRuntimeSpecResourcesLimits',
    'KogitoRuntimeSpecResourcesRequests',
    'KogitoRuntimeStatus',
    'KogitoRuntimeStatusCloudEvents',
    'KogitoRuntimeStatusCloudEventsConsumes',
    'KogitoRuntimeStatusCloudEventsProduces',
    'KogitoRuntimeStatusConditions',
    'KogitoRuntimeStatusDeploymentConditions',
    'KogitoSupportingServiceSpec',
    'KogitoSupportingServiceSpecEnv',
    'KogitoSupportingServiceSpecEnvValueFrom',
    'KogitoSupportingServiceSpecEnvValueFromConfigMapKeyRef',
    'KogitoSupportingServiceSpecEnvValueFromFieldRef',
    'KogitoSupportingServiceSpecEnvValueFromResourceFieldRef',
    'KogitoSupportingServiceSpecEnvValueFromResourceFieldRefDivisor',
    'KogitoSupportingServiceSpecEnvValueFromSecretKeyRef',
    'KogitoSupportingServiceSpecMonitoring',
    'KogitoSupportingServiceSpecResources',
    'KogitoSupportingServiceSpecResourcesLimits',
    'KogitoSupportingServiceSpecResourcesRequests',
    'KogitoSupportingServiceStatus',
    'KogitoSupportingServiceStatusCloudEvents',
    'KogitoSupportingServiceStatusCloudEventsConsumes',
    'KogitoSupportingServiceStatusCloudEventsProduces',
    'KogitoSupportingServiceStatusConditions',
    'KogitoSupportingServiceStatusDeploymentConditions',
]

@pulumi.output_type
class KogitoBuildSpec(dict):
    """
    KogitoBuildSpec defines the desired state of KogitoBuild.
    """
    def __init__(__self__, *,
                 type: str,
                 artifact: Optional['outputs.KogitoBuildSpecArtifact'] = None,
                 build_image: Optional[str] = None,
                 disable_incremental: Optional[bool] = None,
                 enable_maven_download_output: Optional[bool] = None,
                 env: Optional[Sequence['outputs.KogitoBuildSpecEnv']] = None,
                 git_source: Optional['outputs.KogitoBuildSpecGitSource'] = None,
                 maven_mirror_url: Optional[str] = None,
                 native: Optional[bool] = None,
                 resources: Optional['outputs.KogitoBuildSpecResources'] = None,
                 runtime: Optional[str] = None,
                 runtime_image: Optional[str] = None,
                 target_kogito_runtime: Optional[str] = None,
                 web_hooks: Optional[Sequence['outputs.KogitoBuildSpecWebHooks']] = None):
        """
        KogitoBuildSpec defines the desired state of KogitoBuild.
        :param str type: Sets the type of build that this instance will handle: Binary - takes an uploaded binary file already compiled and creates a Kogito service image from it. RemoteSource - pulls the source code from a Git repository, builds the binary and then the final Kogito service image. LocalSource - takes an uploaded resource file such as DRL (rules), DMN (decision) or BPMN (process), builds the binary and the final Kogito service image.
        :param 'KogitoBuildSpecArtifactArgs' artifact: Artifact contains override information for building the Maven artifact (used for Local Source builds). You might want to override this information when building from decisions, rules or process files. In this scenario the Kogito Images will generate a new Java project for you underneath. This information will be used to generate this project.
        :param str build_image: Image used to build the Kogito Service from source (Local and Remote). The operator will use the one provided by the Kogito Team based on the "Runtime" field. Example: "quay.io/kiegroup/kogito-jvm-builder:latest". On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
        :param bool disable_incremental: DisableIncremental indicates that source to image builds should NOT be incremental. Defaults to false.
        :param bool enable_maven_download_output: If set to true will print the logs for downloading/uploading of maven dependencies. Defaults to false.
        :param Sequence['KogitoBuildSpecEnvArgs'] env: Environment variables used during build time.
        :param 'KogitoBuildSpecGitSourceArgs' git_source: Information about the git repository where the Kogito Service source code resides. Ignored for binary builds.
        :param str maven_mirror_url: Maven Mirror URL to be used during source-to-image builds (Local and Remote) to considerably increase build speed.
        :param bool native: Native indicates if the Kogito Service built should be compiled to run on native mode when Runtime is Quarkus (Source to Image build only). For more information, see https://www.graalvm.org/docs/reference-manual/aot-compilation/.
        :param 'KogitoBuildSpecResourcesArgs' resources: Resources Requirements for builder pods.
        :param str runtime: Which runtime Kogito service base image to use when building the Kogito service. If "BuildImage" is set, this value is ignored by the operator. Default value: quarkus.
        :param str runtime_image: Image used as the base image for the final Kogito service. This image only has the required packages to run the application. For example: quarkus based services will have only JVM installed, native services only the packages required by the OS. The operator will use the one provided by the Kogito Team based on the "Runtime" field. Example: "quay.io/kiegroup/kogito-jvm-builder:latest". On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
        :param str target_kogito_runtime: Set this field targeting the desired KogitoRuntime when this KogitoBuild instance has a different name than the KogitoRuntime. By default this KogitoBuild instance will generate a final image named after its own name (.metadata.name). On OpenShift, an ImageStream will be created causing a redeployment on any KogitoRuntime with the same name. On Kubernetes, the final image will be pushed to the KogitoRuntime deployment. If you have multiple KogitoBuild instances (let's say BinaryBuildType and Remote Source), you might need that both target the same KogitoRuntime. Both KogitoBuilds will update the same ImageStream or generate a final image to the same KogitoRuntime deployment.
        :param Sequence['KogitoBuildSpecWebHooksArgs'] web_hooks: WebHooks secrets for source to image builds based on Git repositories (Remote Sources).
        """
        pulumi.set(__self__, "type", type)
        if artifact is not None:
            pulumi.set(__self__, "artifact", artifact)
        if build_image is not None:
            pulumi.set(__self__, "build_image", build_image)
        if disable_incremental is not None:
            pulumi.set(__self__, "disable_incremental", disable_incremental)
        if enable_maven_download_output is not None:
            pulumi.set(__self__, "enable_maven_download_output", enable_maven_download_output)
        if env is not None:
            pulumi.set(__self__, "env", env)
        if git_source is not None:
            pulumi.set(__self__, "git_source", git_source)
        if maven_mirror_url is not None:
            pulumi.set(__self__, "maven_mirror_url", maven_mirror_url)
        if native is not None:
            pulumi.set(__self__, "native", native)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if runtime is not None:
            pulumi.set(__self__, "runtime", runtime)
        if runtime_image is not None:
            pulumi.set(__self__, "runtime_image", runtime_image)
        if target_kogito_runtime is not None:
            pulumi.set(__self__, "target_kogito_runtime", target_kogito_runtime)
        if web_hooks is not None:
            pulumi.set(__self__, "web_hooks", web_hooks)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Sets the type of build that this instance will handle: Binary - takes an uploaded binary file already compiled and creates a Kogito service image from it. RemoteSource - pulls the source code from a Git repository, builds the binary and then the final Kogito service image. LocalSource - takes an uploaded resource file such as DRL (rules), DMN (decision) or BPMN (process), builds the binary and the final Kogito service image.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def artifact(self) -> Optional['outputs.KogitoBuildSpecArtifact']:
        """
        Artifact contains override information for building the Maven artifact (used for Local Source builds). You might want to override this information when building from decisions, rules or process files. In this scenario the Kogito Images will generate a new Java project for you underneath. This information will be used to generate this project.
        """
        return pulumi.get(self, "artifact")

    @property
    @pulumi.getter(name="buildImage")
    def build_image(self) -> Optional[str]:
        """
        Image used to build the Kogito Service from source (Local and Remote). The operator will use the one provided by the Kogito Team based on the "Runtime" field. Example: "quay.io/kiegroup/kogito-jvm-builder:latest". On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
        """
        return pulumi.get(self, "build_image")

    @property
    @pulumi.getter(name="disableIncremental")
    def disable_incremental(self) -> Optional[bool]:
        """
        DisableIncremental indicates that source to image builds should NOT be incremental. Defaults to false.
        """
        return pulumi.get(self, "disable_incremental")

    @property
    @pulumi.getter(name="enableMavenDownloadOutput")
    def enable_maven_download_output(self) -> Optional[bool]:
        """
        If set to true will print the logs for downloading/uploading of maven dependencies. Defaults to false.
        """
        return pulumi.get(self, "enable_maven_download_output")

    @property
    @pulumi.getter
    def env(self) -> Optional[Sequence['outputs.KogitoBuildSpecEnv']]:
        """
        Environment variables used during build time.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter(name="gitSource")
    def git_source(self) -> Optional['outputs.KogitoBuildSpecGitSource']:
        """
        Information about the git repository where the Kogito Service source code resides. Ignored for binary builds.
        """
        return pulumi.get(self, "git_source")

    @property
    @pulumi.getter(name="mavenMirrorURL")
    def maven_mirror_url(self) -> Optional[str]:
        """
        Maven Mirror URL to be used during source-to-image builds (Local and Remote) to considerably increase build speed.
        """
        return pulumi.get(self, "maven_mirror_url")

    @property
    @pulumi.getter
    def native(self) -> Optional[bool]:
        """
        Native indicates if the Kogito Service built should be compiled to run on native mode when Runtime is Quarkus (Source to Image build only). For more information, see https://www.graalvm.org/docs/reference-manual/aot-compilation/.
        """
        return pulumi.get(self, "native")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.KogitoBuildSpecResources']:
        """
        Resources Requirements for builder pods.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter
    def runtime(self) -> Optional[str]:
        """
        Which runtime Kogito service base image to use when building the Kogito service. If "BuildImage" is set, this value is ignored by the operator. Default value: quarkus.
        """
        return pulumi.get(self, "runtime")

    @property
    @pulumi.getter(name="runtimeImage")
    def runtime_image(self) -> Optional[str]:
        """
        Image used as the base image for the final Kogito service. This image only has the required packages to run the application. For example: quarkus based services will have only JVM installed, native services only the packages required by the OS. The operator will use the one provided by the Kogito Team based on the "Runtime" field. Example: "quay.io/kiegroup/kogito-jvm-builder:latest". On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
        """
        return pulumi.get(self, "runtime_image")

    @property
    @pulumi.getter(name="targetKogitoRuntime")
    def target_kogito_runtime(self) -> Optional[str]:
        """
        Set this field targeting the desired KogitoRuntime when this KogitoBuild instance has a different name than the KogitoRuntime. By default this KogitoBuild instance will generate a final image named after its own name (.metadata.name). On OpenShift, an ImageStream will be created causing a redeployment on any KogitoRuntime with the same name. On Kubernetes, the final image will be pushed to the KogitoRuntime deployment. If you have multiple KogitoBuild instances (let's say BinaryBuildType and Remote Source), you might need that both target the same KogitoRuntime. Both KogitoBuilds will update the same ImageStream or generate a final image to the same KogitoRuntime deployment.
        """
        return pulumi.get(self, "target_kogito_runtime")

    @property
    @pulumi.getter(name="webHooks")
    def web_hooks(self) -> Optional[Sequence['outputs.KogitoBuildSpecWebHooks']]:
        """
        WebHooks secrets for source to image builds based on Git repositories (Remote Sources).
        """
        return pulumi.get(self, "web_hooks")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoBuildSpecArtifact(dict):
    """
    Artifact contains override information for building the Maven artifact (used for Local Source builds). You might want to override this information when building from decisions, rules or process files. In this scenario the Kogito Images will generate a new Java project for you underneath. This information will be used to generate this project.
    """
    def __init__(__self__, *,
                 artifact_id: Optional[str] = None,
                 group_id: Optional[str] = None,
                 version: Optional[str] = None):
        """
        Artifact contains override information for building the Maven artifact (used for Local Source builds). You might want to override this information when building from decisions, rules or process files. In this scenario the Kogito Images will generate a new Java project for you underneath. This information will be used to generate this project.
        :param str artifact_id: Indicates the unique base name of the primary artifact being generated.
        :param str group_id: Indicates the unique identifier of the organization or group that created the project.
        :param str version: Indicates the version of the artifact generated by the project.
        """
        if artifact_id is not None:
            pulumi.set(__self__, "artifact_id", artifact_id)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="artifactId")
    def artifact_id(self) -> Optional[str]:
        """
        Indicates the unique base name of the primary artifact being generated.
        """
        return pulumi.get(self, "artifact_id")

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[str]:
        """
        Indicates the unique identifier of the organization or group that created the project.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Indicates the version of the artifact generated by the project.
        """
        return pulumi.get(self, "version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoBuildSpecEnv(dict):
    """
    EnvVar represents an environment variable present in a Container.
    """
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None,
                 value_from: Optional['outputs.KogitoBuildSpecEnvValueFrom'] = None):
        """
        EnvVar represents an environment variable present in a Container.
        :param str name: Name of the environment variable. Must be a C_IDENTIFIER.
        :param str value: Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        :param 'KogitoBuildSpecEnvValueFromArgs' value_from: Source for the environment variable's value. Cannot be used if value is not empty.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_from is not None:
            pulumi.set(__self__, "value_from", value_from)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the environment variable. Must be a C_IDENTIFIER.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueFrom")
    def value_from(self) -> Optional['outputs.KogitoBuildSpecEnvValueFrom']:
        """
        Source for the environment variable's value. Cannot be used if value is not empty.
        """
        return pulumi.get(self, "value_from")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoBuildSpecEnvValueFrom(dict):
    """
    Source for the environment variable's value. Cannot be used if value is not empty.
    """
    def __init__(__self__, *,
                 config_map_key_ref: Optional['outputs.KogitoBuildSpecEnvValueFromConfigMapKeyRef'] = None,
                 field_ref: Optional['outputs.KogitoBuildSpecEnvValueFromFieldRef'] = None,
                 resource_field_ref: Optional['outputs.KogitoBuildSpecEnvValueFromResourceFieldRef'] = None,
                 secret_key_ref: Optional['outputs.KogitoBuildSpecEnvValueFromSecretKeyRef'] = None):
        """
        Source for the environment variable's value. Cannot be used if value is not empty.
        :param 'KogitoBuildSpecEnvValueFromConfigMapKeyRefArgs' config_map_key_ref: Selects a key of a ConfigMap.
        :param 'KogitoBuildSpecEnvValueFromFieldRefArgs' field_ref: Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        :param 'KogitoBuildSpecEnvValueFromResourceFieldRefArgs' resource_field_ref: Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        :param 'KogitoBuildSpecEnvValueFromSecretKeyRefArgs' secret_key_ref: Selects a key of a secret in the pod's namespace
        """
        if config_map_key_ref is not None:
            pulumi.set(__self__, "config_map_key_ref", config_map_key_ref)
        if field_ref is not None:
            pulumi.set(__self__, "field_ref", field_ref)
        if resource_field_ref is not None:
            pulumi.set(__self__, "resource_field_ref", resource_field_ref)
        if secret_key_ref is not None:
            pulumi.set(__self__, "secret_key_ref", secret_key_ref)

    @property
    @pulumi.getter(name="configMapKeyRef")
    def config_map_key_ref(self) -> Optional['outputs.KogitoBuildSpecEnvValueFromConfigMapKeyRef']:
        """
        Selects a key of a ConfigMap.
        """
        return pulumi.get(self, "config_map_key_ref")

    @property
    @pulumi.getter(name="fieldRef")
    def field_ref(self) -> Optional['outputs.KogitoBuildSpecEnvValueFromFieldRef']:
        """
        Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        """
        return pulumi.get(self, "field_ref")

    @property
    @pulumi.getter(name="resourceFieldRef")
    def resource_field_ref(self) -> Optional['outputs.KogitoBuildSpecEnvValueFromResourceFieldRef']:
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        """
        return pulumi.get(self, "resource_field_ref")

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> Optional['outputs.KogitoBuildSpecEnvValueFromSecretKeyRef']:
        """
        Selects a key of a secret in the pod's namespace
        """
        return pulumi.get(self, "secret_key_ref")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoBuildSpecEnvValueFromConfigMapKeyRef(dict):
    """
    Selects a key of a ConfigMap.
    """
    def __init__(__self__, *,
                 key: str,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        Selects a key of a ConfigMap.
        :param str key: The key to select.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        :param bool optional: Specify whether the ConfigMap or its key must be defined
        """
        pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key to select.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the ConfigMap or its key must be defined
        """
        return pulumi.get(self, "optional")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoBuildSpecEnvValueFromFieldRef(dict):
    """
    Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    """
    def __init__(__self__, *,
                 field_path: str,
                 api_version: Optional[str] = None):
        """
        Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        :param str field_path: Path of the field to select in the specified API version.
        :param str api_version: Version of the schema the FieldPath is written in terms of, defaults to "v1".
        """
        pulumi.set(__self__, "field_path", field_path)
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> str:
        """
        Path of the field to select in the specified API version.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        Version of the schema the FieldPath is written in terms of, defaults to "v1".
        """
        return pulumi.get(self, "api_version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoBuildSpecEnvValueFromResourceFieldRef(dict):
    """
    Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    """
    def __init__(__self__, *,
                 resource: str,
                 container_name: Optional[str] = None,
                 divisor: Optional['outputs.KogitoBuildSpecEnvValueFromResourceFieldRefDivisor'] = None):
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        :param str resource: Required: resource to select
        :param str container_name: Container name: required for volumes, optional for env vars
        :param 'KogitoBuildSpecEnvValueFromResourceFieldRefDivisorArgs' divisor: Specifies the output format of the exposed resources, defaults to "1"
        """
        pulumi.set(__self__, "resource", resource)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if divisor is not None:
            pulumi.set(__self__, "divisor", divisor)

    @property
    @pulumi.getter
    def resource(self) -> str:
        """
        Required: resource to select
        """
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[str]:
        """
        Container name: required for volumes, optional for env vars
        """
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def divisor(self) -> Optional['outputs.KogitoBuildSpecEnvValueFromResourceFieldRefDivisor']:
        """
        Specifies the output format of the exposed resources, defaults to "1"
        """
        return pulumi.get(self, "divisor")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoBuildSpecEnvValueFromResourceFieldRefDivisor(dict):
    def __init__(__self__):
        pass

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoBuildSpecEnvValueFromSecretKeyRef(dict):
    """
    Selects a key of a secret in the pod's namespace
    """
    def __init__(__self__, *,
                 key: str,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        Selects a key of a secret in the pod's namespace
        :param str key: The key of the secret to select from.  Must be a valid secret key.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        :param bool optional: Specify whether the Secret or its key must be defined
        """
        pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the secret to select from.  Must be a valid secret key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the Secret or its key must be defined
        """
        return pulumi.get(self, "optional")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoBuildSpecGitSource(dict):
    """
    Information about the git repository where the Kogito Service source code resides. Ignored for binary builds.
    """
    def __init__(__self__, *,
                 uri: str,
                 context_dir: Optional[str] = None,
                 reference: Optional[str] = None):
        """
        Information about the git repository where the Kogito Service source code resides. Ignored for binary builds.
        :param str uri: Git URI for the s2i source.
        :param str context_dir: Context/subdirectory where the code is located, relative to the repo root.
        :param str reference: Branch to use in the Git repository.
        """
        pulumi.set(__self__, "uri", uri)
        if context_dir is not None:
            pulumi.set(__self__, "context_dir", context_dir)
        if reference is not None:
            pulumi.set(__self__, "reference", reference)

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        Git URI for the s2i source.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter(name="contextDir")
    def context_dir(self) -> Optional[str]:
        """
        Context/subdirectory where the code is located, relative to the repo root.
        """
        return pulumi.get(self, "context_dir")

    @property
    @pulumi.getter
    def reference(self) -> Optional[str]:
        """
        Branch to use in the Git repository.
        """
        return pulumi.get(self, "reference")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoBuildSpecResources(dict):
    """
    Resources Requirements for builder pods.
    """
    def __init__(__self__, *,
                 limits: Optional[Mapping[str, 'outputs.KogitoBuildSpecResourcesLimits']] = None,
                 requests: Optional[Mapping[str, 'outputs.KogitoBuildSpecResourcesRequests']] = None):
        """
        Resources Requirements for builder pods.
        :param Mapping[str, 'KogitoBuildSpecResourcesLimitsArgs'] limits: Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        :param Mapping[str, 'KogitoBuildSpecResourcesRequestsArgs'] requests: Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, 'outputs.KogitoBuildSpecResourcesLimits']]:
        """
        Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Mapping[str, 'outputs.KogitoBuildSpecResourcesRequests']]:
        """
        Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "requests")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoBuildSpecResourcesLimits(dict):
    def __init__(__self__):
        pass

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoBuildSpecResourcesRequests(dict):
    def __init__(__self__):
        pass

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoBuildSpecWebHooks(dict):
    """
    WebHookSecret Secret to use for a given webHook.
    """
    def __init__(__self__, *,
                 secret: Optional[str] = None,
                 type: Optional[str] = None):
        """
        WebHookSecret Secret to use for a given webHook.
        :param str secret: Secret value for webHook
        :param str type: WebHook type, either GitHub or Generic.
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def secret(self) -> Optional[str]:
        """
        Secret value for webHook
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        WebHook type, either GitHub or Generic.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoBuildStatus(dict):
    """
    KogitoBuildStatus defines the observed state of KogitoBuild.
    """
    def __init__(__self__, *,
                 builds: 'outputs.KogitoBuildStatusBuilds',
                 conditions: Sequence['outputs.KogitoBuildStatusConditions'],
                 latest_build: Optional[str] = None):
        """
        KogitoBuildStatus defines the observed state of KogitoBuild.
        :param 'KogitoBuildStatusBuildsArgs' builds: History of builds
        :param Sequence['KogitoBuildStatusConditionsArgs'] conditions: History of conditions for the resource, shows the status of the younger builder controlled by this instance
        """
        pulumi.set(__self__, "builds", builds)
        pulumi.set(__self__, "conditions", conditions)
        if latest_build is not None:
            pulumi.set(__self__, "latest_build", latest_build)

    @property
    @pulumi.getter
    def builds(self) -> 'outputs.KogitoBuildStatusBuilds':
        """
        History of builds
        """
        return pulumi.get(self, "builds")

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.KogitoBuildStatusConditions']:
        """
        History of conditions for the resource, shows the status of the younger builder controlled by this instance
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="latestBuild")
    def latest_build(self) -> Optional[str]:
        return pulumi.get(self, "latest_build")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoBuildStatusBuilds(dict):
    """
    History of builds
    """
    def __init__(__self__, *,
                 cancelled: Optional[Sequence[str]] = None,
                 complete: Optional[Sequence[str]] = None,
                 error: Optional[Sequence[str]] = None,
                 failed: Optional[Sequence[str]] = None,
                 new: Optional[Sequence[str]] = None,
                 pending: Optional[Sequence[str]] = None,
                 running: Optional[Sequence[str]] = None):
        """
        History of builds
        :param Sequence[str] cancelled: Builds have been stopped from executing.
        :param Sequence[str] complete: Builds have executed and succeeded.
        :param Sequence[str] error: Builds have been prevented from executing by an error.
        :param Sequence[str] failed: Builds have executed and failed.
        :param Sequence[str] new: Builds are being created.
        :param Sequence[str] pending: Builds are about to start running.
        :param Sequence[str] running: Builds are running.
        """
        if cancelled is not None:
            pulumi.set(__self__, "cancelled", cancelled)
        if complete is not None:
            pulumi.set(__self__, "complete", complete)
        if error is not None:
            pulumi.set(__self__, "error", error)
        if failed is not None:
            pulumi.set(__self__, "failed", failed)
        if new is not None:
            pulumi.set(__self__, "new", new)
        if pending is not None:
            pulumi.set(__self__, "pending", pending)
        if running is not None:
            pulumi.set(__self__, "running", running)

    @property
    @pulumi.getter
    def cancelled(self) -> Optional[Sequence[str]]:
        """
        Builds have been stopped from executing.
        """
        return pulumi.get(self, "cancelled")

    @property
    @pulumi.getter
    def complete(self) -> Optional[Sequence[str]]:
        """
        Builds have executed and succeeded.
        """
        return pulumi.get(self, "complete")

    @property
    @pulumi.getter
    def error(self) -> Optional[Sequence[str]]:
        """
        Builds have been prevented from executing by an error.
        """
        return pulumi.get(self, "error")

    @property
    @pulumi.getter
    def failed(self) -> Optional[Sequence[str]]:
        """
        Builds have executed and failed.
        """
        return pulumi.get(self, "failed")

    @property
    @pulumi.getter
    def new(self) -> Optional[Sequence[str]]:
        """
        Builds are being created.
        """
        return pulumi.get(self, "new")

    @property
    @pulumi.getter
    def pending(self) -> Optional[Sequence[str]]:
        """
        Builds are about to start running.
        """
        return pulumi.get(self, "pending")

    @property
    @pulumi.getter
    def running(self) -> Optional[Sequence[str]]:
        """
        Builds are running.
        """
        return pulumi.get(self, "running")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoBuildStatusConditions(dict):
    """
    KogitoBuildConditions describes the conditions for this build instance according to Kubernetes status interface.
    """
    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None):
        """
        KogitoBuildConditions describes the conditions for this build instance according to Kubernetes status interface.
        :param str status: Status ...
        :param str type: Type of this condition
        :param str last_transition_time: LastTransitionTime ...
        :param str message: Message ...
        :param str reason: Reason of this condition
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status ...
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of this condition
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        LastTransitionTime ...
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Message ...
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        Reason of this condition
        """
        return pulumi.get(self, "reason")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoInfraSpec(dict):
    """
    KogitoInfraSpec defines the desired state of KogitoInfra.
    """
    def __init__(__self__, *,
                 resource: Optional['outputs.KogitoInfraSpecResource'] = None):
        """
        KogitoInfraSpec defines the desired state of KogitoInfra.
        :param 'KogitoInfraSpecResourceArgs' resource: Resource for the service. Example: Infinispan/Kafka/Keycloak.
        """
        if resource is not None:
            pulumi.set(__self__, "resource", resource)

    @property
    @pulumi.getter
    def resource(self) -> Optional['outputs.KogitoInfraSpecResource']:
        """
        Resource for the service. Example: Infinispan/Kafka/Keycloak.
        """
        return pulumi.get(self, "resource")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoInfraSpecResource(dict):
    """
    Resource for the service. Example: Infinispan/Kafka/Keycloak.
    """
    def __init__(__self__, *,
                 api_version: str,
                 kind: str,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None):
        """
        Resource for the service. Example: Infinispan/Kafka/Keycloak.
        :param str api_version: APIVersion describes the API Version of referred Kubernetes resource for example, infinispan.org/v1
        :param str kind: Kind describes the kind of referred Kubernetes resource for example, Infinispan
        :param str name: Name of referred resource.
        :param str namespace: Namespace where referred resource exists.
        """
        pulumi.set(__self__, "api_version", api_version)
        pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> str:
        """
        APIVersion describes the API Version of referred Kubernetes resource for example, infinispan.org/v1
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        Kind describes the kind of referred Kubernetes resource for example, Infinispan
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of referred resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace where referred resource exists.
        """
        return pulumi.get(self, "namespace")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoInfraStatus(dict):
    """
    KogitoInfraStatus defines the observed state of KogitoInfra.
    """
    def __init__(__self__, *,
                 app_props: Optional[Mapping[str, str]] = None,
                 condition: Optional['outputs.KogitoInfraStatusCondition'] = None,
                 env: Optional[Sequence['outputs.KogitoInfraStatusEnv']] = None,
                 volumes: Optional[Sequence['outputs.KogitoInfraStatusVolumes']] = None):
        """
        KogitoInfraStatus defines the observed state of KogitoInfra.
        :param Mapping[str, str] app_props: Application properties extracted from the linked resource that will be added to the deployed Kogito service.
        :param 'KogitoInfraStatusConditionArgs' condition: KogitoInfraCondition ...
        :param Sequence['KogitoInfraStatusEnvArgs'] env: Environment variables extracted from the linked resource that will be added to the deployed Kogito service.
        :param Sequence['KogitoInfraStatusVolumesArgs'] volumes: List of volumes that should be added to the services bound to this infra instance
        """
        if app_props is not None:
            pulumi.set(__self__, "app_props", app_props)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if env is not None:
            pulumi.set(__self__, "env", env)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @property
    @pulumi.getter(name="appProps")
    def app_props(self) -> Optional[Mapping[str, str]]:
        """
        Application properties extracted from the linked resource that will be added to the deployed Kogito service.
        """
        return pulumi.get(self, "app_props")

    @property
    @pulumi.getter
    def condition(self) -> Optional['outputs.KogitoInfraStatusCondition']:
        """
        KogitoInfraCondition ...
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def env(self) -> Optional[Sequence['outputs.KogitoInfraStatusEnv']]:
        """
        Environment variables extracted from the linked resource that will be added to the deployed Kogito service.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def volumes(self) -> Optional[Sequence['outputs.KogitoInfraStatusVolumes']]:
        """
        List of volumes that should be added to the services bound to this infra instance
        """
        return pulumi.get(self, "volumes")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoInfraStatusCondition(dict):
    """
    KogitoInfraCondition ...
    """
    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None):
        """
        KogitoInfraCondition ...
        :param str status: Status ...
        :param str type: Type ...
        :param str last_transition_time: LastTransitionTime ...
        :param str message: Message ...
        :param str reason: Reason ...
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status ...
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type ...
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        LastTransitionTime ...
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Message ...
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        Reason ...
        """
        return pulumi.get(self, "reason")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoInfraStatusEnv(dict):
    """
    EnvVar represents an environment variable present in a Container.
    """
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None,
                 value_from: Optional['outputs.KogitoInfraStatusEnvValueFrom'] = None):
        """
        EnvVar represents an environment variable present in a Container.
        :param str name: Name of the environment variable. Must be a C_IDENTIFIER.
        :param str value: Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        :param 'KogitoInfraStatusEnvValueFromArgs' value_from: Source for the environment variable's value. Cannot be used if value is not empty.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_from is not None:
            pulumi.set(__self__, "value_from", value_from)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the environment variable. Must be a C_IDENTIFIER.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueFrom")
    def value_from(self) -> Optional['outputs.KogitoInfraStatusEnvValueFrom']:
        """
        Source for the environment variable's value. Cannot be used if value is not empty.
        """
        return pulumi.get(self, "value_from")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoInfraStatusEnvValueFrom(dict):
    """
    Source for the environment variable's value. Cannot be used if value is not empty.
    """
    def __init__(__self__, *,
                 config_map_key_ref: Optional['outputs.KogitoInfraStatusEnvValueFromConfigMapKeyRef'] = None,
                 field_ref: Optional['outputs.KogitoInfraStatusEnvValueFromFieldRef'] = None,
                 resource_field_ref: Optional['outputs.KogitoInfraStatusEnvValueFromResourceFieldRef'] = None,
                 secret_key_ref: Optional['outputs.KogitoInfraStatusEnvValueFromSecretKeyRef'] = None):
        """
        Source for the environment variable's value. Cannot be used if value is not empty.
        :param 'KogitoInfraStatusEnvValueFromConfigMapKeyRefArgs' config_map_key_ref: Selects a key of a ConfigMap.
        :param 'KogitoInfraStatusEnvValueFromFieldRefArgs' field_ref: Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        :param 'KogitoInfraStatusEnvValueFromResourceFieldRefArgs' resource_field_ref: Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        :param 'KogitoInfraStatusEnvValueFromSecretKeyRefArgs' secret_key_ref: Selects a key of a secret in the pod's namespace
        """
        if config_map_key_ref is not None:
            pulumi.set(__self__, "config_map_key_ref", config_map_key_ref)
        if field_ref is not None:
            pulumi.set(__self__, "field_ref", field_ref)
        if resource_field_ref is not None:
            pulumi.set(__self__, "resource_field_ref", resource_field_ref)
        if secret_key_ref is not None:
            pulumi.set(__self__, "secret_key_ref", secret_key_ref)

    @property
    @pulumi.getter(name="configMapKeyRef")
    def config_map_key_ref(self) -> Optional['outputs.KogitoInfraStatusEnvValueFromConfigMapKeyRef']:
        """
        Selects a key of a ConfigMap.
        """
        return pulumi.get(self, "config_map_key_ref")

    @property
    @pulumi.getter(name="fieldRef")
    def field_ref(self) -> Optional['outputs.KogitoInfraStatusEnvValueFromFieldRef']:
        """
        Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        """
        return pulumi.get(self, "field_ref")

    @property
    @pulumi.getter(name="resourceFieldRef")
    def resource_field_ref(self) -> Optional['outputs.KogitoInfraStatusEnvValueFromResourceFieldRef']:
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        """
        return pulumi.get(self, "resource_field_ref")

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> Optional['outputs.KogitoInfraStatusEnvValueFromSecretKeyRef']:
        """
        Selects a key of a secret in the pod's namespace
        """
        return pulumi.get(self, "secret_key_ref")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoInfraStatusEnvValueFromConfigMapKeyRef(dict):
    """
    Selects a key of a ConfigMap.
    """
    def __init__(__self__, *,
                 key: str,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        Selects a key of a ConfigMap.
        :param str key: The key to select.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        :param bool optional: Specify whether the ConfigMap or its key must be defined
        """
        pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key to select.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the ConfigMap or its key must be defined
        """
        return pulumi.get(self, "optional")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoInfraStatusEnvValueFromFieldRef(dict):
    """
    Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    """
    def __init__(__self__, *,
                 field_path: str,
                 api_version: Optional[str] = None):
        """
        Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        :param str field_path: Path of the field to select in the specified API version.
        :param str api_version: Version of the schema the FieldPath is written in terms of, defaults to "v1".
        """
        pulumi.set(__self__, "field_path", field_path)
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> str:
        """
        Path of the field to select in the specified API version.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        Version of the schema the FieldPath is written in terms of, defaults to "v1".
        """
        return pulumi.get(self, "api_version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoInfraStatusEnvValueFromResourceFieldRef(dict):
    """
    Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    """
    def __init__(__self__, *,
                 resource: str,
                 container_name: Optional[str] = None,
                 divisor: Optional['outputs.KogitoInfraStatusEnvValueFromResourceFieldRefDivisor'] = None):
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        :param str resource: Required: resource to select
        :param str container_name: Container name: required for volumes, optional for env vars
        :param 'KogitoInfraStatusEnvValueFromResourceFieldRefDivisorArgs' divisor: Specifies the output format of the exposed resources, defaults to "1"
        """
        pulumi.set(__self__, "resource", resource)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if divisor is not None:
            pulumi.set(__self__, "divisor", divisor)

    @property
    @pulumi.getter
    def resource(self) -> str:
        """
        Required: resource to select
        """
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[str]:
        """
        Container name: required for volumes, optional for env vars
        """
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def divisor(self) -> Optional['outputs.KogitoInfraStatusEnvValueFromResourceFieldRefDivisor']:
        """
        Specifies the output format of the exposed resources, defaults to "1"
        """
        return pulumi.get(self, "divisor")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoInfraStatusEnvValueFromResourceFieldRefDivisor(dict):
    def __init__(__self__):
        pass

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoInfraStatusEnvValueFromSecretKeyRef(dict):
    """
    Selects a key of a secret in the pod's namespace
    """
    def __init__(__self__, *,
                 key: str,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        Selects a key of a secret in the pod's namespace
        :param str key: The key of the secret to select from.  Must be a valid secret key.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        :param bool optional: Specify whether the Secret or its key must be defined
        """
        pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the secret to select from.  Must be a valid secret key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the Secret or its key must be defined
        """
        return pulumi.get(self, "optional")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoInfraStatusVolumes(dict):
    """
    KogitoInfraVolume describes the data structure for volumes that should be mounted in the given service provided by this infra instance
    """
    def __init__(__self__, *,
                 mount: 'outputs.KogitoInfraStatusVolumesMount',
                 volume: 'outputs.KogitoInfraStatusVolumesVolume'):
        """
        KogitoInfraVolume describes the data structure for volumes that should be mounted in the given service provided by this infra instance
        :param 'KogitoInfraStatusVolumesMountArgs' mount: Mount is the Kubernetes VolumeMount referenced by this instance
        :param 'KogitoInfraStatusVolumesVolumeArgs' volume: NamedVolume describes the pod Volume reference
        """
        pulumi.set(__self__, "mount", mount)
        pulumi.set(__self__, "volume", volume)

    @property
    @pulumi.getter
    def mount(self) -> 'outputs.KogitoInfraStatusVolumesMount':
        """
        Mount is the Kubernetes VolumeMount referenced by this instance
        """
        return pulumi.get(self, "mount")

    @property
    @pulumi.getter
    def volume(self) -> 'outputs.KogitoInfraStatusVolumesVolume':
        """
        NamedVolume describes the pod Volume reference
        """
        return pulumi.get(self, "volume")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoInfraStatusVolumesMount(dict):
    """
    Mount is the Kubernetes VolumeMount referenced by this instance
    """
    def __init__(__self__, *,
                 mount_path: str,
                 name: str,
                 mount_propagation: Optional[str] = None,
                 read_only: Optional[bool] = None,
                 sub_path: Optional[str] = None,
                 sub_path_expr: Optional[str] = None):
        """
        Mount is the Kubernetes VolumeMount referenced by this instance
        :param str mount_path: Path within the container at which the volume should be mounted.  Must not contain ':'.
        :param str name: This must match the Name of a Volume.
        :param str mount_propagation: mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
        :param bool read_only: Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
        :param str sub_path: Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
        :param str sub_path_expr: Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
        """
        pulumi.set(__self__, "mount_path", mount_path)
        pulumi.set(__self__, "name", name)
        if mount_propagation is not None:
            pulumi.set(__self__, "mount_propagation", mount_propagation)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if sub_path is not None:
            pulumi.set(__self__, "sub_path", sub_path)
        if sub_path_expr is not None:
            pulumi.set(__self__, "sub_path_expr", sub_path_expr)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> str:
        """
        Path within the container at which the volume should be mounted.  Must not contain ':'.
        """
        return pulumi.get(self, "mount_path")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        This must match the Name of a Volume.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="mountPropagation")
    def mount_propagation(self) -> Optional[str]:
        """
        mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
        """
        return pulumi.get(self, "mount_propagation")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[bool]:
        """
        Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
        """
        return pulumi.get(self, "read_only")

    @property
    @pulumi.getter(name="subPath")
    def sub_path(self) -> Optional[str]:
        """
        Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
        """
        return pulumi.get(self, "sub_path")

    @property
    @pulumi.getter(name="subPathExpr")
    def sub_path_expr(self) -> Optional[str]:
        """
        Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
        """
        return pulumi.get(self, "sub_path_expr")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoInfraStatusVolumesVolume(dict):
    """
    NamedVolume describes the pod Volume reference
    """
    def __init__(__self__, *,
                 name: str,
                 config_map: Optional['outputs.KogitoInfraStatusVolumesVolumeConfigMap'] = None,
                 secret: Optional['outputs.KogitoInfraStatusVolumesVolumeSecret'] = None):
        """
        NamedVolume describes the pod Volume reference
        :param str name: Volume's name. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param 'KogitoInfraStatusVolumesVolumeConfigMapArgs' config_map: ConfigMap represents a configMap that should populate this volume
        :param 'KogitoInfraStatusVolumesVolumeSecretArgs' secret: Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
        """
        pulumi.set(__self__, "name", name)
        if config_map is not None:
            pulumi.set(__self__, "config_map", config_map)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Volume's name. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="configMap")
    def config_map(self) -> Optional['outputs.KogitoInfraStatusVolumesVolumeConfigMap']:
        """
        ConfigMap represents a configMap that should populate this volume
        """
        return pulumi.get(self, "config_map")

    @property
    @pulumi.getter
    def secret(self) -> Optional['outputs.KogitoInfraStatusVolumesVolumeSecret']:
        """
        Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
        """
        return pulumi.get(self, "secret")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoInfraStatusVolumesVolumeConfigMap(dict):
    """
    ConfigMap represents a configMap that should populate this volume
    """
    def __init__(__self__, *,
                 default_mode: Optional[int] = None,
                 items: Optional[Sequence['outputs.KogitoInfraStatusVolumesVolumeConfigMapItems']] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        ConfigMap represents a configMap that should populate this volume
        :param int default_mode: Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        :param Sequence['KogitoInfraStatusVolumesVolumeConfigMapItemsArgs'] items: If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        :param bool optional: Specify whether the ConfigMap or its keys must be defined
        """
        if default_mode is not None:
            pulumi.set(__self__, "default_mode", default_mode)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter(name="defaultMode")
    def default_mode(self) -> Optional[int]:
        """
        Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        return pulumi.get(self, "default_mode")

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.KogitoInfraStatusVolumesVolumeConfigMapItems']]:
        """
        If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
        """
        return pulumi.get(self, "items")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the ConfigMap or its keys must be defined
        """
        return pulumi.get(self, "optional")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoInfraStatusVolumesVolumeConfigMapItems(dict):
    """
    Maps a string key to a path within a volume.
    """
    def __init__(__self__, *,
                 key: str,
                 path: str,
                 mode: Optional[int] = None):
        """
        Maps a string key to a path within a volume.
        :param str key: The key to project.
        :param str path: The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
        :param int mode: Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "path", path)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key to project.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def mode(self) -> Optional[int]:
        """
        Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        return pulumi.get(self, "mode")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoInfraStatusVolumesVolumeSecret(dict):
    """
    Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
    """
    def __init__(__self__, *,
                 default_mode: Optional[int] = None,
                 items: Optional[Sequence['outputs.KogitoInfraStatusVolumesVolumeSecretItems']] = None,
                 optional: Optional[bool] = None,
                 secret_name: Optional[str] = None):
        """
        Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
        :param int default_mode: Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        :param Sequence['KogitoInfraStatusVolumesVolumeSecretItemsArgs'] items: If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
        :param bool optional: Specify whether the Secret or its keys must be defined
        :param str secret_name: Name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
        """
        if default_mode is not None:
            pulumi.set(__self__, "default_mode", default_mode)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="defaultMode")
    def default_mode(self) -> Optional[int]:
        """
        Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        return pulumi.get(self, "default_mode")

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.KogitoInfraStatusVolumesVolumeSecretItems']]:
        """
        If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
        """
        return pulumi.get(self, "items")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the Secret or its keys must be defined
        """
        return pulumi.get(self, "optional")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[str]:
        """
        Name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoInfraStatusVolumesVolumeSecretItems(dict):
    """
    Maps a string key to a path within a volume.
    """
    def __init__(__self__, *,
                 key: str,
                 path: str,
                 mode: Optional[int] = None):
        """
        Maps a string key to a path within a volume.
        :param str key: The key to project.
        :param str path: The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
        :param int mode: Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "path", path)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key to project.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def mode(self) -> Optional[int]:
        """
        Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        return pulumi.get(self, "mode")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoRuntimeSpec(dict):
    """
    KogitoRuntimeSpec defines the desired state of KogitoRuntime.
    """
    def __init__(__self__, *,
                 config: Optional[Mapping[str, str]] = None,
                 deployment_labels: Optional[Mapping[str, str]] = None,
                 enable_istio: Optional[bool] = None,
                 env: Optional[Sequence['outputs.KogitoRuntimeSpecEnv']] = None,
                 image: Optional[str] = None,
                 infra: Optional[Sequence[str]] = None,
                 insecure_image_registry: Optional[bool] = None,
                 monitoring: Optional['outputs.KogitoRuntimeSpecMonitoring'] = None,
                 properties_config_map: Optional[str] = None,
                 replicas: Optional[int] = None,
                 resources: Optional['outputs.KogitoRuntimeSpecResources'] = None,
                 runtime: Optional[str] = None,
                 service_labels: Optional[Mapping[str, str]] = None):
        """
        KogitoRuntimeSpec defines the desired state of KogitoRuntime.
        :param Mapping[str, str] config: Application properties that will be set to the service. For example 'MY_VAR: my_value'.
        :param Mapping[str, str] deployment_labels: Additional labels to be added to the Deployment and Pods managed by the operator.
        :param bool enable_istio: Annotates the pods managed by the operator with the required metadata for Istio to setup its sidecars, enabling the mesh. Defaults to false.
        :param Sequence['KogitoRuntimeSpecEnvArgs'] env: Environment variables to be added to the runtime container. Keys must be a C_IDENTIFIER.
        :param str image: Image definition for the service. Example: "quay.io/kiegroup/kogito-service:latest". On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
        :param Sequence[str] infra: Infra provides list of dependent KogitoInfra objects.
        :param bool insecure_image_registry: A flag indicating that image streams created by Kogito Operator should be configured to allow pulling from insecure registries. Usable just on OpenShift. Defaults to 'false'.
        :param 'KogitoRuntimeSpecMonitoringArgs' monitoring: Create Service monitor instance to connect with Monitoring service
        :param str properties_config_map: Custom ConfigMap with application.properties file to be mounted for the Kogito service. The ConfigMap must be created in the same namespace. Use this property if you need custom properties to be mounted before the application deployment. If left empty, one will be created for you. Later it can be updated to add any custom properties to apply to the service.
        :param int replicas: Number of replicas that the service will have deployed in the cluster. Default value: 1.
        :param 'KogitoRuntimeSpecResourcesArgs' resources: Defined compute resource requirements for the deployed service.
        :param str runtime: The name of the runtime used, either Quarkus or SpringBoot. Default value: quarkus
        :param Mapping[str, str] service_labels: Additional labels to be added to the Service managed by the operator.
        """
        if config is not None:
            pulumi.set(__self__, "config", config)
        if deployment_labels is not None:
            pulumi.set(__self__, "deployment_labels", deployment_labels)
        if enable_istio is not None:
            pulumi.set(__self__, "enable_istio", enable_istio)
        if env is not None:
            pulumi.set(__self__, "env", env)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if infra is not None:
            pulumi.set(__self__, "infra", infra)
        if insecure_image_registry is not None:
            pulumi.set(__self__, "insecure_image_registry", insecure_image_registry)
        if monitoring is not None:
            pulumi.set(__self__, "monitoring", monitoring)
        if properties_config_map is not None:
            pulumi.set(__self__, "properties_config_map", properties_config_map)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if runtime is not None:
            pulumi.set(__self__, "runtime", runtime)
        if service_labels is not None:
            pulumi.set(__self__, "service_labels", service_labels)

    @property
    @pulumi.getter
    def config(self) -> Optional[Mapping[str, str]]:
        """
        Application properties that will be set to the service. For example 'MY_VAR: my_value'.
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter(name="deploymentLabels")
    def deployment_labels(self) -> Optional[Mapping[str, str]]:
        """
        Additional labels to be added to the Deployment and Pods managed by the operator.
        """
        return pulumi.get(self, "deployment_labels")

    @property
    @pulumi.getter(name="enableIstio")
    def enable_istio(self) -> Optional[bool]:
        """
        Annotates the pods managed by the operator with the required metadata for Istio to setup its sidecars, enabling the mesh. Defaults to false.
        """
        return pulumi.get(self, "enable_istio")

    @property
    @pulumi.getter
    def env(self) -> Optional[Sequence['outputs.KogitoRuntimeSpecEnv']]:
        """
        Environment variables to be added to the runtime container. Keys must be a C_IDENTIFIER.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        Image definition for the service. Example: "quay.io/kiegroup/kogito-service:latest". On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def infra(self) -> Optional[Sequence[str]]:
        """
        Infra provides list of dependent KogitoInfra objects.
        """
        return pulumi.get(self, "infra")

    @property
    @pulumi.getter(name="insecureImageRegistry")
    def insecure_image_registry(self) -> Optional[bool]:
        """
        A flag indicating that image streams created by Kogito Operator should be configured to allow pulling from insecure registries. Usable just on OpenShift. Defaults to 'false'.
        """
        return pulumi.get(self, "insecure_image_registry")

    @property
    @pulumi.getter
    def monitoring(self) -> Optional['outputs.KogitoRuntimeSpecMonitoring']:
        """
        Create Service monitor instance to connect with Monitoring service
        """
        return pulumi.get(self, "monitoring")

    @property
    @pulumi.getter(name="propertiesConfigMap")
    def properties_config_map(self) -> Optional[str]:
        """
        Custom ConfigMap with application.properties file to be mounted for the Kogito service. The ConfigMap must be created in the same namespace. Use this property if you need custom properties to be mounted before the application deployment. If left empty, one will be created for you. Later it can be updated to add any custom properties to apply to the service.
        """
        return pulumi.get(self, "properties_config_map")

    @property
    @pulumi.getter
    def replicas(self) -> Optional[int]:
        """
        Number of replicas that the service will have deployed in the cluster. Default value: 1.
        """
        return pulumi.get(self, "replicas")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.KogitoRuntimeSpecResources']:
        """
        Defined compute resource requirements for the deployed service.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter
    def runtime(self) -> Optional[str]:
        """
        The name of the runtime used, either Quarkus or SpringBoot. Default value: quarkus
        """
        return pulumi.get(self, "runtime")

    @property
    @pulumi.getter(name="serviceLabels")
    def service_labels(self) -> Optional[Mapping[str, str]]:
        """
        Additional labels to be added to the Service managed by the operator.
        """
        return pulumi.get(self, "service_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoRuntimeSpecEnv(dict):
    """
    EnvVar represents an environment variable present in a Container.
    """
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None,
                 value_from: Optional['outputs.KogitoRuntimeSpecEnvValueFrom'] = None):
        """
        EnvVar represents an environment variable present in a Container.
        :param str name: Name of the environment variable. Must be a C_IDENTIFIER.
        :param str value: Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        :param 'KogitoRuntimeSpecEnvValueFromArgs' value_from: Source for the environment variable's value. Cannot be used if value is not empty.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_from is not None:
            pulumi.set(__self__, "value_from", value_from)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the environment variable. Must be a C_IDENTIFIER.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueFrom")
    def value_from(self) -> Optional['outputs.KogitoRuntimeSpecEnvValueFrom']:
        """
        Source for the environment variable's value. Cannot be used if value is not empty.
        """
        return pulumi.get(self, "value_from")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoRuntimeSpecEnvValueFrom(dict):
    """
    Source for the environment variable's value. Cannot be used if value is not empty.
    """
    def __init__(__self__, *,
                 config_map_key_ref: Optional['outputs.KogitoRuntimeSpecEnvValueFromConfigMapKeyRef'] = None,
                 field_ref: Optional['outputs.KogitoRuntimeSpecEnvValueFromFieldRef'] = None,
                 resource_field_ref: Optional['outputs.KogitoRuntimeSpecEnvValueFromResourceFieldRef'] = None,
                 secret_key_ref: Optional['outputs.KogitoRuntimeSpecEnvValueFromSecretKeyRef'] = None):
        """
        Source for the environment variable's value. Cannot be used if value is not empty.
        :param 'KogitoRuntimeSpecEnvValueFromConfigMapKeyRefArgs' config_map_key_ref: Selects a key of a ConfigMap.
        :param 'KogitoRuntimeSpecEnvValueFromFieldRefArgs' field_ref: Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        :param 'KogitoRuntimeSpecEnvValueFromResourceFieldRefArgs' resource_field_ref: Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        :param 'KogitoRuntimeSpecEnvValueFromSecretKeyRefArgs' secret_key_ref: Selects a key of a secret in the pod's namespace
        """
        if config_map_key_ref is not None:
            pulumi.set(__self__, "config_map_key_ref", config_map_key_ref)
        if field_ref is not None:
            pulumi.set(__self__, "field_ref", field_ref)
        if resource_field_ref is not None:
            pulumi.set(__self__, "resource_field_ref", resource_field_ref)
        if secret_key_ref is not None:
            pulumi.set(__self__, "secret_key_ref", secret_key_ref)

    @property
    @pulumi.getter(name="configMapKeyRef")
    def config_map_key_ref(self) -> Optional['outputs.KogitoRuntimeSpecEnvValueFromConfigMapKeyRef']:
        """
        Selects a key of a ConfigMap.
        """
        return pulumi.get(self, "config_map_key_ref")

    @property
    @pulumi.getter(name="fieldRef")
    def field_ref(self) -> Optional['outputs.KogitoRuntimeSpecEnvValueFromFieldRef']:
        """
        Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        """
        return pulumi.get(self, "field_ref")

    @property
    @pulumi.getter(name="resourceFieldRef")
    def resource_field_ref(self) -> Optional['outputs.KogitoRuntimeSpecEnvValueFromResourceFieldRef']:
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        """
        return pulumi.get(self, "resource_field_ref")

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> Optional['outputs.KogitoRuntimeSpecEnvValueFromSecretKeyRef']:
        """
        Selects a key of a secret in the pod's namespace
        """
        return pulumi.get(self, "secret_key_ref")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoRuntimeSpecEnvValueFromConfigMapKeyRef(dict):
    """
    Selects a key of a ConfigMap.
    """
    def __init__(__self__, *,
                 key: str,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        Selects a key of a ConfigMap.
        :param str key: The key to select.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        :param bool optional: Specify whether the ConfigMap or its key must be defined
        """
        pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key to select.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the ConfigMap or its key must be defined
        """
        return pulumi.get(self, "optional")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoRuntimeSpecEnvValueFromFieldRef(dict):
    """
    Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    """
    def __init__(__self__, *,
                 field_path: str,
                 api_version: Optional[str] = None):
        """
        Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        :param str field_path: Path of the field to select in the specified API version.
        :param str api_version: Version of the schema the FieldPath is written in terms of, defaults to "v1".
        """
        pulumi.set(__self__, "field_path", field_path)
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> str:
        """
        Path of the field to select in the specified API version.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        Version of the schema the FieldPath is written in terms of, defaults to "v1".
        """
        return pulumi.get(self, "api_version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoRuntimeSpecEnvValueFromResourceFieldRef(dict):
    """
    Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    """
    def __init__(__self__, *,
                 resource: str,
                 container_name: Optional[str] = None,
                 divisor: Optional['outputs.KogitoRuntimeSpecEnvValueFromResourceFieldRefDivisor'] = None):
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        :param str resource: Required: resource to select
        :param str container_name: Container name: required for volumes, optional for env vars
        :param 'KogitoRuntimeSpecEnvValueFromResourceFieldRefDivisorArgs' divisor: Specifies the output format of the exposed resources, defaults to "1"
        """
        pulumi.set(__self__, "resource", resource)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if divisor is not None:
            pulumi.set(__self__, "divisor", divisor)

    @property
    @pulumi.getter
    def resource(self) -> str:
        """
        Required: resource to select
        """
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[str]:
        """
        Container name: required for volumes, optional for env vars
        """
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def divisor(self) -> Optional['outputs.KogitoRuntimeSpecEnvValueFromResourceFieldRefDivisor']:
        """
        Specifies the output format of the exposed resources, defaults to "1"
        """
        return pulumi.get(self, "divisor")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoRuntimeSpecEnvValueFromResourceFieldRefDivisor(dict):
    def __init__(__self__):
        pass

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoRuntimeSpecEnvValueFromSecretKeyRef(dict):
    """
    Selects a key of a secret in the pod's namespace
    """
    def __init__(__self__, *,
                 key: str,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        Selects a key of a secret in the pod's namespace
        :param str key: The key of the secret to select from.  Must be a valid secret key.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        :param bool optional: Specify whether the Secret or its key must be defined
        """
        pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the secret to select from.  Must be a valid secret key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the Secret or its key must be defined
        """
        return pulumi.get(self, "optional")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoRuntimeSpecMonitoring(dict):
    """
    Create Service monitor instance to connect with Monitoring service
    """
    def __init__(__self__, *,
                 path: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        Create Service monitor instance to connect with Monitoring service
        :param str path: HTTP path to scrape for metrics.
        :param str scheme: HTTP scheme to use for scraping.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        HTTP path to scrape for metrics.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        HTTP scheme to use for scraping.
        """
        return pulumi.get(self, "scheme")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoRuntimeSpecResources(dict):
    """
    Defined compute resource requirements for the deployed service.
    """
    def __init__(__self__, *,
                 limits: Optional[Mapping[str, 'outputs.KogitoRuntimeSpecResourcesLimits']] = None,
                 requests: Optional[Mapping[str, 'outputs.KogitoRuntimeSpecResourcesRequests']] = None):
        """
        Defined compute resource requirements for the deployed service.
        :param Mapping[str, 'KogitoRuntimeSpecResourcesLimitsArgs'] limits: Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        :param Mapping[str, 'KogitoRuntimeSpecResourcesRequestsArgs'] requests: Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, 'outputs.KogitoRuntimeSpecResourcesLimits']]:
        """
        Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Mapping[str, 'outputs.KogitoRuntimeSpecResourcesRequests']]:
        """
        Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "requests")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoRuntimeSpecResourcesLimits(dict):
    def __init__(__self__):
        pass

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoRuntimeSpecResourcesRequests(dict):
    def __init__(__self__):
        pass

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoRuntimeStatus(dict):
    """
    KogitoRuntimeStatus defines the observed state of KogitoRuntime.
    """
    def __init__(__self__, *,
                 conditions: Sequence['outputs.KogitoRuntimeStatusConditions'],
                 cloud_events: Optional['outputs.KogitoRuntimeStatusCloudEvents'] = None,
                 deployment_conditions: Optional[Sequence['outputs.KogitoRuntimeStatusDeploymentConditions']] = None,
                 external_uri: Optional[str] = None,
                 image: Optional[str] = None):
        """
        KogitoRuntimeStatus defines the observed state of KogitoRuntime.
        :param Sequence['KogitoRuntimeStatusConditionsArgs'] conditions: History of conditions for the resource
        :param 'KogitoRuntimeStatusCloudEventsArgs' cloud_events: Describes the CloudEvents that this instance can consume or produce
        :param Sequence['KogitoRuntimeStatusDeploymentConditionsArgs'] deployment_conditions: General conditions for the Kogito Service deployment.
        :param str external_uri: URI is where the service is exposed.
        :param str image: Image is the resolved image for this service.
        """
        pulumi.set(__self__, "conditions", conditions)
        if cloud_events is not None:
            pulumi.set(__self__, "cloud_events", cloud_events)
        if deployment_conditions is not None:
            pulumi.set(__self__, "deployment_conditions", deployment_conditions)
        if external_uri is not None:
            pulumi.set(__self__, "external_uri", external_uri)
        if image is not None:
            pulumi.set(__self__, "image", image)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.KogitoRuntimeStatusConditions']:
        """
        History of conditions for the resource
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="cloudEvents")
    def cloud_events(self) -> Optional['outputs.KogitoRuntimeStatusCloudEvents']:
        """
        Describes the CloudEvents that this instance can consume or produce
        """
        return pulumi.get(self, "cloud_events")

    @property
    @pulumi.getter(name="deploymentConditions")
    def deployment_conditions(self) -> Optional[Sequence['outputs.KogitoRuntimeStatusDeploymentConditions']]:
        """
        General conditions for the Kogito Service deployment.
        """
        return pulumi.get(self, "deployment_conditions")

    @property
    @pulumi.getter(name="externalURI")
    def external_uri(self) -> Optional[str]:
        """
        URI is where the service is exposed.
        """
        return pulumi.get(self, "external_uri")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        Image is the resolved image for this service.
        """
        return pulumi.get(self, "image")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoRuntimeStatusCloudEvents(dict):
    """
    Describes the CloudEvents that this instance can consume or produce
    """
    def __init__(__self__, *,
                 consumes: Optional[Sequence['outputs.KogitoRuntimeStatusCloudEventsConsumes']] = None,
                 produces: Optional[Sequence['outputs.KogitoRuntimeStatusCloudEventsProduces']] = None):
        """
        Describes the CloudEvents that this instance can consume or produce
        """
        if consumes is not None:
            pulumi.set(__self__, "consumes", consumes)
        if produces is not None:
            pulumi.set(__self__, "produces", produces)

    @property
    @pulumi.getter
    def consumes(self) -> Optional[Sequence['outputs.KogitoRuntimeStatusCloudEventsConsumes']]:
        return pulumi.get(self, "consumes")

    @property
    @pulumi.getter
    def produces(self) -> Optional[Sequence['outputs.KogitoRuntimeStatusCloudEventsProduces']]:
        return pulumi.get(self, "produces")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoRuntimeStatusCloudEventsConsumes(dict):
    """
    KogitoCloudEventInfo describes the CloudEvent information based on the specification
    """
    def __init__(__self__, *,
                 type: str,
                 source: Optional[str] = None):
        """
        KogitoCloudEventInfo describes the CloudEvent information based on the specification
        """
        pulumi.set(__self__, "type", type)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoRuntimeStatusCloudEventsProduces(dict):
    """
    KogitoCloudEventInfo describes the CloudEvent information based on the specification
    """
    def __init__(__self__, *,
                 type: str,
                 source: Optional[str] = None):
        """
        KogitoCloudEventInfo describes the CloudEvent information based on the specification
        """
        pulumi.set(__self__, "type", type)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoRuntimeStatusConditions(dict):
    """
    Condition is the detailed condition for the resource
    """
    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None):
        """
        Condition is the detailed condition for the resource
        :param str type: ConditionType is the type of condition
        :param str reason: KogitoServiceConditionReason is the type of reason
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        ConditionType is the type of condition
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        KogitoServiceConditionReason is the type of reason
        """
        return pulumi.get(self, "reason")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoRuntimeStatusDeploymentConditions(dict):
    """
    DeploymentCondition describes the state of a deployment at a certain point.
    """
    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 last_update_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None):
        """
        DeploymentCondition describes the state of a deployment at a certain point.
        :param str status: Status of the condition, one of True, False, Unknown.
        :param str type: Type of deployment condition.
        :param str last_transition_time: Last time the condition transitioned from one status to another.
        :param str last_update_time: The last time this condition was updated.
        :param str message: A human readable message indicating details about the transition.
        :param str reason: The reason for the condition's last transition.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if last_update_time is not None:
            pulumi.set(__self__, "last_update_time", last_update_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of deployment condition.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        Last time the condition transitioned from one status to another.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter(name="lastUpdateTime")
    def last_update_time(self) -> Optional[str]:
        """
        The last time this condition was updated.
        """
        return pulumi.get(self, "last_update_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        A human readable message indicating details about the transition.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        The reason for the condition's last transition.
        """
        return pulumi.get(self, "reason")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoSupportingServiceSpec(dict):
    """
    KogitoSupportingServiceSpec defines the desired state of KogitoSupportingService.
    """
    def __init__(__self__, *,
                 service_type: str,
                 config: Optional[Mapping[str, str]] = None,
                 deployment_labels: Optional[Mapping[str, str]] = None,
                 env: Optional[Sequence['outputs.KogitoSupportingServiceSpecEnv']] = None,
                 image: Optional[str] = None,
                 infra: Optional[Sequence[str]] = None,
                 insecure_image_registry: Optional[bool] = None,
                 monitoring: Optional['outputs.KogitoSupportingServiceSpecMonitoring'] = None,
                 properties_config_map: Optional[str] = None,
                 replicas: Optional[int] = None,
                 resources: Optional['outputs.KogitoSupportingServiceSpecResources'] = None,
                 service_labels: Optional[Mapping[str, str]] = None):
        """
        KogitoSupportingServiceSpec defines the desired state of KogitoSupportingService.
        :param str service_type: Defines the type for the supporting service, eg: DataIndex, JobsService Default value: JobsService
        :param Mapping[str, str] config: Application properties that will be set to the service. For example 'MY_VAR: my_value'.
        :param Mapping[str, str] deployment_labels: Additional labels to be added to the Deployment and Pods managed by the operator.
        :param Sequence['KogitoSupportingServiceSpecEnvArgs'] env: Environment variables to be added to the runtime container. Keys must be a C_IDENTIFIER.
        :param str image: Image definition for the service. Example: "quay.io/kiegroup/kogito-service:latest". On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
        :param Sequence[str] infra: Infra provides list of dependent KogitoInfra objects.
        :param bool insecure_image_registry: A flag indicating that image streams created by Kogito Operator should be configured to allow pulling from insecure registries. Usable just on OpenShift. Defaults to 'false'.
        :param 'KogitoSupportingServiceSpecMonitoringArgs' monitoring: Create Service monitor instance to connect with Monitoring service
        :param str properties_config_map: Custom ConfigMap with application.properties file to be mounted for the Kogito service. The ConfigMap must be created in the same namespace. Use this property if you need custom properties to be mounted before the application deployment. If left empty, one will be created for you. Later it can be updated to add any custom properties to apply to the service.
        :param int replicas: Number of replicas that the service will have deployed in the cluster. Default value: 1.
        :param 'KogitoSupportingServiceSpecResourcesArgs' resources: Defined compute resource requirements for the deployed service.
        :param Mapping[str, str] service_labels: Additional labels to be added to the Service managed by the operator.
        """
        pulumi.set(__self__, "service_type", service_type)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if deployment_labels is not None:
            pulumi.set(__self__, "deployment_labels", deployment_labels)
        if env is not None:
            pulumi.set(__self__, "env", env)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if infra is not None:
            pulumi.set(__self__, "infra", infra)
        if insecure_image_registry is not None:
            pulumi.set(__self__, "insecure_image_registry", insecure_image_registry)
        if monitoring is not None:
            pulumi.set(__self__, "monitoring", monitoring)
        if properties_config_map is not None:
            pulumi.set(__self__, "properties_config_map", properties_config_map)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if service_labels is not None:
            pulumi.set(__self__, "service_labels", service_labels)

    @property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> str:
        """
        Defines the type for the supporting service, eg: DataIndex, JobsService Default value: JobsService
        """
        return pulumi.get(self, "service_type")

    @property
    @pulumi.getter
    def config(self) -> Optional[Mapping[str, str]]:
        """
        Application properties that will be set to the service. For example 'MY_VAR: my_value'.
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter(name="deploymentLabels")
    def deployment_labels(self) -> Optional[Mapping[str, str]]:
        """
        Additional labels to be added to the Deployment and Pods managed by the operator.
        """
        return pulumi.get(self, "deployment_labels")

    @property
    @pulumi.getter
    def env(self) -> Optional[Sequence['outputs.KogitoSupportingServiceSpecEnv']]:
        """
        Environment variables to be added to the runtime container. Keys must be a C_IDENTIFIER.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        Image definition for the service. Example: "quay.io/kiegroup/kogito-service:latest". On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def infra(self) -> Optional[Sequence[str]]:
        """
        Infra provides list of dependent KogitoInfra objects.
        """
        return pulumi.get(self, "infra")

    @property
    @pulumi.getter(name="insecureImageRegistry")
    def insecure_image_registry(self) -> Optional[bool]:
        """
        A flag indicating that image streams created by Kogito Operator should be configured to allow pulling from insecure registries. Usable just on OpenShift. Defaults to 'false'.
        """
        return pulumi.get(self, "insecure_image_registry")

    @property
    @pulumi.getter
    def monitoring(self) -> Optional['outputs.KogitoSupportingServiceSpecMonitoring']:
        """
        Create Service monitor instance to connect with Monitoring service
        """
        return pulumi.get(self, "monitoring")

    @property
    @pulumi.getter(name="propertiesConfigMap")
    def properties_config_map(self) -> Optional[str]:
        """
        Custom ConfigMap with application.properties file to be mounted for the Kogito service. The ConfigMap must be created in the same namespace. Use this property if you need custom properties to be mounted before the application deployment. If left empty, one will be created for you. Later it can be updated to add any custom properties to apply to the service.
        """
        return pulumi.get(self, "properties_config_map")

    @property
    @pulumi.getter
    def replicas(self) -> Optional[int]:
        """
        Number of replicas that the service will have deployed in the cluster. Default value: 1.
        """
        return pulumi.get(self, "replicas")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.KogitoSupportingServiceSpecResources']:
        """
        Defined compute resource requirements for the deployed service.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter(name="serviceLabels")
    def service_labels(self) -> Optional[Mapping[str, str]]:
        """
        Additional labels to be added to the Service managed by the operator.
        """
        return pulumi.get(self, "service_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoSupportingServiceSpecEnv(dict):
    """
    EnvVar represents an environment variable present in a Container.
    """
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None,
                 value_from: Optional['outputs.KogitoSupportingServiceSpecEnvValueFrom'] = None):
        """
        EnvVar represents an environment variable present in a Container.
        :param str name: Name of the environment variable. Must be a C_IDENTIFIER.
        :param str value: Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        :param 'KogitoSupportingServiceSpecEnvValueFromArgs' value_from: Source for the environment variable's value. Cannot be used if value is not empty.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_from is not None:
            pulumi.set(__self__, "value_from", value_from)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the environment variable. Must be a C_IDENTIFIER.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueFrom")
    def value_from(self) -> Optional['outputs.KogitoSupportingServiceSpecEnvValueFrom']:
        """
        Source for the environment variable's value. Cannot be used if value is not empty.
        """
        return pulumi.get(self, "value_from")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoSupportingServiceSpecEnvValueFrom(dict):
    """
    Source for the environment variable's value. Cannot be used if value is not empty.
    """
    def __init__(__self__, *,
                 config_map_key_ref: Optional['outputs.KogitoSupportingServiceSpecEnvValueFromConfigMapKeyRef'] = None,
                 field_ref: Optional['outputs.KogitoSupportingServiceSpecEnvValueFromFieldRef'] = None,
                 resource_field_ref: Optional['outputs.KogitoSupportingServiceSpecEnvValueFromResourceFieldRef'] = None,
                 secret_key_ref: Optional['outputs.KogitoSupportingServiceSpecEnvValueFromSecretKeyRef'] = None):
        """
        Source for the environment variable's value. Cannot be used if value is not empty.
        :param 'KogitoSupportingServiceSpecEnvValueFromConfigMapKeyRefArgs' config_map_key_ref: Selects a key of a ConfigMap.
        :param 'KogitoSupportingServiceSpecEnvValueFromFieldRefArgs' field_ref: Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        :param 'KogitoSupportingServiceSpecEnvValueFromResourceFieldRefArgs' resource_field_ref: Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        :param 'KogitoSupportingServiceSpecEnvValueFromSecretKeyRefArgs' secret_key_ref: Selects a key of a secret in the pod's namespace
        """
        if config_map_key_ref is not None:
            pulumi.set(__self__, "config_map_key_ref", config_map_key_ref)
        if field_ref is not None:
            pulumi.set(__self__, "field_ref", field_ref)
        if resource_field_ref is not None:
            pulumi.set(__self__, "resource_field_ref", resource_field_ref)
        if secret_key_ref is not None:
            pulumi.set(__self__, "secret_key_ref", secret_key_ref)

    @property
    @pulumi.getter(name="configMapKeyRef")
    def config_map_key_ref(self) -> Optional['outputs.KogitoSupportingServiceSpecEnvValueFromConfigMapKeyRef']:
        """
        Selects a key of a ConfigMap.
        """
        return pulumi.get(self, "config_map_key_ref")

    @property
    @pulumi.getter(name="fieldRef")
    def field_ref(self) -> Optional['outputs.KogitoSupportingServiceSpecEnvValueFromFieldRef']:
        """
        Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        """
        return pulumi.get(self, "field_ref")

    @property
    @pulumi.getter(name="resourceFieldRef")
    def resource_field_ref(self) -> Optional['outputs.KogitoSupportingServiceSpecEnvValueFromResourceFieldRef']:
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        """
        return pulumi.get(self, "resource_field_ref")

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> Optional['outputs.KogitoSupportingServiceSpecEnvValueFromSecretKeyRef']:
        """
        Selects a key of a secret in the pod's namespace
        """
        return pulumi.get(self, "secret_key_ref")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoSupportingServiceSpecEnvValueFromConfigMapKeyRef(dict):
    """
    Selects a key of a ConfigMap.
    """
    def __init__(__self__, *,
                 key: str,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        Selects a key of a ConfigMap.
        :param str key: The key to select.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        :param bool optional: Specify whether the ConfigMap or its key must be defined
        """
        pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key to select.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the ConfigMap or its key must be defined
        """
        return pulumi.get(self, "optional")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoSupportingServiceSpecEnvValueFromFieldRef(dict):
    """
    Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    """
    def __init__(__self__, *,
                 field_path: str,
                 api_version: Optional[str] = None):
        """
        Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        :param str field_path: Path of the field to select in the specified API version.
        :param str api_version: Version of the schema the FieldPath is written in terms of, defaults to "v1".
        """
        pulumi.set(__self__, "field_path", field_path)
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> str:
        """
        Path of the field to select in the specified API version.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        Version of the schema the FieldPath is written in terms of, defaults to "v1".
        """
        return pulumi.get(self, "api_version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoSupportingServiceSpecEnvValueFromResourceFieldRef(dict):
    """
    Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    """
    def __init__(__self__, *,
                 resource: str,
                 container_name: Optional[str] = None,
                 divisor: Optional['outputs.KogitoSupportingServiceSpecEnvValueFromResourceFieldRefDivisor'] = None):
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        :param str resource: Required: resource to select
        :param str container_name: Container name: required for volumes, optional for env vars
        :param 'KogitoSupportingServiceSpecEnvValueFromResourceFieldRefDivisorArgs' divisor: Specifies the output format of the exposed resources, defaults to "1"
        """
        pulumi.set(__self__, "resource", resource)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if divisor is not None:
            pulumi.set(__self__, "divisor", divisor)

    @property
    @pulumi.getter
    def resource(self) -> str:
        """
        Required: resource to select
        """
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[str]:
        """
        Container name: required for volumes, optional for env vars
        """
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def divisor(self) -> Optional['outputs.KogitoSupportingServiceSpecEnvValueFromResourceFieldRefDivisor']:
        """
        Specifies the output format of the exposed resources, defaults to "1"
        """
        return pulumi.get(self, "divisor")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoSupportingServiceSpecEnvValueFromResourceFieldRefDivisor(dict):
    def __init__(__self__):
        pass

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoSupportingServiceSpecEnvValueFromSecretKeyRef(dict):
    """
    Selects a key of a secret in the pod's namespace
    """
    def __init__(__self__, *,
                 key: str,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        Selects a key of a secret in the pod's namespace
        :param str key: The key of the secret to select from.  Must be a valid secret key.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        :param bool optional: Specify whether the Secret or its key must be defined
        """
        pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the secret to select from.  Must be a valid secret key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the Secret or its key must be defined
        """
        return pulumi.get(self, "optional")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoSupportingServiceSpecMonitoring(dict):
    """
    Create Service monitor instance to connect with Monitoring service
    """
    def __init__(__self__, *,
                 path: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        Create Service monitor instance to connect with Monitoring service
        :param str path: HTTP path to scrape for metrics.
        :param str scheme: HTTP scheme to use for scraping.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        HTTP path to scrape for metrics.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        HTTP scheme to use for scraping.
        """
        return pulumi.get(self, "scheme")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoSupportingServiceSpecResources(dict):
    """
    Defined compute resource requirements for the deployed service.
    """
    def __init__(__self__, *,
                 limits: Optional[Mapping[str, 'outputs.KogitoSupportingServiceSpecResourcesLimits']] = None,
                 requests: Optional[Mapping[str, 'outputs.KogitoSupportingServiceSpecResourcesRequests']] = None):
        """
        Defined compute resource requirements for the deployed service.
        :param Mapping[str, 'KogitoSupportingServiceSpecResourcesLimitsArgs'] limits: Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        :param Mapping[str, 'KogitoSupportingServiceSpecResourcesRequestsArgs'] requests: Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, 'outputs.KogitoSupportingServiceSpecResourcesLimits']]:
        """
        Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Mapping[str, 'outputs.KogitoSupportingServiceSpecResourcesRequests']]:
        """
        Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "requests")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoSupportingServiceSpecResourcesLimits(dict):
    def __init__(__self__):
        pass

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoSupportingServiceSpecResourcesRequests(dict):
    def __init__(__self__):
        pass

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoSupportingServiceStatus(dict):
    """
    KogitoSupportingServiceStatus defines the observed state of KogitoSupportingService.
    """
    def __init__(__self__, *,
                 conditions: Sequence['outputs.KogitoSupportingServiceStatusConditions'],
                 cloud_events: Optional['outputs.KogitoSupportingServiceStatusCloudEvents'] = None,
                 deployment_conditions: Optional[Sequence['outputs.KogitoSupportingServiceStatusDeploymentConditions']] = None,
                 external_uri: Optional[str] = None,
                 image: Optional[str] = None):
        """
        KogitoSupportingServiceStatus defines the observed state of KogitoSupportingService.
        :param Sequence['KogitoSupportingServiceStatusConditionsArgs'] conditions: History of conditions for the resource
        :param 'KogitoSupportingServiceStatusCloudEventsArgs' cloud_events: Describes the CloudEvents that this instance can consume or produce
        :param Sequence['KogitoSupportingServiceStatusDeploymentConditionsArgs'] deployment_conditions: General conditions for the Kogito Service deployment.
        :param str external_uri: URI is where the service is exposed.
        :param str image: Image is the resolved image for this service.
        """
        pulumi.set(__self__, "conditions", conditions)
        if cloud_events is not None:
            pulumi.set(__self__, "cloud_events", cloud_events)
        if deployment_conditions is not None:
            pulumi.set(__self__, "deployment_conditions", deployment_conditions)
        if external_uri is not None:
            pulumi.set(__self__, "external_uri", external_uri)
        if image is not None:
            pulumi.set(__self__, "image", image)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.KogitoSupportingServiceStatusConditions']:
        """
        History of conditions for the resource
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="cloudEvents")
    def cloud_events(self) -> Optional['outputs.KogitoSupportingServiceStatusCloudEvents']:
        """
        Describes the CloudEvents that this instance can consume or produce
        """
        return pulumi.get(self, "cloud_events")

    @property
    @pulumi.getter(name="deploymentConditions")
    def deployment_conditions(self) -> Optional[Sequence['outputs.KogitoSupportingServiceStatusDeploymentConditions']]:
        """
        General conditions for the Kogito Service deployment.
        """
        return pulumi.get(self, "deployment_conditions")

    @property
    @pulumi.getter(name="externalURI")
    def external_uri(self) -> Optional[str]:
        """
        URI is where the service is exposed.
        """
        return pulumi.get(self, "external_uri")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        Image is the resolved image for this service.
        """
        return pulumi.get(self, "image")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoSupportingServiceStatusCloudEvents(dict):
    """
    Describes the CloudEvents that this instance can consume or produce
    """
    def __init__(__self__, *,
                 consumes: Optional[Sequence['outputs.KogitoSupportingServiceStatusCloudEventsConsumes']] = None,
                 produces: Optional[Sequence['outputs.KogitoSupportingServiceStatusCloudEventsProduces']] = None):
        """
        Describes the CloudEvents that this instance can consume or produce
        """
        if consumes is not None:
            pulumi.set(__self__, "consumes", consumes)
        if produces is not None:
            pulumi.set(__self__, "produces", produces)

    @property
    @pulumi.getter
    def consumes(self) -> Optional[Sequence['outputs.KogitoSupportingServiceStatusCloudEventsConsumes']]:
        return pulumi.get(self, "consumes")

    @property
    @pulumi.getter
    def produces(self) -> Optional[Sequence['outputs.KogitoSupportingServiceStatusCloudEventsProduces']]:
        return pulumi.get(self, "produces")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoSupportingServiceStatusCloudEventsConsumes(dict):
    """
    KogitoCloudEventInfo describes the CloudEvent information based on the specification
    """
    def __init__(__self__, *,
                 type: str,
                 source: Optional[str] = None):
        """
        KogitoCloudEventInfo describes the CloudEvent information based on the specification
        """
        pulumi.set(__self__, "type", type)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoSupportingServiceStatusCloudEventsProduces(dict):
    """
    KogitoCloudEventInfo describes the CloudEvent information based on the specification
    """
    def __init__(__self__, *,
                 type: str,
                 source: Optional[str] = None):
        """
        KogitoCloudEventInfo describes the CloudEvent information based on the specification
        """
        pulumi.set(__self__, "type", type)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoSupportingServiceStatusConditions(dict):
    """
    Condition is the detailed condition for the resource
    """
    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None):
        """
        Condition is the detailed condition for the resource
        :param str type: ConditionType is the type of condition
        :param str reason: KogitoServiceConditionReason is the type of reason
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        ConditionType is the type of condition
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        KogitoServiceConditionReason is the type of reason
        """
        return pulumi.get(self, "reason")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoSupportingServiceStatusDeploymentConditions(dict):
    """
    DeploymentCondition describes the state of a deployment at a certain point.
    """
    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 last_update_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None):
        """
        DeploymentCondition describes the state of a deployment at a certain point.
        :param str status: Status of the condition, one of True, False, Unknown.
        :param str type: Type of deployment condition.
        :param str last_transition_time: Last time the condition transitioned from one status to another.
        :param str last_update_time: The last time this condition was updated.
        :param str message: A human readable message indicating details about the transition.
        :param str reason: The reason for the condition's last transition.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if last_update_time is not None:
            pulumi.set(__self__, "last_update_time", last_update_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of deployment condition.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        Last time the condition transitioned from one status to another.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter(name="lastUpdateTime")
    def last_update_time(self) -> Optional[str]:
        """
        The last time this condition was updated.
        """
        return pulumi.get(self, "last_update_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        A human readable message indicating details about the transition.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        The reason for the condition's last transition.
        """
        return pulumi.get(self, "reason")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


