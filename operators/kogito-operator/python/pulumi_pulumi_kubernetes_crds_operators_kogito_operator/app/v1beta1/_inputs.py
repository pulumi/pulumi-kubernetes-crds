# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from ... import _utilities, _tables

__all__ = [
    'KogitoBuildSpecArgs',
    'KogitoBuildSpecArtifactArgs',
    'KogitoBuildSpecEnvArgs',
    'KogitoBuildSpecEnvValueFromArgs',
    'KogitoBuildSpecEnvValueFromConfigMapKeyRefArgs',
    'KogitoBuildSpecEnvValueFromFieldRefArgs',
    'KogitoBuildSpecEnvValueFromResourceFieldRefArgs',
    'KogitoBuildSpecEnvValueFromResourceFieldRefDivisorArgs',
    'KogitoBuildSpecEnvValueFromSecretKeyRefArgs',
    'KogitoBuildSpecGitSourceArgs',
    'KogitoBuildSpecResourcesArgs',
    'KogitoBuildSpecResourcesLimitsArgs',
    'KogitoBuildSpecResourcesRequestsArgs',
    'KogitoBuildSpecWebHooksArgs',
    'KogitoBuildStatusArgs',
    'KogitoBuildStatusBuildsArgs',
    'KogitoBuildStatusConditionsArgs',
    'KogitoInfraSpecArgs',
    'KogitoInfraSpecResourceArgs',
    'KogitoInfraStatusArgs',
    'KogitoInfraStatusConditionArgs',
    'KogitoInfraStatusEnvArgs',
    'KogitoInfraStatusEnvValueFromArgs',
    'KogitoInfraStatusEnvValueFromConfigMapKeyRefArgs',
    'KogitoInfraStatusEnvValueFromFieldRefArgs',
    'KogitoInfraStatusEnvValueFromResourceFieldRefArgs',
    'KogitoInfraStatusEnvValueFromResourceFieldRefDivisorArgs',
    'KogitoInfraStatusEnvValueFromSecretKeyRefArgs',
    'KogitoInfraStatusVolumesArgs',
    'KogitoInfraStatusVolumesMountArgs',
    'KogitoInfraStatusVolumesVolumeArgs',
    'KogitoInfraStatusVolumesVolumeConfigMapArgs',
    'KogitoInfraStatusVolumesVolumeConfigMapItemsArgs',
    'KogitoInfraStatusVolumesVolumeSecretArgs',
    'KogitoInfraStatusVolumesVolumeSecretItemsArgs',
    'KogitoRuntimeSpecArgs',
    'KogitoRuntimeSpecEnvArgs',
    'KogitoRuntimeSpecEnvValueFromArgs',
    'KogitoRuntimeSpecEnvValueFromConfigMapKeyRefArgs',
    'KogitoRuntimeSpecEnvValueFromFieldRefArgs',
    'KogitoRuntimeSpecEnvValueFromResourceFieldRefArgs',
    'KogitoRuntimeSpecEnvValueFromResourceFieldRefDivisorArgs',
    'KogitoRuntimeSpecEnvValueFromSecretKeyRefArgs',
    'KogitoRuntimeSpecMonitoringArgs',
    'KogitoRuntimeSpecResourcesArgs',
    'KogitoRuntimeSpecResourcesLimitsArgs',
    'KogitoRuntimeSpecResourcesRequestsArgs',
    'KogitoRuntimeStatusArgs',
    'KogitoRuntimeStatusCloudEventsArgs',
    'KogitoRuntimeStatusCloudEventsConsumesArgs',
    'KogitoRuntimeStatusCloudEventsProducesArgs',
    'KogitoRuntimeStatusConditionsArgs',
    'KogitoRuntimeStatusDeploymentConditionsArgs',
    'KogitoSupportingServiceSpecArgs',
    'KogitoSupportingServiceSpecEnvArgs',
    'KogitoSupportingServiceSpecEnvValueFromArgs',
    'KogitoSupportingServiceSpecEnvValueFromConfigMapKeyRefArgs',
    'KogitoSupportingServiceSpecEnvValueFromFieldRefArgs',
    'KogitoSupportingServiceSpecEnvValueFromResourceFieldRefArgs',
    'KogitoSupportingServiceSpecEnvValueFromResourceFieldRefDivisorArgs',
    'KogitoSupportingServiceSpecEnvValueFromSecretKeyRefArgs',
    'KogitoSupportingServiceSpecMonitoringArgs',
    'KogitoSupportingServiceSpecResourcesArgs',
    'KogitoSupportingServiceSpecResourcesLimitsArgs',
    'KogitoSupportingServiceSpecResourcesRequestsArgs',
    'KogitoSupportingServiceStatusArgs',
    'KogitoSupportingServiceStatusCloudEventsArgs',
    'KogitoSupportingServiceStatusCloudEventsConsumesArgs',
    'KogitoSupportingServiceStatusCloudEventsProducesArgs',
    'KogitoSupportingServiceStatusConditionsArgs',
    'KogitoSupportingServiceStatusDeploymentConditionsArgs',
]

@pulumi.input_type
class KogitoBuildSpecArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 artifact: Optional[pulumi.Input['KogitoBuildSpecArtifactArgs']] = None,
                 build_image: Optional[pulumi.Input[str]] = None,
                 disable_incremental: Optional[pulumi.Input[bool]] = None,
                 enable_maven_download_output: Optional[pulumi.Input[bool]] = None,
                 env: Optional[pulumi.Input[Sequence[pulumi.Input['KogitoBuildSpecEnvArgs']]]] = None,
                 git_source: Optional[pulumi.Input['KogitoBuildSpecGitSourceArgs']] = None,
                 maven_mirror_url: Optional[pulumi.Input[str]] = None,
                 native: Optional[pulumi.Input[bool]] = None,
                 resources: Optional[pulumi.Input['KogitoBuildSpecResourcesArgs']] = None,
                 runtime: Optional[pulumi.Input[str]] = None,
                 runtime_image: Optional[pulumi.Input[str]] = None,
                 target_kogito_runtime: Optional[pulumi.Input[str]] = None,
                 web_hooks: Optional[pulumi.Input[Sequence[pulumi.Input['KogitoBuildSpecWebHooksArgs']]]] = None):
        """
        KogitoBuildSpec defines the desired state of KogitoBuild.
        :param pulumi.Input[str] type: Sets the type of build that this instance will handle: Binary - takes an uploaded binary file already compiled and creates a Kogito service image from it. RemoteSource - pulls the source code from a Git repository, builds the binary and then the final Kogito service image. LocalSource - takes an uploaded resource file such as DRL (rules), DMN (decision) or BPMN (process), builds the binary and the final Kogito service image.
        :param pulumi.Input['KogitoBuildSpecArtifactArgs'] artifact: Artifact contains override information for building the Maven artifact (used for Local Source builds). You might want to override this information when building from decisions, rules or process files. In this scenario the Kogito Images will generate a new Java project for you underneath. This information will be used to generate this project.
        :param pulumi.Input[str] build_image: Image used to build the Kogito Service from source (Local and Remote). The operator will use the one provided by the Kogito Team based on the "Runtime" field. Example: "quay.io/kiegroup/kogito-jvm-builder:latest". On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
        :param pulumi.Input[bool] disable_incremental: DisableIncremental indicates that source to image builds should NOT be incremental. Defaults to false.
        :param pulumi.Input[bool] enable_maven_download_output: If set to true will print the logs for downloading/uploading of maven dependencies. Defaults to false.
        :param pulumi.Input[Sequence[pulumi.Input['KogitoBuildSpecEnvArgs']]] env: Environment variables used during build time.
        :param pulumi.Input['KogitoBuildSpecGitSourceArgs'] git_source: Information about the git repository where the Kogito Service source code resides. Ignored for binary builds.
        :param pulumi.Input[str] maven_mirror_url: Maven Mirror URL to be used during source-to-image builds (Local and Remote) to considerably increase build speed.
        :param pulumi.Input[bool] native: Native indicates if the Kogito Service built should be compiled to run on native mode when Runtime is Quarkus (Source to Image build only). For more information, see https://www.graalvm.org/docs/reference-manual/aot-compilation/.
        :param pulumi.Input['KogitoBuildSpecResourcesArgs'] resources: Resources Requirements for builder pods.
        :param pulumi.Input[str] runtime: Which runtime Kogito service base image to use when building the Kogito service. If "BuildImage" is set, this value is ignored by the operator. Default value: quarkus.
        :param pulumi.Input[str] runtime_image: Image used as the base image for the final Kogito service. This image only has the required packages to run the application. For example: quarkus based services will have only JVM installed, native services only the packages required by the OS. The operator will use the one provided by the Kogito Team based on the "Runtime" field. Example: "quay.io/kiegroup/kogito-jvm-builder:latest". On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
        :param pulumi.Input[str] target_kogito_runtime: Set this field targeting the desired KogitoRuntime when this KogitoBuild instance has a different name than the KogitoRuntime. By default this KogitoBuild instance will generate a final image named after its own name (.metadata.name). On OpenShift, an ImageStream will be created causing a redeployment on any KogitoRuntime with the same name. On Kubernetes, the final image will be pushed to the KogitoRuntime deployment. If you have multiple KogitoBuild instances (let's say BinaryBuildType and Remote Source), you might need that both target the same KogitoRuntime. Both KogitoBuilds will update the same ImageStream or generate a final image to the same KogitoRuntime deployment.
        :param pulumi.Input[Sequence[pulumi.Input['KogitoBuildSpecWebHooksArgs']]] web_hooks: WebHooks secrets for source to image builds based on Git repositories (Remote Sources).
        """
        pulumi.set(__self__, "type", type)
        if artifact is not None:
            pulumi.set(__self__, "artifact", artifact)
        if build_image is not None:
            pulumi.set(__self__, "build_image", build_image)
        if disable_incremental is not None:
            pulumi.set(__self__, "disable_incremental", disable_incremental)
        if enable_maven_download_output is not None:
            pulumi.set(__self__, "enable_maven_download_output", enable_maven_download_output)
        if env is not None:
            pulumi.set(__self__, "env", env)
        if git_source is not None:
            pulumi.set(__self__, "git_source", git_source)
        if maven_mirror_url is not None:
            pulumi.set(__self__, "maven_mirror_url", maven_mirror_url)
        if native is not None:
            pulumi.set(__self__, "native", native)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if runtime is not None:
            pulumi.set(__self__, "runtime", runtime)
        if runtime_image is not None:
            pulumi.set(__self__, "runtime_image", runtime_image)
        if target_kogito_runtime is not None:
            pulumi.set(__self__, "target_kogito_runtime", target_kogito_runtime)
        if web_hooks is not None:
            pulumi.set(__self__, "web_hooks", web_hooks)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Sets the type of build that this instance will handle: Binary - takes an uploaded binary file already compiled and creates a Kogito service image from it. RemoteSource - pulls the source code from a Git repository, builds the binary and then the final Kogito service image. LocalSource - takes an uploaded resource file such as DRL (rules), DMN (decision) or BPMN (process), builds the binary and the final Kogito service image.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def artifact(self) -> Optional[pulumi.Input['KogitoBuildSpecArtifactArgs']]:
        """
        Artifact contains override information for building the Maven artifact (used for Local Source builds). You might want to override this information when building from decisions, rules or process files. In this scenario the Kogito Images will generate a new Java project for you underneath. This information will be used to generate this project.
        """
        return pulumi.get(self, "artifact")

    @artifact.setter
    def artifact(self, value: Optional[pulumi.Input['KogitoBuildSpecArtifactArgs']]):
        pulumi.set(self, "artifact", value)

    @property
    @pulumi.getter(name="buildImage")
    def build_image(self) -> Optional[pulumi.Input[str]]:
        """
        Image used to build the Kogito Service from source (Local and Remote). The operator will use the one provided by the Kogito Team based on the "Runtime" field. Example: "quay.io/kiegroup/kogito-jvm-builder:latest". On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
        """
        return pulumi.get(self, "build_image")

    @build_image.setter
    def build_image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "build_image", value)

    @property
    @pulumi.getter(name="disableIncremental")
    def disable_incremental(self) -> Optional[pulumi.Input[bool]]:
        """
        DisableIncremental indicates that source to image builds should NOT be incremental. Defaults to false.
        """
        return pulumi.get(self, "disable_incremental")

    @disable_incremental.setter
    def disable_incremental(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_incremental", value)

    @property
    @pulumi.getter(name="enableMavenDownloadOutput")
    def enable_maven_download_output(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true will print the logs for downloading/uploading of maven dependencies. Defaults to false.
        """
        return pulumi.get(self, "enable_maven_download_output")

    @enable_maven_download_output.setter
    def enable_maven_download_output(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_maven_download_output", value)

    @property
    @pulumi.getter
    def env(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KogitoBuildSpecEnvArgs']]]]:
        """
        Environment variables used during build time.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KogitoBuildSpecEnvArgs']]]]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter(name="gitSource")
    def git_source(self) -> Optional[pulumi.Input['KogitoBuildSpecGitSourceArgs']]:
        """
        Information about the git repository where the Kogito Service source code resides. Ignored for binary builds.
        """
        return pulumi.get(self, "git_source")

    @git_source.setter
    def git_source(self, value: Optional[pulumi.Input['KogitoBuildSpecGitSourceArgs']]):
        pulumi.set(self, "git_source", value)

    @property
    @pulumi.getter(name="mavenMirrorURL")
    def maven_mirror_url(self) -> Optional[pulumi.Input[str]]:
        """
        Maven Mirror URL to be used during source-to-image builds (Local and Remote) to considerably increase build speed.
        """
        return pulumi.get(self, "maven_mirror_url")

    @maven_mirror_url.setter
    def maven_mirror_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "maven_mirror_url", value)

    @property
    @pulumi.getter
    def native(self) -> Optional[pulumi.Input[bool]]:
        """
        Native indicates if the Kogito Service built should be compiled to run on native mode when Runtime is Quarkus (Source to Image build only). For more information, see https://www.graalvm.org/docs/reference-manual/aot-compilation/.
        """
        return pulumi.get(self, "native")

    @native.setter
    def native(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "native", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['KogitoBuildSpecResourcesArgs']]:
        """
        Resources Requirements for builder pods.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['KogitoBuildSpecResourcesArgs']]):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter
    def runtime(self) -> Optional[pulumi.Input[str]]:
        """
        Which runtime Kogito service base image to use when building the Kogito service. If "BuildImage" is set, this value is ignored by the operator. Default value: quarkus.
        """
        return pulumi.get(self, "runtime")

    @runtime.setter
    def runtime(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime", value)

    @property
    @pulumi.getter(name="runtimeImage")
    def runtime_image(self) -> Optional[pulumi.Input[str]]:
        """
        Image used as the base image for the final Kogito service. This image only has the required packages to run the application. For example: quarkus based services will have only JVM installed, native services only the packages required by the OS. The operator will use the one provided by the Kogito Team based on the "Runtime" field. Example: "quay.io/kiegroup/kogito-jvm-builder:latest". On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
        """
        return pulumi.get(self, "runtime_image")

    @runtime_image.setter
    def runtime_image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime_image", value)

    @property
    @pulumi.getter(name="targetKogitoRuntime")
    def target_kogito_runtime(self) -> Optional[pulumi.Input[str]]:
        """
        Set this field targeting the desired KogitoRuntime when this KogitoBuild instance has a different name than the KogitoRuntime. By default this KogitoBuild instance will generate a final image named after its own name (.metadata.name). On OpenShift, an ImageStream will be created causing a redeployment on any KogitoRuntime with the same name. On Kubernetes, the final image will be pushed to the KogitoRuntime deployment. If you have multiple KogitoBuild instances (let's say BinaryBuildType and Remote Source), you might need that both target the same KogitoRuntime. Both KogitoBuilds will update the same ImageStream or generate a final image to the same KogitoRuntime deployment.
        """
        return pulumi.get(self, "target_kogito_runtime")

    @target_kogito_runtime.setter
    def target_kogito_runtime(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_kogito_runtime", value)

    @property
    @pulumi.getter(name="webHooks")
    def web_hooks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KogitoBuildSpecWebHooksArgs']]]]:
        """
        WebHooks secrets for source to image builds based on Git repositories (Remote Sources).
        """
        return pulumi.get(self, "web_hooks")

    @web_hooks.setter
    def web_hooks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KogitoBuildSpecWebHooksArgs']]]]):
        pulumi.set(self, "web_hooks", value)


@pulumi.input_type
class KogitoBuildSpecArtifactArgs:
    def __init__(__self__, *,
                 artifact_id: Optional[pulumi.Input[str]] = None,
                 group_id: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        Artifact contains override information for building the Maven artifact (used for Local Source builds). You might want to override this information when building from decisions, rules or process files. In this scenario the Kogito Images will generate a new Java project for you underneath. This information will be used to generate this project.
        :param pulumi.Input[str] artifact_id: Indicates the unique base name of the primary artifact being generated.
        :param pulumi.Input[str] group_id: Indicates the unique identifier of the organization or group that created the project.
        :param pulumi.Input[str] version: Indicates the version of the artifact generated by the project.
        """
        if artifact_id is not None:
            pulumi.set(__self__, "artifact_id", artifact_id)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="artifactId")
    def artifact_id(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates the unique base name of the primary artifact being generated.
        """
        return pulumi.get(self, "artifact_id")

    @artifact_id.setter
    def artifact_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "artifact_id", value)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates the unique identifier of the organization or group that created the project.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates the version of the artifact generated by the project.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class KogitoBuildSpecEnvArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: Optional[pulumi.Input[str]] = None,
                 value_from: Optional[pulumi.Input['KogitoBuildSpecEnvValueFromArgs']] = None):
        """
        EnvVar represents an environment variable present in a Container.
        :param pulumi.Input[str] name: Name of the environment variable. Must be a C_IDENTIFIER.
        :param pulumi.Input[str] value: Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        :param pulumi.Input['KogitoBuildSpecEnvValueFromArgs'] value_from: Source for the environment variable's value. Cannot be used if value is not empty.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_from is not None:
            pulumi.set(__self__, "value_from", value_from)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the environment variable. Must be a C_IDENTIFIER.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="valueFrom")
    def value_from(self) -> Optional[pulumi.Input['KogitoBuildSpecEnvValueFromArgs']]:
        """
        Source for the environment variable's value. Cannot be used if value is not empty.
        """
        return pulumi.get(self, "value_from")

    @value_from.setter
    def value_from(self, value: Optional[pulumi.Input['KogitoBuildSpecEnvValueFromArgs']]):
        pulumi.set(self, "value_from", value)


@pulumi.input_type
class KogitoBuildSpecEnvValueFromArgs:
    def __init__(__self__, *,
                 config_map_key_ref: Optional[pulumi.Input['KogitoBuildSpecEnvValueFromConfigMapKeyRefArgs']] = None,
                 field_ref: Optional[pulumi.Input['KogitoBuildSpecEnvValueFromFieldRefArgs']] = None,
                 resource_field_ref: Optional[pulumi.Input['KogitoBuildSpecEnvValueFromResourceFieldRefArgs']] = None,
                 secret_key_ref: Optional[pulumi.Input['KogitoBuildSpecEnvValueFromSecretKeyRefArgs']] = None):
        """
        Source for the environment variable's value. Cannot be used if value is not empty.
        :param pulumi.Input['KogitoBuildSpecEnvValueFromConfigMapKeyRefArgs'] config_map_key_ref: Selects a key of a ConfigMap.
        :param pulumi.Input['KogitoBuildSpecEnvValueFromFieldRefArgs'] field_ref: Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        :param pulumi.Input['KogitoBuildSpecEnvValueFromResourceFieldRefArgs'] resource_field_ref: Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        :param pulumi.Input['KogitoBuildSpecEnvValueFromSecretKeyRefArgs'] secret_key_ref: Selects a key of a secret in the pod's namespace
        """
        if config_map_key_ref is not None:
            pulumi.set(__self__, "config_map_key_ref", config_map_key_ref)
        if field_ref is not None:
            pulumi.set(__self__, "field_ref", field_ref)
        if resource_field_ref is not None:
            pulumi.set(__self__, "resource_field_ref", resource_field_ref)
        if secret_key_ref is not None:
            pulumi.set(__self__, "secret_key_ref", secret_key_ref)

    @property
    @pulumi.getter(name="configMapKeyRef")
    def config_map_key_ref(self) -> Optional[pulumi.Input['KogitoBuildSpecEnvValueFromConfigMapKeyRefArgs']]:
        """
        Selects a key of a ConfigMap.
        """
        return pulumi.get(self, "config_map_key_ref")

    @config_map_key_ref.setter
    def config_map_key_ref(self, value: Optional[pulumi.Input['KogitoBuildSpecEnvValueFromConfigMapKeyRefArgs']]):
        pulumi.set(self, "config_map_key_ref", value)

    @property
    @pulumi.getter(name="fieldRef")
    def field_ref(self) -> Optional[pulumi.Input['KogitoBuildSpecEnvValueFromFieldRefArgs']]:
        """
        Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        """
        return pulumi.get(self, "field_ref")

    @field_ref.setter
    def field_ref(self, value: Optional[pulumi.Input['KogitoBuildSpecEnvValueFromFieldRefArgs']]):
        pulumi.set(self, "field_ref", value)

    @property
    @pulumi.getter(name="resourceFieldRef")
    def resource_field_ref(self) -> Optional[pulumi.Input['KogitoBuildSpecEnvValueFromResourceFieldRefArgs']]:
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        """
        return pulumi.get(self, "resource_field_ref")

    @resource_field_ref.setter
    def resource_field_ref(self, value: Optional[pulumi.Input['KogitoBuildSpecEnvValueFromResourceFieldRefArgs']]):
        pulumi.set(self, "resource_field_ref", value)

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> Optional[pulumi.Input['KogitoBuildSpecEnvValueFromSecretKeyRefArgs']]:
        """
        Selects a key of a secret in the pod's namespace
        """
        return pulumi.get(self, "secret_key_ref")

    @secret_key_ref.setter
    def secret_key_ref(self, value: Optional[pulumi.Input['KogitoBuildSpecEnvValueFromSecretKeyRefArgs']]):
        pulumi.set(self, "secret_key_ref", value)


@pulumi.input_type
class KogitoBuildSpecEnvValueFromConfigMapKeyRefArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None,
                 optional: Optional[pulumi.Input[bool]] = None):
        """
        Selects a key of a ConfigMap.
        :param pulumi.Input[str] key: The key to select.
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        :param pulumi.Input[bool] optional: Specify whether the ConfigMap or its key must be defined
        """
        pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key to select.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def optional(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify whether the ConfigMap or its key must be defined
        """
        return pulumi.get(self, "optional")

    @optional.setter
    def optional(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "optional", value)


@pulumi.input_type
class KogitoBuildSpecEnvValueFromFieldRefArgs:
    def __init__(__self__, *,
                 field_path: pulumi.Input[str],
                 api_version: Optional[pulumi.Input[str]] = None):
        """
        Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        :param pulumi.Input[str] field_path: Path of the field to select in the specified API version.
        :param pulumi.Input[str] api_version: Version of the schema the FieldPath is written in terms of, defaults to "v1".
        """
        pulumi.set(__self__, "field_path", field_path)
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> pulumi.Input[str]:
        """
        Path of the field to select in the specified API version.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "field_path", value)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of the schema the FieldPath is written in terms of, defaults to "v1".
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)


@pulumi.input_type
class KogitoBuildSpecEnvValueFromResourceFieldRefArgs:
    def __init__(__self__, *,
                 resource: pulumi.Input[str],
                 container_name: Optional[pulumi.Input[str]] = None,
                 divisor: Optional[pulumi.Input['KogitoBuildSpecEnvValueFromResourceFieldRefDivisorArgs']] = None):
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        :param pulumi.Input[str] resource: Required: resource to select
        :param pulumi.Input[str] container_name: Container name: required for volumes, optional for env vars
        :param pulumi.Input['KogitoBuildSpecEnvValueFromResourceFieldRefDivisorArgs'] divisor: Specifies the output format of the exposed resources, defaults to "1"
        """
        pulumi.set(__self__, "resource", resource)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if divisor is not None:
            pulumi.set(__self__, "divisor", divisor)

    @property
    @pulumi.getter
    def resource(self) -> pulumi.Input[str]:
        """
        Required: resource to select
        """
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource", value)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[pulumi.Input[str]]:
        """
        Container name: required for volumes, optional for env vars
        """
        return pulumi.get(self, "container_name")

    @container_name.setter
    def container_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "container_name", value)

    @property
    @pulumi.getter
    def divisor(self) -> Optional[pulumi.Input['KogitoBuildSpecEnvValueFromResourceFieldRefDivisorArgs']]:
        """
        Specifies the output format of the exposed resources, defaults to "1"
        """
        return pulumi.get(self, "divisor")

    @divisor.setter
    def divisor(self, value: Optional[pulumi.Input['KogitoBuildSpecEnvValueFromResourceFieldRefDivisorArgs']]):
        pulumi.set(self, "divisor", value)


@pulumi.input_type
class KogitoBuildSpecEnvValueFromResourceFieldRefDivisorArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class KogitoBuildSpecEnvValueFromSecretKeyRefArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None,
                 optional: Optional[pulumi.Input[bool]] = None):
        """
        Selects a key of a secret in the pod's namespace
        :param pulumi.Input[str] key: The key of the secret to select from.  Must be a valid secret key.
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        :param pulumi.Input[bool] optional: Specify whether the Secret or its key must be defined
        """
        pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key of the secret to select from.  Must be a valid secret key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def optional(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify whether the Secret or its key must be defined
        """
        return pulumi.get(self, "optional")

    @optional.setter
    def optional(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "optional", value)


@pulumi.input_type
class KogitoBuildSpecGitSourceArgs:
    def __init__(__self__, *,
                 uri: pulumi.Input[str],
                 context_dir: Optional[pulumi.Input[str]] = None,
                 reference: Optional[pulumi.Input[str]] = None):
        """
        Information about the git repository where the Kogito Service source code resides. Ignored for binary builds.
        :param pulumi.Input[str] uri: Git URI for the s2i source.
        :param pulumi.Input[str] context_dir: Context/subdirectory where the code is located, relative to the repo root.
        :param pulumi.Input[str] reference: Branch to use in the Git repository.
        """
        pulumi.set(__self__, "uri", uri)
        if context_dir is not None:
            pulumi.set(__self__, "context_dir", context_dir)
        if reference is not None:
            pulumi.set(__self__, "reference", reference)

    @property
    @pulumi.getter
    def uri(self) -> pulumi.Input[str]:
        """
        Git URI for the s2i source.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "uri", value)

    @property
    @pulumi.getter(name="contextDir")
    def context_dir(self) -> Optional[pulumi.Input[str]]:
        """
        Context/subdirectory where the code is located, relative to the repo root.
        """
        return pulumi.get(self, "context_dir")

    @context_dir.setter
    def context_dir(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "context_dir", value)

    @property
    @pulumi.getter
    def reference(self) -> Optional[pulumi.Input[str]]:
        """
        Branch to use in the Git repository.
        """
        return pulumi.get(self, "reference")

    @reference.setter
    def reference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reference", value)


@pulumi.input_type
class KogitoBuildSpecResourcesArgs:
    def __init__(__self__, *,
                 limits: Optional[pulumi.Input[Mapping[str, pulumi.Input['KogitoBuildSpecResourcesLimitsArgs']]]] = None,
                 requests: Optional[pulumi.Input[Mapping[str, pulumi.Input['KogitoBuildSpecResourcesRequestsArgs']]]] = None):
        """
        Resources Requirements for builder pods.
        :param pulumi.Input[Mapping[str, pulumi.Input['KogitoBuildSpecResourcesLimitsArgs']]] limits: Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        :param pulumi.Input[Mapping[str, pulumi.Input['KogitoBuildSpecResourcesRequestsArgs']]] requests: Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['KogitoBuildSpecResourcesLimitsArgs']]]]:
        """
        Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['KogitoBuildSpecResourcesLimitsArgs']]]]):
        pulumi.set(self, "limits", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['KogitoBuildSpecResourcesRequestsArgs']]]]:
        """
        Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['KogitoBuildSpecResourcesRequestsArgs']]]]):
        pulumi.set(self, "requests", value)


@pulumi.input_type
class KogitoBuildSpecResourcesLimitsArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class KogitoBuildSpecResourcesRequestsArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class KogitoBuildSpecWebHooksArgs:
    def __init__(__self__, *,
                 secret: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        WebHookSecret Secret to use for a given webHook.
        :param pulumi.Input[str] secret: Secret value for webHook
        :param pulumi.Input[str] type: WebHook type, either GitHub or Generic.
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        """
        Secret value for webHook
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        WebHook type, either GitHub or Generic.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class KogitoBuildStatusArgs:
    def __init__(__self__, *,
                 builds: pulumi.Input['KogitoBuildStatusBuildsArgs'],
                 conditions: pulumi.Input[Sequence[pulumi.Input['KogitoBuildStatusConditionsArgs']]],
                 latest_build: Optional[pulumi.Input[str]] = None):
        """
        KogitoBuildStatus defines the observed state of KogitoBuild.
        :param pulumi.Input['KogitoBuildStatusBuildsArgs'] builds: History of builds
        :param pulumi.Input[Sequence[pulumi.Input['KogitoBuildStatusConditionsArgs']]] conditions: History of conditions for the resource, shows the status of the younger builder controlled by this instance
        """
        pulumi.set(__self__, "builds", builds)
        pulumi.set(__self__, "conditions", conditions)
        if latest_build is not None:
            pulumi.set(__self__, "latest_build", latest_build)

    @property
    @pulumi.getter
    def builds(self) -> pulumi.Input['KogitoBuildStatusBuildsArgs']:
        """
        History of builds
        """
        return pulumi.get(self, "builds")

    @builds.setter
    def builds(self, value: pulumi.Input['KogitoBuildStatusBuildsArgs']):
        pulumi.set(self, "builds", value)

    @property
    @pulumi.getter
    def conditions(self) -> pulumi.Input[Sequence[pulumi.Input['KogitoBuildStatusConditionsArgs']]]:
        """
        History of conditions for the resource, shows the status of the younger builder controlled by this instance
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: pulumi.Input[Sequence[pulumi.Input['KogitoBuildStatusConditionsArgs']]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="latestBuild")
    def latest_build(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "latest_build")

    @latest_build.setter
    def latest_build(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "latest_build", value)


@pulumi.input_type
class KogitoBuildStatusBuildsArgs:
    def __init__(__self__, *,
                 cancelled: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 complete: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 error: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 failed: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 new: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 pending: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 running: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        History of builds
        :param pulumi.Input[Sequence[pulumi.Input[str]]] cancelled: Builds have been stopped from executing.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] complete: Builds have executed and succeeded.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] error: Builds have been prevented from executing by an error.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] failed: Builds have executed and failed.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] new: Builds are being created.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] pending: Builds are about to start running.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] running: Builds are running.
        """
        if cancelled is not None:
            pulumi.set(__self__, "cancelled", cancelled)
        if complete is not None:
            pulumi.set(__self__, "complete", complete)
        if error is not None:
            pulumi.set(__self__, "error", error)
        if failed is not None:
            pulumi.set(__self__, "failed", failed)
        if new is not None:
            pulumi.set(__self__, "new", new)
        if pending is not None:
            pulumi.set(__self__, "pending", pending)
        if running is not None:
            pulumi.set(__self__, "running", running)

    @property
    @pulumi.getter
    def cancelled(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Builds have been stopped from executing.
        """
        return pulumi.get(self, "cancelled")

    @cancelled.setter
    def cancelled(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "cancelled", value)

    @property
    @pulumi.getter
    def complete(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Builds have executed and succeeded.
        """
        return pulumi.get(self, "complete")

    @complete.setter
    def complete(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "complete", value)

    @property
    @pulumi.getter
    def error(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Builds have been prevented from executing by an error.
        """
        return pulumi.get(self, "error")

    @error.setter
    def error(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "error", value)

    @property
    @pulumi.getter
    def failed(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Builds have executed and failed.
        """
        return pulumi.get(self, "failed")

    @failed.setter
    def failed(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "failed", value)

    @property
    @pulumi.getter
    def new(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Builds are being created.
        """
        return pulumi.get(self, "new")

    @new.setter
    def new(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "new", value)

    @property
    @pulumi.getter
    def pending(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Builds are about to start running.
        """
        return pulumi.get(self, "pending")

    @pending.setter
    def pending(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "pending", value)

    @property
    @pulumi.getter
    def running(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Builds are running.
        """
        return pulumi.get(self, "running")

    @running.setter
    def running(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "running", value)


@pulumi.input_type
class KogitoBuildStatusConditionsArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[str],
                 type: pulumi.Input[str],
                 last_transition_time: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None):
        """
        KogitoBuildConditions describes the conditions for this build instance according to Kubernetes status interface.
        :param pulumi.Input[str] status: Status ...
        :param pulumi.Input[str] type: Type of this condition
        :param pulumi.Input[str] last_transition_time: LastTransitionTime ...
        :param pulumi.Input[str] message: Message ...
        :param pulumi.Input[str] reason: Reason of this condition
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        """
        Status ...
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of this condition
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[pulumi.Input[str]]:
        """
        LastTransitionTime ...
        """
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Message ...
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        Reason of this condition
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)


@pulumi.input_type
class KogitoInfraSpecArgs:
    def __init__(__self__, *,
                 resource: Optional[pulumi.Input['KogitoInfraSpecResourceArgs']] = None):
        """
        KogitoInfraSpec defines the desired state of KogitoInfra.
        :param pulumi.Input['KogitoInfraSpecResourceArgs'] resource: Resource for the service. Example: Infinispan/Kafka/Keycloak.
        """
        if resource is not None:
            pulumi.set(__self__, "resource", resource)

    @property
    @pulumi.getter
    def resource(self) -> Optional[pulumi.Input['KogitoInfraSpecResourceArgs']]:
        """
        Resource for the service. Example: Infinispan/Kafka/Keycloak.
        """
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: Optional[pulumi.Input['KogitoInfraSpecResourceArgs']]):
        pulumi.set(self, "resource", value)


@pulumi.input_type
class KogitoInfraSpecResourceArgs:
    def __init__(__self__, *,
                 api_version: pulumi.Input[str],
                 kind: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None):
        """
        Resource for the service. Example: Infinispan/Kafka/Keycloak.
        :param pulumi.Input[str] api_version: APIVersion describes the API Version of referred Kubernetes resource for example, infinispan.org/v1
        :param pulumi.Input[str] kind: Kind describes the kind of referred Kubernetes resource for example, Infinispan
        :param pulumi.Input[str] name: Name of referred resource.
        :param pulumi.Input[str] namespace: Namespace where referred resource exists.
        """
        pulumi.set(__self__, "api_version", api_version)
        pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> pulumi.Input[str]:
        """
        APIVersion describes the API Version of referred Kubernetes resource for example, infinispan.org/v1
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[str]:
        """
        Kind describes the kind of referred Kubernetes resource for example, Infinispan
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of referred resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace where referred resource exists.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)


@pulumi.input_type
class KogitoInfraStatusArgs:
    def __init__(__self__, *,
                 app_props: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 condition: Optional[pulumi.Input['KogitoInfraStatusConditionArgs']] = None,
                 env: Optional[pulumi.Input[Sequence[pulumi.Input['KogitoInfraStatusEnvArgs']]]] = None,
                 volumes: Optional[pulumi.Input[Sequence[pulumi.Input['KogitoInfraStatusVolumesArgs']]]] = None):
        """
        KogitoInfraStatus defines the observed state of KogitoInfra.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] app_props: Application properties extracted from the linked resource that will be added to the deployed Kogito service.
        :param pulumi.Input['KogitoInfraStatusConditionArgs'] condition: KogitoInfraCondition ...
        :param pulumi.Input[Sequence[pulumi.Input['KogitoInfraStatusEnvArgs']]] env: Environment variables extracted from the linked resource that will be added to the deployed Kogito service.
        :param pulumi.Input[Sequence[pulumi.Input['KogitoInfraStatusVolumesArgs']]] volumes: List of volumes that should be added to the services bound to this infra instance
        """
        if app_props is not None:
            pulumi.set(__self__, "app_props", app_props)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if env is not None:
            pulumi.set(__self__, "env", env)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @property
    @pulumi.getter(name="appProps")
    def app_props(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Application properties extracted from the linked resource that will be added to the deployed Kogito service.
        """
        return pulumi.get(self, "app_props")

    @app_props.setter
    def app_props(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "app_props", value)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input['KogitoInfraStatusConditionArgs']]:
        """
        KogitoInfraCondition ...
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input['KogitoInfraStatusConditionArgs']]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def env(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KogitoInfraStatusEnvArgs']]]]:
        """
        Environment variables extracted from the linked resource that will be added to the deployed Kogito service.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KogitoInfraStatusEnvArgs']]]]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def volumes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KogitoInfraStatusVolumesArgs']]]]:
        """
        List of volumes that should be added to the services bound to this infra instance
        """
        return pulumi.get(self, "volumes")

    @volumes.setter
    def volumes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KogitoInfraStatusVolumesArgs']]]]):
        pulumi.set(self, "volumes", value)


@pulumi.input_type
class KogitoInfraStatusConditionArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[str],
                 type: pulumi.Input[str],
                 last_transition_time: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None):
        """
        KogitoInfraCondition ...
        :param pulumi.Input[str] status: Status ...
        :param pulumi.Input[str] type: Type ...
        :param pulumi.Input[str] last_transition_time: LastTransitionTime ...
        :param pulumi.Input[str] message: Message ...
        :param pulumi.Input[str] reason: Reason ...
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        """
        Status ...
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type ...
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[pulumi.Input[str]]:
        """
        LastTransitionTime ...
        """
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Message ...
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        Reason ...
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)


@pulumi.input_type
class KogitoInfraStatusEnvArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: Optional[pulumi.Input[str]] = None,
                 value_from: Optional[pulumi.Input['KogitoInfraStatusEnvValueFromArgs']] = None):
        """
        EnvVar represents an environment variable present in a Container.
        :param pulumi.Input[str] name: Name of the environment variable. Must be a C_IDENTIFIER.
        :param pulumi.Input[str] value: Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        :param pulumi.Input['KogitoInfraStatusEnvValueFromArgs'] value_from: Source for the environment variable's value. Cannot be used if value is not empty.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_from is not None:
            pulumi.set(__self__, "value_from", value_from)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the environment variable. Must be a C_IDENTIFIER.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="valueFrom")
    def value_from(self) -> Optional[pulumi.Input['KogitoInfraStatusEnvValueFromArgs']]:
        """
        Source for the environment variable's value. Cannot be used if value is not empty.
        """
        return pulumi.get(self, "value_from")

    @value_from.setter
    def value_from(self, value: Optional[pulumi.Input['KogitoInfraStatusEnvValueFromArgs']]):
        pulumi.set(self, "value_from", value)


@pulumi.input_type
class KogitoInfraStatusEnvValueFromArgs:
    def __init__(__self__, *,
                 config_map_key_ref: Optional[pulumi.Input['KogitoInfraStatusEnvValueFromConfigMapKeyRefArgs']] = None,
                 field_ref: Optional[pulumi.Input['KogitoInfraStatusEnvValueFromFieldRefArgs']] = None,
                 resource_field_ref: Optional[pulumi.Input['KogitoInfraStatusEnvValueFromResourceFieldRefArgs']] = None,
                 secret_key_ref: Optional[pulumi.Input['KogitoInfraStatusEnvValueFromSecretKeyRefArgs']] = None):
        """
        Source for the environment variable's value. Cannot be used if value is not empty.
        :param pulumi.Input['KogitoInfraStatusEnvValueFromConfigMapKeyRefArgs'] config_map_key_ref: Selects a key of a ConfigMap.
        :param pulumi.Input['KogitoInfraStatusEnvValueFromFieldRefArgs'] field_ref: Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        :param pulumi.Input['KogitoInfraStatusEnvValueFromResourceFieldRefArgs'] resource_field_ref: Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        :param pulumi.Input['KogitoInfraStatusEnvValueFromSecretKeyRefArgs'] secret_key_ref: Selects a key of a secret in the pod's namespace
        """
        if config_map_key_ref is not None:
            pulumi.set(__self__, "config_map_key_ref", config_map_key_ref)
        if field_ref is not None:
            pulumi.set(__self__, "field_ref", field_ref)
        if resource_field_ref is not None:
            pulumi.set(__self__, "resource_field_ref", resource_field_ref)
        if secret_key_ref is not None:
            pulumi.set(__self__, "secret_key_ref", secret_key_ref)

    @property
    @pulumi.getter(name="configMapKeyRef")
    def config_map_key_ref(self) -> Optional[pulumi.Input['KogitoInfraStatusEnvValueFromConfigMapKeyRefArgs']]:
        """
        Selects a key of a ConfigMap.
        """
        return pulumi.get(self, "config_map_key_ref")

    @config_map_key_ref.setter
    def config_map_key_ref(self, value: Optional[pulumi.Input['KogitoInfraStatusEnvValueFromConfigMapKeyRefArgs']]):
        pulumi.set(self, "config_map_key_ref", value)

    @property
    @pulumi.getter(name="fieldRef")
    def field_ref(self) -> Optional[pulumi.Input['KogitoInfraStatusEnvValueFromFieldRefArgs']]:
        """
        Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        """
        return pulumi.get(self, "field_ref")

    @field_ref.setter
    def field_ref(self, value: Optional[pulumi.Input['KogitoInfraStatusEnvValueFromFieldRefArgs']]):
        pulumi.set(self, "field_ref", value)

    @property
    @pulumi.getter(name="resourceFieldRef")
    def resource_field_ref(self) -> Optional[pulumi.Input['KogitoInfraStatusEnvValueFromResourceFieldRefArgs']]:
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        """
        return pulumi.get(self, "resource_field_ref")

    @resource_field_ref.setter
    def resource_field_ref(self, value: Optional[pulumi.Input['KogitoInfraStatusEnvValueFromResourceFieldRefArgs']]):
        pulumi.set(self, "resource_field_ref", value)

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> Optional[pulumi.Input['KogitoInfraStatusEnvValueFromSecretKeyRefArgs']]:
        """
        Selects a key of a secret in the pod's namespace
        """
        return pulumi.get(self, "secret_key_ref")

    @secret_key_ref.setter
    def secret_key_ref(self, value: Optional[pulumi.Input['KogitoInfraStatusEnvValueFromSecretKeyRefArgs']]):
        pulumi.set(self, "secret_key_ref", value)


@pulumi.input_type
class KogitoInfraStatusEnvValueFromConfigMapKeyRefArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None,
                 optional: Optional[pulumi.Input[bool]] = None):
        """
        Selects a key of a ConfigMap.
        :param pulumi.Input[str] key: The key to select.
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        :param pulumi.Input[bool] optional: Specify whether the ConfigMap or its key must be defined
        """
        pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key to select.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def optional(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify whether the ConfigMap or its key must be defined
        """
        return pulumi.get(self, "optional")

    @optional.setter
    def optional(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "optional", value)


@pulumi.input_type
class KogitoInfraStatusEnvValueFromFieldRefArgs:
    def __init__(__self__, *,
                 field_path: pulumi.Input[str],
                 api_version: Optional[pulumi.Input[str]] = None):
        """
        Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        :param pulumi.Input[str] field_path: Path of the field to select in the specified API version.
        :param pulumi.Input[str] api_version: Version of the schema the FieldPath is written in terms of, defaults to "v1".
        """
        pulumi.set(__self__, "field_path", field_path)
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> pulumi.Input[str]:
        """
        Path of the field to select in the specified API version.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "field_path", value)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of the schema the FieldPath is written in terms of, defaults to "v1".
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)


@pulumi.input_type
class KogitoInfraStatusEnvValueFromResourceFieldRefArgs:
    def __init__(__self__, *,
                 resource: pulumi.Input[str],
                 container_name: Optional[pulumi.Input[str]] = None,
                 divisor: Optional[pulumi.Input['KogitoInfraStatusEnvValueFromResourceFieldRefDivisorArgs']] = None):
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        :param pulumi.Input[str] resource: Required: resource to select
        :param pulumi.Input[str] container_name: Container name: required for volumes, optional for env vars
        :param pulumi.Input['KogitoInfraStatusEnvValueFromResourceFieldRefDivisorArgs'] divisor: Specifies the output format of the exposed resources, defaults to "1"
        """
        pulumi.set(__self__, "resource", resource)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if divisor is not None:
            pulumi.set(__self__, "divisor", divisor)

    @property
    @pulumi.getter
    def resource(self) -> pulumi.Input[str]:
        """
        Required: resource to select
        """
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource", value)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[pulumi.Input[str]]:
        """
        Container name: required for volumes, optional for env vars
        """
        return pulumi.get(self, "container_name")

    @container_name.setter
    def container_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "container_name", value)

    @property
    @pulumi.getter
    def divisor(self) -> Optional[pulumi.Input['KogitoInfraStatusEnvValueFromResourceFieldRefDivisorArgs']]:
        """
        Specifies the output format of the exposed resources, defaults to "1"
        """
        return pulumi.get(self, "divisor")

    @divisor.setter
    def divisor(self, value: Optional[pulumi.Input['KogitoInfraStatusEnvValueFromResourceFieldRefDivisorArgs']]):
        pulumi.set(self, "divisor", value)


@pulumi.input_type
class KogitoInfraStatusEnvValueFromResourceFieldRefDivisorArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class KogitoInfraStatusEnvValueFromSecretKeyRefArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None,
                 optional: Optional[pulumi.Input[bool]] = None):
        """
        Selects a key of a secret in the pod's namespace
        :param pulumi.Input[str] key: The key of the secret to select from.  Must be a valid secret key.
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        :param pulumi.Input[bool] optional: Specify whether the Secret or its key must be defined
        """
        pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key of the secret to select from.  Must be a valid secret key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def optional(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify whether the Secret or its key must be defined
        """
        return pulumi.get(self, "optional")

    @optional.setter
    def optional(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "optional", value)


@pulumi.input_type
class KogitoInfraStatusVolumesArgs:
    def __init__(__self__, *,
                 mount: pulumi.Input['KogitoInfraStatusVolumesMountArgs'],
                 volume: pulumi.Input['KogitoInfraStatusVolumesVolumeArgs']):
        """
        KogitoInfraVolume describes the data structure for volumes that should be mounted in the given service provided by this infra instance
        :param pulumi.Input['KogitoInfraStatusVolumesMountArgs'] mount: Mount is the Kubernetes VolumeMount referenced by this instance
        :param pulumi.Input['KogitoInfraStatusVolumesVolumeArgs'] volume: NamedVolume describes the pod Volume reference
        """
        pulumi.set(__self__, "mount", mount)
        pulumi.set(__self__, "volume", volume)

    @property
    @pulumi.getter
    def mount(self) -> pulumi.Input['KogitoInfraStatusVolumesMountArgs']:
        """
        Mount is the Kubernetes VolumeMount referenced by this instance
        """
        return pulumi.get(self, "mount")

    @mount.setter
    def mount(self, value: pulumi.Input['KogitoInfraStatusVolumesMountArgs']):
        pulumi.set(self, "mount", value)

    @property
    @pulumi.getter
    def volume(self) -> pulumi.Input['KogitoInfraStatusVolumesVolumeArgs']:
        """
        NamedVolume describes the pod Volume reference
        """
        return pulumi.get(self, "volume")

    @volume.setter
    def volume(self, value: pulumi.Input['KogitoInfraStatusVolumesVolumeArgs']):
        pulumi.set(self, "volume", value)


@pulumi.input_type
class KogitoInfraStatusVolumesMountArgs:
    def __init__(__self__, *,
                 mount_path: pulumi.Input[str],
                 name: pulumi.Input[str],
                 mount_propagation: Optional[pulumi.Input[str]] = None,
                 read_only: Optional[pulumi.Input[bool]] = None,
                 sub_path: Optional[pulumi.Input[str]] = None,
                 sub_path_expr: Optional[pulumi.Input[str]] = None):
        """
        Mount is the Kubernetes VolumeMount referenced by this instance
        :param pulumi.Input[str] mount_path: Path within the container at which the volume should be mounted.  Must not contain ':'.
        :param pulumi.Input[str] name: This must match the Name of a Volume.
        :param pulumi.Input[str] mount_propagation: mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
        :param pulumi.Input[bool] read_only: Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
        :param pulumi.Input[str] sub_path: Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
        :param pulumi.Input[str] sub_path_expr: Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
        """
        pulumi.set(__self__, "mount_path", mount_path)
        pulumi.set(__self__, "name", name)
        if mount_propagation is not None:
            pulumi.set(__self__, "mount_propagation", mount_propagation)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if sub_path is not None:
            pulumi.set(__self__, "sub_path", sub_path)
        if sub_path_expr is not None:
            pulumi.set(__self__, "sub_path_expr", sub_path_expr)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> pulumi.Input[str]:
        """
        Path within the container at which the volume should be mounted.  Must not contain ':'.
        """
        return pulumi.get(self, "mount_path")

    @mount_path.setter
    def mount_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "mount_path", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        This must match the Name of a Volume.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="mountPropagation")
    def mount_propagation(self) -> Optional[pulumi.Input[str]]:
        """
        mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
        """
        return pulumi.get(self, "mount_propagation")

    @mount_propagation.setter
    def mount_propagation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_propagation", value)

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[pulumi.Input[bool]]:
        """
        Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
        """
        return pulumi.get(self, "read_only")

    @read_only.setter
    def read_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "read_only", value)

    @property
    @pulumi.getter(name="subPath")
    def sub_path(self) -> Optional[pulumi.Input[str]]:
        """
        Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
        """
        return pulumi.get(self, "sub_path")

    @sub_path.setter
    def sub_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sub_path", value)

    @property
    @pulumi.getter(name="subPathExpr")
    def sub_path_expr(self) -> Optional[pulumi.Input[str]]:
        """
        Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
        """
        return pulumi.get(self, "sub_path_expr")

    @sub_path_expr.setter
    def sub_path_expr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sub_path_expr", value)


@pulumi.input_type
class KogitoInfraStatusVolumesVolumeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 config_map: Optional[pulumi.Input['KogitoInfraStatusVolumesVolumeConfigMapArgs']] = None,
                 secret: Optional[pulumi.Input['KogitoInfraStatusVolumesVolumeSecretArgs']] = None):
        """
        NamedVolume describes the pod Volume reference
        :param pulumi.Input[str] name: Volume's name. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        :param pulumi.Input['KogitoInfraStatusVolumesVolumeConfigMapArgs'] config_map: ConfigMap represents a configMap that should populate this volume
        :param pulumi.Input['KogitoInfraStatusVolumesVolumeSecretArgs'] secret: Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
        """
        pulumi.set(__self__, "name", name)
        if config_map is not None:
            pulumi.set(__self__, "config_map", config_map)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Volume's name. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="configMap")
    def config_map(self) -> Optional[pulumi.Input['KogitoInfraStatusVolumesVolumeConfigMapArgs']]:
        """
        ConfigMap represents a configMap that should populate this volume
        """
        return pulumi.get(self, "config_map")

    @config_map.setter
    def config_map(self, value: Optional[pulumi.Input['KogitoInfraStatusVolumesVolumeConfigMapArgs']]):
        pulumi.set(self, "config_map", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input['KogitoInfraStatusVolumesVolumeSecretArgs']]:
        """
        Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input['KogitoInfraStatusVolumesVolumeSecretArgs']]):
        pulumi.set(self, "secret", value)


@pulumi.input_type
class KogitoInfraStatusVolumesVolumeConfigMapArgs:
    def __init__(__self__, *,
                 default_mode: Optional[pulumi.Input[int]] = None,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['KogitoInfraStatusVolumesVolumeConfigMapItemsArgs']]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 optional: Optional[pulumi.Input[bool]] = None):
        """
        ConfigMap represents a configMap that should populate this volume
        :param pulumi.Input[int] default_mode: Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        :param pulumi.Input[Sequence[pulumi.Input['KogitoInfraStatusVolumesVolumeConfigMapItemsArgs']]] items: If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        :param pulumi.Input[bool] optional: Specify whether the ConfigMap or its keys must be defined
        """
        if default_mode is not None:
            pulumi.set(__self__, "default_mode", default_mode)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter(name="defaultMode")
    def default_mode(self) -> Optional[pulumi.Input[int]]:
        """
        Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        return pulumi.get(self, "default_mode")

    @default_mode.setter
    def default_mode(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "default_mode", value)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KogitoInfraStatusVolumesVolumeConfigMapItemsArgs']]]]:
        """
        If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KogitoInfraStatusVolumesVolumeConfigMapItemsArgs']]]]):
        pulumi.set(self, "items", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def optional(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify whether the ConfigMap or its keys must be defined
        """
        return pulumi.get(self, "optional")

    @optional.setter
    def optional(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "optional", value)


@pulumi.input_type
class KogitoInfraStatusVolumesVolumeConfigMapItemsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 path: pulumi.Input[str],
                 mode: Optional[pulumi.Input[int]] = None):
        """
        Maps a string key to a path within a volume.
        :param pulumi.Input[str] key: The key to project.
        :param pulumi.Input[str] path: The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
        :param pulumi.Input[int] mode: Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "path", path)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key to project.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[int]]:
        """
        Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "mode", value)


@pulumi.input_type
class KogitoInfraStatusVolumesVolumeSecretArgs:
    def __init__(__self__, *,
                 default_mode: Optional[pulumi.Input[int]] = None,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['KogitoInfraStatusVolumesVolumeSecretItemsArgs']]]] = None,
                 optional: Optional[pulumi.Input[bool]] = None,
                 secret_name: Optional[pulumi.Input[str]] = None):
        """
        Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
        :param pulumi.Input[int] default_mode: Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        :param pulumi.Input[Sequence[pulumi.Input['KogitoInfraStatusVolumesVolumeSecretItemsArgs']]] items: If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
        :param pulumi.Input[bool] optional: Specify whether the Secret or its keys must be defined
        :param pulumi.Input[str] secret_name: Name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
        """
        if default_mode is not None:
            pulumi.set(__self__, "default_mode", default_mode)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="defaultMode")
    def default_mode(self) -> Optional[pulumi.Input[int]]:
        """
        Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        return pulumi.get(self, "default_mode")

    @default_mode.setter
    def default_mode(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "default_mode", value)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KogitoInfraStatusVolumesVolumeSecretItemsArgs']]]]:
        """
        If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KogitoInfraStatusVolumesVolumeSecretItemsArgs']]]]):
        pulumi.set(self, "items", value)

    @property
    @pulumi.getter
    def optional(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify whether the Secret or its keys must be defined
        """
        return pulumi.get(self, "optional")

    @optional.setter
    def optional(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "optional", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KogitoInfraStatusVolumesVolumeSecretItemsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 path: pulumi.Input[str],
                 mode: Optional[pulumi.Input[int]] = None):
        """
        Maps a string key to a path within a volume.
        :param pulumi.Input[str] key: The key to project.
        :param pulumi.Input[str] path: The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
        :param pulumi.Input[int] mode: Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "path", path)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key to project.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[int]]:
        """
        Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "mode", value)


@pulumi.input_type
class KogitoRuntimeSpecArgs:
    def __init__(__self__, *,
                 config: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 deployment_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 enable_istio: Optional[pulumi.Input[bool]] = None,
                 env: Optional[pulumi.Input[Sequence[pulumi.Input['KogitoRuntimeSpecEnvArgs']]]] = None,
                 image: Optional[pulumi.Input[str]] = None,
                 infra: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 insecure_image_registry: Optional[pulumi.Input[bool]] = None,
                 monitoring: Optional[pulumi.Input['KogitoRuntimeSpecMonitoringArgs']] = None,
                 properties_config_map: Optional[pulumi.Input[str]] = None,
                 replicas: Optional[pulumi.Input[int]] = None,
                 resources: Optional[pulumi.Input['KogitoRuntimeSpecResourcesArgs']] = None,
                 runtime: Optional[pulumi.Input[str]] = None,
                 service_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        KogitoRuntimeSpec defines the desired state of KogitoRuntime.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] config: Application properties that will be set to the service. For example 'MY_VAR: my_value'.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] deployment_labels: Additional labels to be added to the Deployment and Pods managed by the operator.
        :param pulumi.Input[bool] enable_istio: Annotates the pods managed by the operator with the required metadata for Istio to setup its sidecars, enabling the mesh. Defaults to false.
        :param pulumi.Input[Sequence[pulumi.Input['KogitoRuntimeSpecEnvArgs']]] env: Environment variables to be added to the runtime container. Keys must be a C_IDENTIFIER.
        :param pulumi.Input[str] image: Image definition for the service. Example: "quay.io/kiegroup/kogito-service:latest". On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] infra: Infra provides list of dependent KogitoInfra objects.
        :param pulumi.Input[bool] insecure_image_registry: A flag indicating that image streams created by Kogito Operator should be configured to allow pulling from insecure registries. Usable just on OpenShift. Defaults to 'false'.
        :param pulumi.Input['KogitoRuntimeSpecMonitoringArgs'] monitoring: Create Service monitor instance to connect with Monitoring service
        :param pulumi.Input[str] properties_config_map: Custom ConfigMap with application.properties file to be mounted for the Kogito service. The ConfigMap must be created in the same namespace. Use this property if you need custom properties to be mounted before the application deployment. If left empty, one will be created for you. Later it can be updated to add any custom properties to apply to the service.
        :param pulumi.Input[int] replicas: Number of replicas that the service will have deployed in the cluster. Default value: 1.
        :param pulumi.Input['KogitoRuntimeSpecResourcesArgs'] resources: Defined compute resource requirements for the deployed service.
        :param pulumi.Input[str] runtime: The name of the runtime used, either Quarkus or SpringBoot. Default value: quarkus
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] service_labels: Additional labels to be added to the Service managed by the operator.
        """
        if config is not None:
            pulumi.set(__self__, "config", config)
        if deployment_labels is not None:
            pulumi.set(__self__, "deployment_labels", deployment_labels)
        if enable_istio is not None:
            pulumi.set(__self__, "enable_istio", enable_istio)
        if env is not None:
            pulumi.set(__self__, "env", env)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if infra is not None:
            pulumi.set(__self__, "infra", infra)
        if insecure_image_registry is not None:
            pulumi.set(__self__, "insecure_image_registry", insecure_image_registry)
        if monitoring is not None:
            pulumi.set(__self__, "monitoring", monitoring)
        if properties_config_map is not None:
            pulumi.set(__self__, "properties_config_map", properties_config_map)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if runtime is not None:
            pulumi.set(__self__, "runtime", runtime)
        if service_labels is not None:
            pulumi.set(__self__, "service_labels", service_labels)

    @property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Application properties that will be set to the service. For example 'MY_VAR: my_value'.
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "config", value)

    @property
    @pulumi.getter(name="deploymentLabels")
    def deployment_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional labels to be added to the Deployment and Pods managed by the operator.
        """
        return pulumi.get(self, "deployment_labels")

    @deployment_labels.setter
    def deployment_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "deployment_labels", value)

    @property
    @pulumi.getter(name="enableIstio")
    def enable_istio(self) -> Optional[pulumi.Input[bool]]:
        """
        Annotates the pods managed by the operator with the required metadata for Istio to setup its sidecars, enabling the mesh. Defaults to false.
        """
        return pulumi.get(self, "enable_istio")

    @enable_istio.setter
    def enable_istio(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_istio", value)

    @property
    @pulumi.getter
    def env(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KogitoRuntimeSpecEnvArgs']]]]:
        """
        Environment variables to be added to the runtime container. Keys must be a C_IDENTIFIER.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KogitoRuntimeSpecEnvArgs']]]]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        Image definition for the service. Example: "quay.io/kiegroup/kogito-service:latest". On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter
    def infra(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Infra provides list of dependent KogitoInfra objects.
        """
        return pulumi.get(self, "infra")

    @infra.setter
    def infra(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "infra", value)

    @property
    @pulumi.getter(name="insecureImageRegistry")
    def insecure_image_registry(self) -> Optional[pulumi.Input[bool]]:
        """
        A flag indicating that image streams created by Kogito Operator should be configured to allow pulling from insecure registries. Usable just on OpenShift. Defaults to 'false'.
        """
        return pulumi.get(self, "insecure_image_registry")

    @insecure_image_registry.setter
    def insecure_image_registry(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "insecure_image_registry", value)

    @property
    @pulumi.getter
    def monitoring(self) -> Optional[pulumi.Input['KogitoRuntimeSpecMonitoringArgs']]:
        """
        Create Service monitor instance to connect with Monitoring service
        """
        return pulumi.get(self, "monitoring")

    @monitoring.setter
    def monitoring(self, value: Optional[pulumi.Input['KogitoRuntimeSpecMonitoringArgs']]):
        pulumi.set(self, "monitoring", value)

    @property
    @pulumi.getter(name="propertiesConfigMap")
    def properties_config_map(self) -> Optional[pulumi.Input[str]]:
        """
        Custom ConfigMap with application.properties file to be mounted for the Kogito service. The ConfigMap must be created in the same namespace. Use this property if you need custom properties to be mounted before the application deployment. If left empty, one will be created for you. Later it can be updated to add any custom properties to apply to the service.
        """
        return pulumi.get(self, "properties_config_map")

    @properties_config_map.setter
    def properties_config_map(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "properties_config_map", value)

    @property
    @pulumi.getter
    def replicas(self) -> Optional[pulumi.Input[int]]:
        """
        Number of replicas that the service will have deployed in the cluster. Default value: 1.
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "replicas", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['KogitoRuntimeSpecResourcesArgs']]:
        """
        Defined compute resource requirements for the deployed service.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['KogitoRuntimeSpecResourcesArgs']]):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter
    def runtime(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the runtime used, either Quarkus or SpringBoot. Default value: quarkus
        """
        return pulumi.get(self, "runtime")

    @runtime.setter
    def runtime(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime", value)

    @property
    @pulumi.getter(name="serviceLabels")
    def service_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional labels to be added to the Service managed by the operator.
        """
        return pulumi.get(self, "service_labels")

    @service_labels.setter
    def service_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "service_labels", value)


@pulumi.input_type
class KogitoRuntimeSpecEnvArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: Optional[pulumi.Input[str]] = None,
                 value_from: Optional[pulumi.Input['KogitoRuntimeSpecEnvValueFromArgs']] = None):
        """
        EnvVar represents an environment variable present in a Container.
        :param pulumi.Input[str] name: Name of the environment variable. Must be a C_IDENTIFIER.
        :param pulumi.Input[str] value: Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        :param pulumi.Input['KogitoRuntimeSpecEnvValueFromArgs'] value_from: Source for the environment variable's value. Cannot be used if value is not empty.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_from is not None:
            pulumi.set(__self__, "value_from", value_from)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the environment variable. Must be a C_IDENTIFIER.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="valueFrom")
    def value_from(self) -> Optional[pulumi.Input['KogitoRuntimeSpecEnvValueFromArgs']]:
        """
        Source for the environment variable's value. Cannot be used if value is not empty.
        """
        return pulumi.get(self, "value_from")

    @value_from.setter
    def value_from(self, value: Optional[pulumi.Input['KogitoRuntimeSpecEnvValueFromArgs']]):
        pulumi.set(self, "value_from", value)


@pulumi.input_type
class KogitoRuntimeSpecEnvValueFromArgs:
    def __init__(__self__, *,
                 config_map_key_ref: Optional[pulumi.Input['KogitoRuntimeSpecEnvValueFromConfigMapKeyRefArgs']] = None,
                 field_ref: Optional[pulumi.Input['KogitoRuntimeSpecEnvValueFromFieldRefArgs']] = None,
                 resource_field_ref: Optional[pulumi.Input['KogitoRuntimeSpecEnvValueFromResourceFieldRefArgs']] = None,
                 secret_key_ref: Optional[pulumi.Input['KogitoRuntimeSpecEnvValueFromSecretKeyRefArgs']] = None):
        """
        Source for the environment variable's value. Cannot be used if value is not empty.
        :param pulumi.Input['KogitoRuntimeSpecEnvValueFromConfigMapKeyRefArgs'] config_map_key_ref: Selects a key of a ConfigMap.
        :param pulumi.Input['KogitoRuntimeSpecEnvValueFromFieldRefArgs'] field_ref: Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        :param pulumi.Input['KogitoRuntimeSpecEnvValueFromResourceFieldRefArgs'] resource_field_ref: Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        :param pulumi.Input['KogitoRuntimeSpecEnvValueFromSecretKeyRefArgs'] secret_key_ref: Selects a key of a secret in the pod's namespace
        """
        if config_map_key_ref is not None:
            pulumi.set(__self__, "config_map_key_ref", config_map_key_ref)
        if field_ref is not None:
            pulumi.set(__self__, "field_ref", field_ref)
        if resource_field_ref is not None:
            pulumi.set(__self__, "resource_field_ref", resource_field_ref)
        if secret_key_ref is not None:
            pulumi.set(__self__, "secret_key_ref", secret_key_ref)

    @property
    @pulumi.getter(name="configMapKeyRef")
    def config_map_key_ref(self) -> Optional[pulumi.Input['KogitoRuntimeSpecEnvValueFromConfigMapKeyRefArgs']]:
        """
        Selects a key of a ConfigMap.
        """
        return pulumi.get(self, "config_map_key_ref")

    @config_map_key_ref.setter
    def config_map_key_ref(self, value: Optional[pulumi.Input['KogitoRuntimeSpecEnvValueFromConfigMapKeyRefArgs']]):
        pulumi.set(self, "config_map_key_ref", value)

    @property
    @pulumi.getter(name="fieldRef")
    def field_ref(self) -> Optional[pulumi.Input['KogitoRuntimeSpecEnvValueFromFieldRefArgs']]:
        """
        Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        """
        return pulumi.get(self, "field_ref")

    @field_ref.setter
    def field_ref(self, value: Optional[pulumi.Input['KogitoRuntimeSpecEnvValueFromFieldRefArgs']]):
        pulumi.set(self, "field_ref", value)

    @property
    @pulumi.getter(name="resourceFieldRef")
    def resource_field_ref(self) -> Optional[pulumi.Input['KogitoRuntimeSpecEnvValueFromResourceFieldRefArgs']]:
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        """
        return pulumi.get(self, "resource_field_ref")

    @resource_field_ref.setter
    def resource_field_ref(self, value: Optional[pulumi.Input['KogitoRuntimeSpecEnvValueFromResourceFieldRefArgs']]):
        pulumi.set(self, "resource_field_ref", value)

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> Optional[pulumi.Input['KogitoRuntimeSpecEnvValueFromSecretKeyRefArgs']]:
        """
        Selects a key of a secret in the pod's namespace
        """
        return pulumi.get(self, "secret_key_ref")

    @secret_key_ref.setter
    def secret_key_ref(self, value: Optional[pulumi.Input['KogitoRuntimeSpecEnvValueFromSecretKeyRefArgs']]):
        pulumi.set(self, "secret_key_ref", value)


@pulumi.input_type
class KogitoRuntimeSpecEnvValueFromConfigMapKeyRefArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None,
                 optional: Optional[pulumi.Input[bool]] = None):
        """
        Selects a key of a ConfigMap.
        :param pulumi.Input[str] key: The key to select.
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        :param pulumi.Input[bool] optional: Specify whether the ConfigMap or its key must be defined
        """
        pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key to select.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def optional(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify whether the ConfigMap or its key must be defined
        """
        return pulumi.get(self, "optional")

    @optional.setter
    def optional(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "optional", value)


@pulumi.input_type
class KogitoRuntimeSpecEnvValueFromFieldRefArgs:
    def __init__(__self__, *,
                 field_path: pulumi.Input[str],
                 api_version: Optional[pulumi.Input[str]] = None):
        """
        Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        :param pulumi.Input[str] field_path: Path of the field to select in the specified API version.
        :param pulumi.Input[str] api_version: Version of the schema the FieldPath is written in terms of, defaults to "v1".
        """
        pulumi.set(__self__, "field_path", field_path)
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> pulumi.Input[str]:
        """
        Path of the field to select in the specified API version.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "field_path", value)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of the schema the FieldPath is written in terms of, defaults to "v1".
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)


@pulumi.input_type
class KogitoRuntimeSpecEnvValueFromResourceFieldRefArgs:
    def __init__(__self__, *,
                 resource: pulumi.Input[str],
                 container_name: Optional[pulumi.Input[str]] = None,
                 divisor: Optional[pulumi.Input['KogitoRuntimeSpecEnvValueFromResourceFieldRefDivisorArgs']] = None):
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        :param pulumi.Input[str] resource: Required: resource to select
        :param pulumi.Input[str] container_name: Container name: required for volumes, optional for env vars
        :param pulumi.Input['KogitoRuntimeSpecEnvValueFromResourceFieldRefDivisorArgs'] divisor: Specifies the output format of the exposed resources, defaults to "1"
        """
        pulumi.set(__self__, "resource", resource)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if divisor is not None:
            pulumi.set(__self__, "divisor", divisor)

    @property
    @pulumi.getter
    def resource(self) -> pulumi.Input[str]:
        """
        Required: resource to select
        """
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource", value)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[pulumi.Input[str]]:
        """
        Container name: required for volumes, optional for env vars
        """
        return pulumi.get(self, "container_name")

    @container_name.setter
    def container_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "container_name", value)

    @property
    @pulumi.getter
    def divisor(self) -> Optional[pulumi.Input['KogitoRuntimeSpecEnvValueFromResourceFieldRefDivisorArgs']]:
        """
        Specifies the output format of the exposed resources, defaults to "1"
        """
        return pulumi.get(self, "divisor")

    @divisor.setter
    def divisor(self, value: Optional[pulumi.Input['KogitoRuntimeSpecEnvValueFromResourceFieldRefDivisorArgs']]):
        pulumi.set(self, "divisor", value)


@pulumi.input_type
class KogitoRuntimeSpecEnvValueFromResourceFieldRefDivisorArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class KogitoRuntimeSpecEnvValueFromSecretKeyRefArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None,
                 optional: Optional[pulumi.Input[bool]] = None):
        """
        Selects a key of a secret in the pod's namespace
        :param pulumi.Input[str] key: The key of the secret to select from.  Must be a valid secret key.
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        :param pulumi.Input[bool] optional: Specify whether the Secret or its key must be defined
        """
        pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key of the secret to select from.  Must be a valid secret key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def optional(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify whether the Secret or its key must be defined
        """
        return pulumi.get(self, "optional")

    @optional.setter
    def optional(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "optional", value)


@pulumi.input_type
class KogitoRuntimeSpecMonitoringArgs:
    def __init__(__self__, *,
                 path: Optional[pulumi.Input[str]] = None,
                 scheme: Optional[pulumi.Input[str]] = None):
        """
        Create Service monitor instance to connect with Monitoring service
        :param pulumi.Input[str] path: HTTP path to scrape for metrics.
        :param pulumi.Input[str] scheme: HTTP scheme to use for scraping.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        HTTP path to scrape for metrics.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[str]]:
        """
        HTTP scheme to use for scraping.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scheme", value)


@pulumi.input_type
class KogitoRuntimeSpecResourcesArgs:
    def __init__(__self__, *,
                 limits: Optional[pulumi.Input[Mapping[str, pulumi.Input['KogitoRuntimeSpecResourcesLimitsArgs']]]] = None,
                 requests: Optional[pulumi.Input[Mapping[str, pulumi.Input['KogitoRuntimeSpecResourcesRequestsArgs']]]] = None):
        """
        Defined compute resource requirements for the deployed service.
        :param pulumi.Input[Mapping[str, pulumi.Input['KogitoRuntimeSpecResourcesLimitsArgs']]] limits: Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        :param pulumi.Input[Mapping[str, pulumi.Input['KogitoRuntimeSpecResourcesRequestsArgs']]] requests: Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['KogitoRuntimeSpecResourcesLimitsArgs']]]]:
        """
        Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['KogitoRuntimeSpecResourcesLimitsArgs']]]]):
        pulumi.set(self, "limits", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['KogitoRuntimeSpecResourcesRequestsArgs']]]]:
        """
        Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['KogitoRuntimeSpecResourcesRequestsArgs']]]]):
        pulumi.set(self, "requests", value)


@pulumi.input_type
class KogitoRuntimeSpecResourcesLimitsArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class KogitoRuntimeSpecResourcesRequestsArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class KogitoRuntimeStatusArgs:
    def __init__(__self__, *,
                 conditions: pulumi.Input[Sequence[pulumi.Input['KogitoRuntimeStatusConditionsArgs']]],
                 cloud_events: Optional[pulumi.Input['KogitoRuntimeStatusCloudEventsArgs']] = None,
                 deployment_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['KogitoRuntimeStatusDeploymentConditionsArgs']]]] = None,
                 external_uri: Optional[pulumi.Input[str]] = None,
                 image: Optional[pulumi.Input[str]] = None):
        """
        KogitoRuntimeStatus defines the observed state of KogitoRuntime.
        :param pulumi.Input[Sequence[pulumi.Input['KogitoRuntimeStatusConditionsArgs']]] conditions: History of conditions for the resource
        :param pulumi.Input['KogitoRuntimeStatusCloudEventsArgs'] cloud_events: Describes the CloudEvents that this instance can consume or produce
        :param pulumi.Input[Sequence[pulumi.Input['KogitoRuntimeStatusDeploymentConditionsArgs']]] deployment_conditions: General conditions for the Kogito Service deployment.
        :param pulumi.Input[str] external_uri: URI is where the service is exposed.
        :param pulumi.Input[str] image: Image is the resolved image for this service.
        """
        pulumi.set(__self__, "conditions", conditions)
        if cloud_events is not None:
            pulumi.set(__self__, "cloud_events", cloud_events)
        if deployment_conditions is not None:
            pulumi.set(__self__, "deployment_conditions", deployment_conditions)
        if external_uri is not None:
            pulumi.set(__self__, "external_uri", external_uri)
        if image is not None:
            pulumi.set(__self__, "image", image)

    @property
    @pulumi.getter
    def conditions(self) -> pulumi.Input[Sequence[pulumi.Input['KogitoRuntimeStatusConditionsArgs']]]:
        """
        History of conditions for the resource
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: pulumi.Input[Sequence[pulumi.Input['KogitoRuntimeStatusConditionsArgs']]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="cloudEvents")
    def cloud_events(self) -> Optional[pulumi.Input['KogitoRuntimeStatusCloudEventsArgs']]:
        """
        Describes the CloudEvents that this instance can consume or produce
        """
        return pulumi.get(self, "cloud_events")

    @cloud_events.setter
    def cloud_events(self, value: Optional[pulumi.Input['KogitoRuntimeStatusCloudEventsArgs']]):
        pulumi.set(self, "cloud_events", value)

    @property
    @pulumi.getter(name="deploymentConditions")
    def deployment_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KogitoRuntimeStatusDeploymentConditionsArgs']]]]:
        """
        General conditions for the Kogito Service deployment.
        """
        return pulumi.get(self, "deployment_conditions")

    @deployment_conditions.setter
    def deployment_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KogitoRuntimeStatusDeploymentConditionsArgs']]]]):
        pulumi.set(self, "deployment_conditions", value)

    @property
    @pulumi.getter(name="externalURI")
    def external_uri(self) -> Optional[pulumi.Input[str]]:
        """
        URI is where the service is exposed.
        """
        return pulumi.get(self, "external_uri")

    @external_uri.setter
    def external_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "external_uri", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        Image is the resolved image for this service.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)


@pulumi.input_type
class KogitoRuntimeStatusCloudEventsArgs:
    def __init__(__self__, *,
                 consumes: Optional[pulumi.Input[Sequence[pulumi.Input['KogitoRuntimeStatusCloudEventsConsumesArgs']]]] = None,
                 produces: Optional[pulumi.Input[Sequence[pulumi.Input['KogitoRuntimeStatusCloudEventsProducesArgs']]]] = None):
        """
        Describes the CloudEvents that this instance can consume or produce
        """
        if consumes is not None:
            pulumi.set(__self__, "consumes", consumes)
        if produces is not None:
            pulumi.set(__self__, "produces", produces)

    @property
    @pulumi.getter
    def consumes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KogitoRuntimeStatusCloudEventsConsumesArgs']]]]:
        return pulumi.get(self, "consumes")

    @consumes.setter
    def consumes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KogitoRuntimeStatusCloudEventsConsumesArgs']]]]):
        pulumi.set(self, "consumes", value)

    @property
    @pulumi.getter
    def produces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KogitoRuntimeStatusCloudEventsProducesArgs']]]]:
        return pulumi.get(self, "produces")

    @produces.setter
    def produces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KogitoRuntimeStatusCloudEventsProducesArgs']]]]):
        pulumi.set(self, "produces", value)


@pulumi.input_type
class KogitoRuntimeStatusCloudEventsConsumesArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 source: Optional[pulumi.Input[str]] = None):
        """
        KogitoCloudEventInfo describes the CloudEvent information based on the specification
        """
        pulumi.set(__self__, "type", type)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)


@pulumi.input_type
class KogitoRuntimeStatusCloudEventsProducesArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 source: Optional[pulumi.Input[str]] = None):
        """
        KogitoCloudEventInfo describes the CloudEvent information based on the specification
        """
        pulumi.set(__self__, "type", type)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)


@pulumi.input_type
class KogitoRuntimeStatusConditionsArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[str],
                 type: pulumi.Input[str],
                 last_transition_time: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None):
        """
        Condition is the detailed condition for the resource
        :param pulumi.Input[str] type: ConditionType is the type of condition
        :param pulumi.Input[str] reason: KogitoServiceConditionReason is the type of reason
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        ConditionType is the type of condition
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        KogitoServiceConditionReason is the type of reason
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)


@pulumi.input_type
class KogitoRuntimeStatusDeploymentConditionsArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[str],
                 type: pulumi.Input[str],
                 last_transition_time: Optional[pulumi.Input[str]] = None,
                 last_update_time: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None):
        """
        DeploymentCondition describes the state of a deployment at a certain point.
        :param pulumi.Input[str] status: Status of the condition, one of True, False, Unknown.
        :param pulumi.Input[str] type: Type of deployment condition.
        :param pulumi.Input[str] last_transition_time: Last time the condition transitioned from one status to another.
        :param pulumi.Input[str] last_update_time: The last time this condition was updated.
        :param pulumi.Input[str] message: A human readable message indicating details about the transition.
        :param pulumi.Input[str] reason: The reason for the condition's last transition.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if last_update_time is not None:
            pulumi.set(__self__, "last_update_time", last_update_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        """
        Status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of deployment condition.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[pulumi.Input[str]]:
        """
        Last time the condition transitioned from one status to another.
        """
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter(name="lastUpdateTime")
    def last_update_time(self) -> Optional[pulumi.Input[str]]:
        """
        The last time this condition was updated.
        """
        return pulumi.get(self, "last_update_time")

    @last_update_time.setter
    def last_update_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_update_time", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        A human readable message indicating details about the transition.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        The reason for the condition's last transition.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)


@pulumi.input_type
class KogitoSupportingServiceSpecArgs:
    def __init__(__self__, *,
                 service_type: pulumi.Input[str],
                 config: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 deployment_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 env: Optional[pulumi.Input[Sequence[pulumi.Input['KogitoSupportingServiceSpecEnvArgs']]]] = None,
                 image: Optional[pulumi.Input[str]] = None,
                 infra: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 insecure_image_registry: Optional[pulumi.Input[bool]] = None,
                 monitoring: Optional[pulumi.Input['KogitoSupportingServiceSpecMonitoringArgs']] = None,
                 properties_config_map: Optional[pulumi.Input[str]] = None,
                 replicas: Optional[pulumi.Input[int]] = None,
                 resources: Optional[pulumi.Input['KogitoSupportingServiceSpecResourcesArgs']] = None,
                 service_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        KogitoSupportingServiceSpec defines the desired state of KogitoSupportingService.
        :param pulumi.Input[str] service_type: Defines the type for the supporting service, eg: DataIndex, JobsService Default value: JobsService
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] config: Application properties that will be set to the service. For example 'MY_VAR: my_value'.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] deployment_labels: Additional labels to be added to the Deployment and Pods managed by the operator.
        :param pulumi.Input[Sequence[pulumi.Input['KogitoSupportingServiceSpecEnvArgs']]] env: Environment variables to be added to the runtime container. Keys must be a C_IDENTIFIER.
        :param pulumi.Input[str] image: Image definition for the service. Example: "quay.io/kiegroup/kogito-service:latest". On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] infra: Infra provides list of dependent KogitoInfra objects.
        :param pulumi.Input[bool] insecure_image_registry: A flag indicating that image streams created by Kogito Operator should be configured to allow pulling from insecure registries. Usable just on OpenShift. Defaults to 'false'.
        :param pulumi.Input['KogitoSupportingServiceSpecMonitoringArgs'] monitoring: Create Service monitor instance to connect with Monitoring service
        :param pulumi.Input[str] properties_config_map: Custom ConfigMap with application.properties file to be mounted for the Kogito service. The ConfigMap must be created in the same namespace. Use this property if you need custom properties to be mounted before the application deployment. If left empty, one will be created for you. Later it can be updated to add any custom properties to apply to the service.
        :param pulumi.Input[int] replicas: Number of replicas that the service will have deployed in the cluster. Default value: 1.
        :param pulumi.Input['KogitoSupportingServiceSpecResourcesArgs'] resources: Defined compute resource requirements for the deployed service.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] service_labels: Additional labels to be added to the Service managed by the operator.
        """
        pulumi.set(__self__, "service_type", service_type)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if deployment_labels is not None:
            pulumi.set(__self__, "deployment_labels", deployment_labels)
        if env is not None:
            pulumi.set(__self__, "env", env)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if infra is not None:
            pulumi.set(__self__, "infra", infra)
        if insecure_image_registry is not None:
            pulumi.set(__self__, "insecure_image_registry", insecure_image_registry)
        if monitoring is not None:
            pulumi.set(__self__, "monitoring", monitoring)
        if properties_config_map is not None:
            pulumi.set(__self__, "properties_config_map", properties_config_map)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if service_labels is not None:
            pulumi.set(__self__, "service_labels", service_labels)

    @property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> pulumi.Input[str]:
        """
        Defines the type for the supporting service, eg: DataIndex, JobsService Default value: JobsService
        """
        return pulumi.get(self, "service_type")

    @service_type.setter
    def service_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_type", value)

    @property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Application properties that will be set to the service. For example 'MY_VAR: my_value'.
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "config", value)

    @property
    @pulumi.getter(name="deploymentLabels")
    def deployment_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional labels to be added to the Deployment and Pods managed by the operator.
        """
        return pulumi.get(self, "deployment_labels")

    @deployment_labels.setter
    def deployment_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "deployment_labels", value)

    @property
    @pulumi.getter
    def env(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KogitoSupportingServiceSpecEnvArgs']]]]:
        """
        Environment variables to be added to the runtime container. Keys must be a C_IDENTIFIER.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KogitoSupportingServiceSpecEnvArgs']]]]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        Image definition for the service. Example: "quay.io/kiegroup/kogito-service:latest". On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter
    def infra(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Infra provides list of dependent KogitoInfra objects.
        """
        return pulumi.get(self, "infra")

    @infra.setter
    def infra(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "infra", value)

    @property
    @pulumi.getter(name="insecureImageRegistry")
    def insecure_image_registry(self) -> Optional[pulumi.Input[bool]]:
        """
        A flag indicating that image streams created by Kogito Operator should be configured to allow pulling from insecure registries. Usable just on OpenShift. Defaults to 'false'.
        """
        return pulumi.get(self, "insecure_image_registry")

    @insecure_image_registry.setter
    def insecure_image_registry(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "insecure_image_registry", value)

    @property
    @pulumi.getter
    def monitoring(self) -> Optional[pulumi.Input['KogitoSupportingServiceSpecMonitoringArgs']]:
        """
        Create Service monitor instance to connect with Monitoring service
        """
        return pulumi.get(self, "monitoring")

    @monitoring.setter
    def monitoring(self, value: Optional[pulumi.Input['KogitoSupportingServiceSpecMonitoringArgs']]):
        pulumi.set(self, "monitoring", value)

    @property
    @pulumi.getter(name="propertiesConfigMap")
    def properties_config_map(self) -> Optional[pulumi.Input[str]]:
        """
        Custom ConfigMap with application.properties file to be mounted for the Kogito service. The ConfigMap must be created in the same namespace. Use this property if you need custom properties to be mounted before the application deployment. If left empty, one will be created for you. Later it can be updated to add any custom properties to apply to the service.
        """
        return pulumi.get(self, "properties_config_map")

    @properties_config_map.setter
    def properties_config_map(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "properties_config_map", value)

    @property
    @pulumi.getter
    def replicas(self) -> Optional[pulumi.Input[int]]:
        """
        Number of replicas that the service will have deployed in the cluster. Default value: 1.
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "replicas", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['KogitoSupportingServiceSpecResourcesArgs']]:
        """
        Defined compute resource requirements for the deployed service.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['KogitoSupportingServiceSpecResourcesArgs']]):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter(name="serviceLabels")
    def service_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional labels to be added to the Service managed by the operator.
        """
        return pulumi.get(self, "service_labels")

    @service_labels.setter
    def service_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "service_labels", value)


@pulumi.input_type
class KogitoSupportingServiceSpecEnvArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: Optional[pulumi.Input[str]] = None,
                 value_from: Optional[pulumi.Input['KogitoSupportingServiceSpecEnvValueFromArgs']] = None):
        """
        EnvVar represents an environment variable present in a Container.
        :param pulumi.Input[str] name: Name of the environment variable. Must be a C_IDENTIFIER.
        :param pulumi.Input[str] value: Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        :param pulumi.Input['KogitoSupportingServiceSpecEnvValueFromArgs'] value_from: Source for the environment variable's value. Cannot be used if value is not empty.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_from is not None:
            pulumi.set(__self__, "value_from", value_from)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the environment variable. Must be a C_IDENTIFIER.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="valueFrom")
    def value_from(self) -> Optional[pulumi.Input['KogitoSupportingServiceSpecEnvValueFromArgs']]:
        """
        Source for the environment variable's value. Cannot be used if value is not empty.
        """
        return pulumi.get(self, "value_from")

    @value_from.setter
    def value_from(self, value: Optional[pulumi.Input['KogitoSupportingServiceSpecEnvValueFromArgs']]):
        pulumi.set(self, "value_from", value)


@pulumi.input_type
class KogitoSupportingServiceSpecEnvValueFromArgs:
    def __init__(__self__, *,
                 config_map_key_ref: Optional[pulumi.Input['KogitoSupportingServiceSpecEnvValueFromConfigMapKeyRefArgs']] = None,
                 field_ref: Optional[pulumi.Input['KogitoSupportingServiceSpecEnvValueFromFieldRefArgs']] = None,
                 resource_field_ref: Optional[pulumi.Input['KogitoSupportingServiceSpecEnvValueFromResourceFieldRefArgs']] = None,
                 secret_key_ref: Optional[pulumi.Input['KogitoSupportingServiceSpecEnvValueFromSecretKeyRefArgs']] = None):
        """
        Source for the environment variable's value. Cannot be used if value is not empty.
        :param pulumi.Input['KogitoSupportingServiceSpecEnvValueFromConfigMapKeyRefArgs'] config_map_key_ref: Selects a key of a ConfigMap.
        :param pulumi.Input['KogitoSupportingServiceSpecEnvValueFromFieldRefArgs'] field_ref: Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        :param pulumi.Input['KogitoSupportingServiceSpecEnvValueFromResourceFieldRefArgs'] resource_field_ref: Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        :param pulumi.Input['KogitoSupportingServiceSpecEnvValueFromSecretKeyRefArgs'] secret_key_ref: Selects a key of a secret in the pod's namespace
        """
        if config_map_key_ref is not None:
            pulumi.set(__self__, "config_map_key_ref", config_map_key_ref)
        if field_ref is not None:
            pulumi.set(__self__, "field_ref", field_ref)
        if resource_field_ref is not None:
            pulumi.set(__self__, "resource_field_ref", resource_field_ref)
        if secret_key_ref is not None:
            pulumi.set(__self__, "secret_key_ref", secret_key_ref)

    @property
    @pulumi.getter(name="configMapKeyRef")
    def config_map_key_ref(self) -> Optional[pulumi.Input['KogitoSupportingServiceSpecEnvValueFromConfigMapKeyRefArgs']]:
        """
        Selects a key of a ConfigMap.
        """
        return pulumi.get(self, "config_map_key_ref")

    @config_map_key_ref.setter
    def config_map_key_ref(self, value: Optional[pulumi.Input['KogitoSupportingServiceSpecEnvValueFromConfigMapKeyRefArgs']]):
        pulumi.set(self, "config_map_key_ref", value)

    @property
    @pulumi.getter(name="fieldRef")
    def field_ref(self) -> Optional[pulumi.Input['KogitoSupportingServiceSpecEnvValueFromFieldRefArgs']]:
        """
        Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        """
        return pulumi.get(self, "field_ref")

    @field_ref.setter
    def field_ref(self, value: Optional[pulumi.Input['KogitoSupportingServiceSpecEnvValueFromFieldRefArgs']]):
        pulumi.set(self, "field_ref", value)

    @property
    @pulumi.getter(name="resourceFieldRef")
    def resource_field_ref(self) -> Optional[pulumi.Input['KogitoSupportingServiceSpecEnvValueFromResourceFieldRefArgs']]:
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        """
        return pulumi.get(self, "resource_field_ref")

    @resource_field_ref.setter
    def resource_field_ref(self, value: Optional[pulumi.Input['KogitoSupportingServiceSpecEnvValueFromResourceFieldRefArgs']]):
        pulumi.set(self, "resource_field_ref", value)

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> Optional[pulumi.Input['KogitoSupportingServiceSpecEnvValueFromSecretKeyRefArgs']]:
        """
        Selects a key of a secret in the pod's namespace
        """
        return pulumi.get(self, "secret_key_ref")

    @secret_key_ref.setter
    def secret_key_ref(self, value: Optional[pulumi.Input['KogitoSupportingServiceSpecEnvValueFromSecretKeyRefArgs']]):
        pulumi.set(self, "secret_key_ref", value)


@pulumi.input_type
class KogitoSupportingServiceSpecEnvValueFromConfigMapKeyRefArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None,
                 optional: Optional[pulumi.Input[bool]] = None):
        """
        Selects a key of a ConfigMap.
        :param pulumi.Input[str] key: The key to select.
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        :param pulumi.Input[bool] optional: Specify whether the ConfigMap or its key must be defined
        """
        pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key to select.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def optional(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify whether the ConfigMap or its key must be defined
        """
        return pulumi.get(self, "optional")

    @optional.setter
    def optional(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "optional", value)


@pulumi.input_type
class KogitoSupportingServiceSpecEnvValueFromFieldRefArgs:
    def __init__(__self__, *,
                 field_path: pulumi.Input[str],
                 api_version: Optional[pulumi.Input[str]] = None):
        """
        Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        :param pulumi.Input[str] field_path: Path of the field to select in the specified API version.
        :param pulumi.Input[str] api_version: Version of the schema the FieldPath is written in terms of, defaults to "v1".
        """
        pulumi.set(__self__, "field_path", field_path)
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> pulumi.Input[str]:
        """
        Path of the field to select in the specified API version.
        """
        return pulumi.get(self, "field_path")

    @field_path.setter
    def field_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "field_path", value)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of the schema the FieldPath is written in terms of, defaults to "v1".
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)


@pulumi.input_type
class KogitoSupportingServiceSpecEnvValueFromResourceFieldRefArgs:
    def __init__(__self__, *,
                 resource: pulumi.Input[str],
                 container_name: Optional[pulumi.Input[str]] = None,
                 divisor: Optional[pulumi.Input['KogitoSupportingServiceSpecEnvValueFromResourceFieldRefDivisorArgs']] = None):
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        :param pulumi.Input[str] resource: Required: resource to select
        :param pulumi.Input[str] container_name: Container name: required for volumes, optional for env vars
        :param pulumi.Input['KogitoSupportingServiceSpecEnvValueFromResourceFieldRefDivisorArgs'] divisor: Specifies the output format of the exposed resources, defaults to "1"
        """
        pulumi.set(__self__, "resource", resource)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if divisor is not None:
            pulumi.set(__self__, "divisor", divisor)

    @property
    @pulumi.getter
    def resource(self) -> pulumi.Input[str]:
        """
        Required: resource to select
        """
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource", value)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[pulumi.Input[str]]:
        """
        Container name: required for volumes, optional for env vars
        """
        return pulumi.get(self, "container_name")

    @container_name.setter
    def container_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "container_name", value)

    @property
    @pulumi.getter
    def divisor(self) -> Optional[pulumi.Input['KogitoSupportingServiceSpecEnvValueFromResourceFieldRefDivisorArgs']]:
        """
        Specifies the output format of the exposed resources, defaults to "1"
        """
        return pulumi.get(self, "divisor")

    @divisor.setter
    def divisor(self, value: Optional[pulumi.Input['KogitoSupportingServiceSpecEnvValueFromResourceFieldRefDivisorArgs']]):
        pulumi.set(self, "divisor", value)


@pulumi.input_type
class KogitoSupportingServiceSpecEnvValueFromResourceFieldRefDivisorArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class KogitoSupportingServiceSpecEnvValueFromSecretKeyRefArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None,
                 optional: Optional[pulumi.Input[bool]] = None):
        """
        Selects a key of a secret in the pod's namespace
        :param pulumi.Input[str] key: The key of the secret to select from.  Must be a valid secret key.
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        :param pulumi.Input[bool] optional: Specify whether the Secret or its key must be defined
        """
        pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key of the secret to select from.  Must be a valid secret key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def optional(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify whether the Secret or its key must be defined
        """
        return pulumi.get(self, "optional")

    @optional.setter
    def optional(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "optional", value)


@pulumi.input_type
class KogitoSupportingServiceSpecMonitoringArgs:
    def __init__(__self__, *,
                 path: Optional[pulumi.Input[str]] = None,
                 scheme: Optional[pulumi.Input[str]] = None):
        """
        Create Service monitor instance to connect with Monitoring service
        :param pulumi.Input[str] path: HTTP path to scrape for metrics.
        :param pulumi.Input[str] scheme: HTTP scheme to use for scraping.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        HTTP path to scrape for metrics.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[str]]:
        """
        HTTP scheme to use for scraping.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scheme", value)


@pulumi.input_type
class KogitoSupportingServiceSpecResourcesArgs:
    def __init__(__self__, *,
                 limits: Optional[pulumi.Input[Mapping[str, pulumi.Input['KogitoSupportingServiceSpecResourcesLimitsArgs']]]] = None,
                 requests: Optional[pulumi.Input[Mapping[str, pulumi.Input['KogitoSupportingServiceSpecResourcesRequestsArgs']]]] = None):
        """
        Defined compute resource requirements for the deployed service.
        :param pulumi.Input[Mapping[str, pulumi.Input['KogitoSupportingServiceSpecResourcesLimitsArgs']]] limits: Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        :param pulumi.Input[Mapping[str, pulumi.Input['KogitoSupportingServiceSpecResourcesRequestsArgs']]] requests: Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['KogitoSupportingServiceSpecResourcesLimitsArgs']]]]:
        """
        Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['KogitoSupportingServiceSpecResourcesLimitsArgs']]]]):
        pulumi.set(self, "limits", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['KogitoSupportingServiceSpecResourcesRequestsArgs']]]]:
        """
        Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['KogitoSupportingServiceSpecResourcesRequestsArgs']]]]):
        pulumi.set(self, "requests", value)


@pulumi.input_type
class KogitoSupportingServiceSpecResourcesLimitsArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class KogitoSupportingServiceSpecResourcesRequestsArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class KogitoSupportingServiceStatusArgs:
    def __init__(__self__, *,
                 conditions: pulumi.Input[Sequence[pulumi.Input['KogitoSupportingServiceStatusConditionsArgs']]],
                 cloud_events: Optional[pulumi.Input['KogitoSupportingServiceStatusCloudEventsArgs']] = None,
                 deployment_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['KogitoSupportingServiceStatusDeploymentConditionsArgs']]]] = None,
                 external_uri: Optional[pulumi.Input[str]] = None,
                 image: Optional[pulumi.Input[str]] = None):
        """
        KogitoSupportingServiceStatus defines the observed state of KogitoSupportingService.
        :param pulumi.Input[Sequence[pulumi.Input['KogitoSupportingServiceStatusConditionsArgs']]] conditions: History of conditions for the resource
        :param pulumi.Input['KogitoSupportingServiceStatusCloudEventsArgs'] cloud_events: Describes the CloudEvents that this instance can consume or produce
        :param pulumi.Input[Sequence[pulumi.Input['KogitoSupportingServiceStatusDeploymentConditionsArgs']]] deployment_conditions: General conditions for the Kogito Service deployment.
        :param pulumi.Input[str] external_uri: URI is where the service is exposed.
        :param pulumi.Input[str] image: Image is the resolved image for this service.
        """
        pulumi.set(__self__, "conditions", conditions)
        if cloud_events is not None:
            pulumi.set(__self__, "cloud_events", cloud_events)
        if deployment_conditions is not None:
            pulumi.set(__self__, "deployment_conditions", deployment_conditions)
        if external_uri is not None:
            pulumi.set(__self__, "external_uri", external_uri)
        if image is not None:
            pulumi.set(__self__, "image", image)

    @property
    @pulumi.getter
    def conditions(self) -> pulumi.Input[Sequence[pulumi.Input['KogitoSupportingServiceStatusConditionsArgs']]]:
        """
        History of conditions for the resource
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: pulumi.Input[Sequence[pulumi.Input['KogitoSupportingServiceStatusConditionsArgs']]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="cloudEvents")
    def cloud_events(self) -> Optional[pulumi.Input['KogitoSupportingServiceStatusCloudEventsArgs']]:
        """
        Describes the CloudEvents that this instance can consume or produce
        """
        return pulumi.get(self, "cloud_events")

    @cloud_events.setter
    def cloud_events(self, value: Optional[pulumi.Input['KogitoSupportingServiceStatusCloudEventsArgs']]):
        pulumi.set(self, "cloud_events", value)

    @property
    @pulumi.getter(name="deploymentConditions")
    def deployment_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KogitoSupportingServiceStatusDeploymentConditionsArgs']]]]:
        """
        General conditions for the Kogito Service deployment.
        """
        return pulumi.get(self, "deployment_conditions")

    @deployment_conditions.setter
    def deployment_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KogitoSupportingServiceStatusDeploymentConditionsArgs']]]]):
        pulumi.set(self, "deployment_conditions", value)

    @property
    @pulumi.getter(name="externalURI")
    def external_uri(self) -> Optional[pulumi.Input[str]]:
        """
        URI is where the service is exposed.
        """
        return pulumi.get(self, "external_uri")

    @external_uri.setter
    def external_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "external_uri", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        Image is the resolved image for this service.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)


@pulumi.input_type
class KogitoSupportingServiceStatusCloudEventsArgs:
    def __init__(__self__, *,
                 consumes: Optional[pulumi.Input[Sequence[pulumi.Input['KogitoSupportingServiceStatusCloudEventsConsumesArgs']]]] = None,
                 produces: Optional[pulumi.Input[Sequence[pulumi.Input['KogitoSupportingServiceStatusCloudEventsProducesArgs']]]] = None):
        """
        Describes the CloudEvents that this instance can consume or produce
        """
        if consumes is not None:
            pulumi.set(__self__, "consumes", consumes)
        if produces is not None:
            pulumi.set(__self__, "produces", produces)

    @property
    @pulumi.getter
    def consumes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KogitoSupportingServiceStatusCloudEventsConsumesArgs']]]]:
        return pulumi.get(self, "consumes")

    @consumes.setter
    def consumes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KogitoSupportingServiceStatusCloudEventsConsumesArgs']]]]):
        pulumi.set(self, "consumes", value)

    @property
    @pulumi.getter
    def produces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KogitoSupportingServiceStatusCloudEventsProducesArgs']]]]:
        return pulumi.get(self, "produces")

    @produces.setter
    def produces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KogitoSupportingServiceStatusCloudEventsProducesArgs']]]]):
        pulumi.set(self, "produces", value)


@pulumi.input_type
class KogitoSupportingServiceStatusCloudEventsConsumesArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 source: Optional[pulumi.Input[str]] = None):
        """
        KogitoCloudEventInfo describes the CloudEvent information based on the specification
        """
        pulumi.set(__self__, "type", type)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)


@pulumi.input_type
class KogitoSupportingServiceStatusCloudEventsProducesArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 source: Optional[pulumi.Input[str]] = None):
        """
        KogitoCloudEventInfo describes the CloudEvent information based on the specification
        """
        pulumi.set(__self__, "type", type)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)


@pulumi.input_type
class KogitoSupportingServiceStatusConditionsArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[str],
                 type: pulumi.Input[str],
                 last_transition_time: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None):
        """
        Condition is the detailed condition for the resource
        :param pulumi.Input[str] type: ConditionType is the type of condition
        :param pulumi.Input[str] reason: KogitoServiceConditionReason is the type of reason
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        ConditionType is the type of condition
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        KogitoServiceConditionReason is the type of reason
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)


@pulumi.input_type
class KogitoSupportingServiceStatusDeploymentConditionsArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[str],
                 type: pulumi.Input[str],
                 last_transition_time: Optional[pulumi.Input[str]] = None,
                 last_update_time: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None):
        """
        DeploymentCondition describes the state of a deployment at a certain point.
        :param pulumi.Input[str] status: Status of the condition, one of True, False, Unknown.
        :param pulumi.Input[str] type: Type of deployment condition.
        :param pulumi.Input[str] last_transition_time: Last time the condition transitioned from one status to another.
        :param pulumi.Input[str] last_update_time: The last time this condition was updated.
        :param pulumi.Input[str] message: A human readable message indicating details about the transition.
        :param pulumi.Input[str] reason: The reason for the condition's last transition.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if last_update_time is not None:
            pulumi.set(__self__, "last_update_time", last_update_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        """
        Status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of deployment condition.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[pulumi.Input[str]]:
        """
        Last time the condition transitioned from one status to another.
        """
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter(name="lastUpdateTime")
    def last_update_time(self) -> Optional[pulumi.Input[str]]:
        """
        The last time this condition was updated.
        """
        return pulumi.get(self, "last_update_time")

    @last_update_time.setter
    def last_update_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_update_time", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        A human readable message indicating details about the transition.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        The reason for the condition's last transition.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)


