# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from ... import _utilities, _tables
from . import outputs

__all__ = [
    'KogitoBuildSpec',
    'KogitoBuildSpecArtifact',
    'KogitoBuildSpecBuildImage',
    'KogitoBuildSpecEnvs',
    'KogitoBuildSpecEnvsValueFrom',
    'KogitoBuildSpecEnvsValueFromConfigMapKeyRef',
    'KogitoBuildSpecEnvsValueFromFieldRef',
    'KogitoBuildSpecEnvsValueFromResourceFieldRef',
    'KogitoBuildSpecEnvsValueFromResourceFieldRefDivisor',
    'KogitoBuildSpecEnvsValueFromSecretKeyRef',
    'KogitoBuildSpecGitSource',
    'KogitoBuildSpecResources',
    'KogitoBuildSpecResourcesLimits',
    'KogitoBuildSpecResourcesRequests',
    'KogitoBuildSpecRuntimeImage',
    'KogitoBuildSpecWebHooks',
    'KogitoBuildStatus',
    'KogitoBuildStatusBuilds',
    'KogitoBuildStatusConditions',
    'KogitoDataIndexSpec',
    'KogitoDataIndexSpecEnvs',
    'KogitoDataIndexSpecEnvsValueFrom',
    'KogitoDataIndexSpecEnvsValueFromConfigMapKeyRef',
    'KogitoDataIndexSpecEnvsValueFromFieldRef',
    'KogitoDataIndexSpecEnvsValueFromResourceFieldRef',
    'KogitoDataIndexSpecEnvsValueFromResourceFieldRefDivisor',
    'KogitoDataIndexSpecEnvsValueFromSecretKeyRef',
    'KogitoDataIndexSpecImage',
    'KogitoDataIndexSpecInfinispan',
    'KogitoDataIndexSpecInfinispanCredentials',
    'KogitoDataIndexSpecKafka',
    'KogitoDataIndexSpecResources',
    'KogitoDataIndexSpecResourcesLimits',
    'KogitoDataIndexSpecResourcesRequests',
    'KogitoDataIndexStatus',
    'KogitoDataIndexStatusConditions',
    'KogitoDataIndexStatusDeploymentConditions',
    'KogitoInfraSpec',
    'KogitoInfraStatus',
    'KogitoInfraStatusCondition',
    'KogitoInfraStatusInfinispan',
    'KogitoInfraStatusInfinispanCondition',
    'KogitoInfraStatusKafka',
    'KogitoInfraStatusKafkaCondition',
    'KogitoInfraStatusKeycloak',
    'KogitoInfraStatusKeycloakCondition',
    'KogitoJobsServiceSpec',
    'KogitoJobsServiceSpecEnvs',
    'KogitoJobsServiceSpecEnvsValueFrom',
    'KogitoJobsServiceSpecEnvsValueFromConfigMapKeyRef',
    'KogitoJobsServiceSpecEnvsValueFromFieldRef',
    'KogitoJobsServiceSpecEnvsValueFromResourceFieldRef',
    'KogitoJobsServiceSpecEnvsValueFromResourceFieldRefDivisor',
    'KogitoJobsServiceSpecEnvsValueFromSecretKeyRef',
    'KogitoJobsServiceSpecImage',
    'KogitoJobsServiceSpecInfinispan',
    'KogitoJobsServiceSpecInfinispanCredentials',
    'KogitoJobsServiceSpecKafka',
    'KogitoJobsServiceSpecResources',
    'KogitoJobsServiceSpecResourcesLimits',
    'KogitoJobsServiceSpecResourcesRequests',
    'KogitoJobsServiceStatus',
    'KogitoJobsServiceStatusConditions',
    'KogitoJobsServiceStatusDeploymentConditions',
    'KogitoMgmtConsoleSpec',
    'KogitoMgmtConsoleSpecEnvs',
    'KogitoMgmtConsoleSpecEnvsValueFrom',
    'KogitoMgmtConsoleSpecEnvsValueFromConfigMapKeyRef',
    'KogitoMgmtConsoleSpecEnvsValueFromFieldRef',
    'KogitoMgmtConsoleSpecEnvsValueFromResourceFieldRef',
    'KogitoMgmtConsoleSpecEnvsValueFromResourceFieldRefDivisor',
    'KogitoMgmtConsoleSpecEnvsValueFromSecretKeyRef',
    'KogitoMgmtConsoleSpecImage',
    'KogitoMgmtConsoleSpecResources',
    'KogitoMgmtConsoleSpecResourcesLimits',
    'KogitoMgmtConsoleSpecResourcesRequests',
    'KogitoMgmtConsoleStatus',
    'KogitoMgmtConsoleStatusConditions',
    'KogitoMgmtConsoleStatusDeploymentConditions',
    'KogitoRuntimeSpec',
    'KogitoRuntimeSpecEnvs',
    'KogitoRuntimeSpecEnvsValueFrom',
    'KogitoRuntimeSpecEnvsValueFromConfigMapKeyRef',
    'KogitoRuntimeSpecEnvsValueFromFieldRef',
    'KogitoRuntimeSpecEnvsValueFromResourceFieldRef',
    'KogitoRuntimeSpecEnvsValueFromResourceFieldRefDivisor',
    'KogitoRuntimeSpecEnvsValueFromSecretKeyRef',
    'KogitoRuntimeSpecImage',
    'KogitoRuntimeSpecInfinispan',
    'KogitoRuntimeSpecInfinispanCredentials',
    'KogitoRuntimeSpecKafka',
    'KogitoRuntimeSpecResources',
    'KogitoRuntimeSpecResourcesLimits',
    'KogitoRuntimeSpecResourcesRequests',
    'KogitoRuntimeStatus',
    'KogitoRuntimeStatusConditions',
    'KogitoRuntimeStatusDeploymentConditions',
    'KogitoTrustySpec',
    'KogitoTrustySpecEnvs',
    'KogitoTrustySpecEnvsValueFrom',
    'KogitoTrustySpecEnvsValueFromConfigMapKeyRef',
    'KogitoTrustySpecEnvsValueFromFieldRef',
    'KogitoTrustySpecEnvsValueFromResourceFieldRef',
    'KogitoTrustySpecEnvsValueFromResourceFieldRefDivisor',
    'KogitoTrustySpecEnvsValueFromSecretKeyRef',
    'KogitoTrustySpecImage',
    'KogitoTrustySpecInfinispan',
    'KogitoTrustySpecInfinispanCredentials',
    'KogitoTrustySpecKafka',
    'KogitoTrustySpecResources',
    'KogitoTrustySpecResourcesLimits',
    'KogitoTrustySpecResourcesRequests',
    'KogitoTrustyStatus',
    'KogitoTrustyStatusConditions',
    'KogitoTrustyStatusDeploymentConditions',
]

@pulumi.output_type
class KogitoBuildSpec(dict):
    """
    KogitoBuildSpec defines the desired state of KogitoBuild.
    """
    def __init__(__self__, *,
                 type: str,
                 artifact: Optional['outputs.KogitoBuildSpecArtifact'] = None,
                 build_image: Optional['outputs.KogitoBuildSpecBuildImage'] = None,
                 disable_incremental: Optional[bool] = None,
                 enable_maven_download_output: Optional[bool] = None,
                 envs: Optional[Sequence['outputs.KogitoBuildSpecEnvs']] = None,
                 git_source: Optional['outputs.KogitoBuildSpecGitSource'] = None,
                 maven_mirror_url: Optional[str] = None,
                 native: Optional[bool] = None,
                 resources: Optional['outputs.KogitoBuildSpecResources'] = None,
                 runtime: Optional[str] = None,
                 runtime_image: Optional['outputs.KogitoBuildSpecRuntimeImage'] = None,
                 target_kogito_runtime: Optional[str] = None,
                 web_hooks: Optional[Sequence['outputs.KogitoBuildSpecWebHooks']] = None):
        """
        KogitoBuildSpec defines the desired state of KogitoBuild.
        :param str type: Sets the type of build that this instance will handle: Binary - takes an uploaded binary file already compiled and creates a Kogito service image from it. RemoteSource - pulls the source code from a Git repository, builds the binary and then the final Kogito service image. LocalSource - takes an uploaded resource file such as DRL (rules), DMN (decision) or BPMN (process), builds the binary and the final Kogito service image.
        :param 'KogitoBuildSpecArtifactArgs' artifact: Artifact contains override information for building the Maven artifact (used for Local Source builds). You might want to override this information when building from decisions, rules or process files. In this scenario the Kogito Images will generate a new Java project for you underneath. This information will be used to generate this project.
        :param 'KogitoBuildSpecBuildImageArgs' build_image: Image used to build the Kogito Service from source (Local and Remote). The operator will use the one provided by the Kogito Team based on the "Runtime" field. Example: Domain: quay.io, Namespace: kiegroup, Name: kogito-jvm-builder, Tag: latest. On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
        :param bool disable_incremental: DisableIncremental indicates that source to image builds should NOT be incremental. Defaults to false.
        :param bool enable_maven_download_output: If set to true will print the logs for downloading/uploading of maven dependencies. Defaults to false.
        :param Sequence['KogitoBuildSpecEnvsArgs'] envs: Environment variables used during build time.
        :param 'KogitoBuildSpecGitSourceArgs' git_source: Information about the git repository where the Kogito Service source code resides. Ignored for binary builds.
        :param str maven_mirror_url: Maven Mirror URL to be used during source-to-image builds (Local and Remote) to considerably increase build speed.
        :param bool native: Native indicates if the Kogito Service built should be compiled to run on native mode when Runtime is Quarkus (Source to Image build only). For more information, see https://www.graalvm.org/docs/reference-manual/aot-compilation/.
        :param 'KogitoBuildSpecResourcesArgs' resources: Resources Requirements for builder pods.
        :param str runtime: Which runtime Kogito service base image to use when building the Kogito service. If "BuildImage" is set, this value is ignored by the operator. Default value: quarkus.
        :param 'KogitoBuildSpecRuntimeImageArgs' runtime_image: Image used as the base image for the final Kogito service. This image only has the required packages to run the application. For example: quarkus based services will have only JVM installed, native services only the packages required by the OS. The operator will use the one provided by the Kogito Team based on the "Runtime" field. Example: Domain: quay.io, Namespace: kiegroup, Name: kogito-jvm-builder, Tag: latest. On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
        :param str target_kogito_runtime: Set this field targeting the desired KogitoRuntime when this KogitoBuild instance has a different name than the KogitoRuntime. By default this KogitoBuild instance will generate a final image named after its own name (.metadata.name). On OpenShift, an ImageStream will be created causing a redeployment on any KogitoRuntime with the same name. On Kubernetes, the final image will be pushed to the KogitoRuntime deployment. If you have multiple KogitoBuild instances (let's say BinaryBuildType and Remote Source), you might need that both target the same KogitoRuntime. Both KogitoBuilds will update the same ImageStream or generate a final image to the same KogitoRuntime deployment.
        :param Sequence['KogitoBuildSpecWebHooksArgs'] web_hooks: WebHooks secrets for source to image builds based on Git repositories (Remote Sources).
        """
        pulumi.set(__self__, "type", type)
        if artifact is not None:
            pulumi.set(__self__, "artifact", artifact)
        if build_image is not None:
            pulumi.set(__self__, "build_image", build_image)
        if disable_incremental is not None:
            pulumi.set(__self__, "disable_incremental", disable_incremental)
        if enable_maven_download_output is not None:
            pulumi.set(__self__, "enable_maven_download_output", enable_maven_download_output)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if git_source is not None:
            pulumi.set(__self__, "git_source", git_source)
        if maven_mirror_url is not None:
            pulumi.set(__self__, "maven_mirror_url", maven_mirror_url)
        if native is not None:
            pulumi.set(__self__, "native", native)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if runtime is not None:
            pulumi.set(__self__, "runtime", runtime)
        if runtime_image is not None:
            pulumi.set(__self__, "runtime_image", runtime_image)
        if target_kogito_runtime is not None:
            pulumi.set(__self__, "target_kogito_runtime", target_kogito_runtime)
        if web_hooks is not None:
            pulumi.set(__self__, "web_hooks", web_hooks)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Sets the type of build that this instance will handle: Binary - takes an uploaded binary file already compiled and creates a Kogito service image from it. RemoteSource - pulls the source code from a Git repository, builds the binary and then the final Kogito service image. LocalSource - takes an uploaded resource file such as DRL (rules), DMN (decision) or BPMN (process), builds the binary and the final Kogito service image.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def artifact(self) -> Optional['outputs.KogitoBuildSpecArtifact']:
        """
        Artifact contains override information for building the Maven artifact (used for Local Source builds). You might want to override this information when building from decisions, rules or process files. In this scenario the Kogito Images will generate a new Java project for you underneath. This information will be used to generate this project.
        """
        return pulumi.get(self, "artifact")

    @property
    @pulumi.getter(name="buildImage")
    def build_image(self) -> Optional['outputs.KogitoBuildSpecBuildImage']:
        """
        Image used to build the Kogito Service from source (Local and Remote). The operator will use the one provided by the Kogito Team based on the "Runtime" field. Example: Domain: quay.io, Namespace: kiegroup, Name: kogito-jvm-builder, Tag: latest. On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
        """
        return pulumi.get(self, "build_image")

    @property
    @pulumi.getter(name="disableIncremental")
    def disable_incremental(self) -> Optional[bool]:
        """
        DisableIncremental indicates that source to image builds should NOT be incremental. Defaults to false.
        """
        return pulumi.get(self, "disable_incremental")

    @property
    @pulumi.getter(name="enableMavenDownloadOutput")
    def enable_maven_download_output(self) -> Optional[bool]:
        """
        If set to true will print the logs for downloading/uploading of maven dependencies. Defaults to false.
        """
        return pulumi.get(self, "enable_maven_download_output")

    @property
    @pulumi.getter
    def envs(self) -> Optional[Sequence['outputs.KogitoBuildSpecEnvs']]:
        """
        Environment variables used during build time.
        """
        return pulumi.get(self, "envs")

    @property
    @pulumi.getter(name="gitSource")
    def git_source(self) -> Optional['outputs.KogitoBuildSpecGitSource']:
        """
        Information about the git repository where the Kogito Service source code resides. Ignored for binary builds.
        """
        return pulumi.get(self, "git_source")

    @property
    @pulumi.getter(name="mavenMirrorURL")
    def maven_mirror_url(self) -> Optional[str]:
        """
        Maven Mirror URL to be used during source-to-image builds (Local and Remote) to considerably increase build speed.
        """
        return pulumi.get(self, "maven_mirror_url")

    @property
    @pulumi.getter
    def native(self) -> Optional[bool]:
        """
        Native indicates if the Kogito Service built should be compiled to run on native mode when Runtime is Quarkus (Source to Image build only). For more information, see https://www.graalvm.org/docs/reference-manual/aot-compilation/.
        """
        return pulumi.get(self, "native")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.KogitoBuildSpecResources']:
        """
        Resources Requirements for builder pods.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter
    def runtime(self) -> Optional[str]:
        """
        Which runtime Kogito service base image to use when building the Kogito service. If "BuildImage" is set, this value is ignored by the operator. Default value: quarkus.
        """
        return pulumi.get(self, "runtime")

    @property
    @pulumi.getter(name="runtimeImage")
    def runtime_image(self) -> Optional['outputs.KogitoBuildSpecRuntimeImage']:
        """
        Image used as the base image for the final Kogito service. This image only has the required packages to run the application. For example: quarkus based services will have only JVM installed, native services only the packages required by the OS. The operator will use the one provided by the Kogito Team based on the "Runtime" field. Example: Domain: quay.io, Namespace: kiegroup, Name: kogito-jvm-builder, Tag: latest. On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
        """
        return pulumi.get(self, "runtime_image")

    @property
    @pulumi.getter(name="targetKogitoRuntime")
    def target_kogito_runtime(self) -> Optional[str]:
        """
        Set this field targeting the desired KogitoRuntime when this KogitoBuild instance has a different name than the KogitoRuntime. By default this KogitoBuild instance will generate a final image named after its own name (.metadata.name). On OpenShift, an ImageStream will be created causing a redeployment on any KogitoRuntime with the same name. On Kubernetes, the final image will be pushed to the KogitoRuntime deployment. If you have multiple KogitoBuild instances (let's say BinaryBuildType and Remote Source), you might need that both target the same KogitoRuntime. Both KogitoBuilds will update the same ImageStream or generate a final image to the same KogitoRuntime deployment.
        """
        return pulumi.get(self, "target_kogito_runtime")

    @property
    @pulumi.getter(name="webHooks")
    def web_hooks(self) -> Optional[Sequence['outputs.KogitoBuildSpecWebHooks']]:
        """
        WebHooks secrets for source to image builds based on Git repositories (Remote Sources).
        """
        return pulumi.get(self, "web_hooks")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoBuildSpecArtifact(dict):
    """
    Artifact contains override information for building the Maven artifact (used for Local Source builds). You might want to override this information when building from decisions, rules or process files. In this scenario the Kogito Images will generate a new Java project for you underneath. This information will be used to generate this project.
    """
    def __init__(__self__, *,
                 artifact_id: Optional[str] = None,
                 group_id: Optional[str] = None,
                 version: Optional[str] = None):
        """
        Artifact contains override information for building the Maven artifact (used for Local Source builds). You might want to override this information when building from decisions, rules or process files. In this scenario the Kogito Images will generate a new Java project for you underneath. This information will be used to generate this project.
        :param str artifact_id: Indicates the unique base name of the primary artifact being generated.
        :param str group_id: Indicates the unique identifier of the organization or group that created the project.
        :param str version: Indicates the version of the artifact generated by the project.
        """
        if artifact_id is not None:
            pulumi.set(__self__, "artifact_id", artifact_id)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="artifactId")
    def artifact_id(self) -> Optional[str]:
        """
        Indicates the unique base name of the primary artifact being generated.
        """
        return pulumi.get(self, "artifact_id")

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[str]:
        """
        Indicates the unique identifier of the organization or group that created the project.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Indicates the version of the artifact generated by the project.
        """
        return pulumi.get(self, "version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoBuildSpecBuildImage(dict):
    """
    Image used to build the Kogito Service from source (Local and Remote). The operator will use the one provided by the Kogito Team based on the "Runtime" field. Example: Domain: quay.io, Namespace: kiegroup, Name: kogito-jvm-builder, Tag: latest. On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
    """
    def __init__(__self__, *,
                 domain: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 tag: Optional[str] = None):
        """
        Image used to build the Kogito Service from source (Local and Remote). The operator will use the one provided by the Kogito Team based on the "Runtime" field. Example: Domain: quay.io, Namespace: kiegroup, Name: kogito-jvm-builder, Tag: latest. On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
        """
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        return pulumi.get(self, "tag")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoBuildSpecEnvs(dict):
    """
    EnvVar represents an environment variable present in a Container.
    """
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None,
                 value_from: Optional['outputs.KogitoBuildSpecEnvsValueFrom'] = None):
        """
        EnvVar represents an environment variable present in a Container.
        :param str name: Name of the environment variable. Must be a C_IDENTIFIER.
        :param str value: Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        :param 'KogitoBuildSpecEnvsValueFromArgs' value_from: Source for the environment variable's value. Cannot be used if value is not empty.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_from is not None:
            pulumi.set(__self__, "value_from", value_from)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the environment variable. Must be a C_IDENTIFIER.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueFrom")
    def value_from(self) -> Optional['outputs.KogitoBuildSpecEnvsValueFrom']:
        """
        Source for the environment variable's value. Cannot be used if value is not empty.
        """
        return pulumi.get(self, "value_from")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoBuildSpecEnvsValueFrom(dict):
    """
    Source for the environment variable's value. Cannot be used if value is not empty.
    """
    def __init__(__self__, *,
                 config_map_key_ref: Optional['outputs.KogitoBuildSpecEnvsValueFromConfigMapKeyRef'] = None,
                 field_ref: Optional['outputs.KogitoBuildSpecEnvsValueFromFieldRef'] = None,
                 resource_field_ref: Optional['outputs.KogitoBuildSpecEnvsValueFromResourceFieldRef'] = None,
                 secret_key_ref: Optional['outputs.KogitoBuildSpecEnvsValueFromSecretKeyRef'] = None):
        """
        Source for the environment variable's value. Cannot be used if value is not empty.
        :param 'KogitoBuildSpecEnvsValueFromConfigMapKeyRefArgs' config_map_key_ref: Selects a key of a ConfigMap.
        :param 'KogitoBuildSpecEnvsValueFromFieldRefArgs' field_ref: Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        :param 'KogitoBuildSpecEnvsValueFromResourceFieldRefArgs' resource_field_ref: Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        :param 'KogitoBuildSpecEnvsValueFromSecretKeyRefArgs' secret_key_ref: Selects a key of a secret in the pod's namespace
        """
        if config_map_key_ref is not None:
            pulumi.set(__self__, "config_map_key_ref", config_map_key_ref)
        if field_ref is not None:
            pulumi.set(__self__, "field_ref", field_ref)
        if resource_field_ref is not None:
            pulumi.set(__self__, "resource_field_ref", resource_field_ref)
        if secret_key_ref is not None:
            pulumi.set(__self__, "secret_key_ref", secret_key_ref)

    @property
    @pulumi.getter(name="configMapKeyRef")
    def config_map_key_ref(self) -> Optional['outputs.KogitoBuildSpecEnvsValueFromConfigMapKeyRef']:
        """
        Selects a key of a ConfigMap.
        """
        return pulumi.get(self, "config_map_key_ref")

    @property
    @pulumi.getter(name="fieldRef")
    def field_ref(self) -> Optional['outputs.KogitoBuildSpecEnvsValueFromFieldRef']:
        """
        Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        """
        return pulumi.get(self, "field_ref")

    @property
    @pulumi.getter(name="resourceFieldRef")
    def resource_field_ref(self) -> Optional['outputs.KogitoBuildSpecEnvsValueFromResourceFieldRef']:
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        """
        return pulumi.get(self, "resource_field_ref")

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> Optional['outputs.KogitoBuildSpecEnvsValueFromSecretKeyRef']:
        """
        Selects a key of a secret in the pod's namespace
        """
        return pulumi.get(self, "secret_key_ref")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoBuildSpecEnvsValueFromConfigMapKeyRef(dict):
    """
    Selects a key of a ConfigMap.
    """
    def __init__(__self__, *,
                 key: str,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        Selects a key of a ConfigMap.
        :param str key: The key to select.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        :param bool optional: Specify whether the ConfigMap or its key must be defined
        """
        pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key to select.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the ConfigMap or its key must be defined
        """
        return pulumi.get(self, "optional")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoBuildSpecEnvsValueFromFieldRef(dict):
    """
    Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    """
    def __init__(__self__, *,
                 field_path: str,
                 api_version: Optional[str] = None):
        """
        Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        :param str field_path: Path of the field to select in the specified API version.
        :param str api_version: Version of the schema the FieldPath is written in terms of, defaults to "v1".
        """
        pulumi.set(__self__, "field_path", field_path)
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> str:
        """
        Path of the field to select in the specified API version.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        Version of the schema the FieldPath is written in terms of, defaults to "v1".
        """
        return pulumi.get(self, "api_version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoBuildSpecEnvsValueFromResourceFieldRef(dict):
    """
    Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    """
    def __init__(__self__, *,
                 resource: str,
                 container_name: Optional[str] = None,
                 divisor: Optional['outputs.KogitoBuildSpecEnvsValueFromResourceFieldRefDivisor'] = None):
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        :param str resource: Required: resource to select
        :param str container_name: Container name: required for volumes, optional for env vars
        :param 'KogitoBuildSpecEnvsValueFromResourceFieldRefDivisorArgs' divisor: Specifies the output format of the exposed resources, defaults to "1"
        """
        pulumi.set(__self__, "resource", resource)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if divisor is not None:
            pulumi.set(__self__, "divisor", divisor)

    @property
    @pulumi.getter
    def resource(self) -> str:
        """
        Required: resource to select
        """
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[str]:
        """
        Container name: required for volumes, optional for env vars
        """
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def divisor(self) -> Optional['outputs.KogitoBuildSpecEnvsValueFromResourceFieldRefDivisor']:
        """
        Specifies the output format of the exposed resources, defaults to "1"
        """
        return pulumi.get(self, "divisor")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoBuildSpecEnvsValueFromResourceFieldRefDivisor(dict):
    def __init__(__self__):
        pass

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoBuildSpecEnvsValueFromSecretKeyRef(dict):
    """
    Selects a key of a secret in the pod's namespace
    """
    def __init__(__self__, *,
                 key: str,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        Selects a key of a secret in the pod's namespace
        :param str key: The key of the secret to select from.  Must be a valid secret key.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        :param bool optional: Specify whether the Secret or its key must be defined
        """
        pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the secret to select from.  Must be a valid secret key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the Secret or its key must be defined
        """
        return pulumi.get(self, "optional")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoBuildSpecGitSource(dict):
    """
    Information about the git repository where the Kogito Service source code resides. Ignored for binary builds.
    """
    def __init__(__self__, *,
                 uri: str,
                 context_dir: Optional[str] = None,
                 reference: Optional[str] = None):
        """
        Information about the git repository where the Kogito Service source code resides. Ignored for binary builds.
        :param str uri: Git URI for the s2i source.
        :param str context_dir: Context/subdirectory where the code is located, relative to the repo root.
        :param str reference: Branch to use in the Git repository.
        """
        pulumi.set(__self__, "uri", uri)
        if context_dir is not None:
            pulumi.set(__self__, "context_dir", context_dir)
        if reference is not None:
            pulumi.set(__self__, "reference", reference)

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        Git URI for the s2i source.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter(name="contextDir")
    def context_dir(self) -> Optional[str]:
        """
        Context/subdirectory where the code is located, relative to the repo root.
        """
        return pulumi.get(self, "context_dir")

    @property
    @pulumi.getter
    def reference(self) -> Optional[str]:
        """
        Branch to use in the Git repository.
        """
        return pulumi.get(self, "reference")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoBuildSpecResources(dict):
    """
    Resources Requirements for builder pods.
    """
    def __init__(__self__, *,
                 limits: Optional[Mapping[str, 'outputs.KogitoBuildSpecResourcesLimits']] = None,
                 requests: Optional[Mapping[str, 'outputs.KogitoBuildSpecResourcesRequests']] = None):
        """
        Resources Requirements for builder pods.
        :param Mapping[str, 'KogitoBuildSpecResourcesLimitsArgs'] limits: Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        :param Mapping[str, 'KogitoBuildSpecResourcesRequestsArgs'] requests: Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, 'outputs.KogitoBuildSpecResourcesLimits']]:
        """
        Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Mapping[str, 'outputs.KogitoBuildSpecResourcesRequests']]:
        """
        Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "requests")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoBuildSpecResourcesLimits(dict):
    def __init__(__self__):
        pass

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoBuildSpecResourcesRequests(dict):
    def __init__(__self__):
        pass

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoBuildSpecRuntimeImage(dict):
    """
    Image used as the base image for the final Kogito service. This image only has the required packages to run the application. For example: quarkus based services will have only JVM installed, native services only the packages required by the OS. The operator will use the one provided by the Kogito Team based on the "Runtime" field. Example: Domain: quay.io, Namespace: kiegroup, Name: kogito-jvm-builder, Tag: latest. On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
    """
    def __init__(__self__, *,
                 domain: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 tag: Optional[str] = None):
        """
        Image used as the base image for the final Kogito service. This image only has the required packages to run the application. For example: quarkus based services will have only JVM installed, native services only the packages required by the OS. The operator will use the one provided by the Kogito Team based on the "Runtime" field. Example: Domain: quay.io, Namespace: kiegroup, Name: kogito-jvm-builder, Tag: latest. On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
        """
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        return pulumi.get(self, "tag")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoBuildSpecWebHooks(dict):
    """
    WebHookSecret Secret to use for a given webHook.
    """
    def __init__(__self__, *,
                 secret: Optional[str] = None,
                 type: Optional[str] = None):
        """
        WebHookSecret Secret to use for a given webHook.
        :param str secret: Secret value for webHook
        :param str type: WebHook type, either GitHub or Generic.
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def secret(self) -> Optional[str]:
        """
        Secret value for webHook
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        WebHook type, either GitHub or Generic.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoBuildStatus(dict):
    """
    KogitoBuildStatus defines the observed state of KogitoBuild.
    """
    def __init__(__self__, *,
                 builds: 'outputs.KogitoBuildStatusBuilds',
                 conditions: Sequence['outputs.KogitoBuildStatusConditions'],
                 latest_build: Optional[str] = None):
        """
        KogitoBuildStatus defines the observed state of KogitoBuild.
        :param 'KogitoBuildStatusBuildsArgs' builds: History of builds
        :param Sequence['KogitoBuildStatusConditionsArgs'] conditions: History of conditions for the resource, shows the status of the younger builder controlled by this instance
        """
        pulumi.set(__self__, "builds", builds)
        pulumi.set(__self__, "conditions", conditions)
        if latest_build is not None:
            pulumi.set(__self__, "latest_build", latest_build)

    @property
    @pulumi.getter
    def builds(self) -> 'outputs.KogitoBuildStatusBuilds':
        """
        History of builds
        """
        return pulumi.get(self, "builds")

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.KogitoBuildStatusConditions']:
        """
        History of conditions for the resource, shows the status of the younger builder controlled by this instance
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="latestBuild")
    def latest_build(self) -> Optional[str]:
        return pulumi.get(self, "latest_build")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoBuildStatusBuilds(dict):
    """
    History of builds
    """
    def __init__(__self__, *,
                 cancelled: Optional[Sequence[str]] = None,
                 complete: Optional[Sequence[str]] = None,
                 error: Optional[Sequence[str]] = None,
                 failed: Optional[Sequence[str]] = None,
                 new: Optional[Sequence[str]] = None,
                 pending: Optional[Sequence[str]] = None,
                 running: Optional[Sequence[str]] = None):
        """
        History of builds
        :param Sequence[str] cancelled: Builds have been stopped from executing.
        :param Sequence[str] complete: Builds have executed and succeeded.
        :param Sequence[str] error: Builds have been prevented from executing by an error.
        :param Sequence[str] failed: Builds have executed and failed.
        :param Sequence[str] new: Builds are being created.
        :param Sequence[str] pending: Builds are about to start running.
        :param Sequence[str] running: Builds are running.
        """
        if cancelled is not None:
            pulumi.set(__self__, "cancelled", cancelled)
        if complete is not None:
            pulumi.set(__self__, "complete", complete)
        if error is not None:
            pulumi.set(__self__, "error", error)
        if failed is not None:
            pulumi.set(__self__, "failed", failed)
        if new is not None:
            pulumi.set(__self__, "new", new)
        if pending is not None:
            pulumi.set(__self__, "pending", pending)
        if running is not None:
            pulumi.set(__self__, "running", running)

    @property
    @pulumi.getter
    def cancelled(self) -> Optional[Sequence[str]]:
        """
        Builds have been stopped from executing.
        """
        return pulumi.get(self, "cancelled")

    @property
    @pulumi.getter
    def complete(self) -> Optional[Sequence[str]]:
        """
        Builds have executed and succeeded.
        """
        return pulumi.get(self, "complete")

    @property
    @pulumi.getter
    def error(self) -> Optional[Sequence[str]]:
        """
        Builds have been prevented from executing by an error.
        """
        return pulumi.get(self, "error")

    @property
    @pulumi.getter
    def failed(self) -> Optional[Sequence[str]]:
        """
        Builds have executed and failed.
        """
        return pulumi.get(self, "failed")

    @property
    @pulumi.getter
    def new(self) -> Optional[Sequence[str]]:
        """
        Builds are being created.
        """
        return pulumi.get(self, "new")

    @property
    @pulumi.getter
    def pending(self) -> Optional[Sequence[str]]:
        """
        Builds are about to start running.
        """
        return pulumi.get(self, "pending")

    @property
    @pulumi.getter
    def running(self) -> Optional[Sequence[str]]:
        """
        Builds are running.
        """
        return pulumi.get(self, "running")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoBuildStatusConditions(dict):
    """
    KogitoBuildConditions describes the conditions for this build instance according to Kubernetes status interface.
    """
    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None):
        """
        KogitoBuildConditions describes the conditions for this build instance according to Kubernetes status interface.
        :param str status: Status ...
        :param str type: Type of this condition
        :param str last_transition_time: LastTransitionTime ...
        :param str message: Message ...
        :param str reason: Reason of this condition
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status ...
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of this condition
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        LastTransitionTime ...
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Message ...
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        Reason of this condition
        """
        return pulumi.get(self, "reason")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoDataIndexSpec(dict):
    """
    KogitoDataIndexSpec defines the desired state of KogitoDataIndex.
    """
    def __init__(__self__, *,
                 deployment_labels: Optional[Mapping[str, str]] = None,
                 envs: Optional[Sequence['outputs.KogitoDataIndexSpecEnvs']] = None,
                 http_port: Optional[int] = None,
                 image: Optional['outputs.KogitoDataIndexSpecImage'] = None,
                 infinispan: Optional['outputs.KogitoDataIndexSpecInfinispan'] = None,
                 insecure_image_registry: Optional[bool] = None,
                 kafka: Optional['outputs.KogitoDataIndexSpecKafka'] = None,
                 replicas: Optional[int] = None,
                 resources: Optional['outputs.KogitoDataIndexSpecResources'] = None,
                 service_labels: Optional[Mapping[str, str]] = None):
        """
        KogitoDataIndexSpec defines the desired state of KogitoDataIndex.
        :param Mapping[str, str] deployment_labels: Additional labels to be added to the Deployment and Pods managed by the operator.
        :param Sequence['KogitoDataIndexSpecEnvsArgs'] envs: Environment variables to be added to the runtime container. Keys must be a C_IDENTIFIER.
        :param int http_port: HttpPort will set the environment env HTTP_PORT to define which port service will listen internally.
        :param 'KogitoDataIndexSpecImageArgs' image: Image definition for the service. Example: Domain: quay.io, Namespace: kiegroup, Name: kogito-service, Tag: latest. On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
        :param 'KogitoDataIndexSpecInfinispanArgs' infinispan: Has the data used by the service to connect to the Infinispan cluster.
        :param bool insecure_image_registry: A flag indicating that image streams created by Kogito Operator should be configured to allow pulling from insecure registries. Usable just on OpenShift. Defaults to 'false'.
        :param 'KogitoDataIndexSpecKafkaArgs' kafka: Has the data used by the service to connect to the Kafka cluster.
        :param int replicas: Number of replicas that the service will have deployed in the cluster. Default value: 1.
        :param 'KogitoDataIndexSpecResourcesArgs' resources: Defined compute resource requirements for the deployed service.
        :param Mapping[str, str] service_labels: Additional labels to be added to the Service managed by the operator.
        """
        if deployment_labels is not None:
            pulumi.set(__self__, "deployment_labels", deployment_labels)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if http_port is not None:
            pulumi.set(__self__, "http_port", http_port)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if infinispan is not None:
            pulumi.set(__self__, "infinispan", infinispan)
        if insecure_image_registry is not None:
            pulumi.set(__self__, "insecure_image_registry", insecure_image_registry)
        if kafka is not None:
            pulumi.set(__self__, "kafka", kafka)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if service_labels is not None:
            pulumi.set(__self__, "service_labels", service_labels)

    @property
    @pulumi.getter(name="deploymentLabels")
    def deployment_labels(self) -> Optional[Mapping[str, str]]:
        """
        Additional labels to be added to the Deployment and Pods managed by the operator.
        """
        return pulumi.get(self, "deployment_labels")

    @property
    @pulumi.getter
    def envs(self) -> Optional[Sequence['outputs.KogitoDataIndexSpecEnvs']]:
        """
        Environment variables to be added to the runtime container. Keys must be a C_IDENTIFIER.
        """
        return pulumi.get(self, "envs")

    @property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[int]:
        """
        HttpPort will set the environment env HTTP_PORT to define which port service will listen internally.
        """
        return pulumi.get(self, "http_port")

    @property
    @pulumi.getter
    def image(self) -> Optional['outputs.KogitoDataIndexSpecImage']:
        """
        Image definition for the service. Example: Domain: quay.io, Namespace: kiegroup, Name: kogito-service, Tag: latest. On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def infinispan(self) -> Optional['outputs.KogitoDataIndexSpecInfinispan']:
        """
        Has the data used by the service to connect to the Infinispan cluster.
        """
        return pulumi.get(self, "infinispan")

    @property
    @pulumi.getter(name="insecureImageRegistry")
    def insecure_image_registry(self) -> Optional[bool]:
        """
        A flag indicating that image streams created by Kogito Operator should be configured to allow pulling from insecure registries. Usable just on OpenShift. Defaults to 'false'.
        """
        return pulumi.get(self, "insecure_image_registry")

    @property
    @pulumi.getter
    def kafka(self) -> Optional['outputs.KogitoDataIndexSpecKafka']:
        """
        Has the data used by the service to connect to the Kafka cluster.
        """
        return pulumi.get(self, "kafka")

    @property
    @pulumi.getter
    def replicas(self) -> Optional[int]:
        """
        Number of replicas that the service will have deployed in the cluster. Default value: 1.
        """
        return pulumi.get(self, "replicas")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.KogitoDataIndexSpecResources']:
        """
        Defined compute resource requirements for the deployed service.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter(name="serviceLabels")
    def service_labels(self) -> Optional[Mapping[str, str]]:
        """
        Additional labels to be added to the Service managed by the operator.
        """
        return pulumi.get(self, "service_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoDataIndexSpecEnvs(dict):
    """
    EnvVar represents an environment variable present in a Container.
    """
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None,
                 value_from: Optional['outputs.KogitoDataIndexSpecEnvsValueFrom'] = None):
        """
        EnvVar represents an environment variable present in a Container.
        :param str name: Name of the environment variable. Must be a C_IDENTIFIER.
        :param str value: Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        :param 'KogitoDataIndexSpecEnvsValueFromArgs' value_from: Source for the environment variable's value. Cannot be used if value is not empty.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_from is not None:
            pulumi.set(__self__, "value_from", value_from)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the environment variable. Must be a C_IDENTIFIER.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueFrom")
    def value_from(self) -> Optional['outputs.KogitoDataIndexSpecEnvsValueFrom']:
        """
        Source for the environment variable's value. Cannot be used if value is not empty.
        """
        return pulumi.get(self, "value_from")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoDataIndexSpecEnvsValueFrom(dict):
    """
    Source for the environment variable's value. Cannot be used if value is not empty.
    """
    def __init__(__self__, *,
                 config_map_key_ref: Optional['outputs.KogitoDataIndexSpecEnvsValueFromConfigMapKeyRef'] = None,
                 field_ref: Optional['outputs.KogitoDataIndexSpecEnvsValueFromFieldRef'] = None,
                 resource_field_ref: Optional['outputs.KogitoDataIndexSpecEnvsValueFromResourceFieldRef'] = None,
                 secret_key_ref: Optional['outputs.KogitoDataIndexSpecEnvsValueFromSecretKeyRef'] = None):
        """
        Source for the environment variable's value. Cannot be used if value is not empty.
        :param 'KogitoDataIndexSpecEnvsValueFromConfigMapKeyRefArgs' config_map_key_ref: Selects a key of a ConfigMap.
        :param 'KogitoDataIndexSpecEnvsValueFromFieldRefArgs' field_ref: Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        :param 'KogitoDataIndexSpecEnvsValueFromResourceFieldRefArgs' resource_field_ref: Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        :param 'KogitoDataIndexSpecEnvsValueFromSecretKeyRefArgs' secret_key_ref: Selects a key of a secret in the pod's namespace
        """
        if config_map_key_ref is not None:
            pulumi.set(__self__, "config_map_key_ref", config_map_key_ref)
        if field_ref is not None:
            pulumi.set(__self__, "field_ref", field_ref)
        if resource_field_ref is not None:
            pulumi.set(__self__, "resource_field_ref", resource_field_ref)
        if secret_key_ref is not None:
            pulumi.set(__self__, "secret_key_ref", secret_key_ref)

    @property
    @pulumi.getter(name="configMapKeyRef")
    def config_map_key_ref(self) -> Optional['outputs.KogitoDataIndexSpecEnvsValueFromConfigMapKeyRef']:
        """
        Selects a key of a ConfigMap.
        """
        return pulumi.get(self, "config_map_key_ref")

    @property
    @pulumi.getter(name="fieldRef")
    def field_ref(self) -> Optional['outputs.KogitoDataIndexSpecEnvsValueFromFieldRef']:
        """
        Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        """
        return pulumi.get(self, "field_ref")

    @property
    @pulumi.getter(name="resourceFieldRef")
    def resource_field_ref(self) -> Optional['outputs.KogitoDataIndexSpecEnvsValueFromResourceFieldRef']:
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        """
        return pulumi.get(self, "resource_field_ref")

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> Optional['outputs.KogitoDataIndexSpecEnvsValueFromSecretKeyRef']:
        """
        Selects a key of a secret in the pod's namespace
        """
        return pulumi.get(self, "secret_key_ref")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoDataIndexSpecEnvsValueFromConfigMapKeyRef(dict):
    """
    Selects a key of a ConfigMap.
    """
    def __init__(__self__, *,
                 key: str,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        Selects a key of a ConfigMap.
        :param str key: The key to select.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        :param bool optional: Specify whether the ConfigMap or its key must be defined
        """
        pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key to select.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the ConfigMap or its key must be defined
        """
        return pulumi.get(self, "optional")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoDataIndexSpecEnvsValueFromFieldRef(dict):
    """
    Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    """
    def __init__(__self__, *,
                 field_path: str,
                 api_version: Optional[str] = None):
        """
        Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        :param str field_path: Path of the field to select in the specified API version.
        :param str api_version: Version of the schema the FieldPath is written in terms of, defaults to "v1".
        """
        pulumi.set(__self__, "field_path", field_path)
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> str:
        """
        Path of the field to select in the specified API version.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        Version of the schema the FieldPath is written in terms of, defaults to "v1".
        """
        return pulumi.get(self, "api_version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoDataIndexSpecEnvsValueFromResourceFieldRef(dict):
    """
    Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    """
    def __init__(__self__, *,
                 resource: str,
                 container_name: Optional[str] = None,
                 divisor: Optional['outputs.KogitoDataIndexSpecEnvsValueFromResourceFieldRefDivisor'] = None):
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        :param str resource: Required: resource to select
        :param str container_name: Container name: required for volumes, optional for env vars
        :param 'KogitoDataIndexSpecEnvsValueFromResourceFieldRefDivisorArgs' divisor: Specifies the output format of the exposed resources, defaults to "1"
        """
        pulumi.set(__self__, "resource", resource)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if divisor is not None:
            pulumi.set(__self__, "divisor", divisor)

    @property
    @pulumi.getter
    def resource(self) -> str:
        """
        Required: resource to select
        """
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[str]:
        """
        Container name: required for volumes, optional for env vars
        """
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def divisor(self) -> Optional['outputs.KogitoDataIndexSpecEnvsValueFromResourceFieldRefDivisor']:
        """
        Specifies the output format of the exposed resources, defaults to "1"
        """
        return pulumi.get(self, "divisor")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoDataIndexSpecEnvsValueFromResourceFieldRefDivisor(dict):
    def __init__(__self__):
        pass

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoDataIndexSpecEnvsValueFromSecretKeyRef(dict):
    """
    Selects a key of a secret in the pod's namespace
    """
    def __init__(__self__, *,
                 key: str,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        Selects a key of a secret in the pod's namespace
        :param str key: The key of the secret to select from.  Must be a valid secret key.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        :param bool optional: Specify whether the Secret or its key must be defined
        """
        pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the secret to select from.  Must be a valid secret key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the Secret or its key must be defined
        """
        return pulumi.get(self, "optional")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoDataIndexSpecImage(dict):
    """
    Image definition for the service. Example: Domain: quay.io, Namespace: kiegroup, Name: kogito-service, Tag: latest. On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
    """
    def __init__(__self__, *,
                 domain: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 tag: Optional[str] = None):
        """
        Image definition for the service. Example: Domain: quay.io, Namespace: kiegroup, Name: kogito-service, Tag: latest. On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
        """
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        return pulumi.get(self, "tag")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoDataIndexSpecInfinispan(dict):
    """
    Has the data used by the service to connect to the Infinispan cluster.
    """
    def __init__(__self__, *,
                 auth_realm: Optional[str] = None,
                 credentials: Optional['outputs.KogitoDataIndexSpecInfinispanCredentials'] = None,
                 sasl_mechanism: Optional[str] = None,
                 uri: Optional[str] = None,
                 use_auth: Optional[bool] = None,
                 use_kogito_infra: Optional[bool] = None):
        """
        Has the data used by the service to connect to the Infinispan cluster.
        :param str auth_realm: Name of the Infinispan authentication realm. This sets the property infinispan.client.hotrod.auth_realm.
        :param 'KogitoDataIndexSpecInfinispanCredentialsArgs' credentials: SecretCredentialsType is the data structure for specifying credentials within a Secret.
        :param str sasl_mechanism: SaslMechanism defined for the authentication. This sets the property infinispan.client.hotrod.sasl_mechanism.
        :param str uri: URI to connect to the Infinispan cluster (can it be an internal service or external URI), for example, myinfinispan-cluster:11222.
        :param bool use_auth: UseAuth is set to true if the credentials are set. This also sets the property infinispan.client.hotrod.use_auth.
        :param bool use_kogito_infra: UseKogitoInfra flags if the instance will use a provided infrastructure by KogitoInfra CR. Setting this to true will deploy a new KogitoInfra CR into the namespace that will install Infinispan via Infinispan Operator. Infinispan Operator MUST be installed in the namespace for this to work. On OpenShift, OLM should install it for you. If running on Kubernetes without OLM installed, please install Infinispan Operator first. Set this to false and fill all other properties to provide your own infrastructure.
        """
        if auth_realm is not None:
            pulumi.set(__self__, "auth_realm", auth_realm)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if sasl_mechanism is not None:
            pulumi.set(__self__, "sasl_mechanism", sasl_mechanism)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)
        if use_auth is not None:
            pulumi.set(__self__, "use_auth", use_auth)
        if use_kogito_infra is not None:
            pulumi.set(__self__, "use_kogito_infra", use_kogito_infra)

    @property
    @pulumi.getter(name="authRealm")
    def auth_realm(self) -> Optional[str]:
        """
        Name of the Infinispan authentication realm. This sets the property infinispan.client.hotrod.auth_realm.
        """
        return pulumi.get(self, "auth_realm")

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.KogitoDataIndexSpecInfinispanCredentials']:
        """
        SecretCredentialsType is the data structure for specifying credentials within a Secret.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="saslMechanism")
    def sasl_mechanism(self) -> Optional[str]:
        """
        SaslMechanism defined for the authentication. This sets the property infinispan.client.hotrod.sasl_mechanism.
        """
        return pulumi.get(self, "sasl_mechanism")

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        """
        URI to connect to the Infinispan cluster (can it be an internal service or external URI), for example, myinfinispan-cluster:11222.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter(name="useAuth")
    def use_auth(self) -> Optional[bool]:
        """
        UseAuth is set to true if the credentials are set. This also sets the property infinispan.client.hotrod.use_auth.
        """
        return pulumi.get(self, "use_auth")

    @property
    @pulumi.getter(name="useKogitoInfra")
    def use_kogito_infra(self) -> Optional[bool]:
        """
        UseKogitoInfra flags if the instance will use a provided infrastructure by KogitoInfra CR. Setting this to true will deploy a new KogitoInfra CR into the namespace that will install Infinispan via Infinispan Operator. Infinispan Operator MUST be installed in the namespace for this to work. On OpenShift, OLM should install it for you. If running on Kubernetes without OLM installed, please install Infinispan Operator first. Set this to false and fill all other properties to provide your own infrastructure.
        """
        return pulumi.get(self, "use_kogito_infra")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoDataIndexSpecInfinispanCredentials(dict):
    """
    SecretCredentialsType is the data structure for specifying credentials within a Secret.
    """
    def __init__(__self__, *,
                 password_key: Optional[str] = None,
                 secret_name: Optional[str] = None,
                 username_key: Optional[str] = None):
        """
        SecretCredentialsType is the data structure for specifying credentials within a Secret.
        :param str password_key: PasswordKey is the key pointing to a value in a Secret holding the password value.
        :param str secret_name: SecretName is the name of the secret where the credentials are set.
        :param str username_key: UsernameKey is the key pointing to a value in a Secret holding the username value.
        """
        if password_key is not None:
            pulumi.set(__self__, "password_key", password_key)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)
        if username_key is not None:
            pulumi.set(__self__, "username_key", username_key)

    @property
    @pulumi.getter(name="passwordKey")
    def password_key(self) -> Optional[str]:
        """
        PasswordKey is the key pointing to a value in a Secret holding the password value.
        """
        return pulumi.get(self, "password_key")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[str]:
        """
        SecretName is the name of the secret where the credentials are set.
        """
        return pulumi.get(self, "secret_name")

    @property
    @pulumi.getter(name="usernameKey")
    def username_key(self) -> Optional[str]:
        """
        UsernameKey is the key pointing to a value in a Secret holding the username value.
        """
        return pulumi.get(self, "username_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoDataIndexSpecKafka(dict):
    """
    Has the data used by the service to connect to the Kafka cluster.
    """
    def __init__(__self__, *,
                 external_uri: Optional[str] = None,
                 instance: Optional[str] = None,
                 use_kogito_infra: Optional[bool] = None):
        """
        Has the data used by the service to connect to the Kafka cluster.
        :param str external_uri: URI is the service URI to connect to the Kafka cluster, for example, my-cluster-kafka-bootstrap:9092.
        :param str instance: Instance is the Kafka instance to be used, for example, kogito-kafka.
        :param bool use_kogito_infra: UseKogitoInfra flags if the instance will use a provided infrastructure by KogitoInfra CR. Setting this to true will configure a KogitoInfra CR to install Kafka via Strimzi Operator. Strimzi Operator MUST be installed in the namespace for this to work. On OpenShift, OLM should install it for you. If running on Kubernetes without OLM installed, please install Strimzi Operator first. Set this to false and fill other properties to provide your own infrastructure.
        """
        if external_uri is not None:
            pulumi.set(__self__, "external_uri", external_uri)
        if instance is not None:
            pulumi.set(__self__, "instance", instance)
        if use_kogito_infra is not None:
            pulumi.set(__self__, "use_kogito_infra", use_kogito_infra)

    @property
    @pulumi.getter(name="externalURI")
    def external_uri(self) -> Optional[str]:
        """
        URI is the service URI to connect to the Kafka cluster, for example, my-cluster-kafka-bootstrap:9092.
        """
        return pulumi.get(self, "external_uri")

    @property
    @pulumi.getter
    def instance(self) -> Optional[str]:
        """
        Instance is the Kafka instance to be used, for example, kogito-kafka.
        """
        return pulumi.get(self, "instance")

    @property
    @pulumi.getter(name="useKogitoInfra")
    def use_kogito_infra(self) -> Optional[bool]:
        """
        UseKogitoInfra flags if the instance will use a provided infrastructure by KogitoInfra CR. Setting this to true will configure a KogitoInfra CR to install Kafka via Strimzi Operator. Strimzi Operator MUST be installed in the namespace for this to work. On OpenShift, OLM should install it for you. If running on Kubernetes without OLM installed, please install Strimzi Operator first. Set this to false and fill other properties to provide your own infrastructure.
        """
        return pulumi.get(self, "use_kogito_infra")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoDataIndexSpecResources(dict):
    """
    Defined compute resource requirements for the deployed service.
    """
    def __init__(__self__, *,
                 limits: Optional[Mapping[str, 'outputs.KogitoDataIndexSpecResourcesLimits']] = None,
                 requests: Optional[Mapping[str, 'outputs.KogitoDataIndexSpecResourcesRequests']] = None):
        """
        Defined compute resource requirements for the deployed service.
        :param Mapping[str, 'KogitoDataIndexSpecResourcesLimitsArgs'] limits: Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        :param Mapping[str, 'KogitoDataIndexSpecResourcesRequestsArgs'] requests: Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, 'outputs.KogitoDataIndexSpecResourcesLimits']]:
        """
        Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Mapping[str, 'outputs.KogitoDataIndexSpecResourcesRequests']]:
        """
        Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "requests")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoDataIndexSpecResourcesLimits(dict):
    def __init__(__self__):
        pass

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoDataIndexSpecResourcesRequests(dict):
    def __init__(__self__):
        pass

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoDataIndexStatus(dict):
    """
    KogitoDataIndexStatus defines the observed state of KogitoDataIndex.
    """
    def __init__(__self__, *,
                 conditions: Sequence['outputs.KogitoDataIndexStatusConditions'],
                 deployment_conditions: Optional[Sequence['outputs.KogitoDataIndexStatusDeploymentConditions']] = None,
                 external_uri: Optional[str] = None,
                 image: Optional[str] = None):
        """
        KogitoDataIndexStatus defines the observed state of KogitoDataIndex.
        :param Sequence['KogitoDataIndexStatusConditionsArgs'] conditions: History of conditions for the resource
        :param Sequence['KogitoDataIndexStatusDeploymentConditionsArgs'] deployment_conditions: General conditions for the Kogito Service deployment.
        :param str external_uri: URI is where the service is exposed.
        :param str image: Image is the resolved image for this service.
        """
        pulumi.set(__self__, "conditions", conditions)
        if deployment_conditions is not None:
            pulumi.set(__self__, "deployment_conditions", deployment_conditions)
        if external_uri is not None:
            pulumi.set(__self__, "external_uri", external_uri)
        if image is not None:
            pulumi.set(__self__, "image", image)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.KogitoDataIndexStatusConditions']:
        """
        History of conditions for the resource
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="deploymentConditions")
    def deployment_conditions(self) -> Optional[Sequence['outputs.KogitoDataIndexStatusDeploymentConditions']]:
        """
        General conditions for the Kogito Service deployment.
        """
        return pulumi.get(self, "deployment_conditions")

    @property
    @pulumi.getter(name="externalURI")
    def external_uri(self) -> Optional[str]:
        """
        URI is where the service is exposed.
        """
        return pulumi.get(self, "external_uri")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        Image is the resolved image for this service.
        """
        return pulumi.get(self, "image")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoDataIndexStatusConditions(dict):
    """
    Condition is the detailed condition for the resource
    """
    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None):
        """
        Condition is the detailed condition for the resource
        :param str type: ConditionType is the type of condition
        :param str reason: ReasonType is the type of reason
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        ConditionType is the type of condition
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        ReasonType is the type of reason
        """
        return pulumi.get(self, "reason")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoDataIndexStatusDeploymentConditions(dict):
    """
    DeploymentCondition describes the state of a deployment at a certain point.
    """
    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 last_update_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None):
        """
        DeploymentCondition describes the state of a deployment at a certain point.
        :param str status: Status of the condition, one of True, False, Unknown.
        :param str type: Type of deployment condition.
        :param str last_transition_time: Last time the condition transitioned from one status to another.
        :param str last_update_time: The last time this condition was updated.
        :param str message: A human readable message indicating details about the transition.
        :param str reason: The reason for the condition's last transition.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if last_update_time is not None:
            pulumi.set(__self__, "last_update_time", last_update_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of deployment condition.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        Last time the condition transitioned from one status to another.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter(name="lastUpdateTime")
    def last_update_time(self) -> Optional[str]:
        """
        The last time this condition was updated.
        """
        return pulumi.get(self, "last_update_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        A human readable message indicating details about the transition.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        The reason for the condition's last transition.
        """
        return pulumi.get(self, "reason")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoInfraSpec(dict):
    """
    KogitoInfraSpec defines the desired state of KogitoInfra.
    """
    def __init__(__self__, *,
                 install_infinispan: Optional[bool] = None,
                 install_kafka: Optional[bool] = None,
                 install_keycloak: Optional[bool] = None):
        """
        KogitoInfraSpec defines the desired state of KogitoInfra.
        :param bool install_infinispan: Indicates if Infinispan should be installed or not using Infinispan Operator. Please note that the Infinispan Operator must be installed manually on environments that doesn't have OLM installed.
        :param bool install_kafka: Indicates if Kafka should be installed or not using Strimzi (Kafka Operator). Please note that the Strimzi must be installed manually on environments that doesn't have OLM installed.
        :param bool install_keycloak: Whether or not to install Keycloak using Keycloak Operator. Please note that the Keycloak Operator must be installed manually on environments that doesn't have OLM installed.
        """
        if install_infinispan is not None:
            pulumi.set(__self__, "install_infinispan", install_infinispan)
        if install_kafka is not None:
            pulumi.set(__self__, "install_kafka", install_kafka)
        if install_keycloak is not None:
            pulumi.set(__self__, "install_keycloak", install_keycloak)

    @property
    @pulumi.getter(name="installInfinispan")
    def install_infinispan(self) -> Optional[bool]:
        """
        Indicates if Infinispan should be installed or not using Infinispan Operator. Please note that the Infinispan Operator must be installed manually on environments that doesn't have OLM installed.
        """
        return pulumi.get(self, "install_infinispan")

    @property
    @pulumi.getter(name="installKafka")
    def install_kafka(self) -> Optional[bool]:
        """
        Indicates if Kafka should be installed or not using Strimzi (Kafka Operator). Please note that the Strimzi must be installed manually on environments that doesn't have OLM installed.
        """
        return pulumi.get(self, "install_kafka")

    @property
    @pulumi.getter(name="installKeycloak")
    def install_keycloak(self) -> Optional[bool]:
        """
        Whether or not to install Keycloak using Keycloak Operator. Please note that the Keycloak Operator must be installed manually on environments that doesn't have OLM installed.
        """
        return pulumi.get(self, "install_keycloak")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoInfraStatus(dict):
    """
    KogitoInfraStatus defines the observed state of KogitoInfra.
    """
    def __init__(__self__, *,
                 condition: Optional['outputs.KogitoInfraStatusCondition'] = None,
                 infinispan: Optional['outputs.KogitoInfraStatusInfinispan'] = None,
                 kafka: Optional['outputs.KogitoInfraStatusKafka'] = None,
                 keycloak: Optional['outputs.KogitoInfraStatusKeycloak'] = None):
        """
        KogitoInfraStatus defines the observed state of KogitoInfra.
        :param 'KogitoInfraStatusConditionArgs' condition: KogitoInfraCondition ...
        :param 'KogitoInfraStatusInfinispanArgs' infinispan: InfinispanInstallStatus defines the Infinispan installation status.
        :param 'KogitoInfraStatusKafkaArgs' kafka: InfraComponentInstallStatusType is the base structure to define the status for an actor in the infrastructure.
        :param 'KogitoInfraStatusKeycloakArgs' keycloak: InfraComponentInstallStatusType is the base structure to define the status for an actor in the infrastructure.
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if infinispan is not None:
            pulumi.set(__self__, "infinispan", infinispan)
        if kafka is not None:
            pulumi.set(__self__, "kafka", kafka)
        if keycloak is not None:
            pulumi.set(__self__, "keycloak", keycloak)

    @property
    @pulumi.getter
    def condition(self) -> Optional['outputs.KogitoInfraStatusCondition']:
        """
        KogitoInfraCondition ...
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def infinispan(self) -> Optional['outputs.KogitoInfraStatusInfinispan']:
        """
        InfinispanInstallStatus defines the Infinispan installation status.
        """
        return pulumi.get(self, "infinispan")

    @property
    @pulumi.getter
    def kafka(self) -> Optional['outputs.KogitoInfraStatusKafka']:
        """
        InfraComponentInstallStatusType is the base structure to define the status for an actor in the infrastructure.
        """
        return pulumi.get(self, "kafka")

    @property
    @pulumi.getter
    def keycloak(self) -> Optional['outputs.KogitoInfraStatusKeycloak']:
        """
        InfraComponentInstallStatusType is the base structure to define the status for an actor in the infrastructure.
        """
        return pulumi.get(self, "keycloak")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoInfraStatusCondition(dict):
    """
    KogitoInfraCondition ...
    """
    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None):
        """
        KogitoInfraCondition ...
        :param str type: KogitoInfraConditionType ...
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        KogitoInfraConditionType ...
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoInfraStatusInfinispan(dict):
    """
    InfinispanInstallStatus defines the Infinispan installation status.
    """
    def __init__(__self__, *,
                 condition: Optional[Sequence['outputs.KogitoInfraStatusInfinispanCondition']] = None,
                 credential_secret: Optional[str] = None,
                 name: Optional[str] = None,
                 service: Optional[str] = None):
        """
        InfinispanInstallStatus defines the Infinispan installation status.
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if credential_secret is not None:
            pulumi.set(__self__, "credential_secret", credential_secret)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def condition(self) -> Optional[Sequence['outputs.KogitoInfraStatusInfinispanCondition']]:
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter(name="credentialSecret")
    def credential_secret(self) -> Optional[str]:
        return pulumi.get(self, "credential_secret")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        return pulumi.get(self, "service")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoInfraStatusInfinispanCondition(dict):
    """
    InstallCondition defines the installation condition for the infrastructure actor.
    """
    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None):
        """
        InstallCondition defines the installation condition for the infrastructure actor.
        :param str type: InstallConditionType defines the possibles conditions that a install might have.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        InstallConditionType defines the possibles conditions that a install might have.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoInfraStatusKafka(dict):
    """
    InfraComponentInstallStatusType is the base structure to define the status for an actor in the infrastructure.
    """
    def __init__(__self__, *,
                 condition: Optional[Sequence['outputs.KogitoInfraStatusKafkaCondition']] = None,
                 name: Optional[str] = None,
                 service: Optional[str] = None):
        """
        InfraComponentInstallStatusType is the base structure to define the status for an actor in the infrastructure.
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def condition(self) -> Optional[Sequence['outputs.KogitoInfraStatusKafkaCondition']]:
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        return pulumi.get(self, "service")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoInfraStatusKafkaCondition(dict):
    """
    InstallCondition defines the installation condition for the infrastructure actor.
    """
    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None):
        """
        InstallCondition defines the installation condition for the infrastructure actor.
        :param str type: InstallConditionType defines the possibles conditions that a install might have.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        InstallConditionType defines the possibles conditions that a install might have.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoInfraStatusKeycloak(dict):
    """
    InfraComponentInstallStatusType is the base structure to define the status for an actor in the infrastructure.
    """
    def __init__(__self__, *,
                 condition: Optional[Sequence['outputs.KogitoInfraStatusKeycloakCondition']] = None,
                 name: Optional[str] = None,
                 service: Optional[str] = None):
        """
        InfraComponentInstallStatusType is the base structure to define the status for an actor in the infrastructure.
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def condition(self) -> Optional[Sequence['outputs.KogitoInfraStatusKeycloakCondition']]:
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        return pulumi.get(self, "service")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoInfraStatusKeycloakCondition(dict):
    """
    InstallCondition defines the installation condition for the infrastructure actor.
    """
    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None):
        """
        InstallCondition defines the installation condition for the infrastructure actor.
        :param str type: InstallConditionType defines the possibles conditions that a install might have.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        InstallConditionType defines the possibles conditions that a install might have.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoJobsServiceSpec(dict):
    """
    KogitoJobsServiceSpec defines the desired state of KogitoJobsService.
    """
    def __init__(__self__, *,
                 back_off_retry_millis: Optional[int] = None,
                 deployment_labels: Optional[Mapping[str, str]] = None,
                 envs: Optional[Sequence['outputs.KogitoJobsServiceSpecEnvs']] = None,
                 http_port: Optional[int] = None,
                 image: Optional['outputs.KogitoJobsServiceSpecImage'] = None,
                 infinispan: Optional['outputs.KogitoJobsServiceSpecInfinispan'] = None,
                 insecure_image_registry: Optional[bool] = None,
                 kafka: Optional['outputs.KogitoJobsServiceSpecKafka'] = None,
                 max_interval_limit_to_retry_millis: Optional[int] = None,
                 replicas: Optional[int] = None,
                 resources: Optional['outputs.KogitoJobsServiceSpecResources'] = None,
                 service_labels: Optional[Mapping[str, str]] = None):
        """
        KogitoJobsServiceSpec defines the desired state of KogitoJobsService.
        :param int back_off_retry_millis: Retry backOff time in milliseconds between the job execution attempts, in case of execution failure. Default to service default, see: https://github.com/kiegroup/kogito-runtimes/wiki/Jobs-Service#configuration-properties
        :param Mapping[str, str] deployment_labels: Additional labels to be added to the Deployment and Pods managed by the operator.
        :param Sequence['KogitoJobsServiceSpecEnvsArgs'] envs: Environment variables to be added to the runtime container. Keys must be a C_IDENTIFIER.
        :param int http_port: HttpPort will set the environment env HTTP_PORT to define which port service will listen internally.
        :param 'KogitoJobsServiceSpecImageArgs' image: Image definition for the service. Example: Domain: quay.io, Namespace: kiegroup, Name: kogito-service, Tag: latest. On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
        :param 'KogitoJobsServiceSpecInfinispanArgs' infinispan: Has the data used by the service to connect to the Infinispan cluster.
        :param bool insecure_image_registry: A flag indicating that image streams created by Kogito Operator should be configured to allow pulling from insecure registries. Usable just on OpenShift. Defaults to 'false'.
        :param 'KogitoJobsServiceSpecKafkaArgs' kafka: Has the data used by the service to connect to the Kafka cluster.
        :param int max_interval_limit_to_retry_millis: Maximum interval in milliseconds when retrying to execute jobs, in case of failures. Default to service default, see: https://github.com/kiegroup/kogito-runtimes/wiki/Jobs-Service#configuration-properties
        :param int replicas: Number of replicas that the service will have deployed in the cluster. Default value: 1.
        :param 'KogitoJobsServiceSpecResourcesArgs' resources: Defined compute resource requirements for the deployed service.
        :param Mapping[str, str] service_labels: Additional labels to be added to the Service managed by the operator.
        """
        if back_off_retry_millis is not None:
            pulumi.set(__self__, "back_off_retry_millis", back_off_retry_millis)
        if deployment_labels is not None:
            pulumi.set(__self__, "deployment_labels", deployment_labels)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if http_port is not None:
            pulumi.set(__self__, "http_port", http_port)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if infinispan is not None:
            pulumi.set(__self__, "infinispan", infinispan)
        if insecure_image_registry is not None:
            pulumi.set(__self__, "insecure_image_registry", insecure_image_registry)
        if kafka is not None:
            pulumi.set(__self__, "kafka", kafka)
        if max_interval_limit_to_retry_millis is not None:
            pulumi.set(__self__, "max_interval_limit_to_retry_millis", max_interval_limit_to_retry_millis)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if service_labels is not None:
            pulumi.set(__self__, "service_labels", service_labels)

    @property
    @pulumi.getter(name="backOffRetryMillis")
    def back_off_retry_millis(self) -> Optional[int]:
        """
        Retry backOff time in milliseconds between the job execution attempts, in case of execution failure. Default to service default, see: https://github.com/kiegroup/kogito-runtimes/wiki/Jobs-Service#configuration-properties
        """
        return pulumi.get(self, "back_off_retry_millis")

    @property
    @pulumi.getter(name="deploymentLabels")
    def deployment_labels(self) -> Optional[Mapping[str, str]]:
        """
        Additional labels to be added to the Deployment and Pods managed by the operator.
        """
        return pulumi.get(self, "deployment_labels")

    @property
    @pulumi.getter
    def envs(self) -> Optional[Sequence['outputs.KogitoJobsServiceSpecEnvs']]:
        """
        Environment variables to be added to the runtime container. Keys must be a C_IDENTIFIER.
        """
        return pulumi.get(self, "envs")

    @property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[int]:
        """
        HttpPort will set the environment env HTTP_PORT to define which port service will listen internally.
        """
        return pulumi.get(self, "http_port")

    @property
    @pulumi.getter
    def image(self) -> Optional['outputs.KogitoJobsServiceSpecImage']:
        """
        Image definition for the service. Example: Domain: quay.io, Namespace: kiegroup, Name: kogito-service, Tag: latest. On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def infinispan(self) -> Optional['outputs.KogitoJobsServiceSpecInfinispan']:
        """
        Has the data used by the service to connect to the Infinispan cluster.
        """
        return pulumi.get(self, "infinispan")

    @property
    @pulumi.getter(name="insecureImageRegistry")
    def insecure_image_registry(self) -> Optional[bool]:
        """
        A flag indicating that image streams created by Kogito Operator should be configured to allow pulling from insecure registries. Usable just on OpenShift. Defaults to 'false'.
        """
        return pulumi.get(self, "insecure_image_registry")

    @property
    @pulumi.getter
    def kafka(self) -> Optional['outputs.KogitoJobsServiceSpecKafka']:
        """
        Has the data used by the service to connect to the Kafka cluster.
        """
        return pulumi.get(self, "kafka")

    @property
    @pulumi.getter(name="maxIntervalLimitToRetryMillis")
    def max_interval_limit_to_retry_millis(self) -> Optional[int]:
        """
        Maximum interval in milliseconds when retrying to execute jobs, in case of failures. Default to service default, see: https://github.com/kiegroup/kogito-runtimes/wiki/Jobs-Service#configuration-properties
        """
        return pulumi.get(self, "max_interval_limit_to_retry_millis")

    @property
    @pulumi.getter
    def replicas(self) -> Optional[int]:
        """
        Number of replicas that the service will have deployed in the cluster. Default value: 1.
        """
        return pulumi.get(self, "replicas")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.KogitoJobsServiceSpecResources']:
        """
        Defined compute resource requirements for the deployed service.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter(name="serviceLabels")
    def service_labels(self) -> Optional[Mapping[str, str]]:
        """
        Additional labels to be added to the Service managed by the operator.
        """
        return pulumi.get(self, "service_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoJobsServiceSpecEnvs(dict):
    """
    EnvVar represents an environment variable present in a Container.
    """
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None,
                 value_from: Optional['outputs.KogitoJobsServiceSpecEnvsValueFrom'] = None):
        """
        EnvVar represents an environment variable present in a Container.
        :param str name: Name of the environment variable. Must be a C_IDENTIFIER.
        :param str value: Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        :param 'KogitoJobsServiceSpecEnvsValueFromArgs' value_from: Source for the environment variable's value. Cannot be used if value is not empty.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_from is not None:
            pulumi.set(__self__, "value_from", value_from)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the environment variable. Must be a C_IDENTIFIER.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueFrom")
    def value_from(self) -> Optional['outputs.KogitoJobsServiceSpecEnvsValueFrom']:
        """
        Source for the environment variable's value. Cannot be used if value is not empty.
        """
        return pulumi.get(self, "value_from")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoJobsServiceSpecEnvsValueFrom(dict):
    """
    Source for the environment variable's value. Cannot be used if value is not empty.
    """
    def __init__(__self__, *,
                 config_map_key_ref: Optional['outputs.KogitoJobsServiceSpecEnvsValueFromConfigMapKeyRef'] = None,
                 field_ref: Optional['outputs.KogitoJobsServiceSpecEnvsValueFromFieldRef'] = None,
                 resource_field_ref: Optional['outputs.KogitoJobsServiceSpecEnvsValueFromResourceFieldRef'] = None,
                 secret_key_ref: Optional['outputs.KogitoJobsServiceSpecEnvsValueFromSecretKeyRef'] = None):
        """
        Source for the environment variable's value. Cannot be used if value is not empty.
        :param 'KogitoJobsServiceSpecEnvsValueFromConfigMapKeyRefArgs' config_map_key_ref: Selects a key of a ConfigMap.
        :param 'KogitoJobsServiceSpecEnvsValueFromFieldRefArgs' field_ref: Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        :param 'KogitoJobsServiceSpecEnvsValueFromResourceFieldRefArgs' resource_field_ref: Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        :param 'KogitoJobsServiceSpecEnvsValueFromSecretKeyRefArgs' secret_key_ref: Selects a key of a secret in the pod's namespace
        """
        if config_map_key_ref is not None:
            pulumi.set(__self__, "config_map_key_ref", config_map_key_ref)
        if field_ref is not None:
            pulumi.set(__self__, "field_ref", field_ref)
        if resource_field_ref is not None:
            pulumi.set(__self__, "resource_field_ref", resource_field_ref)
        if secret_key_ref is not None:
            pulumi.set(__self__, "secret_key_ref", secret_key_ref)

    @property
    @pulumi.getter(name="configMapKeyRef")
    def config_map_key_ref(self) -> Optional['outputs.KogitoJobsServiceSpecEnvsValueFromConfigMapKeyRef']:
        """
        Selects a key of a ConfigMap.
        """
        return pulumi.get(self, "config_map_key_ref")

    @property
    @pulumi.getter(name="fieldRef")
    def field_ref(self) -> Optional['outputs.KogitoJobsServiceSpecEnvsValueFromFieldRef']:
        """
        Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        """
        return pulumi.get(self, "field_ref")

    @property
    @pulumi.getter(name="resourceFieldRef")
    def resource_field_ref(self) -> Optional['outputs.KogitoJobsServiceSpecEnvsValueFromResourceFieldRef']:
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        """
        return pulumi.get(self, "resource_field_ref")

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> Optional['outputs.KogitoJobsServiceSpecEnvsValueFromSecretKeyRef']:
        """
        Selects a key of a secret in the pod's namespace
        """
        return pulumi.get(self, "secret_key_ref")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoJobsServiceSpecEnvsValueFromConfigMapKeyRef(dict):
    """
    Selects a key of a ConfigMap.
    """
    def __init__(__self__, *,
                 key: str,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        Selects a key of a ConfigMap.
        :param str key: The key to select.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        :param bool optional: Specify whether the ConfigMap or its key must be defined
        """
        pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key to select.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the ConfigMap or its key must be defined
        """
        return pulumi.get(self, "optional")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoJobsServiceSpecEnvsValueFromFieldRef(dict):
    """
    Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    """
    def __init__(__self__, *,
                 field_path: str,
                 api_version: Optional[str] = None):
        """
        Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        :param str field_path: Path of the field to select in the specified API version.
        :param str api_version: Version of the schema the FieldPath is written in terms of, defaults to "v1".
        """
        pulumi.set(__self__, "field_path", field_path)
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> str:
        """
        Path of the field to select in the specified API version.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        Version of the schema the FieldPath is written in terms of, defaults to "v1".
        """
        return pulumi.get(self, "api_version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoJobsServiceSpecEnvsValueFromResourceFieldRef(dict):
    """
    Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    """
    def __init__(__self__, *,
                 resource: str,
                 container_name: Optional[str] = None,
                 divisor: Optional['outputs.KogitoJobsServiceSpecEnvsValueFromResourceFieldRefDivisor'] = None):
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        :param str resource: Required: resource to select
        :param str container_name: Container name: required for volumes, optional for env vars
        :param 'KogitoJobsServiceSpecEnvsValueFromResourceFieldRefDivisorArgs' divisor: Specifies the output format of the exposed resources, defaults to "1"
        """
        pulumi.set(__self__, "resource", resource)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if divisor is not None:
            pulumi.set(__self__, "divisor", divisor)

    @property
    @pulumi.getter
    def resource(self) -> str:
        """
        Required: resource to select
        """
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[str]:
        """
        Container name: required for volumes, optional for env vars
        """
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def divisor(self) -> Optional['outputs.KogitoJobsServiceSpecEnvsValueFromResourceFieldRefDivisor']:
        """
        Specifies the output format of the exposed resources, defaults to "1"
        """
        return pulumi.get(self, "divisor")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoJobsServiceSpecEnvsValueFromResourceFieldRefDivisor(dict):
    def __init__(__self__):
        pass

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoJobsServiceSpecEnvsValueFromSecretKeyRef(dict):
    """
    Selects a key of a secret in the pod's namespace
    """
    def __init__(__self__, *,
                 key: str,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        Selects a key of a secret in the pod's namespace
        :param str key: The key of the secret to select from.  Must be a valid secret key.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        :param bool optional: Specify whether the Secret or its key must be defined
        """
        pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the secret to select from.  Must be a valid secret key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the Secret or its key must be defined
        """
        return pulumi.get(self, "optional")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoJobsServiceSpecImage(dict):
    """
    Image definition for the service. Example: Domain: quay.io, Namespace: kiegroup, Name: kogito-service, Tag: latest. On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
    """
    def __init__(__self__, *,
                 domain: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 tag: Optional[str] = None):
        """
        Image definition for the service. Example: Domain: quay.io, Namespace: kiegroup, Name: kogito-service, Tag: latest. On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
        """
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        return pulumi.get(self, "tag")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoJobsServiceSpecInfinispan(dict):
    """
    Has the data used by the service to connect to the Infinispan cluster.
    """
    def __init__(__self__, *,
                 auth_realm: Optional[str] = None,
                 credentials: Optional['outputs.KogitoJobsServiceSpecInfinispanCredentials'] = None,
                 sasl_mechanism: Optional[str] = None,
                 uri: Optional[str] = None,
                 use_auth: Optional[bool] = None,
                 use_kogito_infra: Optional[bool] = None):
        """
        Has the data used by the service to connect to the Infinispan cluster.
        :param str auth_realm: Name of the Infinispan authentication realm. This sets the property infinispan.client.hotrod.auth_realm.
        :param 'KogitoJobsServiceSpecInfinispanCredentialsArgs' credentials: SecretCredentialsType is the data structure for specifying credentials within a Secret.
        :param str sasl_mechanism: SaslMechanism defined for the authentication. This sets the property infinispan.client.hotrod.sasl_mechanism.
        :param str uri: URI to connect to the Infinispan cluster (can it be an internal service or external URI), for example, myinfinispan-cluster:11222.
        :param bool use_auth: UseAuth is set to true if the credentials are set. This also sets the property infinispan.client.hotrod.use_auth.
        :param bool use_kogito_infra: UseKogitoInfra flags if the instance will use a provided infrastructure by KogitoInfra CR. Setting this to true will deploy a new KogitoInfra CR into the namespace that will install Infinispan via Infinispan Operator. Infinispan Operator MUST be installed in the namespace for this to work. On OpenShift, OLM should install it for you. If running on Kubernetes without OLM installed, please install Infinispan Operator first. Set this to false and fill all other properties to provide your own infrastructure.
        """
        if auth_realm is not None:
            pulumi.set(__self__, "auth_realm", auth_realm)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if sasl_mechanism is not None:
            pulumi.set(__self__, "sasl_mechanism", sasl_mechanism)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)
        if use_auth is not None:
            pulumi.set(__self__, "use_auth", use_auth)
        if use_kogito_infra is not None:
            pulumi.set(__self__, "use_kogito_infra", use_kogito_infra)

    @property
    @pulumi.getter(name="authRealm")
    def auth_realm(self) -> Optional[str]:
        """
        Name of the Infinispan authentication realm. This sets the property infinispan.client.hotrod.auth_realm.
        """
        return pulumi.get(self, "auth_realm")

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.KogitoJobsServiceSpecInfinispanCredentials']:
        """
        SecretCredentialsType is the data structure for specifying credentials within a Secret.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="saslMechanism")
    def sasl_mechanism(self) -> Optional[str]:
        """
        SaslMechanism defined for the authentication. This sets the property infinispan.client.hotrod.sasl_mechanism.
        """
        return pulumi.get(self, "sasl_mechanism")

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        """
        URI to connect to the Infinispan cluster (can it be an internal service or external URI), for example, myinfinispan-cluster:11222.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter(name="useAuth")
    def use_auth(self) -> Optional[bool]:
        """
        UseAuth is set to true if the credentials are set. This also sets the property infinispan.client.hotrod.use_auth.
        """
        return pulumi.get(self, "use_auth")

    @property
    @pulumi.getter(name="useKogitoInfra")
    def use_kogito_infra(self) -> Optional[bool]:
        """
        UseKogitoInfra flags if the instance will use a provided infrastructure by KogitoInfra CR. Setting this to true will deploy a new KogitoInfra CR into the namespace that will install Infinispan via Infinispan Operator. Infinispan Operator MUST be installed in the namespace for this to work. On OpenShift, OLM should install it for you. If running on Kubernetes without OLM installed, please install Infinispan Operator first. Set this to false and fill all other properties to provide your own infrastructure.
        """
        return pulumi.get(self, "use_kogito_infra")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoJobsServiceSpecInfinispanCredentials(dict):
    """
    SecretCredentialsType is the data structure for specifying credentials within a Secret.
    """
    def __init__(__self__, *,
                 password_key: Optional[str] = None,
                 secret_name: Optional[str] = None,
                 username_key: Optional[str] = None):
        """
        SecretCredentialsType is the data structure for specifying credentials within a Secret.
        :param str password_key: PasswordKey is the key pointing to a value in a Secret holding the password value.
        :param str secret_name: SecretName is the name of the secret where the credentials are set.
        :param str username_key: UsernameKey is the key pointing to a value in a Secret holding the username value.
        """
        if password_key is not None:
            pulumi.set(__self__, "password_key", password_key)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)
        if username_key is not None:
            pulumi.set(__self__, "username_key", username_key)

    @property
    @pulumi.getter(name="passwordKey")
    def password_key(self) -> Optional[str]:
        """
        PasswordKey is the key pointing to a value in a Secret holding the password value.
        """
        return pulumi.get(self, "password_key")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[str]:
        """
        SecretName is the name of the secret where the credentials are set.
        """
        return pulumi.get(self, "secret_name")

    @property
    @pulumi.getter(name="usernameKey")
    def username_key(self) -> Optional[str]:
        """
        UsernameKey is the key pointing to a value in a Secret holding the username value.
        """
        return pulumi.get(self, "username_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoJobsServiceSpecKafka(dict):
    """
    Has the data used by the service to connect to the Kafka cluster.
    """
    def __init__(__self__, *,
                 external_uri: Optional[str] = None,
                 instance: Optional[str] = None,
                 use_kogito_infra: Optional[bool] = None):
        """
        Has the data used by the service to connect to the Kafka cluster.
        :param str external_uri: URI is the service URI to connect to the Kafka cluster, for example, my-cluster-kafka-bootstrap:9092.
        :param str instance: Instance is the Kafka instance to be used, for example, kogito-kafka.
        :param bool use_kogito_infra: UseKogitoInfra flags if the instance will use a provided infrastructure by KogitoInfra CR. Setting this to true will configure a KogitoInfra CR to install Kafka via Strimzi Operator. Strimzi Operator MUST be installed in the namespace for this to work. On OpenShift, OLM should install it for you. If running on Kubernetes without OLM installed, please install Strimzi Operator first. Set this to false and fill other properties to provide your own infrastructure.
        """
        if external_uri is not None:
            pulumi.set(__self__, "external_uri", external_uri)
        if instance is not None:
            pulumi.set(__self__, "instance", instance)
        if use_kogito_infra is not None:
            pulumi.set(__self__, "use_kogito_infra", use_kogito_infra)

    @property
    @pulumi.getter(name="externalURI")
    def external_uri(self) -> Optional[str]:
        """
        URI is the service URI to connect to the Kafka cluster, for example, my-cluster-kafka-bootstrap:9092.
        """
        return pulumi.get(self, "external_uri")

    @property
    @pulumi.getter
    def instance(self) -> Optional[str]:
        """
        Instance is the Kafka instance to be used, for example, kogito-kafka.
        """
        return pulumi.get(self, "instance")

    @property
    @pulumi.getter(name="useKogitoInfra")
    def use_kogito_infra(self) -> Optional[bool]:
        """
        UseKogitoInfra flags if the instance will use a provided infrastructure by KogitoInfra CR. Setting this to true will configure a KogitoInfra CR to install Kafka via Strimzi Operator. Strimzi Operator MUST be installed in the namespace for this to work. On OpenShift, OLM should install it for you. If running on Kubernetes without OLM installed, please install Strimzi Operator first. Set this to false and fill other properties to provide your own infrastructure.
        """
        return pulumi.get(self, "use_kogito_infra")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoJobsServiceSpecResources(dict):
    """
    Defined compute resource requirements for the deployed service.
    """
    def __init__(__self__, *,
                 limits: Optional[Mapping[str, 'outputs.KogitoJobsServiceSpecResourcesLimits']] = None,
                 requests: Optional[Mapping[str, 'outputs.KogitoJobsServiceSpecResourcesRequests']] = None):
        """
        Defined compute resource requirements for the deployed service.
        :param Mapping[str, 'KogitoJobsServiceSpecResourcesLimitsArgs'] limits: Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        :param Mapping[str, 'KogitoJobsServiceSpecResourcesRequestsArgs'] requests: Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, 'outputs.KogitoJobsServiceSpecResourcesLimits']]:
        """
        Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Mapping[str, 'outputs.KogitoJobsServiceSpecResourcesRequests']]:
        """
        Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "requests")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoJobsServiceSpecResourcesLimits(dict):
    def __init__(__self__):
        pass

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoJobsServiceSpecResourcesRequests(dict):
    def __init__(__self__):
        pass

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoJobsServiceStatus(dict):
    """
    KogitoJobsServiceStatus defines the observed state of KogitoJobsService.
    """
    def __init__(__self__, *,
                 conditions: Sequence['outputs.KogitoJobsServiceStatusConditions'],
                 deployment_conditions: Optional[Sequence['outputs.KogitoJobsServiceStatusDeploymentConditions']] = None,
                 external_uri: Optional[str] = None,
                 image: Optional[str] = None):
        """
        KogitoJobsServiceStatus defines the observed state of KogitoJobsService.
        :param Sequence['KogitoJobsServiceStatusConditionsArgs'] conditions: History of conditions for the resource
        :param Sequence['KogitoJobsServiceStatusDeploymentConditionsArgs'] deployment_conditions: General conditions for the Kogito Service deployment.
        :param str external_uri: URI is where the service is exposed.
        :param str image: Image is the resolved image for this service.
        """
        pulumi.set(__self__, "conditions", conditions)
        if deployment_conditions is not None:
            pulumi.set(__self__, "deployment_conditions", deployment_conditions)
        if external_uri is not None:
            pulumi.set(__self__, "external_uri", external_uri)
        if image is not None:
            pulumi.set(__self__, "image", image)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.KogitoJobsServiceStatusConditions']:
        """
        History of conditions for the resource
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="deploymentConditions")
    def deployment_conditions(self) -> Optional[Sequence['outputs.KogitoJobsServiceStatusDeploymentConditions']]:
        """
        General conditions for the Kogito Service deployment.
        """
        return pulumi.get(self, "deployment_conditions")

    @property
    @pulumi.getter(name="externalURI")
    def external_uri(self) -> Optional[str]:
        """
        URI is where the service is exposed.
        """
        return pulumi.get(self, "external_uri")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        Image is the resolved image for this service.
        """
        return pulumi.get(self, "image")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoJobsServiceStatusConditions(dict):
    """
    Condition is the detailed condition for the resource
    """
    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None):
        """
        Condition is the detailed condition for the resource
        :param str type: ConditionType is the type of condition
        :param str reason: ReasonType is the type of reason
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        ConditionType is the type of condition
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        ReasonType is the type of reason
        """
        return pulumi.get(self, "reason")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoJobsServiceStatusDeploymentConditions(dict):
    """
    DeploymentCondition describes the state of a deployment at a certain point.
    """
    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 last_update_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None):
        """
        DeploymentCondition describes the state of a deployment at a certain point.
        :param str status: Status of the condition, one of True, False, Unknown.
        :param str type: Type of deployment condition.
        :param str last_transition_time: Last time the condition transitioned from one status to another.
        :param str last_update_time: The last time this condition was updated.
        :param str message: A human readable message indicating details about the transition.
        :param str reason: The reason for the condition's last transition.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if last_update_time is not None:
            pulumi.set(__self__, "last_update_time", last_update_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of deployment condition.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        Last time the condition transitioned from one status to another.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter(name="lastUpdateTime")
    def last_update_time(self) -> Optional[str]:
        """
        The last time this condition was updated.
        """
        return pulumi.get(self, "last_update_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        A human readable message indicating details about the transition.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        The reason for the condition's last transition.
        """
        return pulumi.get(self, "reason")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoMgmtConsoleSpec(dict):
    """
    KogitoMgmtConsoleSpec defines the desired state of KogitoMgmtConsole.
    """
    def __init__(__self__, *,
                 deployment_labels: Optional[Mapping[str, str]] = None,
                 envs: Optional[Sequence['outputs.KogitoMgmtConsoleSpecEnvs']] = None,
                 http_port: Optional[int] = None,
                 image: Optional['outputs.KogitoMgmtConsoleSpecImage'] = None,
                 insecure_image_registry: Optional[bool] = None,
                 replicas: Optional[int] = None,
                 resources: Optional['outputs.KogitoMgmtConsoleSpecResources'] = None,
                 service_labels: Optional[Mapping[str, str]] = None):
        """
        KogitoMgmtConsoleSpec defines the desired state of KogitoMgmtConsole.
        :param Mapping[str, str] deployment_labels: Additional labels to be added to the Deployment and Pods managed by the operator.
        :param Sequence['KogitoMgmtConsoleSpecEnvsArgs'] envs: Environment variables to be added to the runtime container. Keys must be a C_IDENTIFIER.
        :param int http_port: HttpPort will set the environment env HTTP_PORT to define which port service will listen internally.
        :param 'KogitoMgmtConsoleSpecImageArgs' image: Image definition for the service. Example: Domain: quay.io, Namespace: kiegroup, Name: kogito-service, Tag: latest. On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
        :param bool insecure_image_registry: A flag indicating that image streams created by Kogito Operator should be configured to allow pulling from insecure registries. Usable just on OpenShift. Defaults to 'false'.
        :param int replicas: Number of replicas that the service will have deployed in the cluster. Default value: 1.
        :param 'KogitoMgmtConsoleSpecResourcesArgs' resources: Defined compute resource requirements for the deployed service.
        :param Mapping[str, str] service_labels: Additional labels to be added to the Service managed by the operator.
        """
        if deployment_labels is not None:
            pulumi.set(__self__, "deployment_labels", deployment_labels)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if http_port is not None:
            pulumi.set(__self__, "http_port", http_port)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if insecure_image_registry is not None:
            pulumi.set(__self__, "insecure_image_registry", insecure_image_registry)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if service_labels is not None:
            pulumi.set(__self__, "service_labels", service_labels)

    @property
    @pulumi.getter(name="deploymentLabels")
    def deployment_labels(self) -> Optional[Mapping[str, str]]:
        """
        Additional labels to be added to the Deployment and Pods managed by the operator.
        """
        return pulumi.get(self, "deployment_labels")

    @property
    @pulumi.getter
    def envs(self) -> Optional[Sequence['outputs.KogitoMgmtConsoleSpecEnvs']]:
        """
        Environment variables to be added to the runtime container. Keys must be a C_IDENTIFIER.
        """
        return pulumi.get(self, "envs")

    @property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[int]:
        """
        HttpPort will set the environment env HTTP_PORT to define which port service will listen internally.
        """
        return pulumi.get(self, "http_port")

    @property
    @pulumi.getter
    def image(self) -> Optional['outputs.KogitoMgmtConsoleSpecImage']:
        """
        Image definition for the service. Example: Domain: quay.io, Namespace: kiegroup, Name: kogito-service, Tag: latest. On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="insecureImageRegistry")
    def insecure_image_registry(self) -> Optional[bool]:
        """
        A flag indicating that image streams created by Kogito Operator should be configured to allow pulling from insecure registries. Usable just on OpenShift. Defaults to 'false'.
        """
        return pulumi.get(self, "insecure_image_registry")

    @property
    @pulumi.getter
    def replicas(self) -> Optional[int]:
        """
        Number of replicas that the service will have deployed in the cluster. Default value: 1.
        """
        return pulumi.get(self, "replicas")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.KogitoMgmtConsoleSpecResources']:
        """
        Defined compute resource requirements for the deployed service.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter(name="serviceLabels")
    def service_labels(self) -> Optional[Mapping[str, str]]:
        """
        Additional labels to be added to the Service managed by the operator.
        """
        return pulumi.get(self, "service_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoMgmtConsoleSpecEnvs(dict):
    """
    EnvVar represents an environment variable present in a Container.
    """
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None,
                 value_from: Optional['outputs.KogitoMgmtConsoleSpecEnvsValueFrom'] = None):
        """
        EnvVar represents an environment variable present in a Container.
        :param str name: Name of the environment variable. Must be a C_IDENTIFIER.
        :param str value: Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        :param 'KogitoMgmtConsoleSpecEnvsValueFromArgs' value_from: Source for the environment variable's value. Cannot be used if value is not empty.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_from is not None:
            pulumi.set(__self__, "value_from", value_from)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the environment variable. Must be a C_IDENTIFIER.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueFrom")
    def value_from(self) -> Optional['outputs.KogitoMgmtConsoleSpecEnvsValueFrom']:
        """
        Source for the environment variable's value. Cannot be used if value is not empty.
        """
        return pulumi.get(self, "value_from")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoMgmtConsoleSpecEnvsValueFrom(dict):
    """
    Source for the environment variable's value. Cannot be used if value is not empty.
    """
    def __init__(__self__, *,
                 config_map_key_ref: Optional['outputs.KogitoMgmtConsoleSpecEnvsValueFromConfigMapKeyRef'] = None,
                 field_ref: Optional['outputs.KogitoMgmtConsoleSpecEnvsValueFromFieldRef'] = None,
                 resource_field_ref: Optional['outputs.KogitoMgmtConsoleSpecEnvsValueFromResourceFieldRef'] = None,
                 secret_key_ref: Optional['outputs.KogitoMgmtConsoleSpecEnvsValueFromSecretKeyRef'] = None):
        """
        Source for the environment variable's value. Cannot be used if value is not empty.
        :param 'KogitoMgmtConsoleSpecEnvsValueFromConfigMapKeyRefArgs' config_map_key_ref: Selects a key of a ConfigMap.
        :param 'KogitoMgmtConsoleSpecEnvsValueFromFieldRefArgs' field_ref: Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        :param 'KogitoMgmtConsoleSpecEnvsValueFromResourceFieldRefArgs' resource_field_ref: Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        :param 'KogitoMgmtConsoleSpecEnvsValueFromSecretKeyRefArgs' secret_key_ref: Selects a key of a secret in the pod's namespace
        """
        if config_map_key_ref is not None:
            pulumi.set(__self__, "config_map_key_ref", config_map_key_ref)
        if field_ref is not None:
            pulumi.set(__self__, "field_ref", field_ref)
        if resource_field_ref is not None:
            pulumi.set(__self__, "resource_field_ref", resource_field_ref)
        if secret_key_ref is not None:
            pulumi.set(__self__, "secret_key_ref", secret_key_ref)

    @property
    @pulumi.getter(name="configMapKeyRef")
    def config_map_key_ref(self) -> Optional['outputs.KogitoMgmtConsoleSpecEnvsValueFromConfigMapKeyRef']:
        """
        Selects a key of a ConfigMap.
        """
        return pulumi.get(self, "config_map_key_ref")

    @property
    @pulumi.getter(name="fieldRef")
    def field_ref(self) -> Optional['outputs.KogitoMgmtConsoleSpecEnvsValueFromFieldRef']:
        """
        Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        """
        return pulumi.get(self, "field_ref")

    @property
    @pulumi.getter(name="resourceFieldRef")
    def resource_field_ref(self) -> Optional['outputs.KogitoMgmtConsoleSpecEnvsValueFromResourceFieldRef']:
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        """
        return pulumi.get(self, "resource_field_ref")

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> Optional['outputs.KogitoMgmtConsoleSpecEnvsValueFromSecretKeyRef']:
        """
        Selects a key of a secret in the pod's namespace
        """
        return pulumi.get(self, "secret_key_ref")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoMgmtConsoleSpecEnvsValueFromConfigMapKeyRef(dict):
    """
    Selects a key of a ConfigMap.
    """
    def __init__(__self__, *,
                 key: str,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        Selects a key of a ConfigMap.
        :param str key: The key to select.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        :param bool optional: Specify whether the ConfigMap or its key must be defined
        """
        pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key to select.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the ConfigMap or its key must be defined
        """
        return pulumi.get(self, "optional")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoMgmtConsoleSpecEnvsValueFromFieldRef(dict):
    """
    Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    """
    def __init__(__self__, *,
                 field_path: str,
                 api_version: Optional[str] = None):
        """
        Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        :param str field_path: Path of the field to select in the specified API version.
        :param str api_version: Version of the schema the FieldPath is written in terms of, defaults to "v1".
        """
        pulumi.set(__self__, "field_path", field_path)
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> str:
        """
        Path of the field to select in the specified API version.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        Version of the schema the FieldPath is written in terms of, defaults to "v1".
        """
        return pulumi.get(self, "api_version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoMgmtConsoleSpecEnvsValueFromResourceFieldRef(dict):
    """
    Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    """
    def __init__(__self__, *,
                 resource: str,
                 container_name: Optional[str] = None,
                 divisor: Optional['outputs.KogitoMgmtConsoleSpecEnvsValueFromResourceFieldRefDivisor'] = None):
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        :param str resource: Required: resource to select
        :param str container_name: Container name: required for volumes, optional for env vars
        :param 'KogitoMgmtConsoleSpecEnvsValueFromResourceFieldRefDivisorArgs' divisor: Specifies the output format of the exposed resources, defaults to "1"
        """
        pulumi.set(__self__, "resource", resource)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if divisor is not None:
            pulumi.set(__self__, "divisor", divisor)

    @property
    @pulumi.getter
    def resource(self) -> str:
        """
        Required: resource to select
        """
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[str]:
        """
        Container name: required for volumes, optional for env vars
        """
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def divisor(self) -> Optional['outputs.KogitoMgmtConsoleSpecEnvsValueFromResourceFieldRefDivisor']:
        """
        Specifies the output format of the exposed resources, defaults to "1"
        """
        return pulumi.get(self, "divisor")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoMgmtConsoleSpecEnvsValueFromResourceFieldRefDivisor(dict):
    def __init__(__self__):
        pass

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoMgmtConsoleSpecEnvsValueFromSecretKeyRef(dict):
    """
    Selects a key of a secret in the pod's namespace
    """
    def __init__(__self__, *,
                 key: str,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        Selects a key of a secret in the pod's namespace
        :param str key: The key of the secret to select from.  Must be a valid secret key.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        :param bool optional: Specify whether the Secret or its key must be defined
        """
        pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the secret to select from.  Must be a valid secret key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the Secret or its key must be defined
        """
        return pulumi.get(self, "optional")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoMgmtConsoleSpecImage(dict):
    """
    Image definition for the service. Example: Domain: quay.io, Namespace: kiegroup, Name: kogito-service, Tag: latest. On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
    """
    def __init__(__self__, *,
                 domain: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 tag: Optional[str] = None):
        """
        Image definition for the service. Example: Domain: quay.io, Namespace: kiegroup, Name: kogito-service, Tag: latest. On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
        """
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        return pulumi.get(self, "tag")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoMgmtConsoleSpecResources(dict):
    """
    Defined compute resource requirements for the deployed service.
    """
    def __init__(__self__, *,
                 limits: Optional[Mapping[str, 'outputs.KogitoMgmtConsoleSpecResourcesLimits']] = None,
                 requests: Optional[Mapping[str, 'outputs.KogitoMgmtConsoleSpecResourcesRequests']] = None):
        """
        Defined compute resource requirements for the deployed service.
        :param Mapping[str, 'KogitoMgmtConsoleSpecResourcesLimitsArgs'] limits: Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        :param Mapping[str, 'KogitoMgmtConsoleSpecResourcesRequestsArgs'] requests: Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, 'outputs.KogitoMgmtConsoleSpecResourcesLimits']]:
        """
        Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Mapping[str, 'outputs.KogitoMgmtConsoleSpecResourcesRequests']]:
        """
        Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "requests")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoMgmtConsoleSpecResourcesLimits(dict):
    def __init__(__self__):
        pass

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoMgmtConsoleSpecResourcesRequests(dict):
    def __init__(__self__):
        pass

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoMgmtConsoleStatus(dict):
    """
    KogitoMgmtConsoleStatus defines the observed state of KogitoMgmtConsole.
    """
    def __init__(__self__, *,
                 conditions: Sequence['outputs.KogitoMgmtConsoleStatusConditions'],
                 deployment_conditions: Optional[Sequence['outputs.KogitoMgmtConsoleStatusDeploymentConditions']] = None,
                 external_uri: Optional[str] = None,
                 image: Optional[str] = None):
        """
        KogitoMgmtConsoleStatus defines the observed state of KogitoMgmtConsole.
        :param Sequence['KogitoMgmtConsoleStatusConditionsArgs'] conditions: History of conditions for the resource
        :param Sequence['KogitoMgmtConsoleStatusDeploymentConditionsArgs'] deployment_conditions: General conditions for the Kogito Service deployment.
        :param str external_uri: URI is where the service is exposed.
        :param str image: Image is the resolved image for this service.
        """
        pulumi.set(__self__, "conditions", conditions)
        if deployment_conditions is not None:
            pulumi.set(__self__, "deployment_conditions", deployment_conditions)
        if external_uri is not None:
            pulumi.set(__self__, "external_uri", external_uri)
        if image is not None:
            pulumi.set(__self__, "image", image)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.KogitoMgmtConsoleStatusConditions']:
        """
        History of conditions for the resource
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="deploymentConditions")
    def deployment_conditions(self) -> Optional[Sequence['outputs.KogitoMgmtConsoleStatusDeploymentConditions']]:
        """
        General conditions for the Kogito Service deployment.
        """
        return pulumi.get(self, "deployment_conditions")

    @property
    @pulumi.getter(name="externalURI")
    def external_uri(self) -> Optional[str]:
        """
        URI is where the service is exposed.
        """
        return pulumi.get(self, "external_uri")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        Image is the resolved image for this service.
        """
        return pulumi.get(self, "image")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoMgmtConsoleStatusConditions(dict):
    """
    Condition is the detailed condition for the resource
    """
    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None):
        """
        Condition is the detailed condition for the resource
        :param str type: ConditionType is the type of condition
        :param str reason: ReasonType is the type of reason
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        ConditionType is the type of condition
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        ReasonType is the type of reason
        """
        return pulumi.get(self, "reason")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoMgmtConsoleStatusDeploymentConditions(dict):
    """
    DeploymentCondition describes the state of a deployment at a certain point.
    """
    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 last_update_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None):
        """
        DeploymentCondition describes the state of a deployment at a certain point.
        :param str status: Status of the condition, one of True, False, Unknown.
        :param str type: Type of deployment condition.
        :param str last_transition_time: Last time the condition transitioned from one status to another.
        :param str last_update_time: The last time this condition was updated.
        :param str message: A human readable message indicating details about the transition.
        :param str reason: The reason for the condition's last transition.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if last_update_time is not None:
            pulumi.set(__self__, "last_update_time", last_update_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of deployment condition.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        Last time the condition transitioned from one status to another.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter(name="lastUpdateTime")
    def last_update_time(self) -> Optional[str]:
        """
        The last time this condition was updated.
        """
        return pulumi.get(self, "last_update_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        A human readable message indicating details about the transition.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        The reason for the condition's last transition.
        """
        return pulumi.get(self, "reason")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoRuntimeSpec(dict):
    """
    KogitoRuntimeSpec defines the desired state of KogitoRuntime.
    """
    def __init__(__self__, *,
                 deployment_labels: Optional[Mapping[str, str]] = None,
                 enable_istio: Optional[bool] = None,
                 envs: Optional[Sequence['outputs.KogitoRuntimeSpecEnvs']] = None,
                 http_port: Optional[int] = None,
                 image: Optional['outputs.KogitoRuntimeSpecImage'] = None,
                 infinispan: Optional['outputs.KogitoRuntimeSpecInfinispan'] = None,
                 insecure_image_registry: Optional[bool] = None,
                 kafka: Optional['outputs.KogitoRuntimeSpecKafka'] = None,
                 replicas: Optional[int] = None,
                 resources: Optional['outputs.KogitoRuntimeSpecResources'] = None,
                 runtime: Optional[str] = None,
                 service_labels: Optional[Mapping[str, str]] = None):
        """
        KogitoRuntimeSpec defines the desired state of KogitoRuntime.
        :param Mapping[str, str] deployment_labels: Additional labels to be added to the Deployment and Pods managed by the operator.
        :param bool enable_istio: Annotates the pods managed by the operator with the required metadata for Istio to setup its sidecars, enabling the mesh. Defaults to false.
        :param Sequence['KogitoRuntimeSpecEnvsArgs'] envs: Environment variables to be added to the runtime container. Keys must be a C_IDENTIFIER.
        :param int http_port: HttpPort will set the environment env HTTP_PORT to define which port service will listen internally.
        :param 'KogitoRuntimeSpecImageArgs' image: Image definition for the service. Example: Domain: quay.io, Namespace: kiegroup, Name: kogito-service, Tag: latest. On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
        :param 'KogitoRuntimeSpecInfinispanArgs' infinispan: Has the data used by the service to connect to the Infinispan cluster.
        :param bool insecure_image_registry: A flag indicating that image streams created by Kogito Operator should be configured to allow pulling from insecure registries. Usable just on OpenShift. Defaults to 'false'.
        :param 'KogitoRuntimeSpecKafkaArgs' kafka: Has the data used by the service to connect to the Kafka cluster.
        :param int replicas: Number of replicas that the service will have deployed in the cluster. Default value: 1.
        :param 'KogitoRuntimeSpecResourcesArgs' resources: Defined compute resource requirements for the deployed service.
        :param str runtime: The name of the runtime used, either Quarkus or SpringBoot. Default value: quarkus
        :param Mapping[str, str] service_labels: Additional labels to be added to the Service managed by the operator.
        """
        if deployment_labels is not None:
            pulumi.set(__self__, "deployment_labels", deployment_labels)
        if enable_istio is not None:
            pulumi.set(__self__, "enable_istio", enable_istio)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if http_port is not None:
            pulumi.set(__self__, "http_port", http_port)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if infinispan is not None:
            pulumi.set(__self__, "infinispan", infinispan)
        if insecure_image_registry is not None:
            pulumi.set(__self__, "insecure_image_registry", insecure_image_registry)
        if kafka is not None:
            pulumi.set(__self__, "kafka", kafka)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if runtime is not None:
            pulumi.set(__self__, "runtime", runtime)
        if service_labels is not None:
            pulumi.set(__self__, "service_labels", service_labels)

    @property
    @pulumi.getter(name="deploymentLabels")
    def deployment_labels(self) -> Optional[Mapping[str, str]]:
        """
        Additional labels to be added to the Deployment and Pods managed by the operator.
        """
        return pulumi.get(self, "deployment_labels")

    @property
    @pulumi.getter(name="enableIstio")
    def enable_istio(self) -> Optional[bool]:
        """
        Annotates the pods managed by the operator with the required metadata for Istio to setup its sidecars, enabling the mesh. Defaults to false.
        """
        return pulumi.get(self, "enable_istio")

    @property
    @pulumi.getter
    def envs(self) -> Optional[Sequence['outputs.KogitoRuntimeSpecEnvs']]:
        """
        Environment variables to be added to the runtime container. Keys must be a C_IDENTIFIER.
        """
        return pulumi.get(self, "envs")

    @property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[int]:
        """
        HttpPort will set the environment env HTTP_PORT to define which port service will listen internally.
        """
        return pulumi.get(self, "http_port")

    @property
    @pulumi.getter
    def image(self) -> Optional['outputs.KogitoRuntimeSpecImage']:
        """
        Image definition for the service. Example: Domain: quay.io, Namespace: kiegroup, Name: kogito-service, Tag: latest. On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def infinispan(self) -> Optional['outputs.KogitoRuntimeSpecInfinispan']:
        """
        Has the data used by the service to connect to the Infinispan cluster.
        """
        return pulumi.get(self, "infinispan")

    @property
    @pulumi.getter(name="insecureImageRegistry")
    def insecure_image_registry(self) -> Optional[bool]:
        """
        A flag indicating that image streams created by Kogito Operator should be configured to allow pulling from insecure registries. Usable just on OpenShift. Defaults to 'false'.
        """
        return pulumi.get(self, "insecure_image_registry")

    @property
    @pulumi.getter
    def kafka(self) -> Optional['outputs.KogitoRuntimeSpecKafka']:
        """
        Has the data used by the service to connect to the Kafka cluster.
        """
        return pulumi.get(self, "kafka")

    @property
    @pulumi.getter
    def replicas(self) -> Optional[int]:
        """
        Number of replicas that the service will have deployed in the cluster. Default value: 1.
        """
        return pulumi.get(self, "replicas")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.KogitoRuntimeSpecResources']:
        """
        Defined compute resource requirements for the deployed service.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter
    def runtime(self) -> Optional[str]:
        """
        The name of the runtime used, either Quarkus or SpringBoot. Default value: quarkus
        """
        return pulumi.get(self, "runtime")

    @property
    @pulumi.getter(name="serviceLabels")
    def service_labels(self) -> Optional[Mapping[str, str]]:
        """
        Additional labels to be added to the Service managed by the operator.
        """
        return pulumi.get(self, "service_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoRuntimeSpecEnvs(dict):
    """
    EnvVar represents an environment variable present in a Container.
    """
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None,
                 value_from: Optional['outputs.KogitoRuntimeSpecEnvsValueFrom'] = None):
        """
        EnvVar represents an environment variable present in a Container.
        :param str name: Name of the environment variable. Must be a C_IDENTIFIER.
        :param str value: Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        :param 'KogitoRuntimeSpecEnvsValueFromArgs' value_from: Source for the environment variable's value. Cannot be used if value is not empty.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_from is not None:
            pulumi.set(__self__, "value_from", value_from)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the environment variable. Must be a C_IDENTIFIER.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueFrom")
    def value_from(self) -> Optional['outputs.KogitoRuntimeSpecEnvsValueFrom']:
        """
        Source for the environment variable's value. Cannot be used if value is not empty.
        """
        return pulumi.get(self, "value_from")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoRuntimeSpecEnvsValueFrom(dict):
    """
    Source for the environment variable's value. Cannot be used if value is not empty.
    """
    def __init__(__self__, *,
                 config_map_key_ref: Optional['outputs.KogitoRuntimeSpecEnvsValueFromConfigMapKeyRef'] = None,
                 field_ref: Optional['outputs.KogitoRuntimeSpecEnvsValueFromFieldRef'] = None,
                 resource_field_ref: Optional['outputs.KogitoRuntimeSpecEnvsValueFromResourceFieldRef'] = None,
                 secret_key_ref: Optional['outputs.KogitoRuntimeSpecEnvsValueFromSecretKeyRef'] = None):
        """
        Source for the environment variable's value. Cannot be used if value is not empty.
        :param 'KogitoRuntimeSpecEnvsValueFromConfigMapKeyRefArgs' config_map_key_ref: Selects a key of a ConfigMap.
        :param 'KogitoRuntimeSpecEnvsValueFromFieldRefArgs' field_ref: Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        :param 'KogitoRuntimeSpecEnvsValueFromResourceFieldRefArgs' resource_field_ref: Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        :param 'KogitoRuntimeSpecEnvsValueFromSecretKeyRefArgs' secret_key_ref: Selects a key of a secret in the pod's namespace
        """
        if config_map_key_ref is not None:
            pulumi.set(__self__, "config_map_key_ref", config_map_key_ref)
        if field_ref is not None:
            pulumi.set(__self__, "field_ref", field_ref)
        if resource_field_ref is not None:
            pulumi.set(__self__, "resource_field_ref", resource_field_ref)
        if secret_key_ref is not None:
            pulumi.set(__self__, "secret_key_ref", secret_key_ref)

    @property
    @pulumi.getter(name="configMapKeyRef")
    def config_map_key_ref(self) -> Optional['outputs.KogitoRuntimeSpecEnvsValueFromConfigMapKeyRef']:
        """
        Selects a key of a ConfigMap.
        """
        return pulumi.get(self, "config_map_key_ref")

    @property
    @pulumi.getter(name="fieldRef")
    def field_ref(self) -> Optional['outputs.KogitoRuntimeSpecEnvsValueFromFieldRef']:
        """
        Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        """
        return pulumi.get(self, "field_ref")

    @property
    @pulumi.getter(name="resourceFieldRef")
    def resource_field_ref(self) -> Optional['outputs.KogitoRuntimeSpecEnvsValueFromResourceFieldRef']:
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        """
        return pulumi.get(self, "resource_field_ref")

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> Optional['outputs.KogitoRuntimeSpecEnvsValueFromSecretKeyRef']:
        """
        Selects a key of a secret in the pod's namespace
        """
        return pulumi.get(self, "secret_key_ref")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoRuntimeSpecEnvsValueFromConfigMapKeyRef(dict):
    """
    Selects a key of a ConfigMap.
    """
    def __init__(__self__, *,
                 key: str,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        Selects a key of a ConfigMap.
        :param str key: The key to select.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        :param bool optional: Specify whether the ConfigMap or its key must be defined
        """
        pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key to select.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the ConfigMap or its key must be defined
        """
        return pulumi.get(self, "optional")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoRuntimeSpecEnvsValueFromFieldRef(dict):
    """
    Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    """
    def __init__(__self__, *,
                 field_path: str,
                 api_version: Optional[str] = None):
        """
        Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        :param str field_path: Path of the field to select in the specified API version.
        :param str api_version: Version of the schema the FieldPath is written in terms of, defaults to "v1".
        """
        pulumi.set(__self__, "field_path", field_path)
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> str:
        """
        Path of the field to select in the specified API version.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        Version of the schema the FieldPath is written in terms of, defaults to "v1".
        """
        return pulumi.get(self, "api_version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoRuntimeSpecEnvsValueFromResourceFieldRef(dict):
    """
    Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    """
    def __init__(__self__, *,
                 resource: str,
                 container_name: Optional[str] = None,
                 divisor: Optional['outputs.KogitoRuntimeSpecEnvsValueFromResourceFieldRefDivisor'] = None):
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        :param str resource: Required: resource to select
        :param str container_name: Container name: required for volumes, optional for env vars
        :param 'KogitoRuntimeSpecEnvsValueFromResourceFieldRefDivisorArgs' divisor: Specifies the output format of the exposed resources, defaults to "1"
        """
        pulumi.set(__self__, "resource", resource)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if divisor is not None:
            pulumi.set(__self__, "divisor", divisor)

    @property
    @pulumi.getter
    def resource(self) -> str:
        """
        Required: resource to select
        """
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[str]:
        """
        Container name: required for volumes, optional for env vars
        """
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def divisor(self) -> Optional['outputs.KogitoRuntimeSpecEnvsValueFromResourceFieldRefDivisor']:
        """
        Specifies the output format of the exposed resources, defaults to "1"
        """
        return pulumi.get(self, "divisor")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoRuntimeSpecEnvsValueFromResourceFieldRefDivisor(dict):
    def __init__(__self__):
        pass

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoRuntimeSpecEnvsValueFromSecretKeyRef(dict):
    """
    Selects a key of a secret in the pod's namespace
    """
    def __init__(__self__, *,
                 key: str,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        Selects a key of a secret in the pod's namespace
        :param str key: The key of the secret to select from.  Must be a valid secret key.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        :param bool optional: Specify whether the Secret or its key must be defined
        """
        pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the secret to select from.  Must be a valid secret key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the Secret or its key must be defined
        """
        return pulumi.get(self, "optional")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoRuntimeSpecImage(dict):
    """
    Image definition for the service. Example: Domain: quay.io, Namespace: kiegroup, Name: kogito-service, Tag: latest. On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
    """
    def __init__(__self__, *,
                 domain: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 tag: Optional[str] = None):
        """
        Image definition for the service. Example: Domain: quay.io, Namespace: kiegroup, Name: kogito-service, Tag: latest. On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
        """
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        return pulumi.get(self, "tag")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoRuntimeSpecInfinispan(dict):
    """
    Has the data used by the service to connect to the Infinispan cluster.
    """
    def __init__(__self__, *,
                 auth_realm: Optional[str] = None,
                 credentials: Optional['outputs.KogitoRuntimeSpecInfinispanCredentials'] = None,
                 sasl_mechanism: Optional[str] = None,
                 uri: Optional[str] = None,
                 use_auth: Optional[bool] = None,
                 use_kogito_infra: Optional[bool] = None):
        """
        Has the data used by the service to connect to the Infinispan cluster.
        :param str auth_realm: Name of the Infinispan authentication realm. This sets the property infinispan.client.hotrod.auth_realm.
        :param 'KogitoRuntimeSpecInfinispanCredentialsArgs' credentials: SecretCredentialsType is the data structure for specifying credentials within a Secret.
        :param str sasl_mechanism: SaslMechanism defined for the authentication. This sets the property infinispan.client.hotrod.sasl_mechanism.
        :param str uri: URI to connect to the Infinispan cluster (can it be an internal service or external URI), for example, myinfinispan-cluster:11222.
        :param bool use_auth: UseAuth is set to true if the credentials are set. This also sets the property infinispan.client.hotrod.use_auth.
        :param bool use_kogito_infra: UseKogitoInfra flags if the instance will use a provided infrastructure by KogitoInfra CR. Setting this to true will deploy a new KogitoInfra CR into the namespace that will install Infinispan via Infinispan Operator. Infinispan Operator MUST be installed in the namespace for this to work. On OpenShift, OLM should install it for you. If running on Kubernetes without OLM installed, please install Infinispan Operator first. Set this to false and fill all other properties to provide your own infrastructure.
        """
        if auth_realm is not None:
            pulumi.set(__self__, "auth_realm", auth_realm)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if sasl_mechanism is not None:
            pulumi.set(__self__, "sasl_mechanism", sasl_mechanism)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)
        if use_auth is not None:
            pulumi.set(__self__, "use_auth", use_auth)
        if use_kogito_infra is not None:
            pulumi.set(__self__, "use_kogito_infra", use_kogito_infra)

    @property
    @pulumi.getter(name="authRealm")
    def auth_realm(self) -> Optional[str]:
        """
        Name of the Infinispan authentication realm. This sets the property infinispan.client.hotrod.auth_realm.
        """
        return pulumi.get(self, "auth_realm")

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.KogitoRuntimeSpecInfinispanCredentials']:
        """
        SecretCredentialsType is the data structure for specifying credentials within a Secret.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="saslMechanism")
    def sasl_mechanism(self) -> Optional[str]:
        """
        SaslMechanism defined for the authentication. This sets the property infinispan.client.hotrod.sasl_mechanism.
        """
        return pulumi.get(self, "sasl_mechanism")

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        """
        URI to connect to the Infinispan cluster (can it be an internal service or external URI), for example, myinfinispan-cluster:11222.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter(name="useAuth")
    def use_auth(self) -> Optional[bool]:
        """
        UseAuth is set to true if the credentials are set. This also sets the property infinispan.client.hotrod.use_auth.
        """
        return pulumi.get(self, "use_auth")

    @property
    @pulumi.getter(name="useKogitoInfra")
    def use_kogito_infra(self) -> Optional[bool]:
        """
        UseKogitoInfra flags if the instance will use a provided infrastructure by KogitoInfra CR. Setting this to true will deploy a new KogitoInfra CR into the namespace that will install Infinispan via Infinispan Operator. Infinispan Operator MUST be installed in the namespace for this to work. On OpenShift, OLM should install it for you. If running on Kubernetes without OLM installed, please install Infinispan Operator first. Set this to false and fill all other properties to provide your own infrastructure.
        """
        return pulumi.get(self, "use_kogito_infra")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoRuntimeSpecInfinispanCredentials(dict):
    """
    SecretCredentialsType is the data structure for specifying credentials within a Secret.
    """
    def __init__(__self__, *,
                 password_key: Optional[str] = None,
                 secret_name: Optional[str] = None,
                 username_key: Optional[str] = None):
        """
        SecretCredentialsType is the data structure for specifying credentials within a Secret.
        :param str password_key: PasswordKey is the key pointing to a value in a Secret holding the password value.
        :param str secret_name: SecretName is the name of the secret where the credentials are set.
        :param str username_key: UsernameKey is the key pointing to a value in a Secret holding the username value.
        """
        if password_key is not None:
            pulumi.set(__self__, "password_key", password_key)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)
        if username_key is not None:
            pulumi.set(__self__, "username_key", username_key)

    @property
    @pulumi.getter(name="passwordKey")
    def password_key(self) -> Optional[str]:
        """
        PasswordKey is the key pointing to a value in a Secret holding the password value.
        """
        return pulumi.get(self, "password_key")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[str]:
        """
        SecretName is the name of the secret where the credentials are set.
        """
        return pulumi.get(self, "secret_name")

    @property
    @pulumi.getter(name="usernameKey")
    def username_key(self) -> Optional[str]:
        """
        UsernameKey is the key pointing to a value in a Secret holding the username value.
        """
        return pulumi.get(self, "username_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoRuntimeSpecKafka(dict):
    """
    Has the data used by the service to connect to the Kafka cluster.
    """
    def __init__(__self__, *,
                 external_uri: Optional[str] = None,
                 instance: Optional[str] = None,
                 use_kogito_infra: Optional[bool] = None):
        """
        Has the data used by the service to connect to the Kafka cluster.
        :param str external_uri: URI is the service URI to connect to the Kafka cluster, for example, my-cluster-kafka-bootstrap:9092.
        :param str instance: Instance is the Kafka instance to be used, for example, kogito-kafka.
        :param bool use_kogito_infra: UseKogitoInfra flags if the instance will use a provided infrastructure by KogitoInfra CR. Setting this to true will configure a KogitoInfra CR to install Kafka via Strimzi Operator. Strimzi Operator MUST be installed in the namespace for this to work. On OpenShift, OLM should install it for you. If running on Kubernetes without OLM installed, please install Strimzi Operator first. Set this to false and fill other properties to provide your own infrastructure.
        """
        if external_uri is not None:
            pulumi.set(__self__, "external_uri", external_uri)
        if instance is not None:
            pulumi.set(__self__, "instance", instance)
        if use_kogito_infra is not None:
            pulumi.set(__self__, "use_kogito_infra", use_kogito_infra)

    @property
    @pulumi.getter(name="externalURI")
    def external_uri(self) -> Optional[str]:
        """
        URI is the service URI to connect to the Kafka cluster, for example, my-cluster-kafka-bootstrap:9092.
        """
        return pulumi.get(self, "external_uri")

    @property
    @pulumi.getter
    def instance(self) -> Optional[str]:
        """
        Instance is the Kafka instance to be used, for example, kogito-kafka.
        """
        return pulumi.get(self, "instance")

    @property
    @pulumi.getter(name="useKogitoInfra")
    def use_kogito_infra(self) -> Optional[bool]:
        """
        UseKogitoInfra flags if the instance will use a provided infrastructure by KogitoInfra CR. Setting this to true will configure a KogitoInfra CR to install Kafka via Strimzi Operator. Strimzi Operator MUST be installed in the namespace for this to work. On OpenShift, OLM should install it for you. If running on Kubernetes without OLM installed, please install Strimzi Operator first. Set this to false and fill other properties to provide your own infrastructure.
        """
        return pulumi.get(self, "use_kogito_infra")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoRuntimeSpecResources(dict):
    """
    Defined compute resource requirements for the deployed service.
    """
    def __init__(__self__, *,
                 limits: Optional[Mapping[str, 'outputs.KogitoRuntimeSpecResourcesLimits']] = None,
                 requests: Optional[Mapping[str, 'outputs.KogitoRuntimeSpecResourcesRequests']] = None):
        """
        Defined compute resource requirements for the deployed service.
        :param Mapping[str, 'KogitoRuntimeSpecResourcesLimitsArgs'] limits: Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        :param Mapping[str, 'KogitoRuntimeSpecResourcesRequestsArgs'] requests: Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, 'outputs.KogitoRuntimeSpecResourcesLimits']]:
        """
        Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Mapping[str, 'outputs.KogitoRuntimeSpecResourcesRequests']]:
        """
        Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "requests")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoRuntimeSpecResourcesLimits(dict):
    def __init__(__self__):
        pass

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoRuntimeSpecResourcesRequests(dict):
    def __init__(__self__):
        pass

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoRuntimeStatus(dict):
    """
    KogitoRuntimeStatus defines the observed state of KogitoRuntime.
    """
    def __init__(__self__, *,
                 conditions: Sequence['outputs.KogitoRuntimeStatusConditions'],
                 deployment_conditions: Optional[Sequence['outputs.KogitoRuntimeStatusDeploymentConditions']] = None,
                 external_uri: Optional[str] = None,
                 image: Optional[str] = None):
        """
        KogitoRuntimeStatus defines the observed state of KogitoRuntime.
        :param Sequence['KogitoRuntimeStatusConditionsArgs'] conditions: History of conditions for the resource
        :param Sequence['KogitoRuntimeStatusDeploymentConditionsArgs'] deployment_conditions: General conditions for the Kogito Service deployment.
        :param str external_uri: URI is where the service is exposed.
        :param str image: Image is the resolved image for this service.
        """
        pulumi.set(__self__, "conditions", conditions)
        if deployment_conditions is not None:
            pulumi.set(__self__, "deployment_conditions", deployment_conditions)
        if external_uri is not None:
            pulumi.set(__self__, "external_uri", external_uri)
        if image is not None:
            pulumi.set(__self__, "image", image)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.KogitoRuntimeStatusConditions']:
        """
        History of conditions for the resource
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="deploymentConditions")
    def deployment_conditions(self) -> Optional[Sequence['outputs.KogitoRuntimeStatusDeploymentConditions']]:
        """
        General conditions for the Kogito Service deployment.
        """
        return pulumi.get(self, "deployment_conditions")

    @property
    @pulumi.getter(name="externalURI")
    def external_uri(self) -> Optional[str]:
        """
        URI is where the service is exposed.
        """
        return pulumi.get(self, "external_uri")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        Image is the resolved image for this service.
        """
        return pulumi.get(self, "image")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoRuntimeStatusConditions(dict):
    """
    Condition is the detailed condition for the resource
    """
    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None):
        """
        Condition is the detailed condition for the resource
        :param str type: ConditionType is the type of condition
        :param str reason: ReasonType is the type of reason
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        ConditionType is the type of condition
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        ReasonType is the type of reason
        """
        return pulumi.get(self, "reason")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoRuntimeStatusDeploymentConditions(dict):
    """
    DeploymentCondition describes the state of a deployment at a certain point.
    """
    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 last_update_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None):
        """
        DeploymentCondition describes the state of a deployment at a certain point.
        :param str status: Status of the condition, one of True, False, Unknown.
        :param str type: Type of deployment condition.
        :param str last_transition_time: Last time the condition transitioned from one status to another.
        :param str last_update_time: The last time this condition was updated.
        :param str message: A human readable message indicating details about the transition.
        :param str reason: The reason for the condition's last transition.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if last_update_time is not None:
            pulumi.set(__self__, "last_update_time", last_update_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of deployment condition.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        Last time the condition transitioned from one status to another.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter(name="lastUpdateTime")
    def last_update_time(self) -> Optional[str]:
        """
        The last time this condition was updated.
        """
        return pulumi.get(self, "last_update_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        A human readable message indicating details about the transition.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        The reason for the condition's last transition.
        """
        return pulumi.get(self, "reason")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoTrustySpec(dict):
    """
    KogitoTrustySpec defines the desired state of KogitoTrusty.
    """
    def __init__(__self__, *,
                 deployment_labels: Optional[Mapping[str, str]] = None,
                 envs: Optional[Sequence['outputs.KogitoTrustySpecEnvs']] = None,
                 http_port: Optional[int] = None,
                 image: Optional['outputs.KogitoTrustySpecImage'] = None,
                 infinispan: Optional['outputs.KogitoTrustySpecInfinispan'] = None,
                 insecure_image_registry: Optional[bool] = None,
                 kafka: Optional['outputs.KogitoTrustySpecKafka'] = None,
                 replicas: Optional[int] = None,
                 resources: Optional['outputs.KogitoTrustySpecResources'] = None,
                 service_labels: Optional[Mapping[str, str]] = None):
        """
        KogitoTrustySpec defines the desired state of KogitoTrusty.
        :param Mapping[str, str] deployment_labels: Additional labels to be added to the Deployment and Pods managed by the operator.
        :param Sequence['KogitoTrustySpecEnvsArgs'] envs: Environment variables to be added to the runtime container. Keys must be a C_IDENTIFIER.
        :param int http_port: HttpPort will set the environment env HTTP_PORT to define which port service will listen internally.
        :param 'KogitoTrustySpecImageArgs' image: Image definition for the service. Example: Domain: quay.io, Namespace: kiegroup, Name: kogito-service, Tag: latest. On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
        :param 'KogitoTrustySpecInfinispanArgs' infinispan: Has the data used by the service to connect to the Infinispan cluster.
        :param bool insecure_image_registry: A flag indicating that image streams created by Kogito Operator should be configured to allow pulling from insecure registries. Usable just on OpenShift. Defaults to 'false'.
        :param 'KogitoTrustySpecKafkaArgs' kafka: Has the data used by the service to connect to the Kafka cluster.
        :param int replicas: Number of replicas that the service will have deployed in the cluster. Default value: 1.
        :param 'KogitoTrustySpecResourcesArgs' resources: Defined compute resource requirements for the deployed service.
        :param Mapping[str, str] service_labels: Additional labels to be added to the Service managed by the operator.
        """
        if deployment_labels is not None:
            pulumi.set(__self__, "deployment_labels", deployment_labels)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if http_port is not None:
            pulumi.set(__self__, "http_port", http_port)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if infinispan is not None:
            pulumi.set(__self__, "infinispan", infinispan)
        if insecure_image_registry is not None:
            pulumi.set(__self__, "insecure_image_registry", insecure_image_registry)
        if kafka is not None:
            pulumi.set(__self__, "kafka", kafka)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if service_labels is not None:
            pulumi.set(__self__, "service_labels", service_labels)

    @property
    @pulumi.getter(name="deploymentLabels")
    def deployment_labels(self) -> Optional[Mapping[str, str]]:
        """
        Additional labels to be added to the Deployment and Pods managed by the operator.
        """
        return pulumi.get(self, "deployment_labels")

    @property
    @pulumi.getter
    def envs(self) -> Optional[Sequence['outputs.KogitoTrustySpecEnvs']]:
        """
        Environment variables to be added to the runtime container. Keys must be a C_IDENTIFIER.
        """
        return pulumi.get(self, "envs")

    @property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[int]:
        """
        HttpPort will set the environment env HTTP_PORT to define which port service will listen internally.
        """
        return pulumi.get(self, "http_port")

    @property
    @pulumi.getter
    def image(self) -> Optional['outputs.KogitoTrustySpecImage']:
        """
        Image definition for the service. Example: Domain: quay.io, Namespace: kiegroup, Name: kogito-service, Tag: latest. On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def infinispan(self) -> Optional['outputs.KogitoTrustySpecInfinispan']:
        """
        Has the data used by the service to connect to the Infinispan cluster.
        """
        return pulumi.get(self, "infinispan")

    @property
    @pulumi.getter(name="insecureImageRegistry")
    def insecure_image_registry(self) -> Optional[bool]:
        """
        A flag indicating that image streams created by Kogito Operator should be configured to allow pulling from insecure registries. Usable just on OpenShift. Defaults to 'false'.
        """
        return pulumi.get(self, "insecure_image_registry")

    @property
    @pulumi.getter
    def kafka(self) -> Optional['outputs.KogitoTrustySpecKafka']:
        """
        Has the data used by the service to connect to the Kafka cluster.
        """
        return pulumi.get(self, "kafka")

    @property
    @pulumi.getter
    def replicas(self) -> Optional[int]:
        """
        Number of replicas that the service will have deployed in the cluster. Default value: 1.
        """
        return pulumi.get(self, "replicas")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.KogitoTrustySpecResources']:
        """
        Defined compute resource requirements for the deployed service.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter(name="serviceLabels")
    def service_labels(self) -> Optional[Mapping[str, str]]:
        """
        Additional labels to be added to the Service managed by the operator.
        """
        return pulumi.get(self, "service_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoTrustySpecEnvs(dict):
    """
    EnvVar represents an environment variable present in a Container.
    """
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None,
                 value_from: Optional['outputs.KogitoTrustySpecEnvsValueFrom'] = None):
        """
        EnvVar represents an environment variable present in a Container.
        :param str name: Name of the environment variable. Must be a C_IDENTIFIER.
        :param str value: Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        :param 'KogitoTrustySpecEnvsValueFromArgs' value_from: Source for the environment variable's value. Cannot be used if value is not empty.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_from is not None:
            pulumi.set(__self__, "value_from", value_from)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the environment variable. Must be a C_IDENTIFIER.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueFrom")
    def value_from(self) -> Optional['outputs.KogitoTrustySpecEnvsValueFrom']:
        """
        Source for the environment variable's value. Cannot be used if value is not empty.
        """
        return pulumi.get(self, "value_from")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoTrustySpecEnvsValueFrom(dict):
    """
    Source for the environment variable's value. Cannot be used if value is not empty.
    """
    def __init__(__self__, *,
                 config_map_key_ref: Optional['outputs.KogitoTrustySpecEnvsValueFromConfigMapKeyRef'] = None,
                 field_ref: Optional['outputs.KogitoTrustySpecEnvsValueFromFieldRef'] = None,
                 resource_field_ref: Optional['outputs.KogitoTrustySpecEnvsValueFromResourceFieldRef'] = None,
                 secret_key_ref: Optional['outputs.KogitoTrustySpecEnvsValueFromSecretKeyRef'] = None):
        """
        Source for the environment variable's value. Cannot be used if value is not empty.
        :param 'KogitoTrustySpecEnvsValueFromConfigMapKeyRefArgs' config_map_key_ref: Selects a key of a ConfigMap.
        :param 'KogitoTrustySpecEnvsValueFromFieldRefArgs' field_ref: Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        :param 'KogitoTrustySpecEnvsValueFromResourceFieldRefArgs' resource_field_ref: Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        :param 'KogitoTrustySpecEnvsValueFromSecretKeyRefArgs' secret_key_ref: Selects a key of a secret in the pod's namespace
        """
        if config_map_key_ref is not None:
            pulumi.set(__self__, "config_map_key_ref", config_map_key_ref)
        if field_ref is not None:
            pulumi.set(__self__, "field_ref", field_ref)
        if resource_field_ref is not None:
            pulumi.set(__self__, "resource_field_ref", resource_field_ref)
        if secret_key_ref is not None:
            pulumi.set(__self__, "secret_key_ref", secret_key_ref)

    @property
    @pulumi.getter(name="configMapKeyRef")
    def config_map_key_ref(self) -> Optional['outputs.KogitoTrustySpecEnvsValueFromConfigMapKeyRef']:
        """
        Selects a key of a ConfigMap.
        """
        return pulumi.get(self, "config_map_key_ref")

    @property
    @pulumi.getter(name="fieldRef")
    def field_ref(self) -> Optional['outputs.KogitoTrustySpecEnvsValueFromFieldRef']:
        """
        Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        """
        return pulumi.get(self, "field_ref")

    @property
    @pulumi.getter(name="resourceFieldRef")
    def resource_field_ref(self) -> Optional['outputs.KogitoTrustySpecEnvsValueFromResourceFieldRef']:
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        """
        return pulumi.get(self, "resource_field_ref")

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> Optional['outputs.KogitoTrustySpecEnvsValueFromSecretKeyRef']:
        """
        Selects a key of a secret in the pod's namespace
        """
        return pulumi.get(self, "secret_key_ref")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoTrustySpecEnvsValueFromConfigMapKeyRef(dict):
    """
    Selects a key of a ConfigMap.
    """
    def __init__(__self__, *,
                 key: str,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        Selects a key of a ConfigMap.
        :param str key: The key to select.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        :param bool optional: Specify whether the ConfigMap or its key must be defined
        """
        pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key to select.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the ConfigMap or its key must be defined
        """
        return pulumi.get(self, "optional")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoTrustySpecEnvsValueFromFieldRef(dict):
    """
    Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    """
    def __init__(__self__, *,
                 field_path: str,
                 api_version: Optional[str] = None):
        """
        Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        :param str field_path: Path of the field to select in the specified API version.
        :param str api_version: Version of the schema the FieldPath is written in terms of, defaults to "v1".
        """
        pulumi.set(__self__, "field_path", field_path)
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)

    @property
    @pulumi.getter(name="fieldPath")
    def field_path(self) -> str:
        """
        Path of the field to select in the specified API version.
        """
        return pulumi.get(self, "field_path")

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        Version of the schema the FieldPath is written in terms of, defaults to "v1".
        """
        return pulumi.get(self, "api_version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoTrustySpecEnvsValueFromResourceFieldRef(dict):
    """
    Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    """
    def __init__(__self__, *,
                 resource: str,
                 container_name: Optional[str] = None,
                 divisor: Optional['outputs.KogitoTrustySpecEnvsValueFromResourceFieldRefDivisor'] = None):
        """
        Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        :param str resource: Required: resource to select
        :param str container_name: Container name: required for volumes, optional for env vars
        :param 'KogitoTrustySpecEnvsValueFromResourceFieldRefDivisorArgs' divisor: Specifies the output format of the exposed resources, defaults to "1"
        """
        pulumi.set(__self__, "resource", resource)
        if container_name is not None:
            pulumi.set(__self__, "container_name", container_name)
        if divisor is not None:
            pulumi.set(__self__, "divisor", divisor)

    @property
    @pulumi.getter
    def resource(self) -> str:
        """
        Required: resource to select
        """
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> Optional[str]:
        """
        Container name: required for volumes, optional for env vars
        """
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter
    def divisor(self) -> Optional['outputs.KogitoTrustySpecEnvsValueFromResourceFieldRefDivisor']:
        """
        Specifies the output format of the exposed resources, defaults to "1"
        """
        return pulumi.get(self, "divisor")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoTrustySpecEnvsValueFromResourceFieldRefDivisor(dict):
    def __init__(__self__):
        pass

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoTrustySpecEnvsValueFromSecretKeyRef(dict):
    """
    Selects a key of a secret in the pod's namespace
    """
    def __init__(__self__, *,
                 key: str,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        Selects a key of a secret in the pod's namespace
        :param str key: The key of the secret to select from.  Must be a valid secret key.
        :param str name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        :param bool optional: Specify whether the Secret or its key must be defined
        """
        pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the secret to select from.  Must be a valid secret key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        """
        Specify whether the Secret or its key must be defined
        """
        return pulumi.get(self, "optional")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoTrustySpecImage(dict):
    """
    Image definition for the service. Example: Domain: quay.io, Namespace: kiegroup, Name: kogito-service, Tag: latest. On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
    """
    def __init__(__self__, *,
                 domain: Optional[str] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 tag: Optional[str] = None):
        """
        Image definition for the service. Example: Domain: quay.io, Namespace: kiegroup, Name: kogito-service, Tag: latest. On OpenShift an ImageStream will be created in the current namespace pointing to the given image.
        """
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        return pulumi.get(self, "tag")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoTrustySpecInfinispan(dict):
    """
    Has the data used by the service to connect to the Infinispan cluster.
    """
    def __init__(__self__, *,
                 auth_realm: Optional[str] = None,
                 credentials: Optional['outputs.KogitoTrustySpecInfinispanCredentials'] = None,
                 sasl_mechanism: Optional[str] = None,
                 uri: Optional[str] = None,
                 use_auth: Optional[bool] = None,
                 use_kogito_infra: Optional[bool] = None):
        """
        Has the data used by the service to connect to the Infinispan cluster.
        :param str auth_realm: Name of the Infinispan authentication realm. This sets the property infinispan.client.hotrod.auth_realm.
        :param 'KogitoTrustySpecInfinispanCredentialsArgs' credentials: SecretCredentialsType is the data structure for specifying credentials within a Secret.
        :param str sasl_mechanism: SaslMechanism defined for the authentication. This sets the property infinispan.client.hotrod.sasl_mechanism.
        :param str uri: URI to connect to the Infinispan cluster (can it be an internal service or external URI), for example, myinfinispan-cluster:11222.
        :param bool use_auth: UseAuth is set to true if the credentials are set. This also sets the property infinispan.client.hotrod.use_auth.
        :param bool use_kogito_infra: UseKogitoInfra flags if the instance will use a provided infrastructure by KogitoInfra CR. Setting this to true will deploy a new KogitoInfra CR into the namespace that will install Infinispan via Infinispan Operator. Infinispan Operator MUST be installed in the namespace for this to work. On OpenShift, OLM should install it for you. If running on Kubernetes without OLM installed, please install Infinispan Operator first. Set this to false and fill all other properties to provide your own infrastructure.
        """
        if auth_realm is not None:
            pulumi.set(__self__, "auth_realm", auth_realm)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if sasl_mechanism is not None:
            pulumi.set(__self__, "sasl_mechanism", sasl_mechanism)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)
        if use_auth is not None:
            pulumi.set(__self__, "use_auth", use_auth)
        if use_kogito_infra is not None:
            pulumi.set(__self__, "use_kogito_infra", use_kogito_infra)

    @property
    @pulumi.getter(name="authRealm")
    def auth_realm(self) -> Optional[str]:
        """
        Name of the Infinispan authentication realm. This sets the property infinispan.client.hotrod.auth_realm.
        """
        return pulumi.get(self, "auth_realm")

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.KogitoTrustySpecInfinispanCredentials']:
        """
        SecretCredentialsType is the data structure for specifying credentials within a Secret.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="saslMechanism")
    def sasl_mechanism(self) -> Optional[str]:
        """
        SaslMechanism defined for the authentication. This sets the property infinispan.client.hotrod.sasl_mechanism.
        """
        return pulumi.get(self, "sasl_mechanism")

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        """
        URI to connect to the Infinispan cluster (can it be an internal service or external URI), for example, myinfinispan-cluster:11222.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter(name="useAuth")
    def use_auth(self) -> Optional[bool]:
        """
        UseAuth is set to true if the credentials are set. This also sets the property infinispan.client.hotrod.use_auth.
        """
        return pulumi.get(self, "use_auth")

    @property
    @pulumi.getter(name="useKogitoInfra")
    def use_kogito_infra(self) -> Optional[bool]:
        """
        UseKogitoInfra flags if the instance will use a provided infrastructure by KogitoInfra CR. Setting this to true will deploy a new KogitoInfra CR into the namespace that will install Infinispan via Infinispan Operator. Infinispan Operator MUST be installed in the namespace for this to work. On OpenShift, OLM should install it for you. If running on Kubernetes without OLM installed, please install Infinispan Operator first. Set this to false and fill all other properties to provide your own infrastructure.
        """
        return pulumi.get(self, "use_kogito_infra")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoTrustySpecInfinispanCredentials(dict):
    """
    SecretCredentialsType is the data structure for specifying credentials within a Secret.
    """
    def __init__(__self__, *,
                 password_key: Optional[str] = None,
                 secret_name: Optional[str] = None,
                 username_key: Optional[str] = None):
        """
        SecretCredentialsType is the data structure for specifying credentials within a Secret.
        :param str password_key: PasswordKey is the key pointing to a value in a Secret holding the password value.
        :param str secret_name: SecretName is the name of the secret where the credentials are set.
        :param str username_key: UsernameKey is the key pointing to a value in a Secret holding the username value.
        """
        if password_key is not None:
            pulumi.set(__self__, "password_key", password_key)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)
        if username_key is not None:
            pulumi.set(__self__, "username_key", username_key)

    @property
    @pulumi.getter(name="passwordKey")
    def password_key(self) -> Optional[str]:
        """
        PasswordKey is the key pointing to a value in a Secret holding the password value.
        """
        return pulumi.get(self, "password_key")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[str]:
        """
        SecretName is the name of the secret where the credentials are set.
        """
        return pulumi.get(self, "secret_name")

    @property
    @pulumi.getter(name="usernameKey")
    def username_key(self) -> Optional[str]:
        """
        UsernameKey is the key pointing to a value in a Secret holding the username value.
        """
        return pulumi.get(self, "username_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoTrustySpecKafka(dict):
    """
    Has the data used by the service to connect to the Kafka cluster.
    """
    def __init__(__self__, *,
                 external_uri: Optional[str] = None,
                 instance: Optional[str] = None,
                 use_kogito_infra: Optional[bool] = None):
        """
        Has the data used by the service to connect to the Kafka cluster.
        :param str external_uri: URI is the service URI to connect to the Kafka cluster, for example, my-cluster-kafka-bootstrap:9092.
        :param str instance: Instance is the Kafka instance to be used, for example, kogito-kafka.
        :param bool use_kogito_infra: UseKogitoInfra flags if the instance will use a provided infrastructure by KogitoInfra CR. Setting this to true will configure a KogitoInfra CR to install Kafka via Strimzi Operator. Strimzi Operator MUST be installed in the namespace for this to work. On OpenShift, OLM should install it for you. If running on Kubernetes without OLM installed, please install Strimzi Operator first. Set this to false and fill other properties to provide your own infrastructure.
        """
        if external_uri is not None:
            pulumi.set(__self__, "external_uri", external_uri)
        if instance is not None:
            pulumi.set(__self__, "instance", instance)
        if use_kogito_infra is not None:
            pulumi.set(__self__, "use_kogito_infra", use_kogito_infra)

    @property
    @pulumi.getter(name="externalURI")
    def external_uri(self) -> Optional[str]:
        """
        URI is the service URI to connect to the Kafka cluster, for example, my-cluster-kafka-bootstrap:9092.
        """
        return pulumi.get(self, "external_uri")

    @property
    @pulumi.getter
    def instance(self) -> Optional[str]:
        """
        Instance is the Kafka instance to be used, for example, kogito-kafka.
        """
        return pulumi.get(self, "instance")

    @property
    @pulumi.getter(name="useKogitoInfra")
    def use_kogito_infra(self) -> Optional[bool]:
        """
        UseKogitoInfra flags if the instance will use a provided infrastructure by KogitoInfra CR. Setting this to true will configure a KogitoInfra CR to install Kafka via Strimzi Operator. Strimzi Operator MUST be installed in the namespace for this to work. On OpenShift, OLM should install it for you. If running on Kubernetes without OLM installed, please install Strimzi Operator first. Set this to false and fill other properties to provide your own infrastructure.
        """
        return pulumi.get(self, "use_kogito_infra")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoTrustySpecResources(dict):
    """
    Defined compute resource requirements for the deployed service.
    """
    def __init__(__self__, *,
                 limits: Optional[Mapping[str, 'outputs.KogitoTrustySpecResourcesLimits']] = None,
                 requests: Optional[Mapping[str, 'outputs.KogitoTrustySpecResourcesRequests']] = None):
        """
        Defined compute resource requirements for the deployed service.
        :param Mapping[str, 'KogitoTrustySpecResourcesLimitsArgs'] limits: Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        :param Mapping[str, 'KogitoTrustySpecResourcesRequestsArgs'] requests: Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, 'outputs.KogitoTrustySpecResourcesLimits']]:
        """
        Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Mapping[str, 'outputs.KogitoTrustySpecResourcesRequests']]:
        """
        Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "requests")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoTrustySpecResourcesLimits(dict):
    def __init__(__self__):
        pass

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoTrustySpecResourcesRequests(dict):
    def __init__(__self__):
        pass

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoTrustyStatus(dict):
    """
    KogitoTrustyStatus defines the observed state of KogitoTrusty.
    """
    def __init__(__self__, *,
                 conditions: Sequence['outputs.KogitoTrustyStatusConditions'],
                 deployment_conditions: Optional[Sequence['outputs.KogitoTrustyStatusDeploymentConditions']] = None,
                 external_uri: Optional[str] = None,
                 image: Optional[str] = None):
        """
        KogitoTrustyStatus defines the observed state of KogitoTrusty.
        :param Sequence['KogitoTrustyStatusConditionsArgs'] conditions: History of conditions for the resource
        :param Sequence['KogitoTrustyStatusDeploymentConditionsArgs'] deployment_conditions: General conditions for the Kogito Service deployment.
        :param str external_uri: URI is where the service is exposed.
        :param str image: Image is the resolved image for this service.
        """
        pulumi.set(__self__, "conditions", conditions)
        if deployment_conditions is not None:
            pulumi.set(__self__, "deployment_conditions", deployment_conditions)
        if external_uri is not None:
            pulumi.set(__self__, "external_uri", external_uri)
        if image is not None:
            pulumi.set(__self__, "image", image)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.KogitoTrustyStatusConditions']:
        """
        History of conditions for the resource
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="deploymentConditions")
    def deployment_conditions(self) -> Optional[Sequence['outputs.KogitoTrustyStatusDeploymentConditions']]:
        """
        General conditions for the Kogito Service deployment.
        """
        return pulumi.get(self, "deployment_conditions")

    @property
    @pulumi.getter(name="externalURI")
    def external_uri(self) -> Optional[str]:
        """
        URI is where the service is exposed.
        """
        return pulumi.get(self, "external_uri")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        Image is the resolved image for this service.
        """
        return pulumi.get(self, "image")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoTrustyStatusConditions(dict):
    """
    Condition is the detailed condition for the resource
    """
    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None):
        """
        Condition is the detailed condition for the resource
        :param str type: ConditionType is the type of condition
        :param str reason: ReasonType is the type of reason
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        ConditionType is the type of condition
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        ReasonType is the type of reason
        """
        return pulumi.get(self, "reason")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KogitoTrustyStatusDeploymentConditions(dict):
    """
    DeploymentCondition describes the state of a deployment at a certain point.
    """
    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 last_update_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None):
        """
        DeploymentCondition describes the state of a deployment at a certain point.
        :param str status: Status of the condition, one of True, False, Unknown.
        :param str type: Type of deployment condition.
        :param str last_transition_time: Last time the condition transitioned from one status to another.
        :param str last_update_time: The last time this condition was updated.
        :param str message: A human readable message indicating details about the transition.
        :param str reason: The reason for the condition's last transition.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if last_update_time is not None:
            pulumi.set(__self__, "last_update_time", last_update_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of deployment condition.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        Last time the condition transitioned from one status to another.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter(name="lastUpdateTime")
    def last_update_time(self) -> Optional[str]:
        """
        The last time this condition was updated.
        """
        return pulumi.get(self, "last_update_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        A human readable message indicating details about the transition.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        The reason for the condition's last transition.
        """
        return pulumi.get(self, "reason")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


