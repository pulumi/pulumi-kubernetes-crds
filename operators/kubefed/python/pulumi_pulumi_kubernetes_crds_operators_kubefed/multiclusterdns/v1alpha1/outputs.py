# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from ... import _utilities, _tables
from . import outputs

__all__ = [
    'DNSEndpointSpec',
    'DNSEndpointSpecEndpoints',
    'DNSEndpointStatus',
    'IngressDNSRecordSpec',
    'IngressDNSRecordStatus',
    'IngressDNSRecordStatusDns',
    'ServiceDNSRecordSpec',
    'ServiceDNSRecordStatus',
    'ServiceDNSRecordStatusDns',
]

@pulumi.output_type
class DNSEndpointSpec(dict):
    def __init__(__self__, *,
                 endpoints: Optional[Sequence['outputs.DNSEndpointSpecEndpoints']] = None):
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[Sequence['outputs.DNSEndpointSpecEndpoints']]:
        return pulumi.get(self, "endpoints")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DNSEndpointSpecEndpoints(dict):
    def __init__(__self__, *,
                 dns_name: Optional[str] = None,
                 labels: Optional[Mapping[str, Any]] = None,
                 record_ttl: Optional[int] = None,
                 record_type: Optional[str] = None,
                 targets: Optional[Sequence[str]] = None):
        """
        :param str dns_name: The FQDN of the DNS record.
        :param Mapping[str, Any] labels: Labels stores labels defined for the Endpoint.
        :param int record_ttl: TTL for the record in seconds.
        :param str record_type: RecordType type of record, e.g. CNAME, A, SRV, TXT etc.
        :param Sequence[str] targets: The targets that the DNS record points to.
        """
        if dns_name is not None:
            pulumi.set(__self__, "dns_name", dns_name)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if record_ttl is not None:
            pulumi.set(__self__, "record_ttl", record_ttl)
        if record_type is not None:
            pulumi.set(__self__, "record_type", record_type)
        if targets is not None:
            pulumi.set(__self__, "targets", targets)

    @property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> Optional[str]:
        """
        The FQDN of the DNS record.
        """
        return pulumi.get(self, "dns_name")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels stores labels defined for the Endpoint.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="recordTTL")
    def record_ttl(self) -> Optional[int]:
        """
        TTL for the record in seconds.
        """
        return pulumi.get(self, "record_ttl")

    @property
    @pulumi.getter(name="recordType")
    def record_type(self) -> Optional[str]:
        """
        RecordType type of record, e.g. CNAME, A, SRV, TXT etc.
        """
        return pulumi.get(self, "record_type")

    @property
    @pulumi.getter
    def targets(self) -> Optional[Sequence[str]]:
        """
        The targets that the DNS record points to.
        """
        return pulumi.get(self, "targets")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DNSEndpointStatus(dict):
    def __init__(__self__, *,
                 observed_generation: Optional[int] = None):
        """
        :param int observed_generation: ObservedGeneration is the generation as observed by the controller consuming the DNSEndpoint.
        """
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[int]:
        """
        ObservedGeneration is the generation as observed by the controller consuming the DNSEndpoint.
        """
        return pulumi.get(self, "observed_generation")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class IngressDNSRecordSpec(dict):
    def __init__(__self__, *,
                 hosts: Optional[Sequence[str]] = None,
                 record_ttl: Optional[int] = None):
        """
        :param Sequence[str] hosts: Host from the IngressRule in Cluster Ingress Spec
        :param int record_ttl: RecordTTL is the TTL in seconds for DNS records created for the Ingress, if omitted a default would be used
        """
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if record_ttl is not None:
            pulumi.set(__self__, "record_ttl", record_ttl)

    @property
    @pulumi.getter
    def hosts(self) -> Optional[Sequence[str]]:
        """
        Host from the IngressRule in Cluster Ingress Spec
        """
        return pulumi.get(self, "hosts")

    @property
    @pulumi.getter(name="recordTTL")
    def record_ttl(self) -> Optional[int]:
        """
        RecordTTL is the TTL in seconds for DNS records created for the Ingress, if omitted a default would be used
        """
        return pulumi.get(self, "record_ttl")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class IngressDNSRecordStatus(dict):
    def __init__(__self__, *,
                 dns: Optional[Sequence['outputs.IngressDNSRecordStatusDns']] = None):
        """
        :param Sequence['IngressDNSRecordStatusDnsArgs'] dns: Array of Ingress Controller LoadBalancers
        """
        if dns is not None:
            pulumi.set(__self__, "dns", dns)

    @property
    @pulumi.getter
    def dns(self) -> Optional[Sequence['outputs.IngressDNSRecordStatusDns']]:
        """
        Array of Ingress Controller LoadBalancers
        """
        return pulumi.get(self, "dns")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class IngressDNSRecordStatusDns(dict):
    def __init__(__self__, *,
                 cluster: Optional[str] = None,
                 load_balancer: Optional[Mapping[str, Any]] = None):
        """
        :param str cluster: Cluster name
        :param Mapping[str, Any] load_balancer: LoadBalancer for the corresponding ingress controller
        """
        if cluster is not None:
            pulumi.set(__self__, "cluster", cluster)
        if load_balancer is not None:
            pulumi.set(__self__, "load_balancer", load_balancer)

    @property
    @pulumi.getter
    def cluster(self) -> Optional[str]:
        """
        Cluster name
        """
        return pulumi.get(self, "cluster")

    @property
    @pulumi.getter(name="loadBalancer")
    def load_balancer(self) -> Optional[Mapping[str, Any]]:
        """
        LoadBalancer for the corresponding ingress controller
        """
        return pulumi.get(self, "load_balancer")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ServiceDNSRecordSpec(dict):
    def __init__(__self__, *,
                 domain_ref: str,
                 allow_service_without_endpoints: Optional[bool] = None,
                 dns_prefix: Optional[str] = None,
                 external_name: Optional[str] = None,
                 record_ttl: Optional[int] = None):
        """
        :param str domain_ref: DomainRef is the name of the domain object to which the corresponding federated service belongs
        :param bool allow_service_without_endpoints: AllowServiceWithoutEndpoints allows DNS records to be written for Service shards without endpoints
        :param str dns_prefix: DNSPrefix when specified, an additional DNS record would be created with <DNSPrefix>.<KubeFedDomain>
        :param str external_name: ExternalName when specified, replaces the service name portion of a resource record with the value of ExternalName.
        :param int record_ttl: RecordTTL is the TTL in seconds for DNS records created for this Service, if omitted a default would be used
        """
        pulumi.set(__self__, "domain_ref", domain_ref)
        if allow_service_without_endpoints is not None:
            pulumi.set(__self__, "allow_service_without_endpoints", allow_service_without_endpoints)
        if dns_prefix is not None:
            pulumi.set(__self__, "dns_prefix", dns_prefix)
        if external_name is not None:
            pulumi.set(__self__, "external_name", external_name)
        if record_ttl is not None:
            pulumi.set(__self__, "record_ttl", record_ttl)

    @property
    @pulumi.getter(name="domainRef")
    def domain_ref(self) -> str:
        """
        DomainRef is the name of the domain object to which the corresponding federated service belongs
        """
        return pulumi.get(self, "domain_ref")

    @property
    @pulumi.getter(name="allowServiceWithoutEndpoints")
    def allow_service_without_endpoints(self) -> Optional[bool]:
        """
        AllowServiceWithoutEndpoints allows DNS records to be written for Service shards without endpoints
        """
        return pulumi.get(self, "allow_service_without_endpoints")

    @property
    @pulumi.getter(name="dnsPrefix")
    def dns_prefix(self) -> Optional[str]:
        """
        DNSPrefix when specified, an additional DNS record would be created with <DNSPrefix>.<KubeFedDomain>
        """
        return pulumi.get(self, "dns_prefix")

    @property
    @pulumi.getter(name="externalName")
    def external_name(self) -> Optional[str]:
        """
        ExternalName when specified, replaces the service name portion of a resource record with the value of ExternalName.
        """
        return pulumi.get(self, "external_name")

    @property
    @pulumi.getter(name="recordTTL")
    def record_ttl(self) -> Optional[int]:
        """
        RecordTTL is the TTL in seconds for DNS records created for this Service, if omitted a default would be used
        """
        return pulumi.get(self, "record_ttl")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ServiceDNSRecordStatus(dict):
    def __init__(__self__, *,
                 dns: Optional[Sequence['outputs.ServiceDNSRecordStatusDns']] = None,
                 domain: Optional[str] = None):
        """
        :param str domain: Domain is the DNS domain of the KubeFed control plane as in Domain API
        """
        if dns is not None:
            pulumi.set(__self__, "dns", dns)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def dns(self) -> Optional[Sequence['outputs.ServiceDNSRecordStatusDns']]:
        return pulumi.get(self, "dns")

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        """
        Domain is the DNS domain of the KubeFed control plane as in Domain API
        """
        return pulumi.get(self, "domain")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ServiceDNSRecordStatusDns(dict):
    def __init__(__self__, *,
                 cluster: Optional[str] = None,
                 load_balancer: Optional[Mapping[str, Any]] = None,
                 region: Optional[str] = None,
                 zones: Optional[Sequence[str]] = None):
        """
        :param str cluster: Cluster name
        :param Mapping[str, Any] load_balancer: LoadBalancer for the corresponding service
        :param str region: Region to which the cluster belongs
        :param Sequence[str] zones: Zones to which the cluster belongs
        """
        if cluster is not None:
            pulumi.set(__self__, "cluster", cluster)
        if load_balancer is not None:
            pulumi.set(__self__, "load_balancer", load_balancer)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if zones is not None:
            pulumi.set(__self__, "zones", zones)

    @property
    @pulumi.getter
    def cluster(self) -> Optional[str]:
        """
        Cluster name
        """
        return pulumi.get(self, "cluster")

    @property
    @pulumi.getter(name="loadBalancer")
    def load_balancer(self) -> Optional[Mapping[str, Any]]:
        """
        LoadBalancer for the corresponding service
        """
        return pulumi.get(self, "load_balancer")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Region to which the cluster belongs
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def zones(self) -> Optional[Sequence[str]]:
        """
        Zones to which the cluster belongs
        """
        return pulumi.get(self, "zones")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


