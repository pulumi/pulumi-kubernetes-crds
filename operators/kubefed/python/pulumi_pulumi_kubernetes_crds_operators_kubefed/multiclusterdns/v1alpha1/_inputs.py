# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from ... import _utilities, _tables

__all__ = [
    'DNSEndpointSpecArgs',
    'DNSEndpointSpecEndpointsArgs',
    'DNSEndpointStatusArgs',
    'IngressDNSRecordSpecArgs',
    'IngressDNSRecordStatusArgs',
    'IngressDNSRecordStatusDnsArgs',
    'ServiceDNSRecordSpecArgs',
    'ServiceDNSRecordStatusArgs',
    'ServiceDNSRecordStatusDnsArgs',
]

@pulumi.input_type
class DNSEndpointSpecArgs:
    def __init__(__self__, *,
                 endpoints: Optional[pulumi.Input[Sequence[pulumi.Input['DNSEndpointSpecEndpointsArgs']]]] = None):
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DNSEndpointSpecEndpointsArgs']]]]:
        return pulumi.get(self, "endpoints")

    @endpoints.setter
    def endpoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DNSEndpointSpecEndpointsArgs']]]]):
        pulumi.set(self, "endpoints", value)


@pulumi.input_type
class DNSEndpointSpecEndpointsArgs:
    def __init__(__self__, *,
                 dns_name: Optional[pulumi.Input[str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 record_ttl: Optional[pulumi.Input[int]] = None,
                 record_type: Optional[pulumi.Input[str]] = None,
                 targets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] dns_name: The FQDN of the DNS record.
        :param pulumi.Input[Mapping[str, Any]] labels: Labels stores labels defined for the Endpoint.
        :param pulumi.Input[int] record_ttl: TTL for the record in seconds.
        :param pulumi.Input[str] record_type: RecordType type of record, e.g. CNAME, A, SRV, TXT etc.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] targets: The targets that the DNS record points to.
        """
        if dns_name is not None:
            pulumi.set(__self__, "dns_name", dns_name)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if record_ttl is not None:
            pulumi.set(__self__, "record_ttl", record_ttl)
        if record_type is not None:
            pulumi.set(__self__, "record_type", record_type)
        if targets is not None:
            pulumi.set(__self__, "targets", targets)

    @property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> Optional[pulumi.Input[str]]:
        """
        The FQDN of the DNS record.
        """
        return pulumi.get(self, "dns_name")

    @dns_name.setter
    def dns_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns_name", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Labels stores labels defined for the Endpoint.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="recordTTL")
    def record_ttl(self) -> Optional[pulumi.Input[int]]:
        """
        TTL for the record in seconds.
        """
        return pulumi.get(self, "record_ttl")

    @record_ttl.setter
    def record_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "record_ttl", value)

    @property
    @pulumi.getter(name="recordType")
    def record_type(self) -> Optional[pulumi.Input[str]]:
        """
        RecordType type of record, e.g. CNAME, A, SRV, TXT etc.
        """
        return pulumi.get(self, "record_type")

    @record_type.setter
    def record_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "record_type", value)

    @property
    @pulumi.getter
    def targets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The targets that the DNS record points to.
        """
        return pulumi.get(self, "targets")

    @targets.setter
    def targets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "targets", value)


@pulumi.input_type
class DNSEndpointStatusArgs:
    def __init__(__self__, *,
                 observed_generation: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] observed_generation: ObservedGeneration is the generation as observed by the controller consuming the DNSEndpoint.
        """
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[pulumi.Input[int]]:
        """
        ObservedGeneration is the generation as observed by the controller consuming the DNSEndpoint.
        """
        return pulumi.get(self, "observed_generation")

    @observed_generation.setter
    def observed_generation(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "observed_generation", value)


@pulumi.input_type
class IngressDNSRecordSpecArgs:
    def __init__(__self__, *,
                 hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 record_ttl: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] hosts: Host from the IngressRule in Cluster Ingress Spec
        :param pulumi.Input[int] record_ttl: RecordTTL is the TTL in seconds for DNS records created for the Ingress, if omitted a default would be used
        """
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if record_ttl is not None:
            pulumi.set(__self__, "record_ttl", record_ttl)

    @property
    @pulumi.getter
    def hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Host from the IngressRule in Cluster Ingress Spec
        """
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hosts", value)

    @property
    @pulumi.getter(name="recordTTL")
    def record_ttl(self) -> Optional[pulumi.Input[int]]:
        """
        RecordTTL is the TTL in seconds for DNS records created for the Ingress, if omitted a default would be used
        """
        return pulumi.get(self, "record_ttl")

    @record_ttl.setter
    def record_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "record_ttl", value)


@pulumi.input_type
class IngressDNSRecordStatusArgs:
    def __init__(__self__, *,
                 dns: Optional[pulumi.Input[Sequence[pulumi.Input['IngressDNSRecordStatusDnsArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['IngressDNSRecordStatusDnsArgs']]] dns: Array of Ingress Controller LoadBalancers
        """
        if dns is not None:
            pulumi.set(__self__, "dns", dns)

    @property
    @pulumi.getter
    def dns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IngressDNSRecordStatusDnsArgs']]]]:
        """
        Array of Ingress Controller LoadBalancers
        """
        return pulumi.get(self, "dns")

    @dns.setter
    def dns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IngressDNSRecordStatusDnsArgs']]]]):
        pulumi.set(self, "dns", value)


@pulumi.input_type
class IngressDNSRecordStatusDnsArgs:
    def __init__(__self__, *,
                 cluster: Optional[pulumi.Input[str]] = None,
                 load_balancer: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        :param pulumi.Input[str] cluster: Cluster name
        :param pulumi.Input[Mapping[str, Any]] load_balancer: LoadBalancer for the corresponding ingress controller
        """
        if cluster is not None:
            pulumi.set(__self__, "cluster", cluster)
        if load_balancer is not None:
            pulumi.set(__self__, "load_balancer", load_balancer)

    @property
    @pulumi.getter
    def cluster(self) -> Optional[pulumi.Input[str]]:
        """
        Cluster name
        """
        return pulumi.get(self, "cluster")

    @cluster.setter
    def cluster(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster", value)

    @property
    @pulumi.getter(name="loadBalancer")
    def load_balancer(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        LoadBalancer for the corresponding ingress controller
        """
        return pulumi.get(self, "load_balancer")

    @load_balancer.setter
    def load_balancer(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "load_balancer", value)


@pulumi.input_type
class ServiceDNSRecordSpecArgs:
    def __init__(__self__, *,
                 domain_ref: pulumi.Input[str],
                 allow_service_without_endpoints: Optional[pulumi.Input[bool]] = None,
                 dns_prefix: Optional[pulumi.Input[str]] = None,
                 external_name: Optional[pulumi.Input[str]] = None,
                 record_ttl: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] domain_ref: DomainRef is the name of the domain object to which the corresponding federated service belongs
        :param pulumi.Input[bool] allow_service_without_endpoints: AllowServiceWithoutEndpoints allows DNS records to be written for Service shards without endpoints
        :param pulumi.Input[str] dns_prefix: DNSPrefix when specified, an additional DNS record would be created with <DNSPrefix>.<KubeFedDomain>
        :param pulumi.Input[str] external_name: ExternalName when specified, replaces the service name portion of a resource record with the value of ExternalName.
        :param pulumi.Input[int] record_ttl: RecordTTL is the TTL in seconds for DNS records created for this Service, if omitted a default would be used
        """
        pulumi.set(__self__, "domain_ref", domain_ref)
        if allow_service_without_endpoints is not None:
            pulumi.set(__self__, "allow_service_without_endpoints", allow_service_without_endpoints)
        if dns_prefix is not None:
            pulumi.set(__self__, "dns_prefix", dns_prefix)
        if external_name is not None:
            pulumi.set(__self__, "external_name", external_name)
        if record_ttl is not None:
            pulumi.set(__self__, "record_ttl", record_ttl)

    @property
    @pulumi.getter(name="domainRef")
    def domain_ref(self) -> pulumi.Input[str]:
        """
        DomainRef is the name of the domain object to which the corresponding federated service belongs
        """
        return pulumi.get(self, "domain_ref")

    @domain_ref.setter
    def domain_ref(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain_ref", value)

    @property
    @pulumi.getter(name="allowServiceWithoutEndpoints")
    def allow_service_without_endpoints(self) -> Optional[pulumi.Input[bool]]:
        """
        AllowServiceWithoutEndpoints allows DNS records to be written for Service shards without endpoints
        """
        return pulumi.get(self, "allow_service_without_endpoints")

    @allow_service_without_endpoints.setter
    def allow_service_without_endpoints(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_service_without_endpoints", value)

    @property
    @pulumi.getter(name="dnsPrefix")
    def dns_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        DNSPrefix when specified, an additional DNS record would be created with <DNSPrefix>.<KubeFedDomain>
        """
        return pulumi.get(self, "dns_prefix")

    @dns_prefix.setter
    def dns_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns_prefix", value)

    @property
    @pulumi.getter(name="externalName")
    def external_name(self) -> Optional[pulumi.Input[str]]:
        """
        ExternalName when specified, replaces the service name portion of a resource record with the value of ExternalName.
        """
        return pulumi.get(self, "external_name")

    @external_name.setter
    def external_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "external_name", value)

    @property
    @pulumi.getter(name="recordTTL")
    def record_ttl(self) -> Optional[pulumi.Input[int]]:
        """
        RecordTTL is the TTL in seconds for DNS records created for this Service, if omitted a default would be used
        """
        return pulumi.get(self, "record_ttl")

    @record_ttl.setter
    def record_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "record_ttl", value)


@pulumi.input_type
class ServiceDNSRecordStatusArgs:
    def __init__(__self__, *,
                 dns: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceDNSRecordStatusDnsArgs']]]] = None,
                 domain: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] domain: Domain is the DNS domain of the KubeFed control plane as in Domain API
        """
        if dns is not None:
            pulumi.set(__self__, "dns", dns)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def dns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceDNSRecordStatusDnsArgs']]]]:
        return pulumi.get(self, "dns")

    @dns.setter
    def dns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceDNSRecordStatusDnsArgs']]]]):
        pulumi.set(self, "dns", value)

    @property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[str]]:
        """
        Domain is the DNS domain of the KubeFed control plane as in Domain API
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain", value)


@pulumi.input_type
class ServiceDNSRecordStatusDnsArgs:
    def __init__(__self__, *,
                 cluster: Optional[pulumi.Input[str]] = None,
                 load_balancer: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 zones: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] cluster: Cluster name
        :param pulumi.Input[Mapping[str, Any]] load_balancer: LoadBalancer for the corresponding service
        :param pulumi.Input[str] region: Region to which the cluster belongs
        :param pulumi.Input[Sequence[pulumi.Input[str]]] zones: Zones to which the cluster belongs
        """
        if cluster is not None:
            pulumi.set(__self__, "cluster", cluster)
        if load_balancer is not None:
            pulumi.set(__self__, "load_balancer", load_balancer)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if zones is not None:
            pulumi.set(__self__, "zones", zones)

    @property
    @pulumi.getter
    def cluster(self) -> Optional[pulumi.Input[str]]:
        """
        Cluster name
        """
        return pulumi.get(self, "cluster")

    @cluster.setter
    def cluster(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster", value)

    @property
    @pulumi.getter(name="loadBalancer")
    def load_balancer(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        LoadBalancer for the corresponding service
        """
        return pulumi.get(self, "load_balancer")

    @load_balancer.setter
    def load_balancer(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "load_balancer", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        Region to which the cluster belongs
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter
    def zones(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zones to which the cluster belongs
        """
        return pulumi.get(self, "zones")

    @zones.setter
    def zones(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "zones", value)


