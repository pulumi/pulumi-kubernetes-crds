# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from ... import _utilities, _tables

__all__ = [
    'FederatedTypeConfigSpecArgs',
    'FederatedTypeConfigSpecFederatedTypeArgs',
    'FederatedTypeConfigSpecStatusTypeArgs',
    'FederatedTypeConfigSpecTargetTypeArgs',
    'FederatedTypeConfigStatusArgs',
    'KubeFedClusterSpecArgs',
    'KubeFedClusterSpecSecretRefArgs',
    'KubeFedClusterStatusArgs',
    'KubeFedClusterStatusConditionsArgs',
    'KubeFedConfigSpecArgs',
    'KubeFedConfigSpecClusterHealthCheckArgs',
    'KubeFedConfigSpecControllerDurationArgs',
    'KubeFedConfigSpecFeatureGatesArgs',
    'KubeFedConfigSpecLeaderElectArgs',
    'KubeFedConfigSpecSyncControllerArgs',
]

@pulumi.input_type
class FederatedTypeConfigSpecArgs:
    def __init__(__self__, *,
                 federated_type: pulumi.Input['FederatedTypeConfigSpecFederatedTypeArgs'],
                 propagation: pulumi.Input[str],
                 target_type: pulumi.Input['FederatedTypeConfigSpecTargetTypeArgs'],
                 status_collection: Optional[pulumi.Input[str]] = None,
                 status_type: Optional[pulumi.Input['FederatedTypeConfigSpecStatusTypeArgs']] = None):
        """
        :param pulumi.Input['FederatedTypeConfigSpecFederatedTypeArgs'] federated_type: Configuration for the federated type that defines (via template, placement and overrides fields) how the target type should appear in multiple cluster.
        :param pulumi.Input[str] propagation: Whether or not propagation to member clusters should be enabled.
        :param pulumi.Input['FederatedTypeConfigSpecTargetTypeArgs'] target_type: The configuration of the target type. If not set, the pluralName and groupName fields will be set from the metadata.name of this resource. The kind field must be set.
        :param pulumi.Input[str] status_collection: Whether or not Status object should be populated.
        :param pulumi.Input['FederatedTypeConfigSpecStatusTypeArgs'] status_type: Configuration for the status type that holds information about which type holds the status of the federated resource. If not provided, the group and version will default to those provided for the federated type api resource.
        """
        pulumi.set(__self__, "federated_type", federated_type)
        pulumi.set(__self__, "propagation", propagation)
        pulumi.set(__self__, "target_type", target_type)
        if status_collection is not None:
            pulumi.set(__self__, "status_collection", status_collection)
        if status_type is not None:
            pulumi.set(__self__, "status_type", status_type)

    @property
    @pulumi.getter(name="federatedType")
    def federated_type(self) -> pulumi.Input['FederatedTypeConfigSpecFederatedTypeArgs']:
        """
        Configuration for the federated type that defines (via template, placement and overrides fields) how the target type should appear in multiple cluster.
        """
        return pulumi.get(self, "federated_type")

    @federated_type.setter
    def federated_type(self, value: pulumi.Input['FederatedTypeConfigSpecFederatedTypeArgs']):
        pulumi.set(self, "federated_type", value)

    @property
    @pulumi.getter
    def propagation(self) -> pulumi.Input[str]:
        """
        Whether or not propagation to member clusters should be enabled.
        """
        return pulumi.get(self, "propagation")

    @propagation.setter
    def propagation(self, value: pulumi.Input[str]):
        pulumi.set(self, "propagation", value)

    @property
    @pulumi.getter(name="targetType")
    def target_type(self) -> pulumi.Input['FederatedTypeConfigSpecTargetTypeArgs']:
        """
        The configuration of the target type. If not set, the pluralName and groupName fields will be set from the metadata.name of this resource. The kind field must be set.
        """
        return pulumi.get(self, "target_type")

    @target_type.setter
    def target_type(self, value: pulumi.Input['FederatedTypeConfigSpecTargetTypeArgs']):
        pulumi.set(self, "target_type", value)

    @property
    @pulumi.getter(name="statusCollection")
    def status_collection(self) -> Optional[pulumi.Input[str]]:
        """
        Whether or not Status object should be populated.
        """
        return pulumi.get(self, "status_collection")

    @status_collection.setter
    def status_collection(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status_collection", value)

    @property
    @pulumi.getter(name="statusType")
    def status_type(self) -> Optional[pulumi.Input['FederatedTypeConfigSpecStatusTypeArgs']]:
        """
        Configuration for the status type that holds information about which type holds the status of the federated resource. If not provided, the group and version will default to those provided for the federated type api resource.
        """
        return pulumi.get(self, "status_type")

    @status_type.setter
    def status_type(self, value: Optional[pulumi.Input['FederatedTypeConfigSpecStatusTypeArgs']]):
        pulumi.set(self, "status_type", value)


@pulumi.input_type
class FederatedTypeConfigSpecFederatedTypeArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[str],
                 plural_name: pulumi.Input[str],
                 scope: pulumi.Input[str],
                 version: pulumi.Input[str],
                 group: Optional[pulumi.Input[str]] = None):
        """
        Configuration for the federated type that defines (via template, placement and overrides fields) how the target type should appear in multiple cluster.
        :param pulumi.Input[str] kind: Camel-cased singular name of the resource (e.g. ConfigMap)
        :param pulumi.Input[str] plural_name: Lower-cased plural name of the resource (e.g. configmaps).  If not provided, it will be computed by lower-casing the kind and suffixing an 's'.
        :param pulumi.Input[str] scope: Scope of the resource.
        :param pulumi.Input[str] version: Version of the resource.
        :param pulumi.Input[str] group: Group of the resource.
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "plural_name", plural_name)
        pulumi.set(__self__, "scope", scope)
        pulumi.set(__self__, "version", version)
        if group is not None:
            pulumi.set(__self__, "group", group)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[str]:
        """
        Camel-cased singular name of the resource (e.g. ConfigMap)
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="pluralName")
    def plural_name(self) -> pulumi.Input[str]:
        """
        Lower-cased plural name of the resource (e.g. configmaps).  If not provided, it will be computed by lower-casing the kind and suffixing an 's'.
        """
        return pulumi.get(self, "plural_name")

    @plural_name.setter
    def plural_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "plural_name", value)

    @property
    @pulumi.getter
    def scope(self) -> pulumi.Input[str]:
        """
        Scope of the resource.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[str]:
        """
        Version of the resource.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[str]):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        Group of the resource.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)


@pulumi.input_type
class FederatedTypeConfigSpecStatusTypeArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[str],
                 plural_name: pulumi.Input[str],
                 scope: pulumi.Input[str],
                 version: pulumi.Input[str],
                 group: Optional[pulumi.Input[str]] = None):
        """
        Configuration for the status type that holds information about which type holds the status of the federated resource. If not provided, the group and version will default to those provided for the federated type api resource.
        :param pulumi.Input[str] kind: Camel-cased singular name of the resource (e.g. ConfigMap)
        :param pulumi.Input[str] plural_name: Lower-cased plural name of the resource (e.g. configmaps).  If not provided, it will be computed by lower-casing the kind and suffixing an 's'.
        :param pulumi.Input[str] scope: Scope of the resource.
        :param pulumi.Input[str] version: Version of the resource.
        :param pulumi.Input[str] group: Group of the resource.
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "plural_name", plural_name)
        pulumi.set(__self__, "scope", scope)
        pulumi.set(__self__, "version", version)
        if group is not None:
            pulumi.set(__self__, "group", group)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[str]:
        """
        Camel-cased singular name of the resource (e.g. ConfigMap)
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="pluralName")
    def plural_name(self) -> pulumi.Input[str]:
        """
        Lower-cased plural name of the resource (e.g. configmaps).  If not provided, it will be computed by lower-casing the kind and suffixing an 's'.
        """
        return pulumi.get(self, "plural_name")

    @plural_name.setter
    def plural_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "plural_name", value)

    @property
    @pulumi.getter
    def scope(self) -> pulumi.Input[str]:
        """
        Scope of the resource.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[str]:
        """
        Version of the resource.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[str]):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        Group of the resource.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)


@pulumi.input_type
class FederatedTypeConfigSpecTargetTypeArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[str],
                 plural_name: pulumi.Input[str],
                 scope: pulumi.Input[str],
                 version: pulumi.Input[str],
                 group: Optional[pulumi.Input[str]] = None):
        """
        The configuration of the target type. If not set, the pluralName and groupName fields will be set from the metadata.name of this resource. The kind field must be set.
        :param pulumi.Input[str] kind: Camel-cased singular name of the resource (e.g. ConfigMap)
        :param pulumi.Input[str] plural_name: Lower-cased plural name of the resource (e.g. configmaps).  If not provided, it will be computed by lower-casing the kind and suffixing an 's'.
        :param pulumi.Input[str] scope: Scope of the resource.
        :param pulumi.Input[str] version: Version of the resource.
        :param pulumi.Input[str] group: Group of the resource.
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "plural_name", plural_name)
        pulumi.set(__self__, "scope", scope)
        pulumi.set(__self__, "version", version)
        if group is not None:
            pulumi.set(__self__, "group", group)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[str]:
        """
        Camel-cased singular name of the resource (e.g. ConfigMap)
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="pluralName")
    def plural_name(self) -> pulumi.Input[str]:
        """
        Lower-cased plural name of the resource (e.g. configmaps).  If not provided, it will be computed by lower-casing the kind and suffixing an 's'.
        """
        return pulumi.get(self, "plural_name")

    @plural_name.setter
    def plural_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "plural_name", value)

    @property
    @pulumi.getter
    def scope(self) -> pulumi.Input[str]:
        """
        Scope of the resource.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[str]:
        """
        Version of the resource.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[str]):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        Group of the resource.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)


@pulumi.input_type
class FederatedTypeConfigStatusArgs:
    def __init__(__self__, *,
                 observed_generation: pulumi.Input[int],
                 propagation_controller: pulumi.Input[str],
                 status_controller: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] observed_generation: ObservedGeneration is the generation as observed by the controller consuming the FederatedTypeConfig.
        :param pulumi.Input[str] propagation_controller: PropagationController tracks the status of the sync controller.
        :param pulumi.Input[str] status_controller: StatusController tracks the status of the status controller.
        """
        pulumi.set(__self__, "observed_generation", observed_generation)
        pulumi.set(__self__, "propagation_controller", propagation_controller)
        if status_controller is not None:
            pulumi.set(__self__, "status_controller", status_controller)

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> pulumi.Input[int]:
        """
        ObservedGeneration is the generation as observed by the controller consuming the FederatedTypeConfig.
        """
        return pulumi.get(self, "observed_generation")

    @observed_generation.setter
    def observed_generation(self, value: pulumi.Input[int]):
        pulumi.set(self, "observed_generation", value)

    @property
    @pulumi.getter(name="propagationController")
    def propagation_controller(self) -> pulumi.Input[str]:
        """
        PropagationController tracks the status of the sync controller.
        """
        return pulumi.get(self, "propagation_controller")

    @propagation_controller.setter
    def propagation_controller(self, value: pulumi.Input[str]):
        pulumi.set(self, "propagation_controller", value)

    @property
    @pulumi.getter(name="statusController")
    def status_controller(self) -> Optional[pulumi.Input[str]]:
        """
        StatusController tracks the status of the status controller.
        """
        return pulumi.get(self, "status_controller")

    @status_controller.setter
    def status_controller(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status_controller", value)


@pulumi.input_type
class KubeFedClusterSpecArgs:
    def __init__(__self__, *,
                 api_endpoint: pulumi.Input[str],
                 secret_ref: pulumi.Input['KubeFedClusterSpecSecretRefArgs'],
                 ca_bundle: Optional[pulumi.Input[str]] = None,
                 disabled_tls_validations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] api_endpoint: The API endpoint of the member cluster. This can be a hostname, hostname:port, IP or IP:port.
        :param pulumi.Input['KubeFedClusterSpecSecretRefArgs'] secret_ref: Name of the secret containing the token required to access the member cluster. The secret needs to exist in the same namespace as the control plane and should have a "token" key.
        :param pulumi.Input[str] ca_bundle: CABundle contains the certificate authority information.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] disabled_tls_validations: DisabledTLSValidations defines a list of checks to ignore when validating the TLS connection to the member cluster.  This can be any of *, SubjectName, or ValidityPeriod. If * is specified, it is expected to be the only option in list.
        """
        pulumi.set(__self__, "api_endpoint", api_endpoint)
        pulumi.set(__self__, "secret_ref", secret_ref)
        if ca_bundle is not None:
            pulumi.set(__self__, "ca_bundle", ca_bundle)
        if disabled_tls_validations is not None:
            pulumi.set(__self__, "disabled_tls_validations", disabled_tls_validations)

    @property
    @pulumi.getter(name="apiEndpoint")
    def api_endpoint(self) -> pulumi.Input[str]:
        """
        The API endpoint of the member cluster. This can be a hostname, hostname:port, IP or IP:port.
        """
        return pulumi.get(self, "api_endpoint")

    @api_endpoint.setter
    def api_endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_endpoint", value)

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> pulumi.Input['KubeFedClusterSpecSecretRefArgs']:
        """
        Name of the secret containing the token required to access the member cluster. The secret needs to exist in the same namespace as the control plane and should have a "token" key.
        """
        return pulumi.get(self, "secret_ref")

    @secret_ref.setter
    def secret_ref(self, value: pulumi.Input['KubeFedClusterSpecSecretRefArgs']):
        pulumi.set(self, "secret_ref", value)

    @property
    @pulumi.getter(name="caBundle")
    def ca_bundle(self) -> Optional[pulumi.Input[str]]:
        """
        CABundle contains the certificate authority information.
        """
        return pulumi.get(self, "ca_bundle")

    @ca_bundle.setter
    def ca_bundle(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_bundle", value)

    @property
    @pulumi.getter(name="disabledTLSValidations")
    def disabled_tls_validations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        DisabledTLSValidations defines a list of checks to ignore when validating the TLS connection to the member cluster.  This can be any of *, SubjectName, or ValidityPeriod. If * is specified, it is expected to be the only option in list.
        """
        return pulumi.get(self, "disabled_tls_validations")

    @disabled_tls_validations.setter
    def disabled_tls_validations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "disabled_tls_validations", value)


@pulumi.input_type
class KubeFedClusterSpecSecretRefArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        Name of the secret containing the token required to access the member cluster. The secret needs to exist in the same namespace as the control plane and should have a "token" key.
        :param pulumi.Input[str] name: Name of a secret within the enclosing namespace
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of a secret within the enclosing namespace
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class KubeFedClusterStatusArgs:
    def __init__(__self__, *,
                 conditions: pulumi.Input[Sequence[pulumi.Input['KubeFedClusterStatusConditionsArgs']]],
                 region: Optional[pulumi.Input[str]] = None,
                 zones: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['KubeFedClusterStatusConditionsArgs']]] conditions: Conditions is an array of current cluster conditions.
        :param pulumi.Input[str] region: Region is the name of the region in which all of the nodes in the cluster exist.  e.g. 'us-east1'.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] zones: Zones are the names of availability zones in which the nodes of the cluster exist, e.g. 'us-east1-a'.
        """
        pulumi.set(__self__, "conditions", conditions)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if zones is not None:
            pulumi.set(__self__, "zones", zones)

    @property
    @pulumi.getter
    def conditions(self) -> pulumi.Input[Sequence[pulumi.Input['KubeFedClusterStatusConditionsArgs']]]:
        """
        Conditions is an array of current cluster conditions.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: pulumi.Input[Sequence[pulumi.Input['KubeFedClusterStatusConditionsArgs']]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        Region is the name of the region in which all of the nodes in the cluster exist.  e.g. 'us-east1'.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter
    def zones(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zones are the names of availability zones in which the nodes of the cluster exist, e.g. 'us-east1-a'.
        """
        return pulumi.get(self, "zones")

    @zones.setter
    def zones(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "zones", value)


@pulumi.input_type
class KubeFedClusterStatusConditionsArgs:
    def __init__(__self__, *,
                 last_probe_time: pulumi.Input[str],
                 status: pulumi.Input[str],
                 type: pulumi.Input[str],
                 last_transition_time: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] last_probe_time: Last time the condition was checked.
        :param pulumi.Input[str] status: Status of the condition, one of True, False, Unknown.
        :param pulumi.Input[str] type: Type of cluster condition, Ready or Offline.
        :param pulumi.Input[str] last_transition_time: Last time the condition transit from one status to another.
        :param pulumi.Input[str] message: Human readable message indicating details about last transition.
        :param pulumi.Input[str] reason: (brief) reason for the condition's last transition.
        """
        pulumi.set(__self__, "last_probe_time", last_probe_time)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter(name="lastProbeTime")
    def last_probe_time(self) -> pulumi.Input[str]:
        """
        Last time the condition was checked.
        """
        return pulumi.get(self, "last_probe_time")

    @last_probe_time.setter
    def last_probe_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "last_probe_time", value)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        """
        Status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of cluster condition, Ready or Offline.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[pulumi.Input[str]]:
        """
        Last time the condition transit from one status to another.
        """
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Human readable message indicating details about last transition.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        (brief) reason for the condition's last transition.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)


@pulumi.input_type
class KubeFedConfigSpecArgs:
    def __init__(__self__, *,
                 scope: pulumi.Input[str],
                 cluster_health_check: Optional[pulumi.Input['KubeFedConfigSpecClusterHealthCheckArgs']] = None,
                 controller_duration: Optional[pulumi.Input['KubeFedConfigSpecControllerDurationArgs']] = None,
                 feature_gates: Optional[pulumi.Input[Sequence[pulumi.Input['KubeFedConfigSpecFeatureGatesArgs']]]] = None,
                 leader_elect: Optional[pulumi.Input['KubeFedConfigSpecLeaderElectArgs']] = None,
                 sync_controller: Optional[pulumi.Input['KubeFedConfigSpecSyncControllerArgs']] = None):
        """
        :param pulumi.Input[str] scope: The scope of the KubeFed control plane should be either `Namespaced` or `Cluster`. `Namespaced` indicates that the KubeFed namespace will be the only target of the control plane.
        """
        pulumi.set(__self__, "scope", scope)
        if cluster_health_check is not None:
            pulumi.set(__self__, "cluster_health_check", cluster_health_check)
        if controller_duration is not None:
            pulumi.set(__self__, "controller_duration", controller_duration)
        if feature_gates is not None:
            pulumi.set(__self__, "feature_gates", feature_gates)
        if leader_elect is not None:
            pulumi.set(__self__, "leader_elect", leader_elect)
        if sync_controller is not None:
            pulumi.set(__self__, "sync_controller", sync_controller)

    @property
    @pulumi.getter
    def scope(self) -> pulumi.Input[str]:
        """
        The scope of the KubeFed control plane should be either `Namespaced` or `Cluster`. `Namespaced` indicates that the KubeFed namespace will be the only target of the control plane.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter(name="clusterHealthCheck")
    def cluster_health_check(self) -> Optional[pulumi.Input['KubeFedConfigSpecClusterHealthCheckArgs']]:
        return pulumi.get(self, "cluster_health_check")

    @cluster_health_check.setter
    def cluster_health_check(self, value: Optional[pulumi.Input['KubeFedConfigSpecClusterHealthCheckArgs']]):
        pulumi.set(self, "cluster_health_check", value)

    @property
    @pulumi.getter(name="controllerDuration")
    def controller_duration(self) -> Optional[pulumi.Input['KubeFedConfigSpecControllerDurationArgs']]:
        return pulumi.get(self, "controller_duration")

    @controller_duration.setter
    def controller_duration(self, value: Optional[pulumi.Input['KubeFedConfigSpecControllerDurationArgs']]):
        pulumi.set(self, "controller_duration", value)

    @property
    @pulumi.getter(name="featureGates")
    def feature_gates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KubeFedConfigSpecFeatureGatesArgs']]]]:
        return pulumi.get(self, "feature_gates")

    @feature_gates.setter
    def feature_gates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KubeFedConfigSpecFeatureGatesArgs']]]]):
        pulumi.set(self, "feature_gates", value)

    @property
    @pulumi.getter(name="leaderElect")
    def leader_elect(self) -> Optional[pulumi.Input['KubeFedConfigSpecLeaderElectArgs']]:
        return pulumi.get(self, "leader_elect")

    @leader_elect.setter
    def leader_elect(self, value: Optional[pulumi.Input['KubeFedConfigSpecLeaderElectArgs']]):
        pulumi.set(self, "leader_elect", value)

    @property
    @pulumi.getter(name="syncController")
    def sync_controller(self) -> Optional[pulumi.Input['KubeFedConfigSpecSyncControllerArgs']]:
        return pulumi.get(self, "sync_controller")

    @sync_controller.setter
    def sync_controller(self, value: Optional[pulumi.Input['KubeFedConfigSpecSyncControllerArgs']]):
        pulumi.set(self, "sync_controller", value)


@pulumi.input_type
class KubeFedConfigSpecClusterHealthCheckArgs:
    def __init__(__self__, *,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 period: Optional[pulumi.Input[str]] = None,
                 success_threshold: Optional[pulumi.Input[int]] = None,
                 timeout: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] failure_threshold: Minimum consecutive failures for the cluster health to be considered failed after having succeeded.
        :param pulumi.Input[str] period: How often to monitor the cluster health.
        :param pulumi.Input[int] success_threshold: Minimum consecutive successes for the cluster health to be considered successful after having failed.
        :param pulumi.Input[str] timeout: Duration after which the cluster health check times out.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive failures for the cluster health to be considered failed after having succeeded.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[str]]:
        """
        How often to monitor the cluster health.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "period", value)

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive successes for the cluster health to be considered successful after having failed.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "success_threshold", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Duration after which the cluster health check times out.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeout", value)


@pulumi.input_type
class KubeFedConfigSpecControllerDurationArgs:
    def __init__(__self__, *,
                 available_delay: Optional[pulumi.Input[str]] = None,
                 unavailable_delay: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] available_delay: Time to wait before reconciling on a healthy cluster.
        :param pulumi.Input[str] unavailable_delay: Time to wait before giving up on an unhealthy cluster.
        """
        if available_delay is not None:
            pulumi.set(__self__, "available_delay", available_delay)
        if unavailable_delay is not None:
            pulumi.set(__self__, "unavailable_delay", unavailable_delay)

    @property
    @pulumi.getter(name="availableDelay")
    def available_delay(self) -> Optional[pulumi.Input[str]]:
        """
        Time to wait before reconciling on a healthy cluster.
        """
        return pulumi.get(self, "available_delay")

    @available_delay.setter
    def available_delay(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "available_delay", value)

    @property
    @pulumi.getter(name="unavailableDelay")
    def unavailable_delay(self) -> Optional[pulumi.Input[str]]:
        """
        Time to wait before giving up on an unhealthy cluster.
        """
        return pulumi.get(self, "unavailable_delay")

    @unavailable_delay.setter
    def unavailable_delay(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unavailable_delay", value)


@pulumi.input_type
class KubeFedConfigSpecFeatureGatesArgs:
    def __init__(__self__, *,
                 configuration: pulumi.Input[str],
                 name: pulumi.Input[str]):
        pulumi.set(__self__, "configuration", configuration)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def configuration(self) -> pulumi.Input[str]:
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: pulumi.Input[str]):
        pulumi.set(self, "configuration", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class KubeFedConfigSpecLeaderElectArgs:
    def __init__(__self__, *,
                 lease_duration: Optional[pulumi.Input[str]] = None,
                 renew_deadline: Optional[pulumi.Input[str]] = None,
                 resource_lock: Optional[pulumi.Input[str]] = None,
                 retry_period: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] lease_duration: The duration that non-leader candidates will wait after observing a leadership renewal until attempting to acquire leadership of a led but unrenewed leader slot. This is effectively the maximum duration that a leader can be stopped before it is replaced by another candidate. This is only applicable if leader election is enabled.
        :param pulumi.Input[str] renew_deadline: The interval between attempts by the acting master to renew a leadership slot before it stops leading. This must be less than or equal to the lease duration. This is only applicable if leader election is enabled.
        :param pulumi.Input[str] resource_lock: The type of resource object that is used for locking during leader election. Supported options are `configmaps` (default) and `endpoints`.
        :param pulumi.Input[str] retry_period: The duration the clients should wait between attempting acquisition and renewal of a leadership. This is only applicable if leader election is enabled.
        """
        if lease_duration is not None:
            pulumi.set(__self__, "lease_duration", lease_duration)
        if renew_deadline is not None:
            pulumi.set(__self__, "renew_deadline", renew_deadline)
        if resource_lock is not None:
            pulumi.set(__self__, "resource_lock", resource_lock)
        if retry_period is not None:
            pulumi.set(__self__, "retry_period", retry_period)

    @property
    @pulumi.getter(name="leaseDuration")
    def lease_duration(self) -> Optional[pulumi.Input[str]]:
        """
        The duration that non-leader candidates will wait after observing a leadership renewal until attempting to acquire leadership of a led but unrenewed leader slot. This is effectively the maximum duration that a leader can be stopped before it is replaced by another candidate. This is only applicable if leader election is enabled.
        """
        return pulumi.get(self, "lease_duration")

    @lease_duration.setter
    def lease_duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lease_duration", value)

    @property
    @pulumi.getter(name="renewDeadline")
    def renew_deadline(self) -> Optional[pulumi.Input[str]]:
        """
        The interval between attempts by the acting master to renew a leadership slot before it stops leading. This must be less than or equal to the lease duration. This is only applicable if leader election is enabled.
        """
        return pulumi.get(self, "renew_deadline")

    @renew_deadline.setter
    def renew_deadline(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "renew_deadline", value)

    @property
    @pulumi.getter(name="resourceLock")
    def resource_lock(self) -> Optional[pulumi.Input[str]]:
        """
        The type of resource object that is used for locking during leader election. Supported options are `configmaps` (default) and `endpoints`.
        """
        return pulumi.get(self, "resource_lock")

    @resource_lock.setter
    def resource_lock(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_lock", value)

    @property
    @pulumi.getter(name="retryPeriod")
    def retry_period(self) -> Optional[pulumi.Input[str]]:
        """
        The duration the clients should wait between attempting acquisition and renewal of a leadership. This is only applicable if leader election is enabled.
        """
        return pulumi.get(self, "retry_period")

    @retry_period.setter
    def retry_period(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "retry_period", value)


@pulumi.input_type
class KubeFedConfigSpecSyncControllerArgs:
    def __init__(__self__, *,
                 adopt_resources: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] adopt_resources: Whether to adopt pre-existing resources in member clusters. Defaults to "Enabled".
        """
        if adopt_resources is not None:
            pulumi.set(__self__, "adopt_resources", adopt_resources)

    @property
    @pulumi.getter(name="adoptResources")
    def adopt_resources(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to adopt pre-existing resources in member clusters. Defaults to "Enabled".
        """
        return pulumi.get(self, "adopt_resources")

    @adopt_resources.setter
    def adopt_resources(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "adopt_resources", value)


