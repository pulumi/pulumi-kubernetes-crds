# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from ... import _utilities, _tables
from . import outputs

__all__ = [
    'FederatedTypeConfigSpec',
    'FederatedTypeConfigSpecFederatedType',
    'FederatedTypeConfigSpecStatusType',
    'FederatedTypeConfigSpecTargetType',
    'FederatedTypeConfigStatus',
    'KubeFedClusterSpec',
    'KubeFedClusterSpecSecretRef',
    'KubeFedClusterStatus',
    'KubeFedClusterStatusConditions',
    'KubeFedConfigSpec',
    'KubeFedConfigSpecClusterHealthCheck',
    'KubeFedConfigSpecControllerDuration',
    'KubeFedConfigSpecFeatureGates',
    'KubeFedConfigSpecLeaderElect',
    'KubeFedConfigSpecSyncController',
]

@pulumi.output_type
class FederatedTypeConfigSpec(dict):
    def __init__(__self__, *,
                 federated_type: 'outputs.FederatedTypeConfigSpecFederatedType',
                 propagation: str,
                 target_type: 'outputs.FederatedTypeConfigSpecTargetType',
                 status_collection: Optional[str] = None,
                 status_type: Optional['outputs.FederatedTypeConfigSpecStatusType'] = None):
        """
        :param 'FederatedTypeConfigSpecFederatedTypeArgs' federated_type: Configuration for the federated type that defines (via template, placement and overrides fields) how the target type should appear in multiple cluster.
        :param str propagation: Whether or not propagation to member clusters should be enabled.
        :param 'FederatedTypeConfigSpecTargetTypeArgs' target_type: The configuration of the target type. If not set, the pluralName and groupName fields will be set from the metadata.name of this resource. The kind field must be set.
        :param str status_collection: Whether or not Status object should be populated.
        :param 'FederatedTypeConfigSpecStatusTypeArgs' status_type: Configuration for the status type that holds information about which type holds the status of the federated resource. If not provided, the group and version will default to those provided for the federated type api resource.
        """
        pulumi.set(__self__, "federated_type", federated_type)
        pulumi.set(__self__, "propagation", propagation)
        pulumi.set(__self__, "target_type", target_type)
        if status_collection is not None:
            pulumi.set(__self__, "status_collection", status_collection)
        if status_type is not None:
            pulumi.set(__self__, "status_type", status_type)

    @property
    @pulumi.getter(name="federatedType")
    def federated_type(self) -> 'outputs.FederatedTypeConfigSpecFederatedType':
        """
        Configuration for the federated type that defines (via template, placement and overrides fields) how the target type should appear in multiple cluster.
        """
        return pulumi.get(self, "federated_type")

    @property
    @pulumi.getter
    def propagation(self) -> str:
        """
        Whether or not propagation to member clusters should be enabled.
        """
        return pulumi.get(self, "propagation")

    @property
    @pulumi.getter(name="targetType")
    def target_type(self) -> 'outputs.FederatedTypeConfigSpecTargetType':
        """
        The configuration of the target type. If not set, the pluralName and groupName fields will be set from the metadata.name of this resource. The kind field must be set.
        """
        return pulumi.get(self, "target_type")

    @property
    @pulumi.getter(name="statusCollection")
    def status_collection(self) -> Optional[str]:
        """
        Whether or not Status object should be populated.
        """
        return pulumi.get(self, "status_collection")

    @property
    @pulumi.getter(name="statusType")
    def status_type(self) -> Optional['outputs.FederatedTypeConfigSpecStatusType']:
        """
        Configuration for the status type that holds information about which type holds the status of the federated resource. If not provided, the group and version will default to those provided for the federated type api resource.
        """
        return pulumi.get(self, "status_type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class FederatedTypeConfigSpecFederatedType(dict):
    """
    Configuration for the federated type that defines (via template, placement and overrides fields) how the target type should appear in multiple cluster.
    """
    def __init__(__self__, *,
                 kind: str,
                 plural_name: str,
                 scope: str,
                 version: str,
                 group: Optional[str] = None):
        """
        Configuration for the federated type that defines (via template, placement and overrides fields) how the target type should appear in multiple cluster.
        :param str kind: Camel-cased singular name of the resource (e.g. ConfigMap)
        :param str plural_name: Lower-cased plural name of the resource (e.g. configmaps).  If not provided, it will be computed by lower-casing the kind and suffixing an 's'.
        :param str scope: Scope of the resource.
        :param str version: Version of the resource.
        :param str group: Group of the resource.
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "plural_name", plural_name)
        pulumi.set(__self__, "scope", scope)
        pulumi.set(__self__, "version", version)
        if group is not None:
            pulumi.set(__self__, "group", group)

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        Camel-cased singular name of the resource (e.g. ConfigMap)
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="pluralName")
    def plural_name(self) -> str:
        """
        Lower-cased plural name of the resource (e.g. configmaps).  If not provided, it will be computed by lower-casing the kind and suffixing an 's'.
        """
        return pulumi.get(self, "plural_name")

    @property
    @pulumi.getter
    def scope(self) -> str:
        """
        Scope of the resource.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Version of the resource.
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group of the resource.
        """
        return pulumi.get(self, "group")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class FederatedTypeConfigSpecStatusType(dict):
    """
    Configuration for the status type that holds information about which type holds the status of the federated resource. If not provided, the group and version will default to those provided for the federated type api resource.
    """
    def __init__(__self__, *,
                 kind: str,
                 plural_name: str,
                 scope: str,
                 version: str,
                 group: Optional[str] = None):
        """
        Configuration for the status type that holds information about which type holds the status of the federated resource. If not provided, the group and version will default to those provided for the federated type api resource.
        :param str kind: Camel-cased singular name of the resource (e.g. ConfigMap)
        :param str plural_name: Lower-cased plural name of the resource (e.g. configmaps).  If not provided, it will be computed by lower-casing the kind and suffixing an 's'.
        :param str scope: Scope of the resource.
        :param str version: Version of the resource.
        :param str group: Group of the resource.
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "plural_name", plural_name)
        pulumi.set(__self__, "scope", scope)
        pulumi.set(__self__, "version", version)
        if group is not None:
            pulumi.set(__self__, "group", group)

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        Camel-cased singular name of the resource (e.g. ConfigMap)
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="pluralName")
    def plural_name(self) -> str:
        """
        Lower-cased plural name of the resource (e.g. configmaps).  If not provided, it will be computed by lower-casing the kind and suffixing an 's'.
        """
        return pulumi.get(self, "plural_name")

    @property
    @pulumi.getter
    def scope(self) -> str:
        """
        Scope of the resource.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Version of the resource.
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group of the resource.
        """
        return pulumi.get(self, "group")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class FederatedTypeConfigSpecTargetType(dict):
    """
    The configuration of the target type. If not set, the pluralName and groupName fields will be set from the metadata.name of this resource. The kind field must be set.
    """
    def __init__(__self__, *,
                 kind: str,
                 plural_name: str,
                 scope: str,
                 version: str,
                 group: Optional[str] = None):
        """
        The configuration of the target type. If not set, the pluralName and groupName fields will be set from the metadata.name of this resource. The kind field must be set.
        :param str kind: Camel-cased singular name of the resource (e.g. ConfigMap)
        :param str plural_name: Lower-cased plural name of the resource (e.g. configmaps).  If not provided, it will be computed by lower-casing the kind and suffixing an 's'.
        :param str scope: Scope of the resource.
        :param str version: Version of the resource.
        :param str group: Group of the resource.
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "plural_name", plural_name)
        pulumi.set(__self__, "scope", scope)
        pulumi.set(__self__, "version", version)
        if group is not None:
            pulumi.set(__self__, "group", group)

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        Camel-cased singular name of the resource (e.g. ConfigMap)
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="pluralName")
    def plural_name(self) -> str:
        """
        Lower-cased plural name of the resource (e.g. configmaps).  If not provided, it will be computed by lower-casing the kind and suffixing an 's'.
        """
        return pulumi.get(self, "plural_name")

    @property
    @pulumi.getter
    def scope(self) -> str:
        """
        Scope of the resource.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Version of the resource.
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group of the resource.
        """
        return pulumi.get(self, "group")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class FederatedTypeConfigStatus(dict):
    def __init__(__self__, *,
                 observed_generation: int,
                 propagation_controller: str,
                 status_controller: Optional[str] = None):
        """
        :param int observed_generation: ObservedGeneration is the generation as observed by the controller consuming the FederatedTypeConfig.
        :param str propagation_controller: PropagationController tracks the status of the sync controller.
        :param str status_controller: StatusController tracks the status of the status controller.
        """
        pulumi.set(__self__, "observed_generation", observed_generation)
        pulumi.set(__self__, "propagation_controller", propagation_controller)
        if status_controller is not None:
            pulumi.set(__self__, "status_controller", status_controller)

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> int:
        """
        ObservedGeneration is the generation as observed by the controller consuming the FederatedTypeConfig.
        """
        return pulumi.get(self, "observed_generation")

    @property
    @pulumi.getter(name="propagationController")
    def propagation_controller(self) -> str:
        """
        PropagationController tracks the status of the sync controller.
        """
        return pulumi.get(self, "propagation_controller")

    @property
    @pulumi.getter(name="statusController")
    def status_controller(self) -> Optional[str]:
        """
        StatusController tracks the status of the status controller.
        """
        return pulumi.get(self, "status_controller")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KubeFedClusterSpec(dict):
    def __init__(__self__, *,
                 api_endpoint: str,
                 secret_ref: 'outputs.KubeFedClusterSpecSecretRef',
                 ca_bundle: Optional[str] = None,
                 disabled_tls_validations: Optional[Sequence[str]] = None):
        """
        :param str api_endpoint: The API endpoint of the member cluster. This can be a hostname, hostname:port, IP or IP:port.
        :param 'KubeFedClusterSpecSecretRefArgs' secret_ref: Name of the secret containing the token required to access the member cluster. The secret needs to exist in the same namespace as the control plane and should have a "token" key.
        :param str ca_bundle: CABundle contains the certificate authority information.
        :param Sequence[str] disabled_tls_validations: DisabledTLSValidations defines a list of checks to ignore when validating the TLS connection to the member cluster.  This can be any of *, SubjectName, or ValidityPeriod. If * is specified, it is expected to be the only option in list.
        """
        pulumi.set(__self__, "api_endpoint", api_endpoint)
        pulumi.set(__self__, "secret_ref", secret_ref)
        if ca_bundle is not None:
            pulumi.set(__self__, "ca_bundle", ca_bundle)
        if disabled_tls_validations is not None:
            pulumi.set(__self__, "disabled_tls_validations", disabled_tls_validations)

    @property
    @pulumi.getter(name="apiEndpoint")
    def api_endpoint(self) -> str:
        """
        The API endpoint of the member cluster. This can be a hostname, hostname:port, IP or IP:port.
        """
        return pulumi.get(self, "api_endpoint")

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> 'outputs.KubeFedClusterSpecSecretRef':
        """
        Name of the secret containing the token required to access the member cluster. The secret needs to exist in the same namespace as the control plane and should have a "token" key.
        """
        return pulumi.get(self, "secret_ref")

    @property
    @pulumi.getter(name="caBundle")
    def ca_bundle(self) -> Optional[str]:
        """
        CABundle contains the certificate authority information.
        """
        return pulumi.get(self, "ca_bundle")

    @property
    @pulumi.getter(name="disabledTLSValidations")
    def disabled_tls_validations(self) -> Optional[Sequence[str]]:
        """
        DisabledTLSValidations defines a list of checks to ignore when validating the TLS connection to the member cluster.  This can be any of *, SubjectName, or ValidityPeriod. If * is specified, it is expected to be the only option in list.
        """
        return pulumi.get(self, "disabled_tls_validations")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KubeFedClusterSpecSecretRef(dict):
    """
    Name of the secret containing the token required to access the member cluster. The secret needs to exist in the same namespace as the control plane and should have a "token" key.
    """
    def __init__(__self__, *,
                 name: str):
        """
        Name of the secret containing the token required to access the member cluster. The secret needs to exist in the same namespace as the control plane and should have a "token" key.
        :param str name: Name of a secret within the enclosing namespace
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of a secret within the enclosing namespace
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KubeFedClusterStatus(dict):
    def __init__(__self__, *,
                 conditions: Sequence['outputs.KubeFedClusterStatusConditions'],
                 region: Optional[str] = None,
                 zones: Optional[Sequence[str]] = None):
        """
        :param Sequence['KubeFedClusterStatusConditionsArgs'] conditions: Conditions is an array of current cluster conditions.
        :param str region: Region is the name of the region in which all of the nodes in the cluster exist.  e.g. 'us-east1'.
        :param Sequence[str] zones: Zones are the names of availability zones in which the nodes of the cluster exist, e.g. 'us-east1-a'.
        """
        pulumi.set(__self__, "conditions", conditions)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if zones is not None:
            pulumi.set(__self__, "zones", zones)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.KubeFedClusterStatusConditions']:
        """
        Conditions is an array of current cluster conditions.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Region is the name of the region in which all of the nodes in the cluster exist.  e.g. 'us-east1'.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def zones(self) -> Optional[Sequence[str]]:
        """
        Zones are the names of availability zones in which the nodes of the cluster exist, e.g. 'us-east1-a'.
        """
        return pulumi.get(self, "zones")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KubeFedClusterStatusConditions(dict):
    def __init__(__self__, *,
                 last_probe_time: str,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None):
        """
        :param str last_probe_time: Last time the condition was checked.
        :param str status: Status of the condition, one of True, False, Unknown.
        :param str type: Type of cluster condition, Ready or Offline.
        :param str last_transition_time: Last time the condition transit from one status to another.
        :param str message: Human readable message indicating details about last transition.
        :param str reason: (brief) reason for the condition's last transition.
        """
        pulumi.set(__self__, "last_probe_time", last_probe_time)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter(name="lastProbeTime")
    def last_probe_time(self) -> str:
        """
        Last time the condition was checked.
        """
        return pulumi.get(self, "last_probe_time")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the condition, one of True, False, Unknown.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of cluster condition, Ready or Offline.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        Last time the condition transit from one status to another.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Human readable message indicating details about last transition.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        (brief) reason for the condition's last transition.
        """
        return pulumi.get(self, "reason")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KubeFedConfigSpec(dict):
    def __init__(__self__, *,
                 scope: str,
                 cluster_health_check: Optional['outputs.KubeFedConfigSpecClusterHealthCheck'] = None,
                 controller_duration: Optional['outputs.KubeFedConfigSpecControllerDuration'] = None,
                 feature_gates: Optional[Sequence['outputs.KubeFedConfigSpecFeatureGates']] = None,
                 leader_elect: Optional['outputs.KubeFedConfigSpecLeaderElect'] = None,
                 sync_controller: Optional['outputs.KubeFedConfigSpecSyncController'] = None):
        """
        :param str scope: The scope of the KubeFed control plane should be either `Namespaced` or `Cluster`. `Namespaced` indicates that the KubeFed namespace will be the only target of the control plane.
        """
        pulumi.set(__self__, "scope", scope)
        if cluster_health_check is not None:
            pulumi.set(__self__, "cluster_health_check", cluster_health_check)
        if controller_duration is not None:
            pulumi.set(__self__, "controller_duration", controller_duration)
        if feature_gates is not None:
            pulumi.set(__self__, "feature_gates", feature_gates)
        if leader_elect is not None:
            pulumi.set(__self__, "leader_elect", leader_elect)
        if sync_controller is not None:
            pulumi.set(__self__, "sync_controller", sync_controller)

    @property
    @pulumi.getter
    def scope(self) -> str:
        """
        The scope of the KubeFed control plane should be either `Namespaced` or `Cluster`. `Namespaced` indicates that the KubeFed namespace will be the only target of the control plane.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter(name="clusterHealthCheck")
    def cluster_health_check(self) -> Optional['outputs.KubeFedConfigSpecClusterHealthCheck']:
        return pulumi.get(self, "cluster_health_check")

    @property
    @pulumi.getter(name="controllerDuration")
    def controller_duration(self) -> Optional['outputs.KubeFedConfigSpecControllerDuration']:
        return pulumi.get(self, "controller_duration")

    @property
    @pulumi.getter(name="featureGates")
    def feature_gates(self) -> Optional[Sequence['outputs.KubeFedConfigSpecFeatureGates']]:
        return pulumi.get(self, "feature_gates")

    @property
    @pulumi.getter(name="leaderElect")
    def leader_elect(self) -> Optional['outputs.KubeFedConfigSpecLeaderElect']:
        return pulumi.get(self, "leader_elect")

    @property
    @pulumi.getter(name="syncController")
    def sync_controller(self) -> Optional['outputs.KubeFedConfigSpecSyncController']:
        return pulumi.get(self, "sync_controller")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KubeFedConfigSpecClusterHealthCheck(dict):
    def __init__(__self__, *,
                 failure_threshold: Optional[int] = None,
                 period: Optional[str] = None,
                 success_threshold: Optional[int] = None,
                 timeout: Optional[str] = None):
        """
        :param int failure_threshold: Minimum consecutive failures for the cluster health to be considered failed after having succeeded.
        :param str period: How often to monitor the cluster health.
        :param int success_threshold: Minimum consecutive successes for the cluster health to be considered successful after having failed.
        :param str timeout: Duration after which the cluster health check times out.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the cluster health to be considered failed after having succeeded.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter
    def period(self) -> Optional[str]:
        """
        How often to monitor the cluster health.
        """
        return pulumi.get(self, "period")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the cluster health to be considered successful after having failed.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[str]:
        """
        Duration after which the cluster health check times out.
        """
        return pulumi.get(self, "timeout")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KubeFedConfigSpecControllerDuration(dict):
    def __init__(__self__, *,
                 available_delay: Optional[str] = None,
                 unavailable_delay: Optional[str] = None):
        """
        :param str available_delay: Time to wait before reconciling on a healthy cluster.
        :param str unavailable_delay: Time to wait before giving up on an unhealthy cluster.
        """
        if available_delay is not None:
            pulumi.set(__self__, "available_delay", available_delay)
        if unavailable_delay is not None:
            pulumi.set(__self__, "unavailable_delay", unavailable_delay)

    @property
    @pulumi.getter(name="availableDelay")
    def available_delay(self) -> Optional[str]:
        """
        Time to wait before reconciling on a healthy cluster.
        """
        return pulumi.get(self, "available_delay")

    @property
    @pulumi.getter(name="unavailableDelay")
    def unavailable_delay(self) -> Optional[str]:
        """
        Time to wait before giving up on an unhealthy cluster.
        """
        return pulumi.get(self, "unavailable_delay")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KubeFedConfigSpecFeatureGates(dict):
    def __init__(__self__, *,
                 configuration: str,
                 name: str):
        pulumi.set(__self__, "configuration", configuration)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def configuration(self) -> str:
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KubeFedConfigSpecLeaderElect(dict):
    def __init__(__self__, *,
                 lease_duration: Optional[str] = None,
                 renew_deadline: Optional[str] = None,
                 resource_lock: Optional[str] = None,
                 retry_period: Optional[str] = None):
        """
        :param str lease_duration: The duration that non-leader candidates will wait after observing a leadership renewal until attempting to acquire leadership of a led but unrenewed leader slot. This is effectively the maximum duration that a leader can be stopped before it is replaced by another candidate. This is only applicable if leader election is enabled.
        :param str renew_deadline: The interval between attempts by the acting master to renew a leadership slot before it stops leading. This must be less than or equal to the lease duration. This is only applicable if leader election is enabled.
        :param str resource_lock: The type of resource object that is used for locking during leader election. Supported options are `configmaps` (default) and `endpoints`.
        :param str retry_period: The duration the clients should wait between attempting acquisition and renewal of a leadership. This is only applicable if leader election is enabled.
        """
        if lease_duration is not None:
            pulumi.set(__self__, "lease_duration", lease_duration)
        if renew_deadline is not None:
            pulumi.set(__self__, "renew_deadline", renew_deadline)
        if resource_lock is not None:
            pulumi.set(__self__, "resource_lock", resource_lock)
        if retry_period is not None:
            pulumi.set(__self__, "retry_period", retry_period)

    @property
    @pulumi.getter(name="leaseDuration")
    def lease_duration(self) -> Optional[str]:
        """
        The duration that non-leader candidates will wait after observing a leadership renewal until attempting to acquire leadership of a led but unrenewed leader slot. This is effectively the maximum duration that a leader can be stopped before it is replaced by another candidate. This is only applicable if leader election is enabled.
        """
        return pulumi.get(self, "lease_duration")

    @property
    @pulumi.getter(name="renewDeadline")
    def renew_deadline(self) -> Optional[str]:
        """
        The interval between attempts by the acting master to renew a leadership slot before it stops leading. This must be less than or equal to the lease duration. This is only applicable if leader election is enabled.
        """
        return pulumi.get(self, "renew_deadline")

    @property
    @pulumi.getter(name="resourceLock")
    def resource_lock(self) -> Optional[str]:
        """
        The type of resource object that is used for locking during leader election. Supported options are `configmaps` (default) and `endpoints`.
        """
        return pulumi.get(self, "resource_lock")

    @property
    @pulumi.getter(name="retryPeriod")
    def retry_period(self) -> Optional[str]:
        """
        The duration the clients should wait between attempting acquisition and renewal of a leadership. This is only applicable if leader election is enabled.
        """
        return pulumi.get(self, "retry_period")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KubeFedConfigSpecSyncController(dict):
    def __init__(__self__, *,
                 adopt_resources: Optional[str] = None):
        """
        :param str adopt_resources: Whether to adopt pre-existing resources in member clusters. Defaults to "Enabled".
        """
        if adopt_resources is not None:
            pulumi.set(__self__, "adopt_resources", adopt_resources)

    @property
    @pulumi.getter(name="adoptResources")
    def adopt_resources(self) -> Optional[str]:
        """
        Whether to adopt pre-existing resources in member clusters. Defaults to "Enabled".
        """
        return pulumi.get(self, "adopt_resources")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


