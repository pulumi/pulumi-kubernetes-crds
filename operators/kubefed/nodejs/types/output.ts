// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

import {ObjectMeta} from "../meta/v1";

export namespace core {
    export namespace v1alpha1 {
        export interface ClusterPropagatedVersionStatus {
            /**
             * The last versions produced in each cluster for this resource.
             */
            clusterVersions?: outputs.core.v1alpha1.ClusterPropagatedVersionStatusClusterVersions[];
            /**
             * The observed version of the overrides for this resource.
             */
            overridesVersion: string;
            /**
             * The observed version of the template for this resource.
             */
            templateVersion: string;
        }

        export interface ClusterPropagatedVersionStatusClusterVersions {
            /**
             * The name of the cluster the version is for.
             */
            clusterName: string;
            /**
             * The last version produced for the resource by a KubeFed operation.
             */
            version: string;
        }

        export interface FederatedServiceStatusClusterStatus {
            clusterName: string;
            status: {[key: string]: any};
        }

        export interface PropagatedVersionStatus {
            /**
             * The last versions produced in each cluster for this resource.
             */
            clusterVersions?: outputs.core.v1alpha1.PropagatedVersionStatusClusterVersions[];
            /**
             * The observed version of the overrides for this resource.
             */
            overridesVersion: string;
            /**
             * The observed version of the template for this resource.
             */
            templateVersion: string;
        }

        export interface PropagatedVersionStatusClusterVersions {
            /**
             * The name of the cluster the version is for.
             */
            clusterName: string;
            /**
             * The last version produced for the resource by a KubeFed operation.
             */
            version: string;
        }
    }

    export namespace v1beta1 {
        export interface FederatedTypeConfigSpec {
            /**
             * Configuration for the federated type that defines (via template, placement and overrides fields) how the target type should appear in multiple cluster.
             */
            federatedType: outputs.core.v1beta1.FederatedTypeConfigSpecFederatedType;
            /**
             * Whether or not propagation to member clusters should be enabled.
             */
            propagation: string;
            /**
             * Whether or not Status object should be populated.
             */
            statusCollection?: string;
            /**
             * Configuration for the status type that holds information about which type holds the status of the federated resource. If not provided, the group and version will default to those provided for the federated type api resource.
             */
            statusType?: outputs.core.v1beta1.FederatedTypeConfigSpecStatusType;
            /**
             * The configuration of the target type. If not set, the pluralName and groupName fields will be set from the metadata.name of this resource. The kind field must be set.
             */
            targetType: outputs.core.v1beta1.FederatedTypeConfigSpecTargetType;
        }

        /**
         * Configuration for the federated type that defines (via template, placement and overrides fields) how the target type should appear in multiple cluster.
         */
        export interface FederatedTypeConfigSpecFederatedType {
            /**
             * Group of the resource.
             */
            group?: string;
            /**
             * Camel-cased singular name of the resource (e.g. ConfigMap)
             */
            kind: string;
            /**
             * Lower-cased plural name of the resource (e.g. configmaps).  If not provided, it will be computed by lower-casing the kind and suffixing an 's'.
             */
            pluralName: string;
            /**
             * Scope of the resource.
             */
            scope: string;
            /**
             * Version of the resource.
             */
            version: string;
        }

        /**
         * Configuration for the status type that holds information about which type holds the status of the federated resource. If not provided, the group and version will default to those provided for the federated type api resource.
         */
        export interface FederatedTypeConfigSpecStatusType {
            /**
             * Group of the resource.
             */
            group?: string;
            /**
             * Camel-cased singular name of the resource (e.g. ConfigMap)
             */
            kind: string;
            /**
             * Lower-cased plural name of the resource (e.g. configmaps).  If not provided, it will be computed by lower-casing the kind and suffixing an 's'.
             */
            pluralName: string;
            /**
             * Scope of the resource.
             */
            scope: string;
            /**
             * Version of the resource.
             */
            version: string;
        }

        /**
         * The configuration of the target type. If not set, the pluralName and groupName fields will be set from the metadata.name of this resource. The kind field must be set.
         */
        export interface FederatedTypeConfigSpecTargetType {
            /**
             * Group of the resource.
             */
            group?: string;
            /**
             * Camel-cased singular name of the resource (e.g. ConfigMap)
             */
            kind: string;
            /**
             * Lower-cased plural name of the resource (e.g. configmaps).  If not provided, it will be computed by lower-casing the kind and suffixing an 's'.
             */
            pluralName: string;
            /**
             * Scope of the resource.
             */
            scope: string;
            /**
             * Version of the resource.
             */
            version: string;
        }

        export interface FederatedTypeConfigStatus {
            /**
             * ObservedGeneration is the generation as observed by the controller consuming the FederatedTypeConfig.
             */
            observedGeneration: number;
            /**
             * PropagationController tracks the status of the sync controller.
             */
            propagationController: string;
            /**
             * StatusController tracks the status of the status controller.
             */
            statusController?: string;
        }

        export interface KubeFedClusterSpec {
            /**
             * The API endpoint of the member cluster. This can be a hostname, hostname:port, IP or IP:port.
             */
            apiEndpoint: string;
            /**
             * CABundle contains the certificate authority information.
             */
            caBundle?: string;
            /**
             * DisabledTLSValidations defines a list of checks to ignore when validating the TLS connection to the member cluster.  This can be any of *, SubjectName, or ValidityPeriod. If * is specified, it is expected to be the only option in list.
             */
            disabledTLSValidations?: string[];
            /**
             * Name of the secret containing the token required to access the member cluster. The secret needs to exist in the same namespace as the control plane and should have a "token" key.
             */
            secretRef: outputs.core.v1beta1.KubeFedClusterSpecSecretRef;
        }

        /**
         * Name of the secret containing the token required to access the member cluster. The secret needs to exist in the same namespace as the control plane and should have a "token" key.
         */
        export interface KubeFedClusterSpecSecretRef {
            /**
             * Name of a secret within the enclosing namespace
             */
            name: string;
        }

        export interface KubeFedClusterStatus {
            /**
             * Conditions is an array of current cluster conditions.
             */
            conditions: outputs.core.v1beta1.KubeFedClusterStatusConditions[];
            /**
             * Region is the name of the region in which all of the nodes in the cluster exist.  e.g. 'us-east1'.
             */
            region?: string;
            /**
             * Zones are the names of availability zones in which the nodes of the cluster exist, e.g. 'us-east1-a'.
             */
            zones?: string[];
        }

        export interface KubeFedClusterStatusConditions {
            /**
             * Last time the condition was checked.
             */
            lastProbeTime: string;
            /**
             * Last time the condition transit from one status to another.
             */
            lastTransitionTime?: string;
            /**
             * Human readable message indicating details about last transition.
             */
            message?: string;
            /**
             * (brief) reason for the condition's last transition.
             */
            reason?: string;
            /**
             * Status of the condition, one of True, False, Unknown.
             */
            status: string;
            /**
             * Type of cluster condition, Ready or Offline.
             */
            type: string;
        }

        export interface KubeFedConfigSpec {
            clusterHealthCheck?: outputs.core.v1beta1.KubeFedConfigSpecClusterHealthCheck;
            controllerDuration?: outputs.core.v1beta1.KubeFedConfigSpecControllerDuration;
            featureGates?: outputs.core.v1beta1.KubeFedConfigSpecFeatureGates[];
            leaderElect?: outputs.core.v1beta1.KubeFedConfigSpecLeaderElect;
            /**
             * The scope of the KubeFed control plane should be either `Namespaced` or `Cluster`. `Namespaced` indicates that the KubeFed namespace will be the only target of the control plane.
             */
            scope: string;
            syncController?: outputs.core.v1beta1.KubeFedConfigSpecSyncController;
        }

        export interface KubeFedConfigSpecClusterHealthCheck {
            /**
             * Minimum consecutive failures for the cluster health to be considered failed after having succeeded.
             */
            failureThreshold?: number;
            /**
             * How often to monitor the cluster health.
             */
            period?: string;
            /**
             * Minimum consecutive successes for the cluster health to be considered successful after having failed.
             */
            successThreshold?: number;
            /**
             * Duration after which the cluster health check times out.
             */
            timeout?: string;
        }

        export interface KubeFedConfigSpecControllerDuration {
            /**
             * Time to wait before reconciling on a healthy cluster.
             */
            availableDelay?: string;
            /**
             * Time to wait before giving up on an unhealthy cluster.
             */
            unavailableDelay?: string;
        }

        export interface KubeFedConfigSpecFeatureGates {
            configuration: string;
            name: string;
        }

        export interface KubeFedConfigSpecLeaderElect {
            /**
             * The duration that non-leader candidates will wait after observing a leadership renewal until attempting to acquire leadership of a led but unrenewed leader slot. This is effectively the maximum duration that a leader can be stopped before it is replaced by another candidate. This is only applicable if leader election is enabled.
             */
            leaseDuration?: string;
            /**
             * The interval between attempts by the acting master to renew a leadership slot before it stops leading. This must be less than or equal to the lease duration. This is only applicable if leader election is enabled.
             */
            renewDeadline?: string;
            /**
             * The type of resource object that is used for locking during leader election. Supported options are `configmaps` (default) and `endpoints`.
             */
            resourceLock?: string;
            /**
             * The duration the clients should wait between attempting acquisition and renewal of a leadership. This is only applicable if leader election is enabled.
             */
            retryPeriod?: string;
        }

        export interface KubeFedConfigSpecSyncController {
            /**
             * Whether to adopt pre-existing resources in member clusters. Defaults to "Enabled".
             */
            adoptResources?: string;
        }
    }
}

export namespace multiclusterdns {
    export namespace v1alpha1 {
        export interface DNSEndpointSpec {
            endpoints?: outputs.multiclusterdns.v1alpha1.DNSEndpointSpecEndpoints[];
        }

        export interface DNSEndpointSpecEndpoints {
            /**
             * The FQDN of the DNS record.
             */
            dnsName?: string;
            /**
             * Labels stores labels defined for the Endpoint.
             */
            labels?: {[key: string]: any};
            /**
             * TTL for the record in seconds.
             */
            recordTTL?: number;
            /**
             * RecordType type of record, e.g. CNAME, A, SRV, TXT etc.
             */
            recordType?: string;
            /**
             * The targets that the DNS record points to.
             */
            targets?: string[];
        }

        export interface DNSEndpointStatus {
            /**
             * ObservedGeneration is the generation as observed by the controller consuming the DNSEndpoint.
             */
            observedGeneration?: number;
        }

        export interface IngressDNSRecordSpec {
            /**
             * Host from the IngressRule in Cluster Ingress Spec
             */
            hosts?: string[];
            /**
             * RecordTTL is the TTL in seconds for DNS records created for the Ingress, if omitted a default would be used
             */
            recordTTL?: number;
        }

        export interface IngressDNSRecordStatus {
            /**
             * Array of Ingress Controller LoadBalancers
             */
            dns?: outputs.multiclusterdns.v1alpha1.IngressDNSRecordStatusDns[];
        }

        export interface IngressDNSRecordStatusDns {
            /**
             * Cluster name
             */
            cluster?: string;
            /**
             * LoadBalancer for the corresponding ingress controller
             */
            loadBalancer?: {[key: string]: any};
        }

        export interface ServiceDNSRecordSpec {
            /**
             * AllowServiceWithoutEndpoints allows DNS records to be written for Service shards without endpoints
             */
            allowServiceWithoutEndpoints?: boolean;
            /**
             * DNSPrefix when specified, an additional DNS record would be created with <DNSPrefix>.<KubeFedDomain>
             */
            dnsPrefix?: string;
            /**
             * DomainRef is the name of the domain object to which the corresponding federated service belongs
             */
            domainRef: string;
            /**
             * ExternalName when specified, replaces the service name portion of a resource record with the value of ExternalName.
             */
            externalName?: string;
            /**
             * RecordTTL is the TTL in seconds for DNS records created for this Service, if omitted a default would be used
             */
            recordTTL?: number;
        }

        export interface ServiceDNSRecordStatus {
            dns?: outputs.multiclusterdns.v1alpha1.ServiceDNSRecordStatusDns[];
            /**
             * Domain is the DNS domain of the KubeFed control plane as in Domain API
             */
            domain?: string;
        }

        export interface ServiceDNSRecordStatusDns {
            /**
             * Cluster name
             */
            cluster?: string;
            /**
             * LoadBalancer for the corresponding service
             */
            loadBalancer?: {[key: string]: any};
            /**
             * Region to which the cluster belongs
             */
            region?: string;
            /**
             * Zones to which the cluster belongs
             */
            zones?: string[];
        }

    }
}

export namespace operator {
    export namespace v1alpha1 {
        export interface KubeFedSpec {
            /**
             * The scope of the installed release
             */
            scope: string;
        }

        export interface KubeFedStatus {
            /**
             * The version of the installed release
             */
            version?: string;
        }

        export interface KubeFedWebHookSpec {
        }

        export interface KubeFedWebHookStatus {
            /**
             * The version of the installed release
             */
            version?: string;
        }
    }
}

export namespace scheduling {
    export namespace v1alpha1 {
        export interface ReplicaSchedulingPreferenceSpec {
            /**
             * A mapping between cluster names and preferences regarding a local workload object (dep, rs, .. ) in these clusters. "*" (if provided) applies to all clusters if an explicit mapping is not provided. If omitted, clusters without explicit preferences should not have any replicas scheduled.
             */
            clusters?: {[key: string]: any};
            /**
             * If set to true then already scheduled and running replicas may be moved to other clusters in order to match current state to the specified preferences. Otherwise, if set to false, up and running replicas will not be moved.
             */
            rebalance?: boolean;
            /**
             * TODO (@irfanurrehman); upgrade this to label selector only if need be. The idea of this API is to have a a set of preferences which can be used for a target FederatedDeployment or FederatedReplicaset. Although the set of preferences in question can be applied to multiple target objects using label selectors, but there are no clear advantages of doing that as of now. To keep the implementation and usage simple, matching ns/name of RSP resource to the target resource is sufficient and only additional information needed in RSP resource is a target kind (FederatedDeployment or FederatedReplicaset).
             */
            targetKind: string;
            /**
             * Total number of pods desired across federated clusters. Replicas specified in the spec for target deployment template or replicaset template will be discarded/overridden when scheduling preferences are specified.
             */
            totalReplicas: number;
        }

    }
}
