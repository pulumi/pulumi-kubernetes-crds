# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from ... import _utilities, _tables
from . import outputs

__all__ = [
    'GroupConfigSpec',
    'GroupConfigSpecAnnotationSelector',
    'GroupConfigSpecAnnotationSelectorMatchExpressions',
    'GroupConfigSpecLabelSelector',
    'GroupConfigSpecLabelSelectorMatchExpressions',
    'GroupConfigSpecTemplates',
    'GroupConfigStatus',
    'GroupConfigStatusConditions',
    'GroupConfigStatusLockedResourceStatuses',
    'NamespaceConfigSpec',
    'NamespaceConfigSpecAnnotationSelector',
    'NamespaceConfigSpecAnnotationSelectorMatchExpressions',
    'NamespaceConfigSpecLabelSelector',
    'NamespaceConfigSpecLabelSelectorMatchExpressions',
    'NamespaceConfigSpecTemplates',
    'NamespaceConfigStatus',
    'NamespaceConfigStatusConditions',
    'NamespaceConfigStatusLockedResourceStatuses',
    'UserConfigSpec',
    'UserConfigSpecAnnotationSelector',
    'UserConfigSpecAnnotationSelectorMatchExpressions',
    'UserConfigSpecIdentityExtraFieldSelector',
    'UserConfigSpecIdentityExtraFieldSelectorMatchExpressions',
    'UserConfigSpecLabelSelector',
    'UserConfigSpecLabelSelectorMatchExpressions',
    'UserConfigSpecTemplates',
    'UserConfigStatus',
    'UserConfigStatusConditions',
    'UserConfigStatusLockedResourceStatuses',
]

@pulumi.output_type
class GroupConfigSpec(dict):
    """
    GroupConfigSpec defines the desired state of GroupConfig There are two selectors: "labelSelector", "annotationSelector". Selectors are considered in AND, so if multiple are defined they must all be true for a Group to be selected.
    """
    def __init__(__self__, *,
                 annotation_selector: Optional['outputs.GroupConfigSpecAnnotationSelector'] = None,
                 label_selector: Optional['outputs.GroupConfigSpecLabelSelector'] = None,
                 templates: Optional[Sequence['outputs.GroupConfigSpecTemplates']] = None):
        """
        GroupConfigSpec defines the desired state of GroupConfig There are two selectors: "labelSelector", "annotationSelector". Selectors are considered in AND, so if multiple are defined they must all be true for a Group to be selected.
        :param 'GroupConfigSpecAnnotationSelectorArgs' annotation_selector: AnnotationSelector selects Groups by annotation.
        :param 'GroupConfigSpecLabelSelectorArgs' label_selector: LabelSelector selects Groups by label.
        """
        if annotation_selector is not None:
            pulumi.set(__self__, "annotation_selector", annotation_selector)
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if templates is not None:
            pulumi.set(__self__, "templates", templates)

    @property
    @pulumi.getter(name="annotationSelector")
    def annotation_selector(self) -> Optional['outputs.GroupConfigSpecAnnotationSelector']:
        """
        AnnotationSelector selects Groups by annotation.
        """
        return pulumi.get(self, "annotation_selector")

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.GroupConfigSpecLabelSelector']:
        """
        LabelSelector selects Groups by label.
        """
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def templates(self) -> Optional[Sequence['outputs.GroupConfigSpecTemplates']]:
        return pulumi.get(self, "templates")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GroupConfigSpecAnnotationSelector(dict):
    """
    AnnotationSelector selects Groups by annotation.
    """
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.GroupConfigSpecAnnotationSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        AnnotationSelector selects Groups by annotation.
        :param Sequence['GroupConfigSpecAnnotationSelectorMatchExpressionsArgs'] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.GroupConfigSpecAnnotationSelectorMatchExpressions']]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GroupConfigSpecAnnotationSelectorMatchExpressions(dict):
    """
    A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
    """
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Optional[Sequence[str]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param str key: key is the label key that the selector applies to.
        :param str operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param Sequence[str] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GroupConfigSpecLabelSelector(dict):
    """
    LabelSelector selects Groups by label.
    """
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.GroupConfigSpecLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        LabelSelector selects Groups by label.
        :param Sequence['GroupConfigSpecLabelSelectorMatchExpressionsArgs'] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.GroupConfigSpecLabelSelectorMatchExpressions']]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GroupConfigSpecLabelSelectorMatchExpressions(dict):
    """
    A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
    """
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Optional[Sequence[str]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param str key: key is the label key that the selector applies to.
        :param str operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param Sequence[str] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GroupConfigSpecTemplates(dict):
    """
    LockedResourceTemplate represents a resource template in go language to be enforced in a LockedResourceController and can be used in a API specification
    """
    def __init__(__self__, *,
                 object_template: str,
                 excluded_paths: Optional[Sequence[str]] = None):
        """
        LockedResourceTemplate represents a resource template in go language to be enforced in a LockedResourceController and can be used in a API specification
        :param str object_template: ObjectTemplate is a goland template. Whne processed, it must resolve to a yaml representation of an API resource
        :param Sequence[str] excluded_paths: ExludedPaths are a set of json paths that need not be considered by the LockedResourceReconciler
        """
        pulumi.set(__self__, "object_template", object_template)
        if excluded_paths is not None:
            pulumi.set(__self__, "excluded_paths", excluded_paths)

    @property
    @pulumi.getter(name="objectTemplate")
    def object_template(self) -> str:
        """
        ObjectTemplate is a goland template. Whne processed, it must resolve to a yaml representation of an API resource
        """
        return pulumi.get(self, "object_template")

    @property
    @pulumi.getter(name="excludedPaths")
    def excluded_paths(self) -> Optional[Sequence[str]]:
        """
        ExludedPaths are a set of json paths that need not be considered by the LockedResourceReconciler
        """
        return pulumi.get(self, "excluded_paths")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GroupConfigStatus(dict):
    """
    GroupConfigStatus defines the observed state of GroupConfig
    """
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.GroupConfigStatusConditions']] = None,
                 locked_resource_statuses: Optional[Mapping[str, Sequence['outputs.GroupConfigStatusLockedResourceStatuses']]] = None):
        """
        GroupConfigStatus defines the observed state of GroupConfig
        :param Sequence['GroupConfigStatusConditionsArgs'] conditions: ReconcileStatus this is the general status of the main reconciler
        :param Mapping[str, Sequence['GroupConfigStatusLockedResourceStatusesArgs']] locked_resource_statuses: LockedResourceStatuses contains the reconcile status for each of the managed resources
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if locked_resource_statuses is not None:
            pulumi.set(__self__, "locked_resource_statuses", locked_resource_statuses)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.GroupConfigStatusConditions']]:
        """
        ReconcileStatus this is the general status of the main reconciler
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="lockedResourceStatuses")
    def locked_resource_statuses(self) -> Optional[Mapping[str, Sequence['outputs.GroupConfigStatusLockedResourceStatuses']]]:
        """
        LockedResourceStatuses contains the reconcile status for each of the managed resources
        """
        return pulumi.get(self, "locked_resource_statuses")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GroupConfigStatusConditions(dict):
    """
    Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
     Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
    """
    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None):
        """
        Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
         Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
        :param str type: ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
                Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        :param str reason: ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
         Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        return pulumi.get(self, "reason")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GroupConfigStatusLockedResourceStatuses(dict):
    """
    Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
     Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
    """
    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None):
        """
        Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
         Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
        :param str type: ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
                Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        :param str reason: ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
         Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        return pulumi.get(self, "reason")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class NamespaceConfigSpec(dict):
    """
    NamespaceConfigSpec defines the desired state of NamespaceConfig There are two selectors: "labelSelector", "annotationSelector". Selectors are considered in AND, so if multiple are defined they must all be true for a Namespace to be selected.
    """
    def __init__(__self__, *,
                 annotation_selector: Optional['outputs.NamespaceConfigSpecAnnotationSelector'] = None,
                 label_selector: Optional['outputs.NamespaceConfigSpecLabelSelector'] = None,
                 templates: Optional[Sequence['outputs.NamespaceConfigSpecTemplates']] = None):
        """
        NamespaceConfigSpec defines the desired state of NamespaceConfig There are two selectors: "labelSelector", "annotationSelector". Selectors are considered in AND, so if multiple are defined they must all be true for a Namespace to be selected.
        :param 'NamespaceConfigSpecAnnotationSelectorArgs' annotation_selector: AnnotationSelector selects Namespaces by annotation.
        :param 'NamespaceConfigSpecLabelSelectorArgs' label_selector: LabelSelector selects Namespaces by label.
        """
        if annotation_selector is not None:
            pulumi.set(__self__, "annotation_selector", annotation_selector)
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if templates is not None:
            pulumi.set(__self__, "templates", templates)

    @property
    @pulumi.getter(name="annotationSelector")
    def annotation_selector(self) -> Optional['outputs.NamespaceConfigSpecAnnotationSelector']:
        """
        AnnotationSelector selects Namespaces by annotation.
        """
        return pulumi.get(self, "annotation_selector")

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.NamespaceConfigSpecLabelSelector']:
        """
        LabelSelector selects Namespaces by label.
        """
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def templates(self) -> Optional[Sequence['outputs.NamespaceConfigSpecTemplates']]:
        return pulumi.get(self, "templates")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class NamespaceConfigSpecAnnotationSelector(dict):
    """
    AnnotationSelector selects Namespaces by annotation.
    """
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.NamespaceConfigSpecAnnotationSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        AnnotationSelector selects Namespaces by annotation.
        :param Sequence['NamespaceConfigSpecAnnotationSelectorMatchExpressionsArgs'] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.NamespaceConfigSpecAnnotationSelectorMatchExpressions']]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class NamespaceConfigSpecAnnotationSelectorMatchExpressions(dict):
    """
    A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
    """
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Optional[Sequence[str]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param str key: key is the label key that the selector applies to.
        :param str operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param Sequence[str] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class NamespaceConfigSpecLabelSelector(dict):
    """
    LabelSelector selects Namespaces by label.
    """
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.NamespaceConfigSpecLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        LabelSelector selects Namespaces by label.
        :param Sequence['NamespaceConfigSpecLabelSelectorMatchExpressionsArgs'] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.NamespaceConfigSpecLabelSelectorMatchExpressions']]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class NamespaceConfigSpecLabelSelectorMatchExpressions(dict):
    """
    A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
    """
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Optional[Sequence[str]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param str key: key is the label key that the selector applies to.
        :param str operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param Sequence[str] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class NamespaceConfigSpecTemplates(dict):
    """
    LockedResourceTemplate represents a resource template in go language to be enforced in a LockedResourceController and can be used in a API specification
    """
    def __init__(__self__, *,
                 object_template: str,
                 excluded_paths: Optional[Sequence[str]] = None):
        """
        LockedResourceTemplate represents a resource template in go language to be enforced in a LockedResourceController and can be used in a API specification
        :param str object_template: ObjectTemplate is a goland template. Whne processed, it must resolve to a yaml representation of an API resource
        :param Sequence[str] excluded_paths: ExludedPaths are a set of json paths that need not be considered by the LockedResourceReconciler
        """
        pulumi.set(__self__, "object_template", object_template)
        if excluded_paths is not None:
            pulumi.set(__self__, "excluded_paths", excluded_paths)

    @property
    @pulumi.getter(name="objectTemplate")
    def object_template(self) -> str:
        """
        ObjectTemplate is a goland template. Whne processed, it must resolve to a yaml representation of an API resource
        """
        return pulumi.get(self, "object_template")

    @property
    @pulumi.getter(name="excludedPaths")
    def excluded_paths(self) -> Optional[Sequence[str]]:
        """
        ExludedPaths are a set of json paths that need not be considered by the LockedResourceReconciler
        """
        return pulumi.get(self, "excluded_paths")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class NamespaceConfigStatus(dict):
    """
    NamespaceConfigStatus defines the observed state of NSConfig
    """
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.NamespaceConfigStatusConditions']] = None,
                 locked_resource_statuses: Optional[Mapping[str, Sequence['outputs.NamespaceConfigStatusLockedResourceStatuses']]] = None):
        """
        NamespaceConfigStatus defines the observed state of NSConfig
        :param Sequence['NamespaceConfigStatusConditionsArgs'] conditions: ReconcileStatus this is the general status of the main reconciler
        :param Mapping[str, Sequence['NamespaceConfigStatusLockedResourceStatusesArgs']] locked_resource_statuses: LockedResourceStatuses contains the reconcile status for each of the managed resources
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if locked_resource_statuses is not None:
            pulumi.set(__self__, "locked_resource_statuses", locked_resource_statuses)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.NamespaceConfigStatusConditions']]:
        """
        ReconcileStatus this is the general status of the main reconciler
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="lockedResourceStatuses")
    def locked_resource_statuses(self) -> Optional[Mapping[str, Sequence['outputs.NamespaceConfigStatusLockedResourceStatuses']]]:
        """
        LockedResourceStatuses contains the reconcile status for each of the managed resources
        """
        return pulumi.get(self, "locked_resource_statuses")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class NamespaceConfigStatusConditions(dict):
    """
    Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
     Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
    """
    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None):
        """
        Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
         Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
        :param str type: ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
                Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        :param str reason: ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
         Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        return pulumi.get(self, "reason")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class NamespaceConfigStatusLockedResourceStatuses(dict):
    """
    Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
     Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
    """
    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None):
        """
        Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
         Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
        :param str type: ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
                Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        :param str reason: ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
         Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        return pulumi.get(self, "reason")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class UserConfigSpec(dict):
    """
    UserConfigSpec defines the desired state of UserConfig There are four selectors: "labelSelector", "annotationSelector", "identityExtraFieldSelector" and "providerName". labelSelector and annoationSelector are matches against the User object identityExtraFieldSelector and providerName are matched against any of the Identities associated with User Selectors are considered in AND, so if multiple are defined tthey must all be true for a User to be selected.
    """
    def __init__(__self__, *,
                 annotation_selector: Optional['outputs.UserConfigSpecAnnotationSelector'] = None,
                 identity_extra_field_selector: Optional['outputs.UserConfigSpecIdentityExtraFieldSelector'] = None,
                 label_selector: Optional['outputs.UserConfigSpecLabelSelector'] = None,
                 provider_name: Optional[str] = None,
                 templates: Optional[Sequence['outputs.UserConfigSpecTemplates']] = None):
        """
        UserConfigSpec defines the desired state of UserConfig There are four selectors: "labelSelector", "annotationSelector", "identityExtraFieldSelector" and "providerName". labelSelector and annoationSelector are matches against the User object identityExtraFieldSelector and providerName are matched against any of the Identities associated with User Selectors are considered in AND, so if multiple are defined tthey must all be true for a User to be selected.
        :param 'UserConfigSpecAnnotationSelectorArgs' annotation_selector: AnnotationSelector selects Users by annotation.
        :param 'UserConfigSpecIdentityExtraFieldSelectorArgs' identity_extra_field_selector: IdentityExtraSelector allows you to specify a selector for the extra fields of the User's idenitities. If one of the user identities matches the selector the User is selected This condition is in OR with ProviderName
        :param 'UserConfigSpecLabelSelectorArgs' label_selector: LabelSelector selects Users by label.
        :param str provider_name: ProviderName allows you to specify an idenitity provider. If a user logged in with that provider it is selected. This condition is in OR with IdentityExtraSelector
        """
        if annotation_selector is not None:
            pulumi.set(__self__, "annotation_selector", annotation_selector)
        if identity_extra_field_selector is not None:
            pulumi.set(__self__, "identity_extra_field_selector", identity_extra_field_selector)
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if provider_name is not None:
            pulumi.set(__self__, "provider_name", provider_name)
        if templates is not None:
            pulumi.set(__self__, "templates", templates)

    @property
    @pulumi.getter(name="annotationSelector")
    def annotation_selector(self) -> Optional['outputs.UserConfigSpecAnnotationSelector']:
        """
        AnnotationSelector selects Users by annotation.
        """
        return pulumi.get(self, "annotation_selector")

    @property
    @pulumi.getter(name="identityExtraFieldSelector")
    def identity_extra_field_selector(self) -> Optional['outputs.UserConfigSpecIdentityExtraFieldSelector']:
        """
        IdentityExtraSelector allows you to specify a selector for the extra fields of the User's idenitities. If one of the user identities matches the selector the User is selected This condition is in OR with ProviderName
        """
        return pulumi.get(self, "identity_extra_field_selector")

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.UserConfigSpecLabelSelector']:
        """
        LabelSelector selects Users by label.
        """
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> Optional[str]:
        """
        ProviderName allows you to specify an idenitity provider. If a user logged in with that provider it is selected. This condition is in OR with IdentityExtraSelector
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter
    def templates(self) -> Optional[Sequence['outputs.UserConfigSpecTemplates']]:
        return pulumi.get(self, "templates")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class UserConfigSpecAnnotationSelector(dict):
    """
    AnnotationSelector selects Users by annotation.
    """
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.UserConfigSpecAnnotationSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        AnnotationSelector selects Users by annotation.
        :param Sequence['UserConfigSpecAnnotationSelectorMatchExpressionsArgs'] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.UserConfigSpecAnnotationSelectorMatchExpressions']]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class UserConfigSpecAnnotationSelectorMatchExpressions(dict):
    """
    A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
    """
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Optional[Sequence[str]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param str key: key is the label key that the selector applies to.
        :param str operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param Sequence[str] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class UserConfigSpecIdentityExtraFieldSelector(dict):
    """
    IdentityExtraSelector allows you to specify a selector for the extra fields of the User's idenitities. If one of the user identities matches the selector the User is selected This condition is in OR with ProviderName
    """
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.UserConfigSpecIdentityExtraFieldSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        IdentityExtraSelector allows you to specify a selector for the extra fields of the User's idenitities. If one of the user identities matches the selector the User is selected This condition is in OR with ProviderName
        :param Sequence['UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsArgs'] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.UserConfigSpecIdentityExtraFieldSelectorMatchExpressions']]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class UserConfigSpecIdentityExtraFieldSelectorMatchExpressions(dict):
    """
    A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
    """
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Optional[Sequence[str]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param str key: key is the label key that the selector applies to.
        :param str operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param Sequence[str] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class UserConfigSpecLabelSelector(dict):
    """
    LabelSelector selects Users by label.
    """
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.UserConfigSpecLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        LabelSelector selects Users by label.
        :param Sequence['UserConfigSpecLabelSelectorMatchExpressionsArgs'] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.UserConfigSpecLabelSelectorMatchExpressions']]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class UserConfigSpecLabelSelectorMatchExpressions(dict):
    """
    A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
    """
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Optional[Sequence[str]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param str key: key is the label key that the selector applies to.
        :param str operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param Sequence[str] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class UserConfigSpecTemplates(dict):
    """
    LockedResourceTemplate represents a resource template in go language to be enforced in a LockedResourceController and can be used in a API specification
    """
    def __init__(__self__, *,
                 object_template: str,
                 excluded_paths: Optional[Sequence[str]] = None):
        """
        LockedResourceTemplate represents a resource template in go language to be enforced in a LockedResourceController and can be used in a API specification
        :param str object_template: ObjectTemplate is a goland template. Whne processed, it must resolve to a yaml representation of an API resource
        :param Sequence[str] excluded_paths: ExludedPaths are a set of json paths that need not be considered by the LockedResourceReconciler
        """
        pulumi.set(__self__, "object_template", object_template)
        if excluded_paths is not None:
            pulumi.set(__self__, "excluded_paths", excluded_paths)

    @property
    @pulumi.getter(name="objectTemplate")
    def object_template(self) -> str:
        """
        ObjectTemplate is a goland template. Whne processed, it must resolve to a yaml representation of an API resource
        """
        return pulumi.get(self, "object_template")

    @property
    @pulumi.getter(name="excludedPaths")
    def excluded_paths(self) -> Optional[Sequence[str]]:
        """
        ExludedPaths are a set of json paths that need not be considered by the LockedResourceReconciler
        """
        return pulumi.get(self, "excluded_paths")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class UserConfigStatus(dict):
    """
    UserConfigStatus defines the observed state of UserConfig
    """
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.UserConfigStatusConditions']] = None,
                 locked_resource_statuses: Optional[Mapping[str, Sequence['outputs.UserConfigStatusLockedResourceStatuses']]] = None):
        """
        UserConfigStatus defines the observed state of UserConfig
        :param Sequence['UserConfigStatusConditionsArgs'] conditions: ReconcileStatus this is the general status of the main reconciler
        :param Mapping[str, Sequence['UserConfigStatusLockedResourceStatusesArgs']] locked_resource_statuses: LockedResourceStatuses contains the reconcile status for each of the managed resources
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if locked_resource_statuses is not None:
            pulumi.set(__self__, "locked_resource_statuses", locked_resource_statuses)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.UserConfigStatusConditions']]:
        """
        ReconcileStatus this is the general status of the main reconciler
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="lockedResourceStatuses")
    def locked_resource_statuses(self) -> Optional[Mapping[str, Sequence['outputs.UserConfigStatusLockedResourceStatuses']]]:
        """
        LockedResourceStatuses contains the reconcile status for each of the managed resources
        """
        return pulumi.get(self, "locked_resource_statuses")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class UserConfigStatusConditions(dict):
    """
    Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
     Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
    """
    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None):
        """
        Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
         Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
        :param str type: ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
                Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        :param str reason: ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
         Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        return pulumi.get(self, "reason")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class UserConfigStatusLockedResourceStatuses(dict):
    """
    Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
     Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
    """
    def __init__(__self__, *,
                 status: str,
                 type: str,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None):
        """
        Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
         Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
        :param str type: ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
                Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        :param str reason: ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
         Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        return pulumi.get(self, "reason")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


