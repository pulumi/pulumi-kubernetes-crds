// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

import {ObjectMeta} from "../meta/v1";

export namespace redhatcop {
    export namespace v1alpha1 {
        /**
         * GroupConfigSpec defines the desired state of GroupConfig There are two selectors: "labelSelector", "annotationSelector". Selectors are considered in AND, so if multiple are defined they must all be true for a Group to be selected.
         */
        export interface GroupConfigSpec {
            /**
             * AnnotationSelector selects Groups by annotation.
             */
            annotationSelector?: outputs.redhatcop.v1alpha1.GroupConfigSpecAnnotationSelector;
            /**
             * LabelSelector selects Groups by label.
             */
            labelSelector?: outputs.redhatcop.v1alpha1.GroupConfigSpecLabelSelector;
            templates?: outputs.redhatcop.v1alpha1.GroupConfigSpecTemplates[];
        }

        /**
         * AnnotationSelector selects Groups by annotation.
         */
        export interface GroupConfigSpecAnnotationSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.redhatcop.v1alpha1.GroupConfigSpecAnnotationSelectorMatchExpressions[];
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: {[key: string]: string};
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
         */
        export interface GroupConfigSpecAnnotationSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string;
            /**
             * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string;
            /**
             * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
             */
            values?: string[];
        }

        /**
         * LabelSelector selects Groups by label.
         */
        export interface GroupConfigSpecLabelSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.redhatcop.v1alpha1.GroupConfigSpecLabelSelectorMatchExpressions[];
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: {[key: string]: string};
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
         */
        export interface GroupConfigSpecLabelSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string;
            /**
             * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string;
            /**
             * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
             */
            values?: string[];
        }

        /**
         * LockedResourceTemplate represents a resource template in go language to be enforced in a LockedResourceController and can be used in a API specification
         */
        export interface GroupConfigSpecTemplates {
            /**
             * ExludedPaths are a set of json paths that need not be considered by the LockedResourceReconciler
             */
            excludedPaths?: string[];
            /**
             * ObjectTemplate is a goland template. Whne processed, it must resolve to a yaml representation of an API resource
             */
            objectTemplate: string;
        }

        /**
         * GroupConfigStatus defines the observed state of GroupConfig
         */
        export interface GroupConfigStatus {
            /**
             * ReconcileStatus this is the general status of the main reconciler
             */
            conditions?: outputs.redhatcop.v1alpha1.GroupConfigStatusConditions[];
            /**
             * LockedResourceStatuses contains the reconcile status for each of the managed resources
             */
            lockedResourceStatuses?: {[key: string]: outputs.redhatcop.v1alpha1.GroupConfigStatusLockedResourceStatuses[]};
        }

        /**
         * Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
         *  Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
         */
        export interface GroupConfigStatusConditions {
            lastTransitionTime?: string;
            message?: string;
            /**
             * ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
             */
            reason?: string;
            status: string;
            /**
             * ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
             *  Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
             */
            type: string;
        }

        /**
         * Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
         *  Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
         */
        export interface GroupConfigStatusLockedResourceStatuses {
            lastTransitionTime?: string;
            message?: string;
            /**
             * ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
             */
            reason?: string;
            status: string;
            /**
             * ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
             *  Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
             */
            type: string;
        }

        /**
         * NamespaceConfigSpec defines the desired state of NamespaceConfig There are two selectors: "labelSelector", "annotationSelector". Selectors are considered in AND, so if multiple are defined they must all be true for a Namespace to be selected.
         */
        export interface NamespaceConfigSpec {
            /**
             * AnnotationSelector selects Namespaces by annotation.
             */
            annotationSelector?: outputs.redhatcop.v1alpha1.NamespaceConfigSpecAnnotationSelector;
            /**
             * LabelSelector selects Namespaces by label.
             */
            labelSelector?: outputs.redhatcop.v1alpha1.NamespaceConfigSpecLabelSelector;
            templates?: outputs.redhatcop.v1alpha1.NamespaceConfigSpecTemplates[];
        }

        /**
         * AnnotationSelector selects Namespaces by annotation.
         */
        export interface NamespaceConfigSpecAnnotationSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.redhatcop.v1alpha1.NamespaceConfigSpecAnnotationSelectorMatchExpressions[];
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: {[key: string]: string};
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
         */
        export interface NamespaceConfigSpecAnnotationSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string;
            /**
             * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string;
            /**
             * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
             */
            values?: string[];
        }

        /**
         * LabelSelector selects Namespaces by label.
         */
        export interface NamespaceConfigSpecLabelSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.redhatcop.v1alpha1.NamespaceConfigSpecLabelSelectorMatchExpressions[];
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: {[key: string]: string};
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
         */
        export interface NamespaceConfigSpecLabelSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string;
            /**
             * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string;
            /**
             * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
             */
            values?: string[];
        }

        /**
         * LockedResourceTemplate represents a resource template in go language to be enforced in a LockedResourceController and can be used in a API specification
         */
        export interface NamespaceConfigSpecTemplates {
            /**
             * ExludedPaths are a set of json paths that need not be considered by the LockedResourceReconciler
             */
            excludedPaths?: string[];
            /**
             * ObjectTemplate is a goland template. Whne processed, it must resolve to a yaml representation of an API resource
             */
            objectTemplate: string;
        }

        /**
         * NamespaceConfigStatus defines the observed state of NSConfig
         */
        export interface NamespaceConfigStatus {
            /**
             * ReconcileStatus this is the general status of the main reconciler
             */
            conditions?: outputs.redhatcop.v1alpha1.NamespaceConfigStatusConditions[];
            /**
             * LockedResourceStatuses contains the reconcile status for each of the managed resources
             */
            lockedResourceStatuses?: {[key: string]: outputs.redhatcop.v1alpha1.NamespaceConfigStatusLockedResourceStatuses[]};
        }

        /**
         * Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
         *  Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
         */
        export interface NamespaceConfigStatusConditions {
            lastTransitionTime?: string;
            message?: string;
            /**
             * ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
             */
            reason?: string;
            status: string;
            /**
             * ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
             *  Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
             */
            type: string;
        }

        /**
         * Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
         *  Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
         */
        export interface NamespaceConfigStatusLockedResourceStatuses {
            lastTransitionTime?: string;
            message?: string;
            /**
             * ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
             */
            reason?: string;
            status: string;
            /**
             * ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
             *  Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
             */
            type: string;
        }

        /**
         * UserConfigSpec defines the desired state of UserConfig There are four selectors: "labelSelector", "annotationSelector", "identityExtraFieldSelector" and "providerName". labelSelector and annoationSelector are matches against the User object identityExtraFieldSelector and providerName are matched against any of the Identities associated with User Selectors are considered in AND, so if multiple are defined tthey must all be true for a User to be selected.
         */
        export interface UserConfigSpec {
            /**
             * AnnotationSelector selects Users by annotation.
             */
            annotationSelector?: outputs.redhatcop.v1alpha1.UserConfigSpecAnnotationSelector;
            /**
             * IdentityExtraSelector allows you to specify a selector for the extra fields of the User's idenitities. If one of the user identities matches the selector the User is selected This condition is in OR with ProviderName
             */
            identityExtraFieldSelector?: outputs.redhatcop.v1alpha1.UserConfigSpecIdentityExtraFieldSelector;
            /**
             * LabelSelector selects Users by label.
             */
            labelSelector?: outputs.redhatcop.v1alpha1.UserConfigSpecLabelSelector;
            /**
             * ProviderName allows you to specify an idenitity provider. If a user logged in with that provider it is selected. This condition is in OR with IdentityExtraSelector
             */
            providerName?: string;
            templates?: outputs.redhatcop.v1alpha1.UserConfigSpecTemplates[];
        }

        /**
         * AnnotationSelector selects Users by annotation.
         */
        export interface UserConfigSpecAnnotationSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.redhatcop.v1alpha1.UserConfigSpecAnnotationSelectorMatchExpressions[];
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: {[key: string]: string};
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
         */
        export interface UserConfigSpecAnnotationSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string;
            /**
             * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string;
            /**
             * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
             */
            values?: string[];
        }

        /**
         * IdentityExtraSelector allows you to specify a selector for the extra fields of the User's idenitities. If one of the user identities matches the selector the User is selected This condition is in OR with ProviderName
         */
        export interface UserConfigSpecIdentityExtraFieldSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.redhatcop.v1alpha1.UserConfigSpecIdentityExtraFieldSelectorMatchExpressions[];
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: {[key: string]: string};
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
         */
        export interface UserConfigSpecIdentityExtraFieldSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string;
            /**
             * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string;
            /**
             * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
             */
            values?: string[];
        }

        /**
         * LabelSelector selects Users by label.
         */
        export interface UserConfigSpecLabelSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.redhatcop.v1alpha1.UserConfigSpecLabelSelectorMatchExpressions[];
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: {[key: string]: string};
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
         */
        export interface UserConfigSpecLabelSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string;
            /**
             * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string;
            /**
             * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
             */
            values?: string[];
        }

        /**
         * LockedResourceTemplate represents a resource template in go language to be enforced in a LockedResourceController and can be used in a API specification
         */
        export interface UserConfigSpecTemplates {
            /**
             * ExludedPaths are a set of json paths that need not be considered by the LockedResourceReconciler
             */
            excludedPaths?: string[];
            /**
             * ObjectTemplate is a goland template. Whne processed, it must resolve to a yaml representation of an API resource
             */
            objectTemplate: string;
        }

        /**
         * UserConfigStatus defines the observed state of UserConfig
         */
        export interface UserConfigStatus {
            /**
             * ReconcileStatus this is the general status of the main reconciler
             */
            conditions?: outputs.redhatcop.v1alpha1.UserConfigStatusConditions[];
            /**
             * LockedResourceStatuses contains the reconcile status for each of the managed resources
             */
            lockedResourceStatuses?: {[key: string]: outputs.redhatcop.v1alpha1.UserConfigStatusLockedResourceStatuses[]};
        }

        /**
         * Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
         *  Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
         */
        export interface UserConfigStatusConditions {
            lastTransitionTime?: string;
            message?: string;
            /**
             * ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
             */
            reason?: string;
            status: string;
            /**
             * ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
             *  Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
             */
            type: string;
        }

        /**
         * Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
         *  Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
         */
        export interface UserConfigStatusLockedResourceStatuses {
            lastTransitionTime?: string;
            message?: string;
            /**
             * ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
             */
            reason?: string;
            status: string;
            /**
             * ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
             *  Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
             */
            type: string;
        }
    }
}
