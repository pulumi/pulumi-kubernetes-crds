// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package v1alpha1

import (
	"context"
	"reflect"

	metav1 "github.com/pulumi/pulumi-kubernetes/sdk/v2/go/kubernetes/meta/v1"
	"github.com/pulumi/pulumi/sdk/v2/go/pulumi"
)

// GroupConfig is the Schema for the groupconfigs API
type GroupConfigType struct {
	ApiVersion *string            `pulumi:"apiVersion"`
	Kind       *string            `pulumi:"kind"`
	Metadata   *metav1.ObjectMeta `pulumi:"metadata"`
	// GroupConfigSpec defines the desired state of GroupConfig There are two selectors: "labelSelector", "annotationSelector". Selectors are considered in AND, so if multiple are defined they must all be true for a Group to be selected.
	Spec *GroupConfigSpec `pulumi:"spec"`
	// GroupConfigStatus defines the observed state of GroupConfig
	Status *GroupConfigStatus `pulumi:"status"`
}

// GroupConfigTypeInput is an input type that accepts GroupConfigTypeArgs and GroupConfigTypeOutput values.
// You can construct a concrete instance of `GroupConfigTypeInput` via:
//
//          GroupConfigTypeArgs{...}
type GroupConfigTypeInput interface {
	pulumi.Input

	ToGroupConfigTypeOutput() GroupConfigTypeOutput
	ToGroupConfigTypeOutputWithContext(context.Context) GroupConfigTypeOutput
}

// GroupConfig is the Schema for the groupconfigs API
type GroupConfigTypeArgs struct {
	ApiVersion pulumi.StringPtrInput     `pulumi:"apiVersion"`
	Kind       pulumi.StringPtrInput     `pulumi:"kind"`
	Metadata   metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	// GroupConfigSpec defines the desired state of GroupConfig There are two selectors: "labelSelector", "annotationSelector". Selectors are considered in AND, so if multiple are defined they must all be true for a Group to be selected.
	Spec GroupConfigSpecPtrInput `pulumi:"spec"`
	// GroupConfigStatus defines the observed state of GroupConfig
	Status GroupConfigStatusPtrInput `pulumi:"status"`
}

func (GroupConfigTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GroupConfigType)(nil)).Elem()
}

func (i GroupConfigTypeArgs) ToGroupConfigTypeOutput() GroupConfigTypeOutput {
	return i.ToGroupConfigTypeOutputWithContext(context.Background())
}

func (i GroupConfigTypeArgs) ToGroupConfigTypeOutputWithContext(ctx context.Context) GroupConfigTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupConfigTypeOutput)
}

// GroupConfig is the Schema for the groupconfigs API
type GroupConfigTypeOutput struct{ *pulumi.OutputState }

func (GroupConfigTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GroupConfigType)(nil)).Elem()
}

func (o GroupConfigTypeOutput) ToGroupConfigTypeOutput() GroupConfigTypeOutput {
	return o
}

func (o GroupConfigTypeOutput) ToGroupConfigTypeOutputWithContext(ctx context.Context) GroupConfigTypeOutput {
	return o
}

func (o GroupConfigTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GroupConfigType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

func (o GroupConfigTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GroupConfigType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

func (o GroupConfigTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v GroupConfigType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

// GroupConfigSpec defines the desired state of GroupConfig There are two selectors: "labelSelector", "annotationSelector". Selectors are considered in AND, so if multiple are defined they must all be true for a Group to be selected.
func (o GroupConfigTypeOutput) Spec() GroupConfigSpecPtrOutput {
	return o.ApplyT(func(v GroupConfigType) *GroupConfigSpec { return v.Spec }).(GroupConfigSpecPtrOutput)
}

// GroupConfigStatus defines the observed state of GroupConfig
func (o GroupConfigTypeOutput) Status() GroupConfigStatusPtrOutput {
	return o.ApplyT(func(v GroupConfigType) *GroupConfigStatus { return v.Status }).(GroupConfigStatusPtrOutput)
}

type GroupConfigMetadata struct {
}

// GroupConfigMetadataInput is an input type that accepts GroupConfigMetadataArgs and GroupConfigMetadataOutput values.
// You can construct a concrete instance of `GroupConfigMetadataInput` via:
//
//          GroupConfigMetadataArgs{...}
type GroupConfigMetadataInput interface {
	pulumi.Input

	ToGroupConfigMetadataOutput() GroupConfigMetadataOutput
	ToGroupConfigMetadataOutputWithContext(context.Context) GroupConfigMetadataOutput
}

type GroupConfigMetadataArgs struct {
}

func (GroupConfigMetadataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GroupConfigMetadata)(nil)).Elem()
}

func (i GroupConfigMetadataArgs) ToGroupConfigMetadataOutput() GroupConfigMetadataOutput {
	return i.ToGroupConfigMetadataOutputWithContext(context.Background())
}

func (i GroupConfigMetadataArgs) ToGroupConfigMetadataOutputWithContext(ctx context.Context) GroupConfigMetadataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupConfigMetadataOutput)
}

type GroupConfigMetadataOutput struct{ *pulumi.OutputState }

func (GroupConfigMetadataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GroupConfigMetadata)(nil)).Elem()
}

func (o GroupConfigMetadataOutput) ToGroupConfigMetadataOutput() GroupConfigMetadataOutput {
	return o
}

func (o GroupConfigMetadataOutput) ToGroupConfigMetadataOutputWithContext(ctx context.Context) GroupConfigMetadataOutput {
	return o
}

// GroupConfigSpec defines the desired state of GroupConfig There are two selectors: "labelSelector", "annotationSelector". Selectors are considered in AND, so if multiple are defined they must all be true for a Group to be selected.
type GroupConfigSpec struct {
	// AnnotationSelector selects Groups by annotation.
	AnnotationSelector *GroupConfigSpecAnnotationSelector `pulumi:"annotationSelector"`
	// LabelSelector selects Groups by label.
	LabelSelector *GroupConfigSpecLabelSelector `pulumi:"labelSelector"`
	Templates     []GroupConfigSpecTemplates    `pulumi:"templates"`
}

// GroupConfigSpecInput is an input type that accepts GroupConfigSpecArgs and GroupConfigSpecOutput values.
// You can construct a concrete instance of `GroupConfigSpecInput` via:
//
//          GroupConfigSpecArgs{...}
type GroupConfigSpecInput interface {
	pulumi.Input

	ToGroupConfigSpecOutput() GroupConfigSpecOutput
	ToGroupConfigSpecOutputWithContext(context.Context) GroupConfigSpecOutput
}

// GroupConfigSpec defines the desired state of GroupConfig There are two selectors: "labelSelector", "annotationSelector". Selectors are considered in AND, so if multiple are defined they must all be true for a Group to be selected.
type GroupConfigSpecArgs struct {
	// AnnotationSelector selects Groups by annotation.
	AnnotationSelector GroupConfigSpecAnnotationSelectorPtrInput `pulumi:"annotationSelector"`
	// LabelSelector selects Groups by label.
	LabelSelector GroupConfigSpecLabelSelectorPtrInput `pulumi:"labelSelector"`
	Templates     GroupConfigSpecTemplatesArrayInput   `pulumi:"templates"`
}

func (GroupConfigSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GroupConfigSpec)(nil)).Elem()
}

func (i GroupConfigSpecArgs) ToGroupConfigSpecOutput() GroupConfigSpecOutput {
	return i.ToGroupConfigSpecOutputWithContext(context.Background())
}

func (i GroupConfigSpecArgs) ToGroupConfigSpecOutputWithContext(ctx context.Context) GroupConfigSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupConfigSpecOutput)
}

func (i GroupConfigSpecArgs) ToGroupConfigSpecPtrOutput() GroupConfigSpecPtrOutput {
	return i.ToGroupConfigSpecPtrOutputWithContext(context.Background())
}

func (i GroupConfigSpecArgs) ToGroupConfigSpecPtrOutputWithContext(ctx context.Context) GroupConfigSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupConfigSpecOutput).ToGroupConfigSpecPtrOutputWithContext(ctx)
}

// GroupConfigSpecPtrInput is an input type that accepts GroupConfigSpecArgs, GroupConfigSpecPtr and GroupConfigSpecPtrOutput values.
// You can construct a concrete instance of `GroupConfigSpecPtrInput` via:
//
//          GroupConfigSpecArgs{...}
//
//  or:
//
//          nil
type GroupConfigSpecPtrInput interface {
	pulumi.Input

	ToGroupConfigSpecPtrOutput() GroupConfigSpecPtrOutput
	ToGroupConfigSpecPtrOutputWithContext(context.Context) GroupConfigSpecPtrOutput
}

type groupConfigSpecPtrType GroupConfigSpecArgs

func GroupConfigSpecPtr(v *GroupConfigSpecArgs) GroupConfigSpecPtrInput {
	return (*groupConfigSpecPtrType)(v)
}

func (*groupConfigSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GroupConfigSpec)(nil)).Elem()
}

func (i *groupConfigSpecPtrType) ToGroupConfigSpecPtrOutput() GroupConfigSpecPtrOutput {
	return i.ToGroupConfigSpecPtrOutputWithContext(context.Background())
}

func (i *groupConfigSpecPtrType) ToGroupConfigSpecPtrOutputWithContext(ctx context.Context) GroupConfigSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupConfigSpecPtrOutput)
}

// GroupConfigSpec defines the desired state of GroupConfig There are two selectors: "labelSelector", "annotationSelector". Selectors are considered in AND, so if multiple are defined they must all be true for a Group to be selected.
type GroupConfigSpecOutput struct{ *pulumi.OutputState }

func (GroupConfigSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GroupConfigSpec)(nil)).Elem()
}

func (o GroupConfigSpecOutput) ToGroupConfigSpecOutput() GroupConfigSpecOutput {
	return o
}

func (o GroupConfigSpecOutput) ToGroupConfigSpecOutputWithContext(ctx context.Context) GroupConfigSpecOutput {
	return o
}

func (o GroupConfigSpecOutput) ToGroupConfigSpecPtrOutput() GroupConfigSpecPtrOutput {
	return o.ToGroupConfigSpecPtrOutputWithContext(context.Background())
}

func (o GroupConfigSpecOutput) ToGroupConfigSpecPtrOutputWithContext(ctx context.Context) GroupConfigSpecPtrOutput {
	return o.ApplyT(func(v GroupConfigSpec) *GroupConfigSpec {
		return &v
	}).(GroupConfigSpecPtrOutput)
}

// AnnotationSelector selects Groups by annotation.
func (o GroupConfigSpecOutput) AnnotationSelector() GroupConfigSpecAnnotationSelectorPtrOutput {
	return o.ApplyT(func(v GroupConfigSpec) *GroupConfigSpecAnnotationSelector { return v.AnnotationSelector }).(GroupConfigSpecAnnotationSelectorPtrOutput)
}

// LabelSelector selects Groups by label.
func (o GroupConfigSpecOutput) LabelSelector() GroupConfigSpecLabelSelectorPtrOutput {
	return o.ApplyT(func(v GroupConfigSpec) *GroupConfigSpecLabelSelector { return v.LabelSelector }).(GroupConfigSpecLabelSelectorPtrOutput)
}

func (o GroupConfigSpecOutput) Templates() GroupConfigSpecTemplatesArrayOutput {
	return o.ApplyT(func(v GroupConfigSpec) []GroupConfigSpecTemplates { return v.Templates }).(GroupConfigSpecTemplatesArrayOutput)
}

type GroupConfigSpecPtrOutput struct{ *pulumi.OutputState }

func (GroupConfigSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GroupConfigSpec)(nil)).Elem()
}

func (o GroupConfigSpecPtrOutput) ToGroupConfigSpecPtrOutput() GroupConfigSpecPtrOutput {
	return o
}

func (o GroupConfigSpecPtrOutput) ToGroupConfigSpecPtrOutputWithContext(ctx context.Context) GroupConfigSpecPtrOutput {
	return o
}

func (o GroupConfigSpecPtrOutput) Elem() GroupConfigSpecOutput {
	return o.ApplyT(func(v *GroupConfigSpec) GroupConfigSpec { return *v }).(GroupConfigSpecOutput)
}

// AnnotationSelector selects Groups by annotation.
func (o GroupConfigSpecPtrOutput) AnnotationSelector() GroupConfigSpecAnnotationSelectorPtrOutput {
	return o.ApplyT(func(v *GroupConfigSpec) *GroupConfigSpecAnnotationSelector {
		if v == nil {
			return nil
		}
		return v.AnnotationSelector
	}).(GroupConfigSpecAnnotationSelectorPtrOutput)
}

// LabelSelector selects Groups by label.
func (o GroupConfigSpecPtrOutput) LabelSelector() GroupConfigSpecLabelSelectorPtrOutput {
	return o.ApplyT(func(v *GroupConfigSpec) *GroupConfigSpecLabelSelector {
		if v == nil {
			return nil
		}
		return v.LabelSelector
	}).(GroupConfigSpecLabelSelectorPtrOutput)
}

func (o GroupConfigSpecPtrOutput) Templates() GroupConfigSpecTemplatesArrayOutput {
	return o.ApplyT(func(v *GroupConfigSpec) []GroupConfigSpecTemplates {
		if v == nil {
			return nil
		}
		return v.Templates
	}).(GroupConfigSpecTemplatesArrayOutput)
}

// AnnotationSelector selects Groups by annotation.
type GroupConfigSpecAnnotationSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []GroupConfigSpecAnnotationSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// GroupConfigSpecAnnotationSelectorInput is an input type that accepts GroupConfigSpecAnnotationSelectorArgs and GroupConfigSpecAnnotationSelectorOutput values.
// You can construct a concrete instance of `GroupConfigSpecAnnotationSelectorInput` via:
//
//          GroupConfigSpecAnnotationSelectorArgs{...}
type GroupConfigSpecAnnotationSelectorInput interface {
	pulumi.Input

	ToGroupConfigSpecAnnotationSelectorOutput() GroupConfigSpecAnnotationSelectorOutput
	ToGroupConfigSpecAnnotationSelectorOutputWithContext(context.Context) GroupConfigSpecAnnotationSelectorOutput
}

// AnnotationSelector selects Groups by annotation.
type GroupConfigSpecAnnotationSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions GroupConfigSpecAnnotationSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (GroupConfigSpecAnnotationSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GroupConfigSpecAnnotationSelector)(nil)).Elem()
}

func (i GroupConfigSpecAnnotationSelectorArgs) ToGroupConfigSpecAnnotationSelectorOutput() GroupConfigSpecAnnotationSelectorOutput {
	return i.ToGroupConfigSpecAnnotationSelectorOutputWithContext(context.Background())
}

func (i GroupConfigSpecAnnotationSelectorArgs) ToGroupConfigSpecAnnotationSelectorOutputWithContext(ctx context.Context) GroupConfigSpecAnnotationSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupConfigSpecAnnotationSelectorOutput)
}

func (i GroupConfigSpecAnnotationSelectorArgs) ToGroupConfigSpecAnnotationSelectorPtrOutput() GroupConfigSpecAnnotationSelectorPtrOutput {
	return i.ToGroupConfigSpecAnnotationSelectorPtrOutputWithContext(context.Background())
}

func (i GroupConfigSpecAnnotationSelectorArgs) ToGroupConfigSpecAnnotationSelectorPtrOutputWithContext(ctx context.Context) GroupConfigSpecAnnotationSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupConfigSpecAnnotationSelectorOutput).ToGroupConfigSpecAnnotationSelectorPtrOutputWithContext(ctx)
}

// GroupConfigSpecAnnotationSelectorPtrInput is an input type that accepts GroupConfigSpecAnnotationSelectorArgs, GroupConfigSpecAnnotationSelectorPtr and GroupConfigSpecAnnotationSelectorPtrOutput values.
// You can construct a concrete instance of `GroupConfigSpecAnnotationSelectorPtrInput` via:
//
//          GroupConfigSpecAnnotationSelectorArgs{...}
//
//  or:
//
//          nil
type GroupConfigSpecAnnotationSelectorPtrInput interface {
	pulumi.Input

	ToGroupConfigSpecAnnotationSelectorPtrOutput() GroupConfigSpecAnnotationSelectorPtrOutput
	ToGroupConfigSpecAnnotationSelectorPtrOutputWithContext(context.Context) GroupConfigSpecAnnotationSelectorPtrOutput
}

type groupConfigSpecAnnotationSelectorPtrType GroupConfigSpecAnnotationSelectorArgs

func GroupConfigSpecAnnotationSelectorPtr(v *GroupConfigSpecAnnotationSelectorArgs) GroupConfigSpecAnnotationSelectorPtrInput {
	return (*groupConfigSpecAnnotationSelectorPtrType)(v)
}

func (*groupConfigSpecAnnotationSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GroupConfigSpecAnnotationSelector)(nil)).Elem()
}

func (i *groupConfigSpecAnnotationSelectorPtrType) ToGroupConfigSpecAnnotationSelectorPtrOutput() GroupConfigSpecAnnotationSelectorPtrOutput {
	return i.ToGroupConfigSpecAnnotationSelectorPtrOutputWithContext(context.Background())
}

func (i *groupConfigSpecAnnotationSelectorPtrType) ToGroupConfigSpecAnnotationSelectorPtrOutputWithContext(ctx context.Context) GroupConfigSpecAnnotationSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupConfigSpecAnnotationSelectorPtrOutput)
}

// AnnotationSelector selects Groups by annotation.
type GroupConfigSpecAnnotationSelectorOutput struct{ *pulumi.OutputState }

func (GroupConfigSpecAnnotationSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GroupConfigSpecAnnotationSelector)(nil)).Elem()
}

func (o GroupConfigSpecAnnotationSelectorOutput) ToGroupConfigSpecAnnotationSelectorOutput() GroupConfigSpecAnnotationSelectorOutput {
	return o
}

func (o GroupConfigSpecAnnotationSelectorOutput) ToGroupConfigSpecAnnotationSelectorOutputWithContext(ctx context.Context) GroupConfigSpecAnnotationSelectorOutput {
	return o
}

func (o GroupConfigSpecAnnotationSelectorOutput) ToGroupConfigSpecAnnotationSelectorPtrOutput() GroupConfigSpecAnnotationSelectorPtrOutput {
	return o.ToGroupConfigSpecAnnotationSelectorPtrOutputWithContext(context.Background())
}

func (o GroupConfigSpecAnnotationSelectorOutput) ToGroupConfigSpecAnnotationSelectorPtrOutputWithContext(ctx context.Context) GroupConfigSpecAnnotationSelectorPtrOutput {
	return o.ApplyT(func(v GroupConfigSpecAnnotationSelector) *GroupConfigSpecAnnotationSelector {
		return &v
	}).(GroupConfigSpecAnnotationSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o GroupConfigSpecAnnotationSelectorOutput) MatchExpressions() GroupConfigSpecAnnotationSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v GroupConfigSpecAnnotationSelector) []GroupConfigSpecAnnotationSelectorMatchExpressions {
		return v.MatchExpressions
	}).(GroupConfigSpecAnnotationSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o GroupConfigSpecAnnotationSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v GroupConfigSpecAnnotationSelector) map[string]string { return v.MatchLabels }).(pulumi.StringMapOutput)
}

type GroupConfigSpecAnnotationSelectorPtrOutput struct{ *pulumi.OutputState }

func (GroupConfigSpecAnnotationSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GroupConfigSpecAnnotationSelector)(nil)).Elem()
}

func (o GroupConfigSpecAnnotationSelectorPtrOutput) ToGroupConfigSpecAnnotationSelectorPtrOutput() GroupConfigSpecAnnotationSelectorPtrOutput {
	return o
}

func (o GroupConfigSpecAnnotationSelectorPtrOutput) ToGroupConfigSpecAnnotationSelectorPtrOutputWithContext(ctx context.Context) GroupConfigSpecAnnotationSelectorPtrOutput {
	return o
}

func (o GroupConfigSpecAnnotationSelectorPtrOutput) Elem() GroupConfigSpecAnnotationSelectorOutput {
	return o.ApplyT(func(v *GroupConfigSpecAnnotationSelector) GroupConfigSpecAnnotationSelector { return *v }).(GroupConfigSpecAnnotationSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o GroupConfigSpecAnnotationSelectorPtrOutput) MatchExpressions() GroupConfigSpecAnnotationSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *GroupConfigSpecAnnotationSelector) []GroupConfigSpecAnnotationSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(GroupConfigSpecAnnotationSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o GroupConfigSpecAnnotationSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *GroupConfigSpecAnnotationSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type GroupConfigSpecAnnotationSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// GroupConfigSpecAnnotationSelectorMatchExpressionsInput is an input type that accepts GroupConfigSpecAnnotationSelectorMatchExpressionsArgs and GroupConfigSpecAnnotationSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `GroupConfigSpecAnnotationSelectorMatchExpressionsInput` via:
//
//          GroupConfigSpecAnnotationSelectorMatchExpressionsArgs{...}
type GroupConfigSpecAnnotationSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToGroupConfigSpecAnnotationSelectorMatchExpressionsOutput() GroupConfigSpecAnnotationSelectorMatchExpressionsOutput
	ToGroupConfigSpecAnnotationSelectorMatchExpressionsOutputWithContext(context.Context) GroupConfigSpecAnnotationSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type GroupConfigSpecAnnotationSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (GroupConfigSpecAnnotationSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GroupConfigSpecAnnotationSelectorMatchExpressions)(nil)).Elem()
}

func (i GroupConfigSpecAnnotationSelectorMatchExpressionsArgs) ToGroupConfigSpecAnnotationSelectorMatchExpressionsOutput() GroupConfigSpecAnnotationSelectorMatchExpressionsOutput {
	return i.ToGroupConfigSpecAnnotationSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i GroupConfigSpecAnnotationSelectorMatchExpressionsArgs) ToGroupConfigSpecAnnotationSelectorMatchExpressionsOutputWithContext(ctx context.Context) GroupConfigSpecAnnotationSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupConfigSpecAnnotationSelectorMatchExpressionsOutput)
}

// GroupConfigSpecAnnotationSelectorMatchExpressionsArrayInput is an input type that accepts GroupConfigSpecAnnotationSelectorMatchExpressionsArray and GroupConfigSpecAnnotationSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `GroupConfigSpecAnnotationSelectorMatchExpressionsArrayInput` via:
//
//          GroupConfigSpecAnnotationSelectorMatchExpressionsArray{ GroupConfigSpecAnnotationSelectorMatchExpressionsArgs{...} }
type GroupConfigSpecAnnotationSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToGroupConfigSpecAnnotationSelectorMatchExpressionsArrayOutput() GroupConfigSpecAnnotationSelectorMatchExpressionsArrayOutput
	ToGroupConfigSpecAnnotationSelectorMatchExpressionsArrayOutputWithContext(context.Context) GroupConfigSpecAnnotationSelectorMatchExpressionsArrayOutput
}

type GroupConfigSpecAnnotationSelectorMatchExpressionsArray []GroupConfigSpecAnnotationSelectorMatchExpressionsInput

func (GroupConfigSpecAnnotationSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GroupConfigSpecAnnotationSelectorMatchExpressions)(nil)).Elem()
}

func (i GroupConfigSpecAnnotationSelectorMatchExpressionsArray) ToGroupConfigSpecAnnotationSelectorMatchExpressionsArrayOutput() GroupConfigSpecAnnotationSelectorMatchExpressionsArrayOutput {
	return i.ToGroupConfigSpecAnnotationSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i GroupConfigSpecAnnotationSelectorMatchExpressionsArray) ToGroupConfigSpecAnnotationSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) GroupConfigSpecAnnotationSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupConfigSpecAnnotationSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type GroupConfigSpecAnnotationSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (GroupConfigSpecAnnotationSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GroupConfigSpecAnnotationSelectorMatchExpressions)(nil)).Elem()
}

func (o GroupConfigSpecAnnotationSelectorMatchExpressionsOutput) ToGroupConfigSpecAnnotationSelectorMatchExpressionsOutput() GroupConfigSpecAnnotationSelectorMatchExpressionsOutput {
	return o
}

func (o GroupConfigSpecAnnotationSelectorMatchExpressionsOutput) ToGroupConfigSpecAnnotationSelectorMatchExpressionsOutputWithContext(ctx context.Context) GroupConfigSpecAnnotationSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o GroupConfigSpecAnnotationSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v GroupConfigSpecAnnotationSelectorMatchExpressions) string { return v.Key }).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
func (o GroupConfigSpecAnnotationSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v GroupConfigSpecAnnotationSelectorMatchExpressions) string { return v.Operator }).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
func (o GroupConfigSpecAnnotationSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GroupConfigSpecAnnotationSelectorMatchExpressions) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type GroupConfigSpecAnnotationSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (GroupConfigSpecAnnotationSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GroupConfigSpecAnnotationSelectorMatchExpressions)(nil)).Elem()
}

func (o GroupConfigSpecAnnotationSelectorMatchExpressionsArrayOutput) ToGroupConfigSpecAnnotationSelectorMatchExpressionsArrayOutput() GroupConfigSpecAnnotationSelectorMatchExpressionsArrayOutput {
	return o
}

func (o GroupConfigSpecAnnotationSelectorMatchExpressionsArrayOutput) ToGroupConfigSpecAnnotationSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) GroupConfigSpecAnnotationSelectorMatchExpressionsArrayOutput {
	return o
}

func (o GroupConfigSpecAnnotationSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) GroupConfigSpecAnnotationSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GroupConfigSpecAnnotationSelectorMatchExpressions {
		return vs[0].([]GroupConfigSpecAnnotationSelectorMatchExpressions)[vs[1].(int)]
	}).(GroupConfigSpecAnnotationSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type GroupConfigSpecAnnotationSelectorMatchLabels struct {
}

// GroupConfigSpecAnnotationSelectorMatchLabelsInput is an input type that accepts GroupConfigSpecAnnotationSelectorMatchLabelsArgs and GroupConfigSpecAnnotationSelectorMatchLabelsOutput values.
// You can construct a concrete instance of `GroupConfigSpecAnnotationSelectorMatchLabelsInput` via:
//
//          GroupConfigSpecAnnotationSelectorMatchLabelsArgs{...}
type GroupConfigSpecAnnotationSelectorMatchLabelsInput interface {
	pulumi.Input

	ToGroupConfigSpecAnnotationSelectorMatchLabelsOutput() GroupConfigSpecAnnotationSelectorMatchLabelsOutput
	ToGroupConfigSpecAnnotationSelectorMatchLabelsOutputWithContext(context.Context) GroupConfigSpecAnnotationSelectorMatchLabelsOutput
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type GroupConfigSpecAnnotationSelectorMatchLabelsArgs struct {
}

func (GroupConfigSpecAnnotationSelectorMatchLabelsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GroupConfigSpecAnnotationSelectorMatchLabels)(nil)).Elem()
}

func (i GroupConfigSpecAnnotationSelectorMatchLabelsArgs) ToGroupConfigSpecAnnotationSelectorMatchLabelsOutput() GroupConfigSpecAnnotationSelectorMatchLabelsOutput {
	return i.ToGroupConfigSpecAnnotationSelectorMatchLabelsOutputWithContext(context.Background())
}

func (i GroupConfigSpecAnnotationSelectorMatchLabelsArgs) ToGroupConfigSpecAnnotationSelectorMatchLabelsOutputWithContext(ctx context.Context) GroupConfigSpecAnnotationSelectorMatchLabelsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupConfigSpecAnnotationSelectorMatchLabelsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type GroupConfigSpecAnnotationSelectorMatchLabelsOutput struct{ *pulumi.OutputState }

func (GroupConfigSpecAnnotationSelectorMatchLabelsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GroupConfigSpecAnnotationSelectorMatchLabels)(nil)).Elem()
}

func (o GroupConfigSpecAnnotationSelectorMatchLabelsOutput) ToGroupConfigSpecAnnotationSelectorMatchLabelsOutput() GroupConfigSpecAnnotationSelectorMatchLabelsOutput {
	return o
}

func (o GroupConfigSpecAnnotationSelectorMatchLabelsOutput) ToGroupConfigSpecAnnotationSelectorMatchLabelsOutputWithContext(ctx context.Context) GroupConfigSpecAnnotationSelectorMatchLabelsOutput {
	return o
}

// LabelSelector selects Groups by label.
type GroupConfigSpecLabelSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []GroupConfigSpecLabelSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// GroupConfigSpecLabelSelectorInput is an input type that accepts GroupConfigSpecLabelSelectorArgs and GroupConfigSpecLabelSelectorOutput values.
// You can construct a concrete instance of `GroupConfigSpecLabelSelectorInput` via:
//
//          GroupConfigSpecLabelSelectorArgs{...}
type GroupConfigSpecLabelSelectorInput interface {
	pulumi.Input

	ToGroupConfigSpecLabelSelectorOutput() GroupConfigSpecLabelSelectorOutput
	ToGroupConfigSpecLabelSelectorOutputWithContext(context.Context) GroupConfigSpecLabelSelectorOutput
}

// LabelSelector selects Groups by label.
type GroupConfigSpecLabelSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions GroupConfigSpecLabelSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (GroupConfigSpecLabelSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GroupConfigSpecLabelSelector)(nil)).Elem()
}

func (i GroupConfigSpecLabelSelectorArgs) ToGroupConfigSpecLabelSelectorOutput() GroupConfigSpecLabelSelectorOutput {
	return i.ToGroupConfigSpecLabelSelectorOutputWithContext(context.Background())
}

func (i GroupConfigSpecLabelSelectorArgs) ToGroupConfigSpecLabelSelectorOutputWithContext(ctx context.Context) GroupConfigSpecLabelSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupConfigSpecLabelSelectorOutput)
}

func (i GroupConfigSpecLabelSelectorArgs) ToGroupConfigSpecLabelSelectorPtrOutput() GroupConfigSpecLabelSelectorPtrOutput {
	return i.ToGroupConfigSpecLabelSelectorPtrOutputWithContext(context.Background())
}

func (i GroupConfigSpecLabelSelectorArgs) ToGroupConfigSpecLabelSelectorPtrOutputWithContext(ctx context.Context) GroupConfigSpecLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupConfigSpecLabelSelectorOutput).ToGroupConfigSpecLabelSelectorPtrOutputWithContext(ctx)
}

// GroupConfigSpecLabelSelectorPtrInput is an input type that accepts GroupConfigSpecLabelSelectorArgs, GroupConfigSpecLabelSelectorPtr and GroupConfigSpecLabelSelectorPtrOutput values.
// You can construct a concrete instance of `GroupConfigSpecLabelSelectorPtrInput` via:
//
//          GroupConfigSpecLabelSelectorArgs{...}
//
//  or:
//
//          nil
type GroupConfigSpecLabelSelectorPtrInput interface {
	pulumi.Input

	ToGroupConfigSpecLabelSelectorPtrOutput() GroupConfigSpecLabelSelectorPtrOutput
	ToGroupConfigSpecLabelSelectorPtrOutputWithContext(context.Context) GroupConfigSpecLabelSelectorPtrOutput
}

type groupConfigSpecLabelSelectorPtrType GroupConfigSpecLabelSelectorArgs

func GroupConfigSpecLabelSelectorPtr(v *GroupConfigSpecLabelSelectorArgs) GroupConfigSpecLabelSelectorPtrInput {
	return (*groupConfigSpecLabelSelectorPtrType)(v)
}

func (*groupConfigSpecLabelSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GroupConfigSpecLabelSelector)(nil)).Elem()
}

func (i *groupConfigSpecLabelSelectorPtrType) ToGroupConfigSpecLabelSelectorPtrOutput() GroupConfigSpecLabelSelectorPtrOutput {
	return i.ToGroupConfigSpecLabelSelectorPtrOutputWithContext(context.Background())
}

func (i *groupConfigSpecLabelSelectorPtrType) ToGroupConfigSpecLabelSelectorPtrOutputWithContext(ctx context.Context) GroupConfigSpecLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupConfigSpecLabelSelectorPtrOutput)
}

// LabelSelector selects Groups by label.
type GroupConfigSpecLabelSelectorOutput struct{ *pulumi.OutputState }

func (GroupConfigSpecLabelSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GroupConfigSpecLabelSelector)(nil)).Elem()
}

func (o GroupConfigSpecLabelSelectorOutput) ToGroupConfigSpecLabelSelectorOutput() GroupConfigSpecLabelSelectorOutput {
	return o
}

func (o GroupConfigSpecLabelSelectorOutput) ToGroupConfigSpecLabelSelectorOutputWithContext(ctx context.Context) GroupConfigSpecLabelSelectorOutput {
	return o
}

func (o GroupConfigSpecLabelSelectorOutput) ToGroupConfigSpecLabelSelectorPtrOutput() GroupConfigSpecLabelSelectorPtrOutput {
	return o.ToGroupConfigSpecLabelSelectorPtrOutputWithContext(context.Background())
}

func (o GroupConfigSpecLabelSelectorOutput) ToGroupConfigSpecLabelSelectorPtrOutputWithContext(ctx context.Context) GroupConfigSpecLabelSelectorPtrOutput {
	return o.ApplyT(func(v GroupConfigSpecLabelSelector) *GroupConfigSpecLabelSelector {
		return &v
	}).(GroupConfigSpecLabelSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o GroupConfigSpecLabelSelectorOutput) MatchExpressions() GroupConfigSpecLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v GroupConfigSpecLabelSelector) []GroupConfigSpecLabelSelectorMatchExpressions {
		return v.MatchExpressions
	}).(GroupConfigSpecLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o GroupConfigSpecLabelSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v GroupConfigSpecLabelSelector) map[string]string { return v.MatchLabels }).(pulumi.StringMapOutput)
}

type GroupConfigSpecLabelSelectorPtrOutput struct{ *pulumi.OutputState }

func (GroupConfigSpecLabelSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GroupConfigSpecLabelSelector)(nil)).Elem()
}

func (o GroupConfigSpecLabelSelectorPtrOutput) ToGroupConfigSpecLabelSelectorPtrOutput() GroupConfigSpecLabelSelectorPtrOutput {
	return o
}

func (o GroupConfigSpecLabelSelectorPtrOutput) ToGroupConfigSpecLabelSelectorPtrOutputWithContext(ctx context.Context) GroupConfigSpecLabelSelectorPtrOutput {
	return o
}

func (o GroupConfigSpecLabelSelectorPtrOutput) Elem() GroupConfigSpecLabelSelectorOutput {
	return o.ApplyT(func(v *GroupConfigSpecLabelSelector) GroupConfigSpecLabelSelector { return *v }).(GroupConfigSpecLabelSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o GroupConfigSpecLabelSelectorPtrOutput) MatchExpressions() GroupConfigSpecLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *GroupConfigSpecLabelSelector) []GroupConfigSpecLabelSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(GroupConfigSpecLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o GroupConfigSpecLabelSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *GroupConfigSpecLabelSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type GroupConfigSpecLabelSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// GroupConfigSpecLabelSelectorMatchExpressionsInput is an input type that accepts GroupConfigSpecLabelSelectorMatchExpressionsArgs and GroupConfigSpecLabelSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `GroupConfigSpecLabelSelectorMatchExpressionsInput` via:
//
//          GroupConfigSpecLabelSelectorMatchExpressionsArgs{...}
type GroupConfigSpecLabelSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToGroupConfigSpecLabelSelectorMatchExpressionsOutput() GroupConfigSpecLabelSelectorMatchExpressionsOutput
	ToGroupConfigSpecLabelSelectorMatchExpressionsOutputWithContext(context.Context) GroupConfigSpecLabelSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type GroupConfigSpecLabelSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (GroupConfigSpecLabelSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GroupConfigSpecLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i GroupConfigSpecLabelSelectorMatchExpressionsArgs) ToGroupConfigSpecLabelSelectorMatchExpressionsOutput() GroupConfigSpecLabelSelectorMatchExpressionsOutput {
	return i.ToGroupConfigSpecLabelSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i GroupConfigSpecLabelSelectorMatchExpressionsArgs) ToGroupConfigSpecLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) GroupConfigSpecLabelSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupConfigSpecLabelSelectorMatchExpressionsOutput)
}

// GroupConfigSpecLabelSelectorMatchExpressionsArrayInput is an input type that accepts GroupConfigSpecLabelSelectorMatchExpressionsArray and GroupConfigSpecLabelSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `GroupConfigSpecLabelSelectorMatchExpressionsArrayInput` via:
//
//          GroupConfigSpecLabelSelectorMatchExpressionsArray{ GroupConfigSpecLabelSelectorMatchExpressionsArgs{...} }
type GroupConfigSpecLabelSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToGroupConfigSpecLabelSelectorMatchExpressionsArrayOutput() GroupConfigSpecLabelSelectorMatchExpressionsArrayOutput
	ToGroupConfigSpecLabelSelectorMatchExpressionsArrayOutputWithContext(context.Context) GroupConfigSpecLabelSelectorMatchExpressionsArrayOutput
}

type GroupConfigSpecLabelSelectorMatchExpressionsArray []GroupConfigSpecLabelSelectorMatchExpressionsInput

func (GroupConfigSpecLabelSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GroupConfigSpecLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i GroupConfigSpecLabelSelectorMatchExpressionsArray) ToGroupConfigSpecLabelSelectorMatchExpressionsArrayOutput() GroupConfigSpecLabelSelectorMatchExpressionsArrayOutput {
	return i.ToGroupConfigSpecLabelSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i GroupConfigSpecLabelSelectorMatchExpressionsArray) ToGroupConfigSpecLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) GroupConfigSpecLabelSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupConfigSpecLabelSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type GroupConfigSpecLabelSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (GroupConfigSpecLabelSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GroupConfigSpecLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o GroupConfigSpecLabelSelectorMatchExpressionsOutput) ToGroupConfigSpecLabelSelectorMatchExpressionsOutput() GroupConfigSpecLabelSelectorMatchExpressionsOutput {
	return o
}

func (o GroupConfigSpecLabelSelectorMatchExpressionsOutput) ToGroupConfigSpecLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) GroupConfigSpecLabelSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o GroupConfigSpecLabelSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v GroupConfigSpecLabelSelectorMatchExpressions) string { return v.Key }).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
func (o GroupConfigSpecLabelSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v GroupConfigSpecLabelSelectorMatchExpressions) string { return v.Operator }).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
func (o GroupConfigSpecLabelSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GroupConfigSpecLabelSelectorMatchExpressions) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type GroupConfigSpecLabelSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (GroupConfigSpecLabelSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GroupConfigSpecLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o GroupConfigSpecLabelSelectorMatchExpressionsArrayOutput) ToGroupConfigSpecLabelSelectorMatchExpressionsArrayOutput() GroupConfigSpecLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o GroupConfigSpecLabelSelectorMatchExpressionsArrayOutput) ToGroupConfigSpecLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) GroupConfigSpecLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o GroupConfigSpecLabelSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) GroupConfigSpecLabelSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GroupConfigSpecLabelSelectorMatchExpressions {
		return vs[0].([]GroupConfigSpecLabelSelectorMatchExpressions)[vs[1].(int)]
	}).(GroupConfigSpecLabelSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type GroupConfigSpecLabelSelectorMatchLabels struct {
}

// GroupConfigSpecLabelSelectorMatchLabelsInput is an input type that accepts GroupConfigSpecLabelSelectorMatchLabelsArgs and GroupConfigSpecLabelSelectorMatchLabelsOutput values.
// You can construct a concrete instance of `GroupConfigSpecLabelSelectorMatchLabelsInput` via:
//
//          GroupConfigSpecLabelSelectorMatchLabelsArgs{...}
type GroupConfigSpecLabelSelectorMatchLabelsInput interface {
	pulumi.Input

	ToGroupConfigSpecLabelSelectorMatchLabelsOutput() GroupConfigSpecLabelSelectorMatchLabelsOutput
	ToGroupConfigSpecLabelSelectorMatchLabelsOutputWithContext(context.Context) GroupConfigSpecLabelSelectorMatchLabelsOutput
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type GroupConfigSpecLabelSelectorMatchLabelsArgs struct {
}

func (GroupConfigSpecLabelSelectorMatchLabelsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GroupConfigSpecLabelSelectorMatchLabels)(nil)).Elem()
}

func (i GroupConfigSpecLabelSelectorMatchLabelsArgs) ToGroupConfigSpecLabelSelectorMatchLabelsOutput() GroupConfigSpecLabelSelectorMatchLabelsOutput {
	return i.ToGroupConfigSpecLabelSelectorMatchLabelsOutputWithContext(context.Background())
}

func (i GroupConfigSpecLabelSelectorMatchLabelsArgs) ToGroupConfigSpecLabelSelectorMatchLabelsOutputWithContext(ctx context.Context) GroupConfigSpecLabelSelectorMatchLabelsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupConfigSpecLabelSelectorMatchLabelsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type GroupConfigSpecLabelSelectorMatchLabelsOutput struct{ *pulumi.OutputState }

func (GroupConfigSpecLabelSelectorMatchLabelsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GroupConfigSpecLabelSelectorMatchLabels)(nil)).Elem()
}

func (o GroupConfigSpecLabelSelectorMatchLabelsOutput) ToGroupConfigSpecLabelSelectorMatchLabelsOutput() GroupConfigSpecLabelSelectorMatchLabelsOutput {
	return o
}

func (o GroupConfigSpecLabelSelectorMatchLabelsOutput) ToGroupConfigSpecLabelSelectorMatchLabelsOutputWithContext(ctx context.Context) GroupConfigSpecLabelSelectorMatchLabelsOutput {
	return o
}

// LockedResourceTemplate represents a resource template in go language to be enforced in a LockedResourceController and can be used in a API specification
type GroupConfigSpecTemplates struct {
	// ExludedPaths are a set of json paths that need not be considered by the LockedResourceReconciler
	ExcludedPaths []string `pulumi:"excludedPaths"`
	// ObjectTemplate is a goland template. Whne processed, it must resolve to a yaml representation of an API resource
	ObjectTemplate string `pulumi:"objectTemplate"`
}

// GroupConfigSpecTemplatesInput is an input type that accepts GroupConfigSpecTemplatesArgs and GroupConfigSpecTemplatesOutput values.
// You can construct a concrete instance of `GroupConfigSpecTemplatesInput` via:
//
//          GroupConfigSpecTemplatesArgs{...}
type GroupConfigSpecTemplatesInput interface {
	pulumi.Input

	ToGroupConfigSpecTemplatesOutput() GroupConfigSpecTemplatesOutput
	ToGroupConfigSpecTemplatesOutputWithContext(context.Context) GroupConfigSpecTemplatesOutput
}

// LockedResourceTemplate represents a resource template in go language to be enforced in a LockedResourceController and can be used in a API specification
type GroupConfigSpecTemplatesArgs struct {
	// ExludedPaths are a set of json paths that need not be considered by the LockedResourceReconciler
	ExcludedPaths pulumi.StringArrayInput `pulumi:"excludedPaths"`
	// ObjectTemplate is a goland template. Whne processed, it must resolve to a yaml representation of an API resource
	ObjectTemplate pulumi.StringInput `pulumi:"objectTemplate"`
}

func (GroupConfigSpecTemplatesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GroupConfigSpecTemplates)(nil)).Elem()
}

func (i GroupConfigSpecTemplatesArgs) ToGroupConfigSpecTemplatesOutput() GroupConfigSpecTemplatesOutput {
	return i.ToGroupConfigSpecTemplatesOutputWithContext(context.Background())
}

func (i GroupConfigSpecTemplatesArgs) ToGroupConfigSpecTemplatesOutputWithContext(ctx context.Context) GroupConfigSpecTemplatesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupConfigSpecTemplatesOutput)
}

// GroupConfigSpecTemplatesArrayInput is an input type that accepts GroupConfigSpecTemplatesArray and GroupConfigSpecTemplatesArrayOutput values.
// You can construct a concrete instance of `GroupConfigSpecTemplatesArrayInput` via:
//
//          GroupConfigSpecTemplatesArray{ GroupConfigSpecTemplatesArgs{...} }
type GroupConfigSpecTemplatesArrayInput interface {
	pulumi.Input

	ToGroupConfigSpecTemplatesArrayOutput() GroupConfigSpecTemplatesArrayOutput
	ToGroupConfigSpecTemplatesArrayOutputWithContext(context.Context) GroupConfigSpecTemplatesArrayOutput
}

type GroupConfigSpecTemplatesArray []GroupConfigSpecTemplatesInput

func (GroupConfigSpecTemplatesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GroupConfigSpecTemplates)(nil)).Elem()
}

func (i GroupConfigSpecTemplatesArray) ToGroupConfigSpecTemplatesArrayOutput() GroupConfigSpecTemplatesArrayOutput {
	return i.ToGroupConfigSpecTemplatesArrayOutputWithContext(context.Background())
}

func (i GroupConfigSpecTemplatesArray) ToGroupConfigSpecTemplatesArrayOutputWithContext(ctx context.Context) GroupConfigSpecTemplatesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupConfigSpecTemplatesArrayOutput)
}

// LockedResourceTemplate represents a resource template in go language to be enforced in a LockedResourceController and can be used in a API specification
type GroupConfigSpecTemplatesOutput struct{ *pulumi.OutputState }

func (GroupConfigSpecTemplatesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GroupConfigSpecTemplates)(nil)).Elem()
}

func (o GroupConfigSpecTemplatesOutput) ToGroupConfigSpecTemplatesOutput() GroupConfigSpecTemplatesOutput {
	return o
}

func (o GroupConfigSpecTemplatesOutput) ToGroupConfigSpecTemplatesOutputWithContext(ctx context.Context) GroupConfigSpecTemplatesOutput {
	return o
}

// ExludedPaths are a set of json paths that need not be considered by the LockedResourceReconciler
func (o GroupConfigSpecTemplatesOutput) ExcludedPaths() pulumi.StringArrayOutput {
	return o.ApplyT(func(v GroupConfigSpecTemplates) []string { return v.ExcludedPaths }).(pulumi.StringArrayOutput)
}

// ObjectTemplate is a goland template. Whne processed, it must resolve to a yaml representation of an API resource
func (o GroupConfigSpecTemplatesOutput) ObjectTemplate() pulumi.StringOutput {
	return o.ApplyT(func(v GroupConfigSpecTemplates) string { return v.ObjectTemplate }).(pulumi.StringOutput)
}

type GroupConfigSpecTemplatesArrayOutput struct{ *pulumi.OutputState }

func (GroupConfigSpecTemplatesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GroupConfigSpecTemplates)(nil)).Elem()
}

func (o GroupConfigSpecTemplatesArrayOutput) ToGroupConfigSpecTemplatesArrayOutput() GroupConfigSpecTemplatesArrayOutput {
	return o
}

func (o GroupConfigSpecTemplatesArrayOutput) ToGroupConfigSpecTemplatesArrayOutputWithContext(ctx context.Context) GroupConfigSpecTemplatesArrayOutput {
	return o
}

func (o GroupConfigSpecTemplatesArrayOutput) Index(i pulumi.IntInput) GroupConfigSpecTemplatesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GroupConfigSpecTemplates {
		return vs[0].([]GroupConfigSpecTemplates)[vs[1].(int)]
	}).(GroupConfigSpecTemplatesOutput)
}

// GroupConfigStatus defines the observed state of GroupConfig
type GroupConfigStatus struct {
	// ReconcileStatus this is the general status of the main reconciler
	Conditions []GroupConfigStatusConditions `pulumi:"conditions"`
	// LockedResourceStatuses contains the reconcile status for each of the managed resources
	LockedResourceStatuses map[string][]GroupConfigStatusLockedResourceStatuses `pulumi:"lockedResourceStatuses"`
}

// GroupConfigStatusInput is an input type that accepts GroupConfigStatusArgs and GroupConfigStatusOutput values.
// You can construct a concrete instance of `GroupConfigStatusInput` via:
//
//          GroupConfigStatusArgs{...}
type GroupConfigStatusInput interface {
	pulumi.Input

	ToGroupConfigStatusOutput() GroupConfigStatusOutput
	ToGroupConfigStatusOutputWithContext(context.Context) GroupConfigStatusOutput
}

// GroupConfigStatus defines the observed state of GroupConfig
type GroupConfigStatusArgs struct {
	// ReconcileStatus this is the general status of the main reconciler
	Conditions GroupConfigStatusConditionsArrayInput `pulumi:"conditions"`
	// LockedResourceStatuses contains the reconcile status for each of the managed resources
	LockedResourceStatuses GroupConfigStatusLockedResourceStatusesArrayMapInput `pulumi:"lockedResourceStatuses"`
}

func (GroupConfigStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GroupConfigStatus)(nil)).Elem()
}

func (i GroupConfigStatusArgs) ToGroupConfigStatusOutput() GroupConfigStatusOutput {
	return i.ToGroupConfigStatusOutputWithContext(context.Background())
}

func (i GroupConfigStatusArgs) ToGroupConfigStatusOutputWithContext(ctx context.Context) GroupConfigStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupConfigStatusOutput)
}

func (i GroupConfigStatusArgs) ToGroupConfigStatusPtrOutput() GroupConfigStatusPtrOutput {
	return i.ToGroupConfigStatusPtrOutputWithContext(context.Background())
}

func (i GroupConfigStatusArgs) ToGroupConfigStatusPtrOutputWithContext(ctx context.Context) GroupConfigStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupConfigStatusOutput).ToGroupConfigStatusPtrOutputWithContext(ctx)
}

// GroupConfigStatusPtrInput is an input type that accepts GroupConfigStatusArgs, GroupConfigStatusPtr and GroupConfigStatusPtrOutput values.
// You can construct a concrete instance of `GroupConfigStatusPtrInput` via:
//
//          GroupConfigStatusArgs{...}
//
//  or:
//
//          nil
type GroupConfigStatusPtrInput interface {
	pulumi.Input

	ToGroupConfigStatusPtrOutput() GroupConfigStatusPtrOutput
	ToGroupConfigStatusPtrOutputWithContext(context.Context) GroupConfigStatusPtrOutput
}

type groupConfigStatusPtrType GroupConfigStatusArgs

func GroupConfigStatusPtr(v *GroupConfigStatusArgs) GroupConfigStatusPtrInput {
	return (*groupConfigStatusPtrType)(v)
}

func (*groupConfigStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**GroupConfigStatus)(nil)).Elem()
}

func (i *groupConfigStatusPtrType) ToGroupConfigStatusPtrOutput() GroupConfigStatusPtrOutput {
	return i.ToGroupConfigStatusPtrOutputWithContext(context.Background())
}

func (i *groupConfigStatusPtrType) ToGroupConfigStatusPtrOutputWithContext(ctx context.Context) GroupConfigStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupConfigStatusPtrOutput)
}

// GroupConfigStatus defines the observed state of GroupConfig
type GroupConfigStatusOutput struct{ *pulumi.OutputState }

func (GroupConfigStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GroupConfigStatus)(nil)).Elem()
}

func (o GroupConfigStatusOutput) ToGroupConfigStatusOutput() GroupConfigStatusOutput {
	return o
}

func (o GroupConfigStatusOutput) ToGroupConfigStatusOutputWithContext(ctx context.Context) GroupConfigStatusOutput {
	return o
}

func (o GroupConfigStatusOutput) ToGroupConfigStatusPtrOutput() GroupConfigStatusPtrOutput {
	return o.ToGroupConfigStatusPtrOutputWithContext(context.Background())
}

func (o GroupConfigStatusOutput) ToGroupConfigStatusPtrOutputWithContext(ctx context.Context) GroupConfigStatusPtrOutput {
	return o.ApplyT(func(v GroupConfigStatus) *GroupConfigStatus {
		return &v
	}).(GroupConfigStatusPtrOutput)
}

// ReconcileStatus this is the general status of the main reconciler
func (o GroupConfigStatusOutput) Conditions() GroupConfigStatusConditionsArrayOutput {
	return o.ApplyT(func(v GroupConfigStatus) []GroupConfigStatusConditions { return v.Conditions }).(GroupConfigStatusConditionsArrayOutput)
}

// LockedResourceStatuses contains the reconcile status for each of the managed resources
func (o GroupConfigStatusOutput) LockedResourceStatuses() GroupConfigStatusLockedResourceStatusesArrayMapOutput {
	return o.ApplyT(func(v GroupConfigStatus) map[string][]GroupConfigStatusLockedResourceStatuses {
		return v.LockedResourceStatuses
	}).(GroupConfigStatusLockedResourceStatusesArrayMapOutput)
}

type GroupConfigStatusPtrOutput struct{ *pulumi.OutputState }

func (GroupConfigStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**GroupConfigStatus)(nil)).Elem()
}

func (o GroupConfigStatusPtrOutput) ToGroupConfigStatusPtrOutput() GroupConfigStatusPtrOutput {
	return o
}

func (o GroupConfigStatusPtrOutput) ToGroupConfigStatusPtrOutputWithContext(ctx context.Context) GroupConfigStatusPtrOutput {
	return o
}

func (o GroupConfigStatusPtrOutput) Elem() GroupConfigStatusOutput {
	return o.ApplyT(func(v *GroupConfigStatus) GroupConfigStatus { return *v }).(GroupConfigStatusOutput)
}

// ReconcileStatus this is the general status of the main reconciler
func (o GroupConfigStatusPtrOutput) Conditions() GroupConfigStatusConditionsArrayOutput {
	return o.ApplyT(func(v *GroupConfigStatus) []GroupConfigStatusConditions {
		if v == nil {
			return nil
		}
		return v.Conditions
	}).(GroupConfigStatusConditionsArrayOutput)
}

// LockedResourceStatuses contains the reconcile status for each of the managed resources
func (o GroupConfigStatusPtrOutput) LockedResourceStatuses() GroupConfigStatusLockedResourceStatusesArrayMapOutput {
	return o.ApplyT(func(v *GroupConfigStatus) map[string][]GroupConfigStatusLockedResourceStatuses {
		if v == nil {
			return nil
		}
		return v.LockedResourceStatuses
	}).(GroupConfigStatusLockedResourceStatusesArrayMapOutput)
}

// Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind.
//  Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
type GroupConfigStatusConditions struct {
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	Message            *string `pulumi:"message"`
	// ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
	Reason *string `pulumi:"reason"`
	Status string  `pulumi:"status"`
	// ConditionType is the type of the condition and is typically a CamelCased word or short phrase.
	//  Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
	Type string `pulumi:"type"`
}

// GroupConfigStatusConditionsInput is an input type that accepts GroupConfigStatusConditionsArgs and GroupConfigStatusConditionsOutput values.
// You can construct a concrete instance of `GroupConfigStatusConditionsInput` via:
//
//          GroupConfigStatusConditionsArgs{...}
type GroupConfigStatusConditionsInput interface {
	pulumi.Input

	ToGroupConfigStatusConditionsOutput() GroupConfigStatusConditionsOutput
	ToGroupConfigStatusConditionsOutputWithContext(context.Context) GroupConfigStatusConditionsOutput
}

// Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind.
//  Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
type GroupConfigStatusConditionsArgs struct {
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	Message            pulumi.StringPtrInput `pulumi:"message"`
	// ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	Status pulumi.StringInput    `pulumi:"status"`
	// ConditionType is the type of the condition and is typically a CamelCased word or short phrase.
	//  Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
	Type pulumi.StringInput `pulumi:"type"`
}

func (GroupConfigStatusConditionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GroupConfigStatusConditions)(nil)).Elem()
}

func (i GroupConfigStatusConditionsArgs) ToGroupConfigStatusConditionsOutput() GroupConfigStatusConditionsOutput {
	return i.ToGroupConfigStatusConditionsOutputWithContext(context.Background())
}

func (i GroupConfigStatusConditionsArgs) ToGroupConfigStatusConditionsOutputWithContext(ctx context.Context) GroupConfigStatusConditionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupConfigStatusConditionsOutput)
}

// GroupConfigStatusConditionsArrayInput is an input type that accepts GroupConfigStatusConditionsArray and GroupConfigStatusConditionsArrayOutput values.
// You can construct a concrete instance of `GroupConfigStatusConditionsArrayInput` via:
//
//          GroupConfigStatusConditionsArray{ GroupConfigStatusConditionsArgs{...} }
type GroupConfigStatusConditionsArrayInput interface {
	pulumi.Input

	ToGroupConfigStatusConditionsArrayOutput() GroupConfigStatusConditionsArrayOutput
	ToGroupConfigStatusConditionsArrayOutputWithContext(context.Context) GroupConfigStatusConditionsArrayOutput
}

type GroupConfigStatusConditionsArray []GroupConfigStatusConditionsInput

func (GroupConfigStatusConditionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GroupConfigStatusConditions)(nil)).Elem()
}

func (i GroupConfigStatusConditionsArray) ToGroupConfigStatusConditionsArrayOutput() GroupConfigStatusConditionsArrayOutput {
	return i.ToGroupConfigStatusConditionsArrayOutputWithContext(context.Background())
}

func (i GroupConfigStatusConditionsArray) ToGroupConfigStatusConditionsArrayOutputWithContext(ctx context.Context) GroupConfigStatusConditionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupConfigStatusConditionsArrayOutput)
}

// Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind.
//  Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
type GroupConfigStatusConditionsOutput struct{ *pulumi.OutputState }

func (GroupConfigStatusConditionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GroupConfigStatusConditions)(nil)).Elem()
}

func (o GroupConfigStatusConditionsOutput) ToGroupConfigStatusConditionsOutput() GroupConfigStatusConditionsOutput {
	return o
}

func (o GroupConfigStatusConditionsOutput) ToGroupConfigStatusConditionsOutputWithContext(ctx context.Context) GroupConfigStatusConditionsOutput {
	return o
}

func (o GroupConfigStatusConditionsOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GroupConfigStatusConditions) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

func (o GroupConfigStatusConditionsOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GroupConfigStatusConditions) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
func (o GroupConfigStatusConditionsOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GroupConfigStatusConditions) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

func (o GroupConfigStatusConditionsOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v GroupConfigStatusConditions) string { return v.Status }).(pulumi.StringOutput)
}

// ConditionType is the type of the condition and is typically a CamelCased word or short phrase.
//  Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
func (o GroupConfigStatusConditionsOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v GroupConfigStatusConditions) string { return v.Type }).(pulumi.StringOutput)
}

type GroupConfigStatusConditionsArrayOutput struct{ *pulumi.OutputState }

func (GroupConfigStatusConditionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GroupConfigStatusConditions)(nil)).Elem()
}

func (o GroupConfigStatusConditionsArrayOutput) ToGroupConfigStatusConditionsArrayOutput() GroupConfigStatusConditionsArrayOutput {
	return o
}

func (o GroupConfigStatusConditionsArrayOutput) ToGroupConfigStatusConditionsArrayOutputWithContext(ctx context.Context) GroupConfigStatusConditionsArrayOutput {
	return o
}

func (o GroupConfigStatusConditionsArrayOutput) Index(i pulumi.IntInput) GroupConfigStatusConditionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GroupConfigStatusConditions {
		return vs[0].([]GroupConfigStatusConditions)[vs[1].(int)]
	}).(GroupConfigStatusConditionsOutput)
}

// Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind.
//  Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
type GroupConfigStatusLockedResourceStatuses struct {
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	Message            *string `pulumi:"message"`
	// ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
	Reason *string `pulumi:"reason"`
	Status string  `pulumi:"status"`
	// ConditionType is the type of the condition and is typically a CamelCased word or short phrase.
	//  Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
	Type string `pulumi:"type"`
}

// GroupConfigStatusLockedResourceStatusesInput is an input type that accepts GroupConfigStatusLockedResourceStatusesArgs and GroupConfigStatusLockedResourceStatusesOutput values.
// You can construct a concrete instance of `GroupConfigStatusLockedResourceStatusesInput` via:
//
//          GroupConfigStatusLockedResourceStatusesArgs{...}
type GroupConfigStatusLockedResourceStatusesInput interface {
	pulumi.Input

	ToGroupConfigStatusLockedResourceStatusesOutput() GroupConfigStatusLockedResourceStatusesOutput
	ToGroupConfigStatusLockedResourceStatusesOutputWithContext(context.Context) GroupConfigStatusLockedResourceStatusesOutput
}

// Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind.
//  Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
type GroupConfigStatusLockedResourceStatusesArgs struct {
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	Message            pulumi.StringPtrInput `pulumi:"message"`
	// ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	Status pulumi.StringInput    `pulumi:"status"`
	// ConditionType is the type of the condition and is typically a CamelCased word or short phrase.
	//  Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
	Type pulumi.StringInput `pulumi:"type"`
}

func (GroupConfigStatusLockedResourceStatusesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*GroupConfigStatusLockedResourceStatuses)(nil)).Elem()
}

func (i GroupConfigStatusLockedResourceStatusesArgs) ToGroupConfigStatusLockedResourceStatusesOutput() GroupConfigStatusLockedResourceStatusesOutput {
	return i.ToGroupConfigStatusLockedResourceStatusesOutputWithContext(context.Background())
}

func (i GroupConfigStatusLockedResourceStatusesArgs) ToGroupConfigStatusLockedResourceStatusesOutputWithContext(ctx context.Context) GroupConfigStatusLockedResourceStatusesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupConfigStatusLockedResourceStatusesOutput)
}

// GroupConfigStatusLockedResourceStatusesArrayInput is an input type that accepts GroupConfigStatusLockedResourceStatusesArray and GroupConfigStatusLockedResourceStatusesArrayOutput values.
// You can construct a concrete instance of `GroupConfigStatusLockedResourceStatusesArrayInput` via:
//
//          GroupConfigStatusLockedResourceStatusesArray{ GroupConfigStatusLockedResourceStatusesArgs{...} }
type GroupConfigStatusLockedResourceStatusesArrayInput interface {
	pulumi.Input

	ToGroupConfigStatusLockedResourceStatusesArrayOutput() GroupConfigStatusLockedResourceStatusesArrayOutput
	ToGroupConfigStatusLockedResourceStatusesArrayOutputWithContext(context.Context) GroupConfigStatusLockedResourceStatusesArrayOutput
}

type GroupConfigStatusLockedResourceStatusesArray []GroupConfigStatusLockedResourceStatusesInput

func (GroupConfigStatusLockedResourceStatusesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GroupConfigStatusLockedResourceStatuses)(nil)).Elem()
}

func (i GroupConfigStatusLockedResourceStatusesArray) ToGroupConfigStatusLockedResourceStatusesArrayOutput() GroupConfigStatusLockedResourceStatusesArrayOutput {
	return i.ToGroupConfigStatusLockedResourceStatusesArrayOutputWithContext(context.Background())
}

func (i GroupConfigStatusLockedResourceStatusesArray) ToGroupConfigStatusLockedResourceStatusesArrayOutputWithContext(ctx context.Context) GroupConfigStatusLockedResourceStatusesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupConfigStatusLockedResourceStatusesArrayOutput)
}

// Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind.
//  Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
type GroupConfigStatusLockedResourceStatusesOutput struct{ *pulumi.OutputState }

func (GroupConfigStatusLockedResourceStatusesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*GroupConfigStatusLockedResourceStatuses)(nil)).Elem()
}

func (o GroupConfigStatusLockedResourceStatusesOutput) ToGroupConfigStatusLockedResourceStatusesOutput() GroupConfigStatusLockedResourceStatusesOutput {
	return o
}

func (o GroupConfigStatusLockedResourceStatusesOutput) ToGroupConfigStatusLockedResourceStatusesOutputWithContext(ctx context.Context) GroupConfigStatusLockedResourceStatusesOutput {
	return o
}

func (o GroupConfigStatusLockedResourceStatusesOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GroupConfigStatusLockedResourceStatuses) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

func (o GroupConfigStatusLockedResourceStatusesOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GroupConfigStatusLockedResourceStatuses) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
func (o GroupConfigStatusLockedResourceStatusesOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v GroupConfigStatusLockedResourceStatuses) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

func (o GroupConfigStatusLockedResourceStatusesOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v GroupConfigStatusLockedResourceStatuses) string { return v.Status }).(pulumi.StringOutput)
}

// ConditionType is the type of the condition and is typically a CamelCased word or short phrase.
//  Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
func (o GroupConfigStatusLockedResourceStatusesOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v GroupConfigStatusLockedResourceStatuses) string { return v.Type }).(pulumi.StringOutput)
}

type GroupConfigStatusLockedResourceStatusesArrayOutput struct{ *pulumi.OutputState }

func (GroupConfigStatusLockedResourceStatusesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]GroupConfigStatusLockedResourceStatuses)(nil)).Elem()
}

func (o GroupConfigStatusLockedResourceStatusesArrayOutput) ToGroupConfigStatusLockedResourceStatusesArrayOutput() GroupConfigStatusLockedResourceStatusesArrayOutput {
	return o
}

func (o GroupConfigStatusLockedResourceStatusesArrayOutput) ToGroupConfigStatusLockedResourceStatusesArrayOutputWithContext(ctx context.Context) GroupConfigStatusLockedResourceStatusesArrayOutput {
	return o
}

func (o GroupConfigStatusLockedResourceStatusesArrayOutput) Index(i pulumi.IntInput) GroupConfigStatusLockedResourceStatusesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) GroupConfigStatusLockedResourceStatuses {
		return vs[0].([]GroupConfigStatusLockedResourceStatuses)[vs[1].(int)]
	}).(GroupConfigStatusLockedResourceStatusesOutput)
}

// NamespaceConfig is the Schema for the nsconfigs API
type NamespaceConfigType struct {
	ApiVersion *string            `pulumi:"apiVersion"`
	Kind       *string            `pulumi:"kind"`
	Metadata   *metav1.ObjectMeta `pulumi:"metadata"`
	// NamespaceConfigSpec defines the desired state of NamespaceConfig There are two selectors: "labelSelector", "annotationSelector". Selectors are considered in AND, so if multiple are defined they must all be true for a Namespace to be selected.
	Spec *NamespaceConfigSpec `pulumi:"spec"`
	// NamespaceConfigStatus defines the observed state of NSConfig
	Status *NamespaceConfigStatus `pulumi:"status"`
}

// NamespaceConfigTypeInput is an input type that accepts NamespaceConfigTypeArgs and NamespaceConfigTypeOutput values.
// You can construct a concrete instance of `NamespaceConfigTypeInput` via:
//
//          NamespaceConfigTypeArgs{...}
type NamespaceConfigTypeInput interface {
	pulumi.Input

	ToNamespaceConfigTypeOutput() NamespaceConfigTypeOutput
	ToNamespaceConfigTypeOutputWithContext(context.Context) NamespaceConfigTypeOutput
}

// NamespaceConfig is the Schema for the nsconfigs API
type NamespaceConfigTypeArgs struct {
	ApiVersion pulumi.StringPtrInput     `pulumi:"apiVersion"`
	Kind       pulumi.StringPtrInput     `pulumi:"kind"`
	Metadata   metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	// NamespaceConfigSpec defines the desired state of NamespaceConfig There are two selectors: "labelSelector", "annotationSelector". Selectors are considered in AND, so if multiple are defined they must all be true for a Namespace to be selected.
	Spec NamespaceConfigSpecPtrInput `pulumi:"spec"`
	// NamespaceConfigStatus defines the observed state of NSConfig
	Status NamespaceConfigStatusPtrInput `pulumi:"status"`
}

func (NamespaceConfigTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NamespaceConfigType)(nil)).Elem()
}

func (i NamespaceConfigTypeArgs) ToNamespaceConfigTypeOutput() NamespaceConfigTypeOutput {
	return i.ToNamespaceConfigTypeOutputWithContext(context.Background())
}

func (i NamespaceConfigTypeArgs) ToNamespaceConfigTypeOutputWithContext(ctx context.Context) NamespaceConfigTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceConfigTypeOutput)
}

// NamespaceConfig is the Schema for the nsconfigs API
type NamespaceConfigTypeOutput struct{ *pulumi.OutputState }

func (NamespaceConfigTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NamespaceConfigType)(nil)).Elem()
}

func (o NamespaceConfigTypeOutput) ToNamespaceConfigTypeOutput() NamespaceConfigTypeOutput {
	return o
}

func (o NamespaceConfigTypeOutput) ToNamespaceConfigTypeOutputWithContext(ctx context.Context) NamespaceConfigTypeOutput {
	return o
}

func (o NamespaceConfigTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NamespaceConfigType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

func (o NamespaceConfigTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NamespaceConfigType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

func (o NamespaceConfigTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v NamespaceConfigType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

// NamespaceConfigSpec defines the desired state of NamespaceConfig There are two selectors: "labelSelector", "annotationSelector". Selectors are considered in AND, so if multiple are defined they must all be true for a Namespace to be selected.
func (o NamespaceConfigTypeOutput) Spec() NamespaceConfigSpecPtrOutput {
	return o.ApplyT(func(v NamespaceConfigType) *NamespaceConfigSpec { return v.Spec }).(NamespaceConfigSpecPtrOutput)
}

// NamespaceConfigStatus defines the observed state of NSConfig
func (o NamespaceConfigTypeOutput) Status() NamespaceConfigStatusPtrOutput {
	return o.ApplyT(func(v NamespaceConfigType) *NamespaceConfigStatus { return v.Status }).(NamespaceConfigStatusPtrOutput)
}

type NamespaceConfigMetadata struct {
}

// NamespaceConfigMetadataInput is an input type that accepts NamespaceConfigMetadataArgs and NamespaceConfigMetadataOutput values.
// You can construct a concrete instance of `NamespaceConfigMetadataInput` via:
//
//          NamespaceConfigMetadataArgs{...}
type NamespaceConfigMetadataInput interface {
	pulumi.Input

	ToNamespaceConfigMetadataOutput() NamespaceConfigMetadataOutput
	ToNamespaceConfigMetadataOutputWithContext(context.Context) NamespaceConfigMetadataOutput
}

type NamespaceConfigMetadataArgs struct {
}

func (NamespaceConfigMetadataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NamespaceConfigMetadata)(nil)).Elem()
}

func (i NamespaceConfigMetadataArgs) ToNamespaceConfigMetadataOutput() NamespaceConfigMetadataOutput {
	return i.ToNamespaceConfigMetadataOutputWithContext(context.Background())
}

func (i NamespaceConfigMetadataArgs) ToNamespaceConfigMetadataOutputWithContext(ctx context.Context) NamespaceConfigMetadataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceConfigMetadataOutput)
}

type NamespaceConfigMetadataOutput struct{ *pulumi.OutputState }

func (NamespaceConfigMetadataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NamespaceConfigMetadata)(nil)).Elem()
}

func (o NamespaceConfigMetadataOutput) ToNamespaceConfigMetadataOutput() NamespaceConfigMetadataOutput {
	return o
}

func (o NamespaceConfigMetadataOutput) ToNamespaceConfigMetadataOutputWithContext(ctx context.Context) NamespaceConfigMetadataOutput {
	return o
}

// NamespaceConfigSpec defines the desired state of NamespaceConfig There are two selectors: "labelSelector", "annotationSelector". Selectors are considered in AND, so if multiple are defined they must all be true for a Namespace to be selected.
type NamespaceConfigSpec struct {
	// AnnotationSelector selects Namespaces by annotation.
	AnnotationSelector *NamespaceConfigSpecAnnotationSelector `pulumi:"annotationSelector"`
	// LabelSelector selects Namespaces by label.
	LabelSelector *NamespaceConfigSpecLabelSelector `pulumi:"labelSelector"`
	Templates     []NamespaceConfigSpecTemplates    `pulumi:"templates"`
}

// NamespaceConfigSpecInput is an input type that accepts NamespaceConfigSpecArgs and NamespaceConfigSpecOutput values.
// You can construct a concrete instance of `NamespaceConfigSpecInput` via:
//
//          NamespaceConfigSpecArgs{...}
type NamespaceConfigSpecInput interface {
	pulumi.Input

	ToNamespaceConfigSpecOutput() NamespaceConfigSpecOutput
	ToNamespaceConfigSpecOutputWithContext(context.Context) NamespaceConfigSpecOutput
}

// NamespaceConfigSpec defines the desired state of NamespaceConfig There are two selectors: "labelSelector", "annotationSelector". Selectors are considered in AND, so if multiple are defined they must all be true for a Namespace to be selected.
type NamespaceConfigSpecArgs struct {
	// AnnotationSelector selects Namespaces by annotation.
	AnnotationSelector NamespaceConfigSpecAnnotationSelectorPtrInput `pulumi:"annotationSelector"`
	// LabelSelector selects Namespaces by label.
	LabelSelector NamespaceConfigSpecLabelSelectorPtrInput `pulumi:"labelSelector"`
	Templates     NamespaceConfigSpecTemplatesArrayInput   `pulumi:"templates"`
}

func (NamespaceConfigSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NamespaceConfigSpec)(nil)).Elem()
}

func (i NamespaceConfigSpecArgs) ToNamespaceConfigSpecOutput() NamespaceConfigSpecOutput {
	return i.ToNamespaceConfigSpecOutputWithContext(context.Background())
}

func (i NamespaceConfigSpecArgs) ToNamespaceConfigSpecOutputWithContext(ctx context.Context) NamespaceConfigSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceConfigSpecOutput)
}

func (i NamespaceConfigSpecArgs) ToNamespaceConfigSpecPtrOutput() NamespaceConfigSpecPtrOutput {
	return i.ToNamespaceConfigSpecPtrOutputWithContext(context.Background())
}

func (i NamespaceConfigSpecArgs) ToNamespaceConfigSpecPtrOutputWithContext(ctx context.Context) NamespaceConfigSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceConfigSpecOutput).ToNamespaceConfigSpecPtrOutputWithContext(ctx)
}

// NamespaceConfigSpecPtrInput is an input type that accepts NamespaceConfigSpecArgs, NamespaceConfigSpecPtr and NamespaceConfigSpecPtrOutput values.
// You can construct a concrete instance of `NamespaceConfigSpecPtrInput` via:
//
//          NamespaceConfigSpecArgs{...}
//
//  or:
//
//          nil
type NamespaceConfigSpecPtrInput interface {
	pulumi.Input

	ToNamespaceConfigSpecPtrOutput() NamespaceConfigSpecPtrOutput
	ToNamespaceConfigSpecPtrOutputWithContext(context.Context) NamespaceConfigSpecPtrOutput
}

type namespaceConfigSpecPtrType NamespaceConfigSpecArgs

func NamespaceConfigSpecPtr(v *NamespaceConfigSpecArgs) NamespaceConfigSpecPtrInput {
	return (*namespaceConfigSpecPtrType)(v)
}

func (*namespaceConfigSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**NamespaceConfigSpec)(nil)).Elem()
}

func (i *namespaceConfigSpecPtrType) ToNamespaceConfigSpecPtrOutput() NamespaceConfigSpecPtrOutput {
	return i.ToNamespaceConfigSpecPtrOutputWithContext(context.Background())
}

func (i *namespaceConfigSpecPtrType) ToNamespaceConfigSpecPtrOutputWithContext(ctx context.Context) NamespaceConfigSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceConfigSpecPtrOutput)
}

// NamespaceConfigSpec defines the desired state of NamespaceConfig There are two selectors: "labelSelector", "annotationSelector". Selectors are considered in AND, so if multiple are defined they must all be true for a Namespace to be selected.
type NamespaceConfigSpecOutput struct{ *pulumi.OutputState }

func (NamespaceConfigSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NamespaceConfigSpec)(nil)).Elem()
}

func (o NamespaceConfigSpecOutput) ToNamespaceConfigSpecOutput() NamespaceConfigSpecOutput {
	return o
}

func (o NamespaceConfigSpecOutput) ToNamespaceConfigSpecOutputWithContext(ctx context.Context) NamespaceConfigSpecOutput {
	return o
}

func (o NamespaceConfigSpecOutput) ToNamespaceConfigSpecPtrOutput() NamespaceConfigSpecPtrOutput {
	return o.ToNamespaceConfigSpecPtrOutputWithContext(context.Background())
}

func (o NamespaceConfigSpecOutput) ToNamespaceConfigSpecPtrOutputWithContext(ctx context.Context) NamespaceConfigSpecPtrOutput {
	return o.ApplyT(func(v NamespaceConfigSpec) *NamespaceConfigSpec {
		return &v
	}).(NamespaceConfigSpecPtrOutput)
}

// AnnotationSelector selects Namespaces by annotation.
func (o NamespaceConfigSpecOutput) AnnotationSelector() NamespaceConfigSpecAnnotationSelectorPtrOutput {
	return o.ApplyT(func(v NamespaceConfigSpec) *NamespaceConfigSpecAnnotationSelector { return v.AnnotationSelector }).(NamespaceConfigSpecAnnotationSelectorPtrOutput)
}

// LabelSelector selects Namespaces by label.
func (o NamespaceConfigSpecOutput) LabelSelector() NamespaceConfigSpecLabelSelectorPtrOutput {
	return o.ApplyT(func(v NamespaceConfigSpec) *NamespaceConfigSpecLabelSelector { return v.LabelSelector }).(NamespaceConfigSpecLabelSelectorPtrOutput)
}

func (o NamespaceConfigSpecOutput) Templates() NamespaceConfigSpecTemplatesArrayOutput {
	return o.ApplyT(func(v NamespaceConfigSpec) []NamespaceConfigSpecTemplates { return v.Templates }).(NamespaceConfigSpecTemplatesArrayOutput)
}

type NamespaceConfigSpecPtrOutput struct{ *pulumi.OutputState }

func (NamespaceConfigSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NamespaceConfigSpec)(nil)).Elem()
}

func (o NamespaceConfigSpecPtrOutput) ToNamespaceConfigSpecPtrOutput() NamespaceConfigSpecPtrOutput {
	return o
}

func (o NamespaceConfigSpecPtrOutput) ToNamespaceConfigSpecPtrOutputWithContext(ctx context.Context) NamespaceConfigSpecPtrOutput {
	return o
}

func (o NamespaceConfigSpecPtrOutput) Elem() NamespaceConfigSpecOutput {
	return o.ApplyT(func(v *NamespaceConfigSpec) NamespaceConfigSpec { return *v }).(NamespaceConfigSpecOutput)
}

// AnnotationSelector selects Namespaces by annotation.
func (o NamespaceConfigSpecPtrOutput) AnnotationSelector() NamespaceConfigSpecAnnotationSelectorPtrOutput {
	return o.ApplyT(func(v *NamespaceConfigSpec) *NamespaceConfigSpecAnnotationSelector {
		if v == nil {
			return nil
		}
		return v.AnnotationSelector
	}).(NamespaceConfigSpecAnnotationSelectorPtrOutput)
}

// LabelSelector selects Namespaces by label.
func (o NamespaceConfigSpecPtrOutput) LabelSelector() NamespaceConfigSpecLabelSelectorPtrOutput {
	return o.ApplyT(func(v *NamespaceConfigSpec) *NamespaceConfigSpecLabelSelector {
		if v == nil {
			return nil
		}
		return v.LabelSelector
	}).(NamespaceConfigSpecLabelSelectorPtrOutput)
}

func (o NamespaceConfigSpecPtrOutput) Templates() NamespaceConfigSpecTemplatesArrayOutput {
	return o.ApplyT(func(v *NamespaceConfigSpec) []NamespaceConfigSpecTemplates {
		if v == nil {
			return nil
		}
		return v.Templates
	}).(NamespaceConfigSpecTemplatesArrayOutput)
}

// AnnotationSelector selects Namespaces by annotation.
type NamespaceConfigSpecAnnotationSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []NamespaceConfigSpecAnnotationSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// NamespaceConfigSpecAnnotationSelectorInput is an input type that accepts NamespaceConfigSpecAnnotationSelectorArgs and NamespaceConfigSpecAnnotationSelectorOutput values.
// You can construct a concrete instance of `NamespaceConfigSpecAnnotationSelectorInput` via:
//
//          NamespaceConfigSpecAnnotationSelectorArgs{...}
type NamespaceConfigSpecAnnotationSelectorInput interface {
	pulumi.Input

	ToNamespaceConfigSpecAnnotationSelectorOutput() NamespaceConfigSpecAnnotationSelectorOutput
	ToNamespaceConfigSpecAnnotationSelectorOutputWithContext(context.Context) NamespaceConfigSpecAnnotationSelectorOutput
}

// AnnotationSelector selects Namespaces by annotation.
type NamespaceConfigSpecAnnotationSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions NamespaceConfigSpecAnnotationSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (NamespaceConfigSpecAnnotationSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NamespaceConfigSpecAnnotationSelector)(nil)).Elem()
}

func (i NamespaceConfigSpecAnnotationSelectorArgs) ToNamespaceConfigSpecAnnotationSelectorOutput() NamespaceConfigSpecAnnotationSelectorOutput {
	return i.ToNamespaceConfigSpecAnnotationSelectorOutputWithContext(context.Background())
}

func (i NamespaceConfigSpecAnnotationSelectorArgs) ToNamespaceConfigSpecAnnotationSelectorOutputWithContext(ctx context.Context) NamespaceConfigSpecAnnotationSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceConfigSpecAnnotationSelectorOutput)
}

func (i NamespaceConfigSpecAnnotationSelectorArgs) ToNamespaceConfigSpecAnnotationSelectorPtrOutput() NamespaceConfigSpecAnnotationSelectorPtrOutput {
	return i.ToNamespaceConfigSpecAnnotationSelectorPtrOutputWithContext(context.Background())
}

func (i NamespaceConfigSpecAnnotationSelectorArgs) ToNamespaceConfigSpecAnnotationSelectorPtrOutputWithContext(ctx context.Context) NamespaceConfigSpecAnnotationSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceConfigSpecAnnotationSelectorOutput).ToNamespaceConfigSpecAnnotationSelectorPtrOutputWithContext(ctx)
}

// NamespaceConfigSpecAnnotationSelectorPtrInput is an input type that accepts NamespaceConfigSpecAnnotationSelectorArgs, NamespaceConfigSpecAnnotationSelectorPtr and NamespaceConfigSpecAnnotationSelectorPtrOutput values.
// You can construct a concrete instance of `NamespaceConfigSpecAnnotationSelectorPtrInput` via:
//
//          NamespaceConfigSpecAnnotationSelectorArgs{...}
//
//  or:
//
//          nil
type NamespaceConfigSpecAnnotationSelectorPtrInput interface {
	pulumi.Input

	ToNamespaceConfigSpecAnnotationSelectorPtrOutput() NamespaceConfigSpecAnnotationSelectorPtrOutput
	ToNamespaceConfigSpecAnnotationSelectorPtrOutputWithContext(context.Context) NamespaceConfigSpecAnnotationSelectorPtrOutput
}

type namespaceConfigSpecAnnotationSelectorPtrType NamespaceConfigSpecAnnotationSelectorArgs

func NamespaceConfigSpecAnnotationSelectorPtr(v *NamespaceConfigSpecAnnotationSelectorArgs) NamespaceConfigSpecAnnotationSelectorPtrInput {
	return (*namespaceConfigSpecAnnotationSelectorPtrType)(v)
}

func (*namespaceConfigSpecAnnotationSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**NamespaceConfigSpecAnnotationSelector)(nil)).Elem()
}

func (i *namespaceConfigSpecAnnotationSelectorPtrType) ToNamespaceConfigSpecAnnotationSelectorPtrOutput() NamespaceConfigSpecAnnotationSelectorPtrOutput {
	return i.ToNamespaceConfigSpecAnnotationSelectorPtrOutputWithContext(context.Background())
}

func (i *namespaceConfigSpecAnnotationSelectorPtrType) ToNamespaceConfigSpecAnnotationSelectorPtrOutputWithContext(ctx context.Context) NamespaceConfigSpecAnnotationSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceConfigSpecAnnotationSelectorPtrOutput)
}

// AnnotationSelector selects Namespaces by annotation.
type NamespaceConfigSpecAnnotationSelectorOutput struct{ *pulumi.OutputState }

func (NamespaceConfigSpecAnnotationSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NamespaceConfigSpecAnnotationSelector)(nil)).Elem()
}

func (o NamespaceConfigSpecAnnotationSelectorOutput) ToNamespaceConfigSpecAnnotationSelectorOutput() NamespaceConfigSpecAnnotationSelectorOutput {
	return o
}

func (o NamespaceConfigSpecAnnotationSelectorOutput) ToNamespaceConfigSpecAnnotationSelectorOutputWithContext(ctx context.Context) NamespaceConfigSpecAnnotationSelectorOutput {
	return o
}

func (o NamespaceConfigSpecAnnotationSelectorOutput) ToNamespaceConfigSpecAnnotationSelectorPtrOutput() NamespaceConfigSpecAnnotationSelectorPtrOutput {
	return o.ToNamespaceConfigSpecAnnotationSelectorPtrOutputWithContext(context.Background())
}

func (o NamespaceConfigSpecAnnotationSelectorOutput) ToNamespaceConfigSpecAnnotationSelectorPtrOutputWithContext(ctx context.Context) NamespaceConfigSpecAnnotationSelectorPtrOutput {
	return o.ApplyT(func(v NamespaceConfigSpecAnnotationSelector) *NamespaceConfigSpecAnnotationSelector {
		return &v
	}).(NamespaceConfigSpecAnnotationSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o NamespaceConfigSpecAnnotationSelectorOutput) MatchExpressions() NamespaceConfigSpecAnnotationSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v NamespaceConfigSpecAnnotationSelector) []NamespaceConfigSpecAnnotationSelectorMatchExpressions {
		return v.MatchExpressions
	}).(NamespaceConfigSpecAnnotationSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o NamespaceConfigSpecAnnotationSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v NamespaceConfigSpecAnnotationSelector) map[string]string { return v.MatchLabels }).(pulumi.StringMapOutput)
}

type NamespaceConfigSpecAnnotationSelectorPtrOutput struct{ *pulumi.OutputState }

func (NamespaceConfigSpecAnnotationSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NamespaceConfigSpecAnnotationSelector)(nil)).Elem()
}

func (o NamespaceConfigSpecAnnotationSelectorPtrOutput) ToNamespaceConfigSpecAnnotationSelectorPtrOutput() NamespaceConfigSpecAnnotationSelectorPtrOutput {
	return o
}

func (o NamespaceConfigSpecAnnotationSelectorPtrOutput) ToNamespaceConfigSpecAnnotationSelectorPtrOutputWithContext(ctx context.Context) NamespaceConfigSpecAnnotationSelectorPtrOutput {
	return o
}

func (o NamespaceConfigSpecAnnotationSelectorPtrOutput) Elem() NamespaceConfigSpecAnnotationSelectorOutput {
	return o.ApplyT(func(v *NamespaceConfigSpecAnnotationSelector) NamespaceConfigSpecAnnotationSelector { return *v }).(NamespaceConfigSpecAnnotationSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o NamespaceConfigSpecAnnotationSelectorPtrOutput) MatchExpressions() NamespaceConfigSpecAnnotationSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *NamespaceConfigSpecAnnotationSelector) []NamespaceConfigSpecAnnotationSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(NamespaceConfigSpecAnnotationSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o NamespaceConfigSpecAnnotationSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *NamespaceConfigSpecAnnotationSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type NamespaceConfigSpecAnnotationSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// NamespaceConfigSpecAnnotationSelectorMatchExpressionsInput is an input type that accepts NamespaceConfigSpecAnnotationSelectorMatchExpressionsArgs and NamespaceConfigSpecAnnotationSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `NamespaceConfigSpecAnnotationSelectorMatchExpressionsInput` via:
//
//          NamespaceConfigSpecAnnotationSelectorMatchExpressionsArgs{...}
type NamespaceConfigSpecAnnotationSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToNamespaceConfigSpecAnnotationSelectorMatchExpressionsOutput() NamespaceConfigSpecAnnotationSelectorMatchExpressionsOutput
	ToNamespaceConfigSpecAnnotationSelectorMatchExpressionsOutputWithContext(context.Context) NamespaceConfigSpecAnnotationSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type NamespaceConfigSpecAnnotationSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (NamespaceConfigSpecAnnotationSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NamespaceConfigSpecAnnotationSelectorMatchExpressions)(nil)).Elem()
}

func (i NamespaceConfigSpecAnnotationSelectorMatchExpressionsArgs) ToNamespaceConfigSpecAnnotationSelectorMatchExpressionsOutput() NamespaceConfigSpecAnnotationSelectorMatchExpressionsOutput {
	return i.ToNamespaceConfigSpecAnnotationSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i NamespaceConfigSpecAnnotationSelectorMatchExpressionsArgs) ToNamespaceConfigSpecAnnotationSelectorMatchExpressionsOutputWithContext(ctx context.Context) NamespaceConfigSpecAnnotationSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceConfigSpecAnnotationSelectorMatchExpressionsOutput)
}

// NamespaceConfigSpecAnnotationSelectorMatchExpressionsArrayInput is an input type that accepts NamespaceConfigSpecAnnotationSelectorMatchExpressionsArray and NamespaceConfigSpecAnnotationSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `NamespaceConfigSpecAnnotationSelectorMatchExpressionsArrayInput` via:
//
//          NamespaceConfigSpecAnnotationSelectorMatchExpressionsArray{ NamespaceConfigSpecAnnotationSelectorMatchExpressionsArgs{...} }
type NamespaceConfigSpecAnnotationSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToNamespaceConfigSpecAnnotationSelectorMatchExpressionsArrayOutput() NamespaceConfigSpecAnnotationSelectorMatchExpressionsArrayOutput
	ToNamespaceConfigSpecAnnotationSelectorMatchExpressionsArrayOutputWithContext(context.Context) NamespaceConfigSpecAnnotationSelectorMatchExpressionsArrayOutput
}

type NamespaceConfigSpecAnnotationSelectorMatchExpressionsArray []NamespaceConfigSpecAnnotationSelectorMatchExpressionsInput

func (NamespaceConfigSpecAnnotationSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NamespaceConfigSpecAnnotationSelectorMatchExpressions)(nil)).Elem()
}

func (i NamespaceConfigSpecAnnotationSelectorMatchExpressionsArray) ToNamespaceConfigSpecAnnotationSelectorMatchExpressionsArrayOutput() NamespaceConfigSpecAnnotationSelectorMatchExpressionsArrayOutput {
	return i.ToNamespaceConfigSpecAnnotationSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i NamespaceConfigSpecAnnotationSelectorMatchExpressionsArray) ToNamespaceConfigSpecAnnotationSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) NamespaceConfigSpecAnnotationSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceConfigSpecAnnotationSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type NamespaceConfigSpecAnnotationSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (NamespaceConfigSpecAnnotationSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NamespaceConfigSpecAnnotationSelectorMatchExpressions)(nil)).Elem()
}

func (o NamespaceConfigSpecAnnotationSelectorMatchExpressionsOutput) ToNamespaceConfigSpecAnnotationSelectorMatchExpressionsOutput() NamespaceConfigSpecAnnotationSelectorMatchExpressionsOutput {
	return o
}

func (o NamespaceConfigSpecAnnotationSelectorMatchExpressionsOutput) ToNamespaceConfigSpecAnnotationSelectorMatchExpressionsOutputWithContext(ctx context.Context) NamespaceConfigSpecAnnotationSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o NamespaceConfigSpecAnnotationSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v NamespaceConfigSpecAnnotationSelectorMatchExpressions) string { return v.Key }).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
func (o NamespaceConfigSpecAnnotationSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v NamespaceConfigSpecAnnotationSelectorMatchExpressions) string { return v.Operator }).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
func (o NamespaceConfigSpecAnnotationSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NamespaceConfigSpecAnnotationSelectorMatchExpressions) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type NamespaceConfigSpecAnnotationSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (NamespaceConfigSpecAnnotationSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NamespaceConfigSpecAnnotationSelectorMatchExpressions)(nil)).Elem()
}

func (o NamespaceConfigSpecAnnotationSelectorMatchExpressionsArrayOutput) ToNamespaceConfigSpecAnnotationSelectorMatchExpressionsArrayOutput() NamespaceConfigSpecAnnotationSelectorMatchExpressionsArrayOutput {
	return o
}

func (o NamespaceConfigSpecAnnotationSelectorMatchExpressionsArrayOutput) ToNamespaceConfigSpecAnnotationSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) NamespaceConfigSpecAnnotationSelectorMatchExpressionsArrayOutput {
	return o
}

func (o NamespaceConfigSpecAnnotationSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) NamespaceConfigSpecAnnotationSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) NamespaceConfigSpecAnnotationSelectorMatchExpressions {
		return vs[0].([]NamespaceConfigSpecAnnotationSelectorMatchExpressions)[vs[1].(int)]
	}).(NamespaceConfigSpecAnnotationSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type NamespaceConfigSpecAnnotationSelectorMatchLabels struct {
}

// NamespaceConfigSpecAnnotationSelectorMatchLabelsInput is an input type that accepts NamespaceConfigSpecAnnotationSelectorMatchLabelsArgs and NamespaceConfigSpecAnnotationSelectorMatchLabelsOutput values.
// You can construct a concrete instance of `NamespaceConfigSpecAnnotationSelectorMatchLabelsInput` via:
//
//          NamespaceConfigSpecAnnotationSelectorMatchLabelsArgs{...}
type NamespaceConfigSpecAnnotationSelectorMatchLabelsInput interface {
	pulumi.Input

	ToNamespaceConfigSpecAnnotationSelectorMatchLabelsOutput() NamespaceConfigSpecAnnotationSelectorMatchLabelsOutput
	ToNamespaceConfigSpecAnnotationSelectorMatchLabelsOutputWithContext(context.Context) NamespaceConfigSpecAnnotationSelectorMatchLabelsOutput
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type NamespaceConfigSpecAnnotationSelectorMatchLabelsArgs struct {
}

func (NamespaceConfigSpecAnnotationSelectorMatchLabelsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NamespaceConfigSpecAnnotationSelectorMatchLabels)(nil)).Elem()
}

func (i NamespaceConfigSpecAnnotationSelectorMatchLabelsArgs) ToNamespaceConfigSpecAnnotationSelectorMatchLabelsOutput() NamespaceConfigSpecAnnotationSelectorMatchLabelsOutput {
	return i.ToNamespaceConfigSpecAnnotationSelectorMatchLabelsOutputWithContext(context.Background())
}

func (i NamespaceConfigSpecAnnotationSelectorMatchLabelsArgs) ToNamespaceConfigSpecAnnotationSelectorMatchLabelsOutputWithContext(ctx context.Context) NamespaceConfigSpecAnnotationSelectorMatchLabelsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceConfigSpecAnnotationSelectorMatchLabelsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type NamespaceConfigSpecAnnotationSelectorMatchLabelsOutput struct{ *pulumi.OutputState }

func (NamespaceConfigSpecAnnotationSelectorMatchLabelsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NamespaceConfigSpecAnnotationSelectorMatchLabels)(nil)).Elem()
}

func (o NamespaceConfigSpecAnnotationSelectorMatchLabelsOutput) ToNamespaceConfigSpecAnnotationSelectorMatchLabelsOutput() NamespaceConfigSpecAnnotationSelectorMatchLabelsOutput {
	return o
}

func (o NamespaceConfigSpecAnnotationSelectorMatchLabelsOutput) ToNamespaceConfigSpecAnnotationSelectorMatchLabelsOutputWithContext(ctx context.Context) NamespaceConfigSpecAnnotationSelectorMatchLabelsOutput {
	return o
}

// LabelSelector selects Namespaces by label.
type NamespaceConfigSpecLabelSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []NamespaceConfigSpecLabelSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// NamespaceConfigSpecLabelSelectorInput is an input type that accepts NamespaceConfigSpecLabelSelectorArgs and NamespaceConfigSpecLabelSelectorOutput values.
// You can construct a concrete instance of `NamespaceConfigSpecLabelSelectorInput` via:
//
//          NamespaceConfigSpecLabelSelectorArgs{...}
type NamespaceConfigSpecLabelSelectorInput interface {
	pulumi.Input

	ToNamespaceConfigSpecLabelSelectorOutput() NamespaceConfigSpecLabelSelectorOutput
	ToNamespaceConfigSpecLabelSelectorOutputWithContext(context.Context) NamespaceConfigSpecLabelSelectorOutput
}

// LabelSelector selects Namespaces by label.
type NamespaceConfigSpecLabelSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions NamespaceConfigSpecLabelSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (NamespaceConfigSpecLabelSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NamespaceConfigSpecLabelSelector)(nil)).Elem()
}

func (i NamespaceConfigSpecLabelSelectorArgs) ToNamespaceConfigSpecLabelSelectorOutput() NamespaceConfigSpecLabelSelectorOutput {
	return i.ToNamespaceConfigSpecLabelSelectorOutputWithContext(context.Background())
}

func (i NamespaceConfigSpecLabelSelectorArgs) ToNamespaceConfigSpecLabelSelectorOutputWithContext(ctx context.Context) NamespaceConfigSpecLabelSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceConfigSpecLabelSelectorOutput)
}

func (i NamespaceConfigSpecLabelSelectorArgs) ToNamespaceConfigSpecLabelSelectorPtrOutput() NamespaceConfigSpecLabelSelectorPtrOutput {
	return i.ToNamespaceConfigSpecLabelSelectorPtrOutputWithContext(context.Background())
}

func (i NamespaceConfigSpecLabelSelectorArgs) ToNamespaceConfigSpecLabelSelectorPtrOutputWithContext(ctx context.Context) NamespaceConfigSpecLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceConfigSpecLabelSelectorOutput).ToNamespaceConfigSpecLabelSelectorPtrOutputWithContext(ctx)
}

// NamespaceConfigSpecLabelSelectorPtrInput is an input type that accepts NamespaceConfigSpecLabelSelectorArgs, NamespaceConfigSpecLabelSelectorPtr and NamespaceConfigSpecLabelSelectorPtrOutput values.
// You can construct a concrete instance of `NamespaceConfigSpecLabelSelectorPtrInput` via:
//
//          NamespaceConfigSpecLabelSelectorArgs{...}
//
//  or:
//
//          nil
type NamespaceConfigSpecLabelSelectorPtrInput interface {
	pulumi.Input

	ToNamespaceConfigSpecLabelSelectorPtrOutput() NamespaceConfigSpecLabelSelectorPtrOutput
	ToNamespaceConfigSpecLabelSelectorPtrOutputWithContext(context.Context) NamespaceConfigSpecLabelSelectorPtrOutput
}

type namespaceConfigSpecLabelSelectorPtrType NamespaceConfigSpecLabelSelectorArgs

func NamespaceConfigSpecLabelSelectorPtr(v *NamespaceConfigSpecLabelSelectorArgs) NamespaceConfigSpecLabelSelectorPtrInput {
	return (*namespaceConfigSpecLabelSelectorPtrType)(v)
}

func (*namespaceConfigSpecLabelSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**NamespaceConfigSpecLabelSelector)(nil)).Elem()
}

func (i *namespaceConfigSpecLabelSelectorPtrType) ToNamespaceConfigSpecLabelSelectorPtrOutput() NamespaceConfigSpecLabelSelectorPtrOutput {
	return i.ToNamespaceConfigSpecLabelSelectorPtrOutputWithContext(context.Background())
}

func (i *namespaceConfigSpecLabelSelectorPtrType) ToNamespaceConfigSpecLabelSelectorPtrOutputWithContext(ctx context.Context) NamespaceConfigSpecLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceConfigSpecLabelSelectorPtrOutput)
}

// LabelSelector selects Namespaces by label.
type NamespaceConfigSpecLabelSelectorOutput struct{ *pulumi.OutputState }

func (NamespaceConfigSpecLabelSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NamespaceConfigSpecLabelSelector)(nil)).Elem()
}

func (o NamespaceConfigSpecLabelSelectorOutput) ToNamespaceConfigSpecLabelSelectorOutput() NamespaceConfigSpecLabelSelectorOutput {
	return o
}

func (o NamespaceConfigSpecLabelSelectorOutput) ToNamespaceConfigSpecLabelSelectorOutputWithContext(ctx context.Context) NamespaceConfigSpecLabelSelectorOutput {
	return o
}

func (o NamespaceConfigSpecLabelSelectorOutput) ToNamespaceConfigSpecLabelSelectorPtrOutput() NamespaceConfigSpecLabelSelectorPtrOutput {
	return o.ToNamespaceConfigSpecLabelSelectorPtrOutputWithContext(context.Background())
}

func (o NamespaceConfigSpecLabelSelectorOutput) ToNamespaceConfigSpecLabelSelectorPtrOutputWithContext(ctx context.Context) NamespaceConfigSpecLabelSelectorPtrOutput {
	return o.ApplyT(func(v NamespaceConfigSpecLabelSelector) *NamespaceConfigSpecLabelSelector {
		return &v
	}).(NamespaceConfigSpecLabelSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o NamespaceConfigSpecLabelSelectorOutput) MatchExpressions() NamespaceConfigSpecLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v NamespaceConfigSpecLabelSelector) []NamespaceConfigSpecLabelSelectorMatchExpressions {
		return v.MatchExpressions
	}).(NamespaceConfigSpecLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o NamespaceConfigSpecLabelSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v NamespaceConfigSpecLabelSelector) map[string]string { return v.MatchLabels }).(pulumi.StringMapOutput)
}

type NamespaceConfigSpecLabelSelectorPtrOutput struct{ *pulumi.OutputState }

func (NamespaceConfigSpecLabelSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NamespaceConfigSpecLabelSelector)(nil)).Elem()
}

func (o NamespaceConfigSpecLabelSelectorPtrOutput) ToNamespaceConfigSpecLabelSelectorPtrOutput() NamespaceConfigSpecLabelSelectorPtrOutput {
	return o
}

func (o NamespaceConfigSpecLabelSelectorPtrOutput) ToNamespaceConfigSpecLabelSelectorPtrOutputWithContext(ctx context.Context) NamespaceConfigSpecLabelSelectorPtrOutput {
	return o
}

func (o NamespaceConfigSpecLabelSelectorPtrOutput) Elem() NamespaceConfigSpecLabelSelectorOutput {
	return o.ApplyT(func(v *NamespaceConfigSpecLabelSelector) NamespaceConfigSpecLabelSelector { return *v }).(NamespaceConfigSpecLabelSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o NamespaceConfigSpecLabelSelectorPtrOutput) MatchExpressions() NamespaceConfigSpecLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *NamespaceConfigSpecLabelSelector) []NamespaceConfigSpecLabelSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(NamespaceConfigSpecLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o NamespaceConfigSpecLabelSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *NamespaceConfigSpecLabelSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type NamespaceConfigSpecLabelSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// NamespaceConfigSpecLabelSelectorMatchExpressionsInput is an input type that accepts NamespaceConfigSpecLabelSelectorMatchExpressionsArgs and NamespaceConfigSpecLabelSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `NamespaceConfigSpecLabelSelectorMatchExpressionsInput` via:
//
//          NamespaceConfigSpecLabelSelectorMatchExpressionsArgs{...}
type NamespaceConfigSpecLabelSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToNamespaceConfigSpecLabelSelectorMatchExpressionsOutput() NamespaceConfigSpecLabelSelectorMatchExpressionsOutput
	ToNamespaceConfigSpecLabelSelectorMatchExpressionsOutputWithContext(context.Context) NamespaceConfigSpecLabelSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type NamespaceConfigSpecLabelSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (NamespaceConfigSpecLabelSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NamespaceConfigSpecLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i NamespaceConfigSpecLabelSelectorMatchExpressionsArgs) ToNamespaceConfigSpecLabelSelectorMatchExpressionsOutput() NamespaceConfigSpecLabelSelectorMatchExpressionsOutput {
	return i.ToNamespaceConfigSpecLabelSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i NamespaceConfigSpecLabelSelectorMatchExpressionsArgs) ToNamespaceConfigSpecLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) NamespaceConfigSpecLabelSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceConfigSpecLabelSelectorMatchExpressionsOutput)
}

// NamespaceConfigSpecLabelSelectorMatchExpressionsArrayInput is an input type that accepts NamespaceConfigSpecLabelSelectorMatchExpressionsArray and NamespaceConfigSpecLabelSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `NamespaceConfigSpecLabelSelectorMatchExpressionsArrayInput` via:
//
//          NamespaceConfigSpecLabelSelectorMatchExpressionsArray{ NamespaceConfigSpecLabelSelectorMatchExpressionsArgs{...} }
type NamespaceConfigSpecLabelSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToNamespaceConfigSpecLabelSelectorMatchExpressionsArrayOutput() NamespaceConfigSpecLabelSelectorMatchExpressionsArrayOutput
	ToNamespaceConfigSpecLabelSelectorMatchExpressionsArrayOutputWithContext(context.Context) NamespaceConfigSpecLabelSelectorMatchExpressionsArrayOutput
}

type NamespaceConfigSpecLabelSelectorMatchExpressionsArray []NamespaceConfigSpecLabelSelectorMatchExpressionsInput

func (NamespaceConfigSpecLabelSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NamespaceConfigSpecLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i NamespaceConfigSpecLabelSelectorMatchExpressionsArray) ToNamespaceConfigSpecLabelSelectorMatchExpressionsArrayOutput() NamespaceConfigSpecLabelSelectorMatchExpressionsArrayOutput {
	return i.ToNamespaceConfigSpecLabelSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i NamespaceConfigSpecLabelSelectorMatchExpressionsArray) ToNamespaceConfigSpecLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) NamespaceConfigSpecLabelSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceConfigSpecLabelSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type NamespaceConfigSpecLabelSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (NamespaceConfigSpecLabelSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NamespaceConfigSpecLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o NamespaceConfigSpecLabelSelectorMatchExpressionsOutput) ToNamespaceConfigSpecLabelSelectorMatchExpressionsOutput() NamespaceConfigSpecLabelSelectorMatchExpressionsOutput {
	return o
}

func (o NamespaceConfigSpecLabelSelectorMatchExpressionsOutput) ToNamespaceConfigSpecLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) NamespaceConfigSpecLabelSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o NamespaceConfigSpecLabelSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v NamespaceConfigSpecLabelSelectorMatchExpressions) string { return v.Key }).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
func (o NamespaceConfigSpecLabelSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v NamespaceConfigSpecLabelSelectorMatchExpressions) string { return v.Operator }).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
func (o NamespaceConfigSpecLabelSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NamespaceConfigSpecLabelSelectorMatchExpressions) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type NamespaceConfigSpecLabelSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (NamespaceConfigSpecLabelSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NamespaceConfigSpecLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o NamespaceConfigSpecLabelSelectorMatchExpressionsArrayOutput) ToNamespaceConfigSpecLabelSelectorMatchExpressionsArrayOutput() NamespaceConfigSpecLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o NamespaceConfigSpecLabelSelectorMatchExpressionsArrayOutput) ToNamespaceConfigSpecLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) NamespaceConfigSpecLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o NamespaceConfigSpecLabelSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) NamespaceConfigSpecLabelSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) NamespaceConfigSpecLabelSelectorMatchExpressions {
		return vs[0].([]NamespaceConfigSpecLabelSelectorMatchExpressions)[vs[1].(int)]
	}).(NamespaceConfigSpecLabelSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type NamespaceConfigSpecLabelSelectorMatchLabels struct {
}

// NamespaceConfigSpecLabelSelectorMatchLabelsInput is an input type that accepts NamespaceConfigSpecLabelSelectorMatchLabelsArgs and NamespaceConfigSpecLabelSelectorMatchLabelsOutput values.
// You can construct a concrete instance of `NamespaceConfigSpecLabelSelectorMatchLabelsInput` via:
//
//          NamespaceConfigSpecLabelSelectorMatchLabelsArgs{...}
type NamespaceConfigSpecLabelSelectorMatchLabelsInput interface {
	pulumi.Input

	ToNamespaceConfigSpecLabelSelectorMatchLabelsOutput() NamespaceConfigSpecLabelSelectorMatchLabelsOutput
	ToNamespaceConfigSpecLabelSelectorMatchLabelsOutputWithContext(context.Context) NamespaceConfigSpecLabelSelectorMatchLabelsOutput
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type NamespaceConfigSpecLabelSelectorMatchLabelsArgs struct {
}

func (NamespaceConfigSpecLabelSelectorMatchLabelsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NamespaceConfigSpecLabelSelectorMatchLabels)(nil)).Elem()
}

func (i NamespaceConfigSpecLabelSelectorMatchLabelsArgs) ToNamespaceConfigSpecLabelSelectorMatchLabelsOutput() NamespaceConfigSpecLabelSelectorMatchLabelsOutput {
	return i.ToNamespaceConfigSpecLabelSelectorMatchLabelsOutputWithContext(context.Background())
}

func (i NamespaceConfigSpecLabelSelectorMatchLabelsArgs) ToNamespaceConfigSpecLabelSelectorMatchLabelsOutputWithContext(ctx context.Context) NamespaceConfigSpecLabelSelectorMatchLabelsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceConfigSpecLabelSelectorMatchLabelsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type NamespaceConfigSpecLabelSelectorMatchLabelsOutput struct{ *pulumi.OutputState }

func (NamespaceConfigSpecLabelSelectorMatchLabelsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NamespaceConfigSpecLabelSelectorMatchLabels)(nil)).Elem()
}

func (o NamespaceConfigSpecLabelSelectorMatchLabelsOutput) ToNamespaceConfigSpecLabelSelectorMatchLabelsOutput() NamespaceConfigSpecLabelSelectorMatchLabelsOutput {
	return o
}

func (o NamespaceConfigSpecLabelSelectorMatchLabelsOutput) ToNamespaceConfigSpecLabelSelectorMatchLabelsOutputWithContext(ctx context.Context) NamespaceConfigSpecLabelSelectorMatchLabelsOutput {
	return o
}

// LockedResourceTemplate represents a resource template in go language to be enforced in a LockedResourceController and can be used in a API specification
type NamespaceConfigSpecTemplates struct {
	// ExludedPaths are a set of json paths that need not be considered by the LockedResourceReconciler
	ExcludedPaths []string `pulumi:"excludedPaths"`
	// ObjectTemplate is a goland template. Whne processed, it must resolve to a yaml representation of an API resource
	ObjectTemplate string `pulumi:"objectTemplate"`
}

// NamespaceConfigSpecTemplatesInput is an input type that accepts NamespaceConfigSpecTemplatesArgs and NamespaceConfigSpecTemplatesOutput values.
// You can construct a concrete instance of `NamespaceConfigSpecTemplatesInput` via:
//
//          NamespaceConfigSpecTemplatesArgs{...}
type NamespaceConfigSpecTemplatesInput interface {
	pulumi.Input

	ToNamespaceConfigSpecTemplatesOutput() NamespaceConfigSpecTemplatesOutput
	ToNamespaceConfigSpecTemplatesOutputWithContext(context.Context) NamespaceConfigSpecTemplatesOutput
}

// LockedResourceTemplate represents a resource template in go language to be enforced in a LockedResourceController and can be used in a API specification
type NamespaceConfigSpecTemplatesArgs struct {
	// ExludedPaths are a set of json paths that need not be considered by the LockedResourceReconciler
	ExcludedPaths pulumi.StringArrayInput `pulumi:"excludedPaths"`
	// ObjectTemplate is a goland template. Whne processed, it must resolve to a yaml representation of an API resource
	ObjectTemplate pulumi.StringInput `pulumi:"objectTemplate"`
}

func (NamespaceConfigSpecTemplatesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NamespaceConfigSpecTemplates)(nil)).Elem()
}

func (i NamespaceConfigSpecTemplatesArgs) ToNamespaceConfigSpecTemplatesOutput() NamespaceConfigSpecTemplatesOutput {
	return i.ToNamespaceConfigSpecTemplatesOutputWithContext(context.Background())
}

func (i NamespaceConfigSpecTemplatesArgs) ToNamespaceConfigSpecTemplatesOutputWithContext(ctx context.Context) NamespaceConfigSpecTemplatesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceConfigSpecTemplatesOutput)
}

// NamespaceConfigSpecTemplatesArrayInput is an input type that accepts NamespaceConfigSpecTemplatesArray and NamespaceConfigSpecTemplatesArrayOutput values.
// You can construct a concrete instance of `NamespaceConfigSpecTemplatesArrayInput` via:
//
//          NamespaceConfigSpecTemplatesArray{ NamespaceConfigSpecTemplatesArgs{...} }
type NamespaceConfigSpecTemplatesArrayInput interface {
	pulumi.Input

	ToNamespaceConfigSpecTemplatesArrayOutput() NamespaceConfigSpecTemplatesArrayOutput
	ToNamespaceConfigSpecTemplatesArrayOutputWithContext(context.Context) NamespaceConfigSpecTemplatesArrayOutput
}

type NamespaceConfigSpecTemplatesArray []NamespaceConfigSpecTemplatesInput

func (NamespaceConfigSpecTemplatesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NamespaceConfigSpecTemplates)(nil)).Elem()
}

func (i NamespaceConfigSpecTemplatesArray) ToNamespaceConfigSpecTemplatesArrayOutput() NamespaceConfigSpecTemplatesArrayOutput {
	return i.ToNamespaceConfigSpecTemplatesArrayOutputWithContext(context.Background())
}

func (i NamespaceConfigSpecTemplatesArray) ToNamespaceConfigSpecTemplatesArrayOutputWithContext(ctx context.Context) NamespaceConfigSpecTemplatesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceConfigSpecTemplatesArrayOutput)
}

// LockedResourceTemplate represents a resource template in go language to be enforced in a LockedResourceController and can be used in a API specification
type NamespaceConfigSpecTemplatesOutput struct{ *pulumi.OutputState }

func (NamespaceConfigSpecTemplatesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NamespaceConfigSpecTemplates)(nil)).Elem()
}

func (o NamespaceConfigSpecTemplatesOutput) ToNamespaceConfigSpecTemplatesOutput() NamespaceConfigSpecTemplatesOutput {
	return o
}

func (o NamespaceConfigSpecTemplatesOutput) ToNamespaceConfigSpecTemplatesOutputWithContext(ctx context.Context) NamespaceConfigSpecTemplatesOutput {
	return o
}

// ExludedPaths are a set of json paths that need not be considered by the LockedResourceReconciler
func (o NamespaceConfigSpecTemplatesOutput) ExcludedPaths() pulumi.StringArrayOutput {
	return o.ApplyT(func(v NamespaceConfigSpecTemplates) []string { return v.ExcludedPaths }).(pulumi.StringArrayOutput)
}

// ObjectTemplate is a goland template. Whne processed, it must resolve to a yaml representation of an API resource
func (o NamespaceConfigSpecTemplatesOutput) ObjectTemplate() pulumi.StringOutput {
	return o.ApplyT(func(v NamespaceConfigSpecTemplates) string { return v.ObjectTemplate }).(pulumi.StringOutput)
}

type NamespaceConfigSpecTemplatesArrayOutput struct{ *pulumi.OutputState }

func (NamespaceConfigSpecTemplatesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NamespaceConfigSpecTemplates)(nil)).Elem()
}

func (o NamespaceConfigSpecTemplatesArrayOutput) ToNamespaceConfigSpecTemplatesArrayOutput() NamespaceConfigSpecTemplatesArrayOutput {
	return o
}

func (o NamespaceConfigSpecTemplatesArrayOutput) ToNamespaceConfigSpecTemplatesArrayOutputWithContext(ctx context.Context) NamespaceConfigSpecTemplatesArrayOutput {
	return o
}

func (o NamespaceConfigSpecTemplatesArrayOutput) Index(i pulumi.IntInput) NamespaceConfigSpecTemplatesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) NamespaceConfigSpecTemplates {
		return vs[0].([]NamespaceConfigSpecTemplates)[vs[1].(int)]
	}).(NamespaceConfigSpecTemplatesOutput)
}

// NamespaceConfigStatus defines the observed state of NSConfig
type NamespaceConfigStatus struct {
	// ReconcileStatus this is the general status of the main reconciler
	Conditions []NamespaceConfigStatusConditions `pulumi:"conditions"`
	// LockedResourceStatuses contains the reconcile status for each of the managed resources
	LockedResourceStatuses map[string][]NamespaceConfigStatusLockedResourceStatuses `pulumi:"lockedResourceStatuses"`
}

// NamespaceConfigStatusInput is an input type that accepts NamespaceConfigStatusArgs and NamespaceConfigStatusOutput values.
// You can construct a concrete instance of `NamespaceConfigStatusInput` via:
//
//          NamespaceConfigStatusArgs{...}
type NamespaceConfigStatusInput interface {
	pulumi.Input

	ToNamespaceConfigStatusOutput() NamespaceConfigStatusOutput
	ToNamespaceConfigStatusOutputWithContext(context.Context) NamespaceConfigStatusOutput
}

// NamespaceConfigStatus defines the observed state of NSConfig
type NamespaceConfigStatusArgs struct {
	// ReconcileStatus this is the general status of the main reconciler
	Conditions NamespaceConfigStatusConditionsArrayInput `pulumi:"conditions"`
	// LockedResourceStatuses contains the reconcile status for each of the managed resources
	LockedResourceStatuses NamespaceConfigStatusLockedResourceStatusesArrayMapInput `pulumi:"lockedResourceStatuses"`
}

func (NamespaceConfigStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NamespaceConfigStatus)(nil)).Elem()
}

func (i NamespaceConfigStatusArgs) ToNamespaceConfigStatusOutput() NamespaceConfigStatusOutput {
	return i.ToNamespaceConfigStatusOutputWithContext(context.Background())
}

func (i NamespaceConfigStatusArgs) ToNamespaceConfigStatusOutputWithContext(ctx context.Context) NamespaceConfigStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceConfigStatusOutput)
}

func (i NamespaceConfigStatusArgs) ToNamespaceConfigStatusPtrOutput() NamespaceConfigStatusPtrOutput {
	return i.ToNamespaceConfigStatusPtrOutputWithContext(context.Background())
}

func (i NamespaceConfigStatusArgs) ToNamespaceConfigStatusPtrOutputWithContext(ctx context.Context) NamespaceConfigStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceConfigStatusOutput).ToNamespaceConfigStatusPtrOutputWithContext(ctx)
}

// NamespaceConfigStatusPtrInput is an input type that accepts NamespaceConfigStatusArgs, NamespaceConfigStatusPtr and NamespaceConfigStatusPtrOutput values.
// You can construct a concrete instance of `NamespaceConfigStatusPtrInput` via:
//
//          NamespaceConfigStatusArgs{...}
//
//  or:
//
//          nil
type NamespaceConfigStatusPtrInput interface {
	pulumi.Input

	ToNamespaceConfigStatusPtrOutput() NamespaceConfigStatusPtrOutput
	ToNamespaceConfigStatusPtrOutputWithContext(context.Context) NamespaceConfigStatusPtrOutput
}

type namespaceConfigStatusPtrType NamespaceConfigStatusArgs

func NamespaceConfigStatusPtr(v *NamespaceConfigStatusArgs) NamespaceConfigStatusPtrInput {
	return (*namespaceConfigStatusPtrType)(v)
}

func (*namespaceConfigStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**NamespaceConfigStatus)(nil)).Elem()
}

func (i *namespaceConfigStatusPtrType) ToNamespaceConfigStatusPtrOutput() NamespaceConfigStatusPtrOutput {
	return i.ToNamespaceConfigStatusPtrOutputWithContext(context.Background())
}

func (i *namespaceConfigStatusPtrType) ToNamespaceConfigStatusPtrOutputWithContext(ctx context.Context) NamespaceConfigStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceConfigStatusPtrOutput)
}

// NamespaceConfigStatus defines the observed state of NSConfig
type NamespaceConfigStatusOutput struct{ *pulumi.OutputState }

func (NamespaceConfigStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NamespaceConfigStatus)(nil)).Elem()
}

func (o NamespaceConfigStatusOutput) ToNamespaceConfigStatusOutput() NamespaceConfigStatusOutput {
	return o
}

func (o NamespaceConfigStatusOutput) ToNamespaceConfigStatusOutputWithContext(ctx context.Context) NamespaceConfigStatusOutput {
	return o
}

func (o NamespaceConfigStatusOutput) ToNamespaceConfigStatusPtrOutput() NamespaceConfigStatusPtrOutput {
	return o.ToNamespaceConfigStatusPtrOutputWithContext(context.Background())
}

func (o NamespaceConfigStatusOutput) ToNamespaceConfigStatusPtrOutputWithContext(ctx context.Context) NamespaceConfigStatusPtrOutput {
	return o.ApplyT(func(v NamespaceConfigStatus) *NamespaceConfigStatus {
		return &v
	}).(NamespaceConfigStatusPtrOutput)
}

// ReconcileStatus this is the general status of the main reconciler
func (o NamespaceConfigStatusOutput) Conditions() NamespaceConfigStatusConditionsArrayOutput {
	return o.ApplyT(func(v NamespaceConfigStatus) []NamespaceConfigStatusConditions { return v.Conditions }).(NamespaceConfigStatusConditionsArrayOutput)
}

// LockedResourceStatuses contains the reconcile status for each of the managed resources
func (o NamespaceConfigStatusOutput) LockedResourceStatuses() NamespaceConfigStatusLockedResourceStatusesArrayMapOutput {
	return o.ApplyT(func(v NamespaceConfigStatus) map[string][]NamespaceConfigStatusLockedResourceStatuses {
		return v.LockedResourceStatuses
	}).(NamespaceConfigStatusLockedResourceStatusesArrayMapOutput)
}

type NamespaceConfigStatusPtrOutput struct{ *pulumi.OutputState }

func (NamespaceConfigStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NamespaceConfigStatus)(nil)).Elem()
}

func (o NamespaceConfigStatusPtrOutput) ToNamespaceConfigStatusPtrOutput() NamespaceConfigStatusPtrOutput {
	return o
}

func (o NamespaceConfigStatusPtrOutput) ToNamespaceConfigStatusPtrOutputWithContext(ctx context.Context) NamespaceConfigStatusPtrOutput {
	return o
}

func (o NamespaceConfigStatusPtrOutput) Elem() NamespaceConfigStatusOutput {
	return o.ApplyT(func(v *NamespaceConfigStatus) NamespaceConfigStatus { return *v }).(NamespaceConfigStatusOutput)
}

// ReconcileStatus this is the general status of the main reconciler
func (o NamespaceConfigStatusPtrOutput) Conditions() NamespaceConfigStatusConditionsArrayOutput {
	return o.ApplyT(func(v *NamespaceConfigStatus) []NamespaceConfigStatusConditions {
		if v == nil {
			return nil
		}
		return v.Conditions
	}).(NamespaceConfigStatusConditionsArrayOutput)
}

// LockedResourceStatuses contains the reconcile status for each of the managed resources
func (o NamespaceConfigStatusPtrOutput) LockedResourceStatuses() NamespaceConfigStatusLockedResourceStatusesArrayMapOutput {
	return o.ApplyT(func(v *NamespaceConfigStatus) map[string][]NamespaceConfigStatusLockedResourceStatuses {
		if v == nil {
			return nil
		}
		return v.LockedResourceStatuses
	}).(NamespaceConfigStatusLockedResourceStatusesArrayMapOutput)
}

// Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind.
//  Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
type NamespaceConfigStatusConditions struct {
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	Message            *string `pulumi:"message"`
	// ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
	Reason *string `pulumi:"reason"`
	Status string  `pulumi:"status"`
	// ConditionType is the type of the condition and is typically a CamelCased word or short phrase.
	//  Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
	Type string `pulumi:"type"`
}

// NamespaceConfigStatusConditionsInput is an input type that accepts NamespaceConfigStatusConditionsArgs and NamespaceConfigStatusConditionsOutput values.
// You can construct a concrete instance of `NamespaceConfigStatusConditionsInput` via:
//
//          NamespaceConfigStatusConditionsArgs{...}
type NamespaceConfigStatusConditionsInput interface {
	pulumi.Input

	ToNamespaceConfigStatusConditionsOutput() NamespaceConfigStatusConditionsOutput
	ToNamespaceConfigStatusConditionsOutputWithContext(context.Context) NamespaceConfigStatusConditionsOutput
}

// Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind.
//  Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
type NamespaceConfigStatusConditionsArgs struct {
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	Message            pulumi.StringPtrInput `pulumi:"message"`
	// ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	Status pulumi.StringInput    `pulumi:"status"`
	// ConditionType is the type of the condition and is typically a CamelCased word or short phrase.
	//  Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
	Type pulumi.StringInput `pulumi:"type"`
}

func (NamespaceConfigStatusConditionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NamespaceConfigStatusConditions)(nil)).Elem()
}

func (i NamespaceConfigStatusConditionsArgs) ToNamespaceConfigStatusConditionsOutput() NamespaceConfigStatusConditionsOutput {
	return i.ToNamespaceConfigStatusConditionsOutputWithContext(context.Background())
}

func (i NamespaceConfigStatusConditionsArgs) ToNamespaceConfigStatusConditionsOutputWithContext(ctx context.Context) NamespaceConfigStatusConditionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceConfigStatusConditionsOutput)
}

// NamespaceConfigStatusConditionsArrayInput is an input type that accepts NamespaceConfigStatusConditionsArray and NamespaceConfigStatusConditionsArrayOutput values.
// You can construct a concrete instance of `NamespaceConfigStatusConditionsArrayInput` via:
//
//          NamespaceConfigStatusConditionsArray{ NamespaceConfigStatusConditionsArgs{...} }
type NamespaceConfigStatusConditionsArrayInput interface {
	pulumi.Input

	ToNamespaceConfigStatusConditionsArrayOutput() NamespaceConfigStatusConditionsArrayOutput
	ToNamespaceConfigStatusConditionsArrayOutputWithContext(context.Context) NamespaceConfigStatusConditionsArrayOutput
}

type NamespaceConfigStatusConditionsArray []NamespaceConfigStatusConditionsInput

func (NamespaceConfigStatusConditionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NamespaceConfigStatusConditions)(nil)).Elem()
}

func (i NamespaceConfigStatusConditionsArray) ToNamespaceConfigStatusConditionsArrayOutput() NamespaceConfigStatusConditionsArrayOutput {
	return i.ToNamespaceConfigStatusConditionsArrayOutputWithContext(context.Background())
}

func (i NamespaceConfigStatusConditionsArray) ToNamespaceConfigStatusConditionsArrayOutputWithContext(ctx context.Context) NamespaceConfigStatusConditionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceConfigStatusConditionsArrayOutput)
}

// Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind.
//  Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
type NamespaceConfigStatusConditionsOutput struct{ *pulumi.OutputState }

func (NamespaceConfigStatusConditionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NamespaceConfigStatusConditions)(nil)).Elem()
}

func (o NamespaceConfigStatusConditionsOutput) ToNamespaceConfigStatusConditionsOutput() NamespaceConfigStatusConditionsOutput {
	return o
}

func (o NamespaceConfigStatusConditionsOutput) ToNamespaceConfigStatusConditionsOutputWithContext(ctx context.Context) NamespaceConfigStatusConditionsOutput {
	return o
}

func (o NamespaceConfigStatusConditionsOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NamespaceConfigStatusConditions) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

func (o NamespaceConfigStatusConditionsOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NamespaceConfigStatusConditions) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
func (o NamespaceConfigStatusConditionsOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NamespaceConfigStatusConditions) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

func (o NamespaceConfigStatusConditionsOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v NamespaceConfigStatusConditions) string { return v.Status }).(pulumi.StringOutput)
}

// ConditionType is the type of the condition and is typically a CamelCased word or short phrase.
//  Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
func (o NamespaceConfigStatusConditionsOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v NamespaceConfigStatusConditions) string { return v.Type }).(pulumi.StringOutput)
}

type NamespaceConfigStatusConditionsArrayOutput struct{ *pulumi.OutputState }

func (NamespaceConfigStatusConditionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NamespaceConfigStatusConditions)(nil)).Elem()
}

func (o NamespaceConfigStatusConditionsArrayOutput) ToNamespaceConfigStatusConditionsArrayOutput() NamespaceConfigStatusConditionsArrayOutput {
	return o
}

func (o NamespaceConfigStatusConditionsArrayOutput) ToNamespaceConfigStatusConditionsArrayOutputWithContext(ctx context.Context) NamespaceConfigStatusConditionsArrayOutput {
	return o
}

func (o NamespaceConfigStatusConditionsArrayOutput) Index(i pulumi.IntInput) NamespaceConfigStatusConditionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) NamespaceConfigStatusConditions {
		return vs[0].([]NamespaceConfigStatusConditions)[vs[1].(int)]
	}).(NamespaceConfigStatusConditionsOutput)
}

// Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind.
//  Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
type NamespaceConfigStatusLockedResourceStatuses struct {
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	Message            *string `pulumi:"message"`
	// ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
	Reason *string `pulumi:"reason"`
	Status string  `pulumi:"status"`
	// ConditionType is the type of the condition and is typically a CamelCased word or short phrase.
	//  Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
	Type string `pulumi:"type"`
}

// NamespaceConfigStatusLockedResourceStatusesInput is an input type that accepts NamespaceConfigStatusLockedResourceStatusesArgs and NamespaceConfigStatusLockedResourceStatusesOutput values.
// You can construct a concrete instance of `NamespaceConfigStatusLockedResourceStatusesInput` via:
//
//          NamespaceConfigStatusLockedResourceStatusesArgs{...}
type NamespaceConfigStatusLockedResourceStatusesInput interface {
	pulumi.Input

	ToNamespaceConfigStatusLockedResourceStatusesOutput() NamespaceConfigStatusLockedResourceStatusesOutput
	ToNamespaceConfigStatusLockedResourceStatusesOutputWithContext(context.Context) NamespaceConfigStatusLockedResourceStatusesOutput
}

// Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind.
//  Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
type NamespaceConfigStatusLockedResourceStatusesArgs struct {
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	Message            pulumi.StringPtrInput `pulumi:"message"`
	// ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	Status pulumi.StringInput    `pulumi:"status"`
	// ConditionType is the type of the condition and is typically a CamelCased word or short phrase.
	//  Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
	Type pulumi.StringInput `pulumi:"type"`
}

func (NamespaceConfigStatusLockedResourceStatusesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NamespaceConfigStatusLockedResourceStatuses)(nil)).Elem()
}

func (i NamespaceConfigStatusLockedResourceStatusesArgs) ToNamespaceConfigStatusLockedResourceStatusesOutput() NamespaceConfigStatusLockedResourceStatusesOutput {
	return i.ToNamespaceConfigStatusLockedResourceStatusesOutputWithContext(context.Background())
}

func (i NamespaceConfigStatusLockedResourceStatusesArgs) ToNamespaceConfigStatusLockedResourceStatusesOutputWithContext(ctx context.Context) NamespaceConfigStatusLockedResourceStatusesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceConfigStatusLockedResourceStatusesOutput)
}

// NamespaceConfigStatusLockedResourceStatusesArrayInput is an input type that accepts NamespaceConfigStatusLockedResourceStatusesArray and NamespaceConfigStatusLockedResourceStatusesArrayOutput values.
// You can construct a concrete instance of `NamespaceConfigStatusLockedResourceStatusesArrayInput` via:
//
//          NamespaceConfigStatusLockedResourceStatusesArray{ NamespaceConfigStatusLockedResourceStatusesArgs{...} }
type NamespaceConfigStatusLockedResourceStatusesArrayInput interface {
	pulumi.Input

	ToNamespaceConfigStatusLockedResourceStatusesArrayOutput() NamespaceConfigStatusLockedResourceStatusesArrayOutput
	ToNamespaceConfigStatusLockedResourceStatusesArrayOutputWithContext(context.Context) NamespaceConfigStatusLockedResourceStatusesArrayOutput
}

type NamespaceConfigStatusLockedResourceStatusesArray []NamespaceConfigStatusLockedResourceStatusesInput

func (NamespaceConfigStatusLockedResourceStatusesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NamespaceConfigStatusLockedResourceStatuses)(nil)).Elem()
}

func (i NamespaceConfigStatusLockedResourceStatusesArray) ToNamespaceConfigStatusLockedResourceStatusesArrayOutput() NamespaceConfigStatusLockedResourceStatusesArrayOutput {
	return i.ToNamespaceConfigStatusLockedResourceStatusesArrayOutputWithContext(context.Background())
}

func (i NamespaceConfigStatusLockedResourceStatusesArray) ToNamespaceConfigStatusLockedResourceStatusesArrayOutputWithContext(ctx context.Context) NamespaceConfigStatusLockedResourceStatusesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceConfigStatusLockedResourceStatusesArrayOutput)
}

// Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind.
//  Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
type NamespaceConfigStatusLockedResourceStatusesOutput struct{ *pulumi.OutputState }

func (NamespaceConfigStatusLockedResourceStatusesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NamespaceConfigStatusLockedResourceStatuses)(nil)).Elem()
}

func (o NamespaceConfigStatusLockedResourceStatusesOutput) ToNamespaceConfigStatusLockedResourceStatusesOutput() NamespaceConfigStatusLockedResourceStatusesOutput {
	return o
}

func (o NamespaceConfigStatusLockedResourceStatusesOutput) ToNamespaceConfigStatusLockedResourceStatusesOutputWithContext(ctx context.Context) NamespaceConfigStatusLockedResourceStatusesOutput {
	return o
}

func (o NamespaceConfigStatusLockedResourceStatusesOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NamespaceConfigStatusLockedResourceStatuses) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

func (o NamespaceConfigStatusLockedResourceStatusesOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NamespaceConfigStatusLockedResourceStatuses) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
func (o NamespaceConfigStatusLockedResourceStatusesOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NamespaceConfigStatusLockedResourceStatuses) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

func (o NamespaceConfigStatusLockedResourceStatusesOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v NamespaceConfigStatusLockedResourceStatuses) string { return v.Status }).(pulumi.StringOutput)
}

// ConditionType is the type of the condition and is typically a CamelCased word or short phrase.
//  Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
func (o NamespaceConfigStatusLockedResourceStatusesOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v NamespaceConfigStatusLockedResourceStatuses) string { return v.Type }).(pulumi.StringOutput)
}

type NamespaceConfigStatusLockedResourceStatusesArrayOutput struct{ *pulumi.OutputState }

func (NamespaceConfigStatusLockedResourceStatusesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NamespaceConfigStatusLockedResourceStatuses)(nil)).Elem()
}

func (o NamespaceConfigStatusLockedResourceStatusesArrayOutput) ToNamespaceConfigStatusLockedResourceStatusesArrayOutput() NamespaceConfigStatusLockedResourceStatusesArrayOutput {
	return o
}

func (o NamespaceConfigStatusLockedResourceStatusesArrayOutput) ToNamespaceConfigStatusLockedResourceStatusesArrayOutputWithContext(ctx context.Context) NamespaceConfigStatusLockedResourceStatusesArrayOutput {
	return o
}

func (o NamespaceConfigStatusLockedResourceStatusesArrayOutput) Index(i pulumi.IntInput) NamespaceConfigStatusLockedResourceStatusesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) NamespaceConfigStatusLockedResourceStatuses {
		return vs[0].([]NamespaceConfigStatusLockedResourceStatuses)[vs[1].(int)]
	}).(NamespaceConfigStatusLockedResourceStatusesOutput)
}

// UserConfig is the Schema for the userconfigs API
type UserConfigType struct {
	ApiVersion *string            `pulumi:"apiVersion"`
	Kind       *string            `pulumi:"kind"`
	Metadata   *metav1.ObjectMeta `pulumi:"metadata"`
	// UserConfigSpec defines the desired state of UserConfig There are four selectors: "labelSelector", "annotationSelector", "identityExtraFieldSelector" and "providerName". labelSelector and annoationSelector are matches against the User object identityExtraFieldSelector and providerName are matched against any of the Identities associated with User Selectors are considered in AND, so if multiple are defined tthey must all be true for a User to be selected.
	Spec *UserConfigSpec `pulumi:"spec"`
	// UserConfigStatus defines the observed state of UserConfig
	Status *UserConfigStatus `pulumi:"status"`
}

// UserConfigTypeInput is an input type that accepts UserConfigTypeArgs and UserConfigTypeOutput values.
// You can construct a concrete instance of `UserConfigTypeInput` via:
//
//          UserConfigTypeArgs{...}
type UserConfigTypeInput interface {
	pulumi.Input

	ToUserConfigTypeOutput() UserConfigTypeOutput
	ToUserConfigTypeOutputWithContext(context.Context) UserConfigTypeOutput
}

// UserConfig is the Schema for the userconfigs API
type UserConfigTypeArgs struct {
	ApiVersion pulumi.StringPtrInput     `pulumi:"apiVersion"`
	Kind       pulumi.StringPtrInput     `pulumi:"kind"`
	Metadata   metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	// UserConfigSpec defines the desired state of UserConfig There are four selectors: "labelSelector", "annotationSelector", "identityExtraFieldSelector" and "providerName". labelSelector and annoationSelector are matches against the User object identityExtraFieldSelector and providerName are matched against any of the Identities associated with User Selectors are considered in AND, so if multiple are defined tthey must all be true for a User to be selected.
	Spec UserConfigSpecPtrInput `pulumi:"spec"`
	// UserConfigStatus defines the observed state of UserConfig
	Status UserConfigStatusPtrInput `pulumi:"status"`
}

func (UserConfigTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UserConfigType)(nil)).Elem()
}

func (i UserConfigTypeArgs) ToUserConfigTypeOutput() UserConfigTypeOutput {
	return i.ToUserConfigTypeOutputWithContext(context.Background())
}

func (i UserConfigTypeArgs) ToUserConfigTypeOutputWithContext(ctx context.Context) UserConfigTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserConfigTypeOutput)
}

// UserConfig is the Schema for the userconfigs API
type UserConfigTypeOutput struct{ *pulumi.OutputState }

func (UserConfigTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UserConfigType)(nil)).Elem()
}

func (o UserConfigTypeOutput) ToUserConfigTypeOutput() UserConfigTypeOutput {
	return o
}

func (o UserConfigTypeOutput) ToUserConfigTypeOutputWithContext(ctx context.Context) UserConfigTypeOutput {
	return o
}

func (o UserConfigTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UserConfigType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

func (o UserConfigTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UserConfigType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

func (o UserConfigTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v UserConfigType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

// UserConfigSpec defines the desired state of UserConfig There are four selectors: "labelSelector", "annotationSelector", "identityExtraFieldSelector" and "providerName". labelSelector and annoationSelector are matches against the User object identityExtraFieldSelector and providerName are matched against any of the Identities associated with User Selectors are considered in AND, so if multiple are defined tthey must all be true for a User to be selected.
func (o UserConfigTypeOutput) Spec() UserConfigSpecPtrOutput {
	return o.ApplyT(func(v UserConfigType) *UserConfigSpec { return v.Spec }).(UserConfigSpecPtrOutput)
}

// UserConfigStatus defines the observed state of UserConfig
func (o UserConfigTypeOutput) Status() UserConfigStatusPtrOutput {
	return o.ApplyT(func(v UserConfigType) *UserConfigStatus { return v.Status }).(UserConfigStatusPtrOutput)
}

type UserConfigMetadata struct {
}

// UserConfigMetadataInput is an input type that accepts UserConfigMetadataArgs and UserConfigMetadataOutput values.
// You can construct a concrete instance of `UserConfigMetadataInput` via:
//
//          UserConfigMetadataArgs{...}
type UserConfigMetadataInput interface {
	pulumi.Input

	ToUserConfigMetadataOutput() UserConfigMetadataOutput
	ToUserConfigMetadataOutputWithContext(context.Context) UserConfigMetadataOutput
}

type UserConfigMetadataArgs struct {
}

func (UserConfigMetadataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UserConfigMetadata)(nil)).Elem()
}

func (i UserConfigMetadataArgs) ToUserConfigMetadataOutput() UserConfigMetadataOutput {
	return i.ToUserConfigMetadataOutputWithContext(context.Background())
}

func (i UserConfigMetadataArgs) ToUserConfigMetadataOutputWithContext(ctx context.Context) UserConfigMetadataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserConfigMetadataOutput)
}

type UserConfigMetadataOutput struct{ *pulumi.OutputState }

func (UserConfigMetadataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UserConfigMetadata)(nil)).Elem()
}

func (o UserConfigMetadataOutput) ToUserConfigMetadataOutput() UserConfigMetadataOutput {
	return o
}

func (o UserConfigMetadataOutput) ToUserConfigMetadataOutputWithContext(ctx context.Context) UserConfigMetadataOutput {
	return o
}

// UserConfigSpec defines the desired state of UserConfig There are four selectors: "labelSelector", "annotationSelector", "identityExtraFieldSelector" and "providerName". labelSelector and annoationSelector are matches against the User object identityExtraFieldSelector and providerName are matched against any of the Identities associated with User Selectors are considered in AND, so if multiple are defined tthey must all be true for a User to be selected.
type UserConfigSpec struct {
	// AnnotationSelector selects Users by annotation.
	AnnotationSelector *UserConfigSpecAnnotationSelector `pulumi:"annotationSelector"`
	// IdentityExtraSelector allows you to specify a selector for the extra fields of the User's idenitities. If one of the user identities matches the selector the User is selected This condition is in OR with ProviderName
	IdentityExtraFieldSelector *UserConfigSpecIdentityExtraFieldSelector `pulumi:"identityExtraFieldSelector"`
	// LabelSelector selects Users by label.
	LabelSelector *UserConfigSpecLabelSelector `pulumi:"labelSelector"`
	// ProviderName allows you to specify an idenitity provider. If a user logged in with that provider it is selected. This condition is in OR with IdentityExtraSelector
	ProviderName *string                   `pulumi:"providerName"`
	Templates    []UserConfigSpecTemplates `pulumi:"templates"`
}

// UserConfigSpecInput is an input type that accepts UserConfigSpecArgs and UserConfigSpecOutput values.
// You can construct a concrete instance of `UserConfigSpecInput` via:
//
//          UserConfigSpecArgs{...}
type UserConfigSpecInput interface {
	pulumi.Input

	ToUserConfigSpecOutput() UserConfigSpecOutput
	ToUserConfigSpecOutputWithContext(context.Context) UserConfigSpecOutput
}

// UserConfigSpec defines the desired state of UserConfig There are four selectors: "labelSelector", "annotationSelector", "identityExtraFieldSelector" and "providerName". labelSelector and annoationSelector are matches against the User object identityExtraFieldSelector and providerName are matched against any of the Identities associated with User Selectors are considered in AND, so if multiple are defined tthey must all be true for a User to be selected.
type UserConfigSpecArgs struct {
	// AnnotationSelector selects Users by annotation.
	AnnotationSelector UserConfigSpecAnnotationSelectorPtrInput `pulumi:"annotationSelector"`
	// IdentityExtraSelector allows you to specify a selector for the extra fields of the User's idenitities. If one of the user identities matches the selector the User is selected This condition is in OR with ProviderName
	IdentityExtraFieldSelector UserConfigSpecIdentityExtraFieldSelectorPtrInput `pulumi:"identityExtraFieldSelector"`
	// LabelSelector selects Users by label.
	LabelSelector UserConfigSpecLabelSelectorPtrInput `pulumi:"labelSelector"`
	// ProviderName allows you to specify an idenitity provider. If a user logged in with that provider it is selected. This condition is in OR with IdentityExtraSelector
	ProviderName pulumi.StringPtrInput             `pulumi:"providerName"`
	Templates    UserConfigSpecTemplatesArrayInput `pulumi:"templates"`
}

func (UserConfigSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UserConfigSpec)(nil)).Elem()
}

func (i UserConfigSpecArgs) ToUserConfigSpecOutput() UserConfigSpecOutput {
	return i.ToUserConfigSpecOutputWithContext(context.Background())
}

func (i UserConfigSpecArgs) ToUserConfigSpecOutputWithContext(ctx context.Context) UserConfigSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserConfigSpecOutput)
}

func (i UserConfigSpecArgs) ToUserConfigSpecPtrOutput() UserConfigSpecPtrOutput {
	return i.ToUserConfigSpecPtrOutputWithContext(context.Background())
}

func (i UserConfigSpecArgs) ToUserConfigSpecPtrOutputWithContext(ctx context.Context) UserConfigSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserConfigSpecOutput).ToUserConfigSpecPtrOutputWithContext(ctx)
}

// UserConfigSpecPtrInput is an input type that accepts UserConfigSpecArgs, UserConfigSpecPtr and UserConfigSpecPtrOutput values.
// You can construct a concrete instance of `UserConfigSpecPtrInput` via:
//
//          UserConfigSpecArgs{...}
//
//  or:
//
//          nil
type UserConfigSpecPtrInput interface {
	pulumi.Input

	ToUserConfigSpecPtrOutput() UserConfigSpecPtrOutput
	ToUserConfigSpecPtrOutputWithContext(context.Context) UserConfigSpecPtrOutput
}

type userConfigSpecPtrType UserConfigSpecArgs

func UserConfigSpecPtr(v *UserConfigSpecArgs) UserConfigSpecPtrInput {
	return (*userConfigSpecPtrType)(v)
}

func (*userConfigSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**UserConfigSpec)(nil)).Elem()
}

func (i *userConfigSpecPtrType) ToUserConfigSpecPtrOutput() UserConfigSpecPtrOutput {
	return i.ToUserConfigSpecPtrOutputWithContext(context.Background())
}

func (i *userConfigSpecPtrType) ToUserConfigSpecPtrOutputWithContext(ctx context.Context) UserConfigSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserConfigSpecPtrOutput)
}

// UserConfigSpec defines the desired state of UserConfig There are four selectors: "labelSelector", "annotationSelector", "identityExtraFieldSelector" and "providerName". labelSelector and annoationSelector are matches against the User object identityExtraFieldSelector and providerName are matched against any of the Identities associated with User Selectors are considered in AND, so if multiple are defined tthey must all be true for a User to be selected.
type UserConfigSpecOutput struct{ *pulumi.OutputState }

func (UserConfigSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UserConfigSpec)(nil)).Elem()
}

func (o UserConfigSpecOutput) ToUserConfigSpecOutput() UserConfigSpecOutput {
	return o
}

func (o UserConfigSpecOutput) ToUserConfigSpecOutputWithContext(ctx context.Context) UserConfigSpecOutput {
	return o
}

func (o UserConfigSpecOutput) ToUserConfigSpecPtrOutput() UserConfigSpecPtrOutput {
	return o.ToUserConfigSpecPtrOutputWithContext(context.Background())
}

func (o UserConfigSpecOutput) ToUserConfigSpecPtrOutputWithContext(ctx context.Context) UserConfigSpecPtrOutput {
	return o.ApplyT(func(v UserConfigSpec) *UserConfigSpec {
		return &v
	}).(UserConfigSpecPtrOutput)
}

// AnnotationSelector selects Users by annotation.
func (o UserConfigSpecOutput) AnnotationSelector() UserConfigSpecAnnotationSelectorPtrOutput {
	return o.ApplyT(func(v UserConfigSpec) *UserConfigSpecAnnotationSelector { return v.AnnotationSelector }).(UserConfigSpecAnnotationSelectorPtrOutput)
}

// IdentityExtraSelector allows you to specify a selector for the extra fields of the User's idenitities. If one of the user identities matches the selector the User is selected This condition is in OR with ProviderName
func (o UserConfigSpecOutput) IdentityExtraFieldSelector() UserConfigSpecIdentityExtraFieldSelectorPtrOutput {
	return o.ApplyT(func(v UserConfigSpec) *UserConfigSpecIdentityExtraFieldSelector { return v.IdentityExtraFieldSelector }).(UserConfigSpecIdentityExtraFieldSelectorPtrOutput)
}

// LabelSelector selects Users by label.
func (o UserConfigSpecOutput) LabelSelector() UserConfigSpecLabelSelectorPtrOutput {
	return o.ApplyT(func(v UserConfigSpec) *UserConfigSpecLabelSelector { return v.LabelSelector }).(UserConfigSpecLabelSelectorPtrOutput)
}

// ProviderName allows you to specify an idenitity provider. If a user logged in with that provider it is selected. This condition is in OR with IdentityExtraSelector
func (o UserConfigSpecOutput) ProviderName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UserConfigSpec) *string { return v.ProviderName }).(pulumi.StringPtrOutput)
}

func (o UserConfigSpecOutput) Templates() UserConfigSpecTemplatesArrayOutput {
	return o.ApplyT(func(v UserConfigSpec) []UserConfigSpecTemplates { return v.Templates }).(UserConfigSpecTemplatesArrayOutput)
}

type UserConfigSpecPtrOutput struct{ *pulumi.OutputState }

func (UserConfigSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**UserConfigSpec)(nil)).Elem()
}

func (o UserConfigSpecPtrOutput) ToUserConfigSpecPtrOutput() UserConfigSpecPtrOutput {
	return o
}

func (o UserConfigSpecPtrOutput) ToUserConfigSpecPtrOutputWithContext(ctx context.Context) UserConfigSpecPtrOutput {
	return o
}

func (o UserConfigSpecPtrOutput) Elem() UserConfigSpecOutput {
	return o.ApplyT(func(v *UserConfigSpec) UserConfigSpec { return *v }).(UserConfigSpecOutput)
}

// AnnotationSelector selects Users by annotation.
func (o UserConfigSpecPtrOutput) AnnotationSelector() UserConfigSpecAnnotationSelectorPtrOutput {
	return o.ApplyT(func(v *UserConfigSpec) *UserConfigSpecAnnotationSelector {
		if v == nil {
			return nil
		}
		return v.AnnotationSelector
	}).(UserConfigSpecAnnotationSelectorPtrOutput)
}

// IdentityExtraSelector allows you to specify a selector for the extra fields of the User's idenitities. If one of the user identities matches the selector the User is selected This condition is in OR with ProviderName
func (o UserConfigSpecPtrOutput) IdentityExtraFieldSelector() UserConfigSpecIdentityExtraFieldSelectorPtrOutput {
	return o.ApplyT(func(v *UserConfigSpec) *UserConfigSpecIdentityExtraFieldSelector {
		if v == nil {
			return nil
		}
		return v.IdentityExtraFieldSelector
	}).(UserConfigSpecIdentityExtraFieldSelectorPtrOutput)
}

// LabelSelector selects Users by label.
func (o UserConfigSpecPtrOutput) LabelSelector() UserConfigSpecLabelSelectorPtrOutput {
	return o.ApplyT(func(v *UserConfigSpec) *UserConfigSpecLabelSelector {
		if v == nil {
			return nil
		}
		return v.LabelSelector
	}).(UserConfigSpecLabelSelectorPtrOutput)
}

// ProviderName allows you to specify an idenitity provider. If a user logged in with that provider it is selected. This condition is in OR with IdentityExtraSelector
func (o UserConfigSpecPtrOutput) ProviderName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *UserConfigSpec) *string {
		if v == nil {
			return nil
		}
		return v.ProviderName
	}).(pulumi.StringPtrOutput)
}

func (o UserConfigSpecPtrOutput) Templates() UserConfigSpecTemplatesArrayOutput {
	return o.ApplyT(func(v *UserConfigSpec) []UserConfigSpecTemplates {
		if v == nil {
			return nil
		}
		return v.Templates
	}).(UserConfigSpecTemplatesArrayOutput)
}

// AnnotationSelector selects Users by annotation.
type UserConfigSpecAnnotationSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []UserConfigSpecAnnotationSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// UserConfigSpecAnnotationSelectorInput is an input type that accepts UserConfigSpecAnnotationSelectorArgs and UserConfigSpecAnnotationSelectorOutput values.
// You can construct a concrete instance of `UserConfigSpecAnnotationSelectorInput` via:
//
//          UserConfigSpecAnnotationSelectorArgs{...}
type UserConfigSpecAnnotationSelectorInput interface {
	pulumi.Input

	ToUserConfigSpecAnnotationSelectorOutput() UserConfigSpecAnnotationSelectorOutput
	ToUserConfigSpecAnnotationSelectorOutputWithContext(context.Context) UserConfigSpecAnnotationSelectorOutput
}

// AnnotationSelector selects Users by annotation.
type UserConfigSpecAnnotationSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions UserConfigSpecAnnotationSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (UserConfigSpecAnnotationSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UserConfigSpecAnnotationSelector)(nil)).Elem()
}

func (i UserConfigSpecAnnotationSelectorArgs) ToUserConfigSpecAnnotationSelectorOutput() UserConfigSpecAnnotationSelectorOutput {
	return i.ToUserConfigSpecAnnotationSelectorOutputWithContext(context.Background())
}

func (i UserConfigSpecAnnotationSelectorArgs) ToUserConfigSpecAnnotationSelectorOutputWithContext(ctx context.Context) UserConfigSpecAnnotationSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserConfigSpecAnnotationSelectorOutput)
}

func (i UserConfigSpecAnnotationSelectorArgs) ToUserConfigSpecAnnotationSelectorPtrOutput() UserConfigSpecAnnotationSelectorPtrOutput {
	return i.ToUserConfigSpecAnnotationSelectorPtrOutputWithContext(context.Background())
}

func (i UserConfigSpecAnnotationSelectorArgs) ToUserConfigSpecAnnotationSelectorPtrOutputWithContext(ctx context.Context) UserConfigSpecAnnotationSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserConfigSpecAnnotationSelectorOutput).ToUserConfigSpecAnnotationSelectorPtrOutputWithContext(ctx)
}

// UserConfigSpecAnnotationSelectorPtrInput is an input type that accepts UserConfigSpecAnnotationSelectorArgs, UserConfigSpecAnnotationSelectorPtr and UserConfigSpecAnnotationSelectorPtrOutput values.
// You can construct a concrete instance of `UserConfigSpecAnnotationSelectorPtrInput` via:
//
//          UserConfigSpecAnnotationSelectorArgs{...}
//
//  or:
//
//          nil
type UserConfigSpecAnnotationSelectorPtrInput interface {
	pulumi.Input

	ToUserConfigSpecAnnotationSelectorPtrOutput() UserConfigSpecAnnotationSelectorPtrOutput
	ToUserConfigSpecAnnotationSelectorPtrOutputWithContext(context.Context) UserConfigSpecAnnotationSelectorPtrOutput
}

type userConfigSpecAnnotationSelectorPtrType UserConfigSpecAnnotationSelectorArgs

func UserConfigSpecAnnotationSelectorPtr(v *UserConfigSpecAnnotationSelectorArgs) UserConfigSpecAnnotationSelectorPtrInput {
	return (*userConfigSpecAnnotationSelectorPtrType)(v)
}

func (*userConfigSpecAnnotationSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**UserConfigSpecAnnotationSelector)(nil)).Elem()
}

func (i *userConfigSpecAnnotationSelectorPtrType) ToUserConfigSpecAnnotationSelectorPtrOutput() UserConfigSpecAnnotationSelectorPtrOutput {
	return i.ToUserConfigSpecAnnotationSelectorPtrOutputWithContext(context.Background())
}

func (i *userConfigSpecAnnotationSelectorPtrType) ToUserConfigSpecAnnotationSelectorPtrOutputWithContext(ctx context.Context) UserConfigSpecAnnotationSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserConfigSpecAnnotationSelectorPtrOutput)
}

// AnnotationSelector selects Users by annotation.
type UserConfigSpecAnnotationSelectorOutput struct{ *pulumi.OutputState }

func (UserConfigSpecAnnotationSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UserConfigSpecAnnotationSelector)(nil)).Elem()
}

func (o UserConfigSpecAnnotationSelectorOutput) ToUserConfigSpecAnnotationSelectorOutput() UserConfigSpecAnnotationSelectorOutput {
	return o
}

func (o UserConfigSpecAnnotationSelectorOutput) ToUserConfigSpecAnnotationSelectorOutputWithContext(ctx context.Context) UserConfigSpecAnnotationSelectorOutput {
	return o
}

func (o UserConfigSpecAnnotationSelectorOutput) ToUserConfigSpecAnnotationSelectorPtrOutput() UserConfigSpecAnnotationSelectorPtrOutput {
	return o.ToUserConfigSpecAnnotationSelectorPtrOutputWithContext(context.Background())
}

func (o UserConfigSpecAnnotationSelectorOutput) ToUserConfigSpecAnnotationSelectorPtrOutputWithContext(ctx context.Context) UserConfigSpecAnnotationSelectorPtrOutput {
	return o.ApplyT(func(v UserConfigSpecAnnotationSelector) *UserConfigSpecAnnotationSelector {
		return &v
	}).(UserConfigSpecAnnotationSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o UserConfigSpecAnnotationSelectorOutput) MatchExpressions() UserConfigSpecAnnotationSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v UserConfigSpecAnnotationSelector) []UserConfigSpecAnnotationSelectorMatchExpressions {
		return v.MatchExpressions
	}).(UserConfigSpecAnnotationSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o UserConfigSpecAnnotationSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v UserConfigSpecAnnotationSelector) map[string]string { return v.MatchLabels }).(pulumi.StringMapOutput)
}

type UserConfigSpecAnnotationSelectorPtrOutput struct{ *pulumi.OutputState }

func (UserConfigSpecAnnotationSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**UserConfigSpecAnnotationSelector)(nil)).Elem()
}

func (o UserConfigSpecAnnotationSelectorPtrOutput) ToUserConfigSpecAnnotationSelectorPtrOutput() UserConfigSpecAnnotationSelectorPtrOutput {
	return o
}

func (o UserConfigSpecAnnotationSelectorPtrOutput) ToUserConfigSpecAnnotationSelectorPtrOutputWithContext(ctx context.Context) UserConfigSpecAnnotationSelectorPtrOutput {
	return o
}

func (o UserConfigSpecAnnotationSelectorPtrOutput) Elem() UserConfigSpecAnnotationSelectorOutput {
	return o.ApplyT(func(v *UserConfigSpecAnnotationSelector) UserConfigSpecAnnotationSelector { return *v }).(UserConfigSpecAnnotationSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o UserConfigSpecAnnotationSelectorPtrOutput) MatchExpressions() UserConfigSpecAnnotationSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *UserConfigSpecAnnotationSelector) []UserConfigSpecAnnotationSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(UserConfigSpecAnnotationSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o UserConfigSpecAnnotationSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *UserConfigSpecAnnotationSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type UserConfigSpecAnnotationSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// UserConfigSpecAnnotationSelectorMatchExpressionsInput is an input type that accepts UserConfigSpecAnnotationSelectorMatchExpressionsArgs and UserConfigSpecAnnotationSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `UserConfigSpecAnnotationSelectorMatchExpressionsInput` via:
//
//          UserConfigSpecAnnotationSelectorMatchExpressionsArgs{...}
type UserConfigSpecAnnotationSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToUserConfigSpecAnnotationSelectorMatchExpressionsOutput() UserConfigSpecAnnotationSelectorMatchExpressionsOutput
	ToUserConfigSpecAnnotationSelectorMatchExpressionsOutputWithContext(context.Context) UserConfigSpecAnnotationSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type UserConfigSpecAnnotationSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (UserConfigSpecAnnotationSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UserConfigSpecAnnotationSelectorMatchExpressions)(nil)).Elem()
}

func (i UserConfigSpecAnnotationSelectorMatchExpressionsArgs) ToUserConfigSpecAnnotationSelectorMatchExpressionsOutput() UserConfigSpecAnnotationSelectorMatchExpressionsOutput {
	return i.ToUserConfigSpecAnnotationSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i UserConfigSpecAnnotationSelectorMatchExpressionsArgs) ToUserConfigSpecAnnotationSelectorMatchExpressionsOutputWithContext(ctx context.Context) UserConfigSpecAnnotationSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserConfigSpecAnnotationSelectorMatchExpressionsOutput)
}

// UserConfigSpecAnnotationSelectorMatchExpressionsArrayInput is an input type that accepts UserConfigSpecAnnotationSelectorMatchExpressionsArray and UserConfigSpecAnnotationSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `UserConfigSpecAnnotationSelectorMatchExpressionsArrayInput` via:
//
//          UserConfigSpecAnnotationSelectorMatchExpressionsArray{ UserConfigSpecAnnotationSelectorMatchExpressionsArgs{...} }
type UserConfigSpecAnnotationSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToUserConfigSpecAnnotationSelectorMatchExpressionsArrayOutput() UserConfigSpecAnnotationSelectorMatchExpressionsArrayOutput
	ToUserConfigSpecAnnotationSelectorMatchExpressionsArrayOutputWithContext(context.Context) UserConfigSpecAnnotationSelectorMatchExpressionsArrayOutput
}

type UserConfigSpecAnnotationSelectorMatchExpressionsArray []UserConfigSpecAnnotationSelectorMatchExpressionsInput

func (UserConfigSpecAnnotationSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UserConfigSpecAnnotationSelectorMatchExpressions)(nil)).Elem()
}

func (i UserConfigSpecAnnotationSelectorMatchExpressionsArray) ToUserConfigSpecAnnotationSelectorMatchExpressionsArrayOutput() UserConfigSpecAnnotationSelectorMatchExpressionsArrayOutput {
	return i.ToUserConfigSpecAnnotationSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i UserConfigSpecAnnotationSelectorMatchExpressionsArray) ToUserConfigSpecAnnotationSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) UserConfigSpecAnnotationSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserConfigSpecAnnotationSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type UserConfigSpecAnnotationSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (UserConfigSpecAnnotationSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UserConfigSpecAnnotationSelectorMatchExpressions)(nil)).Elem()
}

func (o UserConfigSpecAnnotationSelectorMatchExpressionsOutput) ToUserConfigSpecAnnotationSelectorMatchExpressionsOutput() UserConfigSpecAnnotationSelectorMatchExpressionsOutput {
	return o
}

func (o UserConfigSpecAnnotationSelectorMatchExpressionsOutput) ToUserConfigSpecAnnotationSelectorMatchExpressionsOutputWithContext(ctx context.Context) UserConfigSpecAnnotationSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o UserConfigSpecAnnotationSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v UserConfigSpecAnnotationSelectorMatchExpressions) string { return v.Key }).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
func (o UserConfigSpecAnnotationSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v UserConfigSpecAnnotationSelectorMatchExpressions) string { return v.Operator }).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
func (o UserConfigSpecAnnotationSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v UserConfigSpecAnnotationSelectorMatchExpressions) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type UserConfigSpecAnnotationSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (UserConfigSpecAnnotationSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UserConfigSpecAnnotationSelectorMatchExpressions)(nil)).Elem()
}

func (o UserConfigSpecAnnotationSelectorMatchExpressionsArrayOutput) ToUserConfigSpecAnnotationSelectorMatchExpressionsArrayOutput() UserConfigSpecAnnotationSelectorMatchExpressionsArrayOutput {
	return o
}

func (o UserConfigSpecAnnotationSelectorMatchExpressionsArrayOutput) ToUserConfigSpecAnnotationSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) UserConfigSpecAnnotationSelectorMatchExpressionsArrayOutput {
	return o
}

func (o UserConfigSpecAnnotationSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) UserConfigSpecAnnotationSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) UserConfigSpecAnnotationSelectorMatchExpressions {
		return vs[0].([]UserConfigSpecAnnotationSelectorMatchExpressions)[vs[1].(int)]
	}).(UserConfigSpecAnnotationSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type UserConfigSpecAnnotationSelectorMatchLabels struct {
}

// UserConfigSpecAnnotationSelectorMatchLabelsInput is an input type that accepts UserConfigSpecAnnotationSelectorMatchLabelsArgs and UserConfigSpecAnnotationSelectorMatchLabelsOutput values.
// You can construct a concrete instance of `UserConfigSpecAnnotationSelectorMatchLabelsInput` via:
//
//          UserConfigSpecAnnotationSelectorMatchLabelsArgs{...}
type UserConfigSpecAnnotationSelectorMatchLabelsInput interface {
	pulumi.Input

	ToUserConfigSpecAnnotationSelectorMatchLabelsOutput() UserConfigSpecAnnotationSelectorMatchLabelsOutput
	ToUserConfigSpecAnnotationSelectorMatchLabelsOutputWithContext(context.Context) UserConfigSpecAnnotationSelectorMatchLabelsOutput
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type UserConfigSpecAnnotationSelectorMatchLabelsArgs struct {
}

func (UserConfigSpecAnnotationSelectorMatchLabelsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UserConfigSpecAnnotationSelectorMatchLabels)(nil)).Elem()
}

func (i UserConfigSpecAnnotationSelectorMatchLabelsArgs) ToUserConfigSpecAnnotationSelectorMatchLabelsOutput() UserConfigSpecAnnotationSelectorMatchLabelsOutput {
	return i.ToUserConfigSpecAnnotationSelectorMatchLabelsOutputWithContext(context.Background())
}

func (i UserConfigSpecAnnotationSelectorMatchLabelsArgs) ToUserConfigSpecAnnotationSelectorMatchLabelsOutputWithContext(ctx context.Context) UserConfigSpecAnnotationSelectorMatchLabelsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserConfigSpecAnnotationSelectorMatchLabelsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type UserConfigSpecAnnotationSelectorMatchLabelsOutput struct{ *pulumi.OutputState }

func (UserConfigSpecAnnotationSelectorMatchLabelsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UserConfigSpecAnnotationSelectorMatchLabels)(nil)).Elem()
}

func (o UserConfigSpecAnnotationSelectorMatchLabelsOutput) ToUserConfigSpecAnnotationSelectorMatchLabelsOutput() UserConfigSpecAnnotationSelectorMatchLabelsOutput {
	return o
}

func (o UserConfigSpecAnnotationSelectorMatchLabelsOutput) ToUserConfigSpecAnnotationSelectorMatchLabelsOutputWithContext(ctx context.Context) UserConfigSpecAnnotationSelectorMatchLabelsOutput {
	return o
}

// IdentityExtraSelector allows you to specify a selector for the extra fields of the User's idenitities. If one of the user identities matches the selector the User is selected This condition is in OR with ProviderName
type UserConfigSpecIdentityExtraFieldSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []UserConfigSpecIdentityExtraFieldSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// UserConfigSpecIdentityExtraFieldSelectorInput is an input type that accepts UserConfigSpecIdentityExtraFieldSelectorArgs and UserConfigSpecIdentityExtraFieldSelectorOutput values.
// You can construct a concrete instance of `UserConfigSpecIdentityExtraFieldSelectorInput` via:
//
//          UserConfigSpecIdentityExtraFieldSelectorArgs{...}
type UserConfigSpecIdentityExtraFieldSelectorInput interface {
	pulumi.Input

	ToUserConfigSpecIdentityExtraFieldSelectorOutput() UserConfigSpecIdentityExtraFieldSelectorOutput
	ToUserConfigSpecIdentityExtraFieldSelectorOutputWithContext(context.Context) UserConfigSpecIdentityExtraFieldSelectorOutput
}

// IdentityExtraSelector allows you to specify a selector for the extra fields of the User's idenitities. If one of the user identities matches the selector the User is selected This condition is in OR with ProviderName
type UserConfigSpecIdentityExtraFieldSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (UserConfigSpecIdentityExtraFieldSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UserConfigSpecIdentityExtraFieldSelector)(nil)).Elem()
}

func (i UserConfigSpecIdentityExtraFieldSelectorArgs) ToUserConfigSpecIdentityExtraFieldSelectorOutput() UserConfigSpecIdentityExtraFieldSelectorOutput {
	return i.ToUserConfigSpecIdentityExtraFieldSelectorOutputWithContext(context.Background())
}

func (i UserConfigSpecIdentityExtraFieldSelectorArgs) ToUserConfigSpecIdentityExtraFieldSelectorOutputWithContext(ctx context.Context) UserConfigSpecIdentityExtraFieldSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserConfigSpecIdentityExtraFieldSelectorOutput)
}

func (i UserConfigSpecIdentityExtraFieldSelectorArgs) ToUserConfigSpecIdentityExtraFieldSelectorPtrOutput() UserConfigSpecIdentityExtraFieldSelectorPtrOutput {
	return i.ToUserConfigSpecIdentityExtraFieldSelectorPtrOutputWithContext(context.Background())
}

func (i UserConfigSpecIdentityExtraFieldSelectorArgs) ToUserConfigSpecIdentityExtraFieldSelectorPtrOutputWithContext(ctx context.Context) UserConfigSpecIdentityExtraFieldSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserConfigSpecIdentityExtraFieldSelectorOutput).ToUserConfigSpecIdentityExtraFieldSelectorPtrOutputWithContext(ctx)
}

// UserConfigSpecIdentityExtraFieldSelectorPtrInput is an input type that accepts UserConfigSpecIdentityExtraFieldSelectorArgs, UserConfigSpecIdentityExtraFieldSelectorPtr and UserConfigSpecIdentityExtraFieldSelectorPtrOutput values.
// You can construct a concrete instance of `UserConfigSpecIdentityExtraFieldSelectorPtrInput` via:
//
//          UserConfigSpecIdentityExtraFieldSelectorArgs{...}
//
//  or:
//
//          nil
type UserConfigSpecIdentityExtraFieldSelectorPtrInput interface {
	pulumi.Input

	ToUserConfigSpecIdentityExtraFieldSelectorPtrOutput() UserConfigSpecIdentityExtraFieldSelectorPtrOutput
	ToUserConfigSpecIdentityExtraFieldSelectorPtrOutputWithContext(context.Context) UserConfigSpecIdentityExtraFieldSelectorPtrOutput
}

type userConfigSpecIdentityExtraFieldSelectorPtrType UserConfigSpecIdentityExtraFieldSelectorArgs

func UserConfigSpecIdentityExtraFieldSelectorPtr(v *UserConfigSpecIdentityExtraFieldSelectorArgs) UserConfigSpecIdentityExtraFieldSelectorPtrInput {
	return (*userConfigSpecIdentityExtraFieldSelectorPtrType)(v)
}

func (*userConfigSpecIdentityExtraFieldSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**UserConfigSpecIdentityExtraFieldSelector)(nil)).Elem()
}

func (i *userConfigSpecIdentityExtraFieldSelectorPtrType) ToUserConfigSpecIdentityExtraFieldSelectorPtrOutput() UserConfigSpecIdentityExtraFieldSelectorPtrOutput {
	return i.ToUserConfigSpecIdentityExtraFieldSelectorPtrOutputWithContext(context.Background())
}

func (i *userConfigSpecIdentityExtraFieldSelectorPtrType) ToUserConfigSpecIdentityExtraFieldSelectorPtrOutputWithContext(ctx context.Context) UserConfigSpecIdentityExtraFieldSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserConfigSpecIdentityExtraFieldSelectorPtrOutput)
}

// IdentityExtraSelector allows you to specify a selector for the extra fields of the User's idenitities. If one of the user identities matches the selector the User is selected This condition is in OR with ProviderName
type UserConfigSpecIdentityExtraFieldSelectorOutput struct{ *pulumi.OutputState }

func (UserConfigSpecIdentityExtraFieldSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UserConfigSpecIdentityExtraFieldSelector)(nil)).Elem()
}

func (o UserConfigSpecIdentityExtraFieldSelectorOutput) ToUserConfigSpecIdentityExtraFieldSelectorOutput() UserConfigSpecIdentityExtraFieldSelectorOutput {
	return o
}

func (o UserConfigSpecIdentityExtraFieldSelectorOutput) ToUserConfigSpecIdentityExtraFieldSelectorOutputWithContext(ctx context.Context) UserConfigSpecIdentityExtraFieldSelectorOutput {
	return o
}

func (o UserConfigSpecIdentityExtraFieldSelectorOutput) ToUserConfigSpecIdentityExtraFieldSelectorPtrOutput() UserConfigSpecIdentityExtraFieldSelectorPtrOutput {
	return o.ToUserConfigSpecIdentityExtraFieldSelectorPtrOutputWithContext(context.Background())
}

func (o UserConfigSpecIdentityExtraFieldSelectorOutput) ToUserConfigSpecIdentityExtraFieldSelectorPtrOutputWithContext(ctx context.Context) UserConfigSpecIdentityExtraFieldSelectorPtrOutput {
	return o.ApplyT(func(v UserConfigSpecIdentityExtraFieldSelector) *UserConfigSpecIdentityExtraFieldSelector {
		return &v
	}).(UserConfigSpecIdentityExtraFieldSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o UserConfigSpecIdentityExtraFieldSelectorOutput) MatchExpressions() UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v UserConfigSpecIdentityExtraFieldSelector) []UserConfigSpecIdentityExtraFieldSelectorMatchExpressions {
		return v.MatchExpressions
	}).(UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o UserConfigSpecIdentityExtraFieldSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v UserConfigSpecIdentityExtraFieldSelector) map[string]string { return v.MatchLabels }).(pulumi.StringMapOutput)
}

type UserConfigSpecIdentityExtraFieldSelectorPtrOutput struct{ *pulumi.OutputState }

func (UserConfigSpecIdentityExtraFieldSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**UserConfigSpecIdentityExtraFieldSelector)(nil)).Elem()
}

func (o UserConfigSpecIdentityExtraFieldSelectorPtrOutput) ToUserConfigSpecIdentityExtraFieldSelectorPtrOutput() UserConfigSpecIdentityExtraFieldSelectorPtrOutput {
	return o
}

func (o UserConfigSpecIdentityExtraFieldSelectorPtrOutput) ToUserConfigSpecIdentityExtraFieldSelectorPtrOutputWithContext(ctx context.Context) UserConfigSpecIdentityExtraFieldSelectorPtrOutput {
	return o
}

func (o UserConfigSpecIdentityExtraFieldSelectorPtrOutput) Elem() UserConfigSpecIdentityExtraFieldSelectorOutput {
	return o.ApplyT(func(v *UserConfigSpecIdentityExtraFieldSelector) UserConfigSpecIdentityExtraFieldSelector { return *v }).(UserConfigSpecIdentityExtraFieldSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o UserConfigSpecIdentityExtraFieldSelectorPtrOutput) MatchExpressions() UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *UserConfigSpecIdentityExtraFieldSelector) []UserConfigSpecIdentityExtraFieldSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o UserConfigSpecIdentityExtraFieldSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *UserConfigSpecIdentityExtraFieldSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type UserConfigSpecIdentityExtraFieldSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsInput is an input type that accepts UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsArgs and UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsInput` via:
//
//          UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsArgs{...}
type UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToUserConfigSpecIdentityExtraFieldSelectorMatchExpressionsOutput() UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsOutput
	ToUserConfigSpecIdentityExtraFieldSelectorMatchExpressionsOutputWithContext(context.Context) UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UserConfigSpecIdentityExtraFieldSelectorMatchExpressions)(nil)).Elem()
}

func (i UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsArgs) ToUserConfigSpecIdentityExtraFieldSelectorMatchExpressionsOutput() UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsOutput {
	return i.ToUserConfigSpecIdentityExtraFieldSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsArgs) ToUserConfigSpecIdentityExtraFieldSelectorMatchExpressionsOutputWithContext(ctx context.Context) UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsOutput)
}

// UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsArrayInput is an input type that accepts UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsArray and UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsArrayInput` via:
//
//          UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsArray{ UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsArgs{...} }
type UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToUserConfigSpecIdentityExtraFieldSelectorMatchExpressionsArrayOutput() UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsArrayOutput
	ToUserConfigSpecIdentityExtraFieldSelectorMatchExpressionsArrayOutputWithContext(context.Context) UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsArrayOutput
}

type UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsArray []UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsInput

func (UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UserConfigSpecIdentityExtraFieldSelectorMatchExpressions)(nil)).Elem()
}

func (i UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsArray) ToUserConfigSpecIdentityExtraFieldSelectorMatchExpressionsArrayOutput() UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsArrayOutput {
	return i.ToUserConfigSpecIdentityExtraFieldSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsArray) ToUserConfigSpecIdentityExtraFieldSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UserConfigSpecIdentityExtraFieldSelectorMatchExpressions)(nil)).Elem()
}

func (o UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsOutput) ToUserConfigSpecIdentityExtraFieldSelectorMatchExpressionsOutput() UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsOutput {
	return o
}

func (o UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsOutput) ToUserConfigSpecIdentityExtraFieldSelectorMatchExpressionsOutputWithContext(ctx context.Context) UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v UserConfigSpecIdentityExtraFieldSelectorMatchExpressions) string { return v.Key }).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
func (o UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v UserConfigSpecIdentityExtraFieldSelectorMatchExpressions) string { return v.Operator }).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
func (o UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v UserConfigSpecIdentityExtraFieldSelectorMatchExpressions) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UserConfigSpecIdentityExtraFieldSelectorMatchExpressions)(nil)).Elem()
}

func (o UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsArrayOutput) ToUserConfigSpecIdentityExtraFieldSelectorMatchExpressionsArrayOutput() UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsArrayOutput {
	return o
}

func (o UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsArrayOutput) ToUserConfigSpecIdentityExtraFieldSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsArrayOutput {
	return o
}

func (o UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) UserConfigSpecIdentityExtraFieldSelectorMatchExpressions {
		return vs[0].([]UserConfigSpecIdentityExtraFieldSelectorMatchExpressions)[vs[1].(int)]
	}).(UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type UserConfigSpecIdentityExtraFieldSelectorMatchLabels struct {
}

// UserConfigSpecIdentityExtraFieldSelectorMatchLabelsInput is an input type that accepts UserConfigSpecIdentityExtraFieldSelectorMatchLabelsArgs and UserConfigSpecIdentityExtraFieldSelectorMatchLabelsOutput values.
// You can construct a concrete instance of `UserConfigSpecIdentityExtraFieldSelectorMatchLabelsInput` via:
//
//          UserConfigSpecIdentityExtraFieldSelectorMatchLabelsArgs{...}
type UserConfigSpecIdentityExtraFieldSelectorMatchLabelsInput interface {
	pulumi.Input

	ToUserConfigSpecIdentityExtraFieldSelectorMatchLabelsOutput() UserConfigSpecIdentityExtraFieldSelectorMatchLabelsOutput
	ToUserConfigSpecIdentityExtraFieldSelectorMatchLabelsOutputWithContext(context.Context) UserConfigSpecIdentityExtraFieldSelectorMatchLabelsOutput
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type UserConfigSpecIdentityExtraFieldSelectorMatchLabelsArgs struct {
}

func (UserConfigSpecIdentityExtraFieldSelectorMatchLabelsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UserConfigSpecIdentityExtraFieldSelectorMatchLabels)(nil)).Elem()
}

func (i UserConfigSpecIdentityExtraFieldSelectorMatchLabelsArgs) ToUserConfigSpecIdentityExtraFieldSelectorMatchLabelsOutput() UserConfigSpecIdentityExtraFieldSelectorMatchLabelsOutput {
	return i.ToUserConfigSpecIdentityExtraFieldSelectorMatchLabelsOutputWithContext(context.Background())
}

func (i UserConfigSpecIdentityExtraFieldSelectorMatchLabelsArgs) ToUserConfigSpecIdentityExtraFieldSelectorMatchLabelsOutputWithContext(ctx context.Context) UserConfigSpecIdentityExtraFieldSelectorMatchLabelsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserConfigSpecIdentityExtraFieldSelectorMatchLabelsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type UserConfigSpecIdentityExtraFieldSelectorMatchLabelsOutput struct{ *pulumi.OutputState }

func (UserConfigSpecIdentityExtraFieldSelectorMatchLabelsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UserConfigSpecIdentityExtraFieldSelectorMatchLabels)(nil)).Elem()
}

func (o UserConfigSpecIdentityExtraFieldSelectorMatchLabelsOutput) ToUserConfigSpecIdentityExtraFieldSelectorMatchLabelsOutput() UserConfigSpecIdentityExtraFieldSelectorMatchLabelsOutput {
	return o
}

func (o UserConfigSpecIdentityExtraFieldSelectorMatchLabelsOutput) ToUserConfigSpecIdentityExtraFieldSelectorMatchLabelsOutputWithContext(ctx context.Context) UserConfigSpecIdentityExtraFieldSelectorMatchLabelsOutput {
	return o
}

// LabelSelector selects Users by label.
type UserConfigSpecLabelSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []UserConfigSpecLabelSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// UserConfigSpecLabelSelectorInput is an input type that accepts UserConfigSpecLabelSelectorArgs and UserConfigSpecLabelSelectorOutput values.
// You can construct a concrete instance of `UserConfigSpecLabelSelectorInput` via:
//
//          UserConfigSpecLabelSelectorArgs{...}
type UserConfigSpecLabelSelectorInput interface {
	pulumi.Input

	ToUserConfigSpecLabelSelectorOutput() UserConfigSpecLabelSelectorOutput
	ToUserConfigSpecLabelSelectorOutputWithContext(context.Context) UserConfigSpecLabelSelectorOutput
}

// LabelSelector selects Users by label.
type UserConfigSpecLabelSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions UserConfigSpecLabelSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (UserConfigSpecLabelSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UserConfigSpecLabelSelector)(nil)).Elem()
}

func (i UserConfigSpecLabelSelectorArgs) ToUserConfigSpecLabelSelectorOutput() UserConfigSpecLabelSelectorOutput {
	return i.ToUserConfigSpecLabelSelectorOutputWithContext(context.Background())
}

func (i UserConfigSpecLabelSelectorArgs) ToUserConfigSpecLabelSelectorOutputWithContext(ctx context.Context) UserConfigSpecLabelSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserConfigSpecLabelSelectorOutput)
}

func (i UserConfigSpecLabelSelectorArgs) ToUserConfigSpecLabelSelectorPtrOutput() UserConfigSpecLabelSelectorPtrOutput {
	return i.ToUserConfigSpecLabelSelectorPtrOutputWithContext(context.Background())
}

func (i UserConfigSpecLabelSelectorArgs) ToUserConfigSpecLabelSelectorPtrOutputWithContext(ctx context.Context) UserConfigSpecLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserConfigSpecLabelSelectorOutput).ToUserConfigSpecLabelSelectorPtrOutputWithContext(ctx)
}

// UserConfigSpecLabelSelectorPtrInput is an input type that accepts UserConfigSpecLabelSelectorArgs, UserConfigSpecLabelSelectorPtr and UserConfigSpecLabelSelectorPtrOutput values.
// You can construct a concrete instance of `UserConfigSpecLabelSelectorPtrInput` via:
//
//          UserConfigSpecLabelSelectorArgs{...}
//
//  or:
//
//          nil
type UserConfigSpecLabelSelectorPtrInput interface {
	pulumi.Input

	ToUserConfigSpecLabelSelectorPtrOutput() UserConfigSpecLabelSelectorPtrOutput
	ToUserConfigSpecLabelSelectorPtrOutputWithContext(context.Context) UserConfigSpecLabelSelectorPtrOutput
}

type userConfigSpecLabelSelectorPtrType UserConfigSpecLabelSelectorArgs

func UserConfigSpecLabelSelectorPtr(v *UserConfigSpecLabelSelectorArgs) UserConfigSpecLabelSelectorPtrInput {
	return (*userConfigSpecLabelSelectorPtrType)(v)
}

func (*userConfigSpecLabelSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**UserConfigSpecLabelSelector)(nil)).Elem()
}

func (i *userConfigSpecLabelSelectorPtrType) ToUserConfigSpecLabelSelectorPtrOutput() UserConfigSpecLabelSelectorPtrOutput {
	return i.ToUserConfigSpecLabelSelectorPtrOutputWithContext(context.Background())
}

func (i *userConfigSpecLabelSelectorPtrType) ToUserConfigSpecLabelSelectorPtrOutputWithContext(ctx context.Context) UserConfigSpecLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserConfigSpecLabelSelectorPtrOutput)
}

// LabelSelector selects Users by label.
type UserConfigSpecLabelSelectorOutput struct{ *pulumi.OutputState }

func (UserConfigSpecLabelSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UserConfigSpecLabelSelector)(nil)).Elem()
}

func (o UserConfigSpecLabelSelectorOutput) ToUserConfigSpecLabelSelectorOutput() UserConfigSpecLabelSelectorOutput {
	return o
}

func (o UserConfigSpecLabelSelectorOutput) ToUserConfigSpecLabelSelectorOutputWithContext(ctx context.Context) UserConfigSpecLabelSelectorOutput {
	return o
}

func (o UserConfigSpecLabelSelectorOutput) ToUserConfigSpecLabelSelectorPtrOutput() UserConfigSpecLabelSelectorPtrOutput {
	return o.ToUserConfigSpecLabelSelectorPtrOutputWithContext(context.Background())
}

func (o UserConfigSpecLabelSelectorOutput) ToUserConfigSpecLabelSelectorPtrOutputWithContext(ctx context.Context) UserConfigSpecLabelSelectorPtrOutput {
	return o.ApplyT(func(v UserConfigSpecLabelSelector) *UserConfigSpecLabelSelector {
		return &v
	}).(UserConfigSpecLabelSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o UserConfigSpecLabelSelectorOutput) MatchExpressions() UserConfigSpecLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v UserConfigSpecLabelSelector) []UserConfigSpecLabelSelectorMatchExpressions {
		return v.MatchExpressions
	}).(UserConfigSpecLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o UserConfigSpecLabelSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v UserConfigSpecLabelSelector) map[string]string { return v.MatchLabels }).(pulumi.StringMapOutput)
}

type UserConfigSpecLabelSelectorPtrOutput struct{ *pulumi.OutputState }

func (UserConfigSpecLabelSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**UserConfigSpecLabelSelector)(nil)).Elem()
}

func (o UserConfigSpecLabelSelectorPtrOutput) ToUserConfigSpecLabelSelectorPtrOutput() UserConfigSpecLabelSelectorPtrOutput {
	return o
}

func (o UserConfigSpecLabelSelectorPtrOutput) ToUserConfigSpecLabelSelectorPtrOutputWithContext(ctx context.Context) UserConfigSpecLabelSelectorPtrOutput {
	return o
}

func (o UserConfigSpecLabelSelectorPtrOutput) Elem() UserConfigSpecLabelSelectorOutput {
	return o.ApplyT(func(v *UserConfigSpecLabelSelector) UserConfigSpecLabelSelector { return *v }).(UserConfigSpecLabelSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o UserConfigSpecLabelSelectorPtrOutput) MatchExpressions() UserConfigSpecLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *UserConfigSpecLabelSelector) []UserConfigSpecLabelSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(UserConfigSpecLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o UserConfigSpecLabelSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *UserConfigSpecLabelSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type UserConfigSpecLabelSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// UserConfigSpecLabelSelectorMatchExpressionsInput is an input type that accepts UserConfigSpecLabelSelectorMatchExpressionsArgs and UserConfigSpecLabelSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `UserConfigSpecLabelSelectorMatchExpressionsInput` via:
//
//          UserConfigSpecLabelSelectorMatchExpressionsArgs{...}
type UserConfigSpecLabelSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToUserConfigSpecLabelSelectorMatchExpressionsOutput() UserConfigSpecLabelSelectorMatchExpressionsOutput
	ToUserConfigSpecLabelSelectorMatchExpressionsOutputWithContext(context.Context) UserConfigSpecLabelSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type UserConfigSpecLabelSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (UserConfigSpecLabelSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UserConfigSpecLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i UserConfigSpecLabelSelectorMatchExpressionsArgs) ToUserConfigSpecLabelSelectorMatchExpressionsOutput() UserConfigSpecLabelSelectorMatchExpressionsOutput {
	return i.ToUserConfigSpecLabelSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i UserConfigSpecLabelSelectorMatchExpressionsArgs) ToUserConfigSpecLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) UserConfigSpecLabelSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserConfigSpecLabelSelectorMatchExpressionsOutput)
}

// UserConfigSpecLabelSelectorMatchExpressionsArrayInput is an input type that accepts UserConfigSpecLabelSelectorMatchExpressionsArray and UserConfigSpecLabelSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `UserConfigSpecLabelSelectorMatchExpressionsArrayInput` via:
//
//          UserConfigSpecLabelSelectorMatchExpressionsArray{ UserConfigSpecLabelSelectorMatchExpressionsArgs{...} }
type UserConfigSpecLabelSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToUserConfigSpecLabelSelectorMatchExpressionsArrayOutput() UserConfigSpecLabelSelectorMatchExpressionsArrayOutput
	ToUserConfigSpecLabelSelectorMatchExpressionsArrayOutputWithContext(context.Context) UserConfigSpecLabelSelectorMatchExpressionsArrayOutput
}

type UserConfigSpecLabelSelectorMatchExpressionsArray []UserConfigSpecLabelSelectorMatchExpressionsInput

func (UserConfigSpecLabelSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UserConfigSpecLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i UserConfigSpecLabelSelectorMatchExpressionsArray) ToUserConfigSpecLabelSelectorMatchExpressionsArrayOutput() UserConfigSpecLabelSelectorMatchExpressionsArrayOutput {
	return i.ToUserConfigSpecLabelSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i UserConfigSpecLabelSelectorMatchExpressionsArray) ToUserConfigSpecLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) UserConfigSpecLabelSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserConfigSpecLabelSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
type UserConfigSpecLabelSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (UserConfigSpecLabelSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UserConfigSpecLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o UserConfigSpecLabelSelectorMatchExpressionsOutput) ToUserConfigSpecLabelSelectorMatchExpressionsOutput() UserConfigSpecLabelSelectorMatchExpressionsOutput {
	return o
}

func (o UserConfigSpecLabelSelectorMatchExpressionsOutput) ToUserConfigSpecLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) UserConfigSpecLabelSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o UserConfigSpecLabelSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v UserConfigSpecLabelSelectorMatchExpressions) string { return v.Key }).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
func (o UserConfigSpecLabelSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v UserConfigSpecLabelSelectorMatchExpressions) string { return v.Operator }).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
func (o UserConfigSpecLabelSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v UserConfigSpecLabelSelectorMatchExpressions) []string { return v.Values }).(pulumi.StringArrayOutput)
}

type UserConfigSpecLabelSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (UserConfigSpecLabelSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UserConfigSpecLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o UserConfigSpecLabelSelectorMatchExpressionsArrayOutput) ToUserConfigSpecLabelSelectorMatchExpressionsArrayOutput() UserConfigSpecLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o UserConfigSpecLabelSelectorMatchExpressionsArrayOutput) ToUserConfigSpecLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) UserConfigSpecLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o UserConfigSpecLabelSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) UserConfigSpecLabelSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) UserConfigSpecLabelSelectorMatchExpressions {
		return vs[0].([]UserConfigSpecLabelSelectorMatchExpressions)[vs[1].(int)]
	}).(UserConfigSpecLabelSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type UserConfigSpecLabelSelectorMatchLabels struct {
}

// UserConfigSpecLabelSelectorMatchLabelsInput is an input type that accepts UserConfigSpecLabelSelectorMatchLabelsArgs and UserConfigSpecLabelSelectorMatchLabelsOutput values.
// You can construct a concrete instance of `UserConfigSpecLabelSelectorMatchLabelsInput` via:
//
//          UserConfigSpecLabelSelectorMatchLabelsArgs{...}
type UserConfigSpecLabelSelectorMatchLabelsInput interface {
	pulumi.Input

	ToUserConfigSpecLabelSelectorMatchLabelsOutput() UserConfigSpecLabelSelectorMatchLabelsOutput
	ToUserConfigSpecLabelSelectorMatchLabelsOutputWithContext(context.Context) UserConfigSpecLabelSelectorMatchLabelsOutput
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type UserConfigSpecLabelSelectorMatchLabelsArgs struct {
}

func (UserConfigSpecLabelSelectorMatchLabelsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UserConfigSpecLabelSelectorMatchLabels)(nil)).Elem()
}

func (i UserConfigSpecLabelSelectorMatchLabelsArgs) ToUserConfigSpecLabelSelectorMatchLabelsOutput() UserConfigSpecLabelSelectorMatchLabelsOutput {
	return i.ToUserConfigSpecLabelSelectorMatchLabelsOutputWithContext(context.Background())
}

func (i UserConfigSpecLabelSelectorMatchLabelsArgs) ToUserConfigSpecLabelSelectorMatchLabelsOutputWithContext(ctx context.Context) UserConfigSpecLabelSelectorMatchLabelsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserConfigSpecLabelSelectorMatchLabelsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
type UserConfigSpecLabelSelectorMatchLabelsOutput struct{ *pulumi.OutputState }

func (UserConfigSpecLabelSelectorMatchLabelsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UserConfigSpecLabelSelectorMatchLabels)(nil)).Elem()
}

func (o UserConfigSpecLabelSelectorMatchLabelsOutput) ToUserConfigSpecLabelSelectorMatchLabelsOutput() UserConfigSpecLabelSelectorMatchLabelsOutput {
	return o
}

func (o UserConfigSpecLabelSelectorMatchLabelsOutput) ToUserConfigSpecLabelSelectorMatchLabelsOutputWithContext(ctx context.Context) UserConfigSpecLabelSelectorMatchLabelsOutput {
	return o
}

// LockedResourceTemplate represents a resource template in go language to be enforced in a LockedResourceController and can be used in a API specification
type UserConfigSpecTemplates struct {
	// ExludedPaths are a set of json paths that need not be considered by the LockedResourceReconciler
	ExcludedPaths []string `pulumi:"excludedPaths"`
	// ObjectTemplate is a goland template. Whne processed, it must resolve to a yaml representation of an API resource
	ObjectTemplate string `pulumi:"objectTemplate"`
}

// UserConfigSpecTemplatesInput is an input type that accepts UserConfigSpecTemplatesArgs and UserConfigSpecTemplatesOutput values.
// You can construct a concrete instance of `UserConfigSpecTemplatesInput` via:
//
//          UserConfigSpecTemplatesArgs{...}
type UserConfigSpecTemplatesInput interface {
	pulumi.Input

	ToUserConfigSpecTemplatesOutput() UserConfigSpecTemplatesOutput
	ToUserConfigSpecTemplatesOutputWithContext(context.Context) UserConfigSpecTemplatesOutput
}

// LockedResourceTemplate represents a resource template in go language to be enforced in a LockedResourceController and can be used in a API specification
type UserConfigSpecTemplatesArgs struct {
	// ExludedPaths are a set of json paths that need not be considered by the LockedResourceReconciler
	ExcludedPaths pulumi.StringArrayInput `pulumi:"excludedPaths"`
	// ObjectTemplate is a goland template. Whne processed, it must resolve to a yaml representation of an API resource
	ObjectTemplate pulumi.StringInput `pulumi:"objectTemplate"`
}

func (UserConfigSpecTemplatesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UserConfigSpecTemplates)(nil)).Elem()
}

func (i UserConfigSpecTemplatesArgs) ToUserConfigSpecTemplatesOutput() UserConfigSpecTemplatesOutput {
	return i.ToUserConfigSpecTemplatesOutputWithContext(context.Background())
}

func (i UserConfigSpecTemplatesArgs) ToUserConfigSpecTemplatesOutputWithContext(ctx context.Context) UserConfigSpecTemplatesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserConfigSpecTemplatesOutput)
}

// UserConfigSpecTemplatesArrayInput is an input type that accepts UserConfigSpecTemplatesArray and UserConfigSpecTemplatesArrayOutput values.
// You can construct a concrete instance of `UserConfigSpecTemplatesArrayInput` via:
//
//          UserConfigSpecTemplatesArray{ UserConfigSpecTemplatesArgs{...} }
type UserConfigSpecTemplatesArrayInput interface {
	pulumi.Input

	ToUserConfigSpecTemplatesArrayOutput() UserConfigSpecTemplatesArrayOutput
	ToUserConfigSpecTemplatesArrayOutputWithContext(context.Context) UserConfigSpecTemplatesArrayOutput
}

type UserConfigSpecTemplatesArray []UserConfigSpecTemplatesInput

func (UserConfigSpecTemplatesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UserConfigSpecTemplates)(nil)).Elem()
}

func (i UserConfigSpecTemplatesArray) ToUserConfigSpecTemplatesArrayOutput() UserConfigSpecTemplatesArrayOutput {
	return i.ToUserConfigSpecTemplatesArrayOutputWithContext(context.Background())
}

func (i UserConfigSpecTemplatesArray) ToUserConfigSpecTemplatesArrayOutputWithContext(ctx context.Context) UserConfigSpecTemplatesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserConfigSpecTemplatesArrayOutput)
}

// LockedResourceTemplate represents a resource template in go language to be enforced in a LockedResourceController and can be used in a API specification
type UserConfigSpecTemplatesOutput struct{ *pulumi.OutputState }

func (UserConfigSpecTemplatesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UserConfigSpecTemplates)(nil)).Elem()
}

func (o UserConfigSpecTemplatesOutput) ToUserConfigSpecTemplatesOutput() UserConfigSpecTemplatesOutput {
	return o
}

func (o UserConfigSpecTemplatesOutput) ToUserConfigSpecTemplatesOutputWithContext(ctx context.Context) UserConfigSpecTemplatesOutput {
	return o
}

// ExludedPaths are a set of json paths that need not be considered by the LockedResourceReconciler
func (o UserConfigSpecTemplatesOutput) ExcludedPaths() pulumi.StringArrayOutput {
	return o.ApplyT(func(v UserConfigSpecTemplates) []string { return v.ExcludedPaths }).(pulumi.StringArrayOutput)
}

// ObjectTemplate is a goland template. Whne processed, it must resolve to a yaml representation of an API resource
func (o UserConfigSpecTemplatesOutput) ObjectTemplate() pulumi.StringOutput {
	return o.ApplyT(func(v UserConfigSpecTemplates) string { return v.ObjectTemplate }).(pulumi.StringOutput)
}

type UserConfigSpecTemplatesArrayOutput struct{ *pulumi.OutputState }

func (UserConfigSpecTemplatesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UserConfigSpecTemplates)(nil)).Elem()
}

func (o UserConfigSpecTemplatesArrayOutput) ToUserConfigSpecTemplatesArrayOutput() UserConfigSpecTemplatesArrayOutput {
	return o
}

func (o UserConfigSpecTemplatesArrayOutput) ToUserConfigSpecTemplatesArrayOutputWithContext(ctx context.Context) UserConfigSpecTemplatesArrayOutput {
	return o
}

func (o UserConfigSpecTemplatesArrayOutput) Index(i pulumi.IntInput) UserConfigSpecTemplatesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) UserConfigSpecTemplates {
		return vs[0].([]UserConfigSpecTemplates)[vs[1].(int)]
	}).(UserConfigSpecTemplatesOutput)
}

// UserConfigStatus defines the observed state of UserConfig
type UserConfigStatus struct {
	// ReconcileStatus this is the general status of the main reconciler
	Conditions []UserConfigStatusConditions `pulumi:"conditions"`
	// LockedResourceStatuses contains the reconcile status for each of the managed resources
	LockedResourceStatuses map[string][]UserConfigStatusLockedResourceStatuses `pulumi:"lockedResourceStatuses"`
}

// UserConfigStatusInput is an input type that accepts UserConfigStatusArgs and UserConfigStatusOutput values.
// You can construct a concrete instance of `UserConfigStatusInput` via:
//
//          UserConfigStatusArgs{...}
type UserConfigStatusInput interface {
	pulumi.Input

	ToUserConfigStatusOutput() UserConfigStatusOutput
	ToUserConfigStatusOutputWithContext(context.Context) UserConfigStatusOutput
}

// UserConfigStatus defines the observed state of UserConfig
type UserConfigStatusArgs struct {
	// ReconcileStatus this is the general status of the main reconciler
	Conditions UserConfigStatusConditionsArrayInput `pulumi:"conditions"`
	// LockedResourceStatuses contains the reconcile status for each of the managed resources
	LockedResourceStatuses UserConfigStatusLockedResourceStatusesArrayMapInput `pulumi:"lockedResourceStatuses"`
}

func (UserConfigStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UserConfigStatus)(nil)).Elem()
}

func (i UserConfigStatusArgs) ToUserConfigStatusOutput() UserConfigStatusOutput {
	return i.ToUserConfigStatusOutputWithContext(context.Background())
}

func (i UserConfigStatusArgs) ToUserConfigStatusOutputWithContext(ctx context.Context) UserConfigStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserConfigStatusOutput)
}

func (i UserConfigStatusArgs) ToUserConfigStatusPtrOutput() UserConfigStatusPtrOutput {
	return i.ToUserConfigStatusPtrOutputWithContext(context.Background())
}

func (i UserConfigStatusArgs) ToUserConfigStatusPtrOutputWithContext(ctx context.Context) UserConfigStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserConfigStatusOutput).ToUserConfigStatusPtrOutputWithContext(ctx)
}

// UserConfigStatusPtrInput is an input type that accepts UserConfigStatusArgs, UserConfigStatusPtr and UserConfigStatusPtrOutput values.
// You can construct a concrete instance of `UserConfigStatusPtrInput` via:
//
//          UserConfigStatusArgs{...}
//
//  or:
//
//          nil
type UserConfigStatusPtrInput interface {
	pulumi.Input

	ToUserConfigStatusPtrOutput() UserConfigStatusPtrOutput
	ToUserConfigStatusPtrOutputWithContext(context.Context) UserConfigStatusPtrOutput
}

type userConfigStatusPtrType UserConfigStatusArgs

func UserConfigStatusPtr(v *UserConfigStatusArgs) UserConfigStatusPtrInput {
	return (*userConfigStatusPtrType)(v)
}

func (*userConfigStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**UserConfigStatus)(nil)).Elem()
}

func (i *userConfigStatusPtrType) ToUserConfigStatusPtrOutput() UserConfigStatusPtrOutput {
	return i.ToUserConfigStatusPtrOutputWithContext(context.Background())
}

func (i *userConfigStatusPtrType) ToUserConfigStatusPtrOutputWithContext(ctx context.Context) UserConfigStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserConfigStatusPtrOutput)
}

// UserConfigStatus defines the observed state of UserConfig
type UserConfigStatusOutput struct{ *pulumi.OutputState }

func (UserConfigStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UserConfigStatus)(nil)).Elem()
}

func (o UserConfigStatusOutput) ToUserConfigStatusOutput() UserConfigStatusOutput {
	return o
}

func (o UserConfigStatusOutput) ToUserConfigStatusOutputWithContext(ctx context.Context) UserConfigStatusOutput {
	return o
}

func (o UserConfigStatusOutput) ToUserConfigStatusPtrOutput() UserConfigStatusPtrOutput {
	return o.ToUserConfigStatusPtrOutputWithContext(context.Background())
}

func (o UserConfigStatusOutput) ToUserConfigStatusPtrOutputWithContext(ctx context.Context) UserConfigStatusPtrOutput {
	return o.ApplyT(func(v UserConfigStatus) *UserConfigStatus {
		return &v
	}).(UserConfigStatusPtrOutput)
}

// ReconcileStatus this is the general status of the main reconciler
func (o UserConfigStatusOutput) Conditions() UserConfigStatusConditionsArrayOutput {
	return o.ApplyT(func(v UserConfigStatus) []UserConfigStatusConditions { return v.Conditions }).(UserConfigStatusConditionsArrayOutput)
}

// LockedResourceStatuses contains the reconcile status for each of the managed resources
func (o UserConfigStatusOutput) LockedResourceStatuses() UserConfigStatusLockedResourceStatusesArrayMapOutput {
	return o.ApplyT(func(v UserConfigStatus) map[string][]UserConfigStatusLockedResourceStatuses {
		return v.LockedResourceStatuses
	}).(UserConfigStatusLockedResourceStatusesArrayMapOutput)
}

type UserConfigStatusPtrOutput struct{ *pulumi.OutputState }

func (UserConfigStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**UserConfigStatus)(nil)).Elem()
}

func (o UserConfigStatusPtrOutput) ToUserConfigStatusPtrOutput() UserConfigStatusPtrOutput {
	return o
}

func (o UserConfigStatusPtrOutput) ToUserConfigStatusPtrOutputWithContext(ctx context.Context) UserConfigStatusPtrOutput {
	return o
}

func (o UserConfigStatusPtrOutput) Elem() UserConfigStatusOutput {
	return o.ApplyT(func(v *UserConfigStatus) UserConfigStatus { return *v }).(UserConfigStatusOutput)
}

// ReconcileStatus this is the general status of the main reconciler
func (o UserConfigStatusPtrOutput) Conditions() UserConfigStatusConditionsArrayOutput {
	return o.ApplyT(func(v *UserConfigStatus) []UserConfigStatusConditions {
		if v == nil {
			return nil
		}
		return v.Conditions
	}).(UserConfigStatusConditionsArrayOutput)
}

// LockedResourceStatuses contains the reconcile status for each of the managed resources
func (o UserConfigStatusPtrOutput) LockedResourceStatuses() UserConfigStatusLockedResourceStatusesArrayMapOutput {
	return o.ApplyT(func(v *UserConfigStatus) map[string][]UserConfigStatusLockedResourceStatuses {
		if v == nil {
			return nil
		}
		return v.LockedResourceStatuses
	}).(UserConfigStatusLockedResourceStatusesArrayMapOutput)
}

// Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind.
//  Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
type UserConfigStatusConditions struct {
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	Message            *string `pulumi:"message"`
	// ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
	Reason *string `pulumi:"reason"`
	Status string  `pulumi:"status"`
	// ConditionType is the type of the condition and is typically a CamelCased word or short phrase.
	//  Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
	Type string `pulumi:"type"`
}

// UserConfigStatusConditionsInput is an input type that accepts UserConfigStatusConditionsArgs and UserConfigStatusConditionsOutput values.
// You can construct a concrete instance of `UserConfigStatusConditionsInput` via:
//
//          UserConfigStatusConditionsArgs{...}
type UserConfigStatusConditionsInput interface {
	pulumi.Input

	ToUserConfigStatusConditionsOutput() UserConfigStatusConditionsOutput
	ToUserConfigStatusConditionsOutputWithContext(context.Context) UserConfigStatusConditionsOutput
}

// Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind.
//  Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
type UserConfigStatusConditionsArgs struct {
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	Message            pulumi.StringPtrInput `pulumi:"message"`
	// ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	Status pulumi.StringInput    `pulumi:"status"`
	// ConditionType is the type of the condition and is typically a CamelCased word or short phrase.
	//  Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
	Type pulumi.StringInput `pulumi:"type"`
}

func (UserConfigStatusConditionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UserConfigStatusConditions)(nil)).Elem()
}

func (i UserConfigStatusConditionsArgs) ToUserConfigStatusConditionsOutput() UserConfigStatusConditionsOutput {
	return i.ToUserConfigStatusConditionsOutputWithContext(context.Background())
}

func (i UserConfigStatusConditionsArgs) ToUserConfigStatusConditionsOutputWithContext(ctx context.Context) UserConfigStatusConditionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserConfigStatusConditionsOutput)
}

// UserConfigStatusConditionsArrayInput is an input type that accepts UserConfigStatusConditionsArray and UserConfigStatusConditionsArrayOutput values.
// You can construct a concrete instance of `UserConfigStatusConditionsArrayInput` via:
//
//          UserConfigStatusConditionsArray{ UserConfigStatusConditionsArgs{...} }
type UserConfigStatusConditionsArrayInput interface {
	pulumi.Input

	ToUserConfigStatusConditionsArrayOutput() UserConfigStatusConditionsArrayOutput
	ToUserConfigStatusConditionsArrayOutputWithContext(context.Context) UserConfigStatusConditionsArrayOutput
}

type UserConfigStatusConditionsArray []UserConfigStatusConditionsInput

func (UserConfigStatusConditionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UserConfigStatusConditions)(nil)).Elem()
}

func (i UserConfigStatusConditionsArray) ToUserConfigStatusConditionsArrayOutput() UserConfigStatusConditionsArrayOutput {
	return i.ToUserConfigStatusConditionsArrayOutputWithContext(context.Background())
}

func (i UserConfigStatusConditionsArray) ToUserConfigStatusConditionsArrayOutputWithContext(ctx context.Context) UserConfigStatusConditionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserConfigStatusConditionsArrayOutput)
}

// Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind.
//  Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
type UserConfigStatusConditionsOutput struct{ *pulumi.OutputState }

func (UserConfigStatusConditionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UserConfigStatusConditions)(nil)).Elem()
}

func (o UserConfigStatusConditionsOutput) ToUserConfigStatusConditionsOutput() UserConfigStatusConditionsOutput {
	return o
}

func (o UserConfigStatusConditionsOutput) ToUserConfigStatusConditionsOutputWithContext(ctx context.Context) UserConfigStatusConditionsOutput {
	return o
}

func (o UserConfigStatusConditionsOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UserConfigStatusConditions) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

func (o UserConfigStatusConditionsOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UserConfigStatusConditions) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
func (o UserConfigStatusConditionsOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UserConfigStatusConditions) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

func (o UserConfigStatusConditionsOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v UserConfigStatusConditions) string { return v.Status }).(pulumi.StringOutput)
}

// ConditionType is the type of the condition and is typically a CamelCased word or short phrase.
//  Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
func (o UserConfigStatusConditionsOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v UserConfigStatusConditions) string { return v.Type }).(pulumi.StringOutput)
}

type UserConfigStatusConditionsArrayOutput struct{ *pulumi.OutputState }

func (UserConfigStatusConditionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UserConfigStatusConditions)(nil)).Elem()
}

func (o UserConfigStatusConditionsArrayOutput) ToUserConfigStatusConditionsArrayOutput() UserConfigStatusConditionsArrayOutput {
	return o
}

func (o UserConfigStatusConditionsArrayOutput) ToUserConfigStatusConditionsArrayOutputWithContext(ctx context.Context) UserConfigStatusConditionsArrayOutput {
	return o
}

func (o UserConfigStatusConditionsArrayOutput) Index(i pulumi.IntInput) UserConfigStatusConditionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) UserConfigStatusConditions {
		return vs[0].([]UserConfigStatusConditions)[vs[1].(int)]
	}).(UserConfigStatusConditionsOutput)
}

// Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind.
//  Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
type UserConfigStatusLockedResourceStatuses struct {
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	Message            *string `pulumi:"message"`
	// ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
	Reason *string `pulumi:"reason"`
	Status string  `pulumi:"status"`
	// ConditionType is the type of the condition and is typically a CamelCased word or short phrase.
	//  Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
	Type string `pulumi:"type"`
}

// UserConfigStatusLockedResourceStatusesInput is an input type that accepts UserConfigStatusLockedResourceStatusesArgs and UserConfigStatusLockedResourceStatusesOutput values.
// You can construct a concrete instance of `UserConfigStatusLockedResourceStatusesInput` via:
//
//          UserConfigStatusLockedResourceStatusesArgs{...}
type UserConfigStatusLockedResourceStatusesInput interface {
	pulumi.Input

	ToUserConfigStatusLockedResourceStatusesOutput() UserConfigStatusLockedResourceStatusesOutput
	ToUserConfigStatusLockedResourceStatusesOutputWithContext(context.Context) UserConfigStatusLockedResourceStatusesOutput
}

// Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind.
//  Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
type UserConfigStatusLockedResourceStatusesArgs struct {
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	Message            pulumi.StringPtrInput `pulumi:"message"`
	// ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	Status pulumi.StringInput    `pulumi:"status"`
	// ConditionType is the type of the condition and is typically a CamelCased word or short phrase.
	//  Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
	Type pulumi.StringInput `pulumi:"type"`
}

func (UserConfigStatusLockedResourceStatusesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UserConfigStatusLockedResourceStatuses)(nil)).Elem()
}

func (i UserConfigStatusLockedResourceStatusesArgs) ToUserConfigStatusLockedResourceStatusesOutput() UserConfigStatusLockedResourceStatusesOutput {
	return i.ToUserConfigStatusLockedResourceStatusesOutputWithContext(context.Background())
}

func (i UserConfigStatusLockedResourceStatusesArgs) ToUserConfigStatusLockedResourceStatusesOutputWithContext(ctx context.Context) UserConfigStatusLockedResourceStatusesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserConfigStatusLockedResourceStatusesOutput)
}

// UserConfigStatusLockedResourceStatusesArrayInput is an input type that accepts UserConfigStatusLockedResourceStatusesArray and UserConfigStatusLockedResourceStatusesArrayOutput values.
// You can construct a concrete instance of `UserConfigStatusLockedResourceStatusesArrayInput` via:
//
//          UserConfigStatusLockedResourceStatusesArray{ UserConfigStatusLockedResourceStatusesArgs{...} }
type UserConfigStatusLockedResourceStatusesArrayInput interface {
	pulumi.Input

	ToUserConfigStatusLockedResourceStatusesArrayOutput() UserConfigStatusLockedResourceStatusesArrayOutput
	ToUserConfigStatusLockedResourceStatusesArrayOutputWithContext(context.Context) UserConfigStatusLockedResourceStatusesArrayOutput
}

type UserConfigStatusLockedResourceStatusesArray []UserConfigStatusLockedResourceStatusesInput

func (UserConfigStatusLockedResourceStatusesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UserConfigStatusLockedResourceStatuses)(nil)).Elem()
}

func (i UserConfigStatusLockedResourceStatusesArray) ToUserConfigStatusLockedResourceStatusesArrayOutput() UserConfigStatusLockedResourceStatusesArrayOutput {
	return i.ToUserConfigStatusLockedResourceStatusesArrayOutputWithContext(context.Background())
}

func (i UserConfigStatusLockedResourceStatusesArray) ToUserConfigStatusLockedResourceStatusesArrayOutputWithContext(ctx context.Context) UserConfigStatusLockedResourceStatusesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserConfigStatusLockedResourceStatusesArrayOutput)
}

// Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind.
//  Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
type UserConfigStatusLockedResourceStatusesOutput struct{ *pulumi.OutputState }

func (UserConfigStatusLockedResourceStatusesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UserConfigStatusLockedResourceStatuses)(nil)).Elem()
}

func (o UserConfigStatusLockedResourceStatusesOutput) ToUserConfigStatusLockedResourceStatusesOutput() UserConfigStatusLockedResourceStatusesOutput {
	return o
}

func (o UserConfigStatusLockedResourceStatusesOutput) ToUserConfigStatusLockedResourceStatusesOutputWithContext(ctx context.Context) UserConfigStatusLockedResourceStatusesOutput {
	return o
}

func (o UserConfigStatusLockedResourceStatusesOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UserConfigStatusLockedResourceStatuses) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

func (o UserConfigStatusLockedResourceStatusesOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UserConfigStatusLockedResourceStatuses) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
func (o UserConfigStatusLockedResourceStatusesOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UserConfigStatusLockedResourceStatuses) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

func (o UserConfigStatusLockedResourceStatusesOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v UserConfigStatusLockedResourceStatuses) string { return v.Status }).(pulumi.StringOutput)
}

// ConditionType is the type of the condition and is typically a CamelCased word or short phrase.
//  Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
func (o UserConfigStatusLockedResourceStatusesOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v UserConfigStatusLockedResourceStatuses) string { return v.Type }).(pulumi.StringOutput)
}

type UserConfigStatusLockedResourceStatusesArrayOutput struct{ *pulumi.OutputState }

func (UserConfigStatusLockedResourceStatusesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UserConfigStatusLockedResourceStatuses)(nil)).Elem()
}

func (o UserConfigStatusLockedResourceStatusesArrayOutput) ToUserConfigStatusLockedResourceStatusesArrayOutput() UserConfigStatusLockedResourceStatusesArrayOutput {
	return o
}

func (o UserConfigStatusLockedResourceStatusesArrayOutput) ToUserConfigStatusLockedResourceStatusesArrayOutputWithContext(ctx context.Context) UserConfigStatusLockedResourceStatusesArrayOutput {
	return o
}

func (o UserConfigStatusLockedResourceStatusesArrayOutput) Index(i pulumi.IntInput) UserConfigStatusLockedResourceStatusesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) UserConfigStatusLockedResourceStatuses {
		return vs[0].([]UserConfigStatusLockedResourceStatuses)[vs[1].(int)]
	}).(UserConfigStatusLockedResourceStatusesOutput)
}

func init() {
	pulumi.RegisterOutputType(GroupConfigTypeOutput{})
	pulumi.RegisterOutputType(GroupConfigMetadataOutput{})
	pulumi.RegisterOutputType(GroupConfigSpecOutput{})
	pulumi.RegisterOutputType(GroupConfigSpecPtrOutput{})
	pulumi.RegisterOutputType(GroupConfigSpecAnnotationSelectorOutput{})
	pulumi.RegisterOutputType(GroupConfigSpecAnnotationSelectorPtrOutput{})
	pulumi.RegisterOutputType(GroupConfigSpecAnnotationSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(GroupConfigSpecAnnotationSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(GroupConfigSpecAnnotationSelectorMatchLabelsOutput{})
	pulumi.RegisterOutputType(GroupConfigSpecLabelSelectorOutput{})
	pulumi.RegisterOutputType(GroupConfigSpecLabelSelectorPtrOutput{})
	pulumi.RegisterOutputType(GroupConfigSpecLabelSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(GroupConfigSpecLabelSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(GroupConfigSpecLabelSelectorMatchLabelsOutput{})
	pulumi.RegisterOutputType(GroupConfigSpecTemplatesOutput{})
	pulumi.RegisterOutputType(GroupConfigSpecTemplatesArrayOutput{})
	pulumi.RegisterOutputType(GroupConfigStatusOutput{})
	pulumi.RegisterOutputType(GroupConfigStatusPtrOutput{})
	pulumi.RegisterOutputType(GroupConfigStatusConditionsOutput{})
	pulumi.RegisterOutputType(GroupConfigStatusConditionsArrayOutput{})
	pulumi.RegisterOutputType(GroupConfigStatusLockedResourceStatusesOutput{})
	pulumi.RegisterOutputType(GroupConfigStatusLockedResourceStatusesArrayOutput{})
	pulumi.RegisterOutputType(NamespaceConfigTypeOutput{})
	pulumi.RegisterOutputType(NamespaceConfigMetadataOutput{})
	pulumi.RegisterOutputType(NamespaceConfigSpecOutput{})
	pulumi.RegisterOutputType(NamespaceConfigSpecPtrOutput{})
	pulumi.RegisterOutputType(NamespaceConfigSpecAnnotationSelectorOutput{})
	pulumi.RegisterOutputType(NamespaceConfigSpecAnnotationSelectorPtrOutput{})
	pulumi.RegisterOutputType(NamespaceConfigSpecAnnotationSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(NamespaceConfigSpecAnnotationSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(NamespaceConfigSpecAnnotationSelectorMatchLabelsOutput{})
	pulumi.RegisterOutputType(NamespaceConfigSpecLabelSelectorOutput{})
	pulumi.RegisterOutputType(NamespaceConfigSpecLabelSelectorPtrOutput{})
	pulumi.RegisterOutputType(NamespaceConfigSpecLabelSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(NamespaceConfigSpecLabelSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(NamespaceConfigSpecLabelSelectorMatchLabelsOutput{})
	pulumi.RegisterOutputType(NamespaceConfigSpecTemplatesOutput{})
	pulumi.RegisterOutputType(NamespaceConfigSpecTemplatesArrayOutput{})
	pulumi.RegisterOutputType(NamespaceConfigStatusOutput{})
	pulumi.RegisterOutputType(NamespaceConfigStatusPtrOutput{})
	pulumi.RegisterOutputType(NamespaceConfigStatusConditionsOutput{})
	pulumi.RegisterOutputType(NamespaceConfigStatusConditionsArrayOutput{})
	pulumi.RegisterOutputType(NamespaceConfigStatusLockedResourceStatusesOutput{})
	pulumi.RegisterOutputType(NamespaceConfigStatusLockedResourceStatusesArrayOutput{})
	pulumi.RegisterOutputType(UserConfigTypeOutput{})
	pulumi.RegisterOutputType(UserConfigMetadataOutput{})
	pulumi.RegisterOutputType(UserConfigSpecOutput{})
	pulumi.RegisterOutputType(UserConfigSpecPtrOutput{})
	pulumi.RegisterOutputType(UserConfigSpecAnnotationSelectorOutput{})
	pulumi.RegisterOutputType(UserConfigSpecAnnotationSelectorPtrOutput{})
	pulumi.RegisterOutputType(UserConfigSpecAnnotationSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(UserConfigSpecAnnotationSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(UserConfigSpecAnnotationSelectorMatchLabelsOutput{})
	pulumi.RegisterOutputType(UserConfigSpecIdentityExtraFieldSelectorOutput{})
	pulumi.RegisterOutputType(UserConfigSpecIdentityExtraFieldSelectorPtrOutput{})
	pulumi.RegisterOutputType(UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(UserConfigSpecIdentityExtraFieldSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(UserConfigSpecIdentityExtraFieldSelectorMatchLabelsOutput{})
	pulumi.RegisterOutputType(UserConfigSpecLabelSelectorOutput{})
	pulumi.RegisterOutputType(UserConfigSpecLabelSelectorPtrOutput{})
	pulumi.RegisterOutputType(UserConfigSpecLabelSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(UserConfigSpecLabelSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(UserConfigSpecLabelSelectorMatchLabelsOutput{})
	pulumi.RegisterOutputType(UserConfigSpecTemplatesOutput{})
	pulumi.RegisterOutputType(UserConfigSpecTemplatesArrayOutput{})
	pulumi.RegisterOutputType(UserConfigStatusOutput{})
	pulumi.RegisterOutputType(UserConfigStatusPtrOutput{})
	pulumi.RegisterOutputType(UserConfigStatusConditionsOutput{})
	pulumi.RegisterOutputType(UserConfigStatusConditionsArrayOutput{})
	pulumi.RegisterOutputType(UserConfigStatusLockedResourceStatusesOutput{})
	pulumi.RegisterOutputType(UserConfigStatusLockedResourceStatusesArrayOutput{})
}
