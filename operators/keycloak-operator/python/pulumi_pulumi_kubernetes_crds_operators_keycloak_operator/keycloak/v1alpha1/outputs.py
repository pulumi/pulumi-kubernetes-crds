# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from ... import _utilities, _tables
from . import outputs

__all__ = [
    'KeycloakBackupSpec',
    'KeycloakBackupSpecAws',
    'KeycloakBackupSpecInstanceSelector',
    'KeycloakBackupSpecInstanceSelectorMatchExpressions',
    'KeycloakBackupStatus',
    'KeycloakClientSpec',
    'KeycloakClientSpecClient',
    'KeycloakClientSpecClientProtocolMappers',
    'KeycloakClientSpecRealmSelector',
    'KeycloakClientSpecRealmSelectorMatchExpressions',
    'KeycloakClientStatus',
    'KeycloakRealmSpec',
    'KeycloakRealmSpecInstanceSelector',
    'KeycloakRealmSpecInstanceSelectorMatchExpressions',
    'KeycloakRealmSpecRealm',
    'KeycloakRealmSpecRealmClients',
    'KeycloakRealmSpecRealmClientsProtocolMappers',
    'KeycloakRealmSpecRealmIdentityProviders',
    'KeycloakRealmSpecRealmOverrides',
    'KeycloakRealmSpecRealmUsers',
    'KeycloakRealmSpecRealmUsersCredentials',
    'KeycloakRealmSpecRealmUsersFederatedIdentities',
    'KeycloakRealmStatus',
    'KeycloakSpec',
    'KeycloakSpecExternalAccess',
    'KeycloakSpecExternalDatabase',
    'KeycloakSpecKeycloakDeploymentSpec',
    'KeycloakSpecKeycloakDeploymentSpecResources',
    'KeycloakSpecMigration',
    'KeycloakSpecMigrationBackups',
    'KeycloakSpecPodDisruptionBudget',
    'KeycloakSpecPostgresDeploymentSpec',
    'KeycloakSpecPostgresDeploymentSpecResources',
    'KeycloakStatus',
    'KeycloakUserSpec',
    'KeycloakUserSpecRealmSelector',
    'KeycloakUserSpecRealmSelectorMatchExpressions',
    'KeycloakUserSpecUser',
    'KeycloakUserSpecUserCredentials',
    'KeycloakUserSpecUserFederatedIdentities',
    'KeycloakUserStatus',
]

@pulumi.output_type
class KeycloakBackupSpec(dict):
    """
    KeycloakBackupSpec defines the desired state of KeycloakBackup.
    """
    def __init__(__self__, *,
                 aws: Optional['outputs.KeycloakBackupSpecAws'] = None,
                 instance_selector: Optional['outputs.KeycloakBackupSpecInstanceSelector'] = None,
                 restore: Optional[bool] = None,
                 storage_class_name: Optional[str] = None):
        """
        KeycloakBackupSpec defines the desired state of KeycloakBackup.
        :param 'KeycloakBackupSpecAwsArgs' aws: If provided, an automatic database backup will be created on AWS S3 instead of a local Persistent Volume. If this property is not provided - a local Persistent Volume backup will be chosen.
        :param 'KeycloakBackupSpecInstanceSelectorArgs' instance_selector: Selector for looking up Keycloak Custom Resources.
        :param bool restore: Controls automatic restore behavior. Currently not implemented. 
                In the future this will be used to trigger automatic restore for a given KeycloakBackup. Each backup will correspond to a single snapshot of the database (stored either in a Persistent Volume or AWS). If a user wants to restore it, all he/she needs to do is to change this flag to true. Potentially, it will be possible to restore a single backup multiple times.
        :param str storage_class_name: Name of the StorageClass for Postgresql Backup Persistent Volume Claim
        """
        if aws is not None:
            pulumi.set(__self__, "aws", aws)
        if instance_selector is not None:
            pulumi.set(__self__, "instance_selector", instance_selector)
        if restore is not None:
            pulumi.set(__self__, "restore", restore)
        if storage_class_name is not None:
            pulumi.set(__self__, "storage_class_name", storage_class_name)

    @property
    @pulumi.getter
    def aws(self) -> Optional['outputs.KeycloakBackupSpecAws']:
        """
        If provided, an automatic database backup will be created on AWS S3 instead of a local Persistent Volume. If this property is not provided - a local Persistent Volume backup will be chosen.
        """
        return pulumi.get(self, "aws")

    @property
    @pulumi.getter(name="instanceSelector")
    def instance_selector(self) -> Optional['outputs.KeycloakBackupSpecInstanceSelector']:
        """
        Selector for looking up Keycloak Custom Resources.
        """
        return pulumi.get(self, "instance_selector")

    @property
    @pulumi.getter
    def restore(self) -> Optional[bool]:
        """
        Controls automatic restore behavior. Currently not implemented. 
         In the future this will be used to trigger automatic restore for a given KeycloakBackup. Each backup will correspond to a single snapshot of the database (stored either in a Persistent Volume or AWS). If a user wants to restore it, all he/she needs to do is to change this flag to true. Potentially, it will be possible to restore a single backup multiple times.
        """
        return pulumi.get(self, "restore")

    @property
    @pulumi.getter(name="storageClassName")
    def storage_class_name(self) -> Optional[str]:
        """
        Name of the StorageClass for Postgresql Backup Persistent Volume Claim
        """
        return pulumi.get(self, "storage_class_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KeycloakBackupSpecAws(dict):
    """
    If provided, an automatic database backup will be created on AWS S3 instead of a local Persistent Volume. If this property is not provided - a local Persistent Volume backup will be chosen.
    """
    def __init__(__self__, *,
                 credentials_secret_name: Optional[str] = None,
                 encryption_key_secret_name: Optional[str] = None,
                 schedule: Optional[str] = None):
        """
        If provided, an automatic database backup will be created on AWS S3 instead of a local Persistent Volume. If this property is not provided - a local Persistent Volume backup will be chosen.
        :param str credentials_secret_name: Provides a secret name used for connecting to AWS S3 Service. The secret needs to be in the following form: 
                    apiVersion: v1     kind: Secret     metadata:       name: <Secret name>     type: Opaque     stringData:       AWS_S3_BUCKET_NAME: <S3 Bucket Name>       AWS_ACCESS_KEY_ID: <AWS Access Key ID>       AWS_SECRET_ACCESS_KEY: <AWS Secret Key> 
                For more information, please refer to the Operator documentation.
        :param str encryption_key_secret_name: If provided, the database backup will be encrypted. Provides a secret name used for encrypting database data. The secret needs to be in the following form: 
                    apiVersion: v1     kind: Secret     metadata:       name: <Secret name>     type: Opaque     stringData:       GPG_PUBLIC_KEY: <GPG Public Key>       GPG_TRUST_MODEL: <GPG Trust Model>       GPG_RECIPIENT: <GPG Recipient> 
                For more information, please refer to the Operator documentation.
        :param str schedule: If specified, it will be used as a schedule for creating a CronJob.
        """
        if credentials_secret_name is not None:
            pulumi.set(__self__, "credentials_secret_name", credentials_secret_name)
        if encryption_key_secret_name is not None:
            pulumi.set(__self__, "encryption_key_secret_name", encryption_key_secret_name)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)

    @property
    @pulumi.getter(name="credentialsSecretName")
    def credentials_secret_name(self) -> Optional[str]:
        """
        Provides a secret name used for connecting to AWS S3 Service. The secret needs to be in the following form: 
             apiVersion: v1     kind: Secret     metadata:       name: <Secret name>     type: Opaque     stringData:       AWS_S3_BUCKET_NAME: <S3 Bucket Name>       AWS_ACCESS_KEY_ID: <AWS Access Key ID>       AWS_SECRET_ACCESS_KEY: <AWS Secret Key> 
         For more information, please refer to the Operator documentation.
        """
        return pulumi.get(self, "credentials_secret_name")

    @property
    @pulumi.getter(name="encryptionKeySecretName")
    def encryption_key_secret_name(self) -> Optional[str]:
        """
        If provided, the database backup will be encrypted. Provides a secret name used for encrypting database data. The secret needs to be in the following form: 
             apiVersion: v1     kind: Secret     metadata:       name: <Secret name>     type: Opaque     stringData:       GPG_PUBLIC_KEY: <GPG Public Key>       GPG_TRUST_MODEL: <GPG Trust Model>       GPG_RECIPIENT: <GPG Recipient> 
         For more information, please refer to the Operator documentation.
        """
        return pulumi.get(self, "encryption_key_secret_name")

    @property
    @pulumi.getter
    def schedule(self) -> Optional[str]:
        """
        If specified, it will be used as a schedule for creating a CronJob.
        """
        return pulumi.get(self, "schedule")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KeycloakBackupSpecInstanceSelector(dict):
    """
    Selector for looking up Keycloak Custom Resources.
    """
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KeycloakBackupSpecInstanceSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        Selector for looking up Keycloak Custom Resources.
        :param Sequence['KeycloakBackupSpecInstanceSelectorMatchExpressionsArgs'] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KeycloakBackupSpecInstanceSelectorMatchExpressions']]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KeycloakBackupSpecInstanceSelectorMatchExpressions(dict):
    """
    A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
    """
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Optional[Sequence[str]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param str key: key is the label key that the selector applies to.
        :param str operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param Sequence[str] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KeycloakBackupStatus(dict):
    """
    KeycloakBackupStatus defines the observed state of KeycloakBackup.
    """
    def __init__(__self__, *,
                 message: str,
                 phase: str,
                 ready: bool,
                 secondary_resources: Optional[Mapping[str, Sequence[str]]] = None):
        """
        KeycloakBackupStatus defines the observed state of KeycloakBackup.
        :param str message: Human-readable message indicating details about current operator phase or error.
        :param str phase: Current phase of the operator.
        :param bool ready: True if all resources are in a ready state and all work is done.
        :param Mapping[str, Sequence[str]] secondary_resources: A map of all the secondary resources types and names created for this CR. e.g "Deployment": [ "DeploymentName1", "DeploymentName2" ]
        """
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "phase", phase)
        pulumi.set(__self__, "ready", ready)
        if secondary_resources is not None:
            pulumi.set(__self__, "secondary_resources", secondary_resources)

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        Human-readable message indicating details about current operator phase or error.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def phase(self) -> str:
        """
        Current phase of the operator.
        """
        return pulumi.get(self, "phase")

    @property
    @pulumi.getter
    def ready(self) -> bool:
        """
        True if all resources are in a ready state and all work is done.
        """
        return pulumi.get(self, "ready")

    @property
    @pulumi.getter(name="secondaryResources")
    def secondary_resources(self) -> Optional[Mapping[str, Sequence[str]]]:
        """
        A map of all the secondary resources types and names created for this CR. e.g "Deployment": [ "DeploymentName1", "DeploymentName2" ]
        """
        return pulumi.get(self, "secondary_resources")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KeycloakClientSpec(dict):
    """
    KeycloakClientSpec defines the desired state of KeycloakClient.
    """
    def __init__(__self__, *,
                 client: 'outputs.KeycloakClientSpecClient',
                 realm_selector: 'outputs.KeycloakClientSpecRealmSelector'):
        """
        KeycloakClientSpec defines the desired state of KeycloakClient.
        :param 'KeycloakClientSpecClientArgs' client: Keycloak Client REST object.
        :param 'KeycloakClientSpecRealmSelectorArgs' realm_selector: Selector for looking up KeycloakRealm Custom Resources.
        """
        pulumi.set(__self__, "client", client)
        pulumi.set(__self__, "realm_selector", realm_selector)

    @property
    @pulumi.getter
    def client(self) -> 'outputs.KeycloakClientSpecClient':
        """
        Keycloak Client REST object.
        """
        return pulumi.get(self, "client")

    @property
    @pulumi.getter(name="realmSelector")
    def realm_selector(self) -> 'outputs.KeycloakClientSpecRealmSelector':
        """
        Selector for looking up KeycloakRealm Custom Resources.
        """
        return pulumi.get(self, "realm_selector")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KeycloakClientSpecClient(dict):
    """
    Keycloak Client REST object.
    """
    def __init__(__self__, *,
                 client_id: str,
                 access: Optional[Mapping[str, bool]] = None,
                 admin_url: Optional[str] = None,
                 attributes: Optional[Mapping[str, str]] = None,
                 base_url: Optional[str] = None,
                 bearer_only: Optional[bool] = None,
                 client_authenticator_type: Optional[str] = None,
                 consent_required: Optional[bool] = None,
                 default_roles: Optional[Sequence[str]] = None,
                 description: Optional[str] = None,
                 direct_access_grants_enabled: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 frontchannel_logout: Optional[bool] = None,
                 full_scope_allowed: Optional[bool] = None,
                 id: Optional[str] = None,
                 implicit_flow_enabled: Optional[bool] = None,
                 name: Optional[str] = None,
                 node_re_registration_timeout: Optional[int] = None,
                 not_before: Optional[int] = None,
                 protocol: Optional[str] = None,
                 protocol_mappers: Optional[Sequence['outputs.KeycloakClientSpecClientProtocolMappers']] = None,
                 public_client: Optional[bool] = None,
                 redirect_uris: Optional[Sequence[str]] = None,
                 root_url: Optional[str] = None,
                 secret: Optional[str] = None,
                 service_accounts_enabled: Optional[bool] = None,
                 standard_flow_enabled: Optional[bool] = None,
                 surrogate_auth_required: Optional[bool] = None,
                 use_template_config: Optional[bool] = None,
                 use_template_mappers: Optional[bool] = None,
                 use_template_scope: Optional[bool] = None,
                 web_origins: Optional[Sequence[str]] = None):
        """
        Keycloak Client REST object.
        :param str client_id: Client ID.
        :param Mapping[str, bool] access: Access options.
        :param str admin_url: Application Admin URL.
        :param Mapping[str, str] attributes: Client Attributes.
        :param str base_url: Application base URL.
        :param bool bearer_only: True if a client supports only Bearer Tokens.
        :param str client_authenticator_type: What Client authentication type to use.
        :param bool consent_required: True if Consent Screen is required.
        :param Sequence[str] default_roles: Default Client roles.
        :param str description: Client description.
        :param bool direct_access_grants_enabled: True if Direct Grant is enabled.
        :param bool enabled: Client enabled flag.
        :param bool frontchannel_logout: True if this client supports Front Channel logout.
        :param bool full_scope_allowed: True if Full Scope is allowed.
        :param str id: Client ID. If not specified, automatically generated.
        :param bool implicit_flow_enabled: True if Implicit flow is enabled.
        :param str name: Client name.
        :param int node_re_registration_timeout: Node registration timeout.
        :param int not_before: Not Before setting.
        :param str protocol: Protocol used for this Client.
        :param Sequence['KeycloakClientSpecClientProtocolMappersArgs'] protocol_mappers: Protocol Mappers.
        :param bool public_client: True if this is a public Client.
        :param Sequence[str] redirect_uris: A list of valid Redirection URLs.
        :param str root_url: Application root URL.
        :param str secret: Client Secret. The Operator will automatically create a Secret based on this value.
        :param bool service_accounts_enabled: True if Service Accounts are enabled.
        :param bool standard_flow_enabled: True if Standard flow is enabled.
        :param bool surrogate_auth_required: Surrogate Authentication Required option.
        :param bool use_template_config: True to use a Template Config.
        :param bool use_template_mappers: True to use Template Mappers.
        :param bool use_template_scope: True to use Template Scope.
        :param Sequence[str] web_origins: A list of valid Web Origins.
        """
        pulumi.set(__self__, "client_id", client_id)
        if access is not None:
            pulumi.set(__self__, "access", access)
        if admin_url is not None:
            pulumi.set(__self__, "admin_url", admin_url)
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if base_url is not None:
            pulumi.set(__self__, "base_url", base_url)
        if bearer_only is not None:
            pulumi.set(__self__, "bearer_only", bearer_only)
        if client_authenticator_type is not None:
            pulumi.set(__self__, "client_authenticator_type", client_authenticator_type)
        if consent_required is not None:
            pulumi.set(__self__, "consent_required", consent_required)
        if default_roles is not None:
            pulumi.set(__self__, "default_roles", default_roles)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if direct_access_grants_enabled is not None:
            pulumi.set(__self__, "direct_access_grants_enabled", direct_access_grants_enabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if frontchannel_logout is not None:
            pulumi.set(__self__, "frontchannel_logout", frontchannel_logout)
        if full_scope_allowed is not None:
            pulumi.set(__self__, "full_scope_allowed", full_scope_allowed)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if implicit_flow_enabled is not None:
            pulumi.set(__self__, "implicit_flow_enabled", implicit_flow_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if node_re_registration_timeout is not None:
            pulumi.set(__self__, "node_re_registration_timeout", node_re_registration_timeout)
        if not_before is not None:
            pulumi.set(__self__, "not_before", not_before)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if protocol_mappers is not None:
            pulumi.set(__self__, "protocol_mappers", protocol_mappers)
        if public_client is not None:
            pulumi.set(__self__, "public_client", public_client)
        if redirect_uris is not None:
            pulumi.set(__self__, "redirect_uris", redirect_uris)
        if root_url is not None:
            pulumi.set(__self__, "root_url", root_url)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if service_accounts_enabled is not None:
            pulumi.set(__self__, "service_accounts_enabled", service_accounts_enabled)
        if standard_flow_enabled is not None:
            pulumi.set(__self__, "standard_flow_enabled", standard_flow_enabled)
        if surrogate_auth_required is not None:
            pulumi.set(__self__, "surrogate_auth_required", surrogate_auth_required)
        if use_template_config is not None:
            pulumi.set(__self__, "use_template_config", use_template_config)
        if use_template_mappers is not None:
            pulumi.set(__self__, "use_template_mappers", use_template_mappers)
        if use_template_scope is not None:
            pulumi.set(__self__, "use_template_scope", use_template_scope)
        if web_origins is not None:
            pulumi.set(__self__, "web_origins", web_origins)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        Client ID.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter
    def access(self) -> Optional[Mapping[str, bool]]:
        """
        Access options.
        """
        return pulumi.get(self, "access")

    @property
    @pulumi.getter(name="adminUrl")
    def admin_url(self) -> Optional[str]:
        """
        Application Admin URL.
        """
        return pulumi.get(self, "admin_url")

    @property
    @pulumi.getter
    def attributes(self) -> Optional[Mapping[str, str]]:
        """
        Client Attributes.
        """
        return pulumi.get(self, "attributes")

    @property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> Optional[str]:
        """
        Application base URL.
        """
        return pulumi.get(self, "base_url")

    @property
    @pulumi.getter(name="bearerOnly")
    def bearer_only(self) -> Optional[bool]:
        """
        True if a client supports only Bearer Tokens.
        """
        return pulumi.get(self, "bearer_only")

    @property
    @pulumi.getter(name="clientAuthenticatorType")
    def client_authenticator_type(self) -> Optional[str]:
        """
        What Client authentication type to use.
        """
        return pulumi.get(self, "client_authenticator_type")

    @property
    @pulumi.getter(name="consentRequired")
    def consent_required(self) -> Optional[bool]:
        """
        True if Consent Screen is required.
        """
        return pulumi.get(self, "consent_required")

    @property
    @pulumi.getter(name="defaultRoles")
    def default_roles(self) -> Optional[Sequence[str]]:
        """
        Default Client roles.
        """
        return pulumi.get(self, "default_roles")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Client description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="directAccessGrantsEnabled")
    def direct_access_grants_enabled(self) -> Optional[bool]:
        """
        True if Direct Grant is enabled.
        """
        return pulumi.get(self, "direct_access_grants_enabled")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Client enabled flag.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="frontchannelLogout")
    def frontchannel_logout(self) -> Optional[bool]:
        """
        True if this client supports Front Channel logout.
        """
        return pulumi.get(self, "frontchannel_logout")

    @property
    @pulumi.getter(name="fullScopeAllowed")
    def full_scope_allowed(self) -> Optional[bool]:
        """
        True if Full Scope is allowed.
        """
        return pulumi.get(self, "full_scope_allowed")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Client ID. If not specified, automatically generated.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="implicitFlowEnabled")
    def implicit_flow_enabled(self) -> Optional[bool]:
        """
        True if Implicit flow is enabled.
        """
        return pulumi.get(self, "implicit_flow_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Client name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nodeReRegistrationTimeout")
    def node_re_registration_timeout(self) -> Optional[int]:
        """
        Node registration timeout.
        """
        return pulumi.get(self, "node_re_registration_timeout")

    @property
    @pulumi.getter(name="notBefore")
    def not_before(self) -> Optional[int]:
        """
        Not Before setting.
        """
        return pulumi.get(self, "not_before")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Protocol used for this Client.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="protocolMappers")
    def protocol_mappers(self) -> Optional[Sequence['outputs.KeycloakClientSpecClientProtocolMappers']]:
        """
        Protocol Mappers.
        """
        return pulumi.get(self, "protocol_mappers")

    @property
    @pulumi.getter(name="publicClient")
    def public_client(self) -> Optional[bool]:
        """
        True if this is a public Client.
        """
        return pulumi.get(self, "public_client")

    @property
    @pulumi.getter(name="redirectUris")
    def redirect_uris(self) -> Optional[Sequence[str]]:
        """
        A list of valid Redirection URLs.
        """
        return pulumi.get(self, "redirect_uris")

    @property
    @pulumi.getter(name="rootUrl")
    def root_url(self) -> Optional[str]:
        """
        Application root URL.
        """
        return pulumi.get(self, "root_url")

    @property
    @pulumi.getter
    def secret(self) -> Optional[str]:
        """
        Client Secret. The Operator will automatically create a Secret based on this value.
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter(name="serviceAccountsEnabled")
    def service_accounts_enabled(self) -> Optional[bool]:
        """
        True if Service Accounts are enabled.
        """
        return pulumi.get(self, "service_accounts_enabled")

    @property
    @pulumi.getter(name="standardFlowEnabled")
    def standard_flow_enabled(self) -> Optional[bool]:
        """
        True if Standard flow is enabled.
        """
        return pulumi.get(self, "standard_flow_enabled")

    @property
    @pulumi.getter(name="surrogateAuthRequired")
    def surrogate_auth_required(self) -> Optional[bool]:
        """
        Surrogate Authentication Required option.
        """
        return pulumi.get(self, "surrogate_auth_required")

    @property
    @pulumi.getter(name="useTemplateConfig")
    def use_template_config(self) -> Optional[bool]:
        """
        True to use a Template Config.
        """
        return pulumi.get(self, "use_template_config")

    @property
    @pulumi.getter(name="useTemplateMappers")
    def use_template_mappers(self) -> Optional[bool]:
        """
        True to use Template Mappers.
        """
        return pulumi.get(self, "use_template_mappers")

    @property
    @pulumi.getter(name="useTemplateScope")
    def use_template_scope(self) -> Optional[bool]:
        """
        True to use Template Scope.
        """
        return pulumi.get(self, "use_template_scope")

    @property
    @pulumi.getter(name="webOrigins")
    def web_origins(self) -> Optional[Sequence[str]]:
        """
        A list of valid Web Origins.
        """
        return pulumi.get(self, "web_origins")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KeycloakClientSpecClientProtocolMappers(dict):
    def __init__(__self__, *,
                 config: Optional[Mapping[str, str]] = None,
                 consent_required: Optional[bool] = None,
                 consent_text: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 protocol: Optional[str] = None,
                 protocol_mapper: Optional[str] = None):
        """
        :param Mapping[str, str] config: Config options.
        :param bool consent_required: True if Consent Screen is required.
        :param str consent_text: Text to use for displaying Consent Screen.
        :param str id: Protocol Mapper ID.
        :param str name: Protocol Mapper Name.
        :param str protocol: Protocol to use.
        :param str protocol_mapper: Protocol Mapper to use
        """
        if config is not None:
            pulumi.set(__self__, "config", config)
        if consent_required is not None:
            pulumi.set(__self__, "consent_required", consent_required)
        if consent_text is not None:
            pulumi.set(__self__, "consent_text", consent_text)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if protocol_mapper is not None:
            pulumi.set(__self__, "protocol_mapper", protocol_mapper)

    @property
    @pulumi.getter
    def config(self) -> Optional[Mapping[str, str]]:
        """
        Config options.
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter(name="consentRequired")
    def consent_required(self) -> Optional[bool]:
        """
        True if Consent Screen is required.
        """
        return pulumi.get(self, "consent_required")

    @property
    @pulumi.getter(name="consentText")
    def consent_text(self) -> Optional[str]:
        """
        Text to use for displaying Consent Screen.
        """
        return pulumi.get(self, "consent_text")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Protocol Mapper ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Protocol Mapper Name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Protocol to use.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="protocolMapper")
    def protocol_mapper(self) -> Optional[str]:
        """
        Protocol Mapper to use
        """
        return pulumi.get(self, "protocol_mapper")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KeycloakClientSpecRealmSelector(dict):
    """
    Selector for looking up KeycloakRealm Custom Resources.
    """
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KeycloakClientSpecRealmSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        Selector for looking up KeycloakRealm Custom Resources.
        :param Sequence['KeycloakClientSpecRealmSelectorMatchExpressionsArgs'] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KeycloakClientSpecRealmSelectorMatchExpressions']]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KeycloakClientSpecRealmSelectorMatchExpressions(dict):
    """
    A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
    """
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Optional[Sequence[str]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param str key: key is the label key that the selector applies to.
        :param str operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param Sequence[str] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KeycloakClientStatus(dict):
    """
    KeycloakClientStatus defines the observed state of KeycloakClient
    """
    def __init__(__self__, *,
                 message: str,
                 phase: str,
                 ready: bool,
                 secondary_resources: Optional[Mapping[str, Sequence[str]]] = None):
        """
        KeycloakClientStatus defines the observed state of KeycloakClient
        :param str message: Human-readable message indicating details about current operator phase or error.
        :param str phase: Current phase of the operator.
        :param bool ready: True if all resources are in a ready state and all work is done.
        :param Mapping[str, Sequence[str]] secondary_resources: A map of all the secondary resources types and names created for this CR. e.g "Deployment": [ "DeploymentName1", "DeploymentName2" ]
        """
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "phase", phase)
        pulumi.set(__self__, "ready", ready)
        if secondary_resources is not None:
            pulumi.set(__self__, "secondary_resources", secondary_resources)

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        Human-readable message indicating details about current operator phase or error.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def phase(self) -> str:
        """
        Current phase of the operator.
        """
        return pulumi.get(self, "phase")

    @property
    @pulumi.getter
    def ready(self) -> bool:
        """
        True if all resources are in a ready state and all work is done.
        """
        return pulumi.get(self, "ready")

    @property
    @pulumi.getter(name="secondaryResources")
    def secondary_resources(self) -> Optional[Mapping[str, Sequence[str]]]:
        """
        A map of all the secondary resources types and names created for this CR. e.g "Deployment": [ "DeploymentName1", "DeploymentName2" ]
        """
        return pulumi.get(self, "secondary_resources")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KeycloakRealmSpec(dict):
    """
    KeycloakRealmSpec defines the desired state of KeycloakRealm.
    """
    def __init__(__self__, *,
                 realm: 'outputs.KeycloakRealmSpecRealm',
                 instance_selector: Optional['outputs.KeycloakRealmSpecInstanceSelector'] = None,
                 realm_overrides: Optional[Sequence['outputs.KeycloakRealmSpecRealmOverrides']] = None):
        """
        KeycloakRealmSpec defines the desired state of KeycloakRealm.
        :param 'KeycloakRealmSpecRealmArgs' realm: Keycloak Realm REST object.
        :param 'KeycloakRealmSpecInstanceSelectorArgs' instance_selector: Selector for looking up Keycloak Custom Resources.
        :param Sequence['KeycloakRealmSpecRealmOverridesArgs'] realm_overrides: A list of overrides to the default Realm behavior.
        """
        pulumi.set(__self__, "realm", realm)
        if instance_selector is not None:
            pulumi.set(__self__, "instance_selector", instance_selector)
        if realm_overrides is not None:
            pulumi.set(__self__, "realm_overrides", realm_overrides)

    @property
    @pulumi.getter
    def realm(self) -> 'outputs.KeycloakRealmSpecRealm':
        """
        Keycloak Realm REST object.
        """
        return pulumi.get(self, "realm")

    @property
    @pulumi.getter(name="instanceSelector")
    def instance_selector(self) -> Optional['outputs.KeycloakRealmSpecInstanceSelector']:
        """
        Selector for looking up Keycloak Custom Resources.
        """
        return pulumi.get(self, "instance_selector")

    @property
    @pulumi.getter(name="realmOverrides")
    def realm_overrides(self) -> Optional[Sequence['outputs.KeycloakRealmSpecRealmOverrides']]:
        """
        A list of overrides to the default Realm behavior.
        """
        return pulumi.get(self, "realm_overrides")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KeycloakRealmSpecInstanceSelector(dict):
    """
    Selector for looking up Keycloak Custom Resources.
    """
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KeycloakRealmSpecInstanceSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        Selector for looking up Keycloak Custom Resources.
        :param Sequence['KeycloakRealmSpecInstanceSelectorMatchExpressionsArgs'] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KeycloakRealmSpecInstanceSelectorMatchExpressions']]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KeycloakRealmSpecInstanceSelectorMatchExpressions(dict):
    """
    A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
    """
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Optional[Sequence[str]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param str key: key is the label key that the selector applies to.
        :param str operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param Sequence[str] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KeycloakRealmSpecRealm(dict):
    """
    Keycloak Realm REST object.
    """
    def __init__(__self__, *,
                 realm: str,
                 admin_events_details_enabled: Optional[bool] = None,
                 admin_events_enabled: Optional[bool] = None,
                 clients: Optional[Sequence['outputs.KeycloakRealmSpecRealmClients']] = None,
                 display_name: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 events_enabled: Optional[bool] = None,
                 events_listeners: Optional[Sequence[str]] = None,
                 id: Optional[str] = None,
                 identity_providers: Optional[Sequence['outputs.KeycloakRealmSpecRealmIdentityProviders']] = None,
                 users: Optional[Sequence['outputs.KeycloakRealmSpecRealmUsers']] = None):
        """
        Keycloak Realm REST object.
        :param str realm: Realm name.
        :param bool admin_events_details_enabled: Enable admin events details TODO: change to values and use kubebuilder default annotation once supported
        :param bool admin_events_enabled: Enable events recording TODO: change to values and use kubebuilder default annotation once supported
        :param Sequence['KeycloakRealmSpecRealmClientsArgs'] clients: A set of Keycloak Clients.
        :param str display_name: Realm display name.
        :param bool enabled: Realm enabled flag.
        :param bool events_enabled: Enable events recording TODO: change to values and use kubebuilder default annotation once supported
        :param Sequence[str] events_listeners: A set of Event Listeners.
        :param Sequence['KeycloakRealmSpecRealmIdentityProvidersArgs'] identity_providers: A set of Identity Providers.
        :param Sequence['KeycloakRealmSpecRealmUsersArgs'] users: A set of Keycloak Users.
        """
        pulumi.set(__self__, "realm", realm)
        if admin_events_details_enabled is not None:
            pulumi.set(__self__, "admin_events_details_enabled", admin_events_details_enabled)
        if admin_events_enabled is not None:
            pulumi.set(__self__, "admin_events_enabled", admin_events_enabled)
        if clients is not None:
            pulumi.set(__self__, "clients", clients)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if events_enabled is not None:
            pulumi.set(__self__, "events_enabled", events_enabled)
        if events_listeners is not None:
            pulumi.set(__self__, "events_listeners", events_listeners)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if identity_providers is not None:
            pulumi.set(__self__, "identity_providers", identity_providers)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def realm(self) -> str:
        """
        Realm name.
        """
        return pulumi.get(self, "realm")

    @property
    @pulumi.getter(name="adminEventsDetailsEnabled")
    def admin_events_details_enabled(self) -> Optional[bool]:
        """
        Enable admin events details TODO: change to values and use kubebuilder default annotation once supported
        """
        return pulumi.get(self, "admin_events_details_enabled")

    @property
    @pulumi.getter(name="adminEventsEnabled")
    def admin_events_enabled(self) -> Optional[bool]:
        """
        Enable events recording TODO: change to values and use kubebuilder default annotation once supported
        """
        return pulumi.get(self, "admin_events_enabled")

    @property
    @pulumi.getter
    def clients(self) -> Optional[Sequence['outputs.KeycloakRealmSpecRealmClients']]:
        """
        A set of Keycloak Clients.
        """
        return pulumi.get(self, "clients")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        Realm display name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Realm enabled flag.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="eventsEnabled")
    def events_enabled(self) -> Optional[bool]:
        """
        Enable events recording TODO: change to values and use kubebuilder default annotation once supported
        """
        return pulumi.get(self, "events_enabled")

    @property
    @pulumi.getter(name="eventsListeners")
    def events_listeners(self) -> Optional[Sequence[str]]:
        """
        A set of Event Listeners.
        """
        return pulumi.get(self, "events_listeners")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="identityProviders")
    def identity_providers(self) -> Optional[Sequence['outputs.KeycloakRealmSpecRealmIdentityProviders']]:
        """
        A set of Identity Providers.
        """
        return pulumi.get(self, "identity_providers")

    @property
    @pulumi.getter
    def users(self) -> Optional[Sequence['outputs.KeycloakRealmSpecRealmUsers']]:
        """
        A set of Keycloak Users.
        """
        return pulumi.get(self, "users")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KeycloakRealmSpecRealmClients(dict):
    def __init__(__self__, *,
                 client_id: str,
                 access: Optional[Mapping[str, bool]] = None,
                 admin_url: Optional[str] = None,
                 attributes: Optional[Mapping[str, str]] = None,
                 base_url: Optional[str] = None,
                 bearer_only: Optional[bool] = None,
                 client_authenticator_type: Optional[str] = None,
                 consent_required: Optional[bool] = None,
                 default_roles: Optional[Sequence[str]] = None,
                 description: Optional[str] = None,
                 direct_access_grants_enabled: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 frontchannel_logout: Optional[bool] = None,
                 full_scope_allowed: Optional[bool] = None,
                 id: Optional[str] = None,
                 implicit_flow_enabled: Optional[bool] = None,
                 name: Optional[str] = None,
                 node_re_registration_timeout: Optional[int] = None,
                 not_before: Optional[int] = None,
                 protocol: Optional[str] = None,
                 protocol_mappers: Optional[Sequence['outputs.KeycloakRealmSpecRealmClientsProtocolMappers']] = None,
                 public_client: Optional[bool] = None,
                 redirect_uris: Optional[Sequence[str]] = None,
                 root_url: Optional[str] = None,
                 secret: Optional[str] = None,
                 service_accounts_enabled: Optional[bool] = None,
                 standard_flow_enabled: Optional[bool] = None,
                 surrogate_auth_required: Optional[bool] = None,
                 use_template_config: Optional[bool] = None,
                 use_template_mappers: Optional[bool] = None,
                 use_template_scope: Optional[bool] = None,
                 web_origins: Optional[Sequence[str]] = None):
        """
        :param str client_id: Client ID.
        :param Mapping[str, bool] access: Access options.
        :param str admin_url: Application Admin URL.
        :param Mapping[str, str] attributes: Client Attributes.
        :param str base_url: Application base URL.
        :param bool bearer_only: True if a client supports only Bearer Tokens.
        :param str client_authenticator_type: What Client authentication type to use.
        :param bool consent_required: True if Consent Screen is required.
        :param Sequence[str] default_roles: Default Client roles.
        :param str description: Client description.
        :param bool direct_access_grants_enabled: True if Direct Grant is enabled.
        :param bool enabled: Client enabled flag.
        :param bool frontchannel_logout: True if this client supports Front Channel logout.
        :param bool full_scope_allowed: True if Full Scope is allowed.
        :param str id: Client ID. If not specified, automatically generated.
        :param bool implicit_flow_enabled: True if Implicit flow is enabled.
        :param str name: Client name.
        :param int node_re_registration_timeout: Node registration timeout.
        :param int not_before: Not Before setting.
        :param str protocol: Protocol used for this Client.
        :param Sequence['KeycloakRealmSpecRealmClientsProtocolMappersArgs'] protocol_mappers: Protocol Mappers.
        :param bool public_client: True if this is a public Client.
        :param Sequence[str] redirect_uris: A list of valid Redirection URLs.
        :param str root_url: Application root URL.
        :param str secret: Client Secret. The Operator will automatically create a Secret based on this value.
        :param bool service_accounts_enabled: True if Service Accounts are enabled.
        :param bool standard_flow_enabled: True if Standard flow is enabled.
        :param bool surrogate_auth_required: Surrogate Authentication Required option.
        :param bool use_template_config: True to use a Template Config.
        :param bool use_template_mappers: True to use Template Mappers.
        :param bool use_template_scope: True to use Template Scope.
        :param Sequence[str] web_origins: A list of valid Web Origins.
        """
        pulumi.set(__self__, "client_id", client_id)
        if access is not None:
            pulumi.set(__self__, "access", access)
        if admin_url is not None:
            pulumi.set(__self__, "admin_url", admin_url)
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if base_url is not None:
            pulumi.set(__self__, "base_url", base_url)
        if bearer_only is not None:
            pulumi.set(__self__, "bearer_only", bearer_only)
        if client_authenticator_type is not None:
            pulumi.set(__self__, "client_authenticator_type", client_authenticator_type)
        if consent_required is not None:
            pulumi.set(__self__, "consent_required", consent_required)
        if default_roles is not None:
            pulumi.set(__self__, "default_roles", default_roles)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if direct_access_grants_enabled is not None:
            pulumi.set(__self__, "direct_access_grants_enabled", direct_access_grants_enabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if frontchannel_logout is not None:
            pulumi.set(__self__, "frontchannel_logout", frontchannel_logout)
        if full_scope_allowed is not None:
            pulumi.set(__self__, "full_scope_allowed", full_scope_allowed)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if implicit_flow_enabled is not None:
            pulumi.set(__self__, "implicit_flow_enabled", implicit_flow_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if node_re_registration_timeout is not None:
            pulumi.set(__self__, "node_re_registration_timeout", node_re_registration_timeout)
        if not_before is not None:
            pulumi.set(__self__, "not_before", not_before)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if protocol_mappers is not None:
            pulumi.set(__self__, "protocol_mappers", protocol_mappers)
        if public_client is not None:
            pulumi.set(__self__, "public_client", public_client)
        if redirect_uris is not None:
            pulumi.set(__self__, "redirect_uris", redirect_uris)
        if root_url is not None:
            pulumi.set(__self__, "root_url", root_url)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if service_accounts_enabled is not None:
            pulumi.set(__self__, "service_accounts_enabled", service_accounts_enabled)
        if standard_flow_enabled is not None:
            pulumi.set(__self__, "standard_flow_enabled", standard_flow_enabled)
        if surrogate_auth_required is not None:
            pulumi.set(__self__, "surrogate_auth_required", surrogate_auth_required)
        if use_template_config is not None:
            pulumi.set(__self__, "use_template_config", use_template_config)
        if use_template_mappers is not None:
            pulumi.set(__self__, "use_template_mappers", use_template_mappers)
        if use_template_scope is not None:
            pulumi.set(__self__, "use_template_scope", use_template_scope)
        if web_origins is not None:
            pulumi.set(__self__, "web_origins", web_origins)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        Client ID.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter
    def access(self) -> Optional[Mapping[str, bool]]:
        """
        Access options.
        """
        return pulumi.get(self, "access")

    @property
    @pulumi.getter(name="adminUrl")
    def admin_url(self) -> Optional[str]:
        """
        Application Admin URL.
        """
        return pulumi.get(self, "admin_url")

    @property
    @pulumi.getter
    def attributes(self) -> Optional[Mapping[str, str]]:
        """
        Client Attributes.
        """
        return pulumi.get(self, "attributes")

    @property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> Optional[str]:
        """
        Application base URL.
        """
        return pulumi.get(self, "base_url")

    @property
    @pulumi.getter(name="bearerOnly")
    def bearer_only(self) -> Optional[bool]:
        """
        True if a client supports only Bearer Tokens.
        """
        return pulumi.get(self, "bearer_only")

    @property
    @pulumi.getter(name="clientAuthenticatorType")
    def client_authenticator_type(self) -> Optional[str]:
        """
        What Client authentication type to use.
        """
        return pulumi.get(self, "client_authenticator_type")

    @property
    @pulumi.getter(name="consentRequired")
    def consent_required(self) -> Optional[bool]:
        """
        True if Consent Screen is required.
        """
        return pulumi.get(self, "consent_required")

    @property
    @pulumi.getter(name="defaultRoles")
    def default_roles(self) -> Optional[Sequence[str]]:
        """
        Default Client roles.
        """
        return pulumi.get(self, "default_roles")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Client description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="directAccessGrantsEnabled")
    def direct_access_grants_enabled(self) -> Optional[bool]:
        """
        True if Direct Grant is enabled.
        """
        return pulumi.get(self, "direct_access_grants_enabled")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Client enabled flag.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="frontchannelLogout")
    def frontchannel_logout(self) -> Optional[bool]:
        """
        True if this client supports Front Channel logout.
        """
        return pulumi.get(self, "frontchannel_logout")

    @property
    @pulumi.getter(name="fullScopeAllowed")
    def full_scope_allowed(self) -> Optional[bool]:
        """
        True if Full Scope is allowed.
        """
        return pulumi.get(self, "full_scope_allowed")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Client ID. If not specified, automatically generated.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="implicitFlowEnabled")
    def implicit_flow_enabled(self) -> Optional[bool]:
        """
        True if Implicit flow is enabled.
        """
        return pulumi.get(self, "implicit_flow_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Client name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nodeReRegistrationTimeout")
    def node_re_registration_timeout(self) -> Optional[int]:
        """
        Node registration timeout.
        """
        return pulumi.get(self, "node_re_registration_timeout")

    @property
    @pulumi.getter(name="notBefore")
    def not_before(self) -> Optional[int]:
        """
        Not Before setting.
        """
        return pulumi.get(self, "not_before")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Protocol used for this Client.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="protocolMappers")
    def protocol_mappers(self) -> Optional[Sequence['outputs.KeycloakRealmSpecRealmClientsProtocolMappers']]:
        """
        Protocol Mappers.
        """
        return pulumi.get(self, "protocol_mappers")

    @property
    @pulumi.getter(name="publicClient")
    def public_client(self) -> Optional[bool]:
        """
        True if this is a public Client.
        """
        return pulumi.get(self, "public_client")

    @property
    @pulumi.getter(name="redirectUris")
    def redirect_uris(self) -> Optional[Sequence[str]]:
        """
        A list of valid Redirection URLs.
        """
        return pulumi.get(self, "redirect_uris")

    @property
    @pulumi.getter(name="rootUrl")
    def root_url(self) -> Optional[str]:
        """
        Application root URL.
        """
        return pulumi.get(self, "root_url")

    @property
    @pulumi.getter
    def secret(self) -> Optional[str]:
        """
        Client Secret. The Operator will automatically create a Secret based on this value.
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter(name="serviceAccountsEnabled")
    def service_accounts_enabled(self) -> Optional[bool]:
        """
        True if Service Accounts are enabled.
        """
        return pulumi.get(self, "service_accounts_enabled")

    @property
    @pulumi.getter(name="standardFlowEnabled")
    def standard_flow_enabled(self) -> Optional[bool]:
        """
        True if Standard flow is enabled.
        """
        return pulumi.get(self, "standard_flow_enabled")

    @property
    @pulumi.getter(name="surrogateAuthRequired")
    def surrogate_auth_required(self) -> Optional[bool]:
        """
        Surrogate Authentication Required option.
        """
        return pulumi.get(self, "surrogate_auth_required")

    @property
    @pulumi.getter(name="useTemplateConfig")
    def use_template_config(self) -> Optional[bool]:
        """
        True to use a Template Config.
        """
        return pulumi.get(self, "use_template_config")

    @property
    @pulumi.getter(name="useTemplateMappers")
    def use_template_mappers(self) -> Optional[bool]:
        """
        True to use Template Mappers.
        """
        return pulumi.get(self, "use_template_mappers")

    @property
    @pulumi.getter(name="useTemplateScope")
    def use_template_scope(self) -> Optional[bool]:
        """
        True to use Template Scope.
        """
        return pulumi.get(self, "use_template_scope")

    @property
    @pulumi.getter(name="webOrigins")
    def web_origins(self) -> Optional[Sequence[str]]:
        """
        A list of valid Web Origins.
        """
        return pulumi.get(self, "web_origins")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KeycloakRealmSpecRealmClientsProtocolMappers(dict):
    def __init__(__self__, *,
                 config: Optional[Mapping[str, str]] = None,
                 consent_required: Optional[bool] = None,
                 consent_text: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 protocol: Optional[str] = None,
                 protocol_mapper: Optional[str] = None):
        """
        :param Mapping[str, str] config: Config options.
        :param bool consent_required: True if Consent Screen is required.
        :param str consent_text: Text to use for displaying Consent Screen.
        :param str id: Protocol Mapper ID.
        :param str name: Protocol Mapper Name.
        :param str protocol: Protocol to use.
        :param str protocol_mapper: Protocol Mapper to use
        """
        if config is not None:
            pulumi.set(__self__, "config", config)
        if consent_required is not None:
            pulumi.set(__self__, "consent_required", consent_required)
        if consent_text is not None:
            pulumi.set(__self__, "consent_text", consent_text)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if protocol_mapper is not None:
            pulumi.set(__self__, "protocol_mapper", protocol_mapper)

    @property
    @pulumi.getter
    def config(self) -> Optional[Mapping[str, str]]:
        """
        Config options.
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter(name="consentRequired")
    def consent_required(self) -> Optional[bool]:
        """
        True if Consent Screen is required.
        """
        return pulumi.get(self, "consent_required")

    @property
    @pulumi.getter(name="consentText")
    def consent_text(self) -> Optional[str]:
        """
        Text to use for displaying Consent Screen.
        """
        return pulumi.get(self, "consent_text")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Protocol Mapper ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Protocol Mapper Name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Protocol to use.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="protocolMapper")
    def protocol_mapper(self) -> Optional[str]:
        """
        Protocol Mapper to use
        """
        return pulumi.get(self, "protocol_mapper")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KeycloakRealmSpecRealmIdentityProviders(dict):
    def __init__(__self__, *,
                 add_read_token_role_on_create: Optional[bool] = None,
                 alias: Optional[str] = None,
                 config: Optional[Mapping[str, str]] = None,
                 display_name: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 first_broker_login_flow_alias: Optional[str] = None,
                 internal_id: Optional[str] = None,
                 link_only: Optional[bool] = None,
                 post_broker_login_flow_alias: Optional[str] = None,
                 provider_id: Optional[str] = None,
                 store_token: Optional[bool] = None,
                 trust_email: Optional[bool] = None):
        """
        :param bool add_read_token_role_on_create: Adds Read Token role when creating this Identity Provider.
        :param str alias: Identity Provider Alias.
        :param Mapping[str, str] config: Identity Provider config.
        :param str display_name: Identity Provider Display Name.
        :param bool enabled: Identity Provider enabled flag.
        :param str first_broker_login_flow_alias: Identity Provider First Broker Login Flow Alias.
        :param str internal_id: Identity Provider Internal ID.
        :param bool link_only: Identity Provider Link Only setting.
        :param str post_broker_login_flow_alias: Identity Provider Post Broker Login Flow Alias.
        :param str provider_id: Identity Provider ID.
        :param bool store_token: Identity Provider Store to Token.
        :param bool trust_email: Identity Provider Trust Email.
        """
        if add_read_token_role_on_create is not None:
            pulumi.set(__self__, "add_read_token_role_on_create", add_read_token_role_on_create)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if first_broker_login_flow_alias is not None:
            pulumi.set(__self__, "first_broker_login_flow_alias", first_broker_login_flow_alias)
        if internal_id is not None:
            pulumi.set(__self__, "internal_id", internal_id)
        if link_only is not None:
            pulumi.set(__self__, "link_only", link_only)
        if post_broker_login_flow_alias is not None:
            pulumi.set(__self__, "post_broker_login_flow_alias", post_broker_login_flow_alias)
        if provider_id is not None:
            pulumi.set(__self__, "provider_id", provider_id)
        if store_token is not None:
            pulumi.set(__self__, "store_token", store_token)
        if trust_email is not None:
            pulumi.set(__self__, "trust_email", trust_email)

    @property
    @pulumi.getter(name="addReadTokenRoleOnCreate")
    def add_read_token_role_on_create(self) -> Optional[bool]:
        """
        Adds Read Token role when creating this Identity Provider.
        """
        return pulumi.get(self, "add_read_token_role_on_create")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        Identity Provider Alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter
    def config(self) -> Optional[Mapping[str, str]]:
        """
        Identity Provider config.
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        Identity Provider Display Name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Identity Provider enabled flag.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="firstBrokerLoginFlowAlias")
    def first_broker_login_flow_alias(self) -> Optional[str]:
        """
        Identity Provider First Broker Login Flow Alias.
        """
        return pulumi.get(self, "first_broker_login_flow_alias")

    @property
    @pulumi.getter(name="internalId")
    def internal_id(self) -> Optional[str]:
        """
        Identity Provider Internal ID.
        """
        return pulumi.get(self, "internal_id")

    @property
    @pulumi.getter(name="linkOnly")
    def link_only(self) -> Optional[bool]:
        """
        Identity Provider Link Only setting.
        """
        return pulumi.get(self, "link_only")

    @property
    @pulumi.getter(name="postBrokerLoginFlowAlias")
    def post_broker_login_flow_alias(self) -> Optional[str]:
        """
        Identity Provider Post Broker Login Flow Alias.
        """
        return pulumi.get(self, "post_broker_login_flow_alias")

    @property
    @pulumi.getter(name="providerId")
    def provider_id(self) -> Optional[str]:
        """
        Identity Provider ID.
        """
        return pulumi.get(self, "provider_id")

    @property
    @pulumi.getter(name="storeToken")
    def store_token(self) -> Optional[bool]:
        """
        Identity Provider Store to Token.
        """
        return pulumi.get(self, "store_token")

    @property
    @pulumi.getter(name="trustEmail")
    def trust_email(self) -> Optional[bool]:
        """
        Identity Provider Trust Email.
        """
        return pulumi.get(self, "trust_email")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KeycloakRealmSpecRealmOverrides(dict):
    def __init__(__self__, *,
                 for_flow: Optional[str] = None,
                 identity_provider: Optional[str] = None):
        """
        :param str for_flow: Flow to be overridden.
        :param str identity_provider: Identity Provider to be overridden.
        """
        if for_flow is not None:
            pulumi.set(__self__, "for_flow", for_flow)
        if identity_provider is not None:
            pulumi.set(__self__, "identity_provider", identity_provider)

    @property
    @pulumi.getter(name="forFlow")
    def for_flow(self) -> Optional[str]:
        """
        Flow to be overridden.
        """
        return pulumi.get(self, "for_flow")

    @property
    @pulumi.getter(name="identityProvider")
    def identity_provider(self) -> Optional[str]:
        """
        Identity Provider to be overridden.
        """
        return pulumi.get(self, "identity_provider")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KeycloakRealmSpecRealmUsers(dict):
    def __init__(__self__, *,
                 attributes: Optional[Mapping[str, Sequence[str]]] = None,
                 client_roles: Optional[Mapping[str, Sequence[str]]] = None,
                 credentials: Optional[Sequence['outputs.KeycloakRealmSpecRealmUsersCredentials']] = None,
                 email: Optional[str] = None,
                 email_verified: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 federated_identities: Optional[Sequence['outputs.KeycloakRealmSpecRealmUsersFederatedIdentities']] = None,
                 first_name: Optional[str] = None,
                 groups: Optional[Sequence[str]] = None,
                 id: Optional[str] = None,
                 last_name: Optional[str] = None,
                 realm_roles: Optional[Sequence[str]] = None,
                 required_actions: Optional[Sequence[str]] = None,
                 username: Optional[str] = None):
        """
        :param Mapping[str, Sequence[str]] attributes: A set of Attributes.
        :param Mapping[str, Sequence[str]] client_roles: A set of Client Roles.
        :param Sequence['KeycloakRealmSpecRealmUsersCredentialsArgs'] credentials: A set of Credentials.
        :param str email: Email.
        :param bool email_verified: True if email has already been verified.
        :param bool enabled: User enabled flag.
        :param Sequence['KeycloakRealmSpecRealmUsersFederatedIdentitiesArgs'] federated_identities: A set of Federated Identities.
        :param str first_name: First Name.
        :param Sequence[str] groups: A set of Groups.
        :param str id: User ID.
        :param str last_name: Last Name.
        :param Sequence[str] realm_roles: A set of Realm Roles.
        :param Sequence[str] required_actions: A set of Required Actions.
        :param str username: User Name.
        """
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if client_roles is not None:
            pulumi.set(__self__, "client_roles", client_roles)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if email_verified is not None:
            pulumi.set(__self__, "email_verified", email_verified)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if federated_identities is not None:
            pulumi.set(__self__, "federated_identities", federated_identities)
        if first_name is not None:
            pulumi.set(__self__, "first_name", first_name)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if last_name is not None:
            pulumi.set(__self__, "last_name", last_name)
        if realm_roles is not None:
            pulumi.set(__self__, "realm_roles", realm_roles)
        if required_actions is not None:
            pulumi.set(__self__, "required_actions", required_actions)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def attributes(self) -> Optional[Mapping[str, Sequence[str]]]:
        """
        A set of Attributes.
        """
        return pulumi.get(self, "attributes")

    @property
    @pulumi.getter(name="clientRoles")
    def client_roles(self) -> Optional[Mapping[str, Sequence[str]]]:
        """
        A set of Client Roles.
        """
        return pulumi.get(self, "client_roles")

    @property
    @pulumi.getter
    def credentials(self) -> Optional[Sequence['outputs.KeycloakRealmSpecRealmUsersCredentials']]:
        """
        A set of Credentials.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        """
        Email.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="emailVerified")
    def email_verified(self) -> Optional[bool]:
        """
        True if email has already been verified.
        """
        return pulumi.get(self, "email_verified")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        User enabled flag.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="federatedIdentities")
    def federated_identities(self) -> Optional[Sequence['outputs.KeycloakRealmSpecRealmUsersFederatedIdentities']]:
        """
        A set of Federated Identities.
        """
        return pulumi.get(self, "federated_identities")

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> Optional[str]:
        """
        First Name.
        """
        return pulumi.get(self, "first_name")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[str]]:
        """
        A set of Groups.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        User ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> Optional[str]:
        """
        Last Name.
        """
        return pulumi.get(self, "last_name")

    @property
    @pulumi.getter(name="realmRoles")
    def realm_roles(self) -> Optional[Sequence[str]]:
        """
        A set of Realm Roles.
        """
        return pulumi.get(self, "realm_roles")

    @property
    @pulumi.getter(name="requiredActions")
    def required_actions(self) -> Optional[Sequence[str]]:
        """
        A set of Required Actions.
        """
        return pulumi.get(self, "required_actions")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        User Name.
        """
        return pulumi.get(self, "username")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KeycloakRealmSpecRealmUsersCredentials(dict):
    def __init__(__self__, *,
                 temporary: Optional[bool] = None,
                 type: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param bool temporary: True if this credential object is temporary.
        :param str type: Credential Type.
        :param str value: Credential Value.
        """
        if temporary is not None:
            pulumi.set(__self__, "temporary", temporary)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def temporary(self) -> Optional[bool]:
        """
        True if this credential object is temporary.
        """
        return pulumi.get(self, "temporary")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Credential Type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Credential Value.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KeycloakRealmSpecRealmUsersFederatedIdentities(dict):
    def __init__(__self__, *,
                 identity_provider: Optional[str] = None,
                 user_id: Optional[str] = None,
                 user_name: Optional[str] = None):
        """
        :param str identity_provider: Federated Identity Provider.
        :param str user_id: Federated Identity User ID.
        :param str user_name: Federated Identity User Name.
        """
        if identity_provider is not None:
            pulumi.set(__self__, "identity_provider", identity_provider)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="identityProvider")
    def identity_provider(self) -> Optional[str]:
        """
        Federated Identity Provider.
        """
        return pulumi.get(self, "identity_provider")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[str]:
        """
        Federated Identity User ID.
        """
        return pulumi.get(self, "user_id")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[str]:
        """
        Federated Identity User Name.
        """
        return pulumi.get(self, "user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KeycloakRealmStatus(dict):
    """
    KeycloakRealmStatus defines the observed state of KeycloakRealm
    """
    def __init__(__self__, *,
                 login_url: str,
                 message: str,
                 phase: str,
                 ready: bool,
                 secondary_resources: Optional[Mapping[str, Sequence[str]]] = None):
        """
        KeycloakRealmStatus defines the observed state of KeycloakRealm
        :param str login_url: TODO
        :param str message: Human-readable message indicating details about current operator phase or error.
        :param str phase: Current phase of the operator.
        :param bool ready: True if all resources are in a ready state and all work is done.
        :param Mapping[str, Sequence[str]] secondary_resources: A map of all the secondary resources types and names created for this CR. e.g "Deployment": [ "DeploymentName1", "DeploymentName2" ]
        """
        pulumi.set(__self__, "login_url", login_url)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "phase", phase)
        pulumi.set(__self__, "ready", ready)
        if secondary_resources is not None:
            pulumi.set(__self__, "secondary_resources", secondary_resources)

    @property
    @pulumi.getter(name="loginURL")
    def login_url(self) -> str:
        """
        TODO
        """
        return pulumi.get(self, "login_url")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        Human-readable message indicating details about current operator phase or error.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def phase(self) -> str:
        """
        Current phase of the operator.
        """
        return pulumi.get(self, "phase")

    @property
    @pulumi.getter
    def ready(self) -> bool:
        """
        True if all resources are in a ready state and all work is done.
        """
        return pulumi.get(self, "ready")

    @property
    @pulumi.getter(name="secondaryResources")
    def secondary_resources(self) -> Optional[Mapping[str, Sequence[str]]]:
        """
        A map of all the secondary resources types and names created for this CR. e.g "Deployment": [ "DeploymentName1", "DeploymentName2" ]
        """
        return pulumi.get(self, "secondary_resources")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KeycloakSpec(dict):
    """
    KeycloakSpec defines the desired state of Keycloak.
    """
    def __init__(__self__, *,
                 extensions: Optional[Sequence[str]] = None,
                 external_access: Optional['outputs.KeycloakSpecExternalAccess'] = None,
                 external_database: Optional['outputs.KeycloakSpecExternalDatabase'] = None,
                 instances: Optional[int] = None,
                 keycloak_deployment_spec: Optional['outputs.KeycloakSpecKeycloakDeploymentSpec'] = None,
                 migration: Optional['outputs.KeycloakSpecMigration'] = None,
                 pod_disruption_budget: Optional['outputs.KeycloakSpecPodDisruptionBudget'] = None,
                 postgres_deployment_spec: Optional['outputs.KeycloakSpecPostgresDeploymentSpec'] = None,
                 profile: Optional[str] = None,
                 storage_class_name: Optional[str] = None):
        """
        KeycloakSpec defines the desired state of Keycloak.
        :param Sequence[str] extensions: A list of extensions, where each one is a URL to a JAR files that will be deployed in Keycloak.
        :param 'KeycloakSpecExternalAccessArgs' external_access: Controls external Ingress/Route settings.
        :param 'KeycloakSpecExternalDatabaseArgs' external_database: Controls external database settings. Using an external database requires providing a secret containing credentials as well as connection details. Here's an example of such secret: 
                    apiVersion: v1     kind: Secret     metadata:         name: keycloak-db-secret         namespace: keycloak     stringData:         POSTGRES_DATABASE: <Database Name>         POSTGRES_EXTERNAL_ADDRESS: <External Database IP or URL (resolvable by K8s)>         POSTGRES_EXTERNAL_PORT: <External Database Port>         # Strongly recommended to use <'Keycloak CR Name'-postgresql>         POSTGRES_HOST: <Database Service Name>         POSTGRES_PASSWORD: <Database Password>         # Required for AWS Backup functionality         POSTGRES_SUPERUSER: true         POSTGRES_USERNAME: <Database Username>      type: Opaque 
                Both POSTGRES_EXTERNAL_ADDRESS and POSTGRES_EXTERNAL_PORT are specifically required for creating connection to the external database. The secret name is created using the following convention:       <Custom Resource Name>-db-secret 
                For more information, please refer to the Operator documentation.
        :param int instances: Number of Keycloak instances in HA mode. Default is 1.
        :param 'KeycloakSpecKeycloakDeploymentSpecArgs' keycloak_deployment_spec: Resources (Requests and Limits) for KeycloakDeployment.
        :param 'KeycloakSpecMigrationArgs' migration: Specify Migration configuration
        :param 'KeycloakSpecPodDisruptionBudgetArgs' pod_disruption_budget: Specify PodDisruptionBudget configuration.
        :param 'KeycloakSpecPostgresDeploymentSpecArgs' postgres_deployment_spec: Resources (Requests and Limits) for PostgresDeployment.
        :param str profile: Profile used for controlling Operator behavior. Default is empty.
        :param str storage_class_name: Name of the StorageClass for Postgresql Persistent Volume Claim
        """
        if extensions is not None:
            pulumi.set(__self__, "extensions", extensions)
        if external_access is not None:
            pulumi.set(__self__, "external_access", external_access)
        if external_database is not None:
            pulumi.set(__self__, "external_database", external_database)
        if instances is not None:
            pulumi.set(__self__, "instances", instances)
        if keycloak_deployment_spec is not None:
            pulumi.set(__self__, "keycloak_deployment_spec", keycloak_deployment_spec)
        if migration is not None:
            pulumi.set(__self__, "migration", migration)
        if pod_disruption_budget is not None:
            pulumi.set(__self__, "pod_disruption_budget", pod_disruption_budget)
        if postgres_deployment_spec is not None:
            pulumi.set(__self__, "postgres_deployment_spec", postgres_deployment_spec)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)
        if storage_class_name is not None:
            pulumi.set(__self__, "storage_class_name", storage_class_name)

    @property
    @pulumi.getter
    def extensions(self) -> Optional[Sequence[str]]:
        """
        A list of extensions, where each one is a URL to a JAR files that will be deployed in Keycloak.
        """
        return pulumi.get(self, "extensions")

    @property
    @pulumi.getter(name="externalAccess")
    def external_access(self) -> Optional['outputs.KeycloakSpecExternalAccess']:
        """
        Controls external Ingress/Route settings.
        """
        return pulumi.get(self, "external_access")

    @property
    @pulumi.getter(name="externalDatabase")
    def external_database(self) -> Optional['outputs.KeycloakSpecExternalDatabase']:
        """
        Controls external database settings. Using an external database requires providing a secret containing credentials as well as connection details. Here's an example of such secret: 
             apiVersion: v1     kind: Secret     metadata:         name: keycloak-db-secret         namespace: keycloak     stringData:         POSTGRES_DATABASE: <Database Name>         POSTGRES_EXTERNAL_ADDRESS: <External Database IP or URL (resolvable by K8s)>         POSTGRES_EXTERNAL_PORT: <External Database Port>         # Strongly recommended to use <'Keycloak CR Name'-postgresql>         POSTGRES_HOST: <Database Service Name>         POSTGRES_PASSWORD: <Database Password>         # Required for AWS Backup functionality         POSTGRES_SUPERUSER: true         POSTGRES_USERNAME: <Database Username>      type: Opaque 
         Both POSTGRES_EXTERNAL_ADDRESS and POSTGRES_EXTERNAL_PORT are specifically required for creating connection to the external database. The secret name is created using the following convention:       <Custom Resource Name>-db-secret 
         For more information, please refer to the Operator documentation.
        """
        return pulumi.get(self, "external_database")

    @property
    @pulumi.getter
    def instances(self) -> Optional[int]:
        """
        Number of Keycloak instances in HA mode. Default is 1.
        """
        return pulumi.get(self, "instances")

    @property
    @pulumi.getter(name="keycloakDeploymentSpec")
    def keycloak_deployment_spec(self) -> Optional['outputs.KeycloakSpecKeycloakDeploymentSpec']:
        """
        Resources (Requests and Limits) for KeycloakDeployment.
        """
        return pulumi.get(self, "keycloak_deployment_spec")

    @property
    @pulumi.getter
    def migration(self) -> Optional['outputs.KeycloakSpecMigration']:
        """
        Specify Migration configuration
        """
        return pulumi.get(self, "migration")

    @property
    @pulumi.getter(name="podDisruptionBudget")
    def pod_disruption_budget(self) -> Optional['outputs.KeycloakSpecPodDisruptionBudget']:
        """
        Specify PodDisruptionBudget configuration.
        """
        return pulumi.get(self, "pod_disruption_budget")

    @property
    @pulumi.getter(name="postgresDeploymentSpec")
    def postgres_deployment_spec(self) -> Optional['outputs.KeycloakSpecPostgresDeploymentSpec']:
        """
        Resources (Requests and Limits) for PostgresDeployment.
        """
        return pulumi.get(self, "postgres_deployment_spec")

    @property
    @pulumi.getter
    def profile(self) -> Optional[str]:
        """
        Profile used for controlling Operator behavior. Default is empty.
        """
        return pulumi.get(self, "profile")

    @property
    @pulumi.getter(name="storageClassName")
    def storage_class_name(self) -> Optional[str]:
        """
        Name of the StorageClass for Postgresql Persistent Volume Claim
        """
        return pulumi.get(self, "storage_class_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KeycloakSpecExternalAccess(dict):
    """
    Controls external Ingress/Route settings.
    """
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 tls_termination: Optional[str] = None):
        """
        Controls external Ingress/Route settings.
        :param bool enabled: If set to true, the Operator will create an Ingress or a Route pointing to Keycloak.
        :param str tls_termination: TLS Termination type for the external access. Setting this field to "reencrypt" will terminate TLS on the Ingress/Route level. Setting this field to "passthrough" will send encrypted traffic to the Pod. If unspecified, defaults to "reencrypt". Note, that this setting has no effect on Ingress as Ingress TLS settings are not reconciled by this operator. In other words, Ingress TLS configuration is the same in both cases and it is up to the user to configure TLS section of the Ingress.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if tls_termination is not None:
            pulumi.set(__self__, "tls_termination", tls_termination)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set to true, the Operator will create an Ingress or a Route pointing to Keycloak.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="tlsTermination")
    def tls_termination(self) -> Optional[str]:
        """
        TLS Termination type for the external access. Setting this field to "reencrypt" will terminate TLS on the Ingress/Route level. Setting this field to "passthrough" will send encrypted traffic to the Pod. If unspecified, defaults to "reencrypt". Note, that this setting has no effect on Ingress as Ingress TLS settings are not reconciled by this operator. In other words, Ingress TLS configuration is the same in both cases and it is up to the user to configure TLS section of the Ingress.
        """
        return pulumi.get(self, "tls_termination")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KeycloakSpecExternalDatabase(dict):
    """
    Controls external database settings. Using an external database requires providing a secret containing credentials as well as connection details. Here's an example of such secret: 
         apiVersion: v1     kind: Secret     metadata:         name: keycloak-db-secret         namespace: keycloak     stringData:         POSTGRES_DATABASE: <Database Name>         POSTGRES_EXTERNAL_ADDRESS: <External Database IP or URL (resolvable by K8s)>         POSTGRES_EXTERNAL_PORT: <External Database Port>         # Strongly recommended to use <'Keycloak CR Name'-postgresql>         POSTGRES_HOST: <Database Service Name>         POSTGRES_PASSWORD: <Database Password>         # Required for AWS Backup functionality         POSTGRES_SUPERUSER: true         POSTGRES_USERNAME: <Database Username>      type: Opaque 
     Both POSTGRES_EXTERNAL_ADDRESS and POSTGRES_EXTERNAL_PORT are specifically required for creating connection to the external database. The secret name is created using the following convention:       <Custom Resource Name>-db-secret 
     For more information, please refer to the Operator documentation.
    """
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        Controls external database settings. Using an external database requires providing a secret containing credentials as well as connection details. Here's an example of such secret: 
             apiVersion: v1     kind: Secret     metadata:         name: keycloak-db-secret         namespace: keycloak     stringData:         POSTGRES_DATABASE: <Database Name>         POSTGRES_EXTERNAL_ADDRESS: <External Database IP or URL (resolvable by K8s)>         POSTGRES_EXTERNAL_PORT: <External Database Port>         # Strongly recommended to use <'Keycloak CR Name'-postgresql>         POSTGRES_HOST: <Database Service Name>         POSTGRES_PASSWORD: <Database Password>         # Required for AWS Backup functionality         POSTGRES_SUPERUSER: true         POSTGRES_USERNAME: <Database Username>      type: Opaque 
         Both POSTGRES_EXTERNAL_ADDRESS and POSTGRES_EXTERNAL_PORT are specifically required for creating connection to the external database. The secret name is created using the following convention:       <Custom Resource Name>-db-secret 
         For more information, please refer to the Operator documentation.
        :param bool enabled: If set to true, the Operator will use an external database. pointing to Keycloak.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set to true, the Operator will use an external database. pointing to Keycloak.
        """
        return pulumi.get(self, "enabled")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KeycloakSpecKeycloakDeploymentSpec(dict):
    """
    Resources (Requests and Limits) for KeycloakDeployment.
    """
    def __init__(__self__, *,
                 resources: Optional['outputs.KeycloakSpecKeycloakDeploymentSpecResources'] = None):
        """
        Resources (Requests and Limits) for KeycloakDeployment.
        :param 'KeycloakSpecKeycloakDeploymentSpecResourcesArgs' resources: Resources (Requests and Limits) for the Pods.
        """
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.KeycloakSpecKeycloakDeploymentSpecResources']:
        """
        Resources (Requests and Limits) for the Pods.
        """
        return pulumi.get(self, "resources")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KeycloakSpecKeycloakDeploymentSpecResources(dict):
    """
    Resources (Requests and Limits) for the Pods.
    """
    def __init__(__self__, *,
                 limits: Optional[Mapping[str, str]] = None,
                 requests: Optional[Mapping[str, str]] = None):
        """
        Resources (Requests and Limits) for the Pods.
        :param Mapping[str, str] limits: Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        :param Mapping[str, str] requests: Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, str]]:
        """
        Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Mapping[str, str]]:
        """
        Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "requests")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KeycloakSpecMigration(dict):
    """
    Specify Migration configuration
    """
    def __init__(__self__, *,
                 backups: Optional['outputs.KeycloakSpecMigrationBackups'] = None):
        """
        Specify Migration configuration
        :param 'KeycloakSpecMigrationBackupsArgs' backups: Set it to config backup policy for migration
        """
        if backups is not None:
            pulumi.set(__self__, "backups", backups)

    @property
    @pulumi.getter
    def backups(self) -> Optional['outputs.KeycloakSpecMigrationBackups']:
        """
        Set it to config backup policy for migration
        """
        return pulumi.get(self, "backups")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KeycloakSpecMigrationBackups(dict):
    """
    Set it to config backup policy for migration
    """
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        Set it to config backup policy for migration
        :param bool enabled: If set to true, the operator will do database backup before doing migration
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set to true, the operator will do database backup before doing migration
        """
        return pulumi.get(self, "enabled")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KeycloakSpecPodDisruptionBudget(dict):
    """
    Specify PodDisruptionBudget configuration.
    """
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        Specify PodDisruptionBudget configuration.
        :param bool enabled: If set to true, the operator will create a PodDistruptionBudget for the Keycloak deployment and set its `maxUnavailable` value to 1.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If set to true, the operator will create a PodDistruptionBudget for the Keycloak deployment and set its `maxUnavailable` value to 1.
        """
        return pulumi.get(self, "enabled")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KeycloakSpecPostgresDeploymentSpec(dict):
    """
    Resources (Requests and Limits) for PostgresDeployment.
    """
    def __init__(__self__, *,
                 resources: Optional['outputs.KeycloakSpecPostgresDeploymentSpecResources'] = None):
        """
        Resources (Requests and Limits) for PostgresDeployment.
        :param 'KeycloakSpecPostgresDeploymentSpecResourcesArgs' resources: Resources (Requests and Limits) for the Pods.
        """
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.KeycloakSpecPostgresDeploymentSpecResources']:
        """
        Resources (Requests and Limits) for the Pods.
        """
        return pulumi.get(self, "resources")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KeycloakSpecPostgresDeploymentSpecResources(dict):
    """
    Resources (Requests and Limits) for the Pods.
    """
    def __init__(__self__, *,
                 limits: Optional[Mapping[str, str]] = None,
                 requests: Optional[Mapping[str, str]] = None):
        """
        Resources (Requests and Limits) for the Pods.
        :param Mapping[str, str] limits: Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        :param Mapping[str, str] requests: Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, str]]:
        """
        Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Mapping[str, str]]:
        """
        Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
        """
        return pulumi.get(self, "requests")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KeycloakStatus(dict):
    """
    KeycloakStatus defines the observed state of Keycloak.
    """
    def __init__(__self__, *,
                 credential_secret: str,
                 internal_url: str,
                 message: str,
                 phase: str,
                 ready: bool,
                 version: str,
                 secondary_resources: Optional[Mapping[str, Sequence[str]]] = None):
        """
        KeycloakStatus defines the observed state of Keycloak.
        :param str credential_secret: The secret where the admin credentials are to be found.
        :param str internal_url: Service IP and Port for in-cluster access to the keycloak instance.
        :param str message: Human-readable message indicating details about current operator phase or error.
        :param str phase: Current phase of the operator.
        :param bool ready: True if all resources are in a ready state and all work is done.
        :param str version: Version of Keycloak or RHSSO running on the cluster.
        :param Mapping[str, Sequence[str]] secondary_resources: A map of all the secondary resources types and names created for this CR. e.g "Deployment": [ "DeploymentName1", "DeploymentName2" ].
        """
        pulumi.set(__self__, "credential_secret", credential_secret)
        pulumi.set(__self__, "internal_url", internal_url)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "phase", phase)
        pulumi.set(__self__, "ready", ready)
        pulumi.set(__self__, "version", version)
        if secondary_resources is not None:
            pulumi.set(__self__, "secondary_resources", secondary_resources)

    @property
    @pulumi.getter(name="credentialSecret")
    def credential_secret(self) -> str:
        """
        The secret where the admin credentials are to be found.
        """
        return pulumi.get(self, "credential_secret")

    @property
    @pulumi.getter(name="internalURL")
    def internal_url(self) -> str:
        """
        Service IP and Port for in-cluster access to the keycloak instance.
        """
        return pulumi.get(self, "internal_url")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        Human-readable message indicating details about current operator phase or error.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def phase(self) -> str:
        """
        Current phase of the operator.
        """
        return pulumi.get(self, "phase")

    @property
    @pulumi.getter
    def ready(self) -> bool:
        """
        True if all resources are in a ready state and all work is done.
        """
        return pulumi.get(self, "ready")

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        Version of Keycloak or RHSSO running on the cluster.
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter(name="secondaryResources")
    def secondary_resources(self) -> Optional[Mapping[str, Sequence[str]]]:
        """
        A map of all the secondary resources types and names created for this CR. e.g "Deployment": [ "DeploymentName1", "DeploymentName2" ].
        """
        return pulumi.get(self, "secondary_resources")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KeycloakUserSpec(dict):
    """
    KeycloakUserSpec defines the desired state of KeycloakUser.
    """
    def __init__(__self__, *,
                 user: 'outputs.KeycloakUserSpecUser',
                 realm_selector: Optional['outputs.KeycloakUserSpecRealmSelector'] = None):
        """
        KeycloakUserSpec defines the desired state of KeycloakUser.
        :param 'KeycloakUserSpecUserArgs' user: Keycloak User REST object.
        :param 'KeycloakUserSpecRealmSelectorArgs' realm_selector: Selector for looking up KeycloakRealm Custom Resources.
        """
        pulumi.set(__self__, "user", user)
        if realm_selector is not None:
            pulumi.set(__self__, "realm_selector", realm_selector)

    @property
    @pulumi.getter
    def user(self) -> 'outputs.KeycloakUserSpecUser':
        """
        Keycloak User REST object.
        """
        return pulumi.get(self, "user")

    @property
    @pulumi.getter(name="realmSelector")
    def realm_selector(self) -> Optional['outputs.KeycloakUserSpecRealmSelector']:
        """
        Selector for looking up KeycloakRealm Custom Resources.
        """
        return pulumi.get(self, "realm_selector")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KeycloakUserSpecRealmSelector(dict):
    """
    Selector for looking up KeycloakRealm Custom Resources.
    """
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KeycloakUserSpecRealmSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        Selector for looking up KeycloakRealm Custom Resources.
        :param Sequence['KeycloakUserSpecRealmSelectorMatchExpressionsArgs'] match_expressions: matchExpressions is a list of label selector requirements. The requirements are ANDed.
        :param Mapping[str, str] match_labels: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KeycloakUserSpecRealmSelectorMatchExpressions']]:
        """
        matchExpressions is a list of label selector requirements. The requirements are ANDed.
        """
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        """
        matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        """
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KeycloakUserSpecRealmSelectorMatchExpressions(dict):
    """
    A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
    """
    def __init__(__self__, *,
                 key: str,
                 operator: str,
                 values: Optional[Sequence[str]] = None):
        """
        A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
        :param str key: key is the label key that the selector applies to.
        :param str operator: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param Sequence[str] values: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        key is the label key that the selector applies to.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        """
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KeycloakUserSpecUser(dict):
    """
    Keycloak User REST object.
    """
    def __init__(__self__, *,
                 attributes: Optional[Mapping[str, Sequence[str]]] = None,
                 client_roles: Optional[Mapping[str, Sequence[str]]] = None,
                 credentials: Optional[Sequence['outputs.KeycloakUserSpecUserCredentials']] = None,
                 email: Optional[str] = None,
                 email_verified: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 federated_identities: Optional[Sequence['outputs.KeycloakUserSpecUserFederatedIdentities']] = None,
                 first_name: Optional[str] = None,
                 groups: Optional[Sequence[str]] = None,
                 id: Optional[str] = None,
                 last_name: Optional[str] = None,
                 realm_roles: Optional[Sequence[str]] = None,
                 required_actions: Optional[Sequence[str]] = None,
                 username: Optional[str] = None):
        """
        Keycloak User REST object.
        :param Mapping[str, Sequence[str]] attributes: A set of Attributes.
        :param Mapping[str, Sequence[str]] client_roles: A set of Client Roles.
        :param Sequence['KeycloakUserSpecUserCredentialsArgs'] credentials: A set of Credentials.
        :param str email: Email.
        :param bool email_verified: True if email has already been verified.
        :param bool enabled: User enabled flag.
        :param Sequence['KeycloakUserSpecUserFederatedIdentitiesArgs'] federated_identities: A set of Federated Identities.
        :param str first_name: First Name.
        :param Sequence[str] groups: A set of Groups.
        :param str id: User ID.
        :param str last_name: Last Name.
        :param Sequence[str] realm_roles: A set of Realm Roles.
        :param Sequence[str] required_actions: A set of Required Actions.
        :param str username: User Name.
        """
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if client_roles is not None:
            pulumi.set(__self__, "client_roles", client_roles)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if email_verified is not None:
            pulumi.set(__self__, "email_verified", email_verified)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if federated_identities is not None:
            pulumi.set(__self__, "federated_identities", federated_identities)
        if first_name is not None:
            pulumi.set(__self__, "first_name", first_name)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if last_name is not None:
            pulumi.set(__self__, "last_name", last_name)
        if realm_roles is not None:
            pulumi.set(__self__, "realm_roles", realm_roles)
        if required_actions is not None:
            pulumi.set(__self__, "required_actions", required_actions)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def attributes(self) -> Optional[Mapping[str, Sequence[str]]]:
        """
        A set of Attributes.
        """
        return pulumi.get(self, "attributes")

    @property
    @pulumi.getter(name="clientRoles")
    def client_roles(self) -> Optional[Mapping[str, Sequence[str]]]:
        """
        A set of Client Roles.
        """
        return pulumi.get(self, "client_roles")

    @property
    @pulumi.getter
    def credentials(self) -> Optional[Sequence['outputs.KeycloakUserSpecUserCredentials']]:
        """
        A set of Credentials.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        """
        Email.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="emailVerified")
    def email_verified(self) -> Optional[bool]:
        """
        True if email has already been verified.
        """
        return pulumi.get(self, "email_verified")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        User enabled flag.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="federatedIdentities")
    def federated_identities(self) -> Optional[Sequence['outputs.KeycloakUserSpecUserFederatedIdentities']]:
        """
        A set of Federated Identities.
        """
        return pulumi.get(self, "federated_identities")

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> Optional[str]:
        """
        First Name.
        """
        return pulumi.get(self, "first_name")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[str]]:
        """
        A set of Groups.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        User ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> Optional[str]:
        """
        Last Name.
        """
        return pulumi.get(self, "last_name")

    @property
    @pulumi.getter(name="realmRoles")
    def realm_roles(self) -> Optional[Sequence[str]]:
        """
        A set of Realm Roles.
        """
        return pulumi.get(self, "realm_roles")

    @property
    @pulumi.getter(name="requiredActions")
    def required_actions(self) -> Optional[Sequence[str]]:
        """
        A set of Required Actions.
        """
        return pulumi.get(self, "required_actions")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        User Name.
        """
        return pulumi.get(self, "username")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KeycloakUserSpecUserCredentials(dict):
    def __init__(__self__, *,
                 temporary: Optional[bool] = None,
                 type: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param bool temporary: True if this credential object is temporary.
        :param str type: Credential Type.
        :param str value: Credential Value.
        """
        if temporary is not None:
            pulumi.set(__self__, "temporary", temporary)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def temporary(self) -> Optional[bool]:
        """
        True if this credential object is temporary.
        """
        return pulumi.get(self, "temporary")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Credential Type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Credential Value.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KeycloakUserSpecUserFederatedIdentities(dict):
    def __init__(__self__, *,
                 identity_provider: Optional[str] = None,
                 user_id: Optional[str] = None,
                 user_name: Optional[str] = None):
        """
        :param str identity_provider: Federated Identity Provider.
        :param str user_id: Federated Identity User ID.
        :param str user_name: Federated Identity User Name.
        """
        if identity_provider is not None:
            pulumi.set(__self__, "identity_provider", identity_provider)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="identityProvider")
    def identity_provider(self) -> Optional[str]:
        """
        Federated Identity Provider.
        """
        return pulumi.get(self, "identity_provider")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[str]:
        """
        Federated Identity User ID.
        """
        return pulumi.get(self, "user_id")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[str]:
        """
        Federated Identity User Name.
        """
        return pulumi.get(self, "user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KeycloakUserStatus(dict):
    """
    KeycloakUserStatus defines the observed state of KeycloakUser.
    """
    def __init__(__self__, *,
                 message: str,
                 phase: str):
        """
        KeycloakUserStatus defines the observed state of KeycloakUser.
        :param str message: Human-readable message indicating details about current operator phase or error.
        :param str phase: Current phase of the operator.
        """
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "phase", phase)

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        Human-readable message indicating details about current operator phase or error.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def phase(self) -> str:
        """
        Current phase of the operator.
        """
        return pulumi.get(self, "phase")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


