// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Kubernetes.Types.Inputs.Monitoring.V1
{

    /// <summary>
    /// Specification of the desired behavior of the Prometheus cluster. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
    /// </summary>
    public class PrometheusSpecArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// AdditionalAlertManagerConfigs allows specifying a key of a Secret containing additional Prometheus AlertManager configurations. AlertManager configurations specified are appended to the configurations generated by the Prometheus Operator. Job configurations specified must have the form as specified in the official Prometheus documentation: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#alertmanager_config. As AlertManager configs are appended, the user is responsible to make sure it is valid. Note that using this feature may expose the possibility to break upgrades of Prometheus. It is advised to review Prometheus release notes to ensure that no incompatible AlertManager configs are going to break Prometheus after the upgrade.
        /// </summary>
        [Input("additionalAlertManagerConfigs")]
        public Input<Pulumi.Kubernetes.Types.Inputs.Monitoring.V1.PrometheusSpecAdditionalAlertManagerConfigsArgs>? AdditionalAlertManagerConfigs { get; set; }

        /// <summary>
        /// AdditionalAlertRelabelConfigs allows specifying a key of a Secret containing additional Prometheus alert relabel configurations. Alert relabel configurations specified are appended to the configurations generated by the Prometheus Operator. Alert relabel configurations specified must have the form as specified in the official Prometheus documentation: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#alert_relabel_configs. As alert relabel configs are appended, the user is responsible to make sure it is valid. Note that using this feature may expose the possibility to break upgrades of Prometheus. It is advised to review Prometheus release notes to ensure that no incompatible alert relabel configs are going to break Prometheus after the upgrade.
        /// </summary>
        [Input("additionalAlertRelabelConfigs")]
        public Input<Pulumi.Kubernetes.Types.Inputs.Monitoring.V1.PrometheusSpecAdditionalAlertRelabelConfigsArgs>? AdditionalAlertRelabelConfigs { get; set; }

        /// <summary>
        /// AdditionalScrapeConfigs allows specifying a key of a Secret containing additional Prometheus scrape configurations. Scrape configurations specified are appended to the configurations generated by the Prometheus Operator. Job configurations specified must have the form as specified in the official Prometheus documentation: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config. As scrape configs are appended, the user is responsible to make sure it is valid. Note that using this feature may expose the possibility to break upgrades of Prometheus. It is advised to review Prometheus release notes to ensure that no incompatible scrape configs are going to break Prometheus after the upgrade.
        /// </summary>
        [Input("additionalScrapeConfigs")]
        public Input<Pulumi.Kubernetes.Types.Inputs.Monitoring.V1.PrometheusSpecAdditionalScrapeConfigsArgs>? AdditionalScrapeConfigs { get; set; }

        /// <summary>
        /// If specified, the pod's scheduling constraints.
        /// </summary>
        [Input("affinity")]
        public Input<Pulumi.Kubernetes.Types.Inputs.Monitoring.V1.PrometheusSpecAffinityArgs>? Affinity { get; set; }

        /// <summary>
        /// Define details regarding alerting.
        /// </summary>
        [Input("alerting")]
        public Input<Pulumi.Kubernetes.Types.Inputs.Monitoring.V1.PrometheusSpecAlertingArgs>? Alerting { get; set; }

        /// <summary>
        /// APIServerConfig allows specifying a host and auth methods to access apiserver. If left empty, Prometheus is assumed to run inside of the cluster and will discover API servers automatically and use the pod's CA certificate and bearer token file at /var/run/secrets/kubernetes.io/serviceaccount/.
        /// </summary>
        [Input("apiserverConfig")]
        public Input<Pulumi.Kubernetes.Types.Inputs.Monitoring.V1.PrometheusSpecApiserverConfigArgs>? ApiserverConfig { get; set; }

        /// <summary>
        /// ArbitraryFSAccessThroughSMs configures whether configuration based on a service monitor can access arbitrary files on the file system of the Prometheus container e.g. bearer token files.
        /// </summary>
        [Input("arbitraryFSAccessThroughSMs")]
        public Input<Pulumi.Kubernetes.Types.Inputs.Monitoring.V1.PrometheusSpecArbitraryFSAccessThroughSMsArgs>? ArbitraryFSAccessThroughSMs { get; set; }

        /// <summary>
        /// Base image to use for a Prometheus deployment.
        /// </summary>
        [Input("baseImage")]
        public Input<string>? BaseImage { get; set; }

        [Input("configMaps")]
        private InputList<string>? _configMaps;

        /// <summary>
        /// ConfigMaps is a list of ConfigMaps in the same namespace as the Prometheus object, which shall be mounted into the Prometheus Pods. The ConfigMaps are mounted into /etc/prometheus/configmaps/&lt;configmap-name&gt;.
        /// </summary>
        public InputList<string> ConfigMaps
        {
            get => _configMaps ?? (_configMaps = new InputList<string>());
            set => _configMaps = value;
        }

        [Input("containers")]
        private InputList<Pulumi.Kubernetes.Types.Inputs.Monitoring.V1.PrometheusSpecContainersArgs>? _containers;

        /// <summary>
        /// Containers allows injecting additional containers or modifying operator generated containers. This can be used to allow adding an authentication proxy to a Prometheus pod or to change the behavior of an operator generated container. Containers described here modify an operator generated container if they share the same name and modifications are done via a strategic merge patch. The current container names are: `prometheus`, `prometheus-config-reloader`, `rules-configmap-reloader`, and `thanos-sidecar`. Overriding containers is entirely outside the scope of what the maintainers will support and by doing so, you accept that this behaviour may break at any time without notice.
        /// </summary>
        public InputList<Pulumi.Kubernetes.Types.Inputs.Monitoring.V1.PrometheusSpecContainersArgs> Containers
        {
            get => _containers ?? (_containers = new InputList<Pulumi.Kubernetes.Types.Inputs.Monitoring.V1.PrometheusSpecContainersArgs>());
            set => _containers = value;
        }

        /// <summary>
        /// Disable prometheus compaction.
        /// </summary>
        [Input("disableCompaction")]
        public Input<bool>? DisableCompaction { get; set; }

        /// <summary>
        /// Enable access to prometheus web admin API. Defaults to the value of `false`. WARNING: Enabling the admin APIs enables mutating endpoints, to delete data, shutdown Prometheus, and more. Enabling this should be done with care and the user is advised to add additional authentication authorization via a proxy to ensure only clients authorized to perform these actions can do so. For more information see https://prometheus.io/docs/prometheus/latest/querying/api/#tsdb-admin-apis
        /// </summary>
        [Input("enableAdminAPI")]
        public Input<bool>? EnableAdminAPI { get; set; }

        /// <summary>
        /// EnforcedNamespaceLabel enforces adding a namespace label of origin for each alert and metric that is user created. The label value will always be the namespace of the object that is being created.
        /// </summary>
        [Input("enforcedNamespaceLabel")]
        public Input<string>? EnforcedNamespaceLabel { get; set; }

        /// <summary>
        /// Interval between consecutive evaluations.
        /// </summary>
        [Input("evaluationInterval")]
        public Input<string>? EvaluationInterval { get; set; }

        [Input("externalLabels")]
        private InputMap<string>? _externalLabels;

        /// <summary>
        /// The labels to add to any time series or alerts when communicating with external systems (federation, remote storage, Alertmanager).
        /// </summary>
        public InputMap<string> ExternalLabels
        {
            get => _externalLabels ?? (_externalLabels = new InputMap<string>());
            set => _externalLabels = value;
        }

        /// <summary>
        /// The external URL the Prometheus instances will be available under. This is necessary to generate correct URLs. This is necessary if Prometheus is not served from root of a DNS name.
        /// </summary>
        [Input("externalUrl")]
        public Input<string>? ExternalUrl { get; set; }

        /// <summary>
        /// IgnoreNamespaceSelectors if set to true will ignore NamespaceSelector settings from the podmonitor and servicemonitor configs, and they will only discover endpoints within their current namespace.  Defaults to false.
        /// </summary>
        [Input("ignoreNamespaceSelectors")]
        public Input<bool>? IgnoreNamespaceSelectors { get; set; }

        /// <summary>
        /// Image if specified has precedence over baseImage, tag and sha combinations. Specifying the version is still necessary to ensure the Prometheus Operator knows what version of Prometheus is being configured.
        /// </summary>
        [Input("image")]
        public Input<string>? Image { get; set; }

        [Input("imagePullSecrets")]
        private InputList<Pulumi.Kubernetes.Types.Inputs.Monitoring.V1.PrometheusSpecImagePullSecretsArgs>? _imagePullSecrets;

        /// <summary>
        /// An optional list of references to secrets in the same namespace to use for pulling prometheus and alertmanager images from registries see http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod
        /// </summary>
        public InputList<Pulumi.Kubernetes.Types.Inputs.Monitoring.V1.PrometheusSpecImagePullSecretsArgs> ImagePullSecrets
        {
            get => _imagePullSecrets ?? (_imagePullSecrets = new InputList<Pulumi.Kubernetes.Types.Inputs.Monitoring.V1.PrometheusSpecImagePullSecretsArgs>());
            set => _imagePullSecrets = value;
        }

        [Input("initContainers")]
        private InputList<Pulumi.Kubernetes.Types.Inputs.Monitoring.V1.PrometheusSpecInitContainersArgs>? _initContainers;

        /// <summary>
        /// InitContainers allows adding initContainers to the pod definition. Those can be used to e.g. fetch secrets for injection into the Prometheus configuration from external sources. Any errors during the execution of an initContainer will lead to a restart of the Pod. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/ Using initContainers for any use case other then secret fetching is entirely outside the scope of what the maintainers will support and by doing so, you accept that this behaviour may break at any time without notice.
        /// </summary>
        public InputList<Pulumi.Kubernetes.Types.Inputs.Monitoring.V1.PrometheusSpecInitContainersArgs> InitContainers
        {
            get => _initContainers ?? (_initContainers = new InputList<Pulumi.Kubernetes.Types.Inputs.Monitoring.V1.PrometheusSpecInitContainersArgs>());
            set => _initContainers = value;
        }

        /// <summary>
        /// ListenLocal makes the Prometheus server listen on loopback, so that it does not bind against the Pod IP.
        /// </summary>
        [Input("listenLocal")]
        public Input<bool>? ListenLocal { get; set; }

        /// <summary>
        /// Log format for Prometheus to be configured with.
        /// </summary>
        [Input("logFormat")]
        public Input<string>? LogFormat { get; set; }

        /// <summary>
        /// Log level for Prometheus to be configured with.
        /// </summary>
        [Input("logLevel")]
        public Input<string>? LogLevel { get; set; }

        [Input("nodeSelector")]
        private InputMap<string>? _nodeSelector;

        /// <summary>
        /// Define which Nodes the Pods are scheduled on.
        /// </summary>
        public InputMap<string> NodeSelector
        {
            get => _nodeSelector ?? (_nodeSelector = new InputMap<string>());
            set => _nodeSelector = value;
        }

        /// <summary>
        /// OverrideHonorLabels if set to true overrides all user configured honor_labels. If HonorLabels is set in ServiceMonitor or PodMonitor to true, this overrides honor_labels to false.
        /// </summary>
        [Input("overrideHonorLabels")]
        public Input<bool>? OverrideHonorLabels { get; set; }

        /// <summary>
        /// OverrideHonorTimestamps allows to globally enforce honoring timestamps in all scrape configs.
        /// </summary>
        [Input("overrideHonorTimestamps")]
        public Input<bool>? OverrideHonorTimestamps { get; set; }

        /// <summary>
        /// When a Prometheus deployment is paused, no actions except for deletion will be performed on the underlying objects.
        /// </summary>
        [Input("paused")]
        public Input<bool>? Paused { get; set; }

        /// <summary>
        /// PodMetadata configures Labels and Annotations which are propagated to the prometheus pods.
        /// </summary>
        [Input("podMetadata")]
        public Input<Pulumi.Kubernetes.Types.Inputs.Monitoring.V1.PrometheusSpecPodMetadataArgs>? PodMetadata { get; set; }

        /// <summary>
        /// Namespaces to be selected for PodMonitor discovery. If nil, only check own namespace.
        /// </summary>
        [Input("podMonitorNamespaceSelector")]
        public Input<Pulumi.Kubernetes.Types.Inputs.Monitoring.V1.PrometheusSpecPodMonitorNamespaceSelectorArgs>? PodMonitorNamespaceSelector { get; set; }

        /// <summary>
        /// *Experimental* PodMonitors to be selected for target discovery.
        /// </summary>
        [Input("podMonitorSelector")]
        public Input<Pulumi.Kubernetes.Types.Inputs.Monitoring.V1.PrometheusSpecPodMonitorSelectorArgs>? PodMonitorSelector { get; set; }

        /// <summary>
        /// Port name used for the pods and governing service. This defaults to web
        /// </summary>
        [Input("portName")]
        public Input<string>? PortName { get; set; }

        /// <summary>
        /// Priority class assigned to the Pods
        /// </summary>
        [Input("priorityClassName")]
        public Input<string>? PriorityClassName { get; set; }

        /// <summary>
        /// Name of Prometheus external label used to denote Prometheus instance name. Defaults to the value of `prometheus`. External label will _not_ be added when value is set to empty string (`""`).
        /// </summary>
        [Input("prometheusExternalLabelName")]
        public Input<string>? PrometheusExternalLabelName { get; set; }

        /// <summary>
        /// QuerySpec defines the query command line flags when starting Prometheus.
        /// </summary>
        [Input("query")]
        public Input<Pulumi.Kubernetes.Types.Inputs.Monitoring.V1.PrometheusSpecQueryArgs>? Query { get; set; }

        [Input("remoteRead")]
        private InputList<Pulumi.Kubernetes.Types.Inputs.Monitoring.V1.PrometheusSpecRemoteReadArgs>? _remoteRead;

        /// <summary>
        /// If specified, the remote_read spec. This is an experimental feature, it may change in any upcoming release in a breaking way.
        /// </summary>
        public InputList<Pulumi.Kubernetes.Types.Inputs.Monitoring.V1.PrometheusSpecRemoteReadArgs> RemoteRead
        {
            get => _remoteRead ?? (_remoteRead = new InputList<Pulumi.Kubernetes.Types.Inputs.Monitoring.V1.PrometheusSpecRemoteReadArgs>());
            set => _remoteRead = value;
        }

        [Input("remoteWrite")]
        private InputList<Pulumi.Kubernetes.Types.Inputs.Monitoring.V1.PrometheusSpecRemoteWriteArgs>? _remoteWrite;

        /// <summary>
        /// If specified, the remote_write spec. This is an experimental feature, it may change in any upcoming release in a breaking way.
        /// </summary>
        public InputList<Pulumi.Kubernetes.Types.Inputs.Monitoring.V1.PrometheusSpecRemoteWriteArgs> RemoteWrite
        {
            get => _remoteWrite ?? (_remoteWrite = new InputList<Pulumi.Kubernetes.Types.Inputs.Monitoring.V1.PrometheusSpecRemoteWriteArgs>());
            set => _remoteWrite = value;
        }

        /// <summary>
        /// Name of Prometheus external label used to denote replica name. Defaults to the value of `prometheus_replica`. External label will _not_ be added when value is set to empty string (`""`).
        /// </summary>
        [Input("replicaExternalLabelName")]
        public Input<string>? ReplicaExternalLabelName { get; set; }

        /// <summary>
        /// Number of instances to deploy for a Prometheus deployment.
        /// </summary>
        [Input("replicas")]
        public Input<int>? Replicas { get; set; }

        /// <summary>
        /// Define resources requests and limits for single Pods.
        /// </summary>
        [Input("resources")]
        public Input<Pulumi.Kubernetes.Types.Inputs.Monitoring.V1.PrometheusSpecResourcesArgs>? Resources { get; set; }

        /// <summary>
        /// Time duration Prometheus shall retain data for. Default is '24h', and must match the regular expression `[0-9]+(ms|s|m|h|d|w|y)` (milliseconds seconds minutes hours days weeks years).
        /// </summary>
        [Input("retention")]
        public Input<string>? Retention { get; set; }

        /// <summary>
        /// Maximum amount of disk space used by blocks.
        /// </summary>
        [Input("retentionSize")]
        public Input<string>? RetentionSize { get; set; }

        /// <summary>
        /// The route prefix Prometheus registers HTTP handlers for. This is useful, if using ExternalURL and a proxy is rewriting HTTP routes of a request, and the actual ExternalURL is still true, but the server serves requests under a different route prefix. For example for use with `kubectl proxy`.
        /// </summary>
        [Input("routePrefix")]
        public Input<string>? RoutePrefix { get; set; }

        /// <summary>
        /// Namespaces to be selected for PrometheusRules discovery. If unspecified, only the same namespace as the Prometheus object is in is used.
        /// </summary>
        [Input("ruleNamespaceSelector")]
        public Input<Pulumi.Kubernetes.Types.Inputs.Monitoring.V1.PrometheusSpecRuleNamespaceSelectorArgs>? RuleNamespaceSelector { get; set; }

        /// <summary>
        /// A selector to select which PrometheusRules to mount for loading alerting rules from. Until (excluding) Prometheus Operator v0.24.0 Prometheus Operator will migrate any legacy rule ConfigMaps to PrometheusRule custom resources selected by RuleSelector. Make sure it does not match any config maps that you do not want to be migrated.
        /// </summary>
        [Input("ruleSelector")]
        public Input<Pulumi.Kubernetes.Types.Inputs.Monitoring.V1.PrometheusSpecRuleSelectorArgs>? RuleSelector { get; set; }

        /// <summary>
        /// /--rules.*/ command-line arguments.
        /// </summary>
        [Input("rules")]
        public Input<Pulumi.Kubernetes.Types.Inputs.Monitoring.V1.PrometheusSpecRulesArgs>? Rules { get; set; }

        /// <summary>
        /// Interval between consecutive scrapes.
        /// </summary>
        [Input("scrapeInterval")]
        public Input<string>? ScrapeInterval { get; set; }

        [Input("secrets")]
        private InputList<string>? _secrets;

        /// <summary>
        /// Secrets is a list of Secrets in the same namespace as the Prometheus object, which shall be mounted into the Prometheus Pods. The Secrets are mounted into /etc/prometheus/secrets/&lt;secret-name&gt;.
        /// </summary>
        public InputList<string> Secrets
        {
            get => _secrets ?? (_secrets = new InputList<string>());
            set => _secrets = value;
        }

        /// <summary>
        /// SecurityContext holds pod-level security attributes and common container settings. This defaults to the default PodSecurityContext.
        /// </summary>
        [Input("securityContext")]
        public Input<Pulumi.Kubernetes.Types.Inputs.Monitoring.V1.PrometheusSpecSecurityContextArgs>? SecurityContext { get; set; }

        /// <summary>
        /// ServiceAccountName is the name of the ServiceAccount to use to run the Prometheus Pods.
        /// </summary>
        [Input("serviceAccountName")]
        public Input<string>? ServiceAccountName { get; set; }

        /// <summary>
        /// Namespaces to be selected for ServiceMonitor discovery. If nil, only check own namespace.
        /// </summary>
        [Input("serviceMonitorNamespaceSelector")]
        public Input<Pulumi.Kubernetes.Types.Inputs.Monitoring.V1.PrometheusSpecServiceMonitorNamespaceSelectorArgs>? ServiceMonitorNamespaceSelector { get; set; }

        /// <summary>
        /// ServiceMonitors to be selected for target discovery.
        /// </summary>
        [Input("serviceMonitorSelector")]
        public Input<Pulumi.Kubernetes.Types.Inputs.Monitoring.V1.PrometheusSpecServiceMonitorSelectorArgs>? ServiceMonitorSelector { get; set; }

        /// <summary>
        /// SHA of Prometheus container image to be deployed. Defaults to the value of `version`. Similar to a tag, but the SHA explicitly deploys an immutable container image. Version and Tag are ignored if SHA is set.
        /// </summary>
        [Input("sha")]
        public Input<string>? Sha { get; set; }

        /// <summary>
        /// Storage spec to specify how storage shall be used.
        /// </summary>
        [Input("storage")]
        public Input<Pulumi.Kubernetes.Types.Inputs.Monitoring.V1.PrometheusSpecStorageArgs>? Storage { get; set; }

        /// <summary>
        /// Tag of Prometheus container image to be deployed. Defaults to the value of `version`. Version is ignored if Tag is set.
        /// </summary>
        [Input("tag")]
        public Input<string>? Tag { get; set; }

        /// <summary>
        /// Thanos configuration allows configuring various aspects of a Prometheus server in a Thanos environment. 
        ///  This section is experimental, it may change significantly without deprecation notice in any release. 
        ///  This is experimental and may change significantly without backward compatibility in any release.
        /// </summary>
        [Input("thanos")]
        public Input<Pulumi.Kubernetes.Types.Inputs.Monitoring.V1.PrometheusSpecThanosArgs>? Thanos { get; set; }

        [Input("tolerations")]
        private InputList<Pulumi.Kubernetes.Types.Inputs.Monitoring.V1.PrometheusSpecTolerationsArgs>? _tolerations;

        /// <summary>
        /// If specified, the pod's tolerations.
        /// </summary>
        public InputList<Pulumi.Kubernetes.Types.Inputs.Monitoring.V1.PrometheusSpecTolerationsArgs> Tolerations
        {
            get => _tolerations ?? (_tolerations = new InputList<Pulumi.Kubernetes.Types.Inputs.Monitoring.V1.PrometheusSpecTolerationsArgs>());
            set => _tolerations = value;
        }

        /// <summary>
        /// Version of Prometheus to be deployed.
        /// </summary>
        [Input("version")]
        public Input<string>? Version { get; set; }

        [Input("volumes")]
        private InputList<Pulumi.Kubernetes.Types.Inputs.Monitoring.V1.PrometheusSpecVolumesArgs>? _volumes;

        /// <summary>
        /// Volumes allows configuration of additional volumes on the output StatefulSet definition. Volumes specified will be appended to other volumes that are generated as a result of StorageSpec objects.
        /// </summary>
        public InputList<Pulumi.Kubernetes.Types.Inputs.Monitoring.V1.PrometheusSpecVolumesArgs> Volumes
        {
            get => _volumes ?? (_volumes = new InputList<Pulumi.Kubernetes.Types.Inputs.Monitoring.V1.PrometheusSpecVolumesArgs>());
            set => _volumes = value;
        }

        /// <summary>
        /// Enable compression of the write-ahead log using Snappy. This flag is only available in versions of Prometheus &gt;= 2.11.0.
        /// </summary>
        [Input("walCompression")]
        public Input<bool>? WalCompression { get; set; }

        public PrometheusSpecArgs()
        {
        }
    }
}
