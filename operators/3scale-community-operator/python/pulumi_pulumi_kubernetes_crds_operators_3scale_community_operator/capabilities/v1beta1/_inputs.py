# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from ... import _utilities, _tables

__all__ = [
    'BackendSpecArgs',
    'BackendSpecMappingRulesArgs',
    'BackendSpecMethodsArgs',
    'BackendSpecMetricsArgs',
    'BackendSpecProviderAccountRefArgs',
    'BackendStatusArgs',
    'BackendStatusConditionsArgs',
    'ProductSpecArgs',
    'ProductSpecApplicationPlansArgs',
    'ProductSpecApplicationPlansLimitsArgs',
    'ProductSpecApplicationPlansLimitsMetricMethodRefArgs',
    'ProductSpecApplicationPlansPricingRulesArgs',
    'ProductSpecApplicationPlansPricingRulesMetricMethodRefArgs',
    'ProductSpecBackendUsagesArgs',
    'ProductSpecDeploymentArgs',
    'ProductSpecDeploymentApicastHostedArgs',
    'ProductSpecDeploymentApicastHostedAuthenticationArgs',
    'ProductSpecDeploymentApicastHostedAuthenticationAppKeyAppIDArgs',
    'ProductSpecDeploymentApicastHostedAuthenticationAppKeyAppIDSecurityArgs',
    'ProductSpecDeploymentApicastHostedAuthenticationUserkeyArgs',
    'ProductSpecDeploymentApicastHostedAuthenticationUserkeySecurityArgs',
    'ProductSpecDeploymentApicastSelfManagedArgs',
    'ProductSpecDeploymentApicastSelfManagedAuthenticationArgs',
    'ProductSpecDeploymentApicastSelfManagedAuthenticationAppKeyAppIDArgs',
    'ProductSpecDeploymentApicastSelfManagedAuthenticationAppKeyAppIDSecurityArgs',
    'ProductSpecDeploymentApicastSelfManagedAuthenticationUserkeyArgs',
    'ProductSpecDeploymentApicastSelfManagedAuthenticationUserkeySecurityArgs',
    'ProductSpecMappingRulesArgs',
    'ProductSpecMethodsArgs',
    'ProductSpecMetricsArgs',
    'ProductSpecProviderAccountRefArgs',
    'ProductStatusArgs',
    'ProductStatusConditionsArgs',
]

@pulumi.input_type
class BackendSpecArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 private_base_url: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 mapping_rules: Optional[pulumi.Input[Sequence[pulumi.Input['BackendSpecMappingRulesArgs']]]] = None,
                 methods: Optional[pulumi.Input[Mapping[str, pulumi.Input['BackendSpecMethodsArgs']]]] = None,
                 metrics: Optional[pulumi.Input[Mapping[str, pulumi.Input['BackendSpecMetricsArgs']]]] = None,
                 provider_account_ref: Optional[pulumi.Input['BackendSpecProviderAccountRefArgs']] = None,
                 system_name: Optional[pulumi.Input[str]] = None):
        """
        BackendSpec defines the desired state of Backend
        :param pulumi.Input[str] name: Name is human readable name for the backend
        :param pulumi.Input[str] private_base_url: PrivateBaseURL Private Base URL of the API
        :param pulumi.Input[str] description: Description is a human readable text of the backend
        :param pulumi.Input[Mapping[str, pulumi.Input['BackendSpecMethodsArgs']]] methods: Methods Map: system_name -> MethodSpec system_name attr is unique for all metrics AND methods In other words, if metric's system_name is A, there is no metric or method with system_name A.
        :param pulumi.Input[Mapping[str, pulumi.Input['BackendSpecMetricsArgs']]] metrics: Metrics Map: system_name -> MetricSpec system_name attr is unique for all metrics AND methods In other words, if metric's system_name is A, there is no metric or method with system_name A.
        :param pulumi.Input['BackendSpecProviderAccountRefArgs'] provider_account_ref: ProviderAccountRef references account provider credentials
        :param pulumi.Input[str] system_name: SystemName identifies uniquely the product within the account provider Default value will be sanitized Name
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "private_base_url", private_base_url)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if mapping_rules is not None:
            pulumi.set(__self__, "mapping_rules", mapping_rules)
        if methods is not None:
            pulumi.set(__self__, "methods", methods)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if provider_account_ref is not None:
            pulumi.set(__self__, "provider_account_ref", provider_account_ref)
        if system_name is not None:
            pulumi.set(__self__, "system_name", system_name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name is human readable name for the backend
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="privateBaseURL")
    def private_base_url(self) -> pulumi.Input[str]:
        """
        PrivateBaseURL Private Base URL of the API
        """
        return pulumi.get(self, "private_base_url")

    @private_base_url.setter
    def private_base_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "private_base_url", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description is a human readable text of the backend
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="mappingRules")
    def mapping_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BackendSpecMappingRulesArgs']]]]:
        return pulumi.get(self, "mapping_rules")

    @mapping_rules.setter
    def mapping_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BackendSpecMappingRulesArgs']]]]):
        pulumi.set(self, "mapping_rules", value)

    @property
    @pulumi.getter
    def methods(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['BackendSpecMethodsArgs']]]]:
        """
        Methods Map: system_name -> MethodSpec system_name attr is unique for all metrics AND methods In other words, if metric's system_name is A, there is no metric or method with system_name A.
        """
        return pulumi.get(self, "methods")

    @methods.setter
    def methods(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['BackendSpecMethodsArgs']]]]):
        pulumi.set(self, "methods", value)

    @property
    @pulumi.getter
    def metrics(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['BackendSpecMetricsArgs']]]]:
        """
        Metrics Map: system_name -> MetricSpec system_name attr is unique for all metrics AND methods In other words, if metric's system_name is A, there is no metric or method with system_name A.
        """
        return pulumi.get(self, "metrics")

    @metrics.setter
    def metrics(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['BackendSpecMetricsArgs']]]]):
        pulumi.set(self, "metrics", value)

    @property
    @pulumi.getter(name="providerAccountRef")
    def provider_account_ref(self) -> Optional[pulumi.Input['BackendSpecProviderAccountRefArgs']]:
        """
        ProviderAccountRef references account provider credentials
        """
        return pulumi.get(self, "provider_account_ref")

    @provider_account_ref.setter
    def provider_account_ref(self, value: Optional[pulumi.Input['BackendSpecProviderAccountRefArgs']]):
        pulumi.set(self, "provider_account_ref", value)

    @property
    @pulumi.getter(name="systemName")
    def system_name(self) -> Optional[pulumi.Input[str]]:
        """
        SystemName identifies uniquely the product within the account provider Default value will be sanitized Name
        """
        return pulumi.get(self, "system_name")

    @system_name.setter
    def system_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "system_name", value)


@pulumi.input_type
class BackendSpecMappingRulesArgs:
    def __init__(__self__, *,
                 http_method: pulumi.Input[str],
                 increment: pulumi.Input[int],
                 metric_method_ref: pulumi.Input[str],
                 pattern: pulumi.Input[str],
                 position: Optional[pulumi.Input[int]] = None):
        """
        MappingRuleSpec defines the desired state of Product's MappingRule
        """
        pulumi.set(__self__, "http_method", http_method)
        pulumi.set(__self__, "increment", increment)
        pulumi.set(__self__, "metric_method_ref", metric_method_ref)
        pulumi.set(__self__, "pattern", pattern)
        if position is not None:
            pulumi.set(__self__, "position", position)

    @property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> pulumi.Input[str]:
        return pulumi.get(self, "http_method")

    @http_method.setter
    def http_method(self, value: pulumi.Input[str]):
        pulumi.set(self, "http_method", value)

    @property
    @pulumi.getter
    def increment(self) -> pulumi.Input[int]:
        return pulumi.get(self, "increment")

    @increment.setter
    def increment(self, value: pulumi.Input[int]):
        pulumi.set(self, "increment", value)

    @property
    @pulumi.getter(name="metricMethodRef")
    def metric_method_ref(self) -> pulumi.Input[str]:
        return pulumi.get(self, "metric_method_ref")

    @metric_method_ref.setter
    def metric_method_ref(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_method_ref", value)

    @property
    @pulumi.getter
    def pattern(self) -> pulumi.Input[str]:
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: pulumi.Input[str]):
        pulumi.set(self, "pattern", value)

    @property
    @pulumi.getter
    def position(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "position")

    @position.setter
    def position(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "position", value)


@pulumi.input_type
class BackendSpecMethodsArgs:
    def __init__(__self__, *,
                 friendly_name: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        """
        MethodSpec defines the desired state of Product's Method
        """
        pulumi.set(__self__, "friendly_name", friendly_name)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter(name="friendlyName")
    def friendly_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "friendly_name")

    @friendly_name.setter
    def friendly_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "friendly_name", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


@pulumi.input_type
class BackendSpecMetricsArgs:
    def __init__(__self__, *,
                 friendly_name: pulumi.Input[str],
                 unit: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        """
        MetricSpec defines the desired state of Product's Metric
        """
        pulumi.set(__self__, "friendly_name", friendly_name)
        pulumi.set(__self__, "unit", unit)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter(name="friendlyName")
    def friendly_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "friendly_name")

    @friendly_name.setter
    def friendly_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "friendly_name", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input[str]:
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


@pulumi.input_type
class BackendSpecProviderAccountRefArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        ProviderAccountRef references account provider credentials
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class BackendStatusArgs:
    def __init__(__self__, *,
                 backend_id: Optional[pulumi.Input[int]] = None,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['BackendStatusConditionsArgs']]]] = None,
                 observed_generation: Optional[pulumi.Input[int]] = None):
        """
        BackendStatus defines the observed state of Backend
        :param pulumi.Input[Sequence[pulumi.Input['BackendStatusConditionsArgs']]] conditions: Current state of the 3scale backend. Conditions represent the latest available observations of an object's state
        :param pulumi.Input[int] observed_generation: ObservedGeneration reflects the generation of the most recently observed Backend Spec.
        """
        if backend_id is not None:
            pulumi.set(__self__, "backend_id", backend_id)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)

    @property
    @pulumi.getter(name="backendId")
    def backend_id(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "backend_id")

    @backend_id.setter
    def backend_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "backend_id", value)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BackendStatusConditionsArgs']]]]:
        """
        Current state of the 3scale backend. Conditions represent the latest available observations of an object's state
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BackendStatusConditionsArgs']]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[pulumi.Input[int]]:
        """
        ObservedGeneration reflects the generation of the most recently observed Backend Spec.
        """
        return pulumi.get(self, "observed_generation")

    @observed_generation.setter
    def observed_generation(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "observed_generation", value)


@pulumi.input_type
class BackendStatusConditionsArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[str],
                 type: pulumi.Input[str],
                 last_transition_time: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None):
        """
        Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
         Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
        :param pulumi.Input[str] type: ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
                Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        :param pulumi.Input[str] reason: ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
         Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)


@pulumi.input_type
class ProductSpecArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 application_plans: Optional[pulumi.Input[Mapping[str, pulumi.Input['ProductSpecApplicationPlansArgs']]]] = None,
                 backend_usages: Optional[pulumi.Input[Mapping[str, pulumi.Input['ProductSpecBackendUsagesArgs']]]] = None,
                 deployment: Optional[pulumi.Input['ProductSpecDeploymentArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 mapping_rules: Optional[pulumi.Input[Sequence[pulumi.Input['ProductSpecMappingRulesArgs']]]] = None,
                 methods: Optional[pulumi.Input[Mapping[str, pulumi.Input['ProductSpecMethodsArgs']]]] = None,
                 metrics: Optional[pulumi.Input[Mapping[str, pulumi.Input['ProductSpecMetricsArgs']]]] = None,
                 provider_account_ref: Optional[pulumi.Input['ProductSpecProviderAccountRefArgs']] = None,
                 system_name: Optional[pulumi.Input[str]] = None):
        """
        ProductSpec defines the desired state of Product
        :param pulumi.Input[str] name: Name is human readable name for the product
        :param pulumi.Input[Mapping[str, pulumi.Input['ProductSpecApplicationPlansArgs']]] application_plans: Application Plans Map: system_name -> Application Plan Spec
        :param pulumi.Input[Mapping[str, pulumi.Input['ProductSpecBackendUsagesArgs']]] backend_usages: Backend usage will be a map of Map: system_name -> BackendUsageSpec Having system_name as the index, the structure ensures one backend is not used multiple times.
        :param pulumi.Input['ProductSpecDeploymentArgs'] deployment: Deployment defined 3scale product deployment mode
        :param pulumi.Input[str] description: Description is a human readable text of the product
        :param pulumi.Input[Sequence[pulumi.Input['ProductSpecMappingRulesArgs']]] mapping_rules: Mapping Rules Array: MappingRule Spec
        :param pulumi.Input[Mapping[str, pulumi.Input['ProductSpecMethodsArgs']]] methods: Methods Map: system_name -> MethodSpec system_name attr is unique for all metrics AND methods In other words, if metric's system_name is A, there is no metric or method with system_name A.
        :param pulumi.Input[Mapping[str, pulumi.Input['ProductSpecMetricsArgs']]] metrics: Metrics Map: system_name -> MetricSpec system_name attr is unique for all metrics AND methods In other words, if metric's system_name is A, there is no metric or method with system_name A.
        :param pulumi.Input['ProductSpecProviderAccountRefArgs'] provider_account_ref: ProviderAccountRef references account provider credentials
        :param pulumi.Input[str] system_name: SystemName identifies uniquely the product within the account provider Default value will be sanitized Name
        """
        pulumi.set(__self__, "name", name)
        if application_plans is not None:
            pulumi.set(__self__, "application_plans", application_plans)
        if backend_usages is not None:
            pulumi.set(__self__, "backend_usages", backend_usages)
        if deployment is not None:
            pulumi.set(__self__, "deployment", deployment)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if mapping_rules is not None:
            pulumi.set(__self__, "mapping_rules", mapping_rules)
        if methods is not None:
            pulumi.set(__self__, "methods", methods)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if provider_account_ref is not None:
            pulumi.set(__self__, "provider_account_ref", provider_account_ref)
        if system_name is not None:
            pulumi.set(__self__, "system_name", system_name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name is human readable name for the product
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="applicationPlans")
    def application_plans(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ProductSpecApplicationPlansArgs']]]]:
        """
        Application Plans Map: system_name -> Application Plan Spec
        """
        return pulumi.get(self, "application_plans")

    @application_plans.setter
    def application_plans(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ProductSpecApplicationPlansArgs']]]]):
        pulumi.set(self, "application_plans", value)

    @property
    @pulumi.getter(name="backendUsages")
    def backend_usages(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ProductSpecBackendUsagesArgs']]]]:
        """
        Backend usage will be a map of Map: system_name -> BackendUsageSpec Having system_name as the index, the structure ensures one backend is not used multiple times.
        """
        return pulumi.get(self, "backend_usages")

    @backend_usages.setter
    def backend_usages(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ProductSpecBackendUsagesArgs']]]]):
        pulumi.set(self, "backend_usages", value)

    @property
    @pulumi.getter
    def deployment(self) -> Optional[pulumi.Input['ProductSpecDeploymentArgs']]:
        """
        Deployment defined 3scale product deployment mode
        """
        return pulumi.get(self, "deployment")

    @deployment.setter
    def deployment(self, value: Optional[pulumi.Input['ProductSpecDeploymentArgs']]):
        pulumi.set(self, "deployment", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description is a human readable text of the product
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="mappingRules")
    def mapping_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProductSpecMappingRulesArgs']]]]:
        """
        Mapping Rules Array: MappingRule Spec
        """
        return pulumi.get(self, "mapping_rules")

    @mapping_rules.setter
    def mapping_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProductSpecMappingRulesArgs']]]]):
        pulumi.set(self, "mapping_rules", value)

    @property
    @pulumi.getter
    def methods(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ProductSpecMethodsArgs']]]]:
        """
        Methods Map: system_name -> MethodSpec system_name attr is unique for all metrics AND methods In other words, if metric's system_name is A, there is no metric or method with system_name A.
        """
        return pulumi.get(self, "methods")

    @methods.setter
    def methods(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ProductSpecMethodsArgs']]]]):
        pulumi.set(self, "methods", value)

    @property
    @pulumi.getter
    def metrics(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ProductSpecMetricsArgs']]]]:
        """
        Metrics Map: system_name -> MetricSpec system_name attr is unique for all metrics AND methods In other words, if metric's system_name is A, there is no metric or method with system_name A.
        """
        return pulumi.get(self, "metrics")

    @metrics.setter
    def metrics(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ProductSpecMetricsArgs']]]]):
        pulumi.set(self, "metrics", value)

    @property
    @pulumi.getter(name="providerAccountRef")
    def provider_account_ref(self) -> Optional[pulumi.Input['ProductSpecProviderAccountRefArgs']]:
        """
        ProviderAccountRef references account provider credentials
        """
        return pulumi.get(self, "provider_account_ref")

    @provider_account_ref.setter
    def provider_account_ref(self, value: Optional[pulumi.Input['ProductSpecProviderAccountRefArgs']]):
        pulumi.set(self, "provider_account_ref", value)

    @property
    @pulumi.getter(name="systemName")
    def system_name(self) -> Optional[pulumi.Input[str]]:
        """
        SystemName identifies uniquely the product within the account provider Default value will be sanitized Name
        """
        return pulumi.get(self, "system_name")

    @system_name.setter
    def system_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "system_name", value)


@pulumi.input_type
class ProductSpecApplicationPlansArgs:
    def __init__(__self__, *,
                 apps_require_approval: Optional[pulumi.Input[bool]] = None,
                 cost_month: Optional[pulumi.Input[str]] = None,
                 limits: Optional[pulumi.Input[Sequence[pulumi.Input['ProductSpecApplicationPlansLimitsArgs']]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 pricing_rules: Optional[pulumi.Input[Sequence[pulumi.Input['ProductSpecApplicationPlansPricingRulesArgs']]]] = None,
                 setup_fee: Optional[pulumi.Input[str]] = None,
                 trial_period: Optional[pulumi.Input[int]] = None):
        """
        ApplicationPlanSpec defines the desired state of Product's Application Plan
        :param pulumi.Input[bool] apps_require_approval: Set whether or not applications can be created on demand or if approval is required from you before they are activated.
        :param pulumi.Input[str] cost_month: Cost per Month (USD)
        :param pulumi.Input[Sequence[pulumi.Input['ProductSpecApplicationPlansLimitsArgs']]] limits: Limits
        :param pulumi.Input[Sequence[pulumi.Input['ProductSpecApplicationPlansPricingRulesArgs']]] pricing_rules: Pricing Rules
        :param pulumi.Input[str] setup_fee: Setup fee (USD)
        :param pulumi.Input[int] trial_period: Trial Period (days)
        """
        if apps_require_approval is not None:
            pulumi.set(__self__, "apps_require_approval", apps_require_approval)
        if cost_month is not None:
            pulumi.set(__self__, "cost_month", cost_month)
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if pricing_rules is not None:
            pulumi.set(__self__, "pricing_rules", pricing_rules)
        if setup_fee is not None:
            pulumi.set(__self__, "setup_fee", setup_fee)
        if trial_period is not None:
            pulumi.set(__self__, "trial_period", trial_period)

    @property
    @pulumi.getter(name="appsRequireApproval")
    def apps_require_approval(self) -> Optional[pulumi.Input[bool]]:
        """
        Set whether or not applications can be created on demand or if approval is required from you before they are activated.
        """
        return pulumi.get(self, "apps_require_approval")

    @apps_require_approval.setter
    def apps_require_approval(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "apps_require_approval", value)

    @property
    @pulumi.getter(name="costMonth")
    def cost_month(self) -> Optional[pulumi.Input[str]]:
        """
        Cost per Month (USD)
        """
        return pulumi.get(self, "cost_month")

    @cost_month.setter
    def cost_month(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cost_month", value)

    @property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProductSpecApplicationPlansLimitsArgs']]]]:
        """
        Limits
        """
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProductSpecApplicationPlansLimitsArgs']]]]):
        pulumi.set(self, "limits", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="pricingRules")
    def pricing_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProductSpecApplicationPlansPricingRulesArgs']]]]:
        """
        Pricing Rules
        """
        return pulumi.get(self, "pricing_rules")

    @pricing_rules.setter
    def pricing_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProductSpecApplicationPlansPricingRulesArgs']]]]):
        pulumi.set(self, "pricing_rules", value)

    @property
    @pulumi.getter(name="setupFee")
    def setup_fee(self) -> Optional[pulumi.Input[str]]:
        """
        Setup fee (USD)
        """
        return pulumi.get(self, "setup_fee")

    @setup_fee.setter
    def setup_fee(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "setup_fee", value)

    @property
    @pulumi.getter(name="trialPeriod")
    def trial_period(self) -> Optional[pulumi.Input[int]]:
        """
        Trial Period (days)
        """
        return pulumi.get(self, "trial_period")

    @trial_period.setter
    def trial_period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "trial_period", value)


@pulumi.input_type
class ProductSpecApplicationPlansLimitsArgs:
    def __init__(__self__, *,
                 metric_method_ref: pulumi.Input['ProductSpecApplicationPlansLimitsMetricMethodRefArgs'],
                 period: pulumi.Input[str],
                 value: pulumi.Input[int]):
        """
        LimitSpec defines the maximum value a metric can take on a contract before the user is no longer authorized to use resources. Once a limit has been passed in a given period, reject messages will be issued if the service is accessed under this contract.
        :param pulumi.Input['ProductSpecApplicationPlansLimitsMetricMethodRefArgs'] metric_method_ref: Metric or Method Reference
        :param pulumi.Input[str] period: Limit Period
        :param pulumi.Input[int] value: Limit Value
        """
        pulumi.set(__self__, "metric_method_ref", metric_method_ref)
        pulumi.set(__self__, "period", period)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="metricMethodRef")
    def metric_method_ref(self) -> pulumi.Input['ProductSpecApplicationPlansLimitsMetricMethodRefArgs']:
        """
        Metric or Method Reference
        """
        return pulumi.get(self, "metric_method_ref")

    @metric_method_ref.setter
    def metric_method_ref(self, value: pulumi.Input['ProductSpecApplicationPlansLimitsMetricMethodRefArgs']):
        pulumi.set(self, "metric_method_ref", value)

    @property
    @pulumi.getter
    def period(self) -> pulumi.Input[str]:
        """
        Limit Period
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: pulumi.Input[str]):
        pulumi.set(self, "period", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[int]:
        """
        Limit Value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[int]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class ProductSpecApplicationPlansLimitsMetricMethodRefArgs:
    def __init__(__self__, *,
                 system_name: pulumi.Input[str],
                 backend: Optional[pulumi.Input[str]] = None):
        """
        Metric or Method Reference
        :param pulumi.Input[str] system_name: SystemName identifies uniquely the metric or methods
        :param pulumi.Input[str] backend: BackendSystemName identifies uniquely the backend Backend reference must be used by the product
        """
        pulumi.set(__self__, "system_name", system_name)
        if backend is not None:
            pulumi.set(__self__, "backend", backend)

    @property
    @pulumi.getter(name="systemName")
    def system_name(self) -> pulumi.Input[str]:
        """
        SystemName identifies uniquely the metric or methods
        """
        return pulumi.get(self, "system_name")

    @system_name.setter
    def system_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "system_name", value)

    @property
    @pulumi.getter
    def backend(self) -> Optional[pulumi.Input[str]]:
        """
        BackendSystemName identifies uniquely the backend Backend reference must be used by the product
        """
        return pulumi.get(self, "backend")

    @backend.setter
    def backend(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backend", value)


@pulumi.input_type
class ProductSpecApplicationPlansPricingRulesArgs:
    def __init__(__self__, *,
                 from_: pulumi.Input[int],
                 metric_method_ref: pulumi.Input['ProductSpecApplicationPlansPricingRulesMetricMethodRefArgs'],
                 price_per_unit: pulumi.Input[str],
                 to: pulumi.Input[int]):
        """
        PricingRuleSpec defines the cost of each operation performed on an API. Multiple pricing rules on the same metric divide up the ranges of when a pricing rule applies.
        :param pulumi.Input[int] from_: Range From
        :param pulumi.Input['ProductSpecApplicationPlansPricingRulesMetricMethodRefArgs'] metric_method_ref: Metric or Method Reference
        :param pulumi.Input[str] price_per_unit: Price per unit (USD)
        :param pulumi.Input[int] to: Range To
        """
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "metric_method_ref", metric_method_ref)
        pulumi.set(__self__, "price_per_unit", price_per_unit)
        pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> pulumi.Input[int]:
        """
        Range From
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: pulumi.Input[int]):
        pulumi.set(self, "from_", value)

    @property
    @pulumi.getter(name="metricMethodRef")
    def metric_method_ref(self) -> pulumi.Input['ProductSpecApplicationPlansPricingRulesMetricMethodRefArgs']:
        """
        Metric or Method Reference
        """
        return pulumi.get(self, "metric_method_ref")

    @metric_method_ref.setter
    def metric_method_ref(self, value: pulumi.Input['ProductSpecApplicationPlansPricingRulesMetricMethodRefArgs']):
        pulumi.set(self, "metric_method_ref", value)

    @property
    @pulumi.getter(name="pricePerUnit")
    def price_per_unit(self) -> pulumi.Input[str]:
        """
        Price per unit (USD)
        """
        return pulumi.get(self, "price_per_unit")

    @price_per_unit.setter
    def price_per_unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "price_per_unit", value)

    @property
    @pulumi.getter
    def to(self) -> pulumi.Input[int]:
        """
        Range To
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: pulumi.Input[int]):
        pulumi.set(self, "to", value)


@pulumi.input_type
class ProductSpecApplicationPlansPricingRulesMetricMethodRefArgs:
    def __init__(__self__, *,
                 system_name: pulumi.Input[str],
                 backend: Optional[pulumi.Input[str]] = None):
        """
        Metric or Method Reference
        :param pulumi.Input[str] system_name: SystemName identifies uniquely the metric or methods
        :param pulumi.Input[str] backend: BackendSystemName identifies uniquely the backend Backend reference must be used by the product
        """
        pulumi.set(__self__, "system_name", system_name)
        if backend is not None:
            pulumi.set(__self__, "backend", backend)

    @property
    @pulumi.getter(name="systemName")
    def system_name(self) -> pulumi.Input[str]:
        """
        SystemName identifies uniquely the metric or methods
        """
        return pulumi.get(self, "system_name")

    @system_name.setter
    def system_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "system_name", value)

    @property
    @pulumi.getter
    def backend(self) -> Optional[pulumi.Input[str]]:
        """
        BackendSystemName identifies uniquely the backend Backend reference must be used by the product
        """
        return pulumi.get(self, "backend")

    @backend.setter
    def backend(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backend", value)


@pulumi.input_type
class ProductSpecBackendUsagesArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str]):
        """
        BackendUsageSpec defines the desired state of Product's Backend Usages
        """
        pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)


@pulumi.input_type
class ProductSpecDeploymentArgs:
    def __init__(__self__, *,
                 apicast_hosted: Optional[pulumi.Input['ProductSpecDeploymentApicastHostedArgs']] = None,
                 apicast_self_managed: Optional[pulumi.Input['ProductSpecDeploymentApicastSelfManagedArgs']] = None):
        """
        Deployment defined 3scale product deployment mode
        :param pulumi.Input['ProductSpecDeploymentApicastHostedArgs'] apicast_hosted: ApicastHostedSpec defines the desired state of Product Apicast Hosted
        :param pulumi.Input['ProductSpecDeploymentApicastSelfManagedArgs'] apicast_self_managed: ApicastSelfManagedSpec defines the desired state of Product Apicast Self Managed
        """
        if apicast_hosted is not None:
            pulumi.set(__self__, "apicast_hosted", apicast_hosted)
        if apicast_self_managed is not None:
            pulumi.set(__self__, "apicast_self_managed", apicast_self_managed)

    @property
    @pulumi.getter(name="apicastHosted")
    def apicast_hosted(self) -> Optional[pulumi.Input['ProductSpecDeploymentApicastHostedArgs']]:
        """
        ApicastHostedSpec defines the desired state of Product Apicast Hosted
        """
        return pulumi.get(self, "apicast_hosted")

    @apicast_hosted.setter
    def apicast_hosted(self, value: Optional[pulumi.Input['ProductSpecDeploymentApicastHostedArgs']]):
        pulumi.set(self, "apicast_hosted", value)

    @property
    @pulumi.getter(name="apicastSelfManaged")
    def apicast_self_managed(self) -> Optional[pulumi.Input['ProductSpecDeploymentApicastSelfManagedArgs']]:
        """
        ApicastSelfManagedSpec defines the desired state of Product Apicast Self Managed
        """
        return pulumi.get(self, "apicast_self_managed")

    @apicast_self_managed.setter
    def apicast_self_managed(self, value: Optional[pulumi.Input['ProductSpecDeploymentApicastSelfManagedArgs']]):
        pulumi.set(self, "apicast_self_managed", value)


@pulumi.input_type
class ProductSpecDeploymentApicastHostedArgs:
    def __init__(__self__, *,
                 authentication: Optional[pulumi.Input['ProductSpecDeploymentApicastHostedAuthenticationArgs']] = None):
        """
        ApicastHostedSpec defines the desired state of Product Apicast Hosted
        :param pulumi.Input['ProductSpecDeploymentApicastHostedAuthenticationArgs'] authentication: AuthenticationSpec defines the desired state of Product Authentication
        """
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)

    @property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['ProductSpecDeploymentApicastHostedAuthenticationArgs']]:
        """
        AuthenticationSpec defines the desired state of Product Authentication
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['ProductSpecDeploymentApicastHostedAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)


@pulumi.input_type
class ProductSpecDeploymentApicastHostedAuthenticationArgs:
    def __init__(__self__, *,
                 app_key_app_id: Optional[pulumi.Input['ProductSpecDeploymentApicastHostedAuthenticationAppKeyAppIDArgs']] = None,
                 userkey: Optional[pulumi.Input['ProductSpecDeploymentApicastHostedAuthenticationUserkeyArgs']] = None):
        """
        AuthenticationSpec defines the desired state of Product Authentication
        :param pulumi.Input['ProductSpecDeploymentApicastHostedAuthenticationAppKeyAppIDArgs'] app_key_app_id: AppKeyAppIDAuthenticationSpec defines the desired state of AppKey&AppId Authentication
        :param pulumi.Input['ProductSpecDeploymentApicastHostedAuthenticationUserkeyArgs'] userkey: UserKeyAuthenticationSpec defines the desired state of User Key Authentication
        """
        if app_key_app_id is not None:
            pulumi.set(__self__, "app_key_app_id", app_key_app_id)
        if userkey is not None:
            pulumi.set(__self__, "userkey", userkey)

    @property
    @pulumi.getter(name="appKeyAppID")
    def app_key_app_id(self) -> Optional[pulumi.Input['ProductSpecDeploymentApicastHostedAuthenticationAppKeyAppIDArgs']]:
        """
        AppKeyAppIDAuthenticationSpec defines the desired state of AppKey&AppId Authentication
        """
        return pulumi.get(self, "app_key_app_id")

    @app_key_app_id.setter
    def app_key_app_id(self, value: Optional[pulumi.Input['ProductSpecDeploymentApicastHostedAuthenticationAppKeyAppIDArgs']]):
        pulumi.set(self, "app_key_app_id", value)

    @property
    @pulumi.getter
    def userkey(self) -> Optional[pulumi.Input['ProductSpecDeploymentApicastHostedAuthenticationUserkeyArgs']]:
        """
        UserKeyAuthenticationSpec defines the desired state of User Key Authentication
        """
        return pulumi.get(self, "userkey")

    @userkey.setter
    def userkey(self, value: Optional[pulumi.Input['ProductSpecDeploymentApicastHostedAuthenticationUserkeyArgs']]):
        pulumi.set(self, "userkey", value)


@pulumi.input_type
class ProductSpecDeploymentApicastHostedAuthenticationAppKeyAppIDArgs:
    def __init__(__self__, *,
                 app_id: Optional[pulumi.Input[str]] = None,
                 app_key: Optional[pulumi.Input[str]] = None,
                 credentials: Optional[pulumi.Input[str]] = None,
                 security: Optional[pulumi.Input['ProductSpecDeploymentApicastHostedAuthenticationAppKeyAppIDSecurityArgs']] = None):
        """
        AppKeyAppIDAuthenticationSpec defines the desired state of AppKey&AppId Authentication
        :param pulumi.Input[str] app_id: AppID is the name of the parameter that acts of behalf of app id
        :param pulumi.Input[str] app_key: AppKey is the name of the parameter that acts of behalf of app key
        :param pulumi.Input[str] credentials: CredentialsLoc available options: headers: As HTTP Headers query: As query parameters (GET) or body parameters (POST/PUT/DELETE) authorization: As HTTP Basic Authentication
        :param pulumi.Input['ProductSpecDeploymentApicastHostedAuthenticationAppKeyAppIDSecurityArgs'] security: SecuritySpec defines the desired state of Authentication Security
        """
        if app_id is not None:
            pulumi.set(__self__, "app_id", app_id)
        if app_key is not None:
            pulumi.set(__self__, "app_key", app_key)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if security is not None:
            pulumi.set(__self__, "security", security)

    @property
    @pulumi.getter(name="appID")
    def app_id(self) -> Optional[pulumi.Input[str]]:
        """
        AppID is the name of the parameter that acts of behalf of app id
        """
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_id", value)

    @property
    @pulumi.getter(name="appKey")
    def app_key(self) -> Optional[pulumi.Input[str]]:
        """
        AppKey is the name of the parameter that acts of behalf of app key
        """
        return pulumi.get(self, "app_key")

    @app_key.setter
    def app_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_key", value)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input[str]]:
        """
        CredentialsLoc available options: headers: As HTTP Headers query: As query parameters (GET) or body parameters (POST/PUT/DELETE) authorization: As HTTP Basic Authentication
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter
    def security(self) -> Optional[pulumi.Input['ProductSpecDeploymentApicastHostedAuthenticationAppKeyAppIDSecurityArgs']]:
        """
        SecuritySpec defines the desired state of Authentication Security
        """
        return pulumi.get(self, "security")

    @security.setter
    def security(self, value: Optional[pulumi.Input['ProductSpecDeploymentApicastHostedAuthenticationAppKeyAppIDSecurityArgs']]):
        pulumi.set(self, "security", value)


@pulumi.input_type
class ProductSpecDeploymentApicastHostedAuthenticationAppKeyAppIDSecurityArgs:
    def __init__(__self__, *,
                 host_header: Optional[pulumi.Input[str]] = None,
                 secret_token: Optional[pulumi.Input[str]] = None):
        """
        SecuritySpec defines the desired state of Authentication Security
        :param pulumi.Input[str] host_header: HostHeader Lets you define a custom Host request header. This is needed if your API backend only accepts traffic from a specific host.
        :param pulumi.Input[str] secret_token: SecretToken Enables you to block any direct developer requests to your API backend; each 3scale API gateway call to your API backend contains a request header called X-3scale-proxy-secret-token. The value of this header can be set by you here. It's up to you ensure your backend only allows calls with this secret header.
        """
        if host_header is not None:
            pulumi.set(__self__, "host_header", host_header)
        if secret_token is not None:
            pulumi.set(__self__, "secret_token", secret_token)

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> Optional[pulumi.Input[str]]:
        """
        HostHeader Lets you define a custom Host request header. This is needed if your API backend only accepts traffic from a specific host.
        """
        return pulumi.get(self, "host_header")

    @host_header.setter
    def host_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_header", value)

    @property
    @pulumi.getter(name="secretToken")
    def secret_token(self) -> Optional[pulumi.Input[str]]:
        """
        SecretToken Enables you to block any direct developer requests to your API backend; each 3scale API gateway call to your API backend contains a request header called X-3scale-proxy-secret-token. The value of this header can be set by you here. It's up to you ensure your backend only allows calls with this secret header.
        """
        return pulumi.get(self, "secret_token")

    @secret_token.setter
    def secret_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_token", value)


@pulumi.input_type
class ProductSpecDeploymentApicastHostedAuthenticationUserkeyArgs:
    def __init__(__self__, *,
                 auth_user_key: Optional[pulumi.Input[str]] = None,
                 credentials: Optional[pulumi.Input[str]] = None,
                 security: Optional[pulumi.Input['ProductSpecDeploymentApicastHostedAuthenticationUserkeySecurityArgs']] = None):
        """
        UserKeyAuthenticationSpec defines the desired state of User Key Authentication
        :param pulumi.Input[str] credentials: Credentials Location available options: headers: As HTTP Headers query: As query parameters (GET) or body parameters (POST/PUT/DELETE) authorization: As HTTP Basic Authentication
        :param pulumi.Input['ProductSpecDeploymentApicastHostedAuthenticationUserkeySecurityArgs'] security: SecuritySpec defines the desired state of Authentication Security
        """
        if auth_user_key is not None:
            pulumi.set(__self__, "auth_user_key", auth_user_key)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if security is not None:
            pulumi.set(__self__, "security", security)

    @property
    @pulumi.getter(name="authUserKey")
    def auth_user_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "auth_user_key")

    @auth_user_key.setter
    def auth_user_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_user_key", value)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input[str]]:
        """
        Credentials Location available options: headers: As HTTP Headers query: As query parameters (GET) or body parameters (POST/PUT/DELETE) authorization: As HTTP Basic Authentication
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter
    def security(self) -> Optional[pulumi.Input['ProductSpecDeploymentApicastHostedAuthenticationUserkeySecurityArgs']]:
        """
        SecuritySpec defines the desired state of Authentication Security
        """
        return pulumi.get(self, "security")

    @security.setter
    def security(self, value: Optional[pulumi.Input['ProductSpecDeploymentApicastHostedAuthenticationUserkeySecurityArgs']]):
        pulumi.set(self, "security", value)


@pulumi.input_type
class ProductSpecDeploymentApicastHostedAuthenticationUserkeySecurityArgs:
    def __init__(__self__, *,
                 host_header: Optional[pulumi.Input[str]] = None,
                 secret_token: Optional[pulumi.Input[str]] = None):
        """
        SecuritySpec defines the desired state of Authentication Security
        :param pulumi.Input[str] host_header: HostHeader Lets you define a custom Host request header. This is needed if your API backend only accepts traffic from a specific host.
        :param pulumi.Input[str] secret_token: SecretToken Enables you to block any direct developer requests to your API backend; each 3scale API gateway call to your API backend contains a request header called X-3scale-proxy-secret-token. The value of this header can be set by you here. It's up to you ensure your backend only allows calls with this secret header.
        """
        if host_header is not None:
            pulumi.set(__self__, "host_header", host_header)
        if secret_token is not None:
            pulumi.set(__self__, "secret_token", secret_token)

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> Optional[pulumi.Input[str]]:
        """
        HostHeader Lets you define a custom Host request header. This is needed if your API backend only accepts traffic from a specific host.
        """
        return pulumi.get(self, "host_header")

    @host_header.setter
    def host_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_header", value)

    @property
    @pulumi.getter(name="secretToken")
    def secret_token(self) -> Optional[pulumi.Input[str]]:
        """
        SecretToken Enables you to block any direct developer requests to your API backend; each 3scale API gateway call to your API backend contains a request header called X-3scale-proxy-secret-token. The value of this header can be set by you here. It's up to you ensure your backend only allows calls with this secret header.
        """
        return pulumi.get(self, "secret_token")

    @secret_token.setter
    def secret_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_token", value)


@pulumi.input_type
class ProductSpecDeploymentApicastSelfManagedArgs:
    def __init__(__self__, *,
                 authentication: Optional[pulumi.Input['ProductSpecDeploymentApicastSelfManagedAuthenticationArgs']] = None,
                 production_public_base_url: Optional[pulumi.Input[str]] = None,
                 staging_public_base_url: Optional[pulumi.Input[str]] = None):
        """
        ApicastSelfManagedSpec defines the desired state of Product Apicast Self Managed
        :param pulumi.Input['ProductSpecDeploymentApicastSelfManagedAuthenticationArgs'] authentication: AuthenticationSpec defines the desired state of Product Authentication
        """
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if production_public_base_url is not None:
            pulumi.set(__self__, "production_public_base_url", production_public_base_url)
        if staging_public_base_url is not None:
            pulumi.set(__self__, "staging_public_base_url", staging_public_base_url)

    @property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['ProductSpecDeploymentApicastSelfManagedAuthenticationArgs']]:
        """
        AuthenticationSpec defines the desired state of Product Authentication
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['ProductSpecDeploymentApicastSelfManagedAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @property
    @pulumi.getter(name="productionPublicBaseURL")
    def production_public_base_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "production_public_base_url")

    @production_public_base_url.setter
    def production_public_base_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "production_public_base_url", value)

    @property
    @pulumi.getter(name="stagingPublicBaseURL")
    def staging_public_base_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "staging_public_base_url")

    @staging_public_base_url.setter
    def staging_public_base_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "staging_public_base_url", value)


@pulumi.input_type
class ProductSpecDeploymentApicastSelfManagedAuthenticationArgs:
    def __init__(__self__, *,
                 app_key_app_id: Optional[pulumi.Input['ProductSpecDeploymentApicastSelfManagedAuthenticationAppKeyAppIDArgs']] = None,
                 userkey: Optional[pulumi.Input['ProductSpecDeploymentApicastSelfManagedAuthenticationUserkeyArgs']] = None):
        """
        AuthenticationSpec defines the desired state of Product Authentication
        :param pulumi.Input['ProductSpecDeploymentApicastSelfManagedAuthenticationAppKeyAppIDArgs'] app_key_app_id: AppKeyAppIDAuthenticationSpec defines the desired state of AppKey&AppId Authentication
        :param pulumi.Input['ProductSpecDeploymentApicastSelfManagedAuthenticationUserkeyArgs'] userkey: UserKeyAuthenticationSpec defines the desired state of User Key Authentication
        """
        if app_key_app_id is not None:
            pulumi.set(__self__, "app_key_app_id", app_key_app_id)
        if userkey is not None:
            pulumi.set(__self__, "userkey", userkey)

    @property
    @pulumi.getter(name="appKeyAppID")
    def app_key_app_id(self) -> Optional[pulumi.Input['ProductSpecDeploymentApicastSelfManagedAuthenticationAppKeyAppIDArgs']]:
        """
        AppKeyAppIDAuthenticationSpec defines the desired state of AppKey&AppId Authentication
        """
        return pulumi.get(self, "app_key_app_id")

    @app_key_app_id.setter
    def app_key_app_id(self, value: Optional[pulumi.Input['ProductSpecDeploymentApicastSelfManagedAuthenticationAppKeyAppIDArgs']]):
        pulumi.set(self, "app_key_app_id", value)

    @property
    @pulumi.getter
    def userkey(self) -> Optional[pulumi.Input['ProductSpecDeploymentApicastSelfManagedAuthenticationUserkeyArgs']]:
        """
        UserKeyAuthenticationSpec defines the desired state of User Key Authentication
        """
        return pulumi.get(self, "userkey")

    @userkey.setter
    def userkey(self, value: Optional[pulumi.Input['ProductSpecDeploymentApicastSelfManagedAuthenticationUserkeyArgs']]):
        pulumi.set(self, "userkey", value)


@pulumi.input_type
class ProductSpecDeploymentApicastSelfManagedAuthenticationAppKeyAppIDArgs:
    def __init__(__self__, *,
                 app_id: Optional[pulumi.Input[str]] = None,
                 app_key: Optional[pulumi.Input[str]] = None,
                 credentials: Optional[pulumi.Input[str]] = None,
                 security: Optional[pulumi.Input['ProductSpecDeploymentApicastSelfManagedAuthenticationAppKeyAppIDSecurityArgs']] = None):
        """
        AppKeyAppIDAuthenticationSpec defines the desired state of AppKey&AppId Authentication
        :param pulumi.Input[str] app_id: AppID is the name of the parameter that acts of behalf of app id
        :param pulumi.Input[str] app_key: AppKey is the name of the parameter that acts of behalf of app key
        :param pulumi.Input[str] credentials: CredentialsLoc available options: headers: As HTTP Headers query: As query parameters (GET) or body parameters (POST/PUT/DELETE) authorization: As HTTP Basic Authentication
        :param pulumi.Input['ProductSpecDeploymentApicastSelfManagedAuthenticationAppKeyAppIDSecurityArgs'] security: SecuritySpec defines the desired state of Authentication Security
        """
        if app_id is not None:
            pulumi.set(__self__, "app_id", app_id)
        if app_key is not None:
            pulumi.set(__self__, "app_key", app_key)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if security is not None:
            pulumi.set(__self__, "security", security)

    @property
    @pulumi.getter(name="appID")
    def app_id(self) -> Optional[pulumi.Input[str]]:
        """
        AppID is the name of the parameter that acts of behalf of app id
        """
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_id", value)

    @property
    @pulumi.getter(name="appKey")
    def app_key(self) -> Optional[pulumi.Input[str]]:
        """
        AppKey is the name of the parameter that acts of behalf of app key
        """
        return pulumi.get(self, "app_key")

    @app_key.setter
    def app_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_key", value)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input[str]]:
        """
        CredentialsLoc available options: headers: As HTTP Headers query: As query parameters (GET) or body parameters (POST/PUT/DELETE) authorization: As HTTP Basic Authentication
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter
    def security(self) -> Optional[pulumi.Input['ProductSpecDeploymentApicastSelfManagedAuthenticationAppKeyAppIDSecurityArgs']]:
        """
        SecuritySpec defines the desired state of Authentication Security
        """
        return pulumi.get(self, "security")

    @security.setter
    def security(self, value: Optional[pulumi.Input['ProductSpecDeploymentApicastSelfManagedAuthenticationAppKeyAppIDSecurityArgs']]):
        pulumi.set(self, "security", value)


@pulumi.input_type
class ProductSpecDeploymentApicastSelfManagedAuthenticationAppKeyAppIDSecurityArgs:
    def __init__(__self__, *,
                 host_header: Optional[pulumi.Input[str]] = None,
                 secret_token: Optional[pulumi.Input[str]] = None):
        """
        SecuritySpec defines the desired state of Authentication Security
        :param pulumi.Input[str] host_header: HostHeader Lets you define a custom Host request header. This is needed if your API backend only accepts traffic from a specific host.
        :param pulumi.Input[str] secret_token: SecretToken Enables you to block any direct developer requests to your API backend; each 3scale API gateway call to your API backend contains a request header called X-3scale-proxy-secret-token. The value of this header can be set by you here. It's up to you ensure your backend only allows calls with this secret header.
        """
        if host_header is not None:
            pulumi.set(__self__, "host_header", host_header)
        if secret_token is not None:
            pulumi.set(__self__, "secret_token", secret_token)

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> Optional[pulumi.Input[str]]:
        """
        HostHeader Lets you define a custom Host request header. This is needed if your API backend only accepts traffic from a specific host.
        """
        return pulumi.get(self, "host_header")

    @host_header.setter
    def host_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_header", value)

    @property
    @pulumi.getter(name="secretToken")
    def secret_token(self) -> Optional[pulumi.Input[str]]:
        """
        SecretToken Enables you to block any direct developer requests to your API backend; each 3scale API gateway call to your API backend contains a request header called X-3scale-proxy-secret-token. The value of this header can be set by you here. It's up to you ensure your backend only allows calls with this secret header.
        """
        return pulumi.get(self, "secret_token")

    @secret_token.setter
    def secret_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_token", value)


@pulumi.input_type
class ProductSpecDeploymentApicastSelfManagedAuthenticationUserkeyArgs:
    def __init__(__self__, *,
                 auth_user_key: Optional[pulumi.Input[str]] = None,
                 credentials: Optional[pulumi.Input[str]] = None,
                 security: Optional[pulumi.Input['ProductSpecDeploymentApicastSelfManagedAuthenticationUserkeySecurityArgs']] = None):
        """
        UserKeyAuthenticationSpec defines the desired state of User Key Authentication
        :param pulumi.Input[str] credentials: Credentials Location available options: headers: As HTTP Headers query: As query parameters (GET) or body parameters (POST/PUT/DELETE) authorization: As HTTP Basic Authentication
        :param pulumi.Input['ProductSpecDeploymentApicastSelfManagedAuthenticationUserkeySecurityArgs'] security: SecuritySpec defines the desired state of Authentication Security
        """
        if auth_user_key is not None:
            pulumi.set(__self__, "auth_user_key", auth_user_key)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if security is not None:
            pulumi.set(__self__, "security", security)

    @property
    @pulumi.getter(name="authUserKey")
    def auth_user_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "auth_user_key")

    @auth_user_key.setter
    def auth_user_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_user_key", value)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input[str]]:
        """
        Credentials Location available options: headers: As HTTP Headers query: As query parameters (GET) or body parameters (POST/PUT/DELETE) authorization: As HTTP Basic Authentication
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter
    def security(self) -> Optional[pulumi.Input['ProductSpecDeploymentApicastSelfManagedAuthenticationUserkeySecurityArgs']]:
        """
        SecuritySpec defines the desired state of Authentication Security
        """
        return pulumi.get(self, "security")

    @security.setter
    def security(self, value: Optional[pulumi.Input['ProductSpecDeploymentApicastSelfManagedAuthenticationUserkeySecurityArgs']]):
        pulumi.set(self, "security", value)


@pulumi.input_type
class ProductSpecDeploymentApicastSelfManagedAuthenticationUserkeySecurityArgs:
    def __init__(__self__, *,
                 host_header: Optional[pulumi.Input[str]] = None,
                 secret_token: Optional[pulumi.Input[str]] = None):
        """
        SecuritySpec defines the desired state of Authentication Security
        :param pulumi.Input[str] host_header: HostHeader Lets you define a custom Host request header. This is needed if your API backend only accepts traffic from a specific host.
        :param pulumi.Input[str] secret_token: SecretToken Enables you to block any direct developer requests to your API backend; each 3scale API gateway call to your API backend contains a request header called X-3scale-proxy-secret-token. The value of this header can be set by you here. It's up to you ensure your backend only allows calls with this secret header.
        """
        if host_header is not None:
            pulumi.set(__self__, "host_header", host_header)
        if secret_token is not None:
            pulumi.set(__self__, "secret_token", secret_token)

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> Optional[pulumi.Input[str]]:
        """
        HostHeader Lets you define a custom Host request header. This is needed if your API backend only accepts traffic from a specific host.
        """
        return pulumi.get(self, "host_header")

    @host_header.setter
    def host_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_header", value)

    @property
    @pulumi.getter(name="secretToken")
    def secret_token(self) -> Optional[pulumi.Input[str]]:
        """
        SecretToken Enables you to block any direct developer requests to your API backend; each 3scale API gateway call to your API backend contains a request header called X-3scale-proxy-secret-token. The value of this header can be set by you here. It's up to you ensure your backend only allows calls with this secret header.
        """
        return pulumi.get(self, "secret_token")

    @secret_token.setter
    def secret_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_token", value)


@pulumi.input_type
class ProductSpecMappingRulesArgs:
    def __init__(__self__, *,
                 http_method: pulumi.Input[str],
                 increment: pulumi.Input[int],
                 metric_method_ref: pulumi.Input[str],
                 pattern: pulumi.Input[str],
                 position: Optional[pulumi.Input[int]] = None):
        """
        MappingRuleSpec defines the desired state of Product's MappingRule
        """
        pulumi.set(__self__, "http_method", http_method)
        pulumi.set(__self__, "increment", increment)
        pulumi.set(__self__, "metric_method_ref", metric_method_ref)
        pulumi.set(__self__, "pattern", pattern)
        if position is not None:
            pulumi.set(__self__, "position", position)

    @property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> pulumi.Input[str]:
        return pulumi.get(self, "http_method")

    @http_method.setter
    def http_method(self, value: pulumi.Input[str]):
        pulumi.set(self, "http_method", value)

    @property
    @pulumi.getter
    def increment(self) -> pulumi.Input[int]:
        return pulumi.get(self, "increment")

    @increment.setter
    def increment(self, value: pulumi.Input[int]):
        pulumi.set(self, "increment", value)

    @property
    @pulumi.getter(name="metricMethodRef")
    def metric_method_ref(self) -> pulumi.Input[str]:
        return pulumi.get(self, "metric_method_ref")

    @metric_method_ref.setter
    def metric_method_ref(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_method_ref", value)

    @property
    @pulumi.getter
    def pattern(self) -> pulumi.Input[str]:
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: pulumi.Input[str]):
        pulumi.set(self, "pattern", value)

    @property
    @pulumi.getter
    def position(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "position")

    @position.setter
    def position(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "position", value)


@pulumi.input_type
class ProductSpecMethodsArgs:
    def __init__(__self__, *,
                 friendly_name: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        """
        MethodSpec defines the desired state of Product's Method
        """
        pulumi.set(__self__, "friendly_name", friendly_name)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter(name="friendlyName")
    def friendly_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "friendly_name")

    @friendly_name.setter
    def friendly_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "friendly_name", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


@pulumi.input_type
class ProductSpecMetricsArgs:
    def __init__(__self__, *,
                 friendly_name: pulumi.Input[str],
                 unit: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        """
        MetricSpec defines the desired state of Product's Metric
        """
        pulumi.set(__self__, "friendly_name", friendly_name)
        pulumi.set(__self__, "unit", unit)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter(name="friendlyName")
    def friendly_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "friendly_name")

    @friendly_name.setter
    def friendly_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "friendly_name", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input[str]:
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


@pulumi.input_type
class ProductSpecProviderAccountRefArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        ProviderAccountRef references account provider credentials
        :param pulumi.Input[str] name: Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class ProductStatusArgs:
    def __init__(__self__, *,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['ProductStatusConditionsArgs']]]] = None,
                 observed_generation: Optional[pulumi.Input[int]] = None,
                 product_id: Optional[pulumi.Input[int]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        ProductStatus defines the observed state of Product
        :param pulumi.Input[Sequence[pulumi.Input['ProductStatusConditionsArgs']]] conditions: Current state of the 3scale product. Conditions represent the latest available observations of an object's state
        :param pulumi.Input[int] observed_generation: ObservedGeneration reflects the generation of the most recently observed Product Spec.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if product_id is not None:
            pulumi.set(__self__, "product_id", product_id)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProductStatusConditionsArgs']]]]:
        """
        Current state of the 3scale product. Conditions represent the latest available observations of an object's state
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProductStatusConditionsArgs']]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[pulumi.Input[int]]:
        """
        ObservedGeneration reflects the generation of the most recently observed Product Spec.
        """
        return pulumi.get(self, "observed_generation")

    @observed_generation.setter
    def observed_generation(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "observed_generation", value)

    @property
    @pulumi.getter(name="productId")
    def product_id(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "product_id")

    @product_id.setter
    def product_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "product_id", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


@pulumi.input_type
class ProductStatusConditionsArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[str],
                 type: pulumi.Input[str],
                 last_transition_time: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None):
        """
        Condition represents an observation of an object's state. Conditions are an extension mechanism intended to be used when the details of an observation are not a priori known or would not apply to all instances of a given Kind. 
         Conditions should be added to explicitly convey properties that users and components care about rather than requiring those properties to be inferred from other observations. Once defined, the meaning of a Condition can not be changed arbitrarily - it becomes part of the API, and has the same backwards- and forwards-compatibility concerns of any other part of the API.
        :param pulumi.Input[str] type: ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
                Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        :param pulumi.Input[str] reason: ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        ConditionType is the type of the condition and is typically a CamelCased word or short phrase. 
         Condition types should indicate state in the "abnormal-true" polarity. For example, if the condition indicates when a policy is invalid, the "is valid" case is probably the norm, so the condition should be called "Invalid".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        ConditionReason is intended to be a one-word, CamelCase representation of the category of cause of the current status. It is intended to be used in concise output, such as one-line kubectl get output, and in summarizing occurrences of causes.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)


