// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

import {ObjectMeta} from "../meta/v1";

export namespace kafka {
    export namespace v1alpha1 {
        /**
         * The specification of the Kafka Bridge.
         */
        export interface KafkaBridgeSpec {
            /**
             * Authentication configuration for connecting to the cluster.
             */
            authentication?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecAuthentication>;
            /**
             * A list of host:port pairs for establishing the initial connection to the Kafka cluster.
             */
            bootstrapServers: pulumi.Input<string>;
            /**
             * Kafka consumer related configuration.
             */
            consumer?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecConsumer>;
            /**
             * Enable the metrics for the Kafka Bridge. Default is false.
             */
            enableMetrics?: pulumi.Input<boolean>;
            /**
             * The HTTP related configuration.
             */
            http?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecHttp>;
            /**
             * The docker image for the pods.
             */
            image?: pulumi.Input<string>;
            /**
             * **Currently not supported** JVM Options for pods.
             */
            jvmOptions?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecJvmOptions>;
            /**
             * Pod liveness checking.
             */
            livenessProbe?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecLivenessProbe>;
            /**
             * Logging configuration for Kafka Bridge.
             */
            logging?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecLogging>;
            /**
             * Kafka producer related configuration.
             */
            producer?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecProducer>;
            /**
             * Pod readiness checking.
             */
            readinessProbe?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecReadinessProbe>;
            /**
             * The number of pods in the `Deployment`.
             */
            replicas?: pulumi.Input<number>;
            /**
             * CPU and memory resources to reserve.
             */
            resources?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecResources>;
            /**
             * Template for Kafka Bridge resources. The template allows users to specify how is the `Deployment` and `Pods` generated.
             */
            template?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplate>;
            /**
             * TLS configuration for connecting Kafka Bridge to the cluster.
             */
            tls?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTls>;
            /**
             * The configuration of tracing in Kafka Bridge.
             */
            tracing?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTracing>;
        }

        /**
         * Authentication configuration for connecting to the cluster.
         */
        export interface KafkaBridgeSpecAuthentication {
            /**
             * Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
             */
            accessToken?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecAuthenticationAccessToken>;
            /**
             * Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
             */
            accessTokenIsJwt?: pulumi.Input<boolean>;
            /**
             * Reference to the `Secret` which holds the certificate and private key pair.
             */
            certificateAndKey?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecAuthenticationCertificateAndKey>;
            /**
             * OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
             */
            clientId?: pulumi.Input<string>;
            /**
             * Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
             */
            clientSecret?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecAuthenticationClientSecret>;
            /**
             * Enable or disable TLS hostname verification. Default value is `false`.
             */
            disableTlsHostnameVerification?: pulumi.Input<boolean>;
            /**
             * Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.
             */
            maxTokenExpirySeconds?: pulumi.Input<number>;
            /**
             * Reference to the `Secret` which holds the password.
             */
            passwordSecret?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecAuthenticationPasswordSecret>;
            /**
             * Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
             */
            refreshToken?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecAuthenticationRefreshToken>;
            /**
             * OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.
             */
            scope?: pulumi.Input<string>;
            /**
             * Trusted certificates for TLS connection to the OAuth server.
             */
            tlsTrustedCertificates?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecAuthenticationTlsTrustedCertificates>[]>;
            /**
             * Authorization server token endpoint URI.
             */
            tokenEndpointUri?: pulumi.Input<string>;
            /**
             * Authentication type. Currently the only supported types are `tls`, `scram-sha-512`, and `plain`. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
             */
            type: pulumi.Input<string>;
            /**
             * Username used for the authentication.
             */
            username?: pulumi.Input<string>;
        }

        /**
         * Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
         */
        export interface KafkaBridgeSpecAuthenticationAccessToken {
            /**
             * The key under which the secret value is stored in the Kubernetes Secret.
             */
            key: pulumi.Input<string>;
            /**
             * The name of the Kubernetes Secret containing the secret value.
             */
            secretName: pulumi.Input<string>;
        }

        /**
         * Reference to the `Secret` which holds the certificate and private key pair.
         */
        export interface KafkaBridgeSpecAuthenticationCertificateAndKey {
            /**
             * The name of the file certificate in the Secret.
             */
            certificate: pulumi.Input<string>;
            /**
             * The name of the private key in the Secret.
             */
            key: pulumi.Input<string>;
            /**
             * The name of the Secret containing the certificate.
             */
            secretName: pulumi.Input<string>;
        }

        /**
         * Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
         */
        export interface KafkaBridgeSpecAuthenticationClientSecret {
            /**
             * The key under which the secret value is stored in the Kubernetes Secret.
             */
            key: pulumi.Input<string>;
            /**
             * The name of the Kubernetes Secret containing the secret value.
             */
            secretName: pulumi.Input<string>;
        }

        /**
         * Reference to the `Secret` which holds the password.
         */
        export interface KafkaBridgeSpecAuthenticationPasswordSecret {
            /**
             * The name of the key in the Secret under which the password is stored.
             */
            password: pulumi.Input<string>;
            /**
             * The name of the Secret containing the password.
             */
            secretName: pulumi.Input<string>;
        }

        /**
         * Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
         */
        export interface KafkaBridgeSpecAuthenticationRefreshToken {
            /**
             * The key under which the secret value is stored in the Kubernetes Secret.
             */
            key: pulumi.Input<string>;
            /**
             * The name of the Kubernetes Secret containing the secret value.
             */
            secretName: pulumi.Input<string>;
        }

        export interface KafkaBridgeSpecAuthenticationTlsTrustedCertificates {
            /**
             * The name of the file certificate in the Secret.
             */
            certificate: pulumi.Input<string>;
            /**
             * The name of the Secret containing the certificate.
             */
            secretName: pulumi.Input<string>;
        }

        /**
         * Kafka consumer related configuration.
         */
        export interface KafkaBridgeSpecConsumer {
            /**
             * The Kafka consumer configuration used for consumer instances created by the bridge. Properties with the following prefixes cannot be set: ssl., bootstrap.servers, group.id, sasl., security. (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
             */
            config?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * The HTTP related configuration.
         */
        export interface KafkaBridgeSpecHttp {
            /**
             * CORS configuration for the HTTP Bridge.
             */
            cors?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecHttpCors>;
            /**
             * The port which is the server listening on.
             */
            port?: pulumi.Input<number>;
        }

        /**
         * CORS configuration for the HTTP Bridge.
         */
        export interface KafkaBridgeSpecHttpCors {
            /**
             * List of allowed HTTP methods.
             */
            allowedMethods: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * List of allowed origins. Java regular expressions can be used.
             */
            allowedOrigins: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * **Currently not supported** JVM Options for pods.
         */
        export interface KafkaBridgeSpecJvmOptions {
            /**
             * A map of -XX options to the JVM.
             */
            -XX?: pulumi.Input<{[key: string]: any}>;
            /**
             * -Xms option to to the JVM.
             */
            -Xms?: pulumi.Input<string>;
            /**
             * -Xmx option to to the JVM.
             */
            -Xmx?: pulumi.Input<string>;
            /**
             * Specifies whether the Garbage Collection logging is enabled. The default is false.
             */
            gcLoggingEnabled?: pulumi.Input<boolean>;
            /**
             * A map of additional system properties which will be passed using the `-D` option to the JVM.
             */
            javaSystemProperties?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecJvmOptionsJavaSystemProperties>[]>;
        }

        export interface KafkaBridgeSpecJvmOptionsJavaSystemProperties {
            /**
             * The system property name.
             */
            name?: pulumi.Input<string>;
            /**
             * The system property value.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * Pod liveness checking.
         */
        export interface KafkaBridgeSpecLivenessProbe {
            /**
             * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
             */
            failureThreshold?: pulumi.Input<number>;
            /**
             * The initial delay before first the health is first checked.
             */
            initialDelaySeconds?: pulumi.Input<number>;
            /**
             * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
             */
            successThreshold?: pulumi.Input<number>;
            /**
             * The timeout for each attempted health check.
             */
            timeoutSeconds?: pulumi.Input<number>;
        }

        /**
         * Logging configuration for Kafka Bridge.
         */
        export interface KafkaBridgeSpecLogging {
            /**
             * A Map from logger name to logger level.
             */
            loggers?: pulumi.Input<{[key: string]: any}>;
            /**
             * The name of the `ConfigMap` from which to get the logging configuration.
             */
            name?: pulumi.Input<string>;
            /**
             * Logging type, must be either 'inline' or 'external'.
             */
            type: pulumi.Input<string>;
        }

        /**
         * Kafka producer related configuration.
         */
        export interface KafkaBridgeSpecProducer {
            /**
             * The Kafka producer configuration used for producer instances created by the bridge. Properties with the following prefixes cannot be set: ssl., bootstrap.servers, sasl., security. (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
             */
            config?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Pod readiness checking.
         */
        export interface KafkaBridgeSpecReadinessProbe {
            /**
             * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
             */
            failureThreshold?: pulumi.Input<number>;
            /**
             * The initial delay before first the health is first checked.
             */
            initialDelaySeconds?: pulumi.Input<number>;
            /**
             * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
             */
            successThreshold?: pulumi.Input<number>;
            /**
             * The timeout for each attempted health check.
             */
            timeoutSeconds?: pulumi.Input<number>;
        }

        /**
         * CPU and memory resources to reserve.
         */
        export interface KafkaBridgeSpecResources {
            limits?: pulumi.Input<{[key: string]: any}>;
            requests?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Template for Kafka Bridge resources. The template allows users to specify how is the `Deployment` and `Pods` generated.
         */
        export interface KafkaBridgeSpecTemplate {
            /**
             * Template for Kafka Bridge API `Service`.
             */
            apiService?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplateApiService>;
            /**
             * Template for the Kafka Bridge container.
             */
            bridgeContainer?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplateBridgeContainer>;
            /**
             * Template for Kafka Bridge `Deployment`.
             */
            deployment?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplateDeployment>;
            /**
             * Template for Kafka Bridge `Pods`.
             */
            pod?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplatePod>;
            /**
             * Template for Kafka Bridge `PodDisruptionBudget`.
             */
            podDisruptionBudget?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplatePodDisruptionBudget>;
        }

        /**
         * Template for Kafka Bridge API `Service`.
         */
        export interface KafkaBridgeSpecTemplateApiService {
            /**
             * Metadata applied to the resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplateApiServiceMetadata>;
        }

        /**
         * Metadata applied to the resource.
         */
        export interface KafkaBridgeSpecTemplateApiServiceMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Template for the Kafka Bridge container.
         */
        export interface KafkaBridgeSpecTemplateBridgeContainer {
            /**
             * Environment variables which should be applied to the container.
             */
            env?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplateBridgeContainerEnv>[]>;
            /**
             * Security context for the container.
             */
            securityContext?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplateBridgeContainerSecurityContext>;
        }

        export interface KafkaBridgeSpecTemplateBridgeContainerEnv {
            /**
             * The environment variable key.
             */
            name?: pulumi.Input<string>;
            /**
             * The environment variable value.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * Security context for the container.
         */
        export interface KafkaBridgeSpecTemplateBridgeContainerSecurityContext {
            allowPrivilegeEscalation?: pulumi.Input<boolean>;
            capabilities?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplateBridgeContainerSecurityContextCapabilities>;
            privileged?: pulumi.Input<boolean>;
            procMount?: pulumi.Input<string>;
            readOnlyRootFilesystem?: pulumi.Input<boolean>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeLinuxOptions>;
            windowsOptions?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplateBridgeContainerSecurityContextWindowsOptions>;
        }

        export interface KafkaBridgeSpecTemplateBridgeContainerSecurityContextCapabilities {
            add?: pulumi.Input<pulumi.Input<string>[]>;
            drop?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface KafkaBridgeSpecTemplateBridgeContainerSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
        }

        /**
         * Template for Kafka Bridge `Deployment`.
         */
        export interface KafkaBridgeSpecTemplateDeployment {
            /**
             * Metadata applied to the resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplateDeploymentMetadata>;
        }

        /**
         * Metadata applied to the resource.
         */
        export interface KafkaBridgeSpecTemplateDeploymentMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Template for Kafka Bridge `Pods`.
         */
        export interface KafkaBridgeSpecTemplatePod {
            /**
             * The pod's affinity rules.
             */
            affinity?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplatePodAffinity>;
            /**
             * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
             */
            imagePullSecrets?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplatePodImagePullSecrets>[]>;
            /**
             * Metadata applied to the resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplatePodMetadata>;
            /**
             * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
             */
            priorityClassName?: pulumi.Input<string>;
            /**
             * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
             */
            schedulerName?: pulumi.Input<string>;
            /**
             * Configures pod-level security attributes and common container settings.
             */
            securityContext?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplatePodSecurityContext>;
            /**
             * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
             */
            terminationGracePeriodSeconds?: pulumi.Input<number>;
            /**
             * The pod's tolerations.
             */
            tolerations?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplatePodTolerations>[]>;
        }

        /**
         * The pod's affinity rules.
         */
        export interface KafkaBridgeSpecTemplatePodAffinity {
            nodeAffinity?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplatePodAffinityNodeAffinity>;
            podAffinity?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplatePodAffinityPodAffinity>;
            podAntiAffinity?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplatePodAffinityPodAntiAffinity>;
        }

        export interface KafkaBridgeSpecTemplatePodAffinityNodeAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>;
        }

        export interface KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>[]>;
        }

        export interface KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            nodeSelectorTerms?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>[]>;
        }

        export interface KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>[]>;
        }

        export interface KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaBridgeSpecTemplatePodAffinityPodAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaBridgeSpecTemplatePodAffinityPodAntiAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Template for Kafka Bridge `PodDisruptionBudget`.
         */
        export interface KafkaBridgeSpecTemplatePodDisruptionBudget {
            /**
             * Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
             */
            maxUnavailable?: pulumi.Input<number>;
            /**
             * Metadata to apply to the `PodDistruptionBugetTemplate` resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplatePodDisruptionBudgetMetadata>;
        }

        /**
         * Metadata to apply to the `PodDistruptionBugetTemplate` resource.
         */
        export interface KafkaBridgeSpecTemplatePodDisruptionBudgetMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaBridgeSpecTemplatePodImagePullSecrets {
            name?: pulumi.Input<string>;
        }

        /**
         * Metadata applied to the resource.
         */
        export interface KafkaBridgeSpecTemplatePodMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Configures pod-level security attributes and common container settings.
         */
        export interface KafkaBridgeSpecTemplatePodSecurityContext {
            fsGroup?: pulumi.Input<number>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplatePodSecurityContextSeLinuxOptions>;
            supplementalGroups?: pulumi.Input<pulumi.Input<number>[]>;
            sysctls?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplatePodSecurityContextSysctls>[]>;
            windowsOptions?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTemplatePodSecurityContextWindowsOptions>;
        }

        export interface KafkaBridgeSpecTemplatePodSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface KafkaBridgeSpecTemplatePodSecurityContextSysctls {
            name?: pulumi.Input<string>;
            value?: pulumi.Input<string>;
        }

        export interface KafkaBridgeSpecTemplatePodSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
        }

        export interface KafkaBridgeSpecTemplatePodTolerations {
            effect?: pulumi.Input<string>;
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            tolerationSeconds?: pulumi.Input<number>;
            value?: pulumi.Input<string>;
        }

        /**
         * TLS configuration for connecting Kafka Bridge to the cluster.
         */
        export interface KafkaBridgeSpecTls {
            /**
             * Trusted certificates for TLS connection.
             */
            trustedCertificates?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeSpecTlsTrustedCertificates>[]>;
        }

        export interface KafkaBridgeSpecTlsTrustedCertificates {
            /**
             * The name of the file certificate in the Secret.
             */
            certificate: pulumi.Input<string>;
            /**
             * The name of the Secret containing the certificate.
             */
            secretName: pulumi.Input<string>;
        }

        /**
         * The configuration of tracing in Kafka Bridge.
         */
        export interface KafkaBridgeSpecTracing {
            /**
             * Type of the tracing used. Currently the only supported type is `jaeger` for Jaeger tracing.
             */
            type: pulumi.Input<string>;
        }

        /**
         * The status of the Kafka Bridge.
         */
        export interface KafkaBridgeStatus {
            /**
             * List of status conditions.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeStatusConditions>[]>;
            /**
             * The generation of the CRD that was last reconciled by the operator.
             */
            observedGeneration?: pulumi.Input<number>;
            /**
             * Label selector for pods providing this resource.
             */
            podSelector?: pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeStatusPodSelector>;
            /**
             * The current number of pods being used to provide this resource.
             */
            replicas?: pulumi.Input<number>;
            /**
             * The URL at which external client applications can access the Kafka Bridge.
             */
            url?: pulumi.Input<string>;
        }

        export interface KafkaBridgeStatusConditions {
            /**
             * Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
             */
            lastTransitionTime?: pulumi.Input<string>;
            /**
             * Human-readable message indicating details about the condition's last transition.
             */
            message?: pulumi.Input<string>;
            /**
             * The reason for the condition's last transition (a single word in CamelCase).
             */
            reason?: pulumi.Input<string>;
            /**
             * The status of the condition, either True, False or Unknown.
             */
            status?: pulumi.Input<string>;
            /**
             * The unique identifier of a condition, used to distinguish between other conditions in the resource.
             */
            type?: pulumi.Input<string>;
        }

        /**
         * Label selector for pods providing this resource.
         */
        export interface KafkaBridgeStatusPodSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaBridgeStatusPodSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaBridgeStatusPodSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * The specification of the Kafka Connector.
         */
        export interface KafkaConnectorSpec {
            /**
             * The Class for the Kafka Connector.
             */
            class?: pulumi.Input<string>;
            /**
             * The Kafka Connector configuration. The following properties cannot be set: connector.class, tasks.max.
             */
            config?: pulumi.Input<{[key: string]: any}>;
            /**
             * Whether the connector should be paused. Defaults to false.
             */
            pause?: pulumi.Input<boolean>;
            /**
             * The maximum number of tasks for the Kafka Connector.
             */
            tasksMax?: pulumi.Input<number>;
        }

        /**
         * The status of the Kafka Connector.
         */
        export interface KafkaConnectorStatus {
            /**
             * List of status conditions.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaConnectorStatusConditions>[]>;
            /**
             * The connector status, as reported by the Kafka Connect REST API.
             */
            connectorStatus?: pulumi.Input<{[key: string]: any}>;
            /**
             * The generation of the CRD that was last reconciled by the operator.
             */
            observedGeneration?: pulumi.Input<number>;
            /**
             * The maximum number of tasks for the Kafka Connector.
             */
            tasksMax?: pulumi.Input<number>;
        }

        export interface KafkaConnectorStatusConditions {
            /**
             * Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
             */
            lastTransitionTime?: pulumi.Input<string>;
            /**
             * Human-readable message indicating details about the condition's last transition.
             */
            message?: pulumi.Input<string>;
            /**
             * The reason for the condition's last transition (a single word in CamelCase).
             */
            reason?: pulumi.Input<string>;
            /**
             * The status of the condition, either True, False or Unknown.
             */
            status?: pulumi.Input<string>;
            /**
             * The unique identifier of a condition, used to distinguish between other conditions in the resource.
             */
            type?: pulumi.Input<string>;
        }

        /**
         * The specification of the Kafka MirrorMaker 2.0 cluster.
         */
        export interface KafkaMirrorMaker2Spec {
            /**
             * The pod's affinity rules.
             */
            affinity?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecAffinity>;
            /**
             * Kafka clusters for mirroring.
             */
            clusters?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecClusters>[]>;
            /**
             * The cluster alias used for Kafka Connect. The alias must match a cluster in the list at `spec.clusters`.
             */
            connectCluster: pulumi.Input<string>;
            /**
             * Pass data from Secrets or ConfigMaps to the Kafka Connect pods and use them to configure connectors.
             */
            externalConfiguration?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecExternalConfiguration>;
            /**
             * The docker image for the pods.
             */
            image?: pulumi.Input<string>;
            /**
             * JVM Options for pods.
             */
            jvmOptions?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecJvmOptions>;
            /**
             * Pod liveness checking.
             */
            livenessProbe?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecLivenessProbe>;
            /**
             * Logging configuration for Kafka Connect.
             */
            logging?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecLogging>;
            /**
             * The Prometheus JMX Exporter configuration. See https://github.com/prometheus/jmx_exporter for details of the structure of this configuration.
             */
            metrics?: pulumi.Input<{[key: string]: any}>;
            /**
             * Configuration of the MirrorMaker 2.0 connectors.
             */
            mirrors?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecMirrors>[]>;
            /**
             * Pod readiness checking.
             */
            readinessProbe?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecReadinessProbe>;
            /**
             * The number of pods in the Kafka Connect group.
             */
            replicas?: pulumi.Input<number>;
            /**
             * The maximum limits for CPU and memory resources and the requested initial resources.
             */
            resources?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecResources>;
            /**
             * Template for Kafka Connect and Kafka Connect S2I resources. The template allows users to specify how the `Deployment`, `Pods` and `Service` are generated.
             */
            template?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplate>;
            /**
             * The pod's tolerations.
             */
            tolerations?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTolerations>[]>;
            /**
             * The configuration of tracing in Kafka Connect.
             */
            tracing?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTracing>;
            /**
             * The Kafka Connect version. Defaults to {DefaultKafkaVersion}. Consult the user documentation to understand the process required to upgrade or downgrade the version.
             */
            version?: pulumi.Input<string>;
        }

        /**
         * The pod's affinity rules.
         */
        export interface KafkaMirrorMaker2SpecAffinity {
            nodeAffinity?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecAffinityNodeAffinity>;
            podAffinity?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecAffinityPodAffinity>;
            podAntiAffinity?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecAffinityPodAntiAffinity>;
        }

        export interface KafkaMirrorMaker2SpecAffinityNodeAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>;
        }

        export interface KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>[]>;
        }

        export interface KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            nodeSelectorTerms?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>[]>;
        }

        export interface KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>[]>;
        }

        export interface KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaMirrorMaker2SpecAffinityPodAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaMirrorMaker2SpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaMirrorMaker2SpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaMirrorMaker2SpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaMirrorMaker2SpecAffinityPodAntiAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaMirrorMaker2SpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaMirrorMaker2SpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaMirrorMaker2SpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaMirrorMaker2SpecClusters {
            /**
             * Alias used to reference the Kafka cluster.
             */
            alias: pulumi.Input<string>;
            /**
             * Authentication configuration for connecting to the cluster.
             */
            authentication?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecClustersAuthentication>;
            /**
             * A comma-separated list of `host:port` pairs for establishing the connection to the Kafka cluster.
             */
            bootstrapServers: pulumi.Input<string>;
            /**
             * The MirrorMaker 2.0 cluster config. Properties with the following prefixes cannot be set: ssl., sasl., security., listeners, plugin.path, rest., bootstrap.servers, consumer.interceptor.classes, producer.interceptor.classes (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
             */
            config?: pulumi.Input<{[key: string]: any}>;
            /**
             * TLS configuration for connecting MirrorMaker 2.0 connectors to a cluster.
             */
            tls?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecClustersTls>;
        }

        /**
         * Authentication configuration for connecting to the cluster.
         */
        export interface KafkaMirrorMaker2SpecClustersAuthentication {
            /**
             * Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
             */
            accessToken?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecClustersAuthenticationAccessToken>;
            /**
             * Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
             */
            accessTokenIsJwt?: pulumi.Input<boolean>;
            /**
             * Reference to the `Secret` which holds the certificate and private key pair.
             */
            certificateAndKey?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecClustersAuthenticationCertificateAndKey>;
            /**
             * OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
             */
            clientId?: pulumi.Input<string>;
            /**
             * Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
             */
            clientSecret?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecClustersAuthenticationClientSecret>;
            /**
             * Enable or disable TLS hostname verification. Default value is `false`.
             */
            disableTlsHostnameVerification?: pulumi.Input<boolean>;
            /**
             * Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.
             */
            maxTokenExpirySeconds?: pulumi.Input<number>;
            /**
             * Reference to the `Secret` which holds the password.
             */
            passwordSecret?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecClustersAuthenticationPasswordSecret>;
            /**
             * Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
             */
            refreshToken?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecClustersAuthenticationRefreshToken>;
            /**
             * OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.
             */
            scope?: pulumi.Input<string>;
            /**
             * Trusted certificates for TLS connection to the OAuth server.
             */
            tlsTrustedCertificates?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecClustersAuthenticationTlsTrustedCertificates>[]>;
            /**
             * Authorization server token endpoint URI.
             */
            tokenEndpointUri?: pulumi.Input<string>;
            /**
             * Authentication type. Currently the only supported types are `tls`, `scram-sha-512`, and `plain`. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
             */
            type: pulumi.Input<string>;
            /**
             * Username used for the authentication.
             */
            username?: pulumi.Input<string>;
        }

        /**
         * Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
         */
        export interface KafkaMirrorMaker2SpecClustersAuthenticationAccessToken {
            /**
             * The key under which the secret value is stored in the Kubernetes Secret.
             */
            key: pulumi.Input<string>;
            /**
             * The name of the Kubernetes Secret containing the secret value.
             */
            secretName: pulumi.Input<string>;
        }

        /**
         * Reference to the `Secret` which holds the certificate and private key pair.
         */
        export interface KafkaMirrorMaker2SpecClustersAuthenticationCertificateAndKey {
            /**
             * The name of the file certificate in the Secret.
             */
            certificate: pulumi.Input<string>;
            /**
             * The name of the private key in the Secret.
             */
            key: pulumi.Input<string>;
            /**
             * The name of the Secret containing the certificate.
             */
            secretName: pulumi.Input<string>;
        }

        /**
         * Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
         */
        export interface KafkaMirrorMaker2SpecClustersAuthenticationClientSecret {
            /**
             * The key under which the secret value is stored in the Kubernetes Secret.
             */
            key: pulumi.Input<string>;
            /**
             * The name of the Kubernetes Secret containing the secret value.
             */
            secretName: pulumi.Input<string>;
        }

        /**
         * Reference to the `Secret` which holds the password.
         */
        export interface KafkaMirrorMaker2SpecClustersAuthenticationPasswordSecret {
            /**
             * The name of the key in the Secret under which the password is stored.
             */
            password: pulumi.Input<string>;
            /**
             * The name of the Secret containing the password.
             */
            secretName: pulumi.Input<string>;
        }

        /**
         * Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
         */
        export interface KafkaMirrorMaker2SpecClustersAuthenticationRefreshToken {
            /**
             * The key under which the secret value is stored in the Kubernetes Secret.
             */
            key: pulumi.Input<string>;
            /**
             * The name of the Kubernetes Secret containing the secret value.
             */
            secretName: pulumi.Input<string>;
        }

        export interface KafkaMirrorMaker2SpecClustersAuthenticationTlsTrustedCertificates {
            /**
             * The name of the file certificate in the Secret.
             */
            certificate: pulumi.Input<string>;
            /**
             * The name of the Secret containing the certificate.
             */
            secretName: pulumi.Input<string>;
        }

        /**
         * TLS configuration for connecting MirrorMaker 2.0 connectors to a cluster.
         */
        export interface KafkaMirrorMaker2SpecClustersTls {
            /**
             * Trusted certificates for TLS connection.
             */
            trustedCertificates?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecClustersTlsTrustedCertificates>[]>;
        }

        export interface KafkaMirrorMaker2SpecClustersTlsTrustedCertificates {
            /**
             * The name of the file certificate in the Secret.
             */
            certificate: pulumi.Input<string>;
            /**
             * The name of the Secret containing the certificate.
             */
            secretName: pulumi.Input<string>;
        }

        /**
         * Pass data from Secrets or ConfigMaps to the Kafka Connect pods and use them to configure connectors.
         */
        export interface KafkaMirrorMaker2SpecExternalConfiguration {
            /**
             * Allows to pass data from Secret or ConfigMap to the Kafka Connect pods as environment variables.
             */
            env?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecExternalConfigurationEnv>[]>;
            /**
             * Allows to pass data from Secret or ConfigMap to the Kafka Connect pods as volumes.
             */
            volumes?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecExternalConfigurationVolumes>[]>;
        }

        export interface KafkaMirrorMaker2SpecExternalConfigurationEnv {
            /**
             * Name of the environment variable which will be passed to the Kafka Connect pods. The name of the environment variable cannot start with `KAFKA_` or `STRIMZI_`.
             */
            name: pulumi.Input<string>;
            /**
             * Value of the environment variable which will be passed to the Kafka Connect pods. It can be passed either as a reference to Secret or ConfigMap field. The field has to specify exactly one Secret or ConfigMap.
             */
            valueFrom: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecExternalConfigurationEnvValueFrom>;
        }

        /**
         * Value of the environment variable which will be passed to the Kafka Connect pods. It can be passed either as a reference to Secret or ConfigMap field. The field has to specify exactly one Secret or ConfigMap.
         */
        export interface KafkaMirrorMaker2SpecExternalConfigurationEnvValueFrom {
            /**
             * Refernce to a key in a ConfigMap.
             */
            configMapKeyRef?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromConfigMapKeyRef>;
            /**
             * Reference to a key in a Secret.
             */
            secretKeyRef?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromSecretKeyRef>;
        }

        /**
         * Refernce to a key in a ConfigMap.
         */
        export interface KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromConfigMapKeyRef {
            key?: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        /**
         * Reference to a key in a Secret.
         */
        export interface KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromSecretKeyRef {
            key?: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface KafkaMirrorMaker2SpecExternalConfigurationVolumes {
            /**
             * Reference to a key in a ConfigMap. Exactly one Secret or ConfigMap has to be specified.
             */
            configMap?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMap>;
            /**
             * Name of the volume which will be added to the Kafka Connect pods.
             */
            name: pulumi.Input<string>;
            /**
             * Reference to a key in a Secret. Exactly one Secret or ConfigMap has to be specified.
             */
            secret?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecExternalConfigurationVolumesSecret>;
        }

        /**
         * Reference to a key in a ConfigMap. Exactly one Secret or ConfigMap has to be specified.
         */
        export interface KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMap {
            defaultMode?: pulumi.Input<number>;
            items?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMapItems>[]>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMapItems {
            key?: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path?: pulumi.Input<string>;
        }

        /**
         * Reference to a key in a Secret. Exactly one Secret or ConfigMap has to be specified.
         */
        export interface KafkaMirrorMaker2SpecExternalConfigurationVolumesSecret {
            defaultMode?: pulumi.Input<number>;
            items?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecExternalConfigurationVolumesSecretItems>[]>;
            optional?: pulumi.Input<boolean>;
            secretName?: pulumi.Input<string>;
        }

        export interface KafkaMirrorMaker2SpecExternalConfigurationVolumesSecretItems {
            key?: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path?: pulumi.Input<string>;
        }

        /**
         * JVM Options for pods.
         */
        export interface KafkaMirrorMaker2SpecJvmOptions {
            /**
             * A map of -XX options to the JVM.
             */
            -XX?: pulumi.Input<{[key: string]: any}>;
            /**
             * -Xms option to to the JVM.
             */
            -Xms?: pulumi.Input<string>;
            /**
             * -Xmx option to to the JVM.
             */
            -Xmx?: pulumi.Input<string>;
            /**
             * Specifies whether the Garbage Collection logging is enabled. The default is false.
             */
            gcLoggingEnabled?: pulumi.Input<boolean>;
            /**
             * A map of additional system properties which will be passed using the `-D` option to the JVM.
             */
            javaSystemProperties?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecJvmOptionsJavaSystemProperties>[]>;
        }

        export interface KafkaMirrorMaker2SpecJvmOptionsJavaSystemProperties {
            /**
             * The system property name.
             */
            name?: pulumi.Input<string>;
            /**
             * The system property value.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * Pod liveness checking.
         */
        export interface KafkaMirrorMaker2SpecLivenessProbe {
            /**
             * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
             */
            failureThreshold?: pulumi.Input<number>;
            /**
             * The initial delay before first the health is first checked.
             */
            initialDelaySeconds?: pulumi.Input<number>;
            /**
             * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
             */
            successThreshold?: pulumi.Input<number>;
            /**
             * The timeout for each attempted health check.
             */
            timeoutSeconds?: pulumi.Input<number>;
        }

        /**
         * Logging configuration for Kafka Connect.
         */
        export interface KafkaMirrorMaker2SpecLogging {
            /**
             * A Map from logger name to logger level.
             */
            loggers?: pulumi.Input<{[key: string]: any}>;
            /**
             * The name of the `ConfigMap` from which to get the logging configuration.
             */
            name?: pulumi.Input<string>;
            /**
             * Logging type, must be either 'inline' or 'external'.
             */
            type: pulumi.Input<string>;
        }

        export interface KafkaMirrorMaker2SpecMirrors {
            /**
             * The specification of the Kafka MirrorMaker 2.0 checkpoint connector.
             */
            checkpointConnector?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecMirrorsCheckpointConnector>;
            /**
             * A regular expression matching the consumer groups to exclude from mirroring. Comma-separated lists are also supported.
             */
            groupsBlacklistPattern?: pulumi.Input<string>;
            /**
             * A regular expression matching the consumer groups to be mirrored. Comma-separated lists are also supported.
             */
            groupsPattern?: pulumi.Input<string>;
            /**
             * The specification of the Kafka MirrorMaker 2.0 heartbeat connector.
             */
            heartbeatConnector?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecMirrorsHeartbeatConnector>;
            /**
             * The alias of the source cluster used by the Kafka MirrorMaker 2.0 connectors. The alias must match a cluster in the list at `spec.clusters`.
             */
            sourceCluster: pulumi.Input<string>;
            /**
             * The specification of the Kafka MirrorMaker 2.0 source connector.
             */
            sourceConnector?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecMirrorsSourceConnector>;
            /**
             * The alias of the target cluster used by the Kafka MirrorMaker 2.0 connectors. The alias must match a cluster in the list at `spec.clusters`.
             */
            targetCluster: pulumi.Input<string>;
            /**
             * A regular expression matching the topics to exclude from mirroring. Comma-separated lists are also supported.
             */
            topicsBlacklistPattern?: pulumi.Input<string>;
            /**
             * A regular expression matching the topics to be mirrored, for example, "topic1\|topic2\|topic3". Comma-separated lists are also supported.
             */
            topicsPattern?: pulumi.Input<string>;
        }

        /**
         * The specification of the Kafka MirrorMaker 2.0 checkpoint connector.
         */
        export interface KafkaMirrorMaker2SpecMirrorsCheckpointConnector {
            /**
             * The Kafka Connector configuration. The following properties cannot be set: connector.class, tasks.max.
             */
            config?: pulumi.Input<{[key: string]: any}>;
            /**
             * Whether the connector should be paused. Defaults to false.
             */
            pause?: pulumi.Input<boolean>;
            /**
             * The maximum number of tasks for the Kafka Connector.
             */
            tasksMax?: pulumi.Input<number>;
        }

        /**
         * The specification of the Kafka MirrorMaker 2.0 heartbeat connector.
         */
        export interface KafkaMirrorMaker2SpecMirrorsHeartbeatConnector {
            /**
             * The Kafka Connector configuration. The following properties cannot be set: connector.class, tasks.max.
             */
            config?: pulumi.Input<{[key: string]: any}>;
            /**
             * Whether the connector should be paused. Defaults to false.
             */
            pause?: pulumi.Input<boolean>;
            /**
             * The maximum number of tasks for the Kafka Connector.
             */
            tasksMax?: pulumi.Input<number>;
        }

        /**
         * The specification of the Kafka MirrorMaker 2.0 source connector.
         */
        export interface KafkaMirrorMaker2SpecMirrorsSourceConnector {
            /**
             * The Kafka Connector configuration. The following properties cannot be set: connector.class, tasks.max.
             */
            config?: pulumi.Input<{[key: string]: any}>;
            /**
             * Whether the connector should be paused. Defaults to false.
             */
            pause?: pulumi.Input<boolean>;
            /**
             * The maximum number of tasks for the Kafka Connector.
             */
            tasksMax?: pulumi.Input<number>;
        }

        /**
         * Pod readiness checking.
         */
        export interface KafkaMirrorMaker2SpecReadinessProbe {
            /**
             * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
             */
            failureThreshold?: pulumi.Input<number>;
            /**
             * The initial delay before first the health is first checked.
             */
            initialDelaySeconds?: pulumi.Input<number>;
            /**
             * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
             */
            successThreshold?: pulumi.Input<number>;
            /**
             * The timeout for each attempted health check.
             */
            timeoutSeconds?: pulumi.Input<number>;
        }

        /**
         * The maximum limits for CPU and memory resources and the requested initial resources.
         */
        export interface KafkaMirrorMaker2SpecResources {
            limits?: pulumi.Input<{[key: string]: any}>;
            requests?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Template for Kafka Connect and Kafka Connect S2I resources. The template allows users to specify how the `Deployment`, `Pods` and `Service` are generated.
         */
        export interface KafkaMirrorMaker2SpecTemplate {
            /**
             * Template for Kafka Connect API `Service`.
             */
            apiService?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplateApiService>;
            /**
             * Template for the Kafka Connect container.
             */
            connectContainer?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplateConnectContainer>;
            /**
             * Template for Kafka Connect `Deployment`.
             */
            deployment?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplateDeployment>;
            /**
             * Template for Kafka Connect `Pods`.
             */
            pod?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplatePod>;
            /**
             * Template for Kafka Connect `PodDisruptionBudget`.
             */
            podDisruptionBudget?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplatePodDisruptionBudget>;
        }

        /**
         * Template for Kafka Connect API `Service`.
         */
        export interface KafkaMirrorMaker2SpecTemplateApiService {
            /**
             * Metadata applied to the resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplateApiServiceMetadata>;
        }

        /**
         * Metadata applied to the resource.
         */
        export interface KafkaMirrorMaker2SpecTemplateApiServiceMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Template for the Kafka Connect container.
         */
        export interface KafkaMirrorMaker2SpecTemplateConnectContainer {
            /**
             * Environment variables which should be applied to the container.
             */
            env?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplateConnectContainerEnv>[]>;
            /**
             * Security context for the container.
             */
            securityContext?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContext>;
        }

        export interface KafkaMirrorMaker2SpecTemplateConnectContainerEnv {
            /**
             * The environment variable key.
             */
            name?: pulumi.Input<string>;
            /**
             * The environment variable value.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * Security context for the container.
         */
        export interface KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContext {
            allowPrivilegeEscalation?: pulumi.Input<boolean>;
            capabilities?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextCapabilities>;
            privileged?: pulumi.Input<boolean>;
            procMount?: pulumi.Input<string>;
            readOnlyRootFilesystem?: pulumi.Input<boolean>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextSeLinuxOptions>;
            windowsOptions?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextWindowsOptions>;
        }

        export interface KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextCapabilities {
            add?: pulumi.Input<pulumi.Input<string>[]>;
            drop?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
        }

        /**
         * Template for Kafka Connect `Deployment`.
         */
        export interface KafkaMirrorMaker2SpecTemplateDeployment {
            /**
             * Metadata applied to the resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplateDeploymentMetadata>;
        }

        /**
         * Metadata applied to the resource.
         */
        export interface KafkaMirrorMaker2SpecTemplateDeploymentMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Template for Kafka Connect `Pods`.
         */
        export interface KafkaMirrorMaker2SpecTemplatePod {
            /**
             * The pod's affinity rules.
             */
            affinity?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplatePodAffinity>;
            /**
             * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
             */
            imagePullSecrets?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplatePodImagePullSecrets>[]>;
            /**
             * Metadata applied to the resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplatePodMetadata>;
            /**
             * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
             */
            priorityClassName?: pulumi.Input<string>;
            /**
             * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
             */
            schedulerName?: pulumi.Input<string>;
            /**
             * Configures pod-level security attributes and common container settings.
             */
            securityContext?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplatePodSecurityContext>;
            /**
             * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
             */
            terminationGracePeriodSeconds?: pulumi.Input<number>;
            /**
             * The pod's tolerations.
             */
            tolerations?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplatePodTolerations>[]>;
        }

        /**
         * The pod's affinity rules.
         */
        export interface KafkaMirrorMaker2SpecTemplatePodAffinity {
            nodeAffinity?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinity>;
            podAffinity?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinity>;
            podAntiAffinity?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinity>;
        }

        export interface KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>;
        }

        export interface KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>[]>;
        }

        export interface KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            nodeSelectorTerms?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>[]>;
        }

        export interface KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>[]>;
        }

        export interface KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Template for Kafka Connect `PodDisruptionBudget`.
         */
        export interface KafkaMirrorMaker2SpecTemplatePodDisruptionBudget {
            /**
             * Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
             */
            maxUnavailable?: pulumi.Input<number>;
            /**
             * Metadata to apply to the `PodDistruptionBugetTemplate` resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplatePodDisruptionBudgetMetadata>;
        }

        /**
         * Metadata to apply to the `PodDistruptionBugetTemplate` resource.
         */
        export interface KafkaMirrorMaker2SpecTemplatePodDisruptionBudgetMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaMirrorMaker2SpecTemplatePodImagePullSecrets {
            name?: pulumi.Input<string>;
        }

        /**
         * Metadata applied to the resource.
         */
        export interface KafkaMirrorMaker2SpecTemplatePodMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Configures pod-level security attributes and common container settings.
         */
        export interface KafkaMirrorMaker2SpecTemplatePodSecurityContext {
            fsGroup?: pulumi.Input<number>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplatePodSecurityContextSeLinuxOptions>;
            supplementalGroups?: pulumi.Input<pulumi.Input<number>[]>;
            sysctls?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplatePodSecurityContextSysctls>[]>;
            windowsOptions?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2SpecTemplatePodSecurityContextWindowsOptions>;
        }

        export interface KafkaMirrorMaker2SpecTemplatePodSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface KafkaMirrorMaker2SpecTemplatePodSecurityContextSysctls {
            name?: pulumi.Input<string>;
            value?: pulumi.Input<string>;
        }

        export interface KafkaMirrorMaker2SpecTemplatePodSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
        }

        export interface KafkaMirrorMaker2SpecTemplatePodTolerations {
            effect?: pulumi.Input<string>;
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            tolerationSeconds?: pulumi.Input<number>;
            value?: pulumi.Input<string>;
        }

        export interface KafkaMirrorMaker2SpecTolerations {
            effect?: pulumi.Input<string>;
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            tolerationSeconds?: pulumi.Input<number>;
            value?: pulumi.Input<string>;
        }

        /**
         * The configuration of tracing in Kafka Connect.
         */
        export interface KafkaMirrorMaker2SpecTracing {
            /**
             * Type of the tracing used. Currently the only supported type is `jaeger` for Jaeger tracing.
             */
            type: pulumi.Input<string>;
        }

        /**
         * The status of the Kafka MirrorMaker 2.0 cluster.
         */
        export interface KafkaMirrorMaker2Status {
            /**
             * List of status conditions.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2StatusConditions>[]>;
            /**
             * The list of connector plugins available in this Kafka Connect deployment.
             */
            connectorPlugins?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2StatusConnectorPlugins>[]>;
            /**
             * List of MirrorMaker 2.0 connector statuses, as reported by the Kafka Connect REST API.
             */
            connectors?: pulumi.Input<pulumi.Input<{[key: string]: any}>[]>;
            /**
             * The generation of the CRD that was last reconciled by the operator.
             */
            observedGeneration?: pulumi.Input<number>;
            /**
             * Label selector for pods providing this resource.
             */
            podSelector?: pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2StatusPodSelector>;
            /**
             * The current number of pods being used to provide this resource.
             */
            replicas?: pulumi.Input<number>;
            /**
             * The URL of the REST API endpoint for managing and monitoring Kafka Connect connectors.
             */
            url?: pulumi.Input<string>;
        }

        export interface KafkaMirrorMaker2StatusConditions {
            /**
             * Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
             */
            lastTransitionTime?: pulumi.Input<string>;
            /**
             * Human-readable message indicating details about the condition's last transition.
             */
            message?: pulumi.Input<string>;
            /**
             * The reason for the condition's last transition (a single word in CamelCase).
             */
            reason?: pulumi.Input<string>;
            /**
             * The status of the condition, either True, False or Unknown.
             */
            status?: pulumi.Input<string>;
            /**
             * The unique identifier of a condition, used to distinguish between other conditions in the resource.
             */
            type?: pulumi.Input<string>;
        }

        export interface KafkaMirrorMaker2StatusConnectorPlugins {
            /**
             * The class of the connector plugin.
             */
            class?: pulumi.Input<string>;
            /**
             * The type of the connector plugin. The available types are `sink` and `source`.
             */
            type?: pulumi.Input<string>;
            /**
             * The version of the connector plugin.
             */
            version?: pulumi.Input<string>;
        }

        /**
         * Label selector for pods providing this resource.
         */
        export interface KafkaMirrorMaker2StatusPodSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaMirrorMaker2StatusPodSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaMirrorMaker2StatusPodSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * The specification of the Kafka rebalance.
         */
        export interface KafkaRebalanceSpec {
            /**
             * The upper bound of ongoing partition replica movements between disks within each broker. Default is 2.
             */
            concurrentIntraBrokerPartitionMovements?: pulumi.Input<number>;
            /**
             * The upper bound of ongoing partition leadership movements. Default is 1000.
             */
            concurrentLeaderMovements?: pulumi.Input<number>;
            /**
             * The upper bound of ongoing partition replica movements going into/out of each broker. Default is 5.
             */
            concurrentPartitionMovementsPerBroker?: pulumi.Input<number>;
            /**
             * A regular expression where any matching topics will be excluded from the calculation of optimization proposals. This expression will be parsed by the java.util.regex.Pattern class; for more information on the supported formar consult the documentation for that class.
             */
            excludedTopics?: pulumi.Input<string>;
            /**
             * A list of goals, ordered by decreasing priority, to use for generating and executing the rebalance proposal. The supported goals are available at https://github.com/linkedin/cruise-control#goals. If an empty goals list is provided, the goals declared in the default.goals Cruise Control configuration parameter are used.
             */
            goals?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * The upper bound, in bytes per second, on the bandwidth used to move replicas. There is no limit by default.
             */
            replicationThrottle?: pulumi.Input<number>;
            /**
             * Whether to allow the hard goals specified in the Kafka CR to be skipped in optimization proposal generation. This can be useful when some of those hard goals are preventing a balance solution being found. Default is false.
             */
            skipHardGoalCheck?: pulumi.Input<boolean>;
        }

        /**
         * The status of the Kafka rebalance.
         */
        export interface KafkaRebalanceStatus {
            /**
             * List of status conditions.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.kafka.v1alpha1.KafkaRebalanceStatusConditions>[]>;
            /**
             * The generation of the CRD that was last reconciled by the operator.
             */
            observedGeneration?: pulumi.Input<number>;
            /**
             * A JSON object describing the optimization result.
             */
            optimizationResult?: pulumi.Input<{[key: string]: any}>;
            /**
             * The session identifier for requests to Cruise Control pertaining to this KafkaRebalance resource. This is used by the Kafka Rebalance operator to track the status of ongoing rebalancing operations.
             */
            sessionId?: pulumi.Input<string>;
        }

        export interface KafkaRebalanceStatusConditions {
            /**
             * Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
             */
            lastTransitionTime?: pulumi.Input<string>;
            /**
             * Human-readable message indicating details about the condition's last transition.
             */
            message?: pulumi.Input<string>;
            /**
             * The reason for the condition's last transition (a single word in CamelCase).
             */
            reason?: pulumi.Input<string>;
            /**
             * The status of the condition, either True, False or Unknown.
             */
            status?: pulumi.Input<string>;
            /**
             * The unique identifier of a condition, used to distinguish between other conditions in the resource.
             */
            type?: pulumi.Input<string>;
        }

    }

    export namespace v1beta1 {
        /**
         * The specification of the Kafka Connect Source-to-Image (S2I) cluster.
         */
        export interface KafkaConnectS2ISpec {
            /**
             * The pod's affinity rules.
             */
            affinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecAffinity>;
            /**
             * Authentication configuration for Kafka Connect.
             */
            authentication?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecAuthentication>;
            /**
             * Bootstrap servers to connect to. This should be given as a comma separated list of _<hostname>_:_<port>_ pairs.
             */
            bootstrapServers: pulumi.Input<string>;
            /**
             * CPU and memory resources to reserve.
             */
            buildResources?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecBuildResources>;
            /**
             * The Kafka Connect configuration. Properties with the following prefixes cannot be set: ssl., sasl., security., listeners, plugin.path, rest., bootstrap.servers, consumer.interceptor.classes, producer.interceptor.classes (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
             */
            config?: pulumi.Input<{[key: string]: any}>;
            /**
             * Pass data from Secrets or ConfigMaps to the Kafka Connect pods and use them to configure connectors.
             */
            externalConfiguration?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecExternalConfiguration>;
            /**
             * The docker image for the pods.
             */
            image?: pulumi.Input<string>;
            /**
             * When true this configures the source repository with the 'Local' reference policy and an import policy that accepts insecure source tags.
             */
            insecureSourceRepository?: pulumi.Input<boolean>;
            /**
             * JVM Options for pods.
             */
            jvmOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecJvmOptions>;
            /**
             * Pod liveness checking.
             */
            livenessProbe?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecLivenessProbe>;
            /**
             * Logging configuration for Kafka Connect.
             */
            logging?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecLogging>;
            /**
             * The Prometheus JMX Exporter configuration. See https://github.com/prometheus/jmx_exporter for details of the structure of this configuration.
             */
            metrics?: pulumi.Input<{[key: string]: any}>;
            /**
             * Pod readiness checking.
             */
            readinessProbe?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecReadinessProbe>;
            /**
             * The number of pods in the Kafka Connect group.
             */
            replicas?: pulumi.Input<number>;
            /**
             * The maximum limits for CPU and memory resources and the requested initial resources.
             */
            resources?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecResources>;
            /**
             * Template for Kafka Connect and Kafka Connect S2I resources. The template allows users to specify how the `Deployment`, `Pods` and `Service` are generated.
             */
            template?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplate>;
            /**
             * TLS configuration.
             */
            tls?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTls>;
            /**
             * The pod's tolerations.
             */
            tolerations?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTolerations>[]>;
            /**
             * The configuration of tracing in Kafka Connect.
             */
            tracing?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTracing>;
            /**
             * The Kafka Connect version. Defaults to {DefaultKafkaVersion}. Consult the user documentation to understand the process required to upgrade or downgrade the version.
             */
            version?: pulumi.Input<string>;
        }

        /**
         * The pod's affinity rules.
         */
        export interface KafkaConnectS2ISpecAffinity {
            nodeAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecAffinityNodeAffinity>;
            podAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecAffinityPodAffinity>;
            podAntiAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecAffinityPodAntiAffinity>;
        }

        export interface KafkaConnectS2ISpecAffinityNodeAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>;
        }

        export interface KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>[]>;
        }

        export interface KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            nodeSelectorTerms?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>[]>;
        }

        export interface KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>[]>;
        }

        export interface KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaConnectS2ISpecAffinityPodAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaConnectS2ISpecAffinityPodAntiAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Authentication configuration for Kafka Connect.
         */
        export interface KafkaConnectS2ISpecAuthentication {
            /**
             * Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
             */
            accessToken?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecAuthenticationAccessToken>;
            /**
             * Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
             */
            accessTokenIsJwt?: pulumi.Input<boolean>;
            /**
             * Reference to the `Secret` which holds the certificate and private key pair.
             */
            certificateAndKey?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecAuthenticationCertificateAndKey>;
            /**
             * OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
             */
            clientId?: pulumi.Input<string>;
            /**
             * Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
             */
            clientSecret?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecAuthenticationClientSecret>;
            /**
             * Enable or disable TLS hostname verification. Default value is `false`.
             */
            disableTlsHostnameVerification?: pulumi.Input<boolean>;
            /**
             * Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.
             */
            maxTokenExpirySeconds?: pulumi.Input<number>;
            /**
             * Reference to the `Secret` which holds the password.
             */
            passwordSecret?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecAuthenticationPasswordSecret>;
            /**
             * Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
             */
            refreshToken?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecAuthenticationRefreshToken>;
            /**
             * OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.
             */
            scope?: pulumi.Input<string>;
            /**
             * Trusted certificates for TLS connection to the OAuth server.
             */
            tlsTrustedCertificates?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecAuthenticationTlsTrustedCertificates>[]>;
            /**
             * Authorization server token endpoint URI.
             */
            tokenEndpointUri?: pulumi.Input<string>;
            /**
             * Authentication type. Currently the only supported types are `tls`, `scram-sha-512`, and `plain`. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
             */
            type: pulumi.Input<string>;
            /**
             * Username used for the authentication.
             */
            username?: pulumi.Input<string>;
        }

        /**
         * Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
         */
        export interface KafkaConnectS2ISpecAuthenticationAccessToken {
            /**
             * The key under which the secret value is stored in the Kubernetes Secret.
             */
            key: pulumi.Input<string>;
            /**
             * The name of the Kubernetes Secret containing the secret value.
             */
            secretName: pulumi.Input<string>;
        }

        /**
         * Reference to the `Secret` which holds the certificate and private key pair.
         */
        export interface KafkaConnectS2ISpecAuthenticationCertificateAndKey {
            /**
             * The name of the file certificate in the Secret.
             */
            certificate: pulumi.Input<string>;
            /**
             * The name of the private key in the Secret.
             */
            key: pulumi.Input<string>;
            /**
             * The name of the Secret containing the certificate.
             */
            secretName: pulumi.Input<string>;
        }

        /**
         * Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
         */
        export interface KafkaConnectS2ISpecAuthenticationClientSecret {
            /**
             * The key under which the secret value is stored in the Kubernetes Secret.
             */
            key: pulumi.Input<string>;
            /**
             * The name of the Kubernetes Secret containing the secret value.
             */
            secretName: pulumi.Input<string>;
        }

        /**
         * Reference to the `Secret` which holds the password.
         */
        export interface KafkaConnectS2ISpecAuthenticationPasswordSecret {
            /**
             * The name of the key in the Secret under which the password is stored.
             */
            password: pulumi.Input<string>;
            /**
             * The name of the Secret containing the password.
             */
            secretName: pulumi.Input<string>;
        }

        /**
         * Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
         */
        export interface KafkaConnectS2ISpecAuthenticationRefreshToken {
            /**
             * The key under which the secret value is stored in the Kubernetes Secret.
             */
            key: pulumi.Input<string>;
            /**
             * The name of the Kubernetes Secret containing the secret value.
             */
            secretName: pulumi.Input<string>;
        }

        export interface KafkaConnectS2ISpecAuthenticationTlsTrustedCertificates {
            /**
             * The name of the file certificate in the Secret.
             */
            certificate: pulumi.Input<string>;
            /**
             * The name of the Secret containing the certificate.
             */
            secretName: pulumi.Input<string>;
        }

        /**
         * CPU and memory resources to reserve.
         */
        export interface KafkaConnectS2ISpecBuildResources {
            limits?: pulumi.Input<{[key: string]: any}>;
            requests?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Pass data from Secrets or ConfigMaps to the Kafka Connect pods and use them to configure connectors.
         */
        export interface KafkaConnectS2ISpecExternalConfiguration {
            /**
             * Allows to pass data from Secret or ConfigMap to the Kafka Connect pods as environment variables.
             */
            env?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecExternalConfigurationEnv>[]>;
            /**
             * Allows to pass data from Secret or ConfigMap to the Kafka Connect pods as volumes.
             */
            volumes?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecExternalConfigurationVolumes>[]>;
        }

        export interface KafkaConnectS2ISpecExternalConfigurationEnv {
            /**
             * Name of the environment variable which will be passed to the Kafka Connect pods. The name of the environment variable cannot start with `KAFKA_` or `STRIMZI_`.
             */
            name: pulumi.Input<string>;
            /**
             * Value of the environment variable which will be passed to the Kafka Connect pods. It can be passed either as a reference to Secret or ConfigMap field. The field has to specify exactly one Secret or ConfigMap.
             */
            valueFrom: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecExternalConfigurationEnvValueFrom>;
        }

        /**
         * Value of the environment variable which will be passed to the Kafka Connect pods. It can be passed either as a reference to Secret or ConfigMap field. The field has to specify exactly one Secret or ConfigMap.
         */
        export interface KafkaConnectS2ISpecExternalConfigurationEnvValueFrom {
            /**
             * Refernce to a key in a ConfigMap.
             */
            configMapKeyRef?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecExternalConfigurationEnvValueFromConfigMapKeyRef>;
            /**
             * Reference to a key in a Secret.
             */
            secretKeyRef?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecExternalConfigurationEnvValueFromSecretKeyRef>;
        }

        /**
         * Refernce to a key in a ConfigMap.
         */
        export interface KafkaConnectS2ISpecExternalConfigurationEnvValueFromConfigMapKeyRef {
            key?: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        /**
         * Reference to a key in a Secret.
         */
        export interface KafkaConnectS2ISpecExternalConfigurationEnvValueFromSecretKeyRef {
            key?: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface KafkaConnectS2ISpecExternalConfigurationVolumes {
            /**
             * Reference to a key in a ConfigMap. Exactly one Secret or ConfigMap has to be specified.
             */
            configMap?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecExternalConfigurationVolumesConfigMap>;
            /**
             * Name of the volume which will be added to the Kafka Connect pods.
             */
            name: pulumi.Input<string>;
            /**
             * Reference to a key in a Secret. Exactly one Secret or ConfigMap has to be specified.
             */
            secret?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecExternalConfigurationVolumesSecret>;
        }

        /**
         * Reference to a key in a ConfigMap. Exactly one Secret or ConfigMap has to be specified.
         */
        export interface KafkaConnectS2ISpecExternalConfigurationVolumesConfigMap {
            defaultMode?: pulumi.Input<number>;
            items?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecExternalConfigurationVolumesConfigMapItems>[]>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface KafkaConnectS2ISpecExternalConfigurationVolumesConfigMapItems {
            key?: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path?: pulumi.Input<string>;
        }

        /**
         * Reference to a key in a Secret. Exactly one Secret or ConfigMap has to be specified.
         */
        export interface KafkaConnectS2ISpecExternalConfigurationVolumesSecret {
            defaultMode?: pulumi.Input<number>;
            items?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecExternalConfigurationVolumesSecretItems>[]>;
            optional?: pulumi.Input<boolean>;
            secretName?: pulumi.Input<string>;
        }

        export interface KafkaConnectS2ISpecExternalConfigurationVolumesSecretItems {
            key?: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path?: pulumi.Input<string>;
        }

        /**
         * JVM Options for pods.
         */
        export interface KafkaConnectS2ISpecJvmOptions {
            /**
             * A map of -XX options to the JVM.
             */
            -XX?: pulumi.Input<{[key: string]: any}>;
            /**
             * -Xms option to to the JVM.
             */
            -Xms?: pulumi.Input<string>;
            /**
             * -Xmx option to to the JVM.
             */
            -Xmx?: pulumi.Input<string>;
            /**
             * Specifies whether the Garbage Collection logging is enabled. The default is false.
             */
            gcLoggingEnabled?: pulumi.Input<boolean>;
            /**
             * A map of additional system properties which will be passed using the `-D` option to the JVM.
             */
            javaSystemProperties?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecJvmOptionsJavaSystemProperties>[]>;
        }

        export interface KafkaConnectS2ISpecJvmOptionsJavaSystemProperties {
            /**
             * The system property name.
             */
            name?: pulumi.Input<string>;
            /**
             * The system property value.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * Pod liveness checking.
         */
        export interface KafkaConnectS2ISpecLivenessProbe {
            /**
             * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
             */
            failureThreshold?: pulumi.Input<number>;
            /**
             * The initial delay before first the health is first checked.
             */
            initialDelaySeconds?: pulumi.Input<number>;
            /**
             * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
             */
            successThreshold?: pulumi.Input<number>;
            /**
             * The timeout for each attempted health check.
             */
            timeoutSeconds?: pulumi.Input<number>;
        }

        /**
         * Logging configuration for Kafka Connect.
         */
        export interface KafkaConnectS2ISpecLogging {
            /**
             * A Map from logger name to logger level.
             */
            loggers?: pulumi.Input<{[key: string]: any}>;
            /**
             * The name of the `ConfigMap` from which to get the logging configuration.
             */
            name?: pulumi.Input<string>;
            /**
             * Logging type, must be either 'inline' or 'external'.
             */
            type: pulumi.Input<string>;
        }

        /**
         * Pod readiness checking.
         */
        export interface KafkaConnectS2ISpecReadinessProbe {
            /**
             * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
             */
            failureThreshold?: pulumi.Input<number>;
            /**
             * The initial delay before first the health is first checked.
             */
            initialDelaySeconds?: pulumi.Input<number>;
            /**
             * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
             */
            successThreshold?: pulumi.Input<number>;
            /**
             * The timeout for each attempted health check.
             */
            timeoutSeconds?: pulumi.Input<number>;
        }

        /**
         * The maximum limits for CPU and memory resources and the requested initial resources.
         */
        export interface KafkaConnectS2ISpecResources {
            limits?: pulumi.Input<{[key: string]: any}>;
            requests?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Template for Kafka Connect and Kafka Connect S2I resources. The template allows users to specify how the `Deployment`, `Pods` and `Service` are generated.
         */
        export interface KafkaConnectS2ISpecTemplate {
            /**
             * Template for Kafka Connect API `Service`.
             */
            apiService?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplateApiService>;
            /**
             * Template for the Kafka Connect container.
             */
            connectContainer?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplateConnectContainer>;
            /**
             * Template for Kafka Connect `Deployment`.
             */
            deployment?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplateDeployment>;
            /**
             * Template for Kafka Connect `Pods`.
             */
            pod?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplatePod>;
            /**
             * Template for Kafka Connect `PodDisruptionBudget`.
             */
            podDisruptionBudget?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplatePodDisruptionBudget>;
        }

        /**
         * Template for Kafka Connect API `Service`.
         */
        export interface KafkaConnectS2ISpecTemplateApiService {
            /**
             * Metadata applied to the resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplateApiServiceMetadata>;
        }

        /**
         * Metadata applied to the resource.
         */
        export interface KafkaConnectS2ISpecTemplateApiServiceMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Template for the Kafka Connect container.
         */
        export interface KafkaConnectS2ISpecTemplateConnectContainer {
            /**
             * Environment variables which should be applied to the container.
             */
            env?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplateConnectContainerEnv>[]>;
            /**
             * Security context for the container.
             */
            securityContext?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplateConnectContainerSecurityContext>;
        }

        export interface KafkaConnectS2ISpecTemplateConnectContainerEnv {
            /**
             * The environment variable key.
             */
            name?: pulumi.Input<string>;
            /**
             * The environment variable value.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * Security context for the container.
         */
        export interface KafkaConnectS2ISpecTemplateConnectContainerSecurityContext {
            allowPrivilegeEscalation?: pulumi.Input<boolean>;
            capabilities?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplateConnectContainerSecurityContextCapabilities>;
            privileged?: pulumi.Input<boolean>;
            procMount?: pulumi.Input<string>;
            readOnlyRootFilesystem?: pulumi.Input<boolean>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplateConnectContainerSecurityContextSeLinuxOptions>;
            windowsOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplateConnectContainerSecurityContextWindowsOptions>;
        }

        export interface KafkaConnectS2ISpecTemplateConnectContainerSecurityContextCapabilities {
            add?: pulumi.Input<pulumi.Input<string>[]>;
            drop?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaConnectS2ISpecTemplateConnectContainerSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface KafkaConnectS2ISpecTemplateConnectContainerSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
        }

        /**
         * Template for Kafka Connect `Deployment`.
         */
        export interface KafkaConnectS2ISpecTemplateDeployment {
            /**
             * Metadata applied to the resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplateDeploymentMetadata>;
        }

        /**
         * Metadata applied to the resource.
         */
        export interface KafkaConnectS2ISpecTemplateDeploymentMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Template for Kafka Connect `Pods`.
         */
        export interface KafkaConnectS2ISpecTemplatePod {
            /**
             * The pod's affinity rules.
             */
            affinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplatePodAffinity>;
            /**
             * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
             */
            imagePullSecrets?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplatePodImagePullSecrets>[]>;
            /**
             * Metadata applied to the resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplatePodMetadata>;
            /**
             * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
             */
            priorityClassName?: pulumi.Input<string>;
            /**
             * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
             */
            schedulerName?: pulumi.Input<string>;
            /**
             * Configures pod-level security attributes and common container settings.
             */
            securityContext?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplatePodSecurityContext>;
            /**
             * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
             */
            terminationGracePeriodSeconds?: pulumi.Input<number>;
            /**
             * The pod's tolerations.
             */
            tolerations?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplatePodTolerations>[]>;
        }

        /**
         * The pod's affinity rules.
         */
        export interface KafkaConnectS2ISpecTemplatePodAffinity {
            nodeAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplatePodAffinityNodeAffinity>;
            podAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplatePodAffinityPodAffinity>;
            podAntiAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinity>;
        }

        export interface KafkaConnectS2ISpecTemplatePodAffinityNodeAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>;
        }

        export interface KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>[]>;
        }

        export interface KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            nodeSelectorTerms?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>[]>;
        }

        export interface KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>[]>;
        }

        export interface KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaConnectS2ISpecTemplatePodAffinityPodAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Template for Kafka Connect `PodDisruptionBudget`.
         */
        export interface KafkaConnectS2ISpecTemplatePodDisruptionBudget {
            /**
             * Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
             */
            maxUnavailable?: pulumi.Input<number>;
            /**
             * Metadata to apply to the `PodDistruptionBugetTemplate` resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplatePodDisruptionBudgetMetadata>;
        }

        /**
         * Metadata to apply to the `PodDistruptionBugetTemplate` resource.
         */
        export interface KafkaConnectS2ISpecTemplatePodDisruptionBudgetMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaConnectS2ISpecTemplatePodImagePullSecrets {
            name?: pulumi.Input<string>;
        }

        /**
         * Metadata applied to the resource.
         */
        export interface KafkaConnectS2ISpecTemplatePodMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Configures pod-level security attributes and common container settings.
         */
        export interface KafkaConnectS2ISpecTemplatePodSecurityContext {
            fsGroup?: pulumi.Input<number>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplatePodSecurityContextSeLinuxOptions>;
            supplementalGroups?: pulumi.Input<pulumi.Input<number>[]>;
            sysctls?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplatePodSecurityContextSysctls>[]>;
            windowsOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTemplatePodSecurityContextWindowsOptions>;
        }

        export interface KafkaConnectS2ISpecTemplatePodSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface KafkaConnectS2ISpecTemplatePodSecurityContextSysctls {
            name?: pulumi.Input<string>;
            value?: pulumi.Input<string>;
        }

        export interface KafkaConnectS2ISpecTemplatePodSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
        }

        export interface KafkaConnectS2ISpecTemplatePodTolerations {
            effect?: pulumi.Input<string>;
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            tolerationSeconds?: pulumi.Input<number>;
            value?: pulumi.Input<string>;
        }

        /**
         * TLS configuration.
         */
        export interface KafkaConnectS2ISpecTls {
            /**
             * Trusted certificates for TLS connection.
             */
            trustedCertificates?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2ISpecTlsTrustedCertificates>[]>;
        }

        export interface KafkaConnectS2ISpecTlsTrustedCertificates {
            /**
             * The name of the file certificate in the Secret.
             */
            certificate: pulumi.Input<string>;
            /**
             * The name of the Secret containing the certificate.
             */
            secretName: pulumi.Input<string>;
        }

        export interface KafkaConnectS2ISpecTolerations {
            effect?: pulumi.Input<string>;
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            tolerationSeconds?: pulumi.Input<number>;
            value?: pulumi.Input<string>;
        }

        /**
         * The configuration of tracing in Kafka Connect.
         */
        export interface KafkaConnectS2ISpecTracing {
            /**
             * Type of the tracing used. Currently the only supported type is `jaeger` for Jaeger tracing.
             */
            type: pulumi.Input<string>;
        }

        /**
         * The status of the Kafka Connect Source-to-Image (S2I) cluster.
         */
        export interface KafkaConnectS2IStatus {
            /**
             * The name of the build configuration.
             */
            buildConfigName?: pulumi.Input<string>;
            /**
             * List of status conditions.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2IStatusConditions>[]>;
            /**
             * The list of connector plugins available in this Kafka Connect deployment.
             */
            connectorPlugins?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2IStatusConnectorPlugins>[]>;
            /**
             * The generation of the CRD that was last reconciled by the operator.
             */
            observedGeneration?: pulumi.Input<number>;
            /**
             * Label selector for pods providing this resource.
             */
            podSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2IStatusPodSelector>;
            /**
             * The current number of pods being used to provide this resource.
             */
            replicas?: pulumi.Input<number>;
            /**
             * The URL of the REST API endpoint for managing and monitoring Kafka Connect connectors.
             */
            url?: pulumi.Input<string>;
        }

        export interface KafkaConnectS2IStatusConditions {
            /**
             * Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
             */
            lastTransitionTime?: pulumi.Input<string>;
            /**
             * Human-readable message indicating details about the condition's last transition.
             */
            message?: pulumi.Input<string>;
            /**
             * The reason for the condition's last transition (a single word in CamelCase).
             */
            reason?: pulumi.Input<string>;
            /**
             * The status of the condition, either True, False or Unknown.
             */
            status?: pulumi.Input<string>;
            /**
             * The unique identifier of a condition, used to distinguish between other conditions in the resource.
             */
            type?: pulumi.Input<string>;
        }

        export interface KafkaConnectS2IStatusConnectorPlugins {
            /**
             * The class of the connector plugin.
             */
            class?: pulumi.Input<string>;
            /**
             * The type of the connector plugin. The available types are `sink` and `source`.
             */
            type?: pulumi.Input<string>;
            /**
             * The version of the connector plugin.
             */
            version?: pulumi.Input<string>;
        }

        /**
         * Label selector for pods providing this resource.
         */
        export interface KafkaConnectS2IStatusPodSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectS2IStatusPodSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaConnectS2IStatusPodSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * The specification of the Kafka Connect cluster.
         */
        export interface KafkaConnectSpec {
            /**
             * The pod's affinity rules.
             */
            affinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecAffinity>;
            /**
             * Authentication configuration for Kafka Connect.
             */
            authentication?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecAuthentication>;
            /**
             * Bootstrap servers to connect to. This should be given as a comma separated list of _<hostname>_:_<port>_ pairs.
             */
            bootstrapServers: pulumi.Input<string>;
            /**
             * The Kafka Connect configuration. Properties with the following prefixes cannot be set: ssl., sasl., security., listeners, plugin.path, rest., bootstrap.servers, consumer.interceptor.classes, producer.interceptor.classes (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
             */
            config?: pulumi.Input<{[key: string]: any}>;
            /**
             * Pass data from Secrets or ConfigMaps to the Kafka Connect pods and use them to configure connectors.
             */
            externalConfiguration?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecExternalConfiguration>;
            /**
             * The docker image for the pods.
             */
            image?: pulumi.Input<string>;
            /**
             * JVM Options for pods.
             */
            jvmOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecJvmOptions>;
            /**
             * Pod liveness checking.
             */
            livenessProbe?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecLivenessProbe>;
            /**
             * Logging configuration for Kafka Connect.
             */
            logging?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecLogging>;
            /**
             * The Prometheus JMX Exporter configuration. See https://github.com/prometheus/jmx_exporter for details of the structure of this configuration.
             */
            metrics?: pulumi.Input<{[key: string]: any}>;
            /**
             * Pod readiness checking.
             */
            readinessProbe?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecReadinessProbe>;
            /**
             * The number of pods in the Kafka Connect group.
             */
            replicas?: pulumi.Input<number>;
            /**
             * The maximum limits for CPU and memory resources and the requested initial resources.
             */
            resources?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecResources>;
            /**
             * Template for Kafka Connect and Kafka Connect S2I resources. The template allows users to specify how the `Deployment`, `Pods` and `Service` are generated.
             */
            template?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplate>;
            /**
             * TLS configuration.
             */
            tls?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTls>;
            /**
             * The pod's tolerations.
             */
            tolerations?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTolerations>[]>;
            /**
             * The configuration of tracing in Kafka Connect.
             */
            tracing?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTracing>;
            /**
             * The Kafka Connect version. Defaults to {DefaultKafkaVersion}. Consult the user documentation to understand the process required to upgrade or downgrade the version.
             */
            version?: pulumi.Input<string>;
        }

        /**
         * The pod's affinity rules.
         */
        export interface KafkaConnectSpecAffinity {
            nodeAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecAffinityNodeAffinity>;
            podAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecAffinityPodAffinity>;
            podAntiAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecAffinityPodAntiAffinity>;
        }

        export interface KafkaConnectSpecAffinityNodeAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>;
        }

        export interface KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>[]>;
        }

        export interface KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            nodeSelectorTerms?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>[]>;
        }

        export interface KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>[]>;
        }

        export interface KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaConnectSpecAffinityPodAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaConnectSpecAffinityPodAntiAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Authentication configuration for Kafka Connect.
         */
        export interface KafkaConnectSpecAuthentication {
            /**
             * Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
             */
            accessToken?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecAuthenticationAccessToken>;
            /**
             * Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
             */
            accessTokenIsJwt?: pulumi.Input<boolean>;
            /**
             * Reference to the `Secret` which holds the certificate and private key pair.
             */
            certificateAndKey?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecAuthenticationCertificateAndKey>;
            /**
             * OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
             */
            clientId?: pulumi.Input<string>;
            /**
             * Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
             */
            clientSecret?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecAuthenticationClientSecret>;
            /**
             * Enable or disable TLS hostname verification. Default value is `false`.
             */
            disableTlsHostnameVerification?: pulumi.Input<boolean>;
            /**
             * Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.
             */
            maxTokenExpirySeconds?: pulumi.Input<number>;
            /**
             * Reference to the `Secret` which holds the password.
             */
            passwordSecret?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecAuthenticationPasswordSecret>;
            /**
             * Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
             */
            refreshToken?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecAuthenticationRefreshToken>;
            /**
             * OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.
             */
            scope?: pulumi.Input<string>;
            /**
             * Trusted certificates for TLS connection to the OAuth server.
             */
            tlsTrustedCertificates?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecAuthenticationTlsTrustedCertificates>[]>;
            /**
             * Authorization server token endpoint URI.
             */
            tokenEndpointUri?: pulumi.Input<string>;
            /**
             * Authentication type. Currently the only supported types are `tls`, `scram-sha-512`, and `plain`. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
             */
            type: pulumi.Input<string>;
            /**
             * Username used for the authentication.
             */
            username?: pulumi.Input<string>;
        }

        /**
         * Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
         */
        export interface KafkaConnectSpecAuthenticationAccessToken {
            /**
             * The key under which the secret value is stored in the Kubernetes Secret.
             */
            key: pulumi.Input<string>;
            /**
             * The name of the Kubernetes Secret containing the secret value.
             */
            secretName: pulumi.Input<string>;
        }

        /**
         * Reference to the `Secret` which holds the certificate and private key pair.
         */
        export interface KafkaConnectSpecAuthenticationCertificateAndKey {
            /**
             * The name of the file certificate in the Secret.
             */
            certificate: pulumi.Input<string>;
            /**
             * The name of the private key in the Secret.
             */
            key: pulumi.Input<string>;
            /**
             * The name of the Secret containing the certificate.
             */
            secretName: pulumi.Input<string>;
        }

        /**
         * Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
         */
        export interface KafkaConnectSpecAuthenticationClientSecret {
            /**
             * The key under which the secret value is stored in the Kubernetes Secret.
             */
            key: pulumi.Input<string>;
            /**
             * The name of the Kubernetes Secret containing the secret value.
             */
            secretName: pulumi.Input<string>;
        }

        /**
         * Reference to the `Secret` which holds the password.
         */
        export interface KafkaConnectSpecAuthenticationPasswordSecret {
            /**
             * The name of the key in the Secret under which the password is stored.
             */
            password: pulumi.Input<string>;
            /**
             * The name of the Secret containing the password.
             */
            secretName: pulumi.Input<string>;
        }

        /**
         * Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
         */
        export interface KafkaConnectSpecAuthenticationRefreshToken {
            /**
             * The key under which the secret value is stored in the Kubernetes Secret.
             */
            key: pulumi.Input<string>;
            /**
             * The name of the Kubernetes Secret containing the secret value.
             */
            secretName: pulumi.Input<string>;
        }

        export interface KafkaConnectSpecAuthenticationTlsTrustedCertificates {
            /**
             * The name of the file certificate in the Secret.
             */
            certificate: pulumi.Input<string>;
            /**
             * The name of the Secret containing the certificate.
             */
            secretName: pulumi.Input<string>;
        }

        /**
         * Pass data from Secrets or ConfigMaps to the Kafka Connect pods and use them to configure connectors.
         */
        export interface KafkaConnectSpecExternalConfiguration {
            /**
             * Allows to pass data from Secret or ConfigMap to the Kafka Connect pods as environment variables.
             */
            env?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecExternalConfigurationEnv>[]>;
            /**
             * Allows to pass data from Secret or ConfigMap to the Kafka Connect pods as volumes.
             */
            volumes?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecExternalConfigurationVolumes>[]>;
        }

        export interface KafkaConnectSpecExternalConfigurationEnv {
            /**
             * Name of the environment variable which will be passed to the Kafka Connect pods. The name of the environment variable cannot start with `KAFKA_` or `STRIMZI_`.
             */
            name: pulumi.Input<string>;
            /**
             * Value of the environment variable which will be passed to the Kafka Connect pods. It can be passed either as a reference to Secret or ConfigMap field. The field has to specify exactly one Secret or ConfigMap.
             */
            valueFrom: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecExternalConfigurationEnvValueFrom>;
        }

        /**
         * Value of the environment variable which will be passed to the Kafka Connect pods. It can be passed either as a reference to Secret or ConfigMap field. The field has to specify exactly one Secret or ConfigMap.
         */
        export interface KafkaConnectSpecExternalConfigurationEnvValueFrom {
            /**
             * Refernce to a key in a ConfigMap.
             */
            configMapKeyRef?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecExternalConfigurationEnvValueFromConfigMapKeyRef>;
            /**
             * Reference to a key in a Secret.
             */
            secretKeyRef?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecExternalConfigurationEnvValueFromSecretKeyRef>;
        }

        /**
         * Refernce to a key in a ConfigMap.
         */
        export interface KafkaConnectSpecExternalConfigurationEnvValueFromConfigMapKeyRef {
            key?: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        /**
         * Reference to a key in a Secret.
         */
        export interface KafkaConnectSpecExternalConfigurationEnvValueFromSecretKeyRef {
            key?: pulumi.Input<string>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface KafkaConnectSpecExternalConfigurationVolumes {
            /**
             * Reference to a key in a ConfigMap. Exactly one Secret or ConfigMap has to be specified.
             */
            configMap?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecExternalConfigurationVolumesConfigMap>;
            /**
             * Name of the volume which will be added to the Kafka Connect pods.
             */
            name: pulumi.Input<string>;
            /**
             * Reference to a key in a Secret. Exactly one Secret or ConfigMap has to be specified.
             */
            secret?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecExternalConfigurationVolumesSecret>;
        }

        /**
         * Reference to a key in a ConfigMap. Exactly one Secret or ConfigMap has to be specified.
         */
        export interface KafkaConnectSpecExternalConfigurationVolumesConfigMap {
            defaultMode?: pulumi.Input<number>;
            items?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecExternalConfigurationVolumesConfigMapItems>[]>;
            name?: pulumi.Input<string>;
            optional?: pulumi.Input<boolean>;
        }

        export interface KafkaConnectSpecExternalConfigurationVolumesConfigMapItems {
            key?: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path?: pulumi.Input<string>;
        }

        /**
         * Reference to a key in a Secret. Exactly one Secret or ConfigMap has to be specified.
         */
        export interface KafkaConnectSpecExternalConfigurationVolumesSecret {
            defaultMode?: pulumi.Input<number>;
            items?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecExternalConfigurationVolumesSecretItems>[]>;
            optional?: pulumi.Input<boolean>;
            secretName?: pulumi.Input<string>;
        }

        export interface KafkaConnectSpecExternalConfigurationVolumesSecretItems {
            key?: pulumi.Input<string>;
            mode?: pulumi.Input<number>;
            path?: pulumi.Input<string>;
        }

        /**
         * JVM Options for pods.
         */
        export interface KafkaConnectSpecJvmOptions {
            /**
             * A map of -XX options to the JVM.
             */
            -XX?: pulumi.Input<{[key: string]: any}>;
            /**
             * -Xms option to to the JVM.
             */
            -Xms?: pulumi.Input<string>;
            /**
             * -Xmx option to to the JVM.
             */
            -Xmx?: pulumi.Input<string>;
            /**
             * Specifies whether the Garbage Collection logging is enabled. The default is false.
             */
            gcLoggingEnabled?: pulumi.Input<boolean>;
            /**
             * A map of additional system properties which will be passed using the `-D` option to the JVM.
             */
            javaSystemProperties?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecJvmOptionsJavaSystemProperties>[]>;
        }

        export interface KafkaConnectSpecJvmOptionsJavaSystemProperties {
            /**
             * The system property name.
             */
            name?: pulumi.Input<string>;
            /**
             * The system property value.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * Pod liveness checking.
         */
        export interface KafkaConnectSpecLivenessProbe {
            /**
             * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
             */
            failureThreshold?: pulumi.Input<number>;
            /**
             * The initial delay before first the health is first checked.
             */
            initialDelaySeconds?: pulumi.Input<number>;
            /**
             * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
             */
            successThreshold?: pulumi.Input<number>;
            /**
             * The timeout for each attempted health check.
             */
            timeoutSeconds?: pulumi.Input<number>;
        }

        /**
         * Logging configuration for Kafka Connect.
         */
        export interface KafkaConnectSpecLogging {
            /**
             * A Map from logger name to logger level.
             */
            loggers?: pulumi.Input<{[key: string]: any}>;
            /**
             * The name of the `ConfigMap` from which to get the logging configuration.
             */
            name?: pulumi.Input<string>;
            /**
             * Logging type, must be either 'inline' or 'external'.
             */
            type: pulumi.Input<string>;
        }

        /**
         * Pod readiness checking.
         */
        export interface KafkaConnectSpecReadinessProbe {
            /**
             * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
             */
            failureThreshold?: pulumi.Input<number>;
            /**
             * The initial delay before first the health is first checked.
             */
            initialDelaySeconds?: pulumi.Input<number>;
            /**
             * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
             */
            successThreshold?: pulumi.Input<number>;
            /**
             * The timeout for each attempted health check.
             */
            timeoutSeconds?: pulumi.Input<number>;
        }

        /**
         * The maximum limits for CPU and memory resources and the requested initial resources.
         */
        export interface KafkaConnectSpecResources {
            limits?: pulumi.Input<{[key: string]: any}>;
            requests?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Template for Kafka Connect and Kafka Connect S2I resources. The template allows users to specify how the `Deployment`, `Pods` and `Service` are generated.
         */
        export interface KafkaConnectSpecTemplate {
            /**
             * Template for Kafka Connect API `Service`.
             */
            apiService?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplateApiService>;
            /**
             * Template for the Kafka Connect container.
             */
            connectContainer?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplateConnectContainer>;
            /**
             * Template for Kafka Connect `Deployment`.
             */
            deployment?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplateDeployment>;
            /**
             * Template for Kafka Connect `Pods`.
             */
            pod?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplatePod>;
            /**
             * Template for Kafka Connect `PodDisruptionBudget`.
             */
            podDisruptionBudget?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplatePodDisruptionBudget>;
        }

        /**
         * Template for Kafka Connect API `Service`.
         */
        export interface KafkaConnectSpecTemplateApiService {
            /**
             * Metadata applied to the resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplateApiServiceMetadata>;
        }

        /**
         * Metadata applied to the resource.
         */
        export interface KafkaConnectSpecTemplateApiServiceMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Template for the Kafka Connect container.
         */
        export interface KafkaConnectSpecTemplateConnectContainer {
            /**
             * Environment variables which should be applied to the container.
             */
            env?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplateConnectContainerEnv>[]>;
            /**
             * Security context for the container.
             */
            securityContext?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplateConnectContainerSecurityContext>;
        }

        export interface KafkaConnectSpecTemplateConnectContainerEnv {
            /**
             * The environment variable key.
             */
            name?: pulumi.Input<string>;
            /**
             * The environment variable value.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * Security context for the container.
         */
        export interface KafkaConnectSpecTemplateConnectContainerSecurityContext {
            allowPrivilegeEscalation?: pulumi.Input<boolean>;
            capabilities?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplateConnectContainerSecurityContextCapabilities>;
            privileged?: pulumi.Input<boolean>;
            procMount?: pulumi.Input<string>;
            readOnlyRootFilesystem?: pulumi.Input<boolean>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptions>;
            windowsOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplateConnectContainerSecurityContextWindowsOptions>;
        }

        export interface KafkaConnectSpecTemplateConnectContainerSecurityContextCapabilities {
            add?: pulumi.Input<pulumi.Input<string>[]>;
            drop?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface KafkaConnectSpecTemplateConnectContainerSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
        }

        /**
         * Template for Kafka Connect `Deployment`.
         */
        export interface KafkaConnectSpecTemplateDeployment {
            /**
             * Metadata applied to the resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplateDeploymentMetadata>;
        }

        /**
         * Metadata applied to the resource.
         */
        export interface KafkaConnectSpecTemplateDeploymentMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Template for Kafka Connect `Pods`.
         */
        export interface KafkaConnectSpecTemplatePod {
            /**
             * The pod's affinity rules.
             */
            affinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplatePodAffinity>;
            /**
             * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
             */
            imagePullSecrets?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplatePodImagePullSecrets>[]>;
            /**
             * Metadata applied to the resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplatePodMetadata>;
            /**
             * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
             */
            priorityClassName?: pulumi.Input<string>;
            /**
             * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
             */
            schedulerName?: pulumi.Input<string>;
            /**
             * Configures pod-level security attributes and common container settings.
             */
            securityContext?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplatePodSecurityContext>;
            /**
             * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
             */
            terminationGracePeriodSeconds?: pulumi.Input<number>;
            /**
             * The pod's tolerations.
             */
            tolerations?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplatePodTolerations>[]>;
        }

        /**
         * The pod's affinity rules.
         */
        export interface KafkaConnectSpecTemplatePodAffinity {
            nodeAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplatePodAffinityNodeAffinity>;
            podAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplatePodAffinityPodAffinity>;
            podAntiAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplatePodAffinityPodAntiAffinity>;
        }

        export interface KafkaConnectSpecTemplatePodAffinityNodeAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>;
        }

        export interface KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>[]>;
        }

        export interface KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            nodeSelectorTerms?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>[]>;
        }

        export interface KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>[]>;
        }

        export interface KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaConnectSpecTemplatePodAffinityPodAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaConnectSpecTemplatePodAffinityPodAntiAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Template for Kafka Connect `PodDisruptionBudget`.
         */
        export interface KafkaConnectSpecTemplatePodDisruptionBudget {
            /**
             * Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
             */
            maxUnavailable?: pulumi.Input<number>;
            /**
             * Metadata to apply to the `PodDistruptionBugetTemplate` resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplatePodDisruptionBudgetMetadata>;
        }

        /**
         * Metadata to apply to the `PodDistruptionBugetTemplate` resource.
         */
        export interface KafkaConnectSpecTemplatePodDisruptionBudgetMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaConnectSpecTemplatePodImagePullSecrets {
            name?: pulumi.Input<string>;
        }

        /**
         * Metadata applied to the resource.
         */
        export interface KafkaConnectSpecTemplatePodMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Configures pod-level security attributes and common container settings.
         */
        export interface KafkaConnectSpecTemplatePodSecurityContext {
            fsGroup?: pulumi.Input<number>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptions>;
            supplementalGroups?: pulumi.Input<pulumi.Input<number>[]>;
            sysctls?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplatePodSecurityContextSysctls>[]>;
            windowsOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTemplatePodSecurityContextWindowsOptions>;
        }

        export interface KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface KafkaConnectSpecTemplatePodSecurityContextSysctls {
            name?: pulumi.Input<string>;
            value?: pulumi.Input<string>;
        }

        export interface KafkaConnectSpecTemplatePodSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
        }

        export interface KafkaConnectSpecTemplatePodTolerations {
            effect?: pulumi.Input<string>;
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            tolerationSeconds?: pulumi.Input<number>;
            value?: pulumi.Input<string>;
        }

        /**
         * TLS configuration.
         */
        export interface KafkaConnectSpecTls {
            /**
             * Trusted certificates for TLS connection.
             */
            trustedCertificates?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectSpecTlsTrustedCertificates>[]>;
        }

        export interface KafkaConnectSpecTlsTrustedCertificates {
            /**
             * The name of the file certificate in the Secret.
             */
            certificate: pulumi.Input<string>;
            /**
             * The name of the Secret containing the certificate.
             */
            secretName: pulumi.Input<string>;
        }

        export interface KafkaConnectSpecTolerations {
            effect?: pulumi.Input<string>;
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            tolerationSeconds?: pulumi.Input<number>;
            value?: pulumi.Input<string>;
        }

        /**
         * The configuration of tracing in Kafka Connect.
         */
        export interface KafkaConnectSpecTracing {
            /**
             * Type of the tracing used. Currently the only supported type is `jaeger` for Jaeger tracing.
             */
            type: pulumi.Input<string>;
        }

        /**
         * The status of the Kafka Connect cluster.
         */
        export interface KafkaConnectStatus {
            /**
             * List of status conditions.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectStatusConditions>[]>;
            /**
             * The list of connector plugins available in this Kafka Connect deployment.
             */
            connectorPlugins?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectStatusConnectorPlugins>[]>;
            /**
             * The generation of the CRD that was last reconciled by the operator.
             */
            observedGeneration?: pulumi.Input<number>;
            /**
             * Label selector for pods providing this resource.
             */
            podSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaConnectStatusPodSelector>;
            /**
             * The current number of pods being used to provide this resource.
             */
            replicas?: pulumi.Input<number>;
            /**
             * The URL of the REST API endpoint for managing and monitoring Kafka Connect connectors.
             */
            url?: pulumi.Input<string>;
        }

        export interface KafkaConnectStatusConditions {
            /**
             * Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
             */
            lastTransitionTime?: pulumi.Input<string>;
            /**
             * Human-readable message indicating details about the condition's last transition.
             */
            message?: pulumi.Input<string>;
            /**
             * The reason for the condition's last transition (a single word in CamelCase).
             */
            reason?: pulumi.Input<string>;
            /**
             * The status of the condition, either True, False or Unknown.
             */
            status?: pulumi.Input<string>;
            /**
             * The unique identifier of a condition, used to distinguish between other conditions in the resource.
             */
            type?: pulumi.Input<string>;
        }

        export interface KafkaConnectStatusConnectorPlugins {
            /**
             * The class of the connector plugin.
             */
            class?: pulumi.Input<string>;
            /**
             * The type of the connector plugin. The available types are `sink` and `source`.
             */
            type?: pulumi.Input<string>;
            /**
             * The version of the connector plugin.
             */
            version?: pulumi.Input<string>;
        }

        /**
         * Label selector for pods providing this resource.
         */
        export interface KafkaConnectStatusPodSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaConnectStatusPodSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaConnectStatusPodSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * The specification of Kafka MirrorMaker.
         */
        export interface KafkaMirrorMakerSpec {
            /**
             * The pod's affinity rules.
             */
            affinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecAffinity>;
            /**
             * Configuration of source cluster.
             */
            consumer: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecConsumer>;
            /**
             * The docker image for the pods.
             */
            image?: pulumi.Input<string>;
            /**
             * JVM Options for pods.
             */
            jvmOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecJvmOptions>;
            /**
             * Pod liveness checking.
             */
            livenessProbe?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecLivenessProbe>;
            /**
             * Logging configuration for MirrorMaker.
             */
            logging?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecLogging>;
            /**
             * The Prometheus JMX Exporter configuration. See {JMXExporter} for details of the structure of this configuration.
             */
            metrics?: pulumi.Input<{[key: string]: any}>;
            /**
             * Configuration of target cluster.
             */
            producer: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecProducer>;
            /**
             * Pod readiness checking.
             */
            readinessProbe?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecReadinessProbe>;
            /**
             * The number of pods in the `Deployment`.
             */
            replicas: pulumi.Input<number>;
            /**
             * CPU and memory resources to reserve.
             */
            resources?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecResources>;
            /**
             * Template to specify how Kafka MirrorMaker resources, `Deployments` and `Pods`, are generated.
             */
            template?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplate>;
            /**
             * The pod's tolerations.
             */
            tolerations?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTolerations>[]>;
            /**
             * The configuration of tracing in Kafka MirrorMaker.
             */
            tracing?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTracing>;
            /**
             * The Kafka MirrorMaker version. Defaults to {DefaultKafkaVersion}. Consult the documentation to understand the process required to upgrade or downgrade the version.
             */
            version?: pulumi.Input<string>;
            /**
             * List of topics which are included for mirroring. This option allows any regular expression using Java-style regular expressions. Mirroring two topics named A and B is achieved by using the whitelist `'A\|B'`. Or, as a special case, you can mirror all topics using the whitelist '*'. You can also specify multiple regular expressions separated by commas.
             */
            whitelist: pulumi.Input<string>;
        }

        /**
         * The pod's affinity rules.
         */
        export interface KafkaMirrorMakerSpecAffinity {
            nodeAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecAffinityNodeAffinity>;
            podAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecAffinityPodAffinity>;
            podAntiAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecAffinityPodAntiAffinity>;
        }

        export interface KafkaMirrorMakerSpecAffinityNodeAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>;
        }

        export interface KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>[]>;
        }

        export interface KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            nodeSelectorTerms?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>[]>;
        }

        export interface KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>[]>;
        }

        export interface KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaMirrorMakerSpecAffinityPodAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaMirrorMakerSpecAffinityPodAntiAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Configuration of source cluster.
         */
        export interface KafkaMirrorMakerSpecConsumer {
            /**
             * Authentication configuration for connecting to the cluster.
             */
            authentication?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecConsumerAuthentication>;
            /**
             * A list of host:port pairs for establishing the initial connection to the Kafka cluster.
             */
            bootstrapServers: pulumi.Input<string>;
            /**
             * The MirrorMaker consumer config. Properties with the following prefixes cannot be set: ssl., bootstrap.servers, group.id, sasl., security., interceptor.classes (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
             */
            config?: pulumi.Input<{[key: string]: any}>;
            /**
             * A unique string that identifies the consumer group this consumer belongs to.
             */
            groupId: pulumi.Input<string>;
            /**
             * Specifies the number of consumer stream threads to create.
             */
            numStreams?: pulumi.Input<number>;
            /**
             * Specifies the offset auto-commit interval in ms. Default value is 60000.
             */
            offsetCommitInterval?: pulumi.Input<number>;
            /**
             * TLS configuration for connecting MirrorMaker to the cluster.
             */
            tls?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecConsumerTls>;
        }

        /**
         * Authentication configuration for connecting to the cluster.
         */
        export interface KafkaMirrorMakerSpecConsumerAuthentication {
            /**
             * Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
             */
            accessToken?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecConsumerAuthenticationAccessToken>;
            /**
             * Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
             */
            accessTokenIsJwt?: pulumi.Input<boolean>;
            /**
             * Reference to the `Secret` which holds the certificate and private key pair.
             */
            certificateAndKey?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecConsumerAuthenticationCertificateAndKey>;
            /**
             * OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
             */
            clientId?: pulumi.Input<string>;
            /**
             * Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
             */
            clientSecret?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecConsumerAuthenticationClientSecret>;
            /**
             * Enable or disable TLS hostname verification. Default value is `false`.
             */
            disableTlsHostnameVerification?: pulumi.Input<boolean>;
            /**
             * Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.
             */
            maxTokenExpirySeconds?: pulumi.Input<number>;
            /**
             * Reference to the `Secret` which holds the password.
             */
            passwordSecret?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecConsumerAuthenticationPasswordSecret>;
            /**
             * Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
             */
            refreshToken?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecConsumerAuthenticationRefreshToken>;
            /**
             * OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.
             */
            scope?: pulumi.Input<string>;
            /**
             * Trusted certificates for TLS connection to the OAuth server.
             */
            tlsTrustedCertificates?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecConsumerAuthenticationTlsTrustedCertificates>[]>;
            /**
             * Authorization server token endpoint URI.
             */
            tokenEndpointUri?: pulumi.Input<string>;
            /**
             * Authentication type. Currently the only supported types are `tls`, `scram-sha-512`, and `plain`. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
             */
            type: pulumi.Input<string>;
            /**
             * Username used for the authentication.
             */
            username?: pulumi.Input<string>;
        }

        /**
         * Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
         */
        export interface KafkaMirrorMakerSpecConsumerAuthenticationAccessToken {
            /**
             * The key under which the secret value is stored in the Kubernetes Secret.
             */
            key: pulumi.Input<string>;
            /**
             * The name of the Kubernetes Secret containing the secret value.
             */
            secretName: pulumi.Input<string>;
        }

        /**
         * Reference to the `Secret` which holds the certificate and private key pair.
         */
        export interface KafkaMirrorMakerSpecConsumerAuthenticationCertificateAndKey {
            /**
             * The name of the file certificate in the Secret.
             */
            certificate: pulumi.Input<string>;
            /**
             * The name of the private key in the Secret.
             */
            key: pulumi.Input<string>;
            /**
             * The name of the Secret containing the certificate.
             */
            secretName: pulumi.Input<string>;
        }

        /**
         * Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
         */
        export interface KafkaMirrorMakerSpecConsumerAuthenticationClientSecret {
            /**
             * The key under which the secret value is stored in the Kubernetes Secret.
             */
            key: pulumi.Input<string>;
            /**
             * The name of the Kubernetes Secret containing the secret value.
             */
            secretName: pulumi.Input<string>;
        }

        /**
         * Reference to the `Secret` which holds the password.
         */
        export interface KafkaMirrorMakerSpecConsumerAuthenticationPasswordSecret {
            /**
             * The name of the key in the Secret under which the password is stored.
             */
            password: pulumi.Input<string>;
            /**
             * The name of the Secret containing the password.
             */
            secretName: pulumi.Input<string>;
        }

        /**
         * Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
         */
        export interface KafkaMirrorMakerSpecConsumerAuthenticationRefreshToken {
            /**
             * The key under which the secret value is stored in the Kubernetes Secret.
             */
            key: pulumi.Input<string>;
            /**
             * The name of the Kubernetes Secret containing the secret value.
             */
            secretName: pulumi.Input<string>;
        }

        export interface KafkaMirrorMakerSpecConsumerAuthenticationTlsTrustedCertificates {
            /**
             * The name of the file certificate in the Secret.
             */
            certificate: pulumi.Input<string>;
            /**
             * The name of the Secret containing the certificate.
             */
            secretName: pulumi.Input<string>;
        }

        /**
         * TLS configuration for connecting MirrorMaker to the cluster.
         */
        export interface KafkaMirrorMakerSpecConsumerTls {
            /**
             * Trusted certificates for TLS connection.
             */
            trustedCertificates?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecConsumerTlsTrustedCertificates>[]>;
        }

        export interface KafkaMirrorMakerSpecConsumerTlsTrustedCertificates {
            /**
             * The name of the file certificate in the Secret.
             */
            certificate: pulumi.Input<string>;
            /**
             * The name of the Secret containing the certificate.
             */
            secretName: pulumi.Input<string>;
        }

        /**
         * JVM Options for pods.
         */
        export interface KafkaMirrorMakerSpecJvmOptions {
            /**
             * A map of -XX options to the JVM.
             */
            -XX?: pulumi.Input<{[key: string]: any}>;
            /**
             * -Xms option to to the JVM.
             */
            -Xms?: pulumi.Input<string>;
            /**
             * -Xmx option to to the JVM.
             */
            -Xmx?: pulumi.Input<string>;
            /**
             * Specifies whether the Garbage Collection logging is enabled. The default is false.
             */
            gcLoggingEnabled?: pulumi.Input<boolean>;
            /**
             * A map of additional system properties which will be passed using the `-D` option to the JVM.
             */
            javaSystemProperties?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecJvmOptionsJavaSystemProperties>[]>;
        }

        export interface KafkaMirrorMakerSpecJvmOptionsJavaSystemProperties {
            /**
             * The system property name.
             */
            name?: pulumi.Input<string>;
            /**
             * The system property value.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * Pod liveness checking.
         */
        export interface KafkaMirrorMakerSpecLivenessProbe {
            /**
             * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
             */
            failureThreshold?: pulumi.Input<number>;
            /**
             * The initial delay before first the health is first checked.
             */
            initialDelaySeconds?: pulumi.Input<number>;
            /**
             * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
             */
            successThreshold?: pulumi.Input<number>;
            /**
             * The timeout for each attempted health check.
             */
            timeoutSeconds?: pulumi.Input<number>;
        }

        /**
         * Logging configuration for MirrorMaker.
         */
        export interface KafkaMirrorMakerSpecLogging {
            /**
             * A Map from logger name to logger level.
             */
            loggers?: pulumi.Input<{[key: string]: any}>;
            /**
             * The name of the `ConfigMap` from which to get the logging configuration.
             */
            name?: pulumi.Input<string>;
            /**
             * Logging type, must be either 'inline' or 'external'.
             */
            type: pulumi.Input<string>;
        }

        /**
         * Configuration of target cluster.
         */
        export interface KafkaMirrorMakerSpecProducer {
            /**
             * Flag to set the MirrorMaker to exit on a failed send. Default value is `true`.
             */
            abortOnSendFailure?: pulumi.Input<boolean>;
            /**
             * Authentication configuration for connecting to the cluster.
             */
            authentication?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecProducerAuthentication>;
            /**
             * A list of host:port pairs for establishing the initial connection to the Kafka cluster.
             */
            bootstrapServers: pulumi.Input<string>;
            /**
             * The MirrorMaker producer config. Properties with the following prefixes cannot be set: ssl., bootstrap.servers, sasl., security., interceptor.classes (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
             */
            config?: pulumi.Input<{[key: string]: any}>;
            /**
             * TLS configuration for connecting MirrorMaker to the cluster.
             */
            tls?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecProducerTls>;
        }

        /**
         * Authentication configuration for connecting to the cluster.
         */
        export interface KafkaMirrorMakerSpecProducerAuthentication {
            /**
             * Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
             */
            accessToken?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecProducerAuthenticationAccessToken>;
            /**
             * Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
             */
            accessTokenIsJwt?: pulumi.Input<boolean>;
            /**
             * Reference to the `Secret` which holds the certificate and private key pair.
             */
            certificateAndKey?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecProducerAuthenticationCertificateAndKey>;
            /**
             * OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
             */
            clientId?: pulumi.Input<string>;
            /**
             * Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
             */
            clientSecret?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecProducerAuthenticationClientSecret>;
            /**
             * Enable or disable TLS hostname verification. Default value is `false`.
             */
            disableTlsHostnameVerification?: pulumi.Input<boolean>;
            /**
             * Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.
             */
            maxTokenExpirySeconds?: pulumi.Input<number>;
            /**
             * Reference to the `Secret` which holds the password.
             */
            passwordSecret?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecProducerAuthenticationPasswordSecret>;
            /**
             * Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
             */
            refreshToken?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecProducerAuthenticationRefreshToken>;
            /**
             * OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.
             */
            scope?: pulumi.Input<string>;
            /**
             * Trusted certificates for TLS connection to the OAuth server.
             */
            tlsTrustedCertificates?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecProducerAuthenticationTlsTrustedCertificates>[]>;
            /**
             * Authorization server token endpoint URI.
             */
            tokenEndpointUri?: pulumi.Input<string>;
            /**
             * Authentication type. Currently the only supported types are `tls`, `scram-sha-512`, and `plain`. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
             */
            type: pulumi.Input<string>;
            /**
             * Username used for the authentication.
             */
            username?: pulumi.Input<string>;
        }

        /**
         * Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
         */
        export interface KafkaMirrorMakerSpecProducerAuthenticationAccessToken {
            /**
             * The key under which the secret value is stored in the Kubernetes Secret.
             */
            key: pulumi.Input<string>;
            /**
             * The name of the Kubernetes Secret containing the secret value.
             */
            secretName: pulumi.Input<string>;
        }

        /**
         * Reference to the `Secret` which holds the certificate and private key pair.
         */
        export interface KafkaMirrorMakerSpecProducerAuthenticationCertificateAndKey {
            /**
             * The name of the file certificate in the Secret.
             */
            certificate: pulumi.Input<string>;
            /**
             * The name of the private key in the Secret.
             */
            key: pulumi.Input<string>;
            /**
             * The name of the Secret containing the certificate.
             */
            secretName: pulumi.Input<string>;
        }

        /**
         * Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
         */
        export interface KafkaMirrorMakerSpecProducerAuthenticationClientSecret {
            /**
             * The key under which the secret value is stored in the Kubernetes Secret.
             */
            key: pulumi.Input<string>;
            /**
             * The name of the Kubernetes Secret containing the secret value.
             */
            secretName: pulumi.Input<string>;
        }

        /**
         * Reference to the `Secret` which holds the password.
         */
        export interface KafkaMirrorMakerSpecProducerAuthenticationPasswordSecret {
            /**
             * The name of the key in the Secret under which the password is stored.
             */
            password: pulumi.Input<string>;
            /**
             * The name of the Secret containing the password.
             */
            secretName: pulumi.Input<string>;
        }

        /**
         * Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
         */
        export interface KafkaMirrorMakerSpecProducerAuthenticationRefreshToken {
            /**
             * The key under which the secret value is stored in the Kubernetes Secret.
             */
            key: pulumi.Input<string>;
            /**
             * The name of the Kubernetes Secret containing the secret value.
             */
            secretName: pulumi.Input<string>;
        }

        export interface KafkaMirrorMakerSpecProducerAuthenticationTlsTrustedCertificates {
            /**
             * The name of the file certificate in the Secret.
             */
            certificate: pulumi.Input<string>;
            /**
             * The name of the Secret containing the certificate.
             */
            secretName: pulumi.Input<string>;
        }

        /**
         * TLS configuration for connecting MirrorMaker to the cluster.
         */
        export interface KafkaMirrorMakerSpecProducerTls {
            /**
             * Trusted certificates for TLS connection.
             */
            trustedCertificates?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecProducerTlsTrustedCertificates>[]>;
        }

        export interface KafkaMirrorMakerSpecProducerTlsTrustedCertificates {
            /**
             * The name of the file certificate in the Secret.
             */
            certificate: pulumi.Input<string>;
            /**
             * The name of the Secret containing the certificate.
             */
            secretName: pulumi.Input<string>;
        }

        /**
         * Pod readiness checking.
         */
        export interface KafkaMirrorMakerSpecReadinessProbe {
            /**
             * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
             */
            failureThreshold?: pulumi.Input<number>;
            /**
             * The initial delay before first the health is first checked.
             */
            initialDelaySeconds?: pulumi.Input<number>;
            /**
             * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
             */
            successThreshold?: pulumi.Input<number>;
            /**
             * The timeout for each attempted health check.
             */
            timeoutSeconds?: pulumi.Input<number>;
        }

        /**
         * CPU and memory resources to reserve.
         */
        export interface KafkaMirrorMakerSpecResources {
            limits?: pulumi.Input<{[key: string]: any}>;
            requests?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Template to specify how Kafka MirrorMaker resources, `Deployments` and `Pods`, are generated.
         */
        export interface KafkaMirrorMakerSpecTemplate {
            /**
             * Template for Kafka MirrorMaker `Deployment`.
             */
            deployment?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplateDeployment>;
            /**
             * Template for Kafka MirrorMaker container.
             */
            mirrorMakerContainer?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplateMirrorMakerContainer>;
            /**
             * Template for Kafka MirrorMaker `Pods`.
             */
            pod?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplatePod>;
            /**
             * Template for Kafka MirrorMaker `PodDisruptionBudget`.
             */
            podDisruptionBudget?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplatePodDisruptionBudget>;
        }

        /**
         * Template for Kafka MirrorMaker `Deployment`.
         */
        export interface KafkaMirrorMakerSpecTemplateDeployment {
            /**
             * Metadata applied to the resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplateDeploymentMetadata>;
        }

        /**
         * Metadata applied to the resource.
         */
        export interface KafkaMirrorMakerSpecTemplateDeploymentMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Template for Kafka MirrorMaker container.
         */
        export interface KafkaMirrorMakerSpecTemplateMirrorMakerContainer {
            /**
             * Environment variables which should be applied to the container.
             */
            env?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplateMirrorMakerContainerEnv>[]>;
            /**
             * Security context for the container.
             */
            securityContext?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContext>;
        }

        export interface KafkaMirrorMakerSpecTemplateMirrorMakerContainerEnv {
            /**
             * The environment variable key.
             */
            name?: pulumi.Input<string>;
            /**
             * The environment variable value.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * Security context for the container.
         */
        export interface KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContext {
            allowPrivilegeEscalation?: pulumi.Input<boolean>;
            capabilities?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextCapabilities>;
            privileged?: pulumi.Input<boolean>;
            procMount?: pulumi.Input<string>;
            readOnlyRootFilesystem?: pulumi.Input<boolean>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextSeLinuxOptions>;
            windowsOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextWindowsOptions>;
        }

        export interface KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextCapabilities {
            add?: pulumi.Input<pulumi.Input<string>[]>;
            drop?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
        }

        /**
         * Template for Kafka MirrorMaker `Pods`.
         */
        export interface KafkaMirrorMakerSpecTemplatePod {
            /**
             * The pod's affinity rules.
             */
            affinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplatePodAffinity>;
            /**
             * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
             */
            imagePullSecrets?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplatePodImagePullSecrets>[]>;
            /**
             * Metadata applied to the resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplatePodMetadata>;
            /**
             * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
             */
            priorityClassName?: pulumi.Input<string>;
            /**
             * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
             */
            schedulerName?: pulumi.Input<string>;
            /**
             * Configures pod-level security attributes and common container settings.
             */
            securityContext?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplatePodSecurityContext>;
            /**
             * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
             */
            terminationGracePeriodSeconds?: pulumi.Input<number>;
            /**
             * The pod's tolerations.
             */
            tolerations?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplatePodTolerations>[]>;
        }

        /**
         * The pod's affinity rules.
         */
        export interface KafkaMirrorMakerSpecTemplatePodAffinity {
            nodeAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinity>;
            podAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplatePodAffinityPodAffinity>;
            podAntiAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinity>;
        }

        export interface KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>;
        }

        export interface KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>[]>;
        }

        export interface KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            nodeSelectorTerms?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>[]>;
        }

        export interface KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>[]>;
        }

        export interface KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Template for Kafka MirrorMaker `PodDisruptionBudget`.
         */
        export interface KafkaMirrorMakerSpecTemplatePodDisruptionBudget {
            /**
             * Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
             */
            maxUnavailable?: pulumi.Input<number>;
            /**
             * Metadata to apply to the `PodDistruptionBugetTemplate` resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplatePodDisruptionBudgetMetadata>;
        }

        /**
         * Metadata to apply to the `PodDistruptionBugetTemplate` resource.
         */
        export interface KafkaMirrorMakerSpecTemplatePodDisruptionBudgetMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaMirrorMakerSpecTemplatePodImagePullSecrets {
            name?: pulumi.Input<string>;
        }

        /**
         * Metadata applied to the resource.
         */
        export interface KafkaMirrorMakerSpecTemplatePodMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Configures pod-level security attributes and common container settings.
         */
        export interface KafkaMirrorMakerSpecTemplatePodSecurityContext {
            fsGroup?: pulumi.Input<number>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplatePodSecurityContextSeLinuxOptions>;
            supplementalGroups?: pulumi.Input<pulumi.Input<number>[]>;
            sysctls?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplatePodSecurityContextSysctls>[]>;
            windowsOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerSpecTemplatePodSecurityContextWindowsOptions>;
        }

        export interface KafkaMirrorMakerSpecTemplatePodSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface KafkaMirrorMakerSpecTemplatePodSecurityContextSysctls {
            name?: pulumi.Input<string>;
            value?: pulumi.Input<string>;
        }

        export interface KafkaMirrorMakerSpecTemplatePodSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
        }

        export interface KafkaMirrorMakerSpecTemplatePodTolerations {
            effect?: pulumi.Input<string>;
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            tolerationSeconds?: pulumi.Input<number>;
            value?: pulumi.Input<string>;
        }

        export interface KafkaMirrorMakerSpecTolerations {
            effect?: pulumi.Input<string>;
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            tolerationSeconds?: pulumi.Input<number>;
            value?: pulumi.Input<string>;
        }

        /**
         * The configuration of tracing in Kafka MirrorMaker.
         */
        export interface KafkaMirrorMakerSpecTracing {
            /**
             * Type of the tracing used. Currently the only supported type is `jaeger` for Jaeger tracing.
             */
            type: pulumi.Input<string>;
        }

        /**
         * The status of Kafka MirrorMaker.
         */
        export interface KafkaMirrorMakerStatus {
            /**
             * List of status conditions.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerStatusConditions>[]>;
            /**
             * The generation of the CRD that was last reconciled by the operator.
             */
            observedGeneration?: pulumi.Input<number>;
            /**
             * Label selector for pods providing this resource.
             */
            podSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerStatusPodSelector>;
            /**
             * The current number of pods being used to provide this resource.
             */
            replicas?: pulumi.Input<number>;
        }

        export interface KafkaMirrorMakerStatusConditions {
            /**
             * Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
             */
            lastTransitionTime?: pulumi.Input<string>;
            /**
             * Human-readable message indicating details about the condition's last transition.
             */
            message?: pulumi.Input<string>;
            /**
             * The reason for the condition's last transition (a single word in CamelCase).
             */
            reason?: pulumi.Input<string>;
            /**
             * The status of the condition, either True, False or Unknown.
             */
            status?: pulumi.Input<string>;
            /**
             * The unique identifier of a condition, used to distinguish between other conditions in the resource.
             */
            type?: pulumi.Input<string>;
        }

        /**
         * Label selector for pods providing this resource.
         */
        export interface KafkaMirrorMakerStatusPodSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaMirrorMakerStatusPodSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaMirrorMakerStatusPodSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * The specification of the Kafka and ZooKeeper clusters, and Topic Operator.
         */
        export interface KafkaSpec {
            /**
             * Configuration of the clients certificate authority.
             */
            clientsCa?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecClientsCa>;
            /**
             * Configuration of the cluster certificate authority.
             */
            clusterCa?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecClusterCa>;
            /**
             * Configuration for Cruise Control deployment. Deploys a Cruise Control instance when specified.
             */
            cruiseControl?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControl>;
            /**
             * Configuration of the Entity Operator.
             */
            entityOperator?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperator>;
            /**
             * Configuration for JmxTrans. When the property is present a JmxTrans deployment is created for gathering JMX metrics from each Kafka broker. For more information see https://github.com/jmxtrans/jmxtrans[JmxTrans GitHub].
             */
            jmxTrans?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTrans>;
            /**
             * Configuration of the Kafka cluster.
             */
            kafka: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafka>;
            /**
             * Configuration of the Kafka Exporter. Kafka Exporter can provide additional metrics, for example lag of consumer group at topic/partition.
             */
            kafkaExporter?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporter>;
            /**
             * A list of time windows for maintenance tasks (that is, certificates renewal). Each time window is defined by a cron expression.
             */
            maintenanceTimeWindows?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Configuration of the Topic Operator.
             */
            topicOperator?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecTopicOperator>;
            /**
             * Configuration of the ZooKeeper cluster.
             */
            zookeeper: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeper>;
        }

        /**
         * Configuration of the clients certificate authority.
         */
        export interface KafkaSpecClientsCa {
            /**
             * How should CA certificate expiration be handled when `generateCertificateAuthority=true`. The default is for a new CA certificate to be generated reusing the existing private key.
             */
            certificateExpirationPolicy?: pulumi.Input<string>;
            /**
             * If true then Certificate Authority certificates will be generated automatically. Otherwise the user will need to provide a Secret with the CA certificate. Default is true.
             */
            generateCertificateAuthority?: pulumi.Input<boolean>;
            /**
             * The number of days in the certificate renewal period. This is the number of days before the a certificate expires during which renewal actions may be performed. When `generateCertificateAuthority` is true, this will cause the generation of a new certificate. When `generateCertificateAuthority` is true, this will cause extra logging at WARN level about the pending certificate expiry. Default is 30.
             */
            renewalDays?: pulumi.Input<number>;
            /**
             * The number of days generated certificates should be valid for. The default is 365.
             */
            validityDays?: pulumi.Input<number>;
        }

        /**
         * Configuration of the cluster certificate authority.
         */
        export interface KafkaSpecClusterCa {
            /**
             * How should CA certificate expiration be handled when `generateCertificateAuthority=true`. The default is for a new CA certificate to be generated reusing the existing private key.
             */
            certificateExpirationPolicy?: pulumi.Input<string>;
            /**
             * If true then Certificate Authority certificates will be generated automatically. Otherwise the user will need to provide a Secret with the CA certificate. Default is true.
             */
            generateCertificateAuthority?: pulumi.Input<boolean>;
            /**
             * The number of days in the certificate renewal period. This is the number of days before the a certificate expires during which renewal actions may be performed. When `generateCertificateAuthority` is true, this will cause the generation of a new certificate. When `generateCertificateAuthority` is true, this will cause extra logging at WARN level about the pending certificate expiry. Default is 30.
             */
            renewalDays?: pulumi.Input<number>;
            /**
             * The number of days generated certificates should be valid for. The default is 365.
             */
            validityDays?: pulumi.Input<number>;
        }

        /**
         * Configuration for Cruise Control deployment. Deploys a Cruise Control instance when specified.
         */
        export interface KafkaSpecCruiseControl {
            /**
             * The Cruise Control `brokerCapacity` configuration.
             */
            brokerCapacity?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlBrokerCapacity>;
            /**
             * The Cruise Control configuration. For a full list of configuration options refer to https://github.com/linkedin/cruise-control/wiki/Configurations. Note that properties with the following prefixes cannot be set: bootstrap.servers, client.id, zookeeper., network., security., failed.brokers.zk.path,webserver.http., webserver.api.urlprefix, webserver.session.path, webserver.accesslog., two.step., request.reason.required,metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, partition.metric.sample.store.topic, broker.metric.sample.store.topic,capacity.config.file, self.healing., anomaly.detection., ssl.
             */
            config?: pulumi.Input<{[key: string]: any}>;
            /**
             * The docker image for the pods.
             */
            image?: pulumi.Input<string>;
            /**
             * JVM Options for the Cruise Control container.
             */
            jvmOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlJvmOptions>;
            /**
             * Pod liveness checking for the Cruise Control container.
             */
            livenessProbe?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlLivenessProbe>;
            /**
             * Logging configuration (log4j1) for Cruise Control.
             */
            logging?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlLogging>;
            /**
             * Pod readiness checking for the Cruise Control container.
             */
            readinessProbe?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlReadinessProbe>;
            /**
             * CPU and memory resources to reserve for the Cruise Control container.
             */
            resources?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlResources>;
            /**
             * Template to specify how Cruise Control resources, `Deployments` and `Pods`, are generated.
             */
            template?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplate>;
            /**
             * TLS sidecar configuration.
             */
            tlsSidecar?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTlsSidecar>;
        }

        /**
         * The Cruise Control `brokerCapacity` configuration.
         */
        export interface KafkaSpecCruiseControlBrokerCapacity {
            /**
             * Broker capacity for CPU resource utilization as a percentage (0 - 100).
             */
            cpuUtilization?: pulumi.Input<number>;
            /**
             * Broker capacity for disk in bytes, for example, 100Gi.
             */
            disk?: pulumi.Input<string>;
            /**
             * Broker capacity for inbound network throughput in bytes per second, for example, 10000KB/s.
             */
            inboundNetwork?: pulumi.Input<string>;
            /**
             * Broker capacity for outbound network throughput in bytes per second, for example 10000KB/s.
             */
            outboundNetwork?: pulumi.Input<string>;
        }

        /**
         * JVM Options for the Cruise Control container.
         */
        export interface KafkaSpecCruiseControlJvmOptions {
            /**
             * A map of -XX options to the JVM.
             */
            -XX?: pulumi.Input<{[key: string]: any}>;
            /**
             * -Xms option to to the JVM.
             */
            -Xms?: pulumi.Input<string>;
            /**
             * -Xmx option to to the JVM.
             */
            -Xmx?: pulumi.Input<string>;
            /**
             * Specifies whether the Garbage Collection logging is enabled. The default is false.
             */
            gcLoggingEnabled?: pulumi.Input<boolean>;
            /**
             * A map of additional system properties which will be passed using the `-D` option to the JVM.
             */
            javaSystemProperties?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlJvmOptionsJavaSystemProperties>[]>;
        }

        export interface KafkaSpecCruiseControlJvmOptionsJavaSystemProperties {
            /**
             * The system property name.
             */
            name?: pulumi.Input<string>;
            /**
             * The system property value.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * Pod liveness checking for the Cruise Control container.
         */
        export interface KafkaSpecCruiseControlLivenessProbe {
            /**
             * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
             */
            failureThreshold?: pulumi.Input<number>;
            /**
             * The initial delay before first the health is first checked.
             */
            initialDelaySeconds?: pulumi.Input<number>;
            /**
             * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
             */
            successThreshold?: pulumi.Input<number>;
            /**
             * The timeout for each attempted health check.
             */
            timeoutSeconds?: pulumi.Input<number>;
        }

        /**
         * Logging configuration (log4j1) for Cruise Control.
         */
        export interface KafkaSpecCruiseControlLogging {
            /**
             * A Map from logger name to logger level.
             */
            loggers?: pulumi.Input<{[key: string]: any}>;
            /**
             * The name of the `ConfigMap` from which to get the logging configuration.
             */
            name?: pulumi.Input<string>;
            /**
             * Logging type, must be either 'inline' or 'external'.
             */
            type: pulumi.Input<string>;
        }

        /**
         * Pod readiness checking for the Cruise Control container.
         */
        export interface KafkaSpecCruiseControlReadinessProbe {
            /**
             * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
             */
            failureThreshold?: pulumi.Input<number>;
            /**
             * The initial delay before first the health is first checked.
             */
            initialDelaySeconds?: pulumi.Input<number>;
            /**
             * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
             */
            successThreshold?: pulumi.Input<number>;
            /**
             * The timeout for each attempted health check.
             */
            timeoutSeconds?: pulumi.Input<number>;
        }

        /**
         * CPU and memory resources to reserve for the Cruise Control container.
         */
        export interface KafkaSpecCruiseControlResources {
            limits?: pulumi.Input<{[key: string]: any}>;
            requests?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Template to specify how Cruise Control resources, `Deployments` and `Pods`, are generated.
         */
        export interface KafkaSpecCruiseControlTemplate {
            /**
             * Template for Cruise Control API `Service`.
             */
            apiService?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplateApiService>;
            /**
             * Template for the Cruise Control container.
             */
            cruiseControlContainer?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplateCruiseControlContainer>;
            /**
             * Template for Cruise Control `Deployment`.
             */
            deployment?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplateDeployment>;
            /**
             * Template for Cruise Control `Pods`.
             */
            pod?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplatePod>;
            /**
             * Template for Cruise Control `PodDisruptionBudget`.
             */
            podDisruptionBudget?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplatePodDisruptionBudget>;
            /**
             * Template for the Cruise Control TLS sidecar container.
             */
            tlsSidecarContainer?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplateTlsSidecarContainer>;
        }

        /**
         * Template for Cruise Control API `Service`.
         */
        export interface KafkaSpecCruiseControlTemplateApiService {
            /**
             * Metadata applied to the resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplateApiServiceMetadata>;
        }

        /**
         * Metadata applied to the resource.
         */
        export interface KafkaSpecCruiseControlTemplateApiServiceMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Template for the Cruise Control container.
         */
        export interface KafkaSpecCruiseControlTemplateCruiseControlContainer {
            /**
             * Environment variables which should be applied to the container.
             */
            env?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplateCruiseControlContainerEnv>[]>;
            /**
             * Security context for the container.
             */
            securityContext?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext>;
        }

        export interface KafkaSpecCruiseControlTemplateCruiseControlContainerEnv {
            /**
             * The environment variable key.
             */
            name?: pulumi.Input<string>;
            /**
             * The environment variable value.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * Security context for the container.
         */
        export interface KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext {
            allowPrivilegeEscalation?: pulumi.Input<boolean>;
            capabilities?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextCapabilities>;
            privileged?: pulumi.Input<boolean>;
            procMount?: pulumi.Input<string>;
            readOnlyRootFilesystem?: pulumi.Input<boolean>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions>;
            windowsOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptions>;
        }

        export interface KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextCapabilities {
            add?: pulumi.Input<pulumi.Input<string>[]>;
            drop?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
        }

        /**
         * Template for Cruise Control `Deployment`.
         */
        export interface KafkaSpecCruiseControlTemplateDeployment {
            /**
             * Metadata applied to the resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplateDeploymentMetadata>;
        }

        /**
         * Metadata applied to the resource.
         */
        export interface KafkaSpecCruiseControlTemplateDeploymentMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Template for Cruise Control `Pods`.
         */
        export interface KafkaSpecCruiseControlTemplatePod {
            /**
             * The pod's affinity rules.
             */
            affinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplatePodAffinity>;
            /**
             * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
             */
            imagePullSecrets?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplatePodImagePullSecrets>[]>;
            /**
             * Metadata applied to the resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplatePodMetadata>;
            /**
             * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
             */
            priorityClassName?: pulumi.Input<string>;
            /**
             * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
             */
            schedulerName?: pulumi.Input<string>;
            /**
             * Configures pod-level security attributes and common container settings.
             */
            securityContext?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplatePodSecurityContext>;
            /**
             * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
             */
            terminationGracePeriodSeconds?: pulumi.Input<number>;
            /**
             * The pod's tolerations.
             */
            tolerations?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplatePodTolerations>[]>;
        }

        /**
         * The pod's affinity rules.
         */
        export interface KafkaSpecCruiseControlTemplatePodAffinity {
            nodeAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplatePodAffinityNodeAffinity>;
            podAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplatePodAffinityPodAffinity>;
            podAntiAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinity>;
        }

        export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>;
        }

        export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>[]>;
        }

        export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            nodeSelectorTerms?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>[]>;
        }

        export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>[]>;
        }

        export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Template for Cruise Control `PodDisruptionBudget`.
         */
        export interface KafkaSpecCruiseControlTemplatePodDisruptionBudget {
            /**
             * Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
             */
            maxUnavailable?: pulumi.Input<number>;
            /**
             * Metadata to apply to the `PodDistruptionBugetTemplate` resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadata>;
        }

        /**
         * Metadata to apply to the `PodDistruptionBugetTemplate` resource.
         */
        export interface KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecCruiseControlTemplatePodImagePullSecrets {
            name?: pulumi.Input<string>;
        }

        /**
         * Metadata applied to the resource.
         */
        export interface KafkaSpecCruiseControlTemplatePodMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Configures pod-level security attributes and common container settings.
         */
        export interface KafkaSpecCruiseControlTemplatePodSecurityContext {
            fsGroup?: pulumi.Input<number>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions>;
            supplementalGroups?: pulumi.Input<pulumi.Input<number>[]>;
            sysctls?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplatePodSecurityContextSysctls>[]>;
            windowsOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptions>;
        }

        export interface KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface KafkaSpecCruiseControlTemplatePodSecurityContextSysctls {
            name?: pulumi.Input<string>;
            value?: pulumi.Input<string>;
        }

        export interface KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
        }

        export interface KafkaSpecCruiseControlTemplatePodTolerations {
            effect?: pulumi.Input<string>;
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            tolerationSeconds?: pulumi.Input<number>;
            value?: pulumi.Input<string>;
        }

        /**
         * Template for the Cruise Control TLS sidecar container.
         */
        export interface KafkaSpecCruiseControlTemplateTlsSidecarContainer {
            /**
             * Environment variables which should be applied to the container.
             */
            env?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplateTlsSidecarContainerEnv>[]>;
            /**
             * Security context for the container.
             */
            securityContext?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext>;
        }

        export interface KafkaSpecCruiseControlTemplateTlsSidecarContainerEnv {
            /**
             * The environment variable key.
             */
            name?: pulumi.Input<string>;
            /**
             * The environment variable value.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * Security context for the container.
         */
        export interface KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext {
            allowPrivilegeEscalation?: pulumi.Input<boolean>;
            capabilities?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextCapabilities>;
            privileged?: pulumi.Input<boolean>;
            procMount?: pulumi.Input<string>;
            readOnlyRootFilesystem?: pulumi.Input<boolean>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions>;
            windowsOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptions>;
        }

        export interface KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextCapabilities {
            add?: pulumi.Input<pulumi.Input<string>[]>;
            drop?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
        }

        /**
         * TLS sidecar configuration.
         */
        export interface KafkaSpecCruiseControlTlsSidecar {
            /**
             * The docker image for the container.
             */
            image?: pulumi.Input<string>;
            /**
             * Pod liveness checking.
             */
            livenessProbe?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTlsSidecarLivenessProbe>;
            /**
             * The log level for the TLS sidecar. Default value is `notice`.
             */
            logLevel?: pulumi.Input<string>;
            /**
             * Pod readiness checking.
             */
            readinessProbe?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTlsSidecarReadinessProbe>;
            /**
             * CPU and memory resources to reserve.
             */
            resources?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecCruiseControlTlsSidecarResources>;
        }

        /**
         * Pod liveness checking.
         */
        export interface KafkaSpecCruiseControlTlsSidecarLivenessProbe {
            /**
             * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
             */
            failureThreshold?: pulumi.Input<number>;
            /**
             * The initial delay before first the health is first checked.
             */
            initialDelaySeconds?: pulumi.Input<number>;
            /**
             * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
             */
            successThreshold?: pulumi.Input<number>;
            /**
             * The timeout for each attempted health check.
             */
            timeoutSeconds?: pulumi.Input<number>;
        }

        /**
         * Pod readiness checking.
         */
        export interface KafkaSpecCruiseControlTlsSidecarReadinessProbe {
            /**
             * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
             */
            failureThreshold?: pulumi.Input<number>;
            /**
             * The initial delay before first the health is first checked.
             */
            initialDelaySeconds?: pulumi.Input<number>;
            /**
             * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
             */
            successThreshold?: pulumi.Input<number>;
            /**
             * The timeout for each attempted health check.
             */
            timeoutSeconds?: pulumi.Input<number>;
        }

        /**
         * CPU and memory resources to reserve.
         */
        export interface KafkaSpecCruiseControlTlsSidecarResources {
            limits?: pulumi.Input<{[key: string]: any}>;
            requests?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Configuration of the Entity Operator.
         */
        export interface KafkaSpecEntityOperator {
            /**
             * The pod's affinity rules.
             */
            affinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorAffinity>;
            /**
             * Template for Entity Operator resources. The template allows users to specify how is the `Deployment` and `Pods` generated.
             */
            template?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplate>;
            /**
             * TLS sidecar configuration.
             */
            tlsSidecar?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTlsSidecar>;
            /**
             * The pod's tolerations.
             */
            tolerations?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTolerations>[]>;
            /**
             * Configuration of the Topic Operator.
             */
            topicOperator?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTopicOperator>;
            /**
             * Configuration of the User Operator.
             */
            userOperator?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorUserOperator>;
        }

        /**
         * The pod's affinity rules.
         */
        export interface KafkaSpecEntityOperatorAffinity {
            nodeAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorAffinityNodeAffinity>;
            podAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorAffinityPodAffinity>;
            podAntiAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorAffinityPodAntiAffinity>;
        }

        export interface KafkaSpecEntityOperatorAffinityNodeAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>;
        }

        export interface KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>[]>;
        }

        export interface KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            nodeSelectorTerms?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>[]>;
        }

        export interface KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>[]>;
        }

        export interface KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecEntityOperatorAffinityPodAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecEntityOperatorAffinityPodAntiAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Template for Entity Operator resources. The template allows users to specify how is the `Deployment` and `Pods` generated.
         */
        export interface KafkaSpecEntityOperatorTemplate {
            /**
             * Template for Entity Operator `Deployment`.
             */
            deployment?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplateDeployment>;
            /**
             * Template for Entity Operator `Pods`.
             */
            pod?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplatePod>;
            /**
             * Template for the Entity Operator TLS sidecar container.
             */
            tlsSidecarContainer?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplateTlsSidecarContainer>;
            /**
             * Template for the Entity Topic Operator container.
             */
            topicOperatorContainer?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplateTopicOperatorContainer>;
            /**
             * Template for the Entity User Operator container.
             */
            userOperatorContainer?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplateUserOperatorContainer>;
        }

        /**
         * Template for Entity Operator `Deployment`.
         */
        export interface KafkaSpecEntityOperatorTemplateDeployment {
            /**
             * Metadata applied to the resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplateDeploymentMetadata>;
        }

        /**
         * Metadata applied to the resource.
         */
        export interface KafkaSpecEntityOperatorTemplateDeploymentMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Template for Entity Operator `Pods`.
         */
        export interface KafkaSpecEntityOperatorTemplatePod {
            /**
             * The pod's affinity rules.
             */
            affinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplatePodAffinity>;
            /**
             * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
             */
            imagePullSecrets?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplatePodImagePullSecrets>[]>;
            /**
             * Metadata applied to the resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplatePodMetadata>;
            /**
             * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
             */
            priorityClassName?: pulumi.Input<string>;
            /**
             * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
             */
            schedulerName?: pulumi.Input<string>;
            /**
             * Configures pod-level security attributes and common container settings.
             */
            securityContext?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplatePodSecurityContext>;
            /**
             * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
             */
            terminationGracePeriodSeconds?: pulumi.Input<number>;
            /**
             * The pod's tolerations.
             */
            tolerations?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplatePodTolerations>[]>;
        }

        /**
         * The pod's affinity rules.
         */
        export interface KafkaSpecEntityOperatorTemplatePodAffinity {
            nodeAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinity>;
            podAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplatePodAffinityPodAffinity>;
            podAntiAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinity>;
        }

        export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>;
        }

        export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>[]>;
        }

        export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            nodeSelectorTerms?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>[]>;
        }

        export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>[]>;
        }

        export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecEntityOperatorTemplatePodImagePullSecrets {
            name?: pulumi.Input<string>;
        }

        /**
         * Metadata applied to the resource.
         */
        export interface KafkaSpecEntityOperatorTemplatePodMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Configures pod-level security attributes and common container settings.
         */
        export interface KafkaSpecEntityOperatorTemplatePodSecurityContext {
            fsGroup?: pulumi.Input<number>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions>;
            supplementalGroups?: pulumi.Input<pulumi.Input<number>[]>;
            sysctls?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplatePodSecurityContextSysctls>[]>;
            windowsOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptions>;
        }

        export interface KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface KafkaSpecEntityOperatorTemplatePodSecurityContextSysctls {
            name?: pulumi.Input<string>;
            value?: pulumi.Input<string>;
        }

        export interface KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
        }

        export interface KafkaSpecEntityOperatorTemplatePodTolerations {
            effect?: pulumi.Input<string>;
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            tolerationSeconds?: pulumi.Input<number>;
            value?: pulumi.Input<string>;
        }

        /**
         * Template for the Entity Operator TLS sidecar container.
         */
        export interface KafkaSpecEntityOperatorTemplateTlsSidecarContainer {
            /**
             * Environment variables which should be applied to the container.
             */
            env?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplateTlsSidecarContainerEnv>[]>;
            /**
             * Security context for the container.
             */
            securityContext?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext>;
        }

        export interface KafkaSpecEntityOperatorTemplateTlsSidecarContainerEnv {
            /**
             * The environment variable key.
             */
            name?: pulumi.Input<string>;
            /**
             * The environment variable value.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * Security context for the container.
         */
        export interface KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext {
            allowPrivilegeEscalation?: pulumi.Input<boolean>;
            capabilities?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextCapabilities>;
            privileged?: pulumi.Input<boolean>;
            procMount?: pulumi.Input<string>;
            readOnlyRootFilesystem?: pulumi.Input<boolean>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions>;
            windowsOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptions>;
        }

        export interface KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextCapabilities {
            add?: pulumi.Input<pulumi.Input<string>[]>;
            drop?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
        }

        /**
         * Template for the Entity Topic Operator container.
         */
        export interface KafkaSpecEntityOperatorTemplateTopicOperatorContainer {
            /**
             * Environment variables which should be applied to the container.
             */
            env?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplateTopicOperatorContainerEnv>[]>;
            /**
             * Security context for the container.
             */
            securityContext?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext>;
        }

        export interface KafkaSpecEntityOperatorTemplateTopicOperatorContainerEnv {
            /**
             * The environment variable key.
             */
            name?: pulumi.Input<string>;
            /**
             * The environment variable value.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * Security context for the container.
         */
        export interface KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext {
            allowPrivilegeEscalation?: pulumi.Input<boolean>;
            capabilities?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextCapabilities>;
            privileged?: pulumi.Input<boolean>;
            procMount?: pulumi.Input<string>;
            readOnlyRootFilesystem?: pulumi.Input<boolean>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions>;
            windowsOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptions>;
        }

        export interface KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextCapabilities {
            add?: pulumi.Input<pulumi.Input<string>[]>;
            drop?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
        }

        /**
         * Template for the Entity User Operator container.
         */
        export interface KafkaSpecEntityOperatorTemplateUserOperatorContainer {
            /**
             * Environment variables which should be applied to the container.
             */
            env?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplateUserOperatorContainerEnv>[]>;
            /**
             * Security context for the container.
             */
            securityContext?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext>;
        }

        export interface KafkaSpecEntityOperatorTemplateUserOperatorContainerEnv {
            /**
             * The environment variable key.
             */
            name?: pulumi.Input<string>;
            /**
             * The environment variable value.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * Security context for the container.
         */
        export interface KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext {
            allowPrivilegeEscalation?: pulumi.Input<boolean>;
            capabilities?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextCapabilities>;
            privileged?: pulumi.Input<boolean>;
            procMount?: pulumi.Input<string>;
            readOnlyRootFilesystem?: pulumi.Input<boolean>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions>;
            windowsOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptions>;
        }

        export interface KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextCapabilities {
            add?: pulumi.Input<pulumi.Input<string>[]>;
            drop?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
        }

        /**
         * TLS sidecar configuration.
         */
        export interface KafkaSpecEntityOperatorTlsSidecar {
            /**
             * The docker image for the container.
             */
            image?: pulumi.Input<string>;
            /**
             * Pod liveness checking.
             */
            livenessProbe?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTlsSidecarLivenessProbe>;
            /**
             * The log level for the TLS sidecar. Default value is `notice`.
             */
            logLevel?: pulumi.Input<string>;
            /**
             * Pod readiness checking.
             */
            readinessProbe?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTlsSidecarReadinessProbe>;
            /**
             * CPU and memory resources to reserve.
             */
            resources?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTlsSidecarResources>;
        }

        /**
         * Pod liveness checking.
         */
        export interface KafkaSpecEntityOperatorTlsSidecarLivenessProbe {
            /**
             * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
             */
            failureThreshold?: pulumi.Input<number>;
            /**
             * The initial delay before first the health is first checked.
             */
            initialDelaySeconds?: pulumi.Input<number>;
            /**
             * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
             */
            successThreshold?: pulumi.Input<number>;
            /**
             * The timeout for each attempted health check.
             */
            timeoutSeconds?: pulumi.Input<number>;
        }

        /**
         * Pod readiness checking.
         */
        export interface KafkaSpecEntityOperatorTlsSidecarReadinessProbe {
            /**
             * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
             */
            failureThreshold?: pulumi.Input<number>;
            /**
             * The initial delay before first the health is first checked.
             */
            initialDelaySeconds?: pulumi.Input<number>;
            /**
             * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
             */
            successThreshold?: pulumi.Input<number>;
            /**
             * The timeout for each attempted health check.
             */
            timeoutSeconds?: pulumi.Input<number>;
        }

        /**
         * CPU and memory resources to reserve.
         */
        export interface KafkaSpecEntityOperatorTlsSidecarResources {
            limits?: pulumi.Input<{[key: string]: any}>;
            requests?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecEntityOperatorTolerations {
            effect?: pulumi.Input<string>;
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            tolerationSeconds?: pulumi.Input<number>;
            value?: pulumi.Input<string>;
        }

        /**
         * Configuration of the Topic Operator.
         */
        export interface KafkaSpecEntityOperatorTopicOperator {
            /**
             * The image to use for the Topic Operator.
             */
            image?: pulumi.Input<string>;
            /**
             * JVM Options for pods.
             */
            jvmOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTopicOperatorJvmOptions>;
            /**
             * Pod liveness checking.
             */
            livenessProbe?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTopicOperatorLivenessProbe>;
            /**
             * Logging configuration.
             */
            logging?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTopicOperatorLogging>;
            /**
             * Pod readiness checking.
             */
            readinessProbe?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTopicOperatorReadinessProbe>;
            /**
             * Interval between periodic reconciliations.
             */
            reconciliationIntervalSeconds?: pulumi.Input<number>;
            /**
             * CPU and memory resources to reserve.
             */
            resources?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTopicOperatorResources>;
            /**
             * The number of attempts at getting topic metadata.
             */
            topicMetadataMaxAttempts?: pulumi.Input<number>;
            /**
             * The namespace the Topic Operator should watch.
             */
            watchedNamespace?: pulumi.Input<string>;
            /**
             * Timeout for the ZooKeeper session.
             */
            zookeeperSessionTimeoutSeconds?: pulumi.Input<number>;
        }

        /**
         * JVM Options for pods.
         */
        export interface KafkaSpecEntityOperatorTopicOperatorJvmOptions {
            /**
             * A map of -XX options to the JVM.
             */
            -XX?: pulumi.Input<{[key: string]: any}>;
            /**
             * -Xms option to to the JVM.
             */
            -Xms?: pulumi.Input<string>;
            /**
             * -Xmx option to to the JVM.
             */
            -Xmx?: pulumi.Input<string>;
            /**
             * Specifies whether the Garbage Collection logging is enabled. The default is false.
             */
            gcLoggingEnabled?: pulumi.Input<boolean>;
            /**
             * A map of additional system properties which will be passed using the `-D` option to the JVM.
             */
            javaSystemProperties?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorTopicOperatorJvmOptionsJavaSystemProperties>[]>;
        }

        export interface KafkaSpecEntityOperatorTopicOperatorJvmOptionsJavaSystemProperties {
            /**
             * The system property name.
             */
            name?: pulumi.Input<string>;
            /**
             * The system property value.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * Pod liveness checking.
         */
        export interface KafkaSpecEntityOperatorTopicOperatorLivenessProbe {
            /**
             * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
             */
            failureThreshold?: pulumi.Input<number>;
            /**
             * The initial delay before first the health is first checked.
             */
            initialDelaySeconds?: pulumi.Input<number>;
            /**
             * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
             */
            successThreshold?: pulumi.Input<number>;
            /**
             * The timeout for each attempted health check.
             */
            timeoutSeconds?: pulumi.Input<number>;
        }

        /**
         * Logging configuration.
         */
        export interface KafkaSpecEntityOperatorTopicOperatorLogging {
            /**
             * A Map from logger name to logger level.
             */
            loggers?: pulumi.Input<{[key: string]: any}>;
            /**
             * The name of the `ConfigMap` from which to get the logging configuration.
             */
            name?: pulumi.Input<string>;
            /**
             * Logging type, must be either 'inline' or 'external'.
             */
            type: pulumi.Input<string>;
        }

        /**
         * Pod readiness checking.
         */
        export interface KafkaSpecEntityOperatorTopicOperatorReadinessProbe {
            /**
             * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
             */
            failureThreshold?: pulumi.Input<number>;
            /**
             * The initial delay before first the health is first checked.
             */
            initialDelaySeconds?: pulumi.Input<number>;
            /**
             * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
             */
            successThreshold?: pulumi.Input<number>;
            /**
             * The timeout for each attempted health check.
             */
            timeoutSeconds?: pulumi.Input<number>;
        }

        /**
         * CPU and memory resources to reserve.
         */
        export interface KafkaSpecEntityOperatorTopicOperatorResources {
            limits?: pulumi.Input<{[key: string]: any}>;
            requests?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Configuration of the User Operator.
         */
        export interface KafkaSpecEntityOperatorUserOperator {
            /**
             * The image to use for the User Operator.
             */
            image?: pulumi.Input<string>;
            /**
             * JVM Options for pods.
             */
            jvmOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorUserOperatorJvmOptions>;
            /**
             * Pod liveness checking.
             */
            livenessProbe?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorUserOperatorLivenessProbe>;
            /**
             * Logging configuration.
             */
            logging?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorUserOperatorLogging>;
            /**
             * Pod readiness checking.
             */
            readinessProbe?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorUserOperatorReadinessProbe>;
            /**
             * Interval between periodic reconciliations.
             */
            reconciliationIntervalSeconds?: pulumi.Input<number>;
            /**
             * CPU and memory resources to reserve.
             */
            resources?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorUserOperatorResources>;
            /**
             * The namespace the User Operator should watch.
             */
            watchedNamespace?: pulumi.Input<string>;
            /**
             * Timeout for the ZooKeeper session.
             */
            zookeeperSessionTimeoutSeconds?: pulumi.Input<number>;
        }

        /**
         * JVM Options for pods.
         */
        export interface KafkaSpecEntityOperatorUserOperatorJvmOptions {
            /**
             * A map of -XX options to the JVM.
             */
            -XX?: pulumi.Input<{[key: string]: any}>;
            /**
             * -Xms option to to the JVM.
             */
            -Xms?: pulumi.Input<string>;
            /**
             * -Xmx option to to the JVM.
             */
            -Xmx?: pulumi.Input<string>;
            /**
             * Specifies whether the Garbage Collection logging is enabled. The default is false.
             */
            gcLoggingEnabled?: pulumi.Input<boolean>;
            /**
             * A map of additional system properties which will be passed using the `-D` option to the JVM.
             */
            javaSystemProperties?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecEntityOperatorUserOperatorJvmOptionsJavaSystemProperties>[]>;
        }

        export interface KafkaSpecEntityOperatorUserOperatorJvmOptionsJavaSystemProperties {
            /**
             * The system property name.
             */
            name?: pulumi.Input<string>;
            /**
             * The system property value.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * Pod liveness checking.
         */
        export interface KafkaSpecEntityOperatorUserOperatorLivenessProbe {
            /**
             * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
             */
            failureThreshold?: pulumi.Input<number>;
            /**
             * The initial delay before first the health is first checked.
             */
            initialDelaySeconds?: pulumi.Input<number>;
            /**
             * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
             */
            successThreshold?: pulumi.Input<number>;
            /**
             * The timeout for each attempted health check.
             */
            timeoutSeconds?: pulumi.Input<number>;
        }

        /**
         * Logging configuration.
         */
        export interface KafkaSpecEntityOperatorUserOperatorLogging {
            /**
             * A Map from logger name to logger level.
             */
            loggers?: pulumi.Input<{[key: string]: any}>;
            /**
             * The name of the `ConfigMap` from which to get the logging configuration.
             */
            name?: pulumi.Input<string>;
            /**
             * Logging type, must be either 'inline' or 'external'.
             */
            type: pulumi.Input<string>;
        }

        /**
         * Pod readiness checking.
         */
        export interface KafkaSpecEntityOperatorUserOperatorReadinessProbe {
            /**
             * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
             */
            failureThreshold?: pulumi.Input<number>;
            /**
             * The initial delay before first the health is first checked.
             */
            initialDelaySeconds?: pulumi.Input<number>;
            /**
             * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
             */
            successThreshold?: pulumi.Input<number>;
            /**
             * The timeout for each attempted health check.
             */
            timeoutSeconds?: pulumi.Input<number>;
        }

        /**
         * CPU and memory resources to reserve.
         */
        export interface KafkaSpecEntityOperatorUserOperatorResources {
            limits?: pulumi.Input<{[key: string]: any}>;
            requests?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Configuration for JmxTrans. When the property is present a JmxTrans deployment is created for gathering JMX metrics from each Kafka broker. For more information see https://github.com/jmxtrans/jmxtrans[JmxTrans GitHub].
         */
        export interface KafkaSpecJmxTrans {
            /**
             * The image to use for the JmxTrans.
             */
            image?: pulumi.Input<string>;
            /**
             * Queries to send to the Kafka brokers to define what data should be read from each broker. For more information on these properties see, xref:type-JmxTransQueryTemplate-reference[`JmxTransQueryTemplate` schema reference].
             */
            kafkaQueries: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransKafkaQueries>[]>;
            /**
             * Sets the logging level of the JmxTrans deployment.For more information see, https://github.com/jmxtrans/jmxtrans-agent/wiki/Troubleshooting[JmxTrans Logging Level].
             */
            logLevel?: pulumi.Input<string>;
            /**
             * Defines the output hosts that will be referenced later on. For more information on these properties see, xref:type-JmxTransOutputDefinitionTemplate-reference[`JmxTransOutputDefinitionTemplate` schema reference].
             */
            outputDefinitions: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransOutputDefinitions>[]>;
            /**
             * CPU and memory resources to reserve.
             */
            resources?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransResources>;
            /**
             * Template for JmxTrans resources.
             */
            template?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransTemplate>;
        }

        export interface KafkaSpecJmxTransKafkaQueries {
            /**
             * Determine which attributes of the targeted MBean should be included.
             */
            attributes: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * List of the names of output definitions specified in the spec.kafka.jmxTrans.outputDefinitions that have defined where JMX metrics are pushed to, and in which data format.
             */
            outputs: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * If using wildcards instead of a specific MBean then the data is gathered from multiple MBeans. Otherwise if specifying an MBean then data is gathered from that specified MBean.
             */
            targetMBean: pulumi.Input<string>;
        }

        export interface KafkaSpecJmxTransOutputDefinitions {
            /**
             * How many seconds the JmxTrans waits before pushing a new set of data out.
             */
            flushDelayInSeconds?: pulumi.Input<number>;
            /**
             * The DNS/hostname of the remote host that the data is pushed to.
             */
            host?: pulumi.Input<string>;
            /**
             * Template for setting the name of the output definition. This is used to identify where to send the results of queries should be sent.
             */
            name: pulumi.Input<string>;
            /**
             * Template for setting the format of the data that will be pushed.For more information see https://github.com/jmxtrans/jmxtrans/wiki/OutputWriters[JmxTrans OutputWriters].
             */
            outputType: pulumi.Input<string>;
            /**
             * The port of the remote host that the data is pushed to.
             */
            port?: pulumi.Input<number>;
            /**
             * Template for filtering data to be included in response to a wildcard query. For more information see https://github.com/jmxtrans/jmxtrans/wiki/Queries[JmxTrans queries].
             */
            typeNames?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * CPU and memory resources to reserve.
         */
        export interface KafkaSpecJmxTransResources {
            limits?: pulumi.Input<{[key: string]: any}>;
            requests?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Template for JmxTrans resources.
         */
        export interface KafkaSpecJmxTransTemplate {
            /**
             * Template for JmxTrans container.
             */
            container?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransTemplateContainer>;
            /**
             * Template for JmxTrans `Deployment`.
             */
            deployment?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransTemplateDeployment>;
            /**
             * Template for JmxTrans `Pods`.
             */
            pod?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransTemplatePod>;
        }

        /**
         * Template for JmxTrans container.
         */
        export interface KafkaSpecJmxTransTemplateContainer {
            /**
             * Environment variables which should be applied to the container.
             */
            env?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransTemplateContainerEnv>[]>;
            /**
             * Security context for the container.
             */
            securityContext?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransTemplateContainerSecurityContext>;
        }

        export interface KafkaSpecJmxTransTemplateContainerEnv {
            /**
             * The environment variable key.
             */
            name?: pulumi.Input<string>;
            /**
             * The environment variable value.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * Security context for the container.
         */
        export interface KafkaSpecJmxTransTemplateContainerSecurityContext {
            allowPrivilegeEscalation?: pulumi.Input<boolean>;
            capabilities?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransTemplateContainerSecurityContextCapabilities>;
            privileged?: pulumi.Input<boolean>;
            procMount?: pulumi.Input<string>;
            readOnlyRootFilesystem?: pulumi.Input<boolean>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions>;
            windowsOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptions>;
        }

        export interface KafkaSpecJmxTransTemplateContainerSecurityContextCapabilities {
            add?: pulumi.Input<pulumi.Input<string>[]>;
            drop?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
        }

        /**
         * Template for JmxTrans `Deployment`.
         */
        export interface KafkaSpecJmxTransTemplateDeployment {
            /**
             * Metadata applied to the resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransTemplateDeploymentMetadata>;
        }

        /**
         * Metadata applied to the resource.
         */
        export interface KafkaSpecJmxTransTemplateDeploymentMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Template for JmxTrans `Pods`.
         */
        export interface KafkaSpecJmxTransTemplatePod {
            /**
             * The pod's affinity rules.
             */
            affinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransTemplatePodAffinity>;
            /**
             * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
             */
            imagePullSecrets?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransTemplatePodImagePullSecrets>[]>;
            /**
             * Metadata applied to the resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransTemplatePodMetadata>;
            /**
             * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
             */
            priorityClassName?: pulumi.Input<string>;
            /**
             * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
             */
            schedulerName?: pulumi.Input<string>;
            /**
             * Configures pod-level security attributes and common container settings.
             */
            securityContext?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransTemplatePodSecurityContext>;
            /**
             * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
             */
            terminationGracePeriodSeconds?: pulumi.Input<number>;
            /**
             * The pod's tolerations.
             */
            tolerations?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransTemplatePodTolerations>[]>;
        }

        /**
         * The pod's affinity rules.
         */
        export interface KafkaSpecJmxTransTemplatePodAffinity {
            nodeAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransTemplatePodAffinityNodeAffinity>;
            podAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransTemplatePodAffinityPodAffinity>;
            podAntiAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinity>;
        }

        export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>;
        }

        export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>[]>;
        }

        export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            nodeSelectorTerms?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>[]>;
        }

        export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>[]>;
        }

        export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecJmxTransTemplatePodImagePullSecrets {
            name?: pulumi.Input<string>;
        }

        /**
         * Metadata applied to the resource.
         */
        export interface KafkaSpecJmxTransTemplatePodMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Configures pod-level security attributes and common container settings.
         */
        export interface KafkaSpecJmxTransTemplatePodSecurityContext {
            fsGroup?: pulumi.Input<number>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions>;
            supplementalGroups?: pulumi.Input<pulumi.Input<number>[]>;
            sysctls?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransTemplatePodSecurityContextSysctls>[]>;
            windowsOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptions>;
        }

        export interface KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface KafkaSpecJmxTransTemplatePodSecurityContextSysctls {
            name?: pulumi.Input<string>;
            value?: pulumi.Input<string>;
        }

        export interface KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
        }

        export interface KafkaSpecJmxTransTemplatePodTolerations {
            effect?: pulumi.Input<string>;
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            tolerationSeconds?: pulumi.Input<number>;
            value?: pulumi.Input<string>;
        }

        /**
         * Configuration of the Kafka cluster.
         */
        export interface KafkaSpecKafka {
            /**
             * The pod's affinity rules.
             */
            affinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaAffinity>;
            /**
             * Authorization configuration for Kafka brokers.
             */
            authorization?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaAuthorization>;
            /**
             * The image of the init container used for initializing the `broker.rack`.
             */
            brokerRackInitImage?: pulumi.Input<string>;
            /**
             * Kafka broker config properties with the following prefixes cannot be set: listeners, advertised., broker., listener., host.name, port, inter.broker.listener.name, sasl., ssl., security., password., principal.builder.class, log.dir, zookeeper.connect, zookeeper.set.acl, authorizer., super.user, cruise.control.metrics.topic, cruise.control.metrics.reporter.bootstrap.servers (with the exception of: zookeeper.connection.timeout.ms, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols,cruise.control.metrics.topic.num.partitions, cruise.control.metrics.topic.replication.factor, cruise.control.metrics.topic.retention.ms,cruise.control.metrics.topic.auto.create.retries, cruise.control.metrics.topic.auto.create.timeout.ms).
             */
            config?: pulumi.Input<{[key: string]: any}>;
            /**
             * The docker image for the pods. The default value depends on the configured `Kafka.spec.kafka.version`.
             */
            image?: pulumi.Input<string>;
            /**
             * JMX Options for Kafka brokers.
             */
            jmxOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaJmxOptions>;
            /**
             * JVM Options for pods.
             */
            jvmOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaJvmOptions>;
            /**
             * Configures listeners of Kafka brokers.
             */
            listeners: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaListeners>;
            /**
             * Pod liveness checking.
             */
            livenessProbe?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaLivenessProbe>;
            /**
             * Logging configuration for Kafka.
             */
            logging?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaLogging>;
            /**
             * The Prometheus JMX Exporter configuration. See https://github.com/prometheus/jmx_exporter for details of the structure of this configuration.
             */
            metrics?: pulumi.Input<{[key: string]: any}>;
            /**
             * Configuration of the `broker.rack` broker config.
             */
            rack?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaRack>;
            /**
             * Pod readiness checking.
             */
            readinessProbe?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaReadinessProbe>;
            /**
             * The number of pods in the cluster.
             */
            replicas: pulumi.Input<number>;
            /**
             * CPU and memory resources to reserve.
             */
            resources?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaResources>;
            /**
             * Storage configuration (disk). Cannot be updated.
             */
            storage: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaStorage>;
            /**
             * Template for Kafka cluster resources. The template allows users to specify how are the `StatefulSet`, `Pods` and `Services` generated.
             */
            template?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplate>;
            /**
             * TLS sidecar configuration.
             */
            tlsSidecar?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTlsSidecar>;
            /**
             * The pod's tolerations.
             */
            tolerations?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTolerations>[]>;
            /**
             * The kafka broker version. Defaults to {DefaultKafkaVersion}. Consult the user documentation to understand the process required to upgrade or downgrade the version.
             */
            version?: pulumi.Input<string>;
        }

        /**
         * The pod's affinity rules.
         */
        export interface KafkaSpecKafkaAffinity {
            nodeAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaAffinityNodeAffinity>;
            podAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaAffinityPodAffinity>;
            podAntiAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaAffinityPodAntiAffinity>;
        }

        export interface KafkaSpecKafkaAffinityNodeAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>;
        }

        export interface KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>[]>;
        }

        export interface KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            nodeSelectorTerms?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>[]>;
        }

        export interface KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>[]>;
        }

        export interface KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecKafkaAffinityPodAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecKafkaAffinityPodAntiAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Authorization configuration for Kafka brokers.
         */
        export interface KafkaSpecKafkaAuthorization {
            /**
             * Defines whether a Kafka client should be allowed or denied by default when the authorizer fails to query the Open Policy Agent, for example, when it is temporarily unavailable). Defaults to `false` - all actions will be denied.
             */
            allowOnError?: pulumi.Input<boolean>;
            /**
             * OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
             */
            clientId?: pulumi.Input<string>;
            /**
             * Whether authorization decision should be delegated to the 'Simple' authorizer if DENIED by Keycloak Authorization Services policies.Default value is `false`.
             */
            delegateToKafkaAcls?: pulumi.Input<boolean>;
            /**
             * Enable or disable TLS hostname verification. Default value is `false`.
             */
            disableTlsHostnameVerification?: pulumi.Input<boolean>;
            /**
             * The expiration of the records kept in the local cache to avoid querying the Open Policy Agent for every request. Defines how often the cached authorization decisions are reloaded from the Open Policy Agent server. In milliseconds. Defaults to `3600000`.
             */
            expireAfterMs?: pulumi.Input<number>;
            /**
             * Initial capacity of the local cache used by the authorizer to avoid querying the Open Policy Agent for every request Defaults to `5000`.
             */
            initialCacheCapacity?: pulumi.Input<number>;
            /**
             * Maximum capacity of the local cache used by the authorizer to avoid querying the Open Policy Agent for every request. Defaults to `50000`.
             */
            maximumCacheSize?: pulumi.Input<number>;
            /**
             * List of super users. Should contain list of user principals which should get unlimited access rights.
             */
            superUsers?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Trusted certificates for TLS connection to the OAuth server.
             */
            tlsTrustedCertificates?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaAuthorizationTlsTrustedCertificates>[]>;
            /**
             * Authorization server token endpoint URI.
             */
            tokenEndpointUri?: pulumi.Input<string>;
            /**
             * Authorization type. Currently, the supported types are `simple`, `keycloak`, and `opa`. `simple` authorization type uses Kafka's `kafka.security.auth.SimpleAclAuthorizer` class for authorization. `keycloak` authorization type uses Keycloak Authorization Services for authorization. `opa` authorization type uses Open Policy Agent based authorization.
             */
            type: pulumi.Input<string>;
            /**
             * The URL used to connect to the Open Policy Agent server. The URL has to include the policy which will be queried by the authorizer. This option is required.
             */
            url?: pulumi.Input<string>;
        }

        export interface KafkaSpecKafkaAuthorizationTlsTrustedCertificates {
            /**
             * The name of the file certificate in the Secret.
             */
            certificate: pulumi.Input<string>;
            /**
             * The name of the Secret containing the certificate.
             */
            secretName: pulumi.Input<string>;
        }

        /**
         * Configuration of the Kafka Exporter. Kafka Exporter can provide additional metrics, for example lag of consumer group at topic/partition.
         */
        export interface KafkaSpecKafkaExporter {
            /**
             * Enable Sarama logging, a Go client library used by the Kafka Exporter.
             */
            enableSaramaLogging?: pulumi.Input<boolean>;
            /**
             * Regular expression to specify which consumer groups to collect. Default value is `.*`.
             */
            groupRegex?: pulumi.Input<string>;
            /**
             * The docker image for the pods.
             */
            image?: pulumi.Input<string>;
            /**
             * Pod liveness check.
             */
            livenessProbe?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterLivenessProbe>;
            /**
             * Only log messages with the given severity or above. Valid levels: [`debug`, `info`, `warn`, `error`, `fatal`]. Default log level is `info`.
             */
            logging?: pulumi.Input<string>;
            /**
             * Pod readiness check.
             */
            readinessProbe?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterReadinessProbe>;
            /**
             * CPU and memory resources to reserve.
             */
            resources?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterResources>;
            /**
             * Customization of deployment templates and pods.
             */
            template?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplate>;
            /**
             * Regular expression to specify which topics to collect. Default value is `.*`.
             */
            topicRegex?: pulumi.Input<string>;
        }

        /**
         * Pod liveness check.
         */
        export interface KafkaSpecKafkaExporterLivenessProbe {
            /**
             * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
             */
            failureThreshold?: pulumi.Input<number>;
            /**
             * The initial delay before first the health is first checked.
             */
            initialDelaySeconds?: pulumi.Input<number>;
            /**
             * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
             */
            successThreshold?: pulumi.Input<number>;
            /**
             * The timeout for each attempted health check.
             */
            timeoutSeconds?: pulumi.Input<number>;
        }

        /**
         * Pod readiness check.
         */
        export interface KafkaSpecKafkaExporterReadinessProbe {
            /**
             * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
             */
            failureThreshold?: pulumi.Input<number>;
            /**
             * The initial delay before first the health is first checked.
             */
            initialDelaySeconds?: pulumi.Input<number>;
            /**
             * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
             */
            successThreshold?: pulumi.Input<number>;
            /**
             * The timeout for each attempted health check.
             */
            timeoutSeconds?: pulumi.Input<number>;
        }

        /**
         * CPU and memory resources to reserve.
         */
        export interface KafkaSpecKafkaExporterResources {
            limits?: pulumi.Input<{[key: string]: any}>;
            requests?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Customization of deployment templates and pods.
         */
        export interface KafkaSpecKafkaExporterTemplate {
            /**
             * Template for the Kafka Exporter container.
             */
            container?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplateContainer>;
            /**
             * Template for Kafka Exporter `Deployment`.
             */
            deployment?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplateDeployment>;
            /**
             * Template for Kafka Exporter `Pods`.
             */
            pod?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplatePod>;
            /**
             * Template for Kafka Exporter `Service`.
             */
            service?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplateService>;
        }

        /**
         * Template for the Kafka Exporter container.
         */
        export interface KafkaSpecKafkaExporterTemplateContainer {
            /**
             * Environment variables which should be applied to the container.
             */
            env?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplateContainerEnv>[]>;
            /**
             * Security context for the container.
             */
            securityContext?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplateContainerSecurityContext>;
        }

        export interface KafkaSpecKafkaExporterTemplateContainerEnv {
            /**
             * The environment variable key.
             */
            name?: pulumi.Input<string>;
            /**
             * The environment variable value.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * Security context for the container.
         */
        export interface KafkaSpecKafkaExporterTemplateContainerSecurityContext {
            allowPrivilegeEscalation?: pulumi.Input<boolean>;
            capabilities?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplateContainerSecurityContextCapabilities>;
            privileged?: pulumi.Input<boolean>;
            procMount?: pulumi.Input<string>;
            readOnlyRootFilesystem?: pulumi.Input<boolean>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions>;
            windowsOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptions>;
        }

        export interface KafkaSpecKafkaExporterTemplateContainerSecurityContextCapabilities {
            add?: pulumi.Input<pulumi.Input<string>[]>;
            drop?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
        }

        /**
         * Template for Kafka Exporter `Deployment`.
         */
        export interface KafkaSpecKafkaExporterTemplateDeployment {
            /**
             * Metadata applied to the resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplateDeploymentMetadata>;
        }

        /**
         * Metadata applied to the resource.
         */
        export interface KafkaSpecKafkaExporterTemplateDeploymentMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Template for Kafka Exporter `Pods`.
         */
        export interface KafkaSpecKafkaExporterTemplatePod {
            /**
             * The pod's affinity rules.
             */
            affinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplatePodAffinity>;
            /**
             * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
             */
            imagePullSecrets?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplatePodImagePullSecrets>[]>;
            /**
             * Metadata applied to the resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplatePodMetadata>;
            /**
             * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
             */
            priorityClassName?: pulumi.Input<string>;
            /**
             * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
             */
            schedulerName?: pulumi.Input<string>;
            /**
             * Configures pod-level security attributes and common container settings.
             */
            securityContext?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplatePodSecurityContext>;
            /**
             * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
             */
            terminationGracePeriodSeconds?: pulumi.Input<number>;
            /**
             * The pod's tolerations.
             */
            tolerations?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplatePodTolerations>[]>;
        }

        /**
         * The pod's affinity rules.
         */
        export interface KafkaSpecKafkaExporterTemplatePodAffinity {
            nodeAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinity>;
            podAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplatePodAffinityPodAffinity>;
            podAntiAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinity>;
        }

        export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>;
        }

        export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>[]>;
        }

        export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            nodeSelectorTerms?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>[]>;
        }

        export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>[]>;
        }

        export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecKafkaExporterTemplatePodImagePullSecrets {
            name?: pulumi.Input<string>;
        }

        /**
         * Metadata applied to the resource.
         */
        export interface KafkaSpecKafkaExporterTemplatePodMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Configures pod-level security attributes and common container settings.
         */
        export interface KafkaSpecKafkaExporterTemplatePodSecurityContext {
            fsGroup?: pulumi.Input<number>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions>;
            supplementalGroups?: pulumi.Input<pulumi.Input<number>[]>;
            sysctls?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplatePodSecurityContextSysctls>[]>;
            windowsOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptions>;
        }

        export interface KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface KafkaSpecKafkaExporterTemplatePodSecurityContextSysctls {
            name?: pulumi.Input<string>;
            value?: pulumi.Input<string>;
        }

        export interface KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
        }

        export interface KafkaSpecKafkaExporterTemplatePodTolerations {
            effect?: pulumi.Input<string>;
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            tolerationSeconds?: pulumi.Input<number>;
            value?: pulumi.Input<string>;
        }

        /**
         * Template for Kafka Exporter `Service`.
         */
        export interface KafkaSpecKafkaExporterTemplateService {
            /**
             * Metadata applied to the resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaExporterTemplateServiceMetadata>;
        }

        /**
         * Metadata applied to the resource.
         */
        export interface KafkaSpecKafkaExporterTemplateServiceMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * JMX Options for Kafka brokers.
         */
        export interface KafkaSpecKafkaJmxOptions {
            /**
             * Authentication configuration for connecting to the Kafka JMX port.
             */
            authentication?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaJmxOptionsAuthentication>;
        }

        /**
         * Authentication configuration for connecting to the Kafka JMX port.
         */
        export interface KafkaSpecKafkaJmxOptionsAuthentication {
            /**
             * Authentication type. Currently the only supported types are `password`.`password` type creates a username and protected port with no TLS.
             */
            type: pulumi.Input<string>;
        }

        /**
         * JVM Options for pods.
         */
        export interface KafkaSpecKafkaJvmOptions {
            /**
             * A map of -XX options to the JVM.
             */
            -XX?: pulumi.Input<{[key: string]: any}>;
            /**
             * -Xms option to to the JVM.
             */
            -Xms?: pulumi.Input<string>;
            /**
             * -Xmx option to to the JVM.
             */
            -Xmx?: pulumi.Input<string>;
            /**
             * Specifies whether the Garbage Collection logging is enabled. The default is false.
             */
            gcLoggingEnabled?: pulumi.Input<boolean>;
            /**
             * A map of additional system properties which will be passed using the `-D` option to the JVM.
             */
            javaSystemProperties?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaJvmOptionsJavaSystemProperties>[]>;
        }

        export interface KafkaSpecKafkaJvmOptionsJavaSystemProperties {
            /**
             * The system property name.
             */
            name?: pulumi.Input<string>;
            /**
             * The system property value.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * Configures listeners of Kafka brokers.
         */
        export interface KafkaSpecKafkaListeners {
            /**
             * Configures external listener on port 9094.
             */
            external?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaListenersExternal>;
            /**
             * Configures plain listener on port 9092.
             */
            plain?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaListenersPlain>;
            /**
             * Configures TLS listener on port 9093.
             */
            tls?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaListenersTls>;
        }

        /**
         * Configures external listener on port 9094.
         */
        export interface KafkaSpecKafkaListenersExternal {
            /**
             * Authentication configuration for Kafka brokers.
             */
            authentication?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaListenersExternalAuthentication>;
            /**
             * Configures the `Ingress` class that defines which `Ingress` controller will be used. If not set, the `Ingress` class is set to `nginx`.
             */
            class?: pulumi.Input<string>;
            /**
             * External listener configuration.
             */
            configuration?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaListenersExternalConfiguration>;
            /**
             * List of peers which should be able to connect to this listener. Peers in this list are combined using a logical OR operation. If this field is empty or missing, all connections will be allowed for this listener. If this field is present and contains at least one item, the listener only allows the traffic which matches at least one item in this list.
             */
            networkPolicyPeers?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaListenersExternalNetworkPolicyPeers>[]>;
            /**
             * Overrides for external bootstrap and broker services and externally advertised addresses.
             */
            overrides?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaListenersExternalOverrides>;
            /**
             * Enables TLS encryption on the listener. By default set to `true` for enabled TLS encryption.
             */
            tls?: pulumi.Input<boolean>;
            /**
             * Type of the external listener. Currently the supported types are `route`, `loadbalancer`, and `nodeport`. 
             *
             * * `route` type uses OpenShift Routes to expose Kafka.* `loadbalancer` type uses LoadBalancer type services to expose Kafka.* `nodeport` type uses NodePort type services to expose Kafka..
             */
            type: pulumi.Input<string>;
        }

        /**
         * Authentication configuration for Kafka brokers.
         */
        export interface KafkaSpecKafkaListenersExternalAuthentication {
            /**
             * Configure whether the access token is treated as JWT. This must be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
             */
            accessTokenIsJwt?: pulumi.Input<boolean>;
            /**
             * Configure whether the access token type check is performed or not. This should be set to `false` if the authorization server does not include 'typ' claim in JWT token. Defaults to `true`.
             */
            checkAccessTokenType?: pulumi.Input<boolean>;
            /**
             * Enable or disable issuer checking. By default issuer is checked using the value configured by `validIssuerUri`. Default value is `true`.
             */
            checkIssuer?: pulumi.Input<boolean>;
            /**
             * OAuth Client ID which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
             */
            clientId?: pulumi.Input<string>;
            /**
             * Link to Kubernetes Secret containing the OAuth client secret which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
             */
            clientSecret?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaListenersExternalAuthenticationClientSecret>;
            /**
             * Enable or disable TLS hostname verification. Default value is `false`.
             */
            disableTlsHostnameVerification?: pulumi.Input<boolean>;
            /**
             * Enable or disable ECDSA support by installing BouncyCastle crypto provider. Default value is `false`.
             */
            enableECDSA?: pulumi.Input<boolean>;
            /**
             * The fallback username claim to be used for the user id if the claim specified by `userNameClaim` is not present. This is useful when `client_credentials` authentication only results in the client id being provided in another claim. It only takes effect if `userNameClaim` is set.
             */
            fallbackUserNameClaim?: pulumi.Input<string>;
            /**
             * The prefix to use with the value of `fallbackUserNameClaim` to construct the user id. This only takes effect if `fallbackUserNameClaim` is true, and the value is present for the claim. Mapping usernames and client ids into the same user id space is useful in preventing name collisions.
             */
            fallbackUserNamePrefix?: pulumi.Input<string>;
            /**
             * URI of the token introspection endpoint which can be used to validate opaque non-JWT tokens.
             */
            introspectionEndpointUri?: pulumi.Input<string>;
            /**
             * URI of the JWKS certificate endpoint, which can be used for local JWT validation.
             */
            jwksEndpointUri?: pulumi.Input<string>;
            /**
             * Configures how often are the JWKS certificates considered valid. The expiry interval has to be at least 60 seconds longer then the refresh interval specified in `jwksRefreshSeconds`. Defaults to 360 seconds.
             */
            jwksExpirySeconds?: pulumi.Input<number>;
            /**
             * Configures how often are the JWKS certificates refreshed. The refresh interval has to be at least 60 seconds shorter then the expiry interval specified in `jwksExpirySeconds`. Defaults to 300 seconds.
             */
            jwksRefreshSeconds?: pulumi.Input<number>;
            /**
             * Trusted certificates for TLS connection to the OAuth server.
             */
            tlsTrustedCertificates?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaListenersExternalAuthenticationTlsTrustedCertificates>[]>;
            /**
             * Authentication type. `oauth` type uses SASL OAUTHBEARER Authentication. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `tls` type uses TLS Client Authentication. `tls` type is supported only on TLS listeners.
             */
            type: pulumi.Input<string>;
            /**
             * URI of the User Info Endpoint to use as a fallback to obtaining the user id when the Introspection Endpoint does not return information that can be used for the user id. 
             */
            userInfoEndpointUri?: pulumi.Input<string>;
            /**
             * Name of the claim from the JWT authentication token, Introspection Endpoint response or User Info Endpoint response which will be used to extract the user id. Defaults to `sub`.
             */
            userNameClaim?: pulumi.Input<string>;
            /**
             * URI of the token issuer used for authentication.
             */
            validIssuerUri?: pulumi.Input<string>;
            /**
             * Valid value for the `token_type` attribute returned by the Introspection Endpoint. No default value, and not checked by default.
             */
            validTokenType?: pulumi.Input<string>;
        }

        /**
         * Link to Kubernetes Secret containing the OAuth client secret which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
         */
        export interface KafkaSpecKafkaListenersExternalAuthenticationClientSecret {
            /**
             * The key under which the secret value is stored in the Kubernetes Secret.
             */
            key: pulumi.Input<string>;
            /**
             * The name of the Kubernetes Secret containing the secret value.
             */
            secretName: pulumi.Input<string>;
        }

        export interface KafkaSpecKafkaListenersExternalAuthenticationTlsTrustedCertificates {
            /**
             * The name of the file certificate in the Secret.
             */
            certificate: pulumi.Input<string>;
            /**
             * The name of the Secret containing the certificate.
             */
            secretName: pulumi.Input<string>;
        }

        /**
         * External listener configuration.
         */
        export interface KafkaSpecKafkaListenersExternalConfiguration {
            /**
             * External bootstrap ingress configuration.
             */
            bootstrap?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaListenersExternalConfigurationBootstrap>;
            /**
             * Reference to the `Secret` which holds the certificate and private key pair. The certificate can optionally contain the whole chain.
             */
            brokerCertChainAndKey?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaListenersExternalConfigurationBrokerCertChainAndKey>;
            /**
             * External broker ingress configuration.
             */
            brokers?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaListenersExternalConfigurationBrokers>[]>;
        }

        /**
         * External bootstrap ingress configuration.
         */
        export interface KafkaSpecKafkaListenersExternalConfigurationBootstrap {
            /**
             * Additional address name for the bootstrap service. The address will be added to the list of subject alternative names of the TLS certificates.
             */
            address?: pulumi.Input<string>;
            /**
             * Annotations that will be added to the `Ingress` resource. You can use this field to configure DNS providers such as External DNS.
             */
            dnsAnnotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Host for the bootstrap route. This field will be used in the Ingress resource.
             */
            host: pulumi.Input<string>;
        }

        /**
         * Reference to the `Secret` which holds the certificate and private key pair. The certificate can optionally contain the whole chain.
         */
        export interface KafkaSpecKafkaListenersExternalConfigurationBrokerCertChainAndKey {
            /**
             * The name of the file certificate in the Secret.
             */
            certificate: pulumi.Input<string>;
            /**
             * The name of the private key in the Secret.
             */
            key: pulumi.Input<string>;
            /**
             * The name of the Secret containing the certificate.
             */
            secretName: pulumi.Input<string>;
        }

        export interface KafkaSpecKafkaListenersExternalConfigurationBrokers {
            /**
             * The host name which will be used in the brokers' `advertised.brokers`.
             */
            advertisedHost?: pulumi.Input<string>;
            /**
             * The port number which will be used in the brokers' `advertised.brokers`.
             */
            advertisedPort?: pulumi.Input<number>;
            /**
             * Id of the kafka broker (broker identifier).
             */
            broker?: pulumi.Input<number>;
            /**
             * Annotations that will be added to the `Ingress` resources for individual brokers. You can use this field to configure DNS providers such as External DNS.
             */
            dnsAnnotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Host for the broker ingress. This field will be used in the Ingress resource.
             */
            host: pulumi.Input<string>;
        }

        export interface KafkaSpecKafkaListenersExternalNetworkPolicyPeers {
            ipBlock?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaListenersExternalNetworkPolicyPeersIpBlock>;
            namespaceSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaListenersExternalNetworkPolicyPeersNamespaceSelector>;
            podSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaListenersExternalNetworkPolicyPeersPodSelector>;
        }

        export interface KafkaSpecKafkaListenersExternalNetworkPolicyPeersIpBlock {
            cidr?: pulumi.Input<string>;
            except?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecKafkaListenersExternalNetworkPolicyPeersNamespaceSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaListenersExternalNetworkPolicyPeersNamespaceSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecKafkaListenersExternalNetworkPolicyPeersNamespaceSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecKafkaListenersExternalNetworkPolicyPeersPodSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaListenersExternalNetworkPolicyPeersPodSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecKafkaListenersExternalNetworkPolicyPeersPodSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Overrides for external bootstrap and broker services and externally advertised addresses.
         */
        export interface KafkaSpecKafkaListenersExternalOverrides {
            /**
             * External bootstrap service configuration.
             */
            bootstrap?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaListenersExternalOverridesBootstrap>;
            /**
             * External broker services configuration.
             */
            brokers?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaListenersExternalOverridesBrokers>[]>;
        }

        /**
         * External bootstrap service configuration.
         */
        export interface KafkaSpecKafkaListenersExternalOverridesBootstrap {
            /**
             * Additional address name for the bootstrap service. The address will be added to the list of subject alternative names of the TLS certificates.
             */
            address?: pulumi.Input<string>;
            /**
             * Annotations that will be added to the `Service` resource. You can use this field to configure DNS providers such as External DNS.
             */
            dnsAnnotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Node port for the bootstrap service.
             */
            nodePort?: pulumi.Input<number>;
        }

        export interface KafkaSpecKafkaListenersExternalOverridesBrokers {
            /**
             * The host name which will be used in the brokers' `advertised.brokers`.
             */
            advertisedHost?: pulumi.Input<string>;
            /**
             * The port number which will be used in the brokers' `advertised.brokers`.
             */
            advertisedPort?: pulumi.Input<number>;
            /**
             * Id of the kafka broker (broker identifier).
             */
            broker?: pulumi.Input<number>;
            /**
             * Annotations that will be added to the `Service` resources for individual brokers. You can use this field to configure DNS providers such as External DNS.
             */
            dnsAnnotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Node port for the broker service.
             */
            nodePort?: pulumi.Input<number>;
        }

        /**
         * Configures plain listener on port 9092.
         */
        export interface KafkaSpecKafkaListenersPlain {
            /**
             * Authentication configuration for this listener. Since this listener does not use TLS transport you cannot configure an authentication with `type: tls`.
             */
            authentication?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaListenersPlainAuthentication>;
            /**
             * List of peers which should be able to connect to this listener. Peers in this list are combined using a logical OR operation. If this field is empty or missing, all connections will be allowed for this listener. If this field is present and contains at least one item, the listener only allows the traffic which matches at least one item in this list.
             */
            networkPolicyPeers?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaListenersPlainNetworkPolicyPeers>[]>;
        }

        /**
         * Authentication configuration for this listener. Since this listener does not use TLS transport you cannot configure an authentication with `type: tls`.
         */
        export interface KafkaSpecKafkaListenersPlainAuthentication {
            /**
             * Configure whether the access token is treated as JWT. This must be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
             */
            accessTokenIsJwt?: pulumi.Input<boolean>;
            /**
             * Configure whether the access token type check is performed or not. This should be set to `false` if the authorization server does not include 'typ' claim in JWT token. Defaults to `true`.
             */
            checkAccessTokenType?: pulumi.Input<boolean>;
            /**
             * Enable or disable issuer checking. By default issuer is checked using the value configured by `validIssuerUri`. Default value is `true`.
             */
            checkIssuer?: pulumi.Input<boolean>;
            /**
             * OAuth Client ID which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
             */
            clientId?: pulumi.Input<string>;
            /**
             * Link to Kubernetes Secret containing the OAuth client secret which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
             */
            clientSecret?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaListenersPlainAuthenticationClientSecret>;
            /**
             * Enable or disable TLS hostname verification. Default value is `false`.
             */
            disableTlsHostnameVerification?: pulumi.Input<boolean>;
            /**
             * Enable or disable ECDSA support by installing BouncyCastle crypto provider. Default value is `false`.
             */
            enableECDSA?: pulumi.Input<boolean>;
            /**
             * The fallback username claim to be used for the user id if the claim specified by `userNameClaim` is not present. This is useful when `client_credentials` authentication only results in the client id being provided in another claim. It only takes effect if `userNameClaim` is set.
             */
            fallbackUserNameClaim?: pulumi.Input<string>;
            /**
             * The prefix to use with the value of `fallbackUserNameClaim` to construct the user id. This only takes effect if `fallbackUserNameClaim` is true, and the value is present for the claim. Mapping usernames and client ids into the same user id space is useful in preventing name collisions.
             */
            fallbackUserNamePrefix?: pulumi.Input<string>;
            /**
             * URI of the token introspection endpoint which can be used to validate opaque non-JWT tokens.
             */
            introspectionEndpointUri?: pulumi.Input<string>;
            /**
             * URI of the JWKS certificate endpoint, which can be used for local JWT validation.
             */
            jwksEndpointUri?: pulumi.Input<string>;
            /**
             * Configures how often are the JWKS certificates considered valid. The expiry interval has to be at least 60 seconds longer then the refresh interval specified in `jwksRefreshSeconds`. Defaults to 360 seconds.
             */
            jwksExpirySeconds?: pulumi.Input<number>;
            /**
             * Configures how often are the JWKS certificates refreshed. The refresh interval has to be at least 60 seconds shorter then the expiry interval specified in `jwksExpirySeconds`. Defaults to 300 seconds.
             */
            jwksRefreshSeconds?: pulumi.Input<number>;
            /**
             * Trusted certificates for TLS connection to the OAuth server.
             */
            tlsTrustedCertificates?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaListenersPlainAuthenticationTlsTrustedCertificates>[]>;
            /**
             * Authentication type. `oauth` type uses SASL OAUTHBEARER Authentication. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `tls` type uses TLS Client Authentication. `tls` type is supported only on TLS listeners.
             */
            type: pulumi.Input<string>;
            /**
             * URI of the User Info Endpoint to use as a fallback to obtaining the user id when the Introspection Endpoint does not return information that can be used for the user id. 
             */
            userInfoEndpointUri?: pulumi.Input<string>;
            /**
             * Name of the claim from the JWT authentication token, Introspection Endpoint response or User Info Endpoint response which will be used to extract the user id. Defaults to `sub`.
             */
            userNameClaim?: pulumi.Input<string>;
            /**
             * URI of the token issuer used for authentication.
             */
            validIssuerUri?: pulumi.Input<string>;
            /**
             * Valid value for the `token_type` attribute returned by the Introspection Endpoint. No default value, and not checked by default.
             */
            validTokenType?: pulumi.Input<string>;
        }

        /**
         * Link to Kubernetes Secret containing the OAuth client secret which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
         */
        export interface KafkaSpecKafkaListenersPlainAuthenticationClientSecret {
            /**
             * The key under which the secret value is stored in the Kubernetes Secret.
             */
            key: pulumi.Input<string>;
            /**
             * The name of the Kubernetes Secret containing the secret value.
             */
            secretName: pulumi.Input<string>;
        }

        export interface KafkaSpecKafkaListenersPlainAuthenticationTlsTrustedCertificates {
            /**
             * The name of the file certificate in the Secret.
             */
            certificate: pulumi.Input<string>;
            /**
             * The name of the Secret containing the certificate.
             */
            secretName: pulumi.Input<string>;
        }

        export interface KafkaSpecKafkaListenersPlainNetworkPolicyPeers {
            ipBlock?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaListenersPlainNetworkPolicyPeersIpBlock>;
            namespaceSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaListenersPlainNetworkPolicyPeersNamespaceSelector>;
            podSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaListenersPlainNetworkPolicyPeersPodSelector>;
        }

        export interface KafkaSpecKafkaListenersPlainNetworkPolicyPeersIpBlock {
            cidr?: pulumi.Input<string>;
            except?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecKafkaListenersPlainNetworkPolicyPeersNamespaceSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaListenersPlainNetworkPolicyPeersNamespaceSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecKafkaListenersPlainNetworkPolicyPeersNamespaceSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecKafkaListenersPlainNetworkPolicyPeersPodSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaListenersPlainNetworkPolicyPeersPodSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecKafkaListenersPlainNetworkPolicyPeersPodSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Configures TLS listener on port 9093.
         */
        export interface KafkaSpecKafkaListenersTls {
            /**
             * Authentication configuration for this listener.
             */
            authentication?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaListenersTlsAuthentication>;
            /**
             * Configuration of TLS listener.
             */
            configuration?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaListenersTlsConfiguration>;
            /**
             * List of peers which should be able to connect to this listener. Peers in this list are combined using a logical OR operation. If this field is empty or missing, all connections will be allowed for this listener. If this field is present and contains at least one item, the listener only allows the traffic which matches at least one item in this list.
             */
            networkPolicyPeers?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaListenersTlsNetworkPolicyPeers>[]>;
        }

        /**
         * Authentication configuration for this listener.
         */
        export interface KafkaSpecKafkaListenersTlsAuthentication {
            /**
             * Configure whether the access token is treated as JWT. This must be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
             */
            accessTokenIsJwt?: pulumi.Input<boolean>;
            /**
             * Configure whether the access token type check is performed or not. This should be set to `false` if the authorization server does not include 'typ' claim in JWT token. Defaults to `true`.
             */
            checkAccessTokenType?: pulumi.Input<boolean>;
            /**
             * Enable or disable issuer checking. By default issuer is checked using the value configured by `validIssuerUri`. Default value is `true`.
             */
            checkIssuer?: pulumi.Input<boolean>;
            /**
             * OAuth Client ID which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
             */
            clientId?: pulumi.Input<string>;
            /**
             * Link to Kubernetes Secret containing the OAuth client secret which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
             */
            clientSecret?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaListenersTlsAuthenticationClientSecret>;
            /**
             * Enable or disable TLS hostname verification. Default value is `false`.
             */
            disableTlsHostnameVerification?: pulumi.Input<boolean>;
            /**
             * Enable or disable ECDSA support by installing BouncyCastle crypto provider. Default value is `false`.
             */
            enableECDSA?: pulumi.Input<boolean>;
            /**
             * The fallback username claim to be used for the user id if the claim specified by `userNameClaim` is not present. This is useful when `client_credentials` authentication only results in the client id being provided in another claim. It only takes effect if `userNameClaim` is set.
             */
            fallbackUserNameClaim?: pulumi.Input<string>;
            /**
             * The prefix to use with the value of `fallbackUserNameClaim` to construct the user id. This only takes effect if `fallbackUserNameClaim` is true, and the value is present for the claim. Mapping usernames and client ids into the same user id space is useful in preventing name collisions.
             */
            fallbackUserNamePrefix?: pulumi.Input<string>;
            /**
             * URI of the token introspection endpoint which can be used to validate opaque non-JWT tokens.
             */
            introspectionEndpointUri?: pulumi.Input<string>;
            /**
             * URI of the JWKS certificate endpoint, which can be used for local JWT validation.
             */
            jwksEndpointUri?: pulumi.Input<string>;
            /**
             * Configures how often are the JWKS certificates considered valid. The expiry interval has to be at least 60 seconds longer then the refresh interval specified in `jwksRefreshSeconds`. Defaults to 360 seconds.
             */
            jwksExpirySeconds?: pulumi.Input<number>;
            /**
             * Configures how often are the JWKS certificates refreshed. The refresh interval has to be at least 60 seconds shorter then the expiry interval specified in `jwksExpirySeconds`. Defaults to 300 seconds.
             */
            jwksRefreshSeconds?: pulumi.Input<number>;
            /**
             * Trusted certificates for TLS connection to the OAuth server.
             */
            tlsTrustedCertificates?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaListenersTlsAuthenticationTlsTrustedCertificates>[]>;
            /**
             * Authentication type. `oauth` type uses SASL OAUTHBEARER Authentication. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `tls` type uses TLS Client Authentication. `tls` type is supported only on TLS listeners.
             */
            type: pulumi.Input<string>;
            /**
             * URI of the User Info Endpoint to use as a fallback to obtaining the user id when the Introspection Endpoint does not return information that can be used for the user id. 
             */
            userInfoEndpointUri?: pulumi.Input<string>;
            /**
             * Name of the claim from the JWT authentication token, Introspection Endpoint response or User Info Endpoint response which will be used to extract the user id. Defaults to `sub`.
             */
            userNameClaim?: pulumi.Input<string>;
            /**
             * URI of the token issuer used for authentication.
             */
            validIssuerUri?: pulumi.Input<string>;
            /**
             * Valid value for the `token_type` attribute returned by the Introspection Endpoint. No default value, and not checked by default.
             */
            validTokenType?: pulumi.Input<string>;
        }

        /**
         * Link to Kubernetes Secret containing the OAuth client secret which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
         */
        export interface KafkaSpecKafkaListenersTlsAuthenticationClientSecret {
            /**
             * The key under which the secret value is stored in the Kubernetes Secret.
             */
            key: pulumi.Input<string>;
            /**
             * The name of the Kubernetes Secret containing the secret value.
             */
            secretName: pulumi.Input<string>;
        }

        export interface KafkaSpecKafkaListenersTlsAuthenticationTlsTrustedCertificates {
            /**
             * The name of the file certificate in the Secret.
             */
            certificate: pulumi.Input<string>;
            /**
             * The name of the Secret containing the certificate.
             */
            secretName: pulumi.Input<string>;
        }

        /**
         * Configuration of TLS listener.
         */
        export interface KafkaSpecKafkaListenersTlsConfiguration {
            /**
             * Reference to the `Secret` which holds the certificate and private key pair. The certificate can optionally contain the whole chain.
             */
            brokerCertChainAndKey?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaListenersTlsConfigurationBrokerCertChainAndKey>;
        }

        /**
         * Reference to the `Secret` which holds the certificate and private key pair. The certificate can optionally contain the whole chain.
         */
        export interface KafkaSpecKafkaListenersTlsConfigurationBrokerCertChainAndKey {
            /**
             * The name of the file certificate in the Secret.
             */
            certificate: pulumi.Input<string>;
            /**
             * The name of the private key in the Secret.
             */
            key: pulumi.Input<string>;
            /**
             * The name of the Secret containing the certificate.
             */
            secretName: pulumi.Input<string>;
        }

        export interface KafkaSpecKafkaListenersTlsNetworkPolicyPeers {
            ipBlock?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaListenersTlsNetworkPolicyPeersIpBlock>;
            namespaceSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaListenersTlsNetworkPolicyPeersNamespaceSelector>;
            podSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaListenersTlsNetworkPolicyPeersPodSelector>;
        }

        export interface KafkaSpecKafkaListenersTlsNetworkPolicyPeersIpBlock {
            cidr?: pulumi.Input<string>;
            except?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecKafkaListenersTlsNetworkPolicyPeersNamespaceSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaListenersTlsNetworkPolicyPeersNamespaceSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecKafkaListenersTlsNetworkPolicyPeersNamespaceSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecKafkaListenersTlsNetworkPolicyPeersPodSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaListenersTlsNetworkPolicyPeersPodSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecKafkaListenersTlsNetworkPolicyPeersPodSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Pod liveness checking.
         */
        export interface KafkaSpecKafkaLivenessProbe {
            /**
             * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
             */
            failureThreshold?: pulumi.Input<number>;
            /**
             * The initial delay before first the health is first checked.
             */
            initialDelaySeconds?: pulumi.Input<number>;
            /**
             * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
             */
            successThreshold?: pulumi.Input<number>;
            /**
             * The timeout for each attempted health check.
             */
            timeoutSeconds?: pulumi.Input<number>;
        }

        /**
         * Logging configuration for Kafka.
         */
        export interface KafkaSpecKafkaLogging {
            /**
             * A Map from logger name to logger level.
             */
            loggers?: pulumi.Input<{[key: string]: any}>;
            /**
             * The name of the `ConfigMap` from which to get the logging configuration.
             */
            name?: pulumi.Input<string>;
            /**
             * Logging type, must be either 'inline' or 'external'.
             */
            type: pulumi.Input<string>;
        }

        /**
         * Configuration of the `broker.rack` broker config.
         */
        export interface KafkaSpecKafkaRack {
            /**
             * A key that matches labels assigned to the Kubernetes cluster nodes. The value of the label is used to set the broker's `broker.rack` config.
             */
            topologyKey: pulumi.Input<string>;
        }

        /**
         * Pod readiness checking.
         */
        export interface KafkaSpecKafkaReadinessProbe {
            /**
             * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
             */
            failureThreshold?: pulumi.Input<number>;
            /**
             * The initial delay before first the health is first checked.
             */
            initialDelaySeconds?: pulumi.Input<number>;
            /**
             * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
             */
            successThreshold?: pulumi.Input<number>;
            /**
             * The timeout for each attempted health check.
             */
            timeoutSeconds?: pulumi.Input<number>;
        }

        /**
         * CPU and memory resources to reserve.
         */
        export interface KafkaSpecKafkaResources {
            limits?: pulumi.Input<{[key: string]: any}>;
            requests?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Storage configuration (disk). Cannot be updated.
         */
        export interface KafkaSpecKafkaStorage {
            /**
             * The storage class to use for dynamic volume allocation.
             */
            class?: pulumi.Input<string>;
            /**
             * Specifies if the persistent volume claim has to be deleted when the cluster is un-deployed.
             */
            deleteClaim?: pulumi.Input<boolean>;
            /**
             * Storage identification number. It is mandatory only for storage volumes defined in a storage of type 'jbod'.
             */
            id?: pulumi.Input<number>;
            /**
             * Overrides for individual brokers. The `overrides` field allows to specify a different configuration for different brokers.
             */
            overrides?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaStorageOverrides>[]>;
            /**
             * Specifies a specific persistent volume to use. It contains key:value pairs representing labels for selecting such a volume.
             */
            selector?: pulumi.Input<{[key: string]: any}>;
            /**
             * When type=persistent-claim, defines the size of the persistent volume claim (i.e 1Gi). Mandatory when type=persistent-claim.
             */
            size?: pulumi.Input<string>;
            /**
             * When type=ephemeral, defines the total amount of local storage required for this EmptyDir volume (for example 1Gi).
             */
            sizeLimit?: pulumi.Input<string>;
            /**
             * Storage type, must be either 'ephemeral', 'persistent-claim', or 'jbod'.
             */
            type: pulumi.Input<string>;
            /**
             * List of volumes as Storage objects representing the JBOD disks array.
             */
            volumes?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaStorageVolumes>[]>;
        }

        export interface KafkaSpecKafkaStorageOverrides {
            /**
             * Id of the kafka broker (broker identifier).
             */
            broker?: pulumi.Input<number>;
            /**
             * The storage class to use for dynamic volume allocation for this broker.
             */
            class?: pulumi.Input<string>;
        }

        export interface KafkaSpecKafkaStorageVolumes {
            /**
             * The storage class to use for dynamic volume allocation.
             */
            class?: pulumi.Input<string>;
            /**
             * Specifies if the persistent volume claim has to be deleted when the cluster is un-deployed.
             */
            deleteClaim?: pulumi.Input<boolean>;
            /**
             * Storage identification number. It is mandatory only for storage volumes defined in a storage of type 'jbod'.
             */
            id?: pulumi.Input<number>;
            /**
             * Overrides for individual brokers. The `overrides` field allows to specify a different configuration for different brokers.
             */
            overrides?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaStorageVolumesOverrides>[]>;
            /**
             * Specifies a specific persistent volume to use. It contains key:value pairs representing labels for selecting such a volume.
             */
            selector?: pulumi.Input<{[key: string]: any}>;
            /**
             * When type=persistent-claim, defines the size of the persistent volume claim (i.e 1Gi). Mandatory when type=persistent-claim.
             */
            size?: pulumi.Input<string>;
            /**
             * When type=ephemeral, defines the total amount of local storage required for this EmptyDir volume (for example 1Gi).
             */
            sizeLimit?: pulumi.Input<string>;
            /**
             * Storage type, must be either 'ephemeral' or 'persistent-claim'.
             */
            type: pulumi.Input<string>;
        }

        export interface KafkaSpecKafkaStorageVolumesOverrides {
            /**
             * Id of the kafka broker (broker identifier).
             */
            broker?: pulumi.Input<number>;
            /**
             * The storage class to use for dynamic volume allocation for this broker.
             */
            class?: pulumi.Input<string>;
        }

        /**
         * Template for Kafka cluster resources. The template allows users to specify how are the `StatefulSet`, `Pods` and `Services` generated.
         */
        export interface KafkaSpecKafkaTemplate {
            /**
             * Template for Kafka bootstrap `Service`.
             */
            bootstrapService?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplateBootstrapService>;
            /**
             * Template for Kafka broker `Service`.
             */
            brokersService?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplateBrokersService>;
            /**
             * Template for Kafka external bootstrap `Ingress`.
             */
            externalBootstrapIngress?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplateExternalBootstrapIngress>;
            /**
             * Template for Kafka external bootstrap `Route`.
             */
            externalBootstrapRoute?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplateExternalBootstrapRoute>;
            /**
             * Template for Kafka external bootstrap `Service`.
             */
            externalBootstrapService?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplateExternalBootstrapService>;
            /**
             * Template for the Kafka init container.
             */
            initContainer?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplateInitContainer>;
            /**
             * Template for the Kafka broker container.
             */
            kafkaContainer?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplateKafkaContainer>;
            /**
             * Template for Kafka per-pod `Ingress` used for access from outside of Kubernetes.
             */
            perPodIngress?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePerPodIngress>;
            /**
             * Template for Kafka per-pod `Routes` used for access from outside of OpenShift.
             */
            perPodRoute?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePerPodRoute>;
            /**
             * Template for Kafka per-pod `Services` used for access from outside of Kubernetes.
             */
            perPodService?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePerPodService>;
            /**
             * Template for all Kafka `PersistentVolumeClaims`.
             */
            persistentVolumeClaim?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePersistentVolumeClaim>;
            /**
             * Template for Kafka `Pods`.
             */
            pod?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePod>;
            /**
             * Template for Kafka `PodDisruptionBudget`.
             */
            podDisruptionBudget?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePodDisruptionBudget>;
            /**
             * Template for Kafka `StatefulSet`.
             */
            statefulset?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplateStatefulset>;
            /**
             * Template for the Kafka broker TLS sidecar container.
             */
            tlsSidecarContainer?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplateTlsSidecarContainer>;
        }

        /**
         * Template for Kafka bootstrap `Service`.
         */
        export interface KafkaSpecKafkaTemplateBootstrapService {
            /**
             * Metadata applied to the resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplateBootstrapServiceMetadata>;
        }

        /**
         * Metadata applied to the resource.
         */
        export interface KafkaSpecKafkaTemplateBootstrapServiceMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Template for Kafka broker `Service`.
         */
        export interface KafkaSpecKafkaTemplateBrokersService {
            /**
             * Metadata applied to the resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplateBrokersServiceMetadata>;
        }

        /**
         * Metadata applied to the resource.
         */
        export interface KafkaSpecKafkaTemplateBrokersServiceMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Template for Kafka external bootstrap `Ingress`.
         */
        export interface KafkaSpecKafkaTemplateExternalBootstrapIngress {
            /**
             * Metadata applied to the resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplateExternalBootstrapIngressMetadata>;
        }

        /**
         * Metadata applied to the resource.
         */
        export interface KafkaSpecKafkaTemplateExternalBootstrapIngressMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Template for Kafka external bootstrap `Route`.
         */
        export interface KafkaSpecKafkaTemplateExternalBootstrapRoute {
            /**
             * Metadata applied to the resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplateExternalBootstrapRouteMetadata>;
        }

        /**
         * Metadata applied to the resource.
         */
        export interface KafkaSpecKafkaTemplateExternalBootstrapRouteMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Template for Kafka external bootstrap `Service`.
         */
        export interface KafkaSpecKafkaTemplateExternalBootstrapService {
            /**
             * Specifies whether the service routes external traffic to node-local or cluster-wide endpoints. `Cluster` may cause a second hop to another node and obscures the client source IP. `Local` avoids a second hop for LoadBalancer and Nodeport type services and preserves the client source IP (when supported by the infrastructure). If unspecified, Kubernetes will use `Cluster` as the default.
             */
            externalTrafficPolicy?: pulumi.Input<string>;
            /**
             * A list of CIDR ranges (for example `10.0.0.0/8` or `130.211.204.1/32`) from which clients can connect to load balancer type listeners. If supported by the platform, traffic through the loadbalancer is restricted to the specified CIDR ranges. This field is applicable only for loadbalancer type services and is ignored if the cloud provider does not support the feature. For more information, see https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/.
             */
            loadBalancerSourceRanges?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Metadata applied to the resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplateExternalBootstrapServiceMetadata>;
        }

        /**
         * Metadata applied to the resource.
         */
        export interface KafkaSpecKafkaTemplateExternalBootstrapServiceMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Template for the Kafka init container.
         */
        export interface KafkaSpecKafkaTemplateInitContainer {
            /**
             * Environment variables which should be applied to the container.
             */
            env?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplateInitContainerEnv>[]>;
            /**
             * Security context for the container.
             */
            securityContext?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplateInitContainerSecurityContext>;
        }

        export interface KafkaSpecKafkaTemplateInitContainerEnv {
            /**
             * The environment variable key.
             */
            name?: pulumi.Input<string>;
            /**
             * The environment variable value.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * Security context for the container.
         */
        export interface KafkaSpecKafkaTemplateInitContainerSecurityContext {
            allowPrivilegeEscalation?: pulumi.Input<boolean>;
            capabilities?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplateInitContainerSecurityContextCapabilities>;
            privileged?: pulumi.Input<boolean>;
            procMount?: pulumi.Input<string>;
            readOnlyRootFilesystem?: pulumi.Input<boolean>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions>;
            windowsOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptions>;
        }

        export interface KafkaSpecKafkaTemplateInitContainerSecurityContextCapabilities {
            add?: pulumi.Input<pulumi.Input<string>[]>;
            drop?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
        }

        /**
         * Template for the Kafka broker container.
         */
        export interface KafkaSpecKafkaTemplateKafkaContainer {
            /**
             * Environment variables which should be applied to the container.
             */
            env?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplateKafkaContainerEnv>[]>;
            /**
             * Security context for the container.
             */
            securityContext?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplateKafkaContainerSecurityContext>;
        }

        export interface KafkaSpecKafkaTemplateKafkaContainerEnv {
            /**
             * The environment variable key.
             */
            name?: pulumi.Input<string>;
            /**
             * The environment variable value.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * Security context for the container.
         */
        export interface KafkaSpecKafkaTemplateKafkaContainerSecurityContext {
            allowPrivilegeEscalation?: pulumi.Input<boolean>;
            capabilities?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplateKafkaContainerSecurityContextCapabilities>;
            privileged?: pulumi.Input<boolean>;
            procMount?: pulumi.Input<string>;
            readOnlyRootFilesystem?: pulumi.Input<boolean>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions>;
            windowsOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptions>;
        }

        export interface KafkaSpecKafkaTemplateKafkaContainerSecurityContextCapabilities {
            add?: pulumi.Input<pulumi.Input<string>[]>;
            drop?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
        }

        /**
         * Template for Kafka per-pod `Ingress` used for access from outside of Kubernetes.
         */
        export interface KafkaSpecKafkaTemplatePerPodIngress {
            /**
             * Metadata applied to the resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePerPodIngressMetadata>;
        }

        /**
         * Metadata applied to the resource.
         */
        export interface KafkaSpecKafkaTemplatePerPodIngressMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Template for Kafka per-pod `Routes` used for access from outside of OpenShift.
         */
        export interface KafkaSpecKafkaTemplatePerPodRoute {
            /**
             * Metadata applied to the resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePerPodRouteMetadata>;
        }

        /**
         * Metadata applied to the resource.
         */
        export interface KafkaSpecKafkaTemplatePerPodRouteMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Template for Kafka per-pod `Services` used for access from outside of Kubernetes.
         */
        export interface KafkaSpecKafkaTemplatePerPodService {
            /**
             * Specifies whether the service routes external traffic to node-local or cluster-wide endpoints. `Cluster` may cause a second hop to another node and obscures the client source IP. `Local` avoids a second hop for LoadBalancer and Nodeport type services and preserves the client source IP (when supported by the infrastructure). If unspecified, Kubernetes will use `Cluster` as the default.
             */
            externalTrafficPolicy?: pulumi.Input<string>;
            /**
             * A list of CIDR ranges (for example `10.0.0.0/8` or `130.211.204.1/32`) from which clients can connect to load balancer type listeners. If supported by the platform, traffic through the loadbalancer is restricted to the specified CIDR ranges. This field is applicable only for loadbalancer type services and is ignored if the cloud provider does not support the feature. For more information, see https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/.
             */
            loadBalancerSourceRanges?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Metadata applied to the resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePerPodServiceMetadata>;
        }

        /**
         * Metadata applied to the resource.
         */
        export interface KafkaSpecKafkaTemplatePerPodServiceMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Template for all Kafka `PersistentVolumeClaims`.
         */
        export interface KafkaSpecKafkaTemplatePersistentVolumeClaim {
            /**
             * Metadata applied to the resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePersistentVolumeClaimMetadata>;
        }

        /**
         * Metadata applied to the resource.
         */
        export interface KafkaSpecKafkaTemplatePersistentVolumeClaimMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Template for Kafka `Pods`.
         */
        export interface KafkaSpecKafkaTemplatePod {
            /**
             * The pod's affinity rules.
             */
            affinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePodAffinity>;
            /**
             * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
             */
            imagePullSecrets?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePodImagePullSecrets>[]>;
            /**
             * Metadata applied to the resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePodMetadata>;
            /**
             * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
             */
            priorityClassName?: pulumi.Input<string>;
            /**
             * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
             */
            schedulerName?: pulumi.Input<string>;
            /**
             * Configures pod-level security attributes and common container settings.
             */
            securityContext?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePodSecurityContext>;
            /**
             * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
             */
            terminationGracePeriodSeconds?: pulumi.Input<number>;
            /**
             * The pod's tolerations.
             */
            tolerations?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePodTolerations>[]>;
        }

        /**
         * The pod's affinity rules.
         */
        export interface KafkaSpecKafkaTemplatePodAffinity {
            nodeAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePodAffinityNodeAffinity>;
            podAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePodAffinityPodAffinity>;
            podAntiAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePodAffinityPodAntiAffinity>;
        }

        export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>;
        }

        export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>[]>;
        }

        export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            nodeSelectorTerms?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>[]>;
        }

        export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>[]>;
        }

        export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecKafkaTemplatePodAffinityPodAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Template for Kafka `PodDisruptionBudget`.
         */
        export interface KafkaSpecKafkaTemplatePodDisruptionBudget {
            /**
             * Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
             */
            maxUnavailable?: pulumi.Input<number>;
            /**
             * Metadata to apply to the `PodDistruptionBugetTemplate` resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePodDisruptionBudgetMetadata>;
        }

        /**
         * Metadata to apply to the `PodDistruptionBugetTemplate` resource.
         */
        export interface KafkaSpecKafkaTemplatePodDisruptionBudgetMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecKafkaTemplatePodImagePullSecrets {
            name?: pulumi.Input<string>;
        }

        /**
         * Metadata applied to the resource.
         */
        export interface KafkaSpecKafkaTemplatePodMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Configures pod-level security attributes and common container settings.
         */
        export interface KafkaSpecKafkaTemplatePodSecurityContext {
            fsGroup?: pulumi.Input<number>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions>;
            supplementalGroups?: pulumi.Input<pulumi.Input<number>[]>;
            sysctls?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePodSecurityContextSysctls>[]>;
            windowsOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplatePodSecurityContextWindowsOptions>;
        }

        export interface KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface KafkaSpecKafkaTemplatePodSecurityContextSysctls {
            name?: pulumi.Input<string>;
            value?: pulumi.Input<string>;
        }

        export interface KafkaSpecKafkaTemplatePodSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
        }

        export interface KafkaSpecKafkaTemplatePodTolerations {
            effect?: pulumi.Input<string>;
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            tolerationSeconds?: pulumi.Input<number>;
            value?: pulumi.Input<string>;
        }

        /**
         * Template for Kafka `StatefulSet`.
         */
        export interface KafkaSpecKafkaTemplateStatefulset {
            /**
             * Metadata applied to the resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplateStatefulsetMetadata>;
            /**
             * PodManagementPolicy which will be used for this StatefulSet. Valid values are `Parallel` and `OrderedReady`. Defaults to `Parallel`.
             */
            podManagementPolicy?: pulumi.Input<string>;
        }

        /**
         * Metadata applied to the resource.
         */
        export interface KafkaSpecKafkaTemplateStatefulsetMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Template for the Kafka broker TLS sidecar container.
         */
        export interface KafkaSpecKafkaTemplateTlsSidecarContainer {
            /**
             * Environment variables which should be applied to the container.
             */
            env?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplateTlsSidecarContainerEnv>[]>;
            /**
             * Security context for the container.
             */
            securityContext?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContext>;
        }

        export interface KafkaSpecKafkaTemplateTlsSidecarContainerEnv {
            /**
             * The environment variable key.
             */
            name?: pulumi.Input<string>;
            /**
             * The environment variable value.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * Security context for the container.
         */
        export interface KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContext {
            allowPrivilegeEscalation?: pulumi.Input<boolean>;
            capabilities?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextCapabilities>;
            privileged?: pulumi.Input<boolean>;
            procMount?: pulumi.Input<string>;
            readOnlyRootFilesystem?: pulumi.Input<boolean>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextSeLinuxOptions>;
            windowsOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextWindowsOptions>;
        }

        export interface KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextCapabilities {
            add?: pulumi.Input<pulumi.Input<string>[]>;
            drop?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
        }

        /**
         * TLS sidecar configuration.
         */
        export interface KafkaSpecKafkaTlsSidecar {
            /**
             * The docker image for the container.
             */
            image?: pulumi.Input<string>;
            /**
             * Pod liveness checking.
             */
            livenessProbe?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTlsSidecarLivenessProbe>;
            /**
             * The log level for the TLS sidecar. Default value is `notice`.
             */
            logLevel?: pulumi.Input<string>;
            /**
             * Pod readiness checking.
             */
            readinessProbe?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTlsSidecarReadinessProbe>;
            /**
             * CPU and memory resources to reserve.
             */
            resources?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecKafkaTlsSidecarResources>;
        }

        /**
         * Pod liveness checking.
         */
        export interface KafkaSpecKafkaTlsSidecarLivenessProbe {
            /**
             * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
             */
            failureThreshold?: pulumi.Input<number>;
            /**
             * The initial delay before first the health is first checked.
             */
            initialDelaySeconds?: pulumi.Input<number>;
            /**
             * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
             */
            successThreshold?: pulumi.Input<number>;
            /**
             * The timeout for each attempted health check.
             */
            timeoutSeconds?: pulumi.Input<number>;
        }

        /**
         * Pod readiness checking.
         */
        export interface KafkaSpecKafkaTlsSidecarReadinessProbe {
            /**
             * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
             */
            failureThreshold?: pulumi.Input<number>;
            /**
             * The initial delay before first the health is first checked.
             */
            initialDelaySeconds?: pulumi.Input<number>;
            /**
             * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
             */
            successThreshold?: pulumi.Input<number>;
            /**
             * The timeout for each attempted health check.
             */
            timeoutSeconds?: pulumi.Input<number>;
        }

        /**
         * CPU and memory resources to reserve.
         */
        export interface KafkaSpecKafkaTlsSidecarResources {
            limits?: pulumi.Input<{[key: string]: any}>;
            requests?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecKafkaTolerations {
            effect?: pulumi.Input<string>;
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            tolerationSeconds?: pulumi.Input<number>;
            value?: pulumi.Input<string>;
        }

        /**
         * Configuration of the Topic Operator.
         */
        export interface KafkaSpecTopicOperator {
            /**
             * Pod affinity rules.
             */
            affinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecTopicOperatorAffinity>;
            /**
             * The image to use for the Topic Operator.
             */
            image?: pulumi.Input<string>;
            /**
             * JVM Options for pods.
             */
            jvmOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecTopicOperatorJvmOptions>;
            /**
             * Pod liveness checking.
             */
            livenessProbe?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecTopicOperatorLivenessProbe>;
            /**
             * Logging configuration.
             */
            logging?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecTopicOperatorLogging>;
            /**
             * Pod readiness checking.
             */
            readinessProbe?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecTopicOperatorReadinessProbe>;
            /**
             * Interval between periodic reconciliations.
             */
            reconciliationIntervalSeconds?: pulumi.Input<number>;
            /**
             * CPU and memory resources to reserve.
             */
            resources?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecTopicOperatorResources>;
            /**
             * TLS sidecar configuration.
             */
            tlsSidecar?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecTopicOperatorTlsSidecar>;
            /**
             * The number of attempts at getting topic metadata.
             */
            topicMetadataMaxAttempts?: pulumi.Input<number>;
            /**
             * The namespace the Topic Operator should watch.
             */
            watchedNamespace?: pulumi.Input<string>;
            /**
             * Timeout for the ZooKeeper session.
             */
            zookeeperSessionTimeoutSeconds?: pulumi.Input<number>;
        }

        /**
         * Pod affinity rules.
         */
        export interface KafkaSpecTopicOperatorAffinity {
            nodeAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecTopicOperatorAffinityNodeAffinity>;
            podAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecTopicOperatorAffinityPodAffinity>;
            podAntiAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecTopicOperatorAffinityPodAntiAffinity>;
        }

        export interface KafkaSpecTopicOperatorAffinityNodeAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>;
        }

        export interface KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>[]>;
        }

        export interface KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            nodeSelectorTerms?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>[]>;
        }

        export interface KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>[]>;
        }

        export interface KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecTopicOperatorAffinityPodAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecTopicOperatorAffinityPodAntiAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * JVM Options for pods.
         */
        export interface KafkaSpecTopicOperatorJvmOptions {
            /**
             * A map of -XX options to the JVM.
             */
            -XX?: pulumi.Input<{[key: string]: any}>;
            /**
             * -Xms option to to the JVM.
             */
            -Xms?: pulumi.Input<string>;
            /**
             * -Xmx option to to the JVM.
             */
            -Xmx?: pulumi.Input<string>;
            /**
             * Specifies whether the Garbage Collection logging is enabled. The default is false.
             */
            gcLoggingEnabled?: pulumi.Input<boolean>;
            /**
             * A map of additional system properties which will be passed using the `-D` option to the JVM.
             */
            javaSystemProperties?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecTopicOperatorJvmOptionsJavaSystemProperties>[]>;
        }

        export interface KafkaSpecTopicOperatorJvmOptionsJavaSystemProperties {
            /**
             * The system property name.
             */
            name?: pulumi.Input<string>;
            /**
             * The system property value.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * Pod liveness checking.
         */
        export interface KafkaSpecTopicOperatorLivenessProbe {
            /**
             * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
             */
            failureThreshold?: pulumi.Input<number>;
            /**
             * The initial delay before first the health is first checked.
             */
            initialDelaySeconds?: pulumi.Input<number>;
            /**
             * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
             */
            successThreshold?: pulumi.Input<number>;
            /**
             * The timeout for each attempted health check.
             */
            timeoutSeconds?: pulumi.Input<number>;
        }

        /**
         * Logging configuration.
         */
        export interface KafkaSpecTopicOperatorLogging {
            /**
             * A Map from logger name to logger level.
             */
            loggers?: pulumi.Input<{[key: string]: any}>;
            /**
             * The name of the `ConfigMap` from which to get the logging configuration.
             */
            name?: pulumi.Input<string>;
            /**
             * Logging type, must be either 'inline' or 'external'.
             */
            type: pulumi.Input<string>;
        }

        /**
         * Pod readiness checking.
         */
        export interface KafkaSpecTopicOperatorReadinessProbe {
            /**
             * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
             */
            failureThreshold?: pulumi.Input<number>;
            /**
             * The initial delay before first the health is first checked.
             */
            initialDelaySeconds?: pulumi.Input<number>;
            /**
             * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
             */
            successThreshold?: pulumi.Input<number>;
            /**
             * The timeout for each attempted health check.
             */
            timeoutSeconds?: pulumi.Input<number>;
        }

        /**
         * CPU and memory resources to reserve.
         */
        export interface KafkaSpecTopicOperatorResources {
            limits?: pulumi.Input<{[key: string]: any}>;
            requests?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * TLS sidecar configuration.
         */
        export interface KafkaSpecTopicOperatorTlsSidecar {
            /**
             * The docker image for the container.
             */
            image?: pulumi.Input<string>;
            /**
             * Pod liveness checking.
             */
            livenessProbe?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecTopicOperatorTlsSidecarLivenessProbe>;
            /**
             * The log level for the TLS sidecar. Default value is `notice`.
             */
            logLevel?: pulumi.Input<string>;
            /**
             * Pod readiness checking.
             */
            readinessProbe?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecTopicOperatorTlsSidecarReadinessProbe>;
            /**
             * CPU and memory resources to reserve.
             */
            resources?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecTopicOperatorTlsSidecarResources>;
        }

        /**
         * Pod liveness checking.
         */
        export interface KafkaSpecTopicOperatorTlsSidecarLivenessProbe {
            /**
             * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
             */
            failureThreshold?: pulumi.Input<number>;
            /**
             * The initial delay before first the health is first checked.
             */
            initialDelaySeconds?: pulumi.Input<number>;
            /**
             * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
             */
            successThreshold?: pulumi.Input<number>;
            /**
             * The timeout for each attempted health check.
             */
            timeoutSeconds?: pulumi.Input<number>;
        }

        /**
         * Pod readiness checking.
         */
        export interface KafkaSpecTopicOperatorTlsSidecarReadinessProbe {
            /**
             * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
             */
            failureThreshold?: pulumi.Input<number>;
            /**
             * The initial delay before first the health is first checked.
             */
            initialDelaySeconds?: pulumi.Input<number>;
            /**
             * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
             */
            successThreshold?: pulumi.Input<number>;
            /**
             * The timeout for each attempted health check.
             */
            timeoutSeconds?: pulumi.Input<number>;
        }

        /**
         * CPU and memory resources to reserve.
         */
        export interface KafkaSpecTopicOperatorTlsSidecarResources {
            limits?: pulumi.Input<{[key: string]: any}>;
            requests?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Configuration of the ZooKeeper cluster.
         */
        export interface KafkaSpecZookeeper {
            /**
             * The pod's affinity rules.
             */
            affinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperAffinity>;
            /**
             * The ZooKeeper broker config. Properties with the following prefixes cannot be set: server., dataDir, dataLogDir, clientPort, authProvider, quorum.auth, requireClientAuthScheme, snapshot.trust.empty, standaloneEnabled, reconfigEnabled, 4lw.commands.whitelist, secureClientPort, ssl., serverCnxnFactory, sslQuorum (with the exception of: ssl.protocol, ssl.quorum.protocol, ssl.enabledProtocols, ssl.quorum.enabledProtocols, ssl.ciphersuites, ssl.quorum.ciphersuites, ssl.hostnameVerification, ssl.quorum.hostnameVerification).
             */
            config?: pulumi.Input<{[key: string]: any}>;
            /**
             * The docker image for the pods.
             */
            image?: pulumi.Input<string>;
            /**
             * JVM Options for pods.
             */
            jvmOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperJvmOptions>;
            /**
             * Pod liveness checking.
             */
            livenessProbe?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperLivenessProbe>;
            /**
             * Logging configuration for ZooKeeper.
             */
            logging?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperLogging>;
            /**
             * The Prometheus JMX Exporter configuration. See https://github.com/prometheus/jmx_exporter for details of the structure of this configuration.
             */
            metrics?: pulumi.Input<{[key: string]: any}>;
            /**
             * Pod readiness checking.
             */
            readinessProbe?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperReadinessProbe>;
            /**
             * The number of pods in the cluster.
             */
            replicas: pulumi.Input<number>;
            /**
             * CPU and memory resources to reserve.
             */
            resources?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperResources>;
            /**
             * Storage configuration (disk). Cannot be updated.
             */
            storage: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperStorage>;
            /**
             * Template for ZooKeeper cluster resources. The template allows users to specify how are the `StatefulSet`, `Pods` and `Services` generated.
             */
            template?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplate>;
            /**
             * TLS sidecar configuration. The TLS sidecar is not used anymore and this option will be ignored.
             */
            tlsSidecar?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTlsSidecar>;
            /**
             * The pod's tolerations.
             */
            tolerations?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTolerations>[]>;
        }

        /**
         * The pod's affinity rules.
         */
        export interface KafkaSpecZookeeperAffinity {
            nodeAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperAffinityNodeAffinity>;
            podAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperAffinityPodAffinity>;
            podAntiAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperAffinityPodAntiAffinity>;
        }

        export interface KafkaSpecZookeeperAffinityNodeAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>;
        }

        export interface KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>[]>;
        }

        export interface KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            nodeSelectorTerms?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>[]>;
        }

        export interface KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>[]>;
        }

        export interface KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecZookeeperAffinityPodAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecZookeeperAffinityPodAntiAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * JVM Options for pods.
         */
        export interface KafkaSpecZookeeperJvmOptions {
            /**
             * A map of -XX options to the JVM.
             */
            -XX?: pulumi.Input<{[key: string]: any}>;
            /**
             * -Xms option to to the JVM.
             */
            -Xms?: pulumi.Input<string>;
            /**
             * -Xmx option to to the JVM.
             */
            -Xmx?: pulumi.Input<string>;
            /**
             * Specifies whether the Garbage Collection logging is enabled. The default is false.
             */
            gcLoggingEnabled?: pulumi.Input<boolean>;
            /**
             * A map of additional system properties which will be passed using the `-D` option to the JVM.
             */
            javaSystemProperties?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperJvmOptionsJavaSystemProperties>[]>;
        }

        export interface KafkaSpecZookeeperJvmOptionsJavaSystemProperties {
            /**
             * The system property name.
             */
            name?: pulumi.Input<string>;
            /**
             * The system property value.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * Pod liveness checking.
         */
        export interface KafkaSpecZookeeperLivenessProbe {
            /**
             * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
             */
            failureThreshold?: pulumi.Input<number>;
            /**
             * The initial delay before first the health is first checked.
             */
            initialDelaySeconds?: pulumi.Input<number>;
            /**
             * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
             */
            successThreshold?: pulumi.Input<number>;
            /**
             * The timeout for each attempted health check.
             */
            timeoutSeconds?: pulumi.Input<number>;
        }

        /**
         * Logging configuration for ZooKeeper.
         */
        export interface KafkaSpecZookeeperLogging {
            /**
             * A Map from logger name to logger level.
             */
            loggers?: pulumi.Input<{[key: string]: any}>;
            /**
             * The name of the `ConfigMap` from which to get the logging configuration.
             */
            name?: pulumi.Input<string>;
            /**
             * Logging type, must be either 'inline' or 'external'.
             */
            type: pulumi.Input<string>;
        }

        /**
         * Pod readiness checking.
         */
        export interface KafkaSpecZookeeperReadinessProbe {
            /**
             * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
             */
            failureThreshold?: pulumi.Input<number>;
            /**
             * The initial delay before first the health is first checked.
             */
            initialDelaySeconds?: pulumi.Input<number>;
            /**
             * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
             */
            successThreshold?: pulumi.Input<number>;
            /**
             * The timeout for each attempted health check.
             */
            timeoutSeconds?: pulumi.Input<number>;
        }

        /**
         * CPU and memory resources to reserve.
         */
        export interface KafkaSpecZookeeperResources {
            limits?: pulumi.Input<{[key: string]: any}>;
            requests?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Storage configuration (disk). Cannot be updated.
         */
        export interface KafkaSpecZookeeperStorage {
            /**
             * The storage class to use for dynamic volume allocation.
             */
            class?: pulumi.Input<string>;
            /**
             * Specifies if the persistent volume claim has to be deleted when the cluster is un-deployed.
             */
            deleteClaim?: pulumi.Input<boolean>;
            /**
             * Storage identification number. It is mandatory only for storage volumes defined in a storage of type 'jbod'.
             */
            id?: pulumi.Input<number>;
            /**
             * Overrides for individual brokers. The `overrides` field allows to specify a different configuration for different brokers.
             */
            overrides?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperStorageOverrides>[]>;
            /**
             * Specifies a specific persistent volume to use. It contains key:value pairs representing labels for selecting such a volume.
             */
            selector?: pulumi.Input<{[key: string]: any}>;
            /**
             * When type=persistent-claim, defines the size of the persistent volume claim (i.e 1Gi). Mandatory when type=persistent-claim.
             */
            size?: pulumi.Input<string>;
            /**
             * When type=ephemeral, defines the total amount of local storage required for this EmptyDir volume (for example 1Gi).
             */
            sizeLimit?: pulumi.Input<string>;
            /**
             * Storage type, must be either 'ephemeral' or 'persistent-claim'.
             */
            type: pulumi.Input<string>;
        }

        export interface KafkaSpecZookeeperStorageOverrides {
            /**
             * Id of the kafka broker (broker identifier).
             */
            broker?: pulumi.Input<number>;
            /**
             * The storage class to use for dynamic volume allocation for this broker.
             */
            class?: pulumi.Input<string>;
        }

        /**
         * Template for ZooKeeper cluster resources. The template allows users to specify how are the `StatefulSet`, `Pods` and `Services` generated.
         */
        export interface KafkaSpecZookeeperTemplate {
            /**
             * Template for ZooKeeper client `Service`.
             */
            clientService?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplateClientService>;
            /**
             * Template for ZooKeeper nodes `Service`.
             */
            nodesService?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplateNodesService>;
            /**
             * Template for all ZooKeeper `PersistentVolumeClaims`.
             */
            persistentVolumeClaim?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplatePersistentVolumeClaim>;
            /**
             * Template for ZooKeeper `Pods`.
             */
            pod?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplatePod>;
            /**
             * Template for ZooKeeper `PodDisruptionBudget`.
             */
            podDisruptionBudget?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplatePodDisruptionBudget>;
            /**
             * Template for ZooKeeper `StatefulSet`.
             */
            statefulset?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplateStatefulset>;
            /**
             * Template for the Zookeeper server TLS sidecar container. The TLS sidecar is not used anymore and this option will be ignored.
             */
            tlsSidecarContainer?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplateTlsSidecarContainer>;
            /**
             * Template for the ZooKeeper container.
             */
            zookeeperContainer?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplateZookeeperContainer>;
        }

        /**
         * Template for ZooKeeper client `Service`.
         */
        export interface KafkaSpecZookeeperTemplateClientService {
            /**
             * Metadata applied to the resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplateClientServiceMetadata>;
        }

        /**
         * Metadata applied to the resource.
         */
        export interface KafkaSpecZookeeperTemplateClientServiceMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Template for ZooKeeper nodes `Service`.
         */
        export interface KafkaSpecZookeeperTemplateNodesService {
            /**
             * Metadata applied to the resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplateNodesServiceMetadata>;
        }

        /**
         * Metadata applied to the resource.
         */
        export interface KafkaSpecZookeeperTemplateNodesServiceMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Template for all ZooKeeper `PersistentVolumeClaims`.
         */
        export interface KafkaSpecZookeeperTemplatePersistentVolumeClaim {
            /**
             * Metadata applied to the resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadata>;
        }

        /**
         * Metadata applied to the resource.
         */
        export interface KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Template for ZooKeeper `Pods`.
         */
        export interface KafkaSpecZookeeperTemplatePod {
            /**
             * The pod's affinity rules.
             */
            affinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplatePodAffinity>;
            /**
             * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
             */
            imagePullSecrets?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplatePodImagePullSecrets>[]>;
            /**
             * Metadata applied to the resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplatePodMetadata>;
            /**
             * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
             */
            priorityClassName?: pulumi.Input<string>;
            /**
             * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
             */
            schedulerName?: pulumi.Input<string>;
            /**
             * Configures pod-level security attributes and common container settings.
             */
            securityContext?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplatePodSecurityContext>;
            /**
             * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
             */
            terminationGracePeriodSeconds?: pulumi.Input<number>;
            /**
             * The pod's tolerations.
             */
            tolerations?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplatePodTolerations>[]>;
        }

        /**
         * The pod's affinity rules.
         */
        export interface KafkaSpecZookeeperTemplatePodAffinity {
            nodeAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplatePodAffinityNodeAffinity>;
            podAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplatePodAffinityPodAffinity>;
            podAntiAffinity?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinity>;
        }

        export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>;
        }

        export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>[]>;
        }

        export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            nodeSelectorTerms?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>[]>;
        }

        export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>[]>;
            matchFields?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>[]>;
        }

        export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinity {
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }

        export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            weight?: pulumi.Input<number>;
        }

        export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            topologyKey?: pulumi.Input<string>;
        }

        export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            matchLabels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Template for ZooKeeper `PodDisruptionBudget`.
         */
        export interface KafkaSpecZookeeperTemplatePodDisruptionBudget {
            /**
             * Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
             */
            maxUnavailable?: pulumi.Input<number>;
            /**
             * Metadata to apply to the `PodDistruptionBugetTemplate` resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadata>;
        }

        /**
         * Metadata to apply to the `PodDistruptionBugetTemplate` resource.
         */
        export interface KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecZookeeperTemplatePodImagePullSecrets {
            name?: pulumi.Input<string>;
        }

        /**
         * Metadata applied to the resource.
         */
        export interface KafkaSpecZookeeperTemplatePodMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Configures pod-level security attributes and common container settings.
         */
        export interface KafkaSpecZookeeperTemplatePodSecurityContext {
            fsGroup?: pulumi.Input<number>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions>;
            supplementalGroups?: pulumi.Input<pulumi.Input<number>[]>;
            sysctls?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplatePodSecurityContextSysctls>[]>;
            windowsOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptions>;
        }

        export interface KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface KafkaSpecZookeeperTemplatePodSecurityContextSysctls {
            name?: pulumi.Input<string>;
            value?: pulumi.Input<string>;
        }

        export interface KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
        }

        export interface KafkaSpecZookeeperTemplatePodTolerations {
            effect?: pulumi.Input<string>;
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            tolerationSeconds?: pulumi.Input<number>;
            value?: pulumi.Input<string>;
        }

        /**
         * Template for ZooKeeper `StatefulSet`.
         */
        export interface KafkaSpecZookeeperTemplateStatefulset {
            /**
             * Metadata applied to the resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplateStatefulsetMetadata>;
            /**
             * PodManagementPolicy which will be used for this StatefulSet. Valid values are `Parallel` and `OrderedReady`. Defaults to `Parallel`.
             */
            podManagementPolicy?: pulumi.Input<string>;
        }

        /**
         * Metadata applied to the resource.
         */
        export interface KafkaSpecZookeeperTemplateStatefulsetMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Template for the Zookeeper server TLS sidecar container. The TLS sidecar is not used anymore and this option will be ignored.
         */
        export interface KafkaSpecZookeeperTemplateTlsSidecarContainer {
            /**
             * Environment variables which should be applied to the container.
             */
            env?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplateTlsSidecarContainerEnv>[]>;
            /**
             * Security context for the container.
             */
            securityContext?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContext>;
        }

        export interface KafkaSpecZookeeperTemplateTlsSidecarContainerEnv {
            /**
             * The environment variable key.
             */
            name?: pulumi.Input<string>;
            /**
             * The environment variable value.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * Security context for the container.
         */
        export interface KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContext {
            allowPrivilegeEscalation?: pulumi.Input<boolean>;
            capabilities?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextCapabilities>;
            privileged?: pulumi.Input<boolean>;
            procMount?: pulumi.Input<string>;
            readOnlyRootFilesystem?: pulumi.Input<boolean>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextSeLinuxOptions>;
            windowsOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextWindowsOptions>;
        }

        export interface KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextCapabilities {
            add?: pulumi.Input<pulumi.Input<string>[]>;
            drop?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
        }

        /**
         * Template for the ZooKeeper container.
         */
        export interface KafkaSpecZookeeperTemplateZookeeperContainer {
            /**
             * Environment variables which should be applied to the container.
             */
            env?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplateZookeeperContainerEnv>[]>;
            /**
             * Security context for the container.
             */
            securityContext?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext>;
        }

        export interface KafkaSpecZookeeperTemplateZookeeperContainerEnv {
            /**
             * The environment variable key.
             */
            name?: pulumi.Input<string>;
            /**
             * The environment variable value.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * Security context for the container.
         */
        export interface KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext {
            allowPrivilegeEscalation?: pulumi.Input<boolean>;
            capabilities?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextCapabilities>;
            privileged?: pulumi.Input<boolean>;
            procMount?: pulumi.Input<string>;
            readOnlyRootFilesystem?: pulumi.Input<boolean>;
            runAsGroup?: pulumi.Input<number>;
            runAsNonRoot?: pulumi.Input<boolean>;
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions>;
            windowsOptions?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptions>;
        }

        export interface KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextCapabilities {
            add?: pulumi.Input<pulumi.Input<string>[]>;
            drop?: pulumi.Input<pulumi.Input<string>[]>;
        }

        export interface KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions {
            level?: pulumi.Input<string>;
            role?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
            user?: pulumi.Input<string>;
        }

        export interface KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptions {
            gmsaCredentialSpec?: pulumi.Input<string>;
            gmsaCredentialSpecName?: pulumi.Input<string>;
        }

        /**
         * TLS sidecar configuration. The TLS sidecar is not used anymore and this option will be ignored.
         */
        export interface KafkaSpecZookeeperTlsSidecar {
            /**
             * The docker image for the container.
             */
            image?: pulumi.Input<string>;
            /**
             * Pod liveness checking.
             */
            livenessProbe?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTlsSidecarLivenessProbe>;
            /**
             * The log level for the TLS sidecar. Default value is `notice`.
             */
            logLevel?: pulumi.Input<string>;
            /**
             * Pod readiness checking.
             */
            readinessProbe?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTlsSidecarReadinessProbe>;
            /**
             * CPU and memory resources to reserve.
             */
            resources?: pulumi.Input<inputs.kafka.v1beta1.KafkaSpecZookeeperTlsSidecarResources>;
        }

        /**
         * Pod liveness checking.
         */
        export interface KafkaSpecZookeeperTlsSidecarLivenessProbe {
            /**
             * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
             */
            failureThreshold?: pulumi.Input<number>;
            /**
             * The initial delay before first the health is first checked.
             */
            initialDelaySeconds?: pulumi.Input<number>;
            /**
             * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
             */
            successThreshold?: pulumi.Input<number>;
            /**
             * The timeout for each attempted health check.
             */
            timeoutSeconds?: pulumi.Input<number>;
        }

        /**
         * Pod readiness checking.
         */
        export interface KafkaSpecZookeeperTlsSidecarReadinessProbe {
            /**
             * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
             */
            failureThreshold?: pulumi.Input<number>;
            /**
             * The initial delay before first the health is first checked.
             */
            initialDelaySeconds?: pulumi.Input<number>;
            /**
             * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
             */
            successThreshold?: pulumi.Input<number>;
            /**
             * The timeout for each attempted health check.
             */
            timeoutSeconds?: pulumi.Input<number>;
        }

        /**
         * CPU and memory resources to reserve.
         */
        export interface KafkaSpecZookeeperTlsSidecarResources {
            limits?: pulumi.Input<{[key: string]: any}>;
            requests?: pulumi.Input<{[key: string]: any}>;
        }

        export interface KafkaSpecZookeeperTolerations {
            effect?: pulumi.Input<string>;
            key?: pulumi.Input<string>;
            operator?: pulumi.Input<string>;
            tolerationSeconds?: pulumi.Input<number>;
            value?: pulumi.Input<string>;
        }

        /**
         * The status of the Kafka and ZooKeeper clusters, and Topic Operator.
         */
        export interface KafkaStatus {
            /**
             * List of status conditions.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaStatusConditions>[]>;
            /**
             * Addresses of the internal and external listeners.
             */
            listeners?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaStatusListeners>[]>;
            /**
             * The generation of the CRD that was last reconciled by the operator.
             */
            observedGeneration?: pulumi.Input<number>;
        }

        export interface KafkaStatusConditions {
            /**
             * Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
             */
            lastTransitionTime?: pulumi.Input<string>;
            /**
             * Human-readable message indicating details about the condition's last transition.
             */
            message?: pulumi.Input<string>;
            /**
             * The reason for the condition's last transition (a single word in CamelCase).
             */
            reason?: pulumi.Input<string>;
            /**
             * The status of the condition, either True, False or Unknown.
             */
            status?: pulumi.Input<string>;
            /**
             * The unique identifier of a condition, used to distinguish between other conditions in the resource.
             */
            type?: pulumi.Input<string>;
        }

        export interface KafkaStatusListeners {
            /**
             * A list of the addresses for this listener.
             */
            addresses?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaStatusListenersAddresses>[]>;
            /**
             * A comma-separated list of `host:port` pairs for connecting to the Kafka cluster using this listener.
             */
            bootstrapServers?: pulumi.Input<string>;
            /**
             * A list of TLS certificates which can be used to verify the identity of the server when connecting to the given listener. Set only for `tls` and `external` listeners.
             */
            certificates?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * The type of the listener. Can be one of the following three types: `plain`, `tls`, and `external`.
             */
            type?: pulumi.Input<string>;
        }

        export interface KafkaStatusListenersAddresses {
            /**
             * The DNS name or IP address of the Kafka bootstrap service.
             */
            host?: pulumi.Input<string>;
            /**
             * The port of the Kafka bootstrap service.
             */
            port?: pulumi.Input<number>;
        }

        /**
         * The specification of the topic.
         */
        export interface KafkaTopicSpec {
            /**
             * The topic configuration.
             */
            config?: pulumi.Input<{[key: string]: any}>;
            /**
             * The number of partitions the topic should have. This cannot be decreased after topic creation. It can be increased after topic creation, but it is important to understand the consequences that has, especially for topics with semantic partitioning.
             */
            partitions: pulumi.Input<number>;
            /**
             * The number of replicas the topic should have.
             */
            replicas: pulumi.Input<number>;
            /**
             * The name of the topic. When absent this will default to the metadata.name of the topic. It is recommended to not set this unless the topic name is not a valid Kubernetes resource name.
             */
            topicName?: pulumi.Input<string>;
        }

        /**
         * The status of the topic.
         */
        export interface KafkaTopicStatus {
            /**
             * List of status conditions.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaTopicStatusConditions>[]>;
            /**
             * The generation of the CRD that was last reconciled by the operator.
             */
            observedGeneration?: pulumi.Input<number>;
        }

        export interface KafkaTopicStatusConditions {
            /**
             * Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
             */
            lastTransitionTime?: pulumi.Input<string>;
            /**
             * Human-readable message indicating details about the condition's last transition.
             */
            message?: pulumi.Input<string>;
            /**
             * The reason for the condition's last transition (a single word in CamelCase).
             */
            reason?: pulumi.Input<string>;
            /**
             * The status of the condition, either True, False or Unknown.
             */
            status?: pulumi.Input<string>;
            /**
             * The unique identifier of a condition, used to distinguish between other conditions in the resource.
             */
            type?: pulumi.Input<string>;
        }

        /**
         * The specification of the user.
         */
        export interface KafkaUserSpec {
            /**
             * Authentication mechanism enabled for this Kafka user.
             */
            authentication?: pulumi.Input<inputs.kafka.v1beta1.KafkaUserSpecAuthentication>;
            /**
             * Authorization rules for this Kafka user.
             */
            authorization?: pulumi.Input<inputs.kafka.v1beta1.KafkaUserSpecAuthorization>;
            /**
             * Quotas on requests to control the broker resources used by clients. Network bandwidth and request rate quotas can be enforced.Kafka documentation for Kafka User quotas can be found at http://kafka.apache.org/documentation/#design_quotas.
             */
            quotas?: pulumi.Input<inputs.kafka.v1beta1.KafkaUserSpecQuotas>;
            /**
             * Template to specify how Kafka User `Secrets` are generated.
             */
            template?: pulumi.Input<inputs.kafka.v1beta1.KafkaUserSpecTemplate>;
        }

        /**
         * Authentication mechanism enabled for this Kafka user.
         */
        export interface KafkaUserSpecAuthentication {
            /**
             * Authentication type.
             */
            type: pulumi.Input<string>;
        }

        /**
         * Authorization rules for this Kafka user.
         */
        export interface KafkaUserSpecAuthorization {
            /**
             * List of ACL rules which should be applied to this user.
             */
            acls: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaUserSpecAuthorizationAcls>[]>;
            /**
             * Authorization type. Currently the only supported type is `simple`. `simple` authorization type uses Kafka's `kafka.security.auth.SimpleAclAuthorizer` class for authorization.
             */
            type: pulumi.Input<string>;
        }

        export interface KafkaUserSpecAuthorizationAcls {
            /**
             * The host from which the action described in the ACL rule is allowed or denied.
             */
            host?: pulumi.Input<string>;
            /**
             * Operation which will be allowed or denied. Supported operations are: Read, Write, Create, Delete, Alter, Describe, ClusterAction, AlterConfigs, DescribeConfigs, IdempotentWrite and All.
             */
            operation: pulumi.Input<string>;
            /**
             * Indicates the resource for which given ACL rule applies.
             */
            resource: pulumi.Input<inputs.kafka.v1beta1.KafkaUserSpecAuthorizationAclsResource>;
            /**
             * The type of the rule. Currently the only supported type is `allow`. ACL rules with type `allow` are used to allow user to execute the specified operations. Default value is `allow`.
             */
            type?: pulumi.Input<string>;
        }

        /**
         * Indicates the resource for which given ACL rule applies.
         */
        export interface KafkaUserSpecAuthorizationAclsResource {
            /**
             * Name of resource for which given ACL rule applies. Can be combined with `patternType` field to use prefix pattern.
             */
            name?: pulumi.Input<string>;
            /**
             * Describes the pattern used in the resource field. The supported types are `literal` and `prefix`. With `literal` pattern type, the resource field will be used as a definition of a full name. With `prefix` pattern type, the resource name will be used only as a prefix. Default value is `literal`.
             */
            patternType?: pulumi.Input<string>;
            /**
             * Resource type. The available resource types are `topic`, `group`, `cluster`, and `transactionalId`.
             */
            type: pulumi.Input<string>;
        }

        /**
         * Quotas on requests to control the broker resources used by clients. Network bandwidth and request rate quotas can be enforced.Kafka documentation for Kafka User quotas can be found at http://kafka.apache.org/documentation/#design_quotas.
         */
        export interface KafkaUserSpecQuotas {
            /**
             * A quota on the maximum bytes per-second that each client group can fetch from a broker before the clients in the group are throttled. Defined on a per-broker basis.
             */
            consumerByteRate?: pulumi.Input<number>;
            /**
             * A quota on the maximum bytes per-second that each client group can publish to a broker before the clients in the group are throttled. Defined on a per-broker basis.
             */
            producerByteRate?: pulumi.Input<number>;
            /**
             * A quota on the maximum CPU utilization of each client group as a percentage of network and I/O threads.
             */
            requestPercentage?: pulumi.Input<number>;
        }

        /**
         * Template to specify how Kafka User `Secrets` are generated.
         */
        export interface KafkaUserSpecTemplate {
            /**
             * Template for KafkaUser resources. The template allows users to specify how the `Secret` with password or TLS certificates is generated.
             */
            secret?: pulumi.Input<inputs.kafka.v1beta1.KafkaUserSpecTemplateSecret>;
        }

        /**
         * Template for KafkaUser resources. The template allows users to specify how the `Secret` with password or TLS certificates is generated.
         */
        export interface KafkaUserSpecTemplateSecret {
            /**
             * Metadata applied to the resource.
             */
            metadata?: pulumi.Input<inputs.kafka.v1beta1.KafkaUserSpecTemplateSecretMetadata>;
        }

        /**
         * Metadata applied to the resource.
         */
        export interface KafkaUserSpecTemplateSecretMetadata {
            /**
             * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            annotations?: pulumi.Input<{[key: string]: any}>;
            /**
             * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
             */
            labels?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * The status of the Kafka User.
         */
        export interface KafkaUserStatus {
            /**
             * List of status conditions.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.kafka.v1beta1.KafkaUserStatusConditions>[]>;
            /**
             * The generation of the CRD that was last reconciled by the operator.
             */
            observedGeneration?: pulumi.Input<number>;
            /**
             * The name of `Secret` where the credentials are stored.
             */
            secret?: pulumi.Input<string>;
            /**
             * Username.
             */
            username?: pulumi.Input<string>;
        }

        export interface KafkaUserStatusConditions {
            /**
             * Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
             */
            lastTransitionTime?: pulumi.Input<string>;
            /**
             * Human-readable message indicating details about the condition's last transition.
             */
            message?: pulumi.Input<string>;
            /**
             * The reason for the condition's last transition (a single word in CamelCase).
             */
            reason?: pulumi.Input<string>;
            /**
             * The status of the condition, either True, False or Unknown.
             */
            status?: pulumi.Input<string>;
            /**
             * The unique identifier of a condition, used to distinguish between other conditions in the resource.
             */
            type?: pulumi.Input<string>;
        }
    }
}
