# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from ... import _utilities, _tables
from . import outputs

__all__ = [
    'KafkaBridgeSpec',
    'KafkaBridgeSpecAuthentication',
    'KafkaBridgeSpecAuthenticationAccessToken',
    'KafkaBridgeSpecAuthenticationCertificateAndKey',
    'KafkaBridgeSpecAuthenticationClientSecret',
    'KafkaBridgeSpecAuthenticationPasswordSecret',
    'KafkaBridgeSpecAuthenticationRefreshToken',
    'KafkaBridgeSpecAuthenticationTlsTrustedCertificates',
    'KafkaBridgeSpecConsumer',
    'KafkaBridgeSpecHttp',
    'KafkaBridgeSpecHttpCors',
    'KafkaBridgeSpecJvmOptions',
    'KafkaBridgeSpecJvmOptionsJavaSystemProperties',
    'KafkaBridgeSpecLivenessProbe',
    'KafkaBridgeSpecLogging',
    'KafkaBridgeSpecProducer',
    'KafkaBridgeSpecReadinessProbe',
    'KafkaBridgeSpecResources',
    'KafkaBridgeSpecTemplate',
    'KafkaBridgeSpecTemplateApiService',
    'KafkaBridgeSpecTemplateApiServiceMetadata',
    'KafkaBridgeSpecTemplateBridgeContainer',
    'KafkaBridgeSpecTemplateBridgeContainerEnv',
    'KafkaBridgeSpecTemplateBridgeContainerSecurityContext',
    'KafkaBridgeSpecTemplateBridgeContainerSecurityContextCapabilities',
    'KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeLinuxOptions',
    'KafkaBridgeSpecTemplateBridgeContainerSecurityContextWindowsOptions',
    'KafkaBridgeSpecTemplateDeployment',
    'KafkaBridgeSpecTemplateDeploymentMetadata',
    'KafkaBridgeSpecTemplatePod',
    'KafkaBridgeSpecTemplatePodAffinity',
    'KafkaBridgeSpecTemplatePodAffinityNodeAffinity',
    'KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference',
    'KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions',
    'KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields',
    'KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms',
    'KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions',
    'KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields',
    'KafkaBridgeSpecTemplatePodAffinityPodAffinity',
    'KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions',
    'KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions',
    'KafkaBridgeSpecTemplatePodAffinityPodAntiAffinity',
    'KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions',
    'KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions',
    'KafkaBridgeSpecTemplatePodDisruptionBudget',
    'KafkaBridgeSpecTemplatePodDisruptionBudgetMetadata',
    'KafkaBridgeSpecTemplatePodHostAliases',
    'KafkaBridgeSpecTemplatePodImagePullSecrets',
    'KafkaBridgeSpecTemplatePodMetadata',
    'KafkaBridgeSpecTemplatePodSecurityContext',
    'KafkaBridgeSpecTemplatePodSecurityContextSeLinuxOptions',
    'KafkaBridgeSpecTemplatePodSecurityContextSysctls',
    'KafkaBridgeSpecTemplatePodSecurityContextWindowsOptions',
    'KafkaBridgeSpecTemplatePodTolerations',
    'KafkaBridgeSpecTls',
    'KafkaBridgeSpecTlsTrustedCertificates',
    'KafkaBridgeSpecTracing',
    'KafkaBridgeStatus',
    'KafkaBridgeStatusConditions',
    'KafkaConnectorSpec',
    'KafkaConnectorStatus',
    'KafkaConnectorStatusConditions',
    'KafkaMirrorMaker2Spec',
    'KafkaMirrorMaker2SpecAffinity',
    'KafkaMirrorMaker2SpecAffinityNodeAffinity',
    'KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference',
    'KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions',
    'KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields',
    'KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms',
    'KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions',
    'KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields',
    'KafkaMirrorMaker2SpecAffinityPodAffinity',
    'KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions',
    'KafkaMirrorMaker2SpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaMirrorMaker2SpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'KafkaMirrorMaker2SpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions',
    'KafkaMirrorMaker2SpecAffinityPodAntiAffinity',
    'KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions',
    'KafkaMirrorMaker2SpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaMirrorMaker2SpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'KafkaMirrorMaker2SpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions',
    'KafkaMirrorMaker2SpecClusters',
    'KafkaMirrorMaker2SpecClustersAuthentication',
    'KafkaMirrorMaker2SpecClustersAuthenticationAccessToken',
    'KafkaMirrorMaker2SpecClustersAuthenticationCertificateAndKey',
    'KafkaMirrorMaker2SpecClustersAuthenticationClientSecret',
    'KafkaMirrorMaker2SpecClustersAuthenticationPasswordSecret',
    'KafkaMirrorMaker2SpecClustersAuthenticationRefreshToken',
    'KafkaMirrorMaker2SpecClustersAuthenticationTlsTrustedCertificates',
    'KafkaMirrorMaker2SpecClustersTls',
    'KafkaMirrorMaker2SpecClustersTlsTrustedCertificates',
    'KafkaMirrorMaker2SpecExternalConfiguration',
    'KafkaMirrorMaker2SpecExternalConfigurationEnv',
    'KafkaMirrorMaker2SpecExternalConfigurationEnvValueFrom',
    'KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromConfigMapKeyRef',
    'KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromSecretKeyRef',
    'KafkaMirrorMaker2SpecExternalConfigurationVolumes',
    'KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMap',
    'KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMapItems',
    'KafkaMirrorMaker2SpecExternalConfigurationVolumesSecret',
    'KafkaMirrorMaker2SpecExternalConfigurationVolumesSecretItems',
    'KafkaMirrorMaker2SpecJvmOptions',
    'KafkaMirrorMaker2SpecJvmOptionsJavaSystemProperties',
    'KafkaMirrorMaker2SpecLivenessProbe',
    'KafkaMirrorMaker2SpecLogging',
    'KafkaMirrorMaker2SpecMirrors',
    'KafkaMirrorMaker2SpecMirrorsCheckpointConnector',
    'KafkaMirrorMaker2SpecMirrorsHeartbeatConnector',
    'KafkaMirrorMaker2SpecMirrorsSourceConnector',
    'KafkaMirrorMaker2SpecReadinessProbe',
    'KafkaMirrorMaker2SpecResources',
    'KafkaMirrorMaker2SpecTemplate',
    'KafkaMirrorMaker2SpecTemplateApiService',
    'KafkaMirrorMaker2SpecTemplateApiServiceMetadata',
    'KafkaMirrorMaker2SpecTemplateConnectContainer',
    'KafkaMirrorMaker2SpecTemplateConnectContainerEnv',
    'KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContext',
    'KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextCapabilities',
    'KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextSeLinuxOptions',
    'KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextWindowsOptions',
    'KafkaMirrorMaker2SpecTemplateDeployment',
    'KafkaMirrorMaker2SpecTemplateDeploymentMetadata',
    'KafkaMirrorMaker2SpecTemplateInitContainer',
    'KafkaMirrorMaker2SpecTemplateInitContainerEnv',
    'KafkaMirrorMaker2SpecTemplateInitContainerSecurityContext',
    'KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextCapabilities',
    'KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextSeLinuxOptions',
    'KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextWindowsOptions',
    'KafkaMirrorMaker2SpecTemplatePod',
    'KafkaMirrorMaker2SpecTemplatePodAffinity',
    'KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinity',
    'KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference',
    'KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions',
    'KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields',
    'KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms',
    'KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions',
    'KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields',
    'KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinity',
    'KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions',
    'KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions',
    'KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinity',
    'KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions',
    'KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions',
    'KafkaMirrorMaker2SpecTemplatePodDisruptionBudget',
    'KafkaMirrorMaker2SpecTemplatePodDisruptionBudgetMetadata',
    'KafkaMirrorMaker2SpecTemplatePodHostAliases',
    'KafkaMirrorMaker2SpecTemplatePodImagePullSecrets',
    'KafkaMirrorMaker2SpecTemplatePodMetadata',
    'KafkaMirrorMaker2SpecTemplatePodSecurityContext',
    'KafkaMirrorMaker2SpecTemplatePodSecurityContextSeLinuxOptions',
    'KafkaMirrorMaker2SpecTemplatePodSecurityContextSysctls',
    'KafkaMirrorMaker2SpecTemplatePodSecurityContextWindowsOptions',
    'KafkaMirrorMaker2SpecTemplatePodTolerations',
    'KafkaMirrorMaker2SpecTolerations',
    'KafkaMirrorMaker2SpecTracing',
    'KafkaMirrorMaker2Status',
    'KafkaMirrorMaker2StatusConditions',
    'KafkaMirrorMaker2StatusConnectorPlugins',
    'KafkaRebalanceSpec',
    'KafkaRebalanceStatus',
    'KafkaRebalanceStatusConditions',
]

@pulumi.output_type
class KafkaBridgeSpec(dict):
    """
    The specification of the Kafka Bridge.
    """
    def __init__(__self__, *,
                 bootstrap_servers: str,
                 authentication: Optional['outputs.KafkaBridgeSpecAuthentication'] = None,
                 consumer: Optional['outputs.KafkaBridgeSpecConsumer'] = None,
                 enable_metrics: Optional[bool] = None,
                 http: Optional['outputs.KafkaBridgeSpecHttp'] = None,
                 image: Optional[str] = None,
                 jvm_options: Optional['outputs.KafkaBridgeSpecJvmOptions'] = None,
                 liveness_probe: Optional['outputs.KafkaBridgeSpecLivenessProbe'] = None,
                 logging: Optional['outputs.KafkaBridgeSpecLogging'] = None,
                 producer: Optional['outputs.KafkaBridgeSpecProducer'] = None,
                 readiness_probe: Optional['outputs.KafkaBridgeSpecReadinessProbe'] = None,
                 replicas: Optional[int] = None,
                 resources: Optional['outputs.KafkaBridgeSpecResources'] = None,
                 template: Optional['outputs.KafkaBridgeSpecTemplate'] = None,
                 tls: Optional['outputs.KafkaBridgeSpecTls'] = None,
                 tracing: Optional['outputs.KafkaBridgeSpecTracing'] = None):
        """
        The specification of the Kafka Bridge.
        :param str bootstrap_servers: A list of host:port pairs for establishing the initial connection to the Kafka cluster.
        :param 'KafkaBridgeSpecAuthenticationArgs' authentication: Authentication configuration for connecting to the cluster.
        :param 'KafkaBridgeSpecConsumerArgs' consumer: Kafka consumer related configuration.
        :param bool enable_metrics: Enable the metrics for the Kafka Bridge. Default is false.
        :param 'KafkaBridgeSpecHttpArgs' http: The HTTP related configuration.
        :param str image: The docker image for the pods.
        :param 'KafkaBridgeSpecJvmOptionsArgs' jvm_options: **Currently not supported** JVM Options for pods.
        :param 'KafkaBridgeSpecLivenessProbeArgs' liveness_probe: Pod liveness checking.
        :param 'KafkaBridgeSpecLoggingArgs' logging: Logging configuration for Kafka Bridge.
        :param 'KafkaBridgeSpecProducerArgs' producer: Kafka producer related configuration.
        :param 'KafkaBridgeSpecReadinessProbeArgs' readiness_probe: Pod readiness checking.
        :param int replicas: The number of pods in the `Deployment`.
        :param 'KafkaBridgeSpecResourcesArgs' resources: CPU and memory resources to reserve.
        :param 'KafkaBridgeSpecTemplateArgs' template: Template for Kafka Bridge resources. The template allows users to specify how is the `Deployment` and `Pods` generated.
        :param 'KafkaBridgeSpecTlsArgs' tls: TLS configuration for connecting Kafka Bridge to the cluster.
        :param 'KafkaBridgeSpecTracingArgs' tracing: The configuration of tracing in Kafka Bridge.
        """
        pulumi.set(__self__, "bootstrap_servers", bootstrap_servers)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if consumer is not None:
            pulumi.set(__self__, "consumer", consumer)
        if enable_metrics is not None:
            pulumi.set(__self__, "enable_metrics", enable_metrics)
        if http is not None:
            pulumi.set(__self__, "http", http)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if jvm_options is not None:
            pulumi.set(__self__, "jvm_options", jvm_options)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)
        if producer is not None:
            pulumi.set(__self__, "producer", producer)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if template is not None:
            pulumi.set(__self__, "template", template)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)
        if tracing is not None:
            pulumi.set(__self__, "tracing", tracing)

    @property
    @pulumi.getter(name="bootstrapServers")
    def bootstrap_servers(self) -> str:
        """
        A list of host:port pairs for establishing the initial connection to the Kafka cluster.
        """
        return pulumi.get(self, "bootstrap_servers")

    @property
    @pulumi.getter
    def authentication(self) -> Optional['outputs.KafkaBridgeSpecAuthentication']:
        """
        Authentication configuration for connecting to the cluster.
        """
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter
    def consumer(self) -> Optional['outputs.KafkaBridgeSpecConsumer']:
        """
        Kafka consumer related configuration.
        """
        return pulumi.get(self, "consumer")

    @property
    @pulumi.getter(name="enableMetrics")
    def enable_metrics(self) -> Optional[bool]:
        """
        Enable the metrics for the Kafka Bridge. Default is false.
        """
        return pulumi.get(self, "enable_metrics")

    @property
    @pulumi.getter
    def http(self) -> Optional['outputs.KafkaBridgeSpecHttp']:
        """
        The HTTP related configuration.
        """
        return pulumi.get(self, "http")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        The docker image for the pods.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="jvmOptions")
    def jvm_options(self) -> Optional['outputs.KafkaBridgeSpecJvmOptions']:
        """
        **Currently not supported** JVM Options for pods.
        """
        return pulumi.get(self, "jvm_options")

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional['outputs.KafkaBridgeSpecLivenessProbe']:
        """
        Pod liveness checking.
        """
        return pulumi.get(self, "liveness_probe")

    @property
    @pulumi.getter
    def logging(self) -> Optional['outputs.KafkaBridgeSpecLogging']:
        """
        Logging configuration for Kafka Bridge.
        """
        return pulumi.get(self, "logging")

    @property
    @pulumi.getter
    def producer(self) -> Optional['outputs.KafkaBridgeSpecProducer']:
        """
        Kafka producer related configuration.
        """
        return pulumi.get(self, "producer")

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional['outputs.KafkaBridgeSpecReadinessProbe']:
        """
        Pod readiness checking.
        """
        return pulumi.get(self, "readiness_probe")

    @property
    @pulumi.getter
    def replicas(self) -> Optional[int]:
        """
        The number of pods in the `Deployment`.
        """
        return pulumi.get(self, "replicas")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.KafkaBridgeSpecResources']:
        """
        CPU and memory resources to reserve.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter
    def template(self) -> Optional['outputs.KafkaBridgeSpecTemplate']:
        """
        Template for Kafka Bridge resources. The template allows users to specify how is the `Deployment` and `Pods` generated.
        """
        return pulumi.get(self, "template")

    @property
    @pulumi.getter
    def tls(self) -> Optional['outputs.KafkaBridgeSpecTls']:
        """
        TLS configuration for connecting Kafka Bridge to the cluster.
        """
        return pulumi.get(self, "tls")

    @property
    @pulumi.getter
    def tracing(self) -> Optional['outputs.KafkaBridgeSpecTracing']:
        """
        The configuration of tracing in Kafka Bridge.
        """
        return pulumi.get(self, "tracing")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecAuthentication(dict):
    """
    Authentication configuration for connecting to the cluster.
    """
    def __init__(__self__, *,
                 type: str,
                 access_token: Optional['outputs.KafkaBridgeSpecAuthenticationAccessToken'] = None,
                 access_token_is_jwt: Optional[bool] = None,
                 certificate_and_key: Optional['outputs.KafkaBridgeSpecAuthenticationCertificateAndKey'] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional['outputs.KafkaBridgeSpecAuthenticationClientSecret'] = None,
                 disable_tls_hostname_verification: Optional[bool] = None,
                 max_token_expiry_seconds: Optional[int] = None,
                 password_secret: Optional['outputs.KafkaBridgeSpecAuthenticationPasswordSecret'] = None,
                 refresh_token: Optional['outputs.KafkaBridgeSpecAuthenticationRefreshToken'] = None,
                 scope: Optional[str] = None,
                 tls_trusted_certificates: Optional[Sequence['outputs.KafkaBridgeSpecAuthenticationTlsTrustedCertificates']] = None,
                 token_endpoint_uri: Optional[str] = None,
                 username: Optional[str] = None):
        """
        Authentication configuration for connecting to the cluster.
        :param str type: Authentication type. Currently the only supported types are `tls`, `scram-sha-512`, and `plain`. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
        :param 'KafkaBridgeSpecAuthenticationAccessTokenArgs' access_token: Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
        :param bool access_token_is_jwt: Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
        :param 'KafkaBridgeSpecAuthenticationCertificateAndKeyArgs' certificate_and_key: Reference to the `Secret` which holds the certificate and private key pair.
        :param str client_id: OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        :param 'KafkaBridgeSpecAuthenticationClientSecretArgs' client_secret: Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        :param bool disable_tls_hostname_verification: Enable or disable TLS hostname verification. Default value is `false`.
        :param int max_token_expiry_seconds: Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.
        :param 'KafkaBridgeSpecAuthenticationPasswordSecretArgs' password_secret: Reference to the `Secret` which holds the password.
        :param 'KafkaBridgeSpecAuthenticationRefreshTokenArgs' refresh_token: Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
        :param str scope: OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.
        :param Sequence['KafkaBridgeSpecAuthenticationTlsTrustedCertificatesArgs'] tls_trusted_certificates: Trusted certificates for TLS connection to the OAuth server.
        :param str token_endpoint_uri: Authorization server token endpoint URI.
        :param str username: Username used for the authentication.
        """
        pulumi.set(__self__, "type", type)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if access_token_is_jwt is not None:
            pulumi.set(__self__, "access_token_is_jwt", access_token_is_jwt)
        if certificate_and_key is not None:
            pulumi.set(__self__, "certificate_and_key", certificate_and_key)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if disable_tls_hostname_verification is not None:
            pulumi.set(__self__, "disable_tls_hostname_verification", disable_tls_hostname_verification)
        if max_token_expiry_seconds is not None:
            pulumi.set(__self__, "max_token_expiry_seconds", max_token_expiry_seconds)
        if password_secret is not None:
            pulumi.set(__self__, "password_secret", password_secret)
        if refresh_token is not None:
            pulumi.set(__self__, "refresh_token", refresh_token)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if tls_trusted_certificates is not None:
            pulumi.set(__self__, "tls_trusted_certificates", tls_trusted_certificates)
        if token_endpoint_uri is not None:
            pulumi.set(__self__, "token_endpoint_uri", token_endpoint_uri)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Authentication type. Currently the only supported types are `tls`, `scram-sha-512`, and `plain`. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional['outputs.KafkaBridgeSpecAuthenticationAccessToken']:
        """
        Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="accessTokenIsJwt")
    def access_token_is_jwt(self) -> Optional[bool]:
        """
        Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
        """
        return pulumi.get(self, "access_token_is_jwt")

    @property
    @pulumi.getter(name="certificateAndKey")
    def certificate_and_key(self) -> Optional['outputs.KafkaBridgeSpecAuthenticationCertificateAndKey']:
        """
        Reference to the `Secret` which holds the certificate and private key pair.
        """
        return pulumi.get(self, "certificate_and_key")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional['outputs.KafkaBridgeSpecAuthenticationClientSecret']:
        """
        Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="disableTlsHostnameVerification")
    def disable_tls_hostname_verification(self) -> Optional[bool]:
        """
        Enable or disable TLS hostname verification. Default value is `false`.
        """
        return pulumi.get(self, "disable_tls_hostname_verification")

    @property
    @pulumi.getter(name="maxTokenExpirySeconds")
    def max_token_expiry_seconds(self) -> Optional[int]:
        """
        Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.
        """
        return pulumi.get(self, "max_token_expiry_seconds")

    @property
    @pulumi.getter(name="passwordSecret")
    def password_secret(self) -> Optional['outputs.KafkaBridgeSpecAuthenticationPasswordSecret']:
        """
        Reference to the `Secret` which holds the password.
        """
        return pulumi.get(self, "password_secret")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional['outputs.KafkaBridgeSpecAuthenticationRefreshToken']:
        """
        Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
        """
        return pulumi.get(self, "refresh_token")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter(name="tlsTrustedCertificates")
    def tls_trusted_certificates(self) -> Optional[Sequence['outputs.KafkaBridgeSpecAuthenticationTlsTrustedCertificates']]:
        """
        Trusted certificates for TLS connection to the OAuth server.
        """
        return pulumi.get(self, "tls_trusted_certificates")

    @property
    @pulumi.getter(name="tokenEndpointUri")
    def token_endpoint_uri(self) -> Optional[str]:
        """
        Authorization server token endpoint URI.
        """
        return pulumi.get(self, "token_endpoint_uri")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username used for the authentication.
        """
        return pulumi.get(self, "username")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecAuthenticationAccessToken(dict):
    """
    Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
    """
    def __init__(__self__, *,
                 key: str,
                 secret_name: str):
        """
        Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
        :param str key: The key under which the secret value is stored in the Kubernetes Secret.
        :param str secret_name: The name of the Kubernetes Secret containing the secret value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key under which the secret value is stored in the Kubernetes Secret.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Kubernetes Secret containing the secret value.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecAuthenticationCertificateAndKey(dict):
    """
    Reference to the `Secret` which holds the certificate and private key pair.
    """
    def __init__(__self__, *,
                 certificate: str,
                 key: str,
                 secret_name: str):
        """
        Reference to the `Secret` which holds the certificate and private key pair.
        :param str certificate: The name of the file certificate in the Secret.
        :param str key: The name of the private key in the Secret.
        :param str secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> str:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The name of the private key in the Secret.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecAuthenticationClientSecret(dict):
    """
    Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
    """
    def __init__(__self__, *,
                 key: str,
                 secret_name: str):
        """
        Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        :param str key: The key under which the secret value is stored in the Kubernetes Secret.
        :param str secret_name: The name of the Kubernetes Secret containing the secret value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key under which the secret value is stored in the Kubernetes Secret.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Kubernetes Secret containing the secret value.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecAuthenticationPasswordSecret(dict):
    """
    Reference to the `Secret` which holds the password.
    """
    def __init__(__self__, *,
                 password: str,
                 secret_name: str):
        """
        Reference to the `Secret` which holds the password.
        :param str password: The name of the key in the Secret under which the password is stored.
        :param str secret_name: The name of the Secret containing the password.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The name of the key in the Secret under which the password is stored.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Secret containing the password.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecAuthenticationRefreshToken(dict):
    """
    Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
    """
    def __init__(__self__, *,
                 key: str,
                 secret_name: str):
        """
        Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
        :param str key: The key under which the secret value is stored in the Kubernetes Secret.
        :param str secret_name: The name of the Kubernetes Secret containing the secret value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key under which the secret value is stored in the Kubernetes Secret.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Kubernetes Secret containing the secret value.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecAuthenticationTlsTrustedCertificates(dict):
    def __init__(__self__, *,
                 certificate: str,
                 secret_name: str):
        """
        :param str certificate: The name of the file certificate in the Secret.
        :param str secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> str:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecConsumer(dict):
    """
    Kafka consumer related configuration.
    """
    def __init__(__self__, *,
                 config: Optional[Mapping[str, Any]] = None):
        """
        Kafka consumer related configuration.
        :param Mapping[str, Any] config: The Kafka consumer configuration used for consumer instances created by the bridge. Properties with the following prefixes cannot be set: ssl., bootstrap.servers, group.id, sasl., security. (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
        """
        if config is not None:
            pulumi.set(__self__, "config", config)

    @property
    @pulumi.getter
    def config(self) -> Optional[Mapping[str, Any]]:
        """
        The Kafka consumer configuration used for consumer instances created by the bridge. Properties with the following prefixes cannot be set: ssl., bootstrap.servers, group.id, sasl., security. (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
        """
        return pulumi.get(self, "config")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecHttp(dict):
    """
    The HTTP related configuration.
    """
    def __init__(__self__, *,
                 cors: Optional['outputs.KafkaBridgeSpecHttpCors'] = None,
                 port: Optional[int] = None):
        """
        The HTTP related configuration.
        :param 'KafkaBridgeSpecHttpCorsArgs' cors: CORS configuration for the HTTP Bridge.
        :param int port: The port which is the server listening on.
        """
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def cors(self) -> Optional['outputs.KafkaBridgeSpecHttpCors']:
        """
        CORS configuration for the HTTP Bridge.
        """
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port which is the server listening on.
        """
        return pulumi.get(self, "port")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecHttpCors(dict):
    """
    CORS configuration for the HTTP Bridge.
    """
    def __init__(__self__, *,
                 allowed_methods: Sequence[str],
                 allowed_origins: Sequence[str]):
        """
        CORS configuration for the HTTP Bridge.
        :param Sequence[str] allowed_methods: List of allowed HTTP methods.
        :param Sequence[str] allowed_origins: List of allowed origins. Java regular expressions can be used.
        """
        pulumi.set(__self__, "allowed_methods", allowed_methods)
        pulumi.set(__self__, "allowed_origins", allowed_origins)

    @property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Sequence[str]:
        """
        List of allowed HTTP methods.
        """
        return pulumi.get(self, "allowed_methods")

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[str]:
        """
        List of allowed origins. Java regular expressions can be used.
        """
        return pulumi.get(self, "allowed_origins")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecJvmOptions(dict):
    """
    **Currently not supported** JVM Options for pods.
    """
    def __init__(__self__, *,
                 __xx: Optional[Mapping[str, Any]] = None,
                 __xms: Optional[str] = None,
                 __xmx: Optional[str] = None,
                 gc_logging_enabled: Optional[bool] = None,
                 java_system_properties: Optional[Sequence['outputs.KafkaBridgeSpecJvmOptionsJavaSystemProperties']] = None):
        """
        **Currently not supported** JVM Options for pods.
        :param Mapping[str, Any] __xx: A map of -XX options to the JVM.
        :param str __xms: -Xms option to to the JVM.
        :param str __xmx: -Xmx option to to the JVM.
        :param bool gc_logging_enabled: Specifies whether the Garbage Collection logging is enabled. The default is false.
        :param Sequence['KafkaBridgeSpecJvmOptionsJavaSystemPropertiesArgs'] java_system_properties: A map of additional system properties which will be passed using the `-D` option to the JVM.
        """
        if __xx is not None:
            pulumi.set(__self__, "__xx", __xx)
        if __xms is not None:
            pulumi.set(__self__, "__xms", __xms)
        if __xmx is not None:
            pulumi.set(__self__, "__xmx", __xmx)
        if gc_logging_enabled is not None:
            pulumi.set(__self__, "gc_logging_enabled", gc_logging_enabled)
        if java_system_properties is not None:
            pulumi.set(__self__, "java_system_properties", java_system_properties)

    @property
    @pulumi.getter(name="-XX")
    def __xx(self) -> Optional[Mapping[str, Any]]:
        """
        A map of -XX options to the JVM.
        """
        return pulumi.get(self, "__xx")

    @property
    @pulumi.getter(name="-Xms")
    def __xms(self) -> Optional[str]:
        """
        -Xms option to to the JVM.
        """
        return pulumi.get(self, "__xms")

    @property
    @pulumi.getter(name="-Xmx")
    def __xmx(self) -> Optional[str]:
        """
        -Xmx option to to the JVM.
        """
        return pulumi.get(self, "__xmx")

    @property
    @pulumi.getter(name="gcLoggingEnabled")
    def gc_logging_enabled(self) -> Optional[bool]:
        """
        Specifies whether the Garbage Collection logging is enabled. The default is false.
        """
        return pulumi.get(self, "gc_logging_enabled")

    @property
    @pulumi.getter(name="javaSystemProperties")
    def java_system_properties(self) -> Optional[Sequence['outputs.KafkaBridgeSpecJvmOptionsJavaSystemProperties']]:
        """
        A map of additional system properties which will be passed using the `-D` option to the JVM.
        """
        return pulumi.get(self, "java_system_properties")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecJvmOptionsJavaSystemProperties(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The system property name.
        :param str value: The system property value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The system property name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The system property value.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecLivenessProbe(dict):
    """
    Pod liveness checking.
    """
    def __init__(__self__, *,
                 failure_threshold: Optional[int] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 timeout_seconds: Optional[int] = None):
        """
        Pod liveness checking.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param int initial_delay_seconds: The initial delay before first the health is first checked.
        :param int period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param int timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecLogging(dict):
    """
    Logging configuration for Kafka Bridge.
    """
    def __init__(__self__, *,
                 type: str,
                 loggers: Optional[Mapping[str, Any]] = None,
                 name: Optional[str] = None):
        """
        Logging configuration for Kafka Bridge.
        :param str type: Logging type, must be either 'inline' or 'external'.
        :param Mapping[str, Any] loggers: A Map from logger name to logger level.
        :param str name: The name of the `ConfigMap` from which to get the logging configuration.
        """
        pulumi.set(__self__, "type", type)
        if loggers is not None:
            pulumi.set(__self__, "loggers", loggers)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Logging type, must be either 'inline' or 'external'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def loggers(self) -> Optional[Mapping[str, Any]]:
        """
        A Map from logger name to logger level.
        """
        return pulumi.get(self, "loggers")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the `ConfigMap` from which to get the logging configuration.
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecProducer(dict):
    """
    Kafka producer related configuration.
    """
    def __init__(__self__, *,
                 config: Optional[Mapping[str, Any]] = None):
        """
        Kafka producer related configuration.
        :param Mapping[str, Any] config: The Kafka producer configuration used for producer instances created by the bridge. Properties with the following prefixes cannot be set: ssl., bootstrap.servers, sasl., security. (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
        """
        if config is not None:
            pulumi.set(__self__, "config", config)

    @property
    @pulumi.getter
    def config(self) -> Optional[Mapping[str, Any]]:
        """
        The Kafka producer configuration used for producer instances created by the bridge. Properties with the following prefixes cannot be set: ssl., bootstrap.servers, sasl., security. (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
        """
        return pulumi.get(self, "config")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecReadinessProbe(dict):
    """
    Pod readiness checking.
    """
    def __init__(__self__, *,
                 failure_threshold: Optional[int] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 timeout_seconds: Optional[int] = None):
        """
        Pod readiness checking.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param int initial_delay_seconds: The initial delay before first the health is first checked.
        :param int period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param int timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecResources(dict):
    """
    CPU and memory resources to reserve.
    """
    def __init__(__self__, *,
                 limits: Optional[Mapping[str, Any]] = None,
                 requests: Optional[Mapping[str, Any]] = None):
        """
        CPU and memory resources to reserve.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "requests")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplate(dict):
    """
    Template for Kafka Bridge resources. The template allows users to specify how is the `Deployment` and `Pods` generated.
    """
    def __init__(__self__, *,
                 api_service: Optional['outputs.KafkaBridgeSpecTemplateApiService'] = None,
                 bridge_container: Optional['outputs.KafkaBridgeSpecTemplateBridgeContainer'] = None,
                 deployment: Optional['outputs.KafkaBridgeSpecTemplateDeployment'] = None,
                 pod: Optional['outputs.KafkaBridgeSpecTemplatePod'] = None,
                 pod_disruption_budget: Optional['outputs.KafkaBridgeSpecTemplatePodDisruptionBudget'] = None):
        """
        Template for Kafka Bridge resources. The template allows users to specify how is the `Deployment` and `Pods` generated.
        :param 'KafkaBridgeSpecTemplateApiServiceArgs' api_service: Template for Kafka Bridge API `Service`.
        :param 'KafkaBridgeSpecTemplateBridgeContainerArgs' bridge_container: Template for the Kafka Bridge container.
        :param 'KafkaBridgeSpecTemplateDeploymentArgs' deployment: Template for Kafka Bridge `Deployment`.
        :param 'KafkaBridgeSpecTemplatePodArgs' pod: Template for Kafka Bridge `Pods`.
        :param 'KafkaBridgeSpecTemplatePodDisruptionBudgetArgs' pod_disruption_budget: Template for Kafka Bridge `PodDisruptionBudget`.
        """
        if api_service is not None:
            pulumi.set(__self__, "api_service", api_service)
        if bridge_container is not None:
            pulumi.set(__self__, "bridge_container", bridge_container)
        if deployment is not None:
            pulumi.set(__self__, "deployment", deployment)
        if pod is not None:
            pulumi.set(__self__, "pod", pod)
        if pod_disruption_budget is not None:
            pulumi.set(__self__, "pod_disruption_budget", pod_disruption_budget)

    @property
    @pulumi.getter(name="apiService")
    def api_service(self) -> Optional['outputs.KafkaBridgeSpecTemplateApiService']:
        """
        Template for Kafka Bridge API `Service`.
        """
        return pulumi.get(self, "api_service")

    @property
    @pulumi.getter(name="bridgeContainer")
    def bridge_container(self) -> Optional['outputs.KafkaBridgeSpecTemplateBridgeContainer']:
        """
        Template for the Kafka Bridge container.
        """
        return pulumi.get(self, "bridge_container")

    @property
    @pulumi.getter
    def deployment(self) -> Optional['outputs.KafkaBridgeSpecTemplateDeployment']:
        """
        Template for Kafka Bridge `Deployment`.
        """
        return pulumi.get(self, "deployment")

    @property
    @pulumi.getter
    def pod(self) -> Optional['outputs.KafkaBridgeSpecTemplatePod']:
        """
        Template for Kafka Bridge `Pods`.
        """
        return pulumi.get(self, "pod")

    @property
    @pulumi.getter(name="podDisruptionBudget")
    def pod_disruption_budget(self) -> Optional['outputs.KafkaBridgeSpecTemplatePodDisruptionBudget']:
        """
        Template for Kafka Bridge `PodDisruptionBudget`.
        """
        return pulumi.get(self, "pod_disruption_budget")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplateApiService(dict):
    """
    Template for Kafka Bridge API `Service`.
    """
    def __init__(__self__, *,
                 metadata: Optional['outputs.KafkaBridgeSpecTemplateApiServiceMetadata'] = None):
        """
        Template for Kafka Bridge API `Service`.
        :param 'KafkaBridgeSpecTemplateApiServiceMetadataArgs' metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaBridgeSpecTemplateApiServiceMetadata']:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplateApiServiceMetadata(dict):
    """
    Metadata applied to the resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata applied to the resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplateBridgeContainer(dict):
    """
    Template for the Kafka Bridge container.
    """
    def __init__(__self__, *,
                 env: Optional[Sequence['outputs.KafkaBridgeSpecTemplateBridgeContainerEnv']] = None,
                 security_context: Optional['outputs.KafkaBridgeSpecTemplateBridgeContainerSecurityContext'] = None):
        """
        Template for the Kafka Bridge container.
        :param Sequence['KafkaBridgeSpecTemplateBridgeContainerEnvArgs'] env: Environment variables which should be applied to the container.
        :param 'KafkaBridgeSpecTemplateBridgeContainerSecurityContextArgs' security_context: Security context for the container.
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)

    @property
    @pulumi.getter
    def env(self) -> Optional[Sequence['outputs.KafkaBridgeSpecTemplateBridgeContainerEnv']]:
        """
        Environment variables which should be applied to the container.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional['outputs.KafkaBridgeSpecTemplateBridgeContainerSecurityContext']:
        """
        Security context for the container.
        """
        return pulumi.get(self, "security_context")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplateBridgeContainerEnv(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The environment variable key.
        :param str value: The environment variable value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The environment variable key.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The environment variable value.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplateBridgeContainerSecurityContext(dict):
    """
    Security context for the container.
    """
    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[bool] = None,
                 capabilities: Optional['outputs.KafkaBridgeSpecTemplateBridgeContainerSecurityContextCapabilities'] = None,
                 privileged: Optional[bool] = None,
                 proc_mount: Optional[str] = None,
                 read_only_root_filesystem: Optional[bool] = None,
                 run_as_group: Optional[int] = None,
                 run_as_non_root: Optional[bool] = None,
                 run_as_user: Optional[int] = None,
                 se_linux_options: Optional['outputs.KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeLinuxOptions'] = None,
                 windows_options: Optional['outputs.KafkaBridgeSpecTemplateBridgeContainerSecurityContextWindowsOptions'] = None):
        """
        Security context for the container.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if proc_mount is not None:
            pulumi.set(__self__, "proc_mount", proc_mount)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[bool]:
        return pulumi.get(self, "allow_privilege_escalation")

    @property
    @pulumi.getter
    def capabilities(self) -> Optional['outputs.KafkaBridgeSpecTemplateBridgeContainerSecurityContextCapabilities']:
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def privileged(self) -> Optional[bool]:
        return pulumi.get(self, "privileged")

    @property
    @pulumi.getter(name="procMount")
    def proc_mount(self) -> Optional[str]:
        return pulumi.get(self, "proc_mount")

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[bool]:
        return pulumi.get(self, "read_only_root_filesystem")

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[int]:
        return pulumi.get(self, "run_as_group")

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[bool]:
        return pulumi.get(self, "run_as_non_root")

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[int]:
        return pulumi.get(self, "run_as_user")

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional['outputs.KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeLinuxOptions']:
        return pulumi.get(self, "se_linux_options")

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional['outputs.KafkaBridgeSpecTemplateBridgeContainerSecurityContextWindowsOptions']:
        return pulumi.get(self, "windows_options")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplateBridgeContainerSecurityContextCapabilities(dict):
    def __init__(__self__, *,
                 add: Optional[Sequence[str]] = None,
                 drop: Optional[Sequence[str]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)

    @property
    @pulumi.getter
    def add(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def drop(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "drop")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeLinuxOptions(dict):
    def __init__(__self__, *,
                 level: Optional[str] = None,
                 role: Optional[str] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        return pulumi.get(self, "user")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplateBridgeContainerSecurityContextWindowsOptions(dict):
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[str] = None,
                 gmsa_credential_spec_name: Optional[str] = None,
                 run_as_user_name: Optional[str] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec")

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[str]:
        return pulumi.get(self, "run_as_user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplateDeployment(dict):
    """
    Template for Kafka Bridge `Deployment`.
    """
    def __init__(__self__, *,
                 metadata: Optional['outputs.KafkaBridgeSpecTemplateDeploymentMetadata'] = None):
        """
        Template for Kafka Bridge `Deployment`.
        :param 'KafkaBridgeSpecTemplateDeploymentMetadataArgs' metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaBridgeSpecTemplateDeploymentMetadata']:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplateDeploymentMetadata(dict):
    """
    Metadata applied to the resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata applied to the resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplatePod(dict):
    """
    Template for Kafka Bridge `Pods`.
    """
    def __init__(__self__, *,
                 affinity: Optional['outputs.KafkaBridgeSpecTemplatePodAffinity'] = None,
                 host_aliases: Optional[Sequence['outputs.KafkaBridgeSpecTemplatePodHostAliases']] = None,
                 image_pull_secrets: Optional[Sequence['outputs.KafkaBridgeSpecTemplatePodImagePullSecrets']] = None,
                 metadata: Optional['outputs.KafkaBridgeSpecTemplatePodMetadata'] = None,
                 priority_class_name: Optional[str] = None,
                 scheduler_name: Optional[str] = None,
                 security_context: Optional['outputs.KafkaBridgeSpecTemplatePodSecurityContext'] = None,
                 termination_grace_period_seconds: Optional[int] = None,
                 tolerations: Optional[Sequence['outputs.KafkaBridgeSpecTemplatePodTolerations']] = None):
        """
        Template for Kafka Bridge `Pods`.
        :param 'KafkaBridgeSpecTemplatePodAffinityArgs' affinity: The pod's affinity rules.
        :param Sequence['KafkaBridgeSpecTemplatePodHostAliasesArgs'] host_aliases: The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
        :param Sequence['KafkaBridgeSpecTemplatePodImagePullSecretsArgs'] image_pull_secrets: List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
        :param 'KafkaBridgeSpecTemplatePodMetadataArgs' metadata: Metadata applied to the resource.
        :param str priority_class_name: The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
        :param str scheduler_name: The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
        :param 'KafkaBridgeSpecTemplatePodSecurityContextArgs' security_context: Configures pod-level security attributes and common container settings.
        :param int termination_grace_period_seconds: The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
        :param Sequence['KafkaBridgeSpecTemplatePodTolerationsArgs'] tolerations: The pod's tolerations.
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if host_aliases is not None:
            pulumi.set(__self__, "host_aliases", host_aliases)
        if image_pull_secrets is not None:
            pulumi.set(__self__, "image_pull_secrets", image_pull_secrets)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if priority_class_name is not None:
            pulumi.set(__self__, "priority_class_name", priority_class_name)
        if scheduler_name is not None:
            pulumi.set(__self__, "scheduler_name", scheduler_name)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)

    @property
    @pulumi.getter
    def affinity(self) -> Optional['outputs.KafkaBridgeSpecTemplatePodAffinity']:
        """
        The pod's affinity rules.
        """
        return pulumi.get(self, "affinity")

    @property
    @pulumi.getter(name="hostAliases")
    def host_aliases(self) -> Optional[Sequence['outputs.KafkaBridgeSpecTemplatePodHostAliases']]:
        """
        The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
        """
        return pulumi.get(self, "host_aliases")

    @property
    @pulumi.getter(name="imagePullSecrets")
    def image_pull_secrets(self) -> Optional[Sequence['outputs.KafkaBridgeSpecTemplatePodImagePullSecrets']]:
        """
        List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
        """
        return pulumi.get(self, "image_pull_secrets")

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaBridgeSpecTemplatePodMetadata']:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter(name="priorityClassName")
    def priority_class_name(self) -> Optional[str]:
        """
        The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
        """
        return pulumi.get(self, "priority_class_name")

    @property
    @pulumi.getter(name="schedulerName")
    def scheduler_name(self) -> Optional[str]:
        """
        The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
        """
        return pulumi.get(self, "scheduler_name")

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional['outputs.KafkaBridgeSpecTemplatePodSecurityContext']:
        """
        Configures pod-level security attributes and common container settings.
        """
        return pulumi.get(self, "security_context")

    @property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[int]:
        """
        The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
        """
        return pulumi.get(self, "termination_grace_period_seconds")

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[Sequence['outputs.KafkaBridgeSpecTemplatePodTolerations']]:
        """
        The pod's tolerations.
        """
        return pulumi.get(self, "tolerations")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplatePodAffinity(dict):
    """
    The pod's affinity rules.
    """
    def __init__(__self__, *,
                 node_affinity: Optional['outputs.KafkaBridgeSpecTemplatePodAffinityNodeAffinity'] = None,
                 pod_affinity: Optional['outputs.KafkaBridgeSpecTemplatePodAffinityPodAffinity'] = None,
                 pod_anti_affinity: Optional['outputs.KafkaBridgeSpecTemplatePodAffinityPodAntiAffinity'] = None):
        """
        The pod's affinity rules.
        """
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional['outputs.KafkaBridgeSpecTemplatePodAffinityNodeAffinity']:
        return pulumi.get(self, "node_affinity")

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional['outputs.KafkaBridgeSpecTemplatePodAffinityPodAffinity']:
        return pulumi.get(self, "pod_affinity")

    @property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional['outputs.KafkaBridgeSpecTemplatePodAffinityPodAntiAffinity']:
        return pulumi.get(self, "pod_anti_affinity")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplatePodAffinityNodeAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional['outputs.KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution'] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional['outputs.KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution']:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 preference: Optional['outputs.KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference'] = None,
                 weight: Optional[int] = None):
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preference(self) -> Optional['outputs.KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference']:
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions']] = None,
                 match_fields: Optional[Sequence['outputs.KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields']] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields']]:
        return pulumi.get(self, "match_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 node_selector_terms: Optional[Sequence['outputs.KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms']] = None):
        if node_selector_terms is not None:
            pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> Optional[Sequence['outputs.KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms']]:
        return pulumi.get(self, "node_selector_terms")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions']] = None,
                 match_fields: Optional[Sequence['outputs.KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields']] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields']]:
        return pulumi.get(self, "match_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplatePodAffinityPodAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 pod_affinity_term: Optional['outputs.KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm'] = None,
                 weight: Optional[int] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional['outputs.KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm']:
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplatePodAffinityPodAntiAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 pod_affinity_term: Optional['outputs.KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm'] = None,
                 weight: Optional[int] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional['outputs.KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm']:
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplatePodDisruptionBudget(dict):
    """
    Template for Kafka Bridge `PodDisruptionBudget`.
    """
    def __init__(__self__, *,
                 max_unavailable: Optional[int] = None,
                 metadata: Optional['outputs.KafkaBridgeSpecTemplatePodDisruptionBudgetMetadata'] = None):
        """
        Template for Kafka Bridge `PodDisruptionBudget`.
        :param int max_unavailable: Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
        :param 'KafkaBridgeSpecTemplatePodDisruptionBudgetMetadataArgs' metadata: Metadata to apply to the `PodDistruptionBugetTemplate` resource.
        """
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[int]:
        """
        Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
        """
        return pulumi.get(self, "max_unavailable")

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaBridgeSpecTemplatePodDisruptionBudgetMetadata']:
        """
        Metadata to apply to the `PodDistruptionBugetTemplate` resource.
        """
        return pulumi.get(self, "metadata")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplatePodDisruptionBudgetMetadata(dict):
    """
    Metadata to apply to the `PodDistruptionBugetTemplate` resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata to apply to the `PodDistruptionBugetTemplate` resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplatePodHostAliases(dict):
    def __init__(__self__, *,
                 hostnames: Optional[Sequence[str]] = None,
                 ip: Optional[str] = None):
        if hostnames is not None:
            pulumi.set(__self__, "hostnames", hostnames)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def hostnames(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "hostnames")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        return pulumi.get(self, "ip")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplatePodImagePullSecrets(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplatePodMetadata(dict):
    """
    Metadata applied to the resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata applied to the resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplatePodSecurityContext(dict):
    """
    Configures pod-level security attributes and common container settings.
    """
    def __init__(__self__, *,
                 fs_group: Optional[int] = None,
                 fs_group_change_policy: Optional[str] = None,
                 run_as_group: Optional[int] = None,
                 run_as_non_root: Optional[bool] = None,
                 run_as_user: Optional[int] = None,
                 se_linux_options: Optional['outputs.KafkaBridgeSpecTemplatePodSecurityContextSeLinuxOptions'] = None,
                 supplemental_groups: Optional[Sequence[int]] = None,
                 sysctls: Optional[Sequence['outputs.KafkaBridgeSpecTemplatePodSecurityContextSysctls']] = None,
                 windows_options: Optional['outputs.KafkaBridgeSpecTemplatePodSecurityContextWindowsOptions'] = None):
        """
        Configures pod-level security attributes and common container settings.
        """
        if fs_group is not None:
            pulumi.set(__self__, "fs_group", fs_group)
        if fs_group_change_policy is not None:
            pulumi.set(__self__, "fs_group_change_policy", fs_group_change_policy)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if supplemental_groups is not None:
            pulumi.set(__self__, "supplemental_groups", supplemental_groups)
        if sysctls is not None:
            pulumi.set(__self__, "sysctls", sysctls)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="fsGroup")
    def fs_group(self) -> Optional[int]:
        return pulumi.get(self, "fs_group")

    @property
    @pulumi.getter(name="fsGroupChangePolicy")
    def fs_group_change_policy(self) -> Optional[str]:
        return pulumi.get(self, "fs_group_change_policy")

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[int]:
        return pulumi.get(self, "run_as_group")

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[bool]:
        return pulumi.get(self, "run_as_non_root")

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[int]:
        return pulumi.get(self, "run_as_user")

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional['outputs.KafkaBridgeSpecTemplatePodSecurityContextSeLinuxOptions']:
        return pulumi.get(self, "se_linux_options")

    @property
    @pulumi.getter(name="supplementalGroups")
    def supplemental_groups(self) -> Optional[Sequence[int]]:
        return pulumi.get(self, "supplemental_groups")

    @property
    @pulumi.getter
    def sysctls(self) -> Optional[Sequence['outputs.KafkaBridgeSpecTemplatePodSecurityContextSysctls']]:
        return pulumi.get(self, "sysctls")

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional['outputs.KafkaBridgeSpecTemplatePodSecurityContextWindowsOptions']:
        return pulumi.get(self, "windows_options")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplatePodSecurityContextSeLinuxOptions(dict):
    def __init__(__self__, *,
                 level: Optional[str] = None,
                 role: Optional[str] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        return pulumi.get(self, "user")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplatePodSecurityContextSysctls(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplatePodSecurityContextWindowsOptions(dict):
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[str] = None,
                 gmsa_credential_spec_name: Optional[str] = None,
                 run_as_user_name: Optional[str] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec")

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[str]:
        return pulumi.get(self, "run_as_user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTemplatePodTolerations(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 toleration_seconds: Optional[int] = None,
                 value: Optional[str] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if toleration_seconds is not None:
            pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> Optional[int]:
        return pulumi.get(self, "toleration_seconds")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTls(dict):
    """
    TLS configuration for connecting Kafka Bridge to the cluster.
    """
    def __init__(__self__, *,
                 trusted_certificates: Optional[Sequence['outputs.KafkaBridgeSpecTlsTrustedCertificates']] = None):
        """
        TLS configuration for connecting Kafka Bridge to the cluster.
        :param Sequence['KafkaBridgeSpecTlsTrustedCertificatesArgs'] trusted_certificates: Trusted certificates for TLS connection.
        """
        if trusted_certificates is not None:
            pulumi.set(__self__, "trusted_certificates", trusted_certificates)

    @property
    @pulumi.getter(name="trustedCertificates")
    def trusted_certificates(self) -> Optional[Sequence['outputs.KafkaBridgeSpecTlsTrustedCertificates']]:
        """
        Trusted certificates for TLS connection.
        """
        return pulumi.get(self, "trusted_certificates")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTlsTrustedCertificates(dict):
    def __init__(__self__, *,
                 certificate: str,
                 secret_name: str):
        """
        :param str certificate: The name of the file certificate in the Secret.
        :param str secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> str:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeSpecTracing(dict):
    """
    The configuration of tracing in Kafka Bridge.
    """
    def __init__(__self__, *,
                 type: str):
        """
        The configuration of tracing in Kafka Bridge.
        :param str type: Type of the tracing used. Currently the only supported type is `jaeger` for Jaeger tracing.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the tracing used. Currently the only supported type is `jaeger` for Jaeger tracing.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeStatus(dict):
    """
    The status of the Kafka Bridge.
    """
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.KafkaBridgeStatusConditions']] = None,
                 label_selector: Optional[str] = None,
                 observed_generation: Optional[int] = None,
                 replicas: Optional[int] = None,
                 url: Optional[str] = None):
        """
        The status of the Kafka Bridge.
        :param Sequence['KafkaBridgeStatusConditionsArgs'] conditions: List of status conditions.
        :param str label_selector: Label selector for pods providing this resource.
        :param int observed_generation: The generation of the CRD that was last reconciled by the operator.
        :param int replicas: The current number of pods being used to provide this resource.
        :param str url: The URL at which external client applications can access the Kafka Bridge.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.KafkaBridgeStatusConditions']]:
        """
        List of status conditions.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[str]:
        """
        Label selector for pods providing this resource.
        """
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[int]:
        """
        The generation of the CRD that was last reconciled by the operator.
        """
        return pulumi.get(self, "observed_generation")

    @property
    @pulumi.getter
    def replicas(self) -> Optional[int]:
        """
        The current number of pods being used to provide this resource.
        """
        return pulumi.get(self, "replicas")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The URL at which external client applications can access the Kafka Bridge.
        """
        return pulumi.get(self, "url")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaBridgeStatusConditions(dict):
    def __init__(__self__, *,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None,
                 status: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str last_transition_time: Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
        :param str message: Human-readable message indicating details about the condition's last transition.
        :param str reason: The reason for the condition's last transition (a single word in CamelCase).
        :param str status: The status of the condition, either True, False or Unknown.
        :param str type: The unique identifier of a condition, used to distinguish between other conditions in the resource.
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Human-readable message indicating details about the condition's last transition.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        The reason for the condition's last transition (a single word in CamelCase).
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The status of the condition, either True, False or Unknown.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The unique identifier of a condition, used to distinguish between other conditions in the resource.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectorSpec(dict):
    """
    The specification of the Kafka Connector.
    """
    def __init__(__self__, *,
                 class_: Optional[str] = None,
                 config: Optional[Mapping[str, Any]] = None,
                 pause: Optional[bool] = None,
                 tasks_max: Optional[int] = None):
        """
        The specification of the Kafka Connector.
        :param str class_: The Class for the Kafka Connector.
        :param Mapping[str, Any] config: The Kafka Connector configuration. The following properties cannot be set: connector.class, tasks.max.
        :param bool pause: Whether the connector should be paused. Defaults to false.
        :param int tasks_max: The maximum number of tasks for the Kafka Connector.
        """
        if class_ is not None:
            pulumi.set(__self__, "class_", class_)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if pause is not None:
            pulumi.set(__self__, "pause", pause)
        if tasks_max is not None:
            pulumi.set(__self__, "tasks_max", tasks_max)

    @property
    @pulumi.getter(name="class")
    def class_(self) -> Optional[str]:
        """
        The Class for the Kafka Connector.
        """
        return pulumi.get(self, "class_")

    @property
    @pulumi.getter
    def config(self) -> Optional[Mapping[str, Any]]:
        """
        The Kafka Connector configuration. The following properties cannot be set: connector.class, tasks.max.
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter
    def pause(self) -> Optional[bool]:
        """
        Whether the connector should be paused. Defaults to false.
        """
        return pulumi.get(self, "pause")

    @property
    @pulumi.getter(name="tasksMax")
    def tasks_max(self) -> Optional[int]:
        """
        The maximum number of tasks for the Kafka Connector.
        """
        return pulumi.get(self, "tasks_max")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectorStatus(dict):
    """
    The status of the Kafka Connector.
    """
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.KafkaConnectorStatusConditions']] = None,
                 connector_status: Optional[Mapping[str, Any]] = None,
                 observed_generation: Optional[int] = None,
                 tasks_max: Optional[int] = None):
        """
        The status of the Kafka Connector.
        :param Sequence['KafkaConnectorStatusConditionsArgs'] conditions: List of status conditions.
        :param Mapping[str, Any] connector_status: The connector status, as reported by the Kafka Connect REST API.
        :param int observed_generation: The generation of the CRD that was last reconciled by the operator.
        :param int tasks_max: The maximum number of tasks for the Kafka Connector.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if connector_status is not None:
            pulumi.set(__self__, "connector_status", connector_status)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if tasks_max is not None:
            pulumi.set(__self__, "tasks_max", tasks_max)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.KafkaConnectorStatusConditions']]:
        """
        List of status conditions.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="connectorStatus")
    def connector_status(self) -> Optional[Mapping[str, Any]]:
        """
        The connector status, as reported by the Kafka Connect REST API.
        """
        return pulumi.get(self, "connector_status")

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[int]:
        """
        The generation of the CRD that was last reconciled by the operator.
        """
        return pulumi.get(self, "observed_generation")

    @property
    @pulumi.getter(name="tasksMax")
    def tasks_max(self) -> Optional[int]:
        """
        The maximum number of tasks for the Kafka Connector.
        """
        return pulumi.get(self, "tasks_max")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectorStatusConditions(dict):
    def __init__(__self__, *,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None,
                 status: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str last_transition_time: Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
        :param str message: Human-readable message indicating details about the condition's last transition.
        :param str reason: The reason for the condition's last transition (a single word in CamelCase).
        :param str status: The status of the condition, either True, False or Unknown.
        :param str type: The unique identifier of a condition, used to distinguish between other conditions in the resource.
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Human-readable message indicating details about the condition's last transition.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        The reason for the condition's last transition (a single word in CamelCase).
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The status of the condition, either True, False or Unknown.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The unique identifier of a condition, used to distinguish between other conditions in the resource.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2Spec(dict):
    """
    The specification of the Kafka MirrorMaker 2.0 cluster.
    """
    def __init__(__self__, *,
                 connect_cluster: str,
                 affinity: Optional['outputs.KafkaMirrorMaker2SpecAffinity'] = None,
                 clusters: Optional[Sequence['outputs.KafkaMirrorMaker2SpecClusters']] = None,
                 external_configuration: Optional['outputs.KafkaMirrorMaker2SpecExternalConfiguration'] = None,
                 image: Optional[str] = None,
                 jvm_options: Optional['outputs.KafkaMirrorMaker2SpecJvmOptions'] = None,
                 liveness_probe: Optional['outputs.KafkaMirrorMaker2SpecLivenessProbe'] = None,
                 logging: Optional['outputs.KafkaMirrorMaker2SpecLogging'] = None,
                 metrics: Optional[Mapping[str, Any]] = None,
                 mirrors: Optional[Sequence['outputs.KafkaMirrorMaker2SpecMirrors']] = None,
                 readiness_probe: Optional['outputs.KafkaMirrorMaker2SpecReadinessProbe'] = None,
                 replicas: Optional[int] = None,
                 resources: Optional['outputs.KafkaMirrorMaker2SpecResources'] = None,
                 template: Optional['outputs.KafkaMirrorMaker2SpecTemplate'] = None,
                 tolerations: Optional[Sequence['outputs.KafkaMirrorMaker2SpecTolerations']] = None,
                 tracing: Optional['outputs.KafkaMirrorMaker2SpecTracing'] = None,
                 version: Optional[str] = None):
        """
        The specification of the Kafka MirrorMaker 2.0 cluster.
        :param str connect_cluster: The cluster alias used for Kafka Connect. The alias must match a cluster in the list at `spec.clusters`.
        :param 'KafkaMirrorMaker2SpecAffinityArgs' affinity: The pod's affinity rules.
        :param Sequence['KafkaMirrorMaker2SpecClustersArgs'] clusters: Kafka clusters for mirroring.
        :param 'KafkaMirrorMaker2SpecExternalConfigurationArgs' external_configuration: Pass data from Secrets or ConfigMaps to the Kafka Connect pods and use them to configure connectors.
        :param str image: The docker image for the pods.
        :param 'KafkaMirrorMaker2SpecJvmOptionsArgs' jvm_options: JVM Options for pods.
        :param 'KafkaMirrorMaker2SpecLivenessProbeArgs' liveness_probe: Pod liveness checking.
        :param 'KafkaMirrorMaker2SpecLoggingArgs' logging: Logging configuration for Kafka Connect.
        :param Mapping[str, Any] metrics: The Prometheus JMX Exporter configuration. See https://github.com/prometheus/jmx_exporter for details of the structure of this configuration.
        :param Sequence['KafkaMirrorMaker2SpecMirrorsArgs'] mirrors: Configuration of the MirrorMaker 2.0 connectors.
        :param 'KafkaMirrorMaker2SpecReadinessProbeArgs' readiness_probe: Pod readiness checking.
        :param int replicas: The number of pods in the Kafka Connect group.
        :param 'KafkaMirrorMaker2SpecResourcesArgs' resources: The maximum limits for CPU and memory resources and the requested initial resources.
        :param 'KafkaMirrorMaker2SpecTemplateArgs' template: Template for Kafka Connect and Kafka Connect S2I resources. The template allows users to specify how the `Deployment`, `Pods` and `Service` are generated.
        :param Sequence['KafkaMirrorMaker2SpecTolerationsArgs'] tolerations: The pod's tolerations.
        :param 'KafkaMirrorMaker2SpecTracingArgs' tracing: The configuration of tracing in Kafka Connect.
        :param str version: The Kafka Connect version. Defaults to {DefaultKafkaVersion}. Consult the user documentation to understand the process required to upgrade or downgrade the version.
        """
        pulumi.set(__self__, "connect_cluster", connect_cluster)
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if clusters is not None:
            pulumi.set(__self__, "clusters", clusters)
        if external_configuration is not None:
            pulumi.set(__self__, "external_configuration", external_configuration)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if jvm_options is not None:
            pulumi.set(__self__, "jvm_options", jvm_options)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if mirrors is not None:
            pulumi.set(__self__, "mirrors", mirrors)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if template is not None:
            pulumi.set(__self__, "template", template)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)
        if tracing is not None:
            pulumi.set(__self__, "tracing", tracing)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="connectCluster")
    def connect_cluster(self) -> str:
        """
        The cluster alias used for Kafka Connect. The alias must match a cluster in the list at `spec.clusters`.
        """
        return pulumi.get(self, "connect_cluster")

    @property
    @pulumi.getter
    def affinity(self) -> Optional['outputs.KafkaMirrorMaker2SpecAffinity']:
        """
        The pod's affinity rules.
        """
        return pulumi.get(self, "affinity")

    @property
    @pulumi.getter
    def clusters(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecClusters']]:
        """
        Kafka clusters for mirroring.
        """
        return pulumi.get(self, "clusters")

    @property
    @pulumi.getter(name="externalConfiguration")
    def external_configuration(self) -> Optional['outputs.KafkaMirrorMaker2SpecExternalConfiguration']:
        """
        Pass data from Secrets or ConfigMaps to the Kafka Connect pods and use them to configure connectors.
        """
        return pulumi.get(self, "external_configuration")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        The docker image for the pods.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="jvmOptions")
    def jvm_options(self) -> Optional['outputs.KafkaMirrorMaker2SpecJvmOptions']:
        """
        JVM Options for pods.
        """
        return pulumi.get(self, "jvm_options")

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional['outputs.KafkaMirrorMaker2SpecLivenessProbe']:
        """
        Pod liveness checking.
        """
        return pulumi.get(self, "liveness_probe")

    @property
    @pulumi.getter
    def logging(self) -> Optional['outputs.KafkaMirrorMaker2SpecLogging']:
        """
        Logging configuration for Kafka Connect.
        """
        return pulumi.get(self, "logging")

    @property
    @pulumi.getter
    def metrics(self) -> Optional[Mapping[str, Any]]:
        """
        The Prometheus JMX Exporter configuration. See https://github.com/prometheus/jmx_exporter for details of the structure of this configuration.
        """
        return pulumi.get(self, "metrics")

    @property
    @pulumi.getter
    def mirrors(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecMirrors']]:
        """
        Configuration of the MirrorMaker 2.0 connectors.
        """
        return pulumi.get(self, "mirrors")

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional['outputs.KafkaMirrorMaker2SpecReadinessProbe']:
        """
        Pod readiness checking.
        """
        return pulumi.get(self, "readiness_probe")

    @property
    @pulumi.getter
    def replicas(self) -> Optional[int]:
        """
        The number of pods in the Kafka Connect group.
        """
        return pulumi.get(self, "replicas")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.KafkaMirrorMaker2SpecResources']:
        """
        The maximum limits for CPU and memory resources and the requested initial resources.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter
    def template(self) -> Optional['outputs.KafkaMirrorMaker2SpecTemplate']:
        """
        Template for Kafka Connect and Kafka Connect S2I resources. The template allows users to specify how the `Deployment`, `Pods` and `Service` are generated.
        """
        return pulumi.get(self, "template")

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecTolerations']]:
        """
        The pod's tolerations.
        """
        return pulumi.get(self, "tolerations")

    @property
    @pulumi.getter
    def tracing(self) -> Optional['outputs.KafkaMirrorMaker2SpecTracing']:
        """
        The configuration of tracing in Kafka Connect.
        """
        return pulumi.get(self, "tracing")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        The Kafka Connect version. Defaults to {DefaultKafkaVersion}. Consult the user documentation to understand the process required to upgrade or downgrade the version.
        """
        return pulumi.get(self, "version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecAffinity(dict):
    """
    The pod's affinity rules.
    """
    def __init__(__self__, *,
                 node_affinity: Optional['outputs.KafkaMirrorMaker2SpecAffinityNodeAffinity'] = None,
                 pod_affinity: Optional['outputs.KafkaMirrorMaker2SpecAffinityPodAffinity'] = None,
                 pod_anti_affinity: Optional['outputs.KafkaMirrorMaker2SpecAffinityPodAntiAffinity'] = None):
        """
        The pod's affinity rules.
        """
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional['outputs.KafkaMirrorMaker2SpecAffinityNodeAffinity']:
        return pulumi.get(self, "node_affinity")

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional['outputs.KafkaMirrorMaker2SpecAffinityPodAffinity']:
        return pulumi.get(self, "pod_affinity")

    @property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional['outputs.KafkaMirrorMaker2SpecAffinityPodAntiAffinity']:
        return pulumi.get(self, "pod_anti_affinity")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecAffinityNodeAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional['outputs.KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution'] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional['outputs.KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution']:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 preference: Optional['outputs.KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference'] = None,
                 weight: Optional[int] = None):
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preference(self) -> Optional['outputs.KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference']:
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions']] = None,
                 match_fields: Optional[Sequence['outputs.KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields']] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields']]:
        return pulumi.get(self, "match_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 node_selector_terms: Optional[Sequence['outputs.KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms']] = None):
        if node_selector_terms is not None:
            pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms']]:
        return pulumi.get(self, "node_selector_terms")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions']] = None,
                 match_fields: Optional[Sequence['outputs.KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields']] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields']]:
        return pulumi.get(self, "match_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecAffinityPodAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaMirrorMaker2SpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 pod_affinity_term: Optional['outputs.KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm'] = None,
                 weight: Optional[int] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional['outputs.KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm']:
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaMirrorMaker2SpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaMirrorMaker2SpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaMirrorMaker2SpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecAffinityPodAntiAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaMirrorMaker2SpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 pod_affinity_term: Optional['outputs.KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm'] = None,
                 weight: Optional[int] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional['outputs.KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm']:
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaMirrorMaker2SpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaMirrorMaker2SpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaMirrorMaker2SpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecClusters(dict):
    def __init__(__self__, *,
                 alias: str,
                 bootstrap_servers: str,
                 authentication: Optional['outputs.KafkaMirrorMaker2SpecClustersAuthentication'] = None,
                 config: Optional[Mapping[str, Any]] = None,
                 tls: Optional['outputs.KafkaMirrorMaker2SpecClustersTls'] = None):
        """
        :param str alias: Alias used to reference the Kafka cluster.
        :param str bootstrap_servers: A comma-separated list of `host:port` pairs for establishing the connection to the Kafka cluster.
        :param 'KafkaMirrorMaker2SpecClustersAuthenticationArgs' authentication: Authentication configuration for connecting to the cluster.
        :param Mapping[str, Any] config: The MirrorMaker 2.0 cluster config. Properties with the following prefixes cannot be set: ssl., sasl., security., listeners, plugin.path, rest., bootstrap.servers, consumer.interceptor.classes, producer.interceptor.classes (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
        :param 'KafkaMirrorMaker2SpecClustersTlsArgs' tls: TLS configuration for connecting MirrorMaker 2.0 connectors to a cluster.
        """
        pulumi.set(__self__, "alias", alias)
        pulumi.set(__self__, "bootstrap_servers", bootstrap_servers)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter
    def alias(self) -> str:
        """
        Alias used to reference the Kafka cluster.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="bootstrapServers")
    def bootstrap_servers(self) -> str:
        """
        A comma-separated list of `host:port` pairs for establishing the connection to the Kafka cluster.
        """
        return pulumi.get(self, "bootstrap_servers")

    @property
    @pulumi.getter
    def authentication(self) -> Optional['outputs.KafkaMirrorMaker2SpecClustersAuthentication']:
        """
        Authentication configuration for connecting to the cluster.
        """
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter
    def config(self) -> Optional[Mapping[str, Any]]:
        """
        The MirrorMaker 2.0 cluster config. Properties with the following prefixes cannot be set: ssl., sasl., security., listeners, plugin.path, rest., bootstrap.servers, consumer.interceptor.classes, producer.interceptor.classes (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter
    def tls(self) -> Optional['outputs.KafkaMirrorMaker2SpecClustersTls']:
        """
        TLS configuration for connecting MirrorMaker 2.0 connectors to a cluster.
        """
        return pulumi.get(self, "tls")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecClustersAuthentication(dict):
    """
    Authentication configuration for connecting to the cluster.
    """
    def __init__(__self__, *,
                 type: str,
                 access_token: Optional['outputs.KafkaMirrorMaker2SpecClustersAuthenticationAccessToken'] = None,
                 access_token_is_jwt: Optional[bool] = None,
                 certificate_and_key: Optional['outputs.KafkaMirrorMaker2SpecClustersAuthenticationCertificateAndKey'] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional['outputs.KafkaMirrorMaker2SpecClustersAuthenticationClientSecret'] = None,
                 disable_tls_hostname_verification: Optional[bool] = None,
                 max_token_expiry_seconds: Optional[int] = None,
                 password_secret: Optional['outputs.KafkaMirrorMaker2SpecClustersAuthenticationPasswordSecret'] = None,
                 refresh_token: Optional['outputs.KafkaMirrorMaker2SpecClustersAuthenticationRefreshToken'] = None,
                 scope: Optional[str] = None,
                 tls_trusted_certificates: Optional[Sequence['outputs.KafkaMirrorMaker2SpecClustersAuthenticationTlsTrustedCertificates']] = None,
                 token_endpoint_uri: Optional[str] = None,
                 username: Optional[str] = None):
        """
        Authentication configuration for connecting to the cluster.
        :param str type: Authentication type. Currently the only supported types are `tls`, `scram-sha-512`, and `plain`. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
        :param 'KafkaMirrorMaker2SpecClustersAuthenticationAccessTokenArgs' access_token: Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
        :param bool access_token_is_jwt: Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
        :param 'KafkaMirrorMaker2SpecClustersAuthenticationCertificateAndKeyArgs' certificate_and_key: Reference to the `Secret` which holds the certificate and private key pair.
        :param str client_id: OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        :param 'KafkaMirrorMaker2SpecClustersAuthenticationClientSecretArgs' client_secret: Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        :param bool disable_tls_hostname_verification: Enable or disable TLS hostname verification. Default value is `false`.
        :param int max_token_expiry_seconds: Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.
        :param 'KafkaMirrorMaker2SpecClustersAuthenticationPasswordSecretArgs' password_secret: Reference to the `Secret` which holds the password.
        :param 'KafkaMirrorMaker2SpecClustersAuthenticationRefreshTokenArgs' refresh_token: Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
        :param str scope: OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.
        :param Sequence['KafkaMirrorMaker2SpecClustersAuthenticationTlsTrustedCertificatesArgs'] tls_trusted_certificates: Trusted certificates for TLS connection to the OAuth server.
        :param str token_endpoint_uri: Authorization server token endpoint URI.
        :param str username: Username used for the authentication.
        """
        pulumi.set(__self__, "type", type)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if access_token_is_jwt is not None:
            pulumi.set(__self__, "access_token_is_jwt", access_token_is_jwt)
        if certificate_and_key is not None:
            pulumi.set(__self__, "certificate_and_key", certificate_and_key)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if disable_tls_hostname_verification is not None:
            pulumi.set(__self__, "disable_tls_hostname_verification", disable_tls_hostname_verification)
        if max_token_expiry_seconds is not None:
            pulumi.set(__self__, "max_token_expiry_seconds", max_token_expiry_seconds)
        if password_secret is not None:
            pulumi.set(__self__, "password_secret", password_secret)
        if refresh_token is not None:
            pulumi.set(__self__, "refresh_token", refresh_token)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if tls_trusted_certificates is not None:
            pulumi.set(__self__, "tls_trusted_certificates", tls_trusted_certificates)
        if token_endpoint_uri is not None:
            pulumi.set(__self__, "token_endpoint_uri", token_endpoint_uri)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Authentication type. Currently the only supported types are `tls`, `scram-sha-512`, and `plain`. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional['outputs.KafkaMirrorMaker2SpecClustersAuthenticationAccessToken']:
        """
        Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="accessTokenIsJwt")
    def access_token_is_jwt(self) -> Optional[bool]:
        """
        Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
        """
        return pulumi.get(self, "access_token_is_jwt")

    @property
    @pulumi.getter(name="certificateAndKey")
    def certificate_and_key(self) -> Optional['outputs.KafkaMirrorMaker2SpecClustersAuthenticationCertificateAndKey']:
        """
        Reference to the `Secret` which holds the certificate and private key pair.
        """
        return pulumi.get(self, "certificate_and_key")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional['outputs.KafkaMirrorMaker2SpecClustersAuthenticationClientSecret']:
        """
        Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="disableTlsHostnameVerification")
    def disable_tls_hostname_verification(self) -> Optional[bool]:
        """
        Enable or disable TLS hostname verification. Default value is `false`.
        """
        return pulumi.get(self, "disable_tls_hostname_verification")

    @property
    @pulumi.getter(name="maxTokenExpirySeconds")
    def max_token_expiry_seconds(self) -> Optional[int]:
        """
        Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.
        """
        return pulumi.get(self, "max_token_expiry_seconds")

    @property
    @pulumi.getter(name="passwordSecret")
    def password_secret(self) -> Optional['outputs.KafkaMirrorMaker2SpecClustersAuthenticationPasswordSecret']:
        """
        Reference to the `Secret` which holds the password.
        """
        return pulumi.get(self, "password_secret")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional['outputs.KafkaMirrorMaker2SpecClustersAuthenticationRefreshToken']:
        """
        Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
        """
        return pulumi.get(self, "refresh_token")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter(name="tlsTrustedCertificates")
    def tls_trusted_certificates(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecClustersAuthenticationTlsTrustedCertificates']]:
        """
        Trusted certificates for TLS connection to the OAuth server.
        """
        return pulumi.get(self, "tls_trusted_certificates")

    @property
    @pulumi.getter(name="tokenEndpointUri")
    def token_endpoint_uri(self) -> Optional[str]:
        """
        Authorization server token endpoint URI.
        """
        return pulumi.get(self, "token_endpoint_uri")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username used for the authentication.
        """
        return pulumi.get(self, "username")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecClustersAuthenticationAccessToken(dict):
    """
    Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
    """
    def __init__(__self__, *,
                 key: str,
                 secret_name: str):
        """
        Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
        :param str key: The key under which the secret value is stored in the Kubernetes Secret.
        :param str secret_name: The name of the Kubernetes Secret containing the secret value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key under which the secret value is stored in the Kubernetes Secret.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Kubernetes Secret containing the secret value.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecClustersAuthenticationCertificateAndKey(dict):
    """
    Reference to the `Secret` which holds the certificate and private key pair.
    """
    def __init__(__self__, *,
                 certificate: str,
                 key: str,
                 secret_name: str):
        """
        Reference to the `Secret` which holds the certificate and private key pair.
        :param str certificate: The name of the file certificate in the Secret.
        :param str key: The name of the private key in the Secret.
        :param str secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> str:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The name of the private key in the Secret.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecClustersAuthenticationClientSecret(dict):
    """
    Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
    """
    def __init__(__self__, *,
                 key: str,
                 secret_name: str):
        """
        Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        :param str key: The key under which the secret value is stored in the Kubernetes Secret.
        :param str secret_name: The name of the Kubernetes Secret containing the secret value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key under which the secret value is stored in the Kubernetes Secret.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Kubernetes Secret containing the secret value.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecClustersAuthenticationPasswordSecret(dict):
    """
    Reference to the `Secret` which holds the password.
    """
    def __init__(__self__, *,
                 password: str,
                 secret_name: str):
        """
        Reference to the `Secret` which holds the password.
        :param str password: The name of the key in the Secret under which the password is stored.
        :param str secret_name: The name of the Secret containing the password.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The name of the key in the Secret under which the password is stored.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Secret containing the password.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecClustersAuthenticationRefreshToken(dict):
    """
    Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
    """
    def __init__(__self__, *,
                 key: str,
                 secret_name: str):
        """
        Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
        :param str key: The key under which the secret value is stored in the Kubernetes Secret.
        :param str secret_name: The name of the Kubernetes Secret containing the secret value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key under which the secret value is stored in the Kubernetes Secret.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Kubernetes Secret containing the secret value.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecClustersAuthenticationTlsTrustedCertificates(dict):
    def __init__(__self__, *,
                 certificate: str,
                 secret_name: str):
        """
        :param str certificate: The name of the file certificate in the Secret.
        :param str secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> str:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecClustersTls(dict):
    """
    TLS configuration for connecting MirrorMaker 2.0 connectors to a cluster.
    """
    def __init__(__self__, *,
                 trusted_certificates: Optional[Sequence['outputs.KafkaMirrorMaker2SpecClustersTlsTrustedCertificates']] = None):
        """
        TLS configuration for connecting MirrorMaker 2.0 connectors to a cluster.
        :param Sequence['KafkaMirrorMaker2SpecClustersTlsTrustedCertificatesArgs'] trusted_certificates: Trusted certificates for TLS connection.
        """
        if trusted_certificates is not None:
            pulumi.set(__self__, "trusted_certificates", trusted_certificates)

    @property
    @pulumi.getter(name="trustedCertificates")
    def trusted_certificates(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecClustersTlsTrustedCertificates']]:
        """
        Trusted certificates for TLS connection.
        """
        return pulumi.get(self, "trusted_certificates")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecClustersTlsTrustedCertificates(dict):
    def __init__(__self__, *,
                 certificate: str,
                 secret_name: str):
        """
        :param str certificate: The name of the file certificate in the Secret.
        :param str secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> str:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecExternalConfiguration(dict):
    """
    Pass data from Secrets or ConfigMaps to the Kafka Connect pods and use them to configure connectors.
    """
    def __init__(__self__, *,
                 env: Optional[Sequence['outputs.KafkaMirrorMaker2SpecExternalConfigurationEnv']] = None,
                 volumes: Optional[Sequence['outputs.KafkaMirrorMaker2SpecExternalConfigurationVolumes']] = None):
        """
        Pass data from Secrets or ConfigMaps to the Kafka Connect pods and use them to configure connectors.
        :param Sequence['KafkaMirrorMaker2SpecExternalConfigurationEnvArgs'] env: Allows to pass data from Secret or ConfigMap to the Kafka Connect pods as environment variables.
        :param Sequence['KafkaMirrorMaker2SpecExternalConfigurationVolumesArgs'] volumes: Allows to pass data from Secret or ConfigMap to the Kafka Connect pods as volumes.
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @property
    @pulumi.getter
    def env(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecExternalConfigurationEnv']]:
        """
        Allows to pass data from Secret or ConfigMap to the Kafka Connect pods as environment variables.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def volumes(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecExternalConfigurationVolumes']]:
        """
        Allows to pass data from Secret or ConfigMap to the Kafka Connect pods as volumes.
        """
        return pulumi.get(self, "volumes")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecExternalConfigurationEnv(dict):
    def __init__(__self__, *,
                 name: str,
                 value_from: 'outputs.KafkaMirrorMaker2SpecExternalConfigurationEnvValueFrom'):
        """
        :param str name: Name of the environment variable which will be passed to the Kafka Connect pods. The name of the environment variable cannot start with `KAFKA_` or `STRIMZI_`.
        :param 'KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromArgs' value_from: Value of the environment variable which will be passed to the Kafka Connect pods. It can be passed either as a reference to Secret or ConfigMap field. The field has to specify exactly one Secret or ConfigMap.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value_from", value_from)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the environment variable which will be passed to the Kafka Connect pods. The name of the environment variable cannot start with `KAFKA_` or `STRIMZI_`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="valueFrom")
    def value_from(self) -> 'outputs.KafkaMirrorMaker2SpecExternalConfigurationEnvValueFrom':
        """
        Value of the environment variable which will be passed to the Kafka Connect pods. It can be passed either as a reference to Secret or ConfigMap field. The field has to specify exactly one Secret or ConfigMap.
        """
        return pulumi.get(self, "value_from")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecExternalConfigurationEnvValueFrom(dict):
    """
    Value of the environment variable which will be passed to the Kafka Connect pods. It can be passed either as a reference to Secret or ConfigMap field. The field has to specify exactly one Secret or ConfigMap.
    """
    def __init__(__self__, *,
                 config_map_key_ref: Optional['outputs.KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromConfigMapKeyRef'] = None,
                 secret_key_ref: Optional['outputs.KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromSecretKeyRef'] = None):
        """
        Value of the environment variable which will be passed to the Kafka Connect pods. It can be passed either as a reference to Secret or ConfigMap field. The field has to specify exactly one Secret or ConfigMap.
        :param 'KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromConfigMapKeyRefArgs' config_map_key_ref: Refernce to a key in a ConfigMap.
        :param 'KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromSecretKeyRefArgs' secret_key_ref: Reference to a key in a Secret.
        """
        if config_map_key_ref is not None:
            pulumi.set(__self__, "config_map_key_ref", config_map_key_ref)
        if secret_key_ref is not None:
            pulumi.set(__self__, "secret_key_ref", secret_key_ref)

    @property
    @pulumi.getter(name="configMapKeyRef")
    def config_map_key_ref(self) -> Optional['outputs.KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromConfigMapKeyRef']:
        """
        Refernce to a key in a ConfigMap.
        """
        return pulumi.get(self, "config_map_key_ref")

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> Optional['outputs.KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromSecretKeyRef']:
        """
        Reference to a key in a Secret.
        """
        return pulumi.get(self, "secret_key_ref")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromConfigMapKeyRef(dict):
    """
    Refernce to a key in a ConfigMap.
    """
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        Refernce to a key in a ConfigMap.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        return pulumi.get(self, "optional")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromSecretKeyRef(dict):
    """
    Reference to a key in a Secret.
    """
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        Reference to a key in a Secret.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        return pulumi.get(self, "optional")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecExternalConfigurationVolumes(dict):
    def __init__(__self__, *,
                 name: str,
                 config_map: Optional['outputs.KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMap'] = None,
                 secret: Optional['outputs.KafkaMirrorMaker2SpecExternalConfigurationVolumesSecret'] = None):
        """
        :param str name: Name of the volume which will be added to the Kafka Connect pods.
        :param 'KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMapArgs' config_map: Reference to a key in a ConfigMap. Exactly one Secret or ConfigMap has to be specified.
        :param 'KafkaMirrorMaker2SpecExternalConfigurationVolumesSecretArgs' secret: Reference to a key in a Secret. Exactly one Secret or ConfigMap has to be specified.
        """
        pulumi.set(__self__, "name", name)
        if config_map is not None:
            pulumi.set(__self__, "config_map", config_map)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the volume which will be added to the Kafka Connect pods.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="configMap")
    def config_map(self) -> Optional['outputs.KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMap']:
        """
        Reference to a key in a ConfigMap. Exactly one Secret or ConfigMap has to be specified.
        """
        return pulumi.get(self, "config_map")

    @property
    @pulumi.getter
    def secret(self) -> Optional['outputs.KafkaMirrorMaker2SpecExternalConfigurationVolumesSecret']:
        """
        Reference to a key in a Secret. Exactly one Secret or ConfigMap has to be specified.
        """
        return pulumi.get(self, "secret")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMap(dict):
    """
    Reference to a key in a ConfigMap. Exactly one Secret or ConfigMap has to be specified.
    """
    def __init__(__self__, *,
                 default_mode: Optional[int] = None,
                 items: Optional[Sequence['outputs.KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMapItems']] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        Reference to a key in a ConfigMap. Exactly one Secret or ConfigMap has to be specified.
        """
        if default_mode is not None:
            pulumi.set(__self__, "default_mode", default_mode)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter(name="defaultMode")
    def default_mode(self) -> Optional[int]:
        return pulumi.get(self, "default_mode")

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMapItems']]:
        return pulumi.get(self, "items")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        return pulumi.get(self, "optional")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMapItems(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 mode: Optional[int] = None,
                 path: Optional[str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def mode(self) -> Optional[int]:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecExternalConfigurationVolumesSecret(dict):
    """
    Reference to a key in a Secret. Exactly one Secret or ConfigMap has to be specified.
    """
    def __init__(__self__, *,
                 default_mode: Optional[int] = None,
                 items: Optional[Sequence['outputs.KafkaMirrorMaker2SpecExternalConfigurationVolumesSecretItems']] = None,
                 optional: Optional[bool] = None,
                 secret_name: Optional[str] = None):
        """
        Reference to a key in a Secret. Exactly one Secret or ConfigMap has to be specified.
        """
        if default_mode is not None:
            pulumi.set(__self__, "default_mode", default_mode)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="defaultMode")
    def default_mode(self) -> Optional[int]:
        return pulumi.get(self, "default_mode")

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecExternalConfigurationVolumesSecretItems']]:
        return pulumi.get(self, "items")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        return pulumi.get(self, "optional")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[str]:
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecExternalConfigurationVolumesSecretItems(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 mode: Optional[int] = None,
                 path: Optional[str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def mode(self) -> Optional[int]:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecJvmOptions(dict):
    """
    JVM Options for pods.
    """
    def __init__(__self__, *,
                 __xx: Optional[Mapping[str, Any]] = None,
                 __xms: Optional[str] = None,
                 __xmx: Optional[str] = None,
                 gc_logging_enabled: Optional[bool] = None,
                 java_system_properties: Optional[Sequence['outputs.KafkaMirrorMaker2SpecJvmOptionsJavaSystemProperties']] = None):
        """
        JVM Options for pods.
        :param Mapping[str, Any] __xx: A map of -XX options to the JVM.
        :param str __xms: -Xms option to to the JVM.
        :param str __xmx: -Xmx option to to the JVM.
        :param bool gc_logging_enabled: Specifies whether the Garbage Collection logging is enabled. The default is false.
        :param Sequence['KafkaMirrorMaker2SpecJvmOptionsJavaSystemPropertiesArgs'] java_system_properties: A map of additional system properties which will be passed using the `-D` option to the JVM.
        """
        if __xx is not None:
            pulumi.set(__self__, "__xx", __xx)
        if __xms is not None:
            pulumi.set(__self__, "__xms", __xms)
        if __xmx is not None:
            pulumi.set(__self__, "__xmx", __xmx)
        if gc_logging_enabled is not None:
            pulumi.set(__self__, "gc_logging_enabled", gc_logging_enabled)
        if java_system_properties is not None:
            pulumi.set(__self__, "java_system_properties", java_system_properties)

    @property
    @pulumi.getter(name="-XX")
    def __xx(self) -> Optional[Mapping[str, Any]]:
        """
        A map of -XX options to the JVM.
        """
        return pulumi.get(self, "__xx")

    @property
    @pulumi.getter(name="-Xms")
    def __xms(self) -> Optional[str]:
        """
        -Xms option to to the JVM.
        """
        return pulumi.get(self, "__xms")

    @property
    @pulumi.getter(name="-Xmx")
    def __xmx(self) -> Optional[str]:
        """
        -Xmx option to to the JVM.
        """
        return pulumi.get(self, "__xmx")

    @property
    @pulumi.getter(name="gcLoggingEnabled")
    def gc_logging_enabled(self) -> Optional[bool]:
        """
        Specifies whether the Garbage Collection logging is enabled. The default is false.
        """
        return pulumi.get(self, "gc_logging_enabled")

    @property
    @pulumi.getter(name="javaSystemProperties")
    def java_system_properties(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecJvmOptionsJavaSystemProperties']]:
        """
        A map of additional system properties which will be passed using the `-D` option to the JVM.
        """
        return pulumi.get(self, "java_system_properties")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecJvmOptionsJavaSystemProperties(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The system property name.
        :param str value: The system property value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The system property name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The system property value.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecLivenessProbe(dict):
    """
    Pod liveness checking.
    """
    def __init__(__self__, *,
                 failure_threshold: Optional[int] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 timeout_seconds: Optional[int] = None):
        """
        Pod liveness checking.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param int initial_delay_seconds: The initial delay before first the health is first checked.
        :param int period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param int timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecLogging(dict):
    """
    Logging configuration for Kafka Connect.
    """
    def __init__(__self__, *,
                 type: str,
                 loggers: Optional[Mapping[str, Any]] = None,
                 name: Optional[str] = None):
        """
        Logging configuration for Kafka Connect.
        :param str type: Logging type, must be either 'inline' or 'external'.
        :param Mapping[str, Any] loggers: A Map from logger name to logger level.
        :param str name: The name of the `ConfigMap` from which to get the logging configuration.
        """
        pulumi.set(__self__, "type", type)
        if loggers is not None:
            pulumi.set(__self__, "loggers", loggers)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Logging type, must be either 'inline' or 'external'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def loggers(self) -> Optional[Mapping[str, Any]]:
        """
        A Map from logger name to logger level.
        """
        return pulumi.get(self, "loggers")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the `ConfigMap` from which to get the logging configuration.
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecMirrors(dict):
    def __init__(__self__, *,
                 source_cluster: str,
                 target_cluster: str,
                 checkpoint_connector: Optional['outputs.KafkaMirrorMaker2SpecMirrorsCheckpointConnector'] = None,
                 groups_blacklist_pattern: Optional[str] = None,
                 groups_pattern: Optional[str] = None,
                 heartbeat_connector: Optional['outputs.KafkaMirrorMaker2SpecMirrorsHeartbeatConnector'] = None,
                 source_connector: Optional['outputs.KafkaMirrorMaker2SpecMirrorsSourceConnector'] = None,
                 topics_blacklist_pattern: Optional[str] = None,
                 topics_pattern: Optional[str] = None):
        """
        :param str source_cluster: The alias of the source cluster used by the Kafka MirrorMaker 2.0 connectors. The alias must match a cluster in the list at `spec.clusters`.
        :param str target_cluster: The alias of the target cluster used by the Kafka MirrorMaker 2.0 connectors. The alias must match a cluster in the list at `spec.clusters`.
        :param 'KafkaMirrorMaker2SpecMirrorsCheckpointConnectorArgs' checkpoint_connector: The specification of the Kafka MirrorMaker 2.0 checkpoint connector.
        :param str groups_blacklist_pattern: A regular expression matching the consumer groups to exclude from mirroring. Comma-separated lists are also supported.
        :param str groups_pattern: A regular expression matching the consumer groups to be mirrored. Comma-separated lists are also supported.
        :param 'KafkaMirrorMaker2SpecMirrorsHeartbeatConnectorArgs' heartbeat_connector: The specification of the Kafka MirrorMaker 2.0 heartbeat connector.
        :param 'KafkaMirrorMaker2SpecMirrorsSourceConnectorArgs' source_connector: The specification of the Kafka MirrorMaker 2.0 source connector.
        :param str topics_blacklist_pattern: A regular expression matching the topics to exclude from mirroring. Comma-separated lists are also supported.
        :param str topics_pattern: A regular expression matching the topics to be mirrored, for example, "topic1\|topic2\|topic3". Comma-separated lists are also supported.
        """
        pulumi.set(__self__, "source_cluster", source_cluster)
        pulumi.set(__self__, "target_cluster", target_cluster)
        if checkpoint_connector is not None:
            pulumi.set(__self__, "checkpoint_connector", checkpoint_connector)
        if groups_blacklist_pattern is not None:
            pulumi.set(__self__, "groups_blacklist_pattern", groups_blacklist_pattern)
        if groups_pattern is not None:
            pulumi.set(__self__, "groups_pattern", groups_pattern)
        if heartbeat_connector is not None:
            pulumi.set(__self__, "heartbeat_connector", heartbeat_connector)
        if source_connector is not None:
            pulumi.set(__self__, "source_connector", source_connector)
        if topics_blacklist_pattern is not None:
            pulumi.set(__self__, "topics_blacklist_pattern", topics_blacklist_pattern)
        if topics_pattern is not None:
            pulumi.set(__self__, "topics_pattern", topics_pattern)

    @property
    @pulumi.getter(name="sourceCluster")
    def source_cluster(self) -> str:
        """
        The alias of the source cluster used by the Kafka MirrorMaker 2.0 connectors. The alias must match a cluster in the list at `spec.clusters`.
        """
        return pulumi.get(self, "source_cluster")

    @property
    @pulumi.getter(name="targetCluster")
    def target_cluster(self) -> str:
        """
        The alias of the target cluster used by the Kafka MirrorMaker 2.0 connectors. The alias must match a cluster in the list at `spec.clusters`.
        """
        return pulumi.get(self, "target_cluster")

    @property
    @pulumi.getter(name="checkpointConnector")
    def checkpoint_connector(self) -> Optional['outputs.KafkaMirrorMaker2SpecMirrorsCheckpointConnector']:
        """
        The specification of the Kafka MirrorMaker 2.0 checkpoint connector.
        """
        return pulumi.get(self, "checkpoint_connector")

    @property
    @pulumi.getter(name="groupsBlacklistPattern")
    def groups_blacklist_pattern(self) -> Optional[str]:
        """
        A regular expression matching the consumer groups to exclude from mirroring. Comma-separated lists are also supported.
        """
        return pulumi.get(self, "groups_blacklist_pattern")

    @property
    @pulumi.getter(name="groupsPattern")
    def groups_pattern(self) -> Optional[str]:
        """
        A regular expression matching the consumer groups to be mirrored. Comma-separated lists are also supported.
        """
        return pulumi.get(self, "groups_pattern")

    @property
    @pulumi.getter(name="heartbeatConnector")
    def heartbeat_connector(self) -> Optional['outputs.KafkaMirrorMaker2SpecMirrorsHeartbeatConnector']:
        """
        The specification of the Kafka MirrorMaker 2.0 heartbeat connector.
        """
        return pulumi.get(self, "heartbeat_connector")

    @property
    @pulumi.getter(name="sourceConnector")
    def source_connector(self) -> Optional['outputs.KafkaMirrorMaker2SpecMirrorsSourceConnector']:
        """
        The specification of the Kafka MirrorMaker 2.0 source connector.
        """
        return pulumi.get(self, "source_connector")

    @property
    @pulumi.getter(name="topicsBlacklistPattern")
    def topics_blacklist_pattern(self) -> Optional[str]:
        """
        A regular expression matching the topics to exclude from mirroring. Comma-separated lists are also supported.
        """
        return pulumi.get(self, "topics_blacklist_pattern")

    @property
    @pulumi.getter(name="topicsPattern")
    def topics_pattern(self) -> Optional[str]:
        """
        A regular expression matching the topics to be mirrored, for example, "topic1\|topic2\|topic3". Comma-separated lists are also supported.
        """
        return pulumi.get(self, "topics_pattern")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecMirrorsCheckpointConnector(dict):
    """
    The specification of the Kafka MirrorMaker 2.0 checkpoint connector.
    """
    def __init__(__self__, *,
                 config: Optional[Mapping[str, Any]] = None,
                 pause: Optional[bool] = None,
                 tasks_max: Optional[int] = None):
        """
        The specification of the Kafka MirrorMaker 2.0 checkpoint connector.
        :param Mapping[str, Any] config: The Kafka Connector configuration. The following properties cannot be set: connector.class, tasks.max.
        :param bool pause: Whether the connector should be paused. Defaults to false.
        :param int tasks_max: The maximum number of tasks for the Kafka Connector.
        """
        if config is not None:
            pulumi.set(__self__, "config", config)
        if pause is not None:
            pulumi.set(__self__, "pause", pause)
        if tasks_max is not None:
            pulumi.set(__self__, "tasks_max", tasks_max)

    @property
    @pulumi.getter
    def config(self) -> Optional[Mapping[str, Any]]:
        """
        The Kafka Connector configuration. The following properties cannot be set: connector.class, tasks.max.
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter
    def pause(self) -> Optional[bool]:
        """
        Whether the connector should be paused. Defaults to false.
        """
        return pulumi.get(self, "pause")

    @property
    @pulumi.getter(name="tasksMax")
    def tasks_max(self) -> Optional[int]:
        """
        The maximum number of tasks for the Kafka Connector.
        """
        return pulumi.get(self, "tasks_max")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecMirrorsHeartbeatConnector(dict):
    """
    The specification of the Kafka MirrorMaker 2.0 heartbeat connector.
    """
    def __init__(__self__, *,
                 config: Optional[Mapping[str, Any]] = None,
                 pause: Optional[bool] = None,
                 tasks_max: Optional[int] = None):
        """
        The specification of the Kafka MirrorMaker 2.0 heartbeat connector.
        :param Mapping[str, Any] config: The Kafka Connector configuration. The following properties cannot be set: connector.class, tasks.max.
        :param bool pause: Whether the connector should be paused. Defaults to false.
        :param int tasks_max: The maximum number of tasks for the Kafka Connector.
        """
        if config is not None:
            pulumi.set(__self__, "config", config)
        if pause is not None:
            pulumi.set(__self__, "pause", pause)
        if tasks_max is not None:
            pulumi.set(__self__, "tasks_max", tasks_max)

    @property
    @pulumi.getter
    def config(self) -> Optional[Mapping[str, Any]]:
        """
        The Kafka Connector configuration. The following properties cannot be set: connector.class, tasks.max.
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter
    def pause(self) -> Optional[bool]:
        """
        Whether the connector should be paused. Defaults to false.
        """
        return pulumi.get(self, "pause")

    @property
    @pulumi.getter(name="tasksMax")
    def tasks_max(self) -> Optional[int]:
        """
        The maximum number of tasks for the Kafka Connector.
        """
        return pulumi.get(self, "tasks_max")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecMirrorsSourceConnector(dict):
    """
    The specification of the Kafka MirrorMaker 2.0 source connector.
    """
    def __init__(__self__, *,
                 config: Optional[Mapping[str, Any]] = None,
                 pause: Optional[bool] = None,
                 tasks_max: Optional[int] = None):
        """
        The specification of the Kafka MirrorMaker 2.0 source connector.
        :param Mapping[str, Any] config: The Kafka Connector configuration. The following properties cannot be set: connector.class, tasks.max.
        :param bool pause: Whether the connector should be paused. Defaults to false.
        :param int tasks_max: The maximum number of tasks for the Kafka Connector.
        """
        if config is not None:
            pulumi.set(__self__, "config", config)
        if pause is not None:
            pulumi.set(__self__, "pause", pause)
        if tasks_max is not None:
            pulumi.set(__self__, "tasks_max", tasks_max)

    @property
    @pulumi.getter
    def config(self) -> Optional[Mapping[str, Any]]:
        """
        The Kafka Connector configuration. The following properties cannot be set: connector.class, tasks.max.
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter
    def pause(self) -> Optional[bool]:
        """
        Whether the connector should be paused. Defaults to false.
        """
        return pulumi.get(self, "pause")

    @property
    @pulumi.getter(name="tasksMax")
    def tasks_max(self) -> Optional[int]:
        """
        The maximum number of tasks for the Kafka Connector.
        """
        return pulumi.get(self, "tasks_max")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecReadinessProbe(dict):
    """
    Pod readiness checking.
    """
    def __init__(__self__, *,
                 failure_threshold: Optional[int] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 timeout_seconds: Optional[int] = None):
        """
        Pod readiness checking.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param int initial_delay_seconds: The initial delay before first the health is first checked.
        :param int period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param int timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecResources(dict):
    """
    The maximum limits for CPU and memory resources and the requested initial resources.
    """
    def __init__(__self__, *,
                 limits: Optional[Mapping[str, Any]] = None,
                 requests: Optional[Mapping[str, Any]] = None):
        """
        The maximum limits for CPU and memory resources and the requested initial resources.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "requests")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplate(dict):
    """
    Template for Kafka Connect and Kafka Connect S2I resources. The template allows users to specify how the `Deployment`, `Pods` and `Service` are generated.
    """
    def __init__(__self__, *,
                 api_service: Optional['outputs.KafkaMirrorMaker2SpecTemplateApiService'] = None,
                 connect_container: Optional['outputs.KafkaMirrorMaker2SpecTemplateConnectContainer'] = None,
                 deployment: Optional['outputs.KafkaMirrorMaker2SpecTemplateDeployment'] = None,
                 init_container: Optional['outputs.KafkaMirrorMaker2SpecTemplateInitContainer'] = None,
                 pod: Optional['outputs.KafkaMirrorMaker2SpecTemplatePod'] = None,
                 pod_disruption_budget: Optional['outputs.KafkaMirrorMaker2SpecTemplatePodDisruptionBudget'] = None):
        """
        Template for Kafka Connect and Kafka Connect S2I resources. The template allows users to specify how the `Deployment`, `Pods` and `Service` are generated.
        :param 'KafkaMirrorMaker2SpecTemplateApiServiceArgs' api_service: Template for Kafka Connect API `Service`.
        :param 'KafkaMirrorMaker2SpecTemplateConnectContainerArgs' connect_container: Template for the Kafka Connect container.
        :param 'KafkaMirrorMaker2SpecTemplateDeploymentArgs' deployment: Template for Kafka Connect `Deployment`.
        :param 'KafkaMirrorMaker2SpecTemplateInitContainerArgs' init_container: Template for the Kafka init container.
        :param 'KafkaMirrorMaker2SpecTemplatePodArgs' pod: Template for Kafka Connect `Pods`.
        :param 'KafkaMirrorMaker2SpecTemplatePodDisruptionBudgetArgs' pod_disruption_budget: Template for Kafka Connect `PodDisruptionBudget`.
        """
        if api_service is not None:
            pulumi.set(__self__, "api_service", api_service)
        if connect_container is not None:
            pulumi.set(__self__, "connect_container", connect_container)
        if deployment is not None:
            pulumi.set(__self__, "deployment", deployment)
        if init_container is not None:
            pulumi.set(__self__, "init_container", init_container)
        if pod is not None:
            pulumi.set(__self__, "pod", pod)
        if pod_disruption_budget is not None:
            pulumi.set(__self__, "pod_disruption_budget", pod_disruption_budget)

    @property
    @pulumi.getter(name="apiService")
    def api_service(self) -> Optional['outputs.KafkaMirrorMaker2SpecTemplateApiService']:
        """
        Template for Kafka Connect API `Service`.
        """
        return pulumi.get(self, "api_service")

    @property
    @pulumi.getter(name="connectContainer")
    def connect_container(self) -> Optional['outputs.KafkaMirrorMaker2SpecTemplateConnectContainer']:
        """
        Template for the Kafka Connect container.
        """
        return pulumi.get(self, "connect_container")

    @property
    @pulumi.getter
    def deployment(self) -> Optional['outputs.KafkaMirrorMaker2SpecTemplateDeployment']:
        """
        Template for Kafka Connect `Deployment`.
        """
        return pulumi.get(self, "deployment")

    @property
    @pulumi.getter(name="initContainer")
    def init_container(self) -> Optional['outputs.KafkaMirrorMaker2SpecTemplateInitContainer']:
        """
        Template for the Kafka init container.
        """
        return pulumi.get(self, "init_container")

    @property
    @pulumi.getter
    def pod(self) -> Optional['outputs.KafkaMirrorMaker2SpecTemplatePod']:
        """
        Template for Kafka Connect `Pods`.
        """
        return pulumi.get(self, "pod")

    @property
    @pulumi.getter(name="podDisruptionBudget")
    def pod_disruption_budget(self) -> Optional['outputs.KafkaMirrorMaker2SpecTemplatePodDisruptionBudget']:
        """
        Template for Kafka Connect `PodDisruptionBudget`.
        """
        return pulumi.get(self, "pod_disruption_budget")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplateApiService(dict):
    """
    Template for Kafka Connect API `Service`.
    """
    def __init__(__self__, *,
                 metadata: Optional['outputs.KafkaMirrorMaker2SpecTemplateApiServiceMetadata'] = None):
        """
        Template for Kafka Connect API `Service`.
        :param 'KafkaMirrorMaker2SpecTemplateApiServiceMetadataArgs' metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaMirrorMaker2SpecTemplateApiServiceMetadata']:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplateApiServiceMetadata(dict):
    """
    Metadata applied to the resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata applied to the resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplateConnectContainer(dict):
    """
    Template for the Kafka Connect container.
    """
    def __init__(__self__, *,
                 env: Optional[Sequence['outputs.KafkaMirrorMaker2SpecTemplateConnectContainerEnv']] = None,
                 security_context: Optional['outputs.KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContext'] = None):
        """
        Template for the Kafka Connect container.
        :param Sequence['KafkaMirrorMaker2SpecTemplateConnectContainerEnvArgs'] env: Environment variables which should be applied to the container.
        :param 'KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextArgs' security_context: Security context for the container.
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)

    @property
    @pulumi.getter
    def env(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecTemplateConnectContainerEnv']]:
        """
        Environment variables which should be applied to the container.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional['outputs.KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContext']:
        """
        Security context for the container.
        """
        return pulumi.get(self, "security_context")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplateConnectContainerEnv(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The environment variable key.
        :param str value: The environment variable value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The environment variable key.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The environment variable value.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContext(dict):
    """
    Security context for the container.
    """
    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[bool] = None,
                 capabilities: Optional['outputs.KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextCapabilities'] = None,
                 privileged: Optional[bool] = None,
                 proc_mount: Optional[str] = None,
                 read_only_root_filesystem: Optional[bool] = None,
                 run_as_group: Optional[int] = None,
                 run_as_non_root: Optional[bool] = None,
                 run_as_user: Optional[int] = None,
                 se_linux_options: Optional['outputs.KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextSeLinuxOptions'] = None,
                 windows_options: Optional['outputs.KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextWindowsOptions'] = None):
        """
        Security context for the container.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if proc_mount is not None:
            pulumi.set(__self__, "proc_mount", proc_mount)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[bool]:
        return pulumi.get(self, "allow_privilege_escalation")

    @property
    @pulumi.getter
    def capabilities(self) -> Optional['outputs.KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextCapabilities']:
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def privileged(self) -> Optional[bool]:
        return pulumi.get(self, "privileged")

    @property
    @pulumi.getter(name="procMount")
    def proc_mount(self) -> Optional[str]:
        return pulumi.get(self, "proc_mount")

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[bool]:
        return pulumi.get(self, "read_only_root_filesystem")

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[int]:
        return pulumi.get(self, "run_as_group")

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[bool]:
        return pulumi.get(self, "run_as_non_root")

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[int]:
        return pulumi.get(self, "run_as_user")

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional['outputs.KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextSeLinuxOptions']:
        return pulumi.get(self, "se_linux_options")

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional['outputs.KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextWindowsOptions']:
        return pulumi.get(self, "windows_options")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextCapabilities(dict):
    def __init__(__self__, *,
                 add: Optional[Sequence[str]] = None,
                 drop: Optional[Sequence[str]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)

    @property
    @pulumi.getter
    def add(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def drop(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "drop")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextSeLinuxOptions(dict):
    def __init__(__self__, *,
                 level: Optional[str] = None,
                 role: Optional[str] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        return pulumi.get(self, "user")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextWindowsOptions(dict):
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[str] = None,
                 gmsa_credential_spec_name: Optional[str] = None,
                 run_as_user_name: Optional[str] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec")

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[str]:
        return pulumi.get(self, "run_as_user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplateDeployment(dict):
    """
    Template for Kafka Connect `Deployment`.
    """
    def __init__(__self__, *,
                 metadata: Optional['outputs.KafkaMirrorMaker2SpecTemplateDeploymentMetadata'] = None):
        """
        Template for Kafka Connect `Deployment`.
        :param 'KafkaMirrorMaker2SpecTemplateDeploymentMetadataArgs' metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaMirrorMaker2SpecTemplateDeploymentMetadata']:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplateDeploymentMetadata(dict):
    """
    Metadata applied to the resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata applied to the resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplateInitContainer(dict):
    """
    Template for the Kafka init container.
    """
    def __init__(__self__, *,
                 env: Optional[Sequence['outputs.KafkaMirrorMaker2SpecTemplateInitContainerEnv']] = None,
                 security_context: Optional['outputs.KafkaMirrorMaker2SpecTemplateInitContainerSecurityContext'] = None):
        """
        Template for the Kafka init container.
        :param Sequence['KafkaMirrorMaker2SpecTemplateInitContainerEnvArgs'] env: Environment variables which should be applied to the container.
        :param 'KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextArgs' security_context: Security context for the container.
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)

    @property
    @pulumi.getter
    def env(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecTemplateInitContainerEnv']]:
        """
        Environment variables which should be applied to the container.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional['outputs.KafkaMirrorMaker2SpecTemplateInitContainerSecurityContext']:
        """
        Security context for the container.
        """
        return pulumi.get(self, "security_context")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplateInitContainerEnv(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The environment variable key.
        :param str value: The environment variable value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The environment variable key.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The environment variable value.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplateInitContainerSecurityContext(dict):
    """
    Security context for the container.
    """
    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[bool] = None,
                 capabilities: Optional['outputs.KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextCapabilities'] = None,
                 privileged: Optional[bool] = None,
                 proc_mount: Optional[str] = None,
                 read_only_root_filesystem: Optional[bool] = None,
                 run_as_group: Optional[int] = None,
                 run_as_non_root: Optional[bool] = None,
                 run_as_user: Optional[int] = None,
                 se_linux_options: Optional['outputs.KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextSeLinuxOptions'] = None,
                 windows_options: Optional['outputs.KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextWindowsOptions'] = None):
        """
        Security context for the container.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if proc_mount is not None:
            pulumi.set(__self__, "proc_mount", proc_mount)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[bool]:
        return pulumi.get(self, "allow_privilege_escalation")

    @property
    @pulumi.getter
    def capabilities(self) -> Optional['outputs.KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextCapabilities']:
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def privileged(self) -> Optional[bool]:
        return pulumi.get(self, "privileged")

    @property
    @pulumi.getter(name="procMount")
    def proc_mount(self) -> Optional[str]:
        return pulumi.get(self, "proc_mount")

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[bool]:
        return pulumi.get(self, "read_only_root_filesystem")

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[int]:
        return pulumi.get(self, "run_as_group")

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[bool]:
        return pulumi.get(self, "run_as_non_root")

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[int]:
        return pulumi.get(self, "run_as_user")

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional['outputs.KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextSeLinuxOptions']:
        return pulumi.get(self, "se_linux_options")

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional['outputs.KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextWindowsOptions']:
        return pulumi.get(self, "windows_options")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextCapabilities(dict):
    def __init__(__self__, *,
                 add: Optional[Sequence[str]] = None,
                 drop: Optional[Sequence[str]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)

    @property
    @pulumi.getter
    def add(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def drop(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "drop")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextSeLinuxOptions(dict):
    def __init__(__self__, *,
                 level: Optional[str] = None,
                 role: Optional[str] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        return pulumi.get(self, "user")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextWindowsOptions(dict):
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[str] = None,
                 gmsa_credential_spec_name: Optional[str] = None,
                 run_as_user_name: Optional[str] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec")

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[str]:
        return pulumi.get(self, "run_as_user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplatePod(dict):
    """
    Template for Kafka Connect `Pods`.
    """
    def __init__(__self__, *,
                 affinity: Optional['outputs.KafkaMirrorMaker2SpecTemplatePodAffinity'] = None,
                 host_aliases: Optional[Sequence['outputs.KafkaMirrorMaker2SpecTemplatePodHostAliases']] = None,
                 image_pull_secrets: Optional[Sequence['outputs.KafkaMirrorMaker2SpecTemplatePodImagePullSecrets']] = None,
                 metadata: Optional['outputs.KafkaMirrorMaker2SpecTemplatePodMetadata'] = None,
                 priority_class_name: Optional[str] = None,
                 scheduler_name: Optional[str] = None,
                 security_context: Optional['outputs.KafkaMirrorMaker2SpecTemplatePodSecurityContext'] = None,
                 termination_grace_period_seconds: Optional[int] = None,
                 tolerations: Optional[Sequence['outputs.KafkaMirrorMaker2SpecTemplatePodTolerations']] = None):
        """
        Template for Kafka Connect `Pods`.
        :param 'KafkaMirrorMaker2SpecTemplatePodAffinityArgs' affinity: The pod's affinity rules.
        :param Sequence['KafkaMirrorMaker2SpecTemplatePodHostAliasesArgs'] host_aliases: The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
        :param Sequence['KafkaMirrorMaker2SpecTemplatePodImagePullSecretsArgs'] image_pull_secrets: List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
        :param 'KafkaMirrorMaker2SpecTemplatePodMetadataArgs' metadata: Metadata applied to the resource.
        :param str priority_class_name: The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
        :param str scheduler_name: The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
        :param 'KafkaMirrorMaker2SpecTemplatePodSecurityContextArgs' security_context: Configures pod-level security attributes and common container settings.
        :param int termination_grace_period_seconds: The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
        :param Sequence['KafkaMirrorMaker2SpecTemplatePodTolerationsArgs'] tolerations: The pod's tolerations.
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if host_aliases is not None:
            pulumi.set(__self__, "host_aliases", host_aliases)
        if image_pull_secrets is not None:
            pulumi.set(__self__, "image_pull_secrets", image_pull_secrets)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if priority_class_name is not None:
            pulumi.set(__self__, "priority_class_name", priority_class_name)
        if scheduler_name is not None:
            pulumi.set(__self__, "scheduler_name", scheduler_name)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)

    @property
    @pulumi.getter
    def affinity(self) -> Optional['outputs.KafkaMirrorMaker2SpecTemplatePodAffinity']:
        """
        The pod's affinity rules.
        """
        return pulumi.get(self, "affinity")

    @property
    @pulumi.getter(name="hostAliases")
    def host_aliases(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecTemplatePodHostAliases']]:
        """
        The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
        """
        return pulumi.get(self, "host_aliases")

    @property
    @pulumi.getter(name="imagePullSecrets")
    def image_pull_secrets(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecTemplatePodImagePullSecrets']]:
        """
        List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
        """
        return pulumi.get(self, "image_pull_secrets")

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaMirrorMaker2SpecTemplatePodMetadata']:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter(name="priorityClassName")
    def priority_class_name(self) -> Optional[str]:
        """
        The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
        """
        return pulumi.get(self, "priority_class_name")

    @property
    @pulumi.getter(name="schedulerName")
    def scheduler_name(self) -> Optional[str]:
        """
        The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
        """
        return pulumi.get(self, "scheduler_name")

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional['outputs.KafkaMirrorMaker2SpecTemplatePodSecurityContext']:
        """
        Configures pod-level security attributes and common container settings.
        """
        return pulumi.get(self, "security_context")

    @property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[int]:
        """
        The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
        """
        return pulumi.get(self, "termination_grace_period_seconds")

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecTemplatePodTolerations']]:
        """
        The pod's tolerations.
        """
        return pulumi.get(self, "tolerations")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplatePodAffinity(dict):
    """
    The pod's affinity rules.
    """
    def __init__(__self__, *,
                 node_affinity: Optional['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinity'] = None,
                 pod_affinity: Optional['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinity'] = None,
                 pod_anti_affinity: Optional['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinity'] = None):
        """
        The pod's affinity rules.
        """
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinity']:
        return pulumi.get(self, "node_affinity")

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinity']:
        return pulumi.get(self, "pod_affinity")

    @property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinity']:
        return pulumi.get(self, "pod_anti_affinity")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution'] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution']:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 preference: Optional['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference'] = None,
                 weight: Optional[int] = None):
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preference(self) -> Optional['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference']:
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions']] = None,
                 match_fields: Optional[Sequence['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields']] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields']]:
        return pulumi.get(self, "match_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 node_selector_terms: Optional[Sequence['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms']] = None):
        if node_selector_terms is not None:
            pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms']]:
        return pulumi.get(self, "node_selector_terms")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions']] = None,
                 match_fields: Optional[Sequence['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields']] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields']]:
        return pulumi.get(self, "match_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 pod_affinity_term: Optional['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm'] = None,
                 weight: Optional[int] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm']:
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 pod_affinity_term: Optional['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm'] = None,
                 weight: Optional[int] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm']:
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplatePodDisruptionBudget(dict):
    """
    Template for Kafka Connect `PodDisruptionBudget`.
    """
    def __init__(__self__, *,
                 max_unavailable: Optional[int] = None,
                 metadata: Optional['outputs.KafkaMirrorMaker2SpecTemplatePodDisruptionBudgetMetadata'] = None):
        """
        Template for Kafka Connect `PodDisruptionBudget`.
        :param int max_unavailable: Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
        :param 'KafkaMirrorMaker2SpecTemplatePodDisruptionBudgetMetadataArgs' metadata: Metadata to apply to the `PodDistruptionBugetTemplate` resource.
        """
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[int]:
        """
        Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
        """
        return pulumi.get(self, "max_unavailable")

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaMirrorMaker2SpecTemplatePodDisruptionBudgetMetadata']:
        """
        Metadata to apply to the `PodDistruptionBugetTemplate` resource.
        """
        return pulumi.get(self, "metadata")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplatePodDisruptionBudgetMetadata(dict):
    """
    Metadata to apply to the `PodDistruptionBugetTemplate` resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata to apply to the `PodDistruptionBugetTemplate` resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplatePodHostAliases(dict):
    def __init__(__self__, *,
                 hostnames: Optional[Sequence[str]] = None,
                 ip: Optional[str] = None):
        if hostnames is not None:
            pulumi.set(__self__, "hostnames", hostnames)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def hostnames(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "hostnames")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        return pulumi.get(self, "ip")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplatePodImagePullSecrets(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplatePodMetadata(dict):
    """
    Metadata applied to the resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata applied to the resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplatePodSecurityContext(dict):
    """
    Configures pod-level security attributes and common container settings.
    """
    def __init__(__self__, *,
                 fs_group: Optional[int] = None,
                 fs_group_change_policy: Optional[str] = None,
                 run_as_group: Optional[int] = None,
                 run_as_non_root: Optional[bool] = None,
                 run_as_user: Optional[int] = None,
                 se_linux_options: Optional['outputs.KafkaMirrorMaker2SpecTemplatePodSecurityContextSeLinuxOptions'] = None,
                 supplemental_groups: Optional[Sequence[int]] = None,
                 sysctls: Optional[Sequence['outputs.KafkaMirrorMaker2SpecTemplatePodSecurityContextSysctls']] = None,
                 windows_options: Optional['outputs.KafkaMirrorMaker2SpecTemplatePodSecurityContextWindowsOptions'] = None):
        """
        Configures pod-level security attributes and common container settings.
        """
        if fs_group is not None:
            pulumi.set(__self__, "fs_group", fs_group)
        if fs_group_change_policy is not None:
            pulumi.set(__self__, "fs_group_change_policy", fs_group_change_policy)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if supplemental_groups is not None:
            pulumi.set(__self__, "supplemental_groups", supplemental_groups)
        if sysctls is not None:
            pulumi.set(__self__, "sysctls", sysctls)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="fsGroup")
    def fs_group(self) -> Optional[int]:
        return pulumi.get(self, "fs_group")

    @property
    @pulumi.getter(name="fsGroupChangePolicy")
    def fs_group_change_policy(self) -> Optional[str]:
        return pulumi.get(self, "fs_group_change_policy")

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[int]:
        return pulumi.get(self, "run_as_group")

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[bool]:
        return pulumi.get(self, "run_as_non_root")

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[int]:
        return pulumi.get(self, "run_as_user")

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional['outputs.KafkaMirrorMaker2SpecTemplatePodSecurityContextSeLinuxOptions']:
        return pulumi.get(self, "se_linux_options")

    @property
    @pulumi.getter(name="supplementalGroups")
    def supplemental_groups(self) -> Optional[Sequence[int]]:
        return pulumi.get(self, "supplemental_groups")

    @property
    @pulumi.getter
    def sysctls(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2SpecTemplatePodSecurityContextSysctls']]:
        return pulumi.get(self, "sysctls")

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional['outputs.KafkaMirrorMaker2SpecTemplatePodSecurityContextWindowsOptions']:
        return pulumi.get(self, "windows_options")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplatePodSecurityContextSeLinuxOptions(dict):
    def __init__(__self__, *,
                 level: Optional[str] = None,
                 role: Optional[str] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        return pulumi.get(self, "user")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplatePodSecurityContextSysctls(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplatePodSecurityContextWindowsOptions(dict):
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[str] = None,
                 gmsa_credential_spec_name: Optional[str] = None,
                 run_as_user_name: Optional[str] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec")

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[str]:
        return pulumi.get(self, "run_as_user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTemplatePodTolerations(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 toleration_seconds: Optional[int] = None,
                 value: Optional[str] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if toleration_seconds is not None:
            pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> Optional[int]:
        return pulumi.get(self, "toleration_seconds")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTolerations(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 toleration_seconds: Optional[int] = None,
                 value: Optional[str] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if toleration_seconds is not None:
            pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> Optional[int]:
        return pulumi.get(self, "toleration_seconds")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2SpecTracing(dict):
    """
    The configuration of tracing in Kafka Connect.
    """
    def __init__(__self__, *,
                 type: str):
        """
        The configuration of tracing in Kafka Connect.
        :param str type: Type of the tracing used. Currently the only supported type is `jaeger` for Jaeger tracing.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the tracing used. Currently the only supported type is `jaeger` for Jaeger tracing.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2Status(dict):
    """
    The status of the Kafka MirrorMaker 2.0 cluster.
    """
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.KafkaMirrorMaker2StatusConditions']] = None,
                 connector_plugins: Optional[Sequence['outputs.KafkaMirrorMaker2StatusConnectorPlugins']] = None,
                 connectors: Optional[Sequence[Mapping[str, Any]]] = None,
                 label_selector: Optional[str] = None,
                 observed_generation: Optional[int] = None,
                 replicas: Optional[int] = None,
                 url: Optional[str] = None):
        """
        The status of the Kafka MirrorMaker 2.0 cluster.
        :param Sequence['KafkaMirrorMaker2StatusConditionsArgs'] conditions: List of status conditions.
        :param Sequence['KafkaMirrorMaker2StatusConnectorPluginsArgs'] connector_plugins: The list of connector plugins available in this Kafka Connect deployment.
        :param Sequence[Mapping[str, Any]] connectors: List of MirrorMaker 2.0 connector statuses, as reported by the Kafka Connect REST API.
        :param str label_selector: Label selector for pods providing this resource.
        :param int observed_generation: The generation of the CRD that was last reconciled by the operator.
        :param int replicas: The current number of pods being used to provide this resource.
        :param str url: The URL of the REST API endpoint for managing and monitoring Kafka Connect connectors.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if connector_plugins is not None:
            pulumi.set(__self__, "connector_plugins", connector_plugins)
        if connectors is not None:
            pulumi.set(__self__, "connectors", connectors)
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2StatusConditions']]:
        """
        List of status conditions.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="connectorPlugins")
    def connector_plugins(self) -> Optional[Sequence['outputs.KafkaMirrorMaker2StatusConnectorPlugins']]:
        """
        The list of connector plugins available in this Kafka Connect deployment.
        """
        return pulumi.get(self, "connector_plugins")

    @property
    @pulumi.getter
    def connectors(self) -> Optional[Sequence[Mapping[str, Any]]]:
        """
        List of MirrorMaker 2.0 connector statuses, as reported by the Kafka Connect REST API.
        """
        return pulumi.get(self, "connectors")

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[str]:
        """
        Label selector for pods providing this resource.
        """
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[int]:
        """
        The generation of the CRD that was last reconciled by the operator.
        """
        return pulumi.get(self, "observed_generation")

    @property
    @pulumi.getter
    def replicas(self) -> Optional[int]:
        """
        The current number of pods being used to provide this resource.
        """
        return pulumi.get(self, "replicas")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The URL of the REST API endpoint for managing and monitoring Kafka Connect connectors.
        """
        return pulumi.get(self, "url")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2StatusConditions(dict):
    def __init__(__self__, *,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None,
                 status: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str last_transition_time: Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
        :param str message: Human-readable message indicating details about the condition's last transition.
        :param str reason: The reason for the condition's last transition (a single word in CamelCase).
        :param str status: The status of the condition, either True, False or Unknown.
        :param str type: The unique identifier of a condition, used to distinguish between other conditions in the resource.
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Human-readable message indicating details about the condition's last transition.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        The reason for the condition's last transition (a single word in CamelCase).
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The status of the condition, either True, False or Unknown.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The unique identifier of a condition, used to distinguish between other conditions in the resource.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMaker2StatusConnectorPlugins(dict):
    def __init__(__self__, *,
                 class_: Optional[str] = None,
                 type: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str class_: The class of the connector plugin.
        :param str type: The type of the connector plugin. The available types are `sink` and `source`.
        :param str version: The version of the connector plugin.
        """
        if class_ is not None:
            pulumi.set(__self__, "class_", class_)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="class")
    def class_(self) -> Optional[str]:
        """
        The class of the connector plugin.
        """
        return pulumi.get(self, "class_")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of the connector plugin. The available types are `sink` and `source`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        The version of the connector plugin.
        """
        return pulumi.get(self, "version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaRebalanceSpec(dict):
    """
    The specification of the Kafka rebalance.
    """
    def __init__(__self__, *,
                 concurrent_intra_broker_partition_movements: Optional[int] = None,
                 concurrent_leader_movements: Optional[int] = None,
                 concurrent_partition_movements_per_broker: Optional[int] = None,
                 excluded_topics: Optional[str] = None,
                 goals: Optional[Sequence[str]] = None,
                 replica_movement_strategies: Optional[Sequence[str]] = None,
                 replication_throttle: Optional[int] = None,
                 skip_hard_goal_check: Optional[bool] = None):
        """
        The specification of the Kafka rebalance.
        :param int concurrent_intra_broker_partition_movements: The upper bound of ongoing partition replica movements between disks within each broker. Default is 2.
        :param int concurrent_leader_movements: The upper bound of ongoing partition leadership movements. Default is 1000.
        :param int concurrent_partition_movements_per_broker: The upper bound of ongoing partition replica movements going into/out of each broker. Default is 5.
        :param str excluded_topics: A regular expression where any matching topics will be excluded from the calculation of optimization proposals. This expression will be parsed by the java.util.regex.Pattern class; for more information on the supported formar consult the documentation for that class.
        :param Sequence[str] goals: A list of goals, ordered by decreasing priority, to use for generating and executing the rebalance proposal. The supported goals are available at https://github.com/linkedin/cruise-control#goals. If an empty goals list is provided, the goals declared in the default.goals Cruise Control configuration parameter are used.
        :param Sequence[str] replica_movement_strategies: A list of strategy class names used to determine the execution order for the replica movements in the generated optimization proposal. By default BaseReplicaMovementStrategy is used, which will execute the replica movements in the order that they were generated.
        :param int replication_throttle: The upper bound, in bytes per second, on the bandwidth used to move replicas. There is no limit by default.
        :param bool skip_hard_goal_check: Whether to allow the hard goals specified in the Kafka CR to be skipped in optimization proposal generation. This can be useful when some of those hard goals are preventing a balance solution being found. Default is false.
        """
        if concurrent_intra_broker_partition_movements is not None:
            pulumi.set(__self__, "concurrent_intra_broker_partition_movements", concurrent_intra_broker_partition_movements)
        if concurrent_leader_movements is not None:
            pulumi.set(__self__, "concurrent_leader_movements", concurrent_leader_movements)
        if concurrent_partition_movements_per_broker is not None:
            pulumi.set(__self__, "concurrent_partition_movements_per_broker", concurrent_partition_movements_per_broker)
        if excluded_topics is not None:
            pulumi.set(__self__, "excluded_topics", excluded_topics)
        if goals is not None:
            pulumi.set(__self__, "goals", goals)
        if replica_movement_strategies is not None:
            pulumi.set(__self__, "replica_movement_strategies", replica_movement_strategies)
        if replication_throttle is not None:
            pulumi.set(__self__, "replication_throttle", replication_throttle)
        if skip_hard_goal_check is not None:
            pulumi.set(__self__, "skip_hard_goal_check", skip_hard_goal_check)

    @property
    @pulumi.getter(name="concurrentIntraBrokerPartitionMovements")
    def concurrent_intra_broker_partition_movements(self) -> Optional[int]:
        """
        The upper bound of ongoing partition replica movements between disks within each broker. Default is 2.
        """
        return pulumi.get(self, "concurrent_intra_broker_partition_movements")

    @property
    @pulumi.getter(name="concurrentLeaderMovements")
    def concurrent_leader_movements(self) -> Optional[int]:
        """
        The upper bound of ongoing partition leadership movements. Default is 1000.
        """
        return pulumi.get(self, "concurrent_leader_movements")

    @property
    @pulumi.getter(name="concurrentPartitionMovementsPerBroker")
    def concurrent_partition_movements_per_broker(self) -> Optional[int]:
        """
        The upper bound of ongoing partition replica movements going into/out of each broker. Default is 5.
        """
        return pulumi.get(self, "concurrent_partition_movements_per_broker")

    @property
    @pulumi.getter(name="excludedTopics")
    def excluded_topics(self) -> Optional[str]:
        """
        A regular expression where any matching topics will be excluded from the calculation of optimization proposals. This expression will be parsed by the java.util.regex.Pattern class; for more information on the supported formar consult the documentation for that class.
        """
        return pulumi.get(self, "excluded_topics")

    @property
    @pulumi.getter
    def goals(self) -> Optional[Sequence[str]]:
        """
        A list of goals, ordered by decreasing priority, to use for generating and executing the rebalance proposal. The supported goals are available at https://github.com/linkedin/cruise-control#goals. If an empty goals list is provided, the goals declared in the default.goals Cruise Control configuration parameter are used.
        """
        return pulumi.get(self, "goals")

    @property
    @pulumi.getter(name="replicaMovementStrategies")
    def replica_movement_strategies(self) -> Optional[Sequence[str]]:
        """
        A list of strategy class names used to determine the execution order for the replica movements in the generated optimization proposal. By default BaseReplicaMovementStrategy is used, which will execute the replica movements in the order that they were generated.
        """
        return pulumi.get(self, "replica_movement_strategies")

    @property
    @pulumi.getter(name="replicationThrottle")
    def replication_throttle(self) -> Optional[int]:
        """
        The upper bound, in bytes per second, on the bandwidth used to move replicas. There is no limit by default.
        """
        return pulumi.get(self, "replication_throttle")

    @property
    @pulumi.getter(name="skipHardGoalCheck")
    def skip_hard_goal_check(self) -> Optional[bool]:
        """
        Whether to allow the hard goals specified in the Kafka CR to be skipped in optimization proposal generation. This can be useful when some of those hard goals are preventing a balance solution being found. Default is false.
        """
        return pulumi.get(self, "skip_hard_goal_check")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaRebalanceStatus(dict):
    """
    The status of the Kafka rebalance.
    """
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.KafkaRebalanceStatusConditions']] = None,
                 observed_generation: Optional[int] = None,
                 optimization_result: Optional[Mapping[str, Any]] = None,
                 session_id: Optional[str] = None):
        """
        The status of the Kafka rebalance.
        :param Sequence['KafkaRebalanceStatusConditionsArgs'] conditions: List of status conditions.
        :param int observed_generation: The generation of the CRD that was last reconciled by the operator.
        :param Mapping[str, Any] optimization_result: A JSON object describing the optimization result.
        :param str session_id: The session identifier for requests to Cruise Control pertaining to this KafkaRebalance resource. This is used by the Kafka Rebalance operator to track the status of ongoing rebalancing operations.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if optimization_result is not None:
            pulumi.set(__self__, "optimization_result", optimization_result)
        if session_id is not None:
            pulumi.set(__self__, "session_id", session_id)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.KafkaRebalanceStatusConditions']]:
        """
        List of status conditions.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[int]:
        """
        The generation of the CRD that was last reconciled by the operator.
        """
        return pulumi.get(self, "observed_generation")

    @property
    @pulumi.getter(name="optimizationResult")
    def optimization_result(self) -> Optional[Mapping[str, Any]]:
        """
        A JSON object describing the optimization result.
        """
        return pulumi.get(self, "optimization_result")

    @property
    @pulumi.getter(name="sessionId")
    def session_id(self) -> Optional[str]:
        """
        The session identifier for requests to Cruise Control pertaining to this KafkaRebalance resource. This is used by the Kafka Rebalance operator to track the status of ongoing rebalancing operations.
        """
        return pulumi.get(self, "session_id")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaRebalanceStatusConditions(dict):
    def __init__(__self__, *,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None,
                 status: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str last_transition_time: Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
        :param str message: Human-readable message indicating details about the condition's last transition.
        :param str reason: The reason for the condition's last transition (a single word in CamelCase).
        :param str status: The status of the condition, either True, False or Unknown.
        :param str type: The unique identifier of a condition, used to distinguish between other conditions in the resource.
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Human-readable message indicating details about the condition's last transition.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        The reason for the condition's last transition (a single word in CamelCase).
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The status of the condition, either True, False or Unknown.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The unique identifier of a condition, used to distinguish between other conditions in the resource.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


