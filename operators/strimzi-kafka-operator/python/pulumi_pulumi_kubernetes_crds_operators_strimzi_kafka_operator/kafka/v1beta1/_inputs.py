# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from ... import _utilities, _tables

__all__ = [
    'KafkaConnectS2ISpecArgs',
    'KafkaConnectS2ISpecAffinityArgs',
    'KafkaConnectS2ISpecAffinityNodeAffinityArgs',
    'KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs',
    'KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs',
    'KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs',
    'KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs',
    'KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs',
    'KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs',
    'KafkaConnectS2ISpecAffinityPodAffinityArgs',
    'KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs',
    'KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs',
    'KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs',
    'KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs',
    'KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs',
    'KafkaConnectS2ISpecAffinityPodAntiAffinityArgs',
    'KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs',
    'KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs',
    'KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs',
    'KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs',
    'KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs',
    'KafkaConnectS2ISpecAuthenticationArgs',
    'KafkaConnectS2ISpecAuthenticationAccessTokenArgs',
    'KafkaConnectS2ISpecAuthenticationCertificateAndKeyArgs',
    'KafkaConnectS2ISpecAuthenticationClientSecretArgs',
    'KafkaConnectS2ISpecAuthenticationPasswordSecretArgs',
    'KafkaConnectS2ISpecAuthenticationRefreshTokenArgs',
    'KafkaConnectS2ISpecAuthenticationTlsTrustedCertificatesArgs',
    'KafkaConnectS2ISpecBuildResourcesArgs',
    'KafkaConnectS2ISpecExternalConfigurationArgs',
    'KafkaConnectS2ISpecExternalConfigurationEnvArgs',
    'KafkaConnectS2ISpecExternalConfigurationEnvValueFromArgs',
    'KafkaConnectS2ISpecExternalConfigurationEnvValueFromConfigMapKeyRefArgs',
    'KafkaConnectS2ISpecExternalConfigurationEnvValueFromSecretKeyRefArgs',
    'KafkaConnectS2ISpecExternalConfigurationVolumesArgs',
    'KafkaConnectS2ISpecExternalConfigurationVolumesConfigMapArgs',
    'KafkaConnectS2ISpecExternalConfigurationVolumesConfigMapItemsArgs',
    'KafkaConnectS2ISpecExternalConfigurationVolumesSecretArgs',
    'KafkaConnectS2ISpecExternalConfigurationVolumesSecretItemsArgs',
    'KafkaConnectS2ISpecJvmOptionsArgs',
    'KafkaConnectS2ISpecJvmOptionsJavaSystemPropertiesArgs',
    'KafkaConnectS2ISpecLivenessProbeArgs',
    'KafkaConnectS2ISpecLoggingArgs',
    'KafkaConnectS2ISpecRackArgs',
    'KafkaConnectS2ISpecReadinessProbeArgs',
    'KafkaConnectS2ISpecResourcesArgs',
    'KafkaConnectS2ISpecTemplateArgs',
    'KafkaConnectS2ISpecTemplateApiServiceArgs',
    'KafkaConnectS2ISpecTemplateApiServiceMetadataArgs',
    'KafkaConnectS2ISpecTemplateConnectContainerArgs',
    'KafkaConnectS2ISpecTemplateConnectContainerEnvArgs',
    'KafkaConnectS2ISpecTemplateConnectContainerSecurityContextArgs',
    'KafkaConnectS2ISpecTemplateConnectContainerSecurityContextCapabilitiesArgs',
    'KafkaConnectS2ISpecTemplateConnectContainerSecurityContextSeLinuxOptionsArgs',
    'KafkaConnectS2ISpecTemplateConnectContainerSecurityContextWindowsOptionsArgs',
    'KafkaConnectS2ISpecTemplateDeploymentArgs',
    'KafkaConnectS2ISpecTemplateDeploymentMetadataArgs',
    'KafkaConnectS2ISpecTemplateInitContainerArgs',
    'KafkaConnectS2ISpecTemplateInitContainerEnvArgs',
    'KafkaConnectS2ISpecTemplateInitContainerSecurityContextArgs',
    'KafkaConnectS2ISpecTemplateInitContainerSecurityContextCapabilitiesArgs',
    'KafkaConnectS2ISpecTemplateInitContainerSecurityContextSeLinuxOptionsArgs',
    'KafkaConnectS2ISpecTemplateInitContainerSecurityContextWindowsOptionsArgs',
    'KafkaConnectS2ISpecTemplatePodArgs',
    'KafkaConnectS2ISpecTemplatePodAffinityArgs',
    'KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityArgs',
    'KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs',
    'KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs',
    'KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs',
    'KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs',
    'KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs',
    'KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs',
    'KafkaConnectS2ISpecTemplatePodAffinityPodAffinityArgs',
    'KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs',
    'KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs',
    'KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs',
    'KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs',
    'KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs',
    'KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityArgs',
    'KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs',
    'KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs',
    'KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs',
    'KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs',
    'KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs',
    'KafkaConnectS2ISpecTemplatePodDisruptionBudgetArgs',
    'KafkaConnectS2ISpecTemplatePodDisruptionBudgetMetadataArgs',
    'KafkaConnectS2ISpecTemplatePodHostAliasesArgs',
    'KafkaConnectS2ISpecTemplatePodImagePullSecretsArgs',
    'KafkaConnectS2ISpecTemplatePodMetadataArgs',
    'KafkaConnectS2ISpecTemplatePodSecurityContextArgs',
    'KafkaConnectS2ISpecTemplatePodSecurityContextSeLinuxOptionsArgs',
    'KafkaConnectS2ISpecTemplatePodSecurityContextSysctlsArgs',
    'KafkaConnectS2ISpecTemplatePodSecurityContextWindowsOptionsArgs',
    'KafkaConnectS2ISpecTemplatePodTolerationsArgs',
    'KafkaConnectS2ISpecTlsArgs',
    'KafkaConnectS2ISpecTlsTrustedCertificatesArgs',
    'KafkaConnectS2ISpecTolerationsArgs',
    'KafkaConnectS2ISpecTracingArgs',
    'KafkaConnectS2IStatusArgs',
    'KafkaConnectS2IStatusConditionsArgs',
    'KafkaConnectS2IStatusConnectorPluginsArgs',
    'KafkaConnectSpecArgs',
    'KafkaConnectSpecAffinityArgs',
    'KafkaConnectSpecAffinityNodeAffinityArgs',
    'KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs',
    'KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs',
    'KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs',
    'KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs',
    'KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs',
    'KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs',
    'KafkaConnectSpecAffinityPodAffinityArgs',
    'KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs',
    'KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs',
    'KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs',
    'KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs',
    'KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs',
    'KafkaConnectSpecAffinityPodAntiAffinityArgs',
    'KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs',
    'KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs',
    'KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs',
    'KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs',
    'KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs',
    'KafkaConnectSpecAuthenticationArgs',
    'KafkaConnectSpecAuthenticationAccessTokenArgs',
    'KafkaConnectSpecAuthenticationCertificateAndKeyArgs',
    'KafkaConnectSpecAuthenticationClientSecretArgs',
    'KafkaConnectSpecAuthenticationPasswordSecretArgs',
    'KafkaConnectSpecAuthenticationRefreshTokenArgs',
    'KafkaConnectSpecAuthenticationTlsTrustedCertificatesArgs',
    'KafkaConnectSpecExternalConfigurationArgs',
    'KafkaConnectSpecExternalConfigurationEnvArgs',
    'KafkaConnectSpecExternalConfigurationEnvValueFromArgs',
    'KafkaConnectSpecExternalConfigurationEnvValueFromConfigMapKeyRefArgs',
    'KafkaConnectSpecExternalConfigurationEnvValueFromSecretKeyRefArgs',
    'KafkaConnectSpecExternalConfigurationVolumesArgs',
    'KafkaConnectSpecExternalConfigurationVolumesConfigMapArgs',
    'KafkaConnectSpecExternalConfigurationVolumesConfigMapItemsArgs',
    'KafkaConnectSpecExternalConfigurationVolumesSecretArgs',
    'KafkaConnectSpecExternalConfigurationVolumesSecretItemsArgs',
    'KafkaConnectSpecJvmOptionsArgs',
    'KafkaConnectSpecJvmOptionsJavaSystemPropertiesArgs',
    'KafkaConnectSpecLivenessProbeArgs',
    'KafkaConnectSpecLoggingArgs',
    'KafkaConnectSpecRackArgs',
    'KafkaConnectSpecReadinessProbeArgs',
    'KafkaConnectSpecResourcesArgs',
    'KafkaConnectSpecTemplateArgs',
    'KafkaConnectSpecTemplateApiServiceArgs',
    'KafkaConnectSpecTemplateApiServiceMetadataArgs',
    'KafkaConnectSpecTemplateConnectContainerArgs',
    'KafkaConnectSpecTemplateConnectContainerEnvArgs',
    'KafkaConnectSpecTemplateConnectContainerSecurityContextArgs',
    'KafkaConnectSpecTemplateConnectContainerSecurityContextCapabilitiesArgs',
    'KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptionsArgs',
    'KafkaConnectSpecTemplateConnectContainerSecurityContextWindowsOptionsArgs',
    'KafkaConnectSpecTemplateDeploymentArgs',
    'KafkaConnectSpecTemplateDeploymentMetadataArgs',
    'KafkaConnectSpecTemplateInitContainerArgs',
    'KafkaConnectSpecTemplateInitContainerEnvArgs',
    'KafkaConnectSpecTemplateInitContainerSecurityContextArgs',
    'KafkaConnectSpecTemplateInitContainerSecurityContextCapabilitiesArgs',
    'KafkaConnectSpecTemplateInitContainerSecurityContextSeLinuxOptionsArgs',
    'KafkaConnectSpecTemplateInitContainerSecurityContextWindowsOptionsArgs',
    'KafkaConnectSpecTemplatePodArgs',
    'KafkaConnectSpecTemplatePodAffinityArgs',
    'KafkaConnectSpecTemplatePodAffinityNodeAffinityArgs',
    'KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs',
    'KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs',
    'KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs',
    'KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs',
    'KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs',
    'KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs',
    'KafkaConnectSpecTemplatePodAffinityPodAffinityArgs',
    'KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs',
    'KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs',
    'KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs',
    'KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs',
    'KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs',
    'KafkaConnectSpecTemplatePodAffinityPodAntiAffinityArgs',
    'KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs',
    'KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs',
    'KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs',
    'KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs',
    'KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs',
    'KafkaConnectSpecTemplatePodDisruptionBudgetArgs',
    'KafkaConnectSpecTemplatePodDisruptionBudgetMetadataArgs',
    'KafkaConnectSpecTemplatePodHostAliasesArgs',
    'KafkaConnectSpecTemplatePodImagePullSecretsArgs',
    'KafkaConnectSpecTemplatePodMetadataArgs',
    'KafkaConnectSpecTemplatePodSecurityContextArgs',
    'KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptionsArgs',
    'KafkaConnectSpecTemplatePodSecurityContextSysctlsArgs',
    'KafkaConnectSpecTemplatePodSecurityContextWindowsOptionsArgs',
    'KafkaConnectSpecTemplatePodTolerationsArgs',
    'KafkaConnectSpecTlsArgs',
    'KafkaConnectSpecTlsTrustedCertificatesArgs',
    'KafkaConnectSpecTolerationsArgs',
    'KafkaConnectSpecTracingArgs',
    'KafkaConnectStatusArgs',
    'KafkaConnectStatusConditionsArgs',
    'KafkaConnectStatusConnectorPluginsArgs',
    'KafkaMirrorMakerSpecArgs',
    'KafkaMirrorMakerSpecAffinityArgs',
    'KafkaMirrorMakerSpecAffinityNodeAffinityArgs',
    'KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs',
    'KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs',
    'KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs',
    'KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs',
    'KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs',
    'KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs',
    'KafkaMirrorMakerSpecAffinityPodAffinityArgs',
    'KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs',
    'KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs',
    'KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs',
    'KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs',
    'KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs',
    'KafkaMirrorMakerSpecAffinityPodAntiAffinityArgs',
    'KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs',
    'KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs',
    'KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs',
    'KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs',
    'KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs',
    'KafkaMirrorMakerSpecConsumerArgs',
    'KafkaMirrorMakerSpecConsumerAuthenticationArgs',
    'KafkaMirrorMakerSpecConsumerAuthenticationAccessTokenArgs',
    'KafkaMirrorMakerSpecConsumerAuthenticationCertificateAndKeyArgs',
    'KafkaMirrorMakerSpecConsumerAuthenticationClientSecretArgs',
    'KafkaMirrorMakerSpecConsumerAuthenticationPasswordSecretArgs',
    'KafkaMirrorMakerSpecConsumerAuthenticationRefreshTokenArgs',
    'KafkaMirrorMakerSpecConsumerAuthenticationTlsTrustedCertificatesArgs',
    'KafkaMirrorMakerSpecConsumerTlsArgs',
    'KafkaMirrorMakerSpecConsumerTlsTrustedCertificatesArgs',
    'KafkaMirrorMakerSpecJvmOptionsArgs',
    'KafkaMirrorMakerSpecJvmOptionsJavaSystemPropertiesArgs',
    'KafkaMirrorMakerSpecLivenessProbeArgs',
    'KafkaMirrorMakerSpecLoggingArgs',
    'KafkaMirrorMakerSpecProducerArgs',
    'KafkaMirrorMakerSpecProducerAuthenticationArgs',
    'KafkaMirrorMakerSpecProducerAuthenticationAccessTokenArgs',
    'KafkaMirrorMakerSpecProducerAuthenticationCertificateAndKeyArgs',
    'KafkaMirrorMakerSpecProducerAuthenticationClientSecretArgs',
    'KafkaMirrorMakerSpecProducerAuthenticationPasswordSecretArgs',
    'KafkaMirrorMakerSpecProducerAuthenticationRefreshTokenArgs',
    'KafkaMirrorMakerSpecProducerAuthenticationTlsTrustedCertificatesArgs',
    'KafkaMirrorMakerSpecProducerTlsArgs',
    'KafkaMirrorMakerSpecProducerTlsTrustedCertificatesArgs',
    'KafkaMirrorMakerSpecReadinessProbeArgs',
    'KafkaMirrorMakerSpecResourcesArgs',
    'KafkaMirrorMakerSpecTemplateArgs',
    'KafkaMirrorMakerSpecTemplateDeploymentArgs',
    'KafkaMirrorMakerSpecTemplateDeploymentMetadataArgs',
    'KafkaMirrorMakerSpecTemplateMirrorMakerContainerArgs',
    'KafkaMirrorMakerSpecTemplateMirrorMakerContainerEnvArgs',
    'KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextArgs',
    'KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextCapabilitiesArgs',
    'KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextSeLinuxOptionsArgs',
    'KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextWindowsOptionsArgs',
    'KafkaMirrorMakerSpecTemplatePodArgs',
    'KafkaMirrorMakerSpecTemplatePodAffinityArgs',
    'KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityArgs',
    'KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs',
    'KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs',
    'KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs',
    'KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs',
    'KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs',
    'KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs',
    'KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityArgs',
    'KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs',
    'KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs',
    'KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs',
    'KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs',
    'KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs',
    'KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityArgs',
    'KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs',
    'KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs',
    'KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs',
    'KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs',
    'KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs',
    'KafkaMirrorMakerSpecTemplatePodDisruptionBudgetArgs',
    'KafkaMirrorMakerSpecTemplatePodDisruptionBudgetMetadataArgs',
    'KafkaMirrorMakerSpecTemplatePodHostAliasesArgs',
    'KafkaMirrorMakerSpecTemplatePodImagePullSecretsArgs',
    'KafkaMirrorMakerSpecTemplatePodMetadataArgs',
    'KafkaMirrorMakerSpecTemplatePodSecurityContextArgs',
    'KafkaMirrorMakerSpecTemplatePodSecurityContextSeLinuxOptionsArgs',
    'KafkaMirrorMakerSpecTemplatePodSecurityContextSysctlsArgs',
    'KafkaMirrorMakerSpecTemplatePodSecurityContextWindowsOptionsArgs',
    'KafkaMirrorMakerSpecTemplatePodTolerationsArgs',
    'KafkaMirrorMakerSpecTolerationsArgs',
    'KafkaMirrorMakerSpecTracingArgs',
    'KafkaMirrorMakerStatusArgs',
    'KafkaMirrorMakerStatusConditionsArgs',
    'KafkaSpecArgs',
    'KafkaSpecClientsCaArgs',
    'KafkaSpecClusterCaArgs',
    'KafkaSpecCruiseControlArgs',
    'KafkaSpecCruiseControlBrokerCapacityArgs',
    'KafkaSpecCruiseControlJvmOptionsArgs',
    'KafkaSpecCruiseControlJvmOptionsJavaSystemPropertiesArgs',
    'KafkaSpecCruiseControlLivenessProbeArgs',
    'KafkaSpecCruiseControlLoggingArgs',
    'KafkaSpecCruiseControlReadinessProbeArgs',
    'KafkaSpecCruiseControlResourcesArgs',
    'KafkaSpecCruiseControlTemplateArgs',
    'KafkaSpecCruiseControlTemplateApiServiceArgs',
    'KafkaSpecCruiseControlTemplateApiServiceMetadataArgs',
    'KafkaSpecCruiseControlTemplateCruiseControlContainerArgs',
    'KafkaSpecCruiseControlTemplateCruiseControlContainerEnvArgs',
    'KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextArgs',
    'KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextCapabilitiesArgs',
    'KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptionsArgs',
    'KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptionsArgs',
    'KafkaSpecCruiseControlTemplateDeploymentArgs',
    'KafkaSpecCruiseControlTemplateDeploymentMetadataArgs',
    'KafkaSpecCruiseControlTemplatePodArgs',
    'KafkaSpecCruiseControlTemplatePodAffinityArgs',
    'KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityArgs',
    'KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs',
    'KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs',
    'KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs',
    'KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs',
    'KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs',
    'KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs',
    'KafkaSpecCruiseControlTemplatePodAffinityPodAffinityArgs',
    'KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs',
    'KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs',
    'KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs',
    'KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs',
    'KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs',
    'KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityArgs',
    'KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs',
    'KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs',
    'KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs',
    'KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs',
    'KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs',
    'KafkaSpecCruiseControlTemplatePodDisruptionBudgetArgs',
    'KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadataArgs',
    'KafkaSpecCruiseControlTemplatePodHostAliasesArgs',
    'KafkaSpecCruiseControlTemplatePodImagePullSecretsArgs',
    'KafkaSpecCruiseControlTemplatePodMetadataArgs',
    'KafkaSpecCruiseControlTemplatePodSecurityContextArgs',
    'KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptionsArgs',
    'KafkaSpecCruiseControlTemplatePodSecurityContextSysctlsArgs',
    'KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptionsArgs',
    'KafkaSpecCruiseControlTemplatePodTolerationsArgs',
    'KafkaSpecCruiseControlTemplateTlsSidecarContainerArgs',
    'KafkaSpecCruiseControlTemplateTlsSidecarContainerEnvArgs',
    'KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextArgs',
    'KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextCapabilitiesArgs',
    'KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptionsArgs',
    'KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptionsArgs',
    'KafkaSpecCruiseControlTlsSidecarArgs',
    'KafkaSpecCruiseControlTlsSidecarLivenessProbeArgs',
    'KafkaSpecCruiseControlTlsSidecarReadinessProbeArgs',
    'KafkaSpecCruiseControlTlsSidecarResourcesArgs',
    'KafkaSpecEntityOperatorArgs',
    'KafkaSpecEntityOperatorAffinityArgs',
    'KafkaSpecEntityOperatorAffinityNodeAffinityArgs',
    'KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs',
    'KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs',
    'KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs',
    'KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs',
    'KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs',
    'KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs',
    'KafkaSpecEntityOperatorAffinityPodAffinityArgs',
    'KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs',
    'KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs',
    'KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs',
    'KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs',
    'KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs',
    'KafkaSpecEntityOperatorAffinityPodAntiAffinityArgs',
    'KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs',
    'KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs',
    'KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs',
    'KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs',
    'KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs',
    'KafkaSpecEntityOperatorTemplateArgs',
    'KafkaSpecEntityOperatorTemplateDeploymentArgs',
    'KafkaSpecEntityOperatorTemplateDeploymentMetadataArgs',
    'KafkaSpecEntityOperatorTemplatePodArgs',
    'KafkaSpecEntityOperatorTemplatePodAffinityArgs',
    'KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityArgs',
    'KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs',
    'KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs',
    'KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs',
    'KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs',
    'KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs',
    'KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs',
    'KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityArgs',
    'KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs',
    'KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs',
    'KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs',
    'KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs',
    'KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs',
    'KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityArgs',
    'KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs',
    'KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs',
    'KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs',
    'KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs',
    'KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs',
    'KafkaSpecEntityOperatorTemplatePodHostAliasesArgs',
    'KafkaSpecEntityOperatorTemplatePodImagePullSecretsArgs',
    'KafkaSpecEntityOperatorTemplatePodMetadataArgs',
    'KafkaSpecEntityOperatorTemplatePodSecurityContextArgs',
    'KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptionsArgs',
    'KafkaSpecEntityOperatorTemplatePodSecurityContextSysctlsArgs',
    'KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptionsArgs',
    'KafkaSpecEntityOperatorTemplatePodTolerationsArgs',
    'KafkaSpecEntityOperatorTemplateTlsSidecarContainerArgs',
    'KafkaSpecEntityOperatorTemplateTlsSidecarContainerEnvArgs',
    'KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextArgs',
    'KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextCapabilitiesArgs',
    'KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptionsArgs',
    'KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptionsArgs',
    'KafkaSpecEntityOperatorTemplateTopicOperatorContainerArgs',
    'KafkaSpecEntityOperatorTemplateTopicOperatorContainerEnvArgs',
    'KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextArgs',
    'KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextCapabilitiesArgs',
    'KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptionsArgs',
    'KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptionsArgs',
    'KafkaSpecEntityOperatorTemplateUserOperatorContainerArgs',
    'KafkaSpecEntityOperatorTemplateUserOperatorContainerEnvArgs',
    'KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextArgs',
    'KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextCapabilitiesArgs',
    'KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptionsArgs',
    'KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptionsArgs',
    'KafkaSpecEntityOperatorTlsSidecarArgs',
    'KafkaSpecEntityOperatorTlsSidecarLivenessProbeArgs',
    'KafkaSpecEntityOperatorTlsSidecarReadinessProbeArgs',
    'KafkaSpecEntityOperatorTlsSidecarResourcesArgs',
    'KafkaSpecEntityOperatorTolerationsArgs',
    'KafkaSpecEntityOperatorTopicOperatorArgs',
    'KafkaSpecEntityOperatorTopicOperatorJvmOptionsArgs',
    'KafkaSpecEntityOperatorTopicOperatorJvmOptionsJavaSystemPropertiesArgs',
    'KafkaSpecEntityOperatorTopicOperatorLivenessProbeArgs',
    'KafkaSpecEntityOperatorTopicOperatorLoggingArgs',
    'KafkaSpecEntityOperatorTopicOperatorReadinessProbeArgs',
    'KafkaSpecEntityOperatorTopicOperatorResourcesArgs',
    'KafkaSpecEntityOperatorUserOperatorArgs',
    'KafkaSpecEntityOperatorUserOperatorJvmOptionsArgs',
    'KafkaSpecEntityOperatorUserOperatorJvmOptionsJavaSystemPropertiesArgs',
    'KafkaSpecEntityOperatorUserOperatorLivenessProbeArgs',
    'KafkaSpecEntityOperatorUserOperatorLoggingArgs',
    'KafkaSpecEntityOperatorUserOperatorReadinessProbeArgs',
    'KafkaSpecEntityOperatorUserOperatorResourcesArgs',
    'KafkaSpecJmxTransArgs',
    'KafkaSpecJmxTransKafkaQueriesArgs',
    'KafkaSpecJmxTransOutputDefinitionsArgs',
    'KafkaSpecJmxTransResourcesArgs',
    'KafkaSpecJmxTransTemplateArgs',
    'KafkaSpecJmxTransTemplateContainerArgs',
    'KafkaSpecJmxTransTemplateContainerEnvArgs',
    'KafkaSpecJmxTransTemplateContainerSecurityContextArgs',
    'KafkaSpecJmxTransTemplateContainerSecurityContextCapabilitiesArgs',
    'KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptionsArgs',
    'KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptionsArgs',
    'KafkaSpecJmxTransTemplateDeploymentArgs',
    'KafkaSpecJmxTransTemplateDeploymentMetadataArgs',
    'KafkaSpecJmxTransTemplatePodArgs',
    'KafkaSpecJmxTransTemplatePodAffinityArgs',
    'KafkaSpecJmxTransTemplatePodAffinityNodeAffinityArgs',
    'KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs',
    'KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs',
    'KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs',
    'KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs',
    'KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs',
    'KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs',
    'KafkaSpecJmxTransTemplatePodAffinityPodAffinityArgs',
    'KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs',
    'KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs',
    'KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs',
    'KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs',
    'KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs',
    'KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityArgs',
    'KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs',
    'KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs',
    'KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs',
    'KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs',
    'KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs',
    'KafkaSpecJmxTransTemplatePodHostAliasesArgs',
    'KafkaSpecJmxTransTemplatePodImagePullSecretsArgs',
    'KafkaSpecJmxTransTemplatePodMetadataArgs',
    'KafkaSpecJmxTransTemplatePodSecurityContextArgs',
    'KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptionsArgs',
    'KafkaSpecJmxTransTemplatePodSecurityContextSysctlsArgs',
    'KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptionsArgs',
    'KafkaSpecJmxTransTemplatePodTolerationsArgs',
    'KafkaSpecKafkaArgs',
    'KafkaSpecKafkaAffinityArgs',
    'KafkaSpecKafkaAffinityNodeAffinityArgs',
    'KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs',
    'KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs',
    'KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs',
    'KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs',
    'KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs',
    'KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs',
    'KafkaSpecKafkaAffinityPodAffinityArgs',
    'KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs',
    'KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs',
    'KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs',
    'KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs',
    'KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs',
    'KafkaSpecKafkaAffinityPodAntiAffinityArgs',
    'KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs',
    'KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs',
    'KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs',
    'KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs',
    'KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs',
    'KafkaSpecKafkaAuthorizationArgs',
    'KafkaSpecKafkaAuthorizationTlsTrustedCertificatesArgs',
    'KafkaSpecKafkaExporterArgs',
    'KafkaSpecKafkaExporterLivenessProbeArgs',
    'KafkaSpecKafkaExporterReadinessProbeArgs',
    'KafkaSpecKafkaExporterResourcesArgs',
    'KafkaSpecKafkaExporterTemplateArgs',
    'KafkaSpecKafkaExporterTemplateContainerArgs',
    'KafkaSpecKafkaExporterTemplateContainerEnvArgs',
    'KafkaSpecKafkaExporterTemplateContainerSecurityContextArgs',
    'KafkaSpecKafkaExporterTemplateContainerSecurityContextCapabilitiesArgs',
    'KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptionsArgs',
    'KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptionsArgs',
    'KafkaSpecKafkaExporterTemplateDeploymentArgs',
    'KafkaSpecKafkaExporterTemplateDeploymentMetadataArgs',
    'KafkaSpecKafkaExporterTemplatePodArgs',
    'KafkaSpecKafkaExporterTemplatePodAffinityArgs',
    'KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityArgs',
    'KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs',
    'KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs',
    'KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs',
    'KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs',
    'KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs',
    'KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs',
    'KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityArgs',
    'KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs',
    'KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs',
    'KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs',
    'KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs',
    'KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs',
    'KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityArgs',
    'KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs',
    'KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs',
    'KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs',
    'KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs',
    'KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs',
    'KafkaSpecKafkaExporterTemplatePodHostAliasesArgs',
    'KafkaSpecKafkaExporterTemplatePodImagePullSecretsArgs',
    'KafkaSpecKafkaExporterTemplatePodMetadataArgs',
    'KafkaSpecKafkaExporterTemplatePodSecurityContextArgs',
    'KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptionsArgs',
    'KafkaSpecKafkaExporterTemplatePodSecurityContextSysctlsArgs',
    'KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptionsArgs',
    'KafkaSpecKafkaExporterTemplatePodTolerationsArgs',
    'KafkaSpecKafkaExporterTemplateServiceArgs',
    'KafkaSpecKafkaExporterTemplateServiceMetadataArgs',
    'KafkaSpecKafkaJmxOptionsArgs',
    'KafkaSpecKafkaJmxOptionsAuthenticationArgs',
    'KafkaSpecKafkaJvmOptionsArgs',
    'KafkaSpecKafkaJvmOptionsJavaSystemPropertiesArgs',
    'KafkaSpecKafkaListenersOneOf0Args',
    'KafkaSpecKafkaListenersOneOf0AuthenticationArgs',
    'KafkaSpecKafkaListenersOneOf0AuthenticationClientSecretArgs',
    'KafkaSpecKafkaListenersOneOf0AuthenticationTlsTrustedCertificatesArgs',
    'KafkaSpecKafkaListenersOneOf0ConfigurationArgs',
    'KafkaSpecKafkaListenersOneOf0ConfigurationBootstrapArgs',
    'KafkaSpecKafkaListenersOneOf0ConfigurationBrokerCertChainAndKeyArgs',
    'KafkaSpecKafkaListenersOneOf0ConfigurationBrokersArgs',
    'KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersArgs',
    'KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersIpBlockArgs',
    'KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersNamespaceSelectorArgs',
    'KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersNamespaceSelectorMatchExpressionsArgs',
    'KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersPodSelectorArgs',
    'KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersPodSelectorMatchExpressionsArgs',
    'KafkaSpecKafkaListenersOneOf1Args',
    'KafkaSpecKafkaListenersOneOf1ExternalArgs',
    'KafkaSpecKafkaListenersOneOf1ExternalAuthenticationArgs',
    'KafkaSpecKafkaListenersOneOf1ExternalAuthenticationClientSecretArgs',
    'KafkaSpecKafkaListenersOneOf1ExternalAuthenticationTlsTrustedCertificatesArgs',
    'KafkaSpecKafkaListenersOneOf1ExternalConfigurationArgs',
    'KafkaSpecKafkaListenersOneOf1ExternalConfigurationBootstrapArgs',
    'KafkaSpecKafkaListenersOneOf1ExternalConfigurationBrokerCertChainAndKeyArgs',
    'KafkaSpecKafkaListenersOneOf1ExternalConfigurationBrokersArgs',
    'KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersArgs',
    'KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersIpBlockArgs',
    'KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersNamespaceSelectorArgs',
    'KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersNamespaceSelectorMatchExpressionsArgs',
    'KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersPodSelectorArgs',
    'KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersPodSelectorMatchExpressionsArgs',
    'KafkaSpecKafkaListenersOneOf1ExternalOverridesArgs',
    'KafkaSpecKafkaListenersOneOf1ExternalOverridesBootstrapArgs',
    'KafkaSpecKafkaListenersOneOf1ExternalOverridesBrokersArgs',
    'KafkaSpecKafkaListenersOneOf1PlainArgs',
    'KafkaSpecKafkaListenersOneOf1PlainAuthenticationArgs',
    'KafkaSpecKafkaListenersOneOf1PlainAuthenticationClientSecretArgs',
    'KafkaSpecKafkaListenersOneOf1PlainAuthenticationTlsTrustedCertificatesArgs',
    'KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersArgs',
    'KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersIpBlockArgs',
    'KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersNamespaceSelectorArgs',
    'KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersNamespaceSelectorMatchExpressionsArgs',
    'KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersPodSelectorArgs',
    'KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersPodSelectorMatchExpressionsArgs',
    'KafkaSpecKafkaListenersOneOf1TlsArgs',
    'KafkaSpecKafkaListenersOneOf1TlsAuthenticationArgs',
    'KafkaSpecKafkaListenersOneOf1TlsAuthenticationClientSecretArgs',
    'KafkaSpecKafkaListenersOneOf1TlsAuthenticationTlsTrustedCertificatesArgs',
    'KafkaSpecKafkaListenersOneOf1TlsConfigurationArgs',
    'KafkaSpecKafkaListenersOneOf1TlsConfigurationBrokerCertChainAndKeyArgs',
    'KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersArgs',
    'KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersIpBlockArgs',
    'KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersNamespaceSelectorArgs',
    'KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersNamespaceSelectorMatchExpressionsArgs',
    'KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersPodSelectorArgs',
    'KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersPodSelectorMatchExpressionsArgs',
    'KafkaSpecKafkaLivenessProbeArgs',
    'KafkaSpecKafkaLoggingArgs',
    'KafkaSpecKafkaRackArgs',
    'KafkaSpecKafkaReadinessProbeArgs',
    'KafkaSpecKafkaResourcesArgs',
    'KafkaSpecKafkaStorageArgs',
    'KafkaSpecKafkaStorageOverridesArgs',
    'KafkaSpecKafkaStorageVolumesArgs',
    'KafkaSpecKafkaStorageVolumesOverridesArgs',
    'KafkaSpecKafkaTemplateArgs',
    'KafkaSpecKafkaTemplateBootstrapServiceArgs',
    'KafkaSpecKafkaTemplateBootstrapServiceMetadataArgs',
    'KafkaSpecKafkaTemplateBrokersServiceArgs',
    'KafkaSpecKafkaTemplateBrokersServiceMetadataArgs',
    'KafkaSpecKafkaTemplateExternalBootstrapIngressArgs',
    'KafkaSpecKafkaTemplateExternalBootstrapIngressMetadataArgs',
    'KafkaSpecKafkaTemplateExternalBootstrapRouteArgs',
    'KafkaSpecKafkaTemplateExternalBootstrapRouteMetadataArgs',
    'KafkaSpecKafkaTemplateExternalBootstrapServiceArgs',
    'KafkaSpecKafkaTemplateExternalBootstrapServiceMetadataArgs',
    'KafkaSpecKafkaTemplateInitContainerArgs',
    'KafkaSpecKafkaTemplateInitContainerEnvArgs',
    'KafkaSpecKafkaTemplateInitContainerSecurityContextArgs',
    'KafkaSpecKafkaTemplateInitContainerSecurityContextCapabilitiesArgs',
    'KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptionsArgs',
    'KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptionsArgs',
    'KafkaSpecKafkaTemplateKafkaContainerArgs',
    'KafkaSpecKafkaTemplateKafkaContainerEnvArgs',
    'KafkaSpecKafkaTemplateKafkaContainerSecurityContextArgs',
    'KafkaSpecKafkaTemplateKafkaContainerSecurityContextCapabilitiesArgs',
    'KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptionsArgs',
    'KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptionsArgs',
    'KafkaSpecKafkaTemplatePerPodIngressArgs',
    'KafkaSpecKafkaTemplatePerPodIngressMetadataArgs',
    'KafkaSpecKafkaTemplatePerPodRouteArgs',
    'KafkaSpecKafkaTemplatePerPodRouteMetadataArgs',
    'KafkaSpecKafkaTemplatePerPodServiceArgs',
    'KafkaSpecKafkaTemplatePerPodServiceMetadataArgs',
    'KafkaSpecKafkaTemplatePersistentVolumeClaimArgs',
    'KafkaSpecKafkaTemplatePersistentVolumeClaimMetadataArgs',
    'KafkaSpecKafkaTemplatePodArgs',
    'KafkaSpecKafkaTemplatePodAffinityArgs',
    'KafkaSpecKafkaTemplatePodAffinityNodeAffinityArgs',
    'KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs',
    'KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs',
    'KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs',
    'KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs',
    'KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs',
    'KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs',
    'KafkaSpecKafkaTemplatePodAffinityPodAffinityArgs',
    'KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs',
    'KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs',
    'KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs',
    'KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs',
    'KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs',
    'KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityArgs',
    'KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs',
    'KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs',
    'KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs',
    'KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs',
    'KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs',
    'KafkaSpecKafkaTemplatePodDisruptionBudgetArgs',
    'KafkaSpecKafkaTemplatePodDisruptionBudgetMetadataArgs',
    'KafkaSpecKafkaTemplatePodHostAliasesArgs',
    'KafkaSpecKafkaTemplatePodImagePullSecretsArgs',
    'KafkaSpecKafkaTemplatePodMetadataArgs',
    'KafkaSpecKafkaTemplatePodSecurityContextArgs',
    'KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptionsArgs',
    'KafkaSpecKafkaTemplatePodSecurityContextSysctlsArgs',
    'KafkaSpecKafkaTemplatePodSecurityContextWindowsOptionsArgs',
    'KafkaSpecKafkaTemplatePodTolerationsArgs',
    'KafkaSpecKafkaTemplateStatefulsetArgs',
    'KafkaSpecKafkaTemplateStatefulsetMetadataArgs',
    'KafkaSpecKafkaTemplateTlsSidecarContainerArgs',
    'KafkaSpecKafkaTemplateTlsSidecarContainerEnvArgs',
    'KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextArgs',
    'KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextCapabilitiesArgs',
    'KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextSeLinuxOptionsArgs',
    'KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextWindowsOptionsArgs',
    'KafkaSpecKafkaTlsSidecarArgs',
    'KafkaSpecKafkaTlsSidecarLivenessProbeArgs',
    'KafkaSpecKafkaTlsSidecarReadinessProbeArgs',
    'KafkaSpecKafkaTlsSidecarResourcesArgs',
    'KafkaSpecKafkaTolerationsArgs',
    'KafkaSpecTopicOperatorArgs',
    'KafkaSpecTopicOperatorAffinityArgs',
    'KafkaSpecTopicOperatorAffinityNodeAffinityArgs',
    'KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs',
    'KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs',
    'KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs',
    'KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs',
    'KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs',
    'KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs',
    'KafkaSpecTopicOperatorAffinityPodAffinityArgs',
    'KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs',
    'KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs',
    'KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs',
    'KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs',
    'KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs',
    'KafkaSpecTopicOperatorAffinityPodAntiAffinityArgs',
    'KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs',
    'KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs',
    'KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs',
    'KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs',
    'KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs',
    'KafkaSpecTopicOperatorJvmOptionsArgs',
    'KafkaSpecTopicOperatorJvmOptionsJavaSystemPropertiesArgs',
    'KafkaSpecTopicOperatorLivenessProbeArgs',
    'KafkaSpecTopicOperatorLoggingArgs',
    'KafkaSpecTopicOperatorReadinessProbeArgs',
    'KafkaSpecTopicOperatorResourcesArgs',
    'KafkaSpecTopicOperatorTlsSidecarArgs',
    'KafkaSpecTopicOperatorTlsSidecarLivenessProbeArgs',
    'KafkaSpecTopicOperatorTlsSidecarReadinessProbeArgs',
    'KafkaSpecTopicOperatorTlsSidecarResourcesArgs',
    'KafkaSpecZookeeperArgs',
    'KafkaSpecZookeeperAffinityArgs',
    'KafkaSpecZookeeperAffinityNodeAffinityArgs',
    'KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs',
    'KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs',
    'KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs',
    'KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs',
    'KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs',
    'KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs',
    'KafkaSpecZookeeperAffinityPodAffinityArgs',
    'KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs',
    'KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs',
    'KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs',
    'KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs',
    'KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs',
    'KafkaSpecZookeeperAffinityPodAntiAffinityArgs',
    'KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs',
    'KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs',
    'KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs',
    'KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs',
    'KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs',
    'KafkaSpecZookeeperJvmOptionsArgs',
    'KafkaSpecZookeeperJvmOptionsJavaSystemPropertiesArgs',
    'KafkaSpecZookeeperLivenessProbeArgs',
    'KafkaSpecZookeeperLoggingArgs',
    'KafkaSpecZookeeperReadinessProbeArgs',
    'KafkaSpecZookeeperResourcesArgs',
    'KafkaSpecZookeeperStorageArgs',
    'KafkaSpecZookeeperStorageOverridesArgs',
    'KafkaSpecZookeeperTemplateArgs',
    'KafkaSpecZookeeperTemplateClientServiceArgs',
    'KafkaSpecZookeeperTemplateClientServiceMetadataArgs',
    'KafkaSpecZookeeperTemplateNodesServiceArgs',
    'KafkaSpecZookeeperTemplateNodesServiceMetadataArgs',
    'KafkaSpecZookeeperTemplatePersistentVolumeClaimArgs',
    'KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadataArgs',
    'KafkaSpecZookeeperTemplatePodArgs',
    'KafkaSpecZookeeperTemplatePodAffinityArgs',
    'KafkaSpecZookeeperTemplatePodAffinityNodeAffinityArgs',
    'KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs',
    'KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs',
    'KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs',
    'KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs',
    'KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs',
    'KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs',
    'KafkaSpecZookeeperTemplatePodAffinityPodAffinityArgs',
    'KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs',
    'KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs',
    'KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs',
    'KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs',
    'KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs',
    'KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityArgs',
    'KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs',
    'KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs',
    'KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs',
    'KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs',
    'KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs',
    'KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs',
    'KafkaSpecZookeeperTemplatePodDisruptionBudgetArgs',
    'KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadataArgs',
    'KafkaSpecZookeeperTemplatePodHostAliasesArgs',
    'KafkaSpecZookeeperTemplatePodImagePullSecretsArgs',
    'KafkaSpecZookeeperTemplatePodMetadataArgs',
    'KafkaSpecZookeeperTemplatePodSecurityContextArgs',
    'KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptionsArgs',
    'KafkaSpecZookeeperTemplatePodSecurityContextSysctlsArgs',
    'KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptionsArgs',
    'KafkaSpecZookeeperTemplatePodTolerationsArgs',
    'KafkaSpecZookeeperTemplateStatefulsetArgs',
    'KafkaSpecZookeeperTemplateStatefulsetMetadataArgs',
    'KafkaSpecZookeeperTemplateTlsSidecarContainerArgs',
    'KafkaSpecZookeeperTemplateTlsSidecarContainerEnvArgs',
    'KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextArgs',
    'KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextCapabilitiesArgs',
    'KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextSeLinuxOptionsArgs',
    'KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextWindowsOptionsArgs',
    'KafkaSpecZookeeperTemplateZookeeperContainerArgs',
    'KafkaSpecZookeeperTemplateZookeeperContainerEnvArgs',
    'KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextArgs',
    'KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextCapabilitiesArgs',
    'KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptionsArgs',
    'KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptionsArgs',
    'KafkaSpecZookeeperTlsSidecarArgs',
    'KafkaSpecZookeeperTlsSidecarLivenessProbeArgs',
    'KafkaSpecZookeeperTlsSidecarReadinessProbeArgs',
    'KafkaSpecZookeeperTlsSidecarResourcesArgs',
    'KafkaSpecZookeeperTolerationsArgs',
    'KafkaStatusArgs',
    'KafkaStatusConditionsArgs',
    'KafkaStatusListenersArgs',
    'KafkaStatusListenersAddressesArgs',
    'KafkaTopicSpecArgs',
    'KafkaTopicStatusArgs',
    'KafkaTopicStatusConditionsArgs',
    'KafkaUserSpecArgs',
    'KafkaUserSpecAuthenticationArgs',
    'KafkaUserSpecAuthorizationArgs',
    'KafkaUserSpecAuthorizationAclsArgs',
    'KafkaUserSpecAuthorizationAclsResourceArgs',
    'KafkaUserSpecQuotasArgs',
    'KafkaUserSpecTemplateArgs',
    'KafkaUserSpecTemplateSecretArgs',
    'KafkaUserSpecTemplateSecretMetadataArgs',
    'KafkaUserStatusArgs',
    'KafkaUserStatusConditionsArgs',
]

@pulumi.input_type
class KafkaConnectS2ISpecArgs:
    def __init__(__self__, *,
                 bootstrap_servers: pulumi.Input[str],
                 affinity: Optional[pulumi.Input['KafkaConnectS2ISpecAffinityArgs']] = None,
                 authentication: Optional[pulumi.Input['KafkaConnectS2ISpecAuthenticationArgs']] = None,
                 build_resources: Optional[pulumi.Input['KafkaConnectS2ISpecBuildResourcesArgs']] = None,
                 client_rack_init_image: Optional[pulumi.Input[str]] = None,
                 config: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 external_configuration: Optional[pulumi.Input['KafkaConnectS2ISpecExternalConfigurationArgs']] = None,
                 image: Optional[pulumi.Input[str]] = None,
                 insecure_source_repository: Optional[pulumi.Input[bool]] = None,
                 jvm_options: Optional[pulumi.Input['KafkaConnectS2ISpecJvmOptionsArgs']] = None,
                 liveness_probe: Optional[pulumi.Input['KafkaConnectS2ISpecLivenessProbeArgs']] = None,
                 logging: Optional[pulumi.Input['KafkaConnectS2ISpecLoggingArgs']] = None,
                 metrics: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 rack: Optional[pulumi.Input['KafkaConnectS2ISpecRackArgs']] = None,
                 readiness_probe: Optional[pulumi.Input['KafkaConnectS2ISpecReadinessProbeArgs']] = None,
                 replicas: Optional[pulumi.Input[int]] = None,
                 resources: Optional[pulumi.Input['KafkaConnectS2ISpecResourcesArgs']] = None,
                 template: Optional[pulumi.Input['KafkaConnectS2ISpecTemplateArgs']] = None,
                 tls: Optional[pulumi.Input['KafkaConnectS2ISpecTlsArgs']] = None,
                 tolerations: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTolerationsArgs']]]] = None,
                 tracing: Optional[pulumi.Input['KafkaConnectS2ISpecTracingArgs']] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        The specification of the Kafka Connect Source-to-Image (S2I) cluster.
        :param pulumi.Input[str] bootstrap_servers: Bootstrap servers to connect to. This should be given as a comma separated list of _<hostname>_:_<port>_ pairs.
        :param pulumi.Input['KafkaConnectS2ISpecAffinityArgs'] affinity: The pod's affinity rules.
        :param pulumi.Input['KafkaConnectS2ISpecAuthenticationArgs'] authentication: Authentication configuration for Kafka Connect.
        :param pulumi.Input['KafkaConnectS2ISpecBuildResourcesArgs'] build_resources: CPU and memory resources to reserve.
        :param pulumi.Input[str] client_rack_init_image: The image of the init container used for initializing the `client.rack`.
        :param pulumi.Input[Mapping[str, Any]] config: The Kafka Connect configuration. Properties with the following prefixes cannot be set: ssl., sasl., security., listeners, plugin.path, rest., bootstrap.servers, consumer.interceptor.classes, producer.interceptor.classes (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
        :param pulumi.Input['KafkaConnectS2ISpecExternalConfigurationArgs'] external_configuration: Pass data from Secrets or ConfigMaps to the Kafka Connect pods and use them to configure connectors.
        :param pulumi.Input[str] image: The docker image for the pods.
        :param pulumi.Input[bool] insecure_source_repository: When true this configures the source repository with the 'Local' reference policy and an import policy that accepts insecure source tags.
        :param pulumi.Input['KafkaConnectS2ISpecJvmOptionsArgs'] jvm_options: JVM Options for pods.
        :param pulumi.Input['KafkaConnectS2ISpecLivenessProbeArgs'] liveness_probe: Pod liveness checking.
        :param pulumi.Input['KafkaConnectS2ISpecLoggingArgs'] logging: Logging configuration for Kafka Connect.
        :param pulumi.Input[Mapping[str, Any]] metrics: The Prometheus JMX Exporter configuration. See https://github.com/prometheus/jmx_exporter for details of the structure of this configuration.
        :param pulumi.Input['KafkaConnectS2ISpecRackArgs'] rack: Configuration of the node label which will be used as the client.rack consumer configuration.
        :param pulumi.Input['KafkaConnectS2ISpecReadinessProbeArgs'] readiness_probe: Pod readiness checking.
        :param pulumi.Input[int] replicas: The number of pods in the Kafka Connect group.
        :param pulumi.Input['KafkaConnectS2ISpecResourcesArgs'] resources: The maximum limits for CPU and memory resources and the requested initial resources.
        :param pulumi.Input['KafkaConnectS2ISpecTemplateArgs'] template: Template for Kafka Connect and Kafka Connect S2I resources. The template allows users to specify how the `Deployment`, `Pods` and `Service` are generated.
        :param pulumi.Input['KafkaConnectS2ISpecTlsArgs'] tls: TLS configuration.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTolerationsArgs']]] tolerations: The pod's tolerations.
        :param pulumi.Input['KafkaConnectS2ISpecTracingArgs'] tracing: The configuration of tracing in Kafka Connect.
        :param pulumi.Input[str] version: The Kafka Connect version. Defaults to {DefaultKafkaVersion}. Consult the user documentation to understand the process required to upgrade or downgrade the version.
        """
        pulumi.set(__self__, "bootstrap_servers", bootstrap_servers)
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if build_resources is not None:
            pulumi.set(__self__, "build_resources", build_resources)
        if client_rack_init_image is not None:
            pulumi.set(__self__, "client_rack_init_image", client_rack_init_image)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if external_configuration is not None:
            pulumi.set(__self__, "external_configuration", external_configuration)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if insecure_source_repository is not None:
            pulumi.set(__self__, "insecure_source_repository", insecure_source_repository)
        if jvm_options is not None:
            pulumi.set(__self__, "jvm_options", jvm_options)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if rack is not None:
            pulumi.set(__self__, "rack", rack)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if template is not None:
            pulumi.set(__self__, "template", template)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)
        if tracing is not None:
            pulumi.set(__self__, "tracing", tracing)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="bootstrapServers")
    def bootstrap_servers(self) -> pulumi.Input[str]:
        """
        Bootstrap servers to connect to. This should be given as a comma separated list of _<hostname>_:_<port>_ pairs.
        """
        return pulumi.get(self, "bootstrap_servers")

    @bootstrap_servers.setter
    def bootstrap_servers(self, value: pulumi.Input[str]):
        pulumi.set(self, "bootstrap_servers", value)

    @property
    @pulumi.getter
    def affinity(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecAffinityArgs']]:
        """
        The pod's affinity rules.
        """
        return pulumi.get(self, "affinity")

    @affinity.setter
    def affinity(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecAffinityArgs']]):
        pulumi.set(self, "affinity", value)

    @property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecAuthenticationArgs']]:
        """
        Authentication configuration for Kafka Connect.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @property
    @pulumi.getter(name="buildResources")
    def build_resources(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecBuildResourcesArgs']]:
        """
        CPU and memory resources to reserve.
        """
        return pulumi.get(self, "build_resources")

    @build_resources.setter
    def build_resources(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecBuildResourcesArgs']]):
        pulumi.set(self, "build_resources", value)

    @property
    @pulumi.getter(name="clientRackInitImage")
    def client_rack_init_image(self) -> Optional[pulumi.Input[str]]:
        """
        The image of the init container used for initializing the `client.rack`.
        """
        return pulumi.get(self, "client_rack_init_image")

    @client_rack_init_image.setter
    def client_rack_init_image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_rack_init_image", value)

    @property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        The Kafka Connect configuration. Properties with the following prefixes cannot be set: ssl., sasl., security., listeners, plugin.path, rest., bootstrap.servers, consumer.interceptor.classes, producer.interceptor.classes (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "config", value)

    @property
    @pulumi.getter(name="externalConfiguration")
    def external_configuration(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecExternalConfigurationArgs']]:
        """
        Pass data from Secrets or ConfigMaps to the Kafka Connect pods and use them to configure connectors.
        """
        return pulumi.get(self, "external_configuration")

    @external_configuration.setter
    def external_configuration(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecExternalConfigurationArgs']]):
        pulumi.set(self, "external_configuration", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        The docker image for the pods.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="insecureSourceRepository")
    def insecure_source_repository(self) -> Optional[pulumi.Input[bool]]:
        """
        When true this configures the source repository with the 'Local' reference policy and an import policy that accepts insecure source tags.
        """
        return pulumi.get(self, "insecure_source_repository")

    @insecure_source_repository.setter
    def insecure_source_repository(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "insecure_source_repository", value)

    @property
    @pulumi.getter(name="jvmOptions")
    def jvm_options(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecJvmOptionsArgs']]:
        """
        JVM Options for pods.
        """
        return pulumi.get(self, "jvm_options")

    @jvm_options.setter
    def jvm_options(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecJvmOptionsArgs']]):
        pulumi.set(self, "jvm_options", value)

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecLivenessProbeArgs']]:
        """
        Pod liveness checking.
        """
        return pulumi.get(self, "liveness_probe")

    @liveness_probe.setter
    def liveness_probe(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecLivenessProbeArgs']]):
        pulumi.set(self, "liveness_probe", value)

    @property
    @pulumi.getter
    def logging(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecLoggingArgs']]:
        """
        Logging configuration for Kafka Connect.
        """
        return pulumi.get(self, "logging")

    @logging.setter
    def logging(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecLoggingArgs']]):
        pulumi.set(self, "logging", value)

    @property
    @pulumi.getter
    def metrics(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        The Prometheus JMX Exporter configuration. See https://github.com/prometheus/jmx_exporter for details of the structure of this configuration.
        """
        return pulumi.get(self, "metrics")

    @metrics.setter
    def metrics(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "metrics", value)

    @property
    @pulumi.getter
    def rack(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecRackArgs']]:
        """
        Configuration of the node label which will be used as the client.rack consumer configuration.
        """
        return pulumi.get(self, "rack")

    @rack.setter
    def rack(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecRackArgs']]):
        pulumi.set(self, "rack", value)

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecReadinessProbeArgs']]:
        """
        Pod readiness checking.
        """
        return pulumi.get(self, "readiness_probe")

    @readiness_probe.setter
    def readiness_probe(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecReadinessProbeArgs']]):
        pulumi.set(self, "readiness_probe", value)

    @property
    @pulumi.getter
    def replicas(self) -> Optional[pulumi.Input[int]]:
        """
        The number of pods in the Kafka Connect group.
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "replicas", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecResourcesArgs']]:
        """
        The maximum limits for CPU and memory resources and the requested initial resources.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecResourcesArgs']]):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter
    def template(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecTemplateArgs']]:
        """
        Template for Kafka Connect and Kafka Connect S2I resources. The template allows users to specify how the `Deployment`, `Pods` and `Service` are generated.
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecTemplateArgs']]):
        pulumi.set(self, "template", value)

    @property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecTlsArgs']]:
        """
        TLS configuration.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecTlsArgs']]):
        pulumi.set(self, "tls", value)

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTolerationsArgs']]]]:
        """
        The pod's tolerations.
        """
        return pulumi.get(self, "tolerations")

    @tolerations.setter
    def tolerations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTolerationsArgs']]]]):
        pulumi.set(self, "tolerations", value)

    @property
    @pulumi.getter
    def tracing(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecTracingArgs']]:
        """
        The configuration of tracing in Kafka Connect.
        """
        return pulumi.get(self, "tracing")

    @tracing.setter
    def tracing(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecTracingArgs']]):
        pulumi.set(self, "tracing", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        The Kafka Connect version. Defaults to {DefaultKafkaVersion}. Consult the user documentation to understand the process required to upgrade or downgrade the version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class KafkaConnectS2ISpecAffinityArgs:
    def __init__(__self__, *,
                 node_affinity: Optional[pulumi.Input['KafkaConnectS2ISpecAffinityNodeAffinityArgs']] = None,
                 pod_affinity: Optional[pulumi.Input['KafkaConnectS2ISpecAffinityPodAffinityArgs']] = None,
                 pod_anti_affinity: Optional[pulumi.Input['KafkaConnectS2ISpecAffinityPodAntiAffinityArgs']] = None):
        """
        The pod's affinity rules.
        """
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecAffinityNodeAffinityArgs']]:
        return pulumi.get(self, "node_affinity")

    @node_affinity.setter
    def node_affinity(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecAffinityNodeAffinityArgs']]):
        pulumi.set(self, "node_affinity", value)

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecAffinityPodAffinityArgs']]:
        return pulumi.get(self, "pod_affinity")

    @pod_affinity.setter
    def pod_affinity(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecAffinityPodAffinityArgs']]):
        pulumi.set(self, "pod_affinity", value)

    @property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecAffinityPodAntiAffinityArgs']]:
        return pulumi.get(self, "pod_anti_affinity")

    @pod_anti_affinity.setter
    def pod_anti_affinity(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecAffinityPodAntiAffinityArgs']]):
        pulumi.set(self, "pod_anti_affinity", value)


@pulumi.input_type
class KafkaConnectS2ISpecAffinityNodeAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input['KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 preference: Optional[pulumi.Input['KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']]:
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]] = None,
                 match_fields: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]]:
        return pulumi.get(self, "match_fields")

    @match_fields.setter
    def match_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]]):
        pulumi.set(self, "match_fields", value)


@pulumi.input_type
class KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 node_selector_terms: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]] = None):
        if node_selector_terms is not None:
            pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]]:
        return pulumi.get(self, "node_selector_terms")

    @node_selector_terms.setter
    def node_selector_terms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]]):
        pulumi.set(self, "node_selector_terms", value)


@pulumi.input_type
class KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]] = None,
                 match_fields: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]]:
        return pulumi.get(self, "match_fields")

    @match_fields.setter
    def match_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]]):
        pulumi.set(self, "match_fields", value)


@pulumi.input_type
class KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaConnectS2ISpecAffinityPodAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 pod_affinity_term: Optional[pulumi.Input['KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]:
        return pulumi.get(self, "pod_affinity_term")

    @pod_affinity_term.setter
    def pod_affinity_term(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]):
        pulumi.set(self, "pod_affinity_term", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaConnectS2ISpecAffinityPodAntiAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 pod_affinity_term: Optional[pulumi.Input['KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]:
        return pulumi.get(self, "pod_affinity_term")

    @pod_affinity_term.setter
    def pod_affinity_term(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]):
        pulumi.set(self, "pod_affinity_term", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaConnectS2ISpecAuthenticationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 access_token: Optional[pulumi.Input['KafkaConnectS2ISpecAuthenticationAccessTokenArgs']] = None,
                 access_token_is_jwt: Optional[pulumi.Input[bool]] = None,
                 certificate_and_key: Optional[pulumi.Input['KafkaConnectS2ISpecAuthenticationCertificateAndKeyArgs']] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input['KafkaConnectS2ISpecAuthenticationClientSecretArgs']] = None,
                 disable_tls_hostname_verification: Optional[pulumi.Input[bool]] = None,
                 max_token_expiry_seconds: Optional[pulumi.Input[int]] = None,
                 password_secret: Optional[pulumi.Input['KafkaConnectS2ISpecAuthenticationPasswordSecretArgs']] = None,
                 refresh_token: Optional[pulumi.Input['KafkaConnectS2ISpecAuthenticationRefreshTokenArgs']] = None,
                 scope: Optional[pulumi.Input[str]] = None,
                 tls_trusted_certificates: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAuthenticationTlsTrustedCertificatesArgs']]]] = None,
                 token_endpoint_uri: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        Authentication configuration for Kafka Connect.
        :param pulumi.Input[str] type: Authentication type. Currently the only supported types are `tls`, `scram-sha-512`, and `plain`. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
        :param pulumi.Input['KafkaConnectS2ISpecAuthenticationAccessTokenArgs'] access_token: Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
        :param pulumi.Input[bool] access_token_is_jwt: Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
        :param pulumi.Input['KafkaConnectS2ISpecAuthenticationCertificateAndKeyArgs'] certificate_and_key: Reference to the `Secret` which holds the certificate and private key pair.
        :param pulumi.Input[str] client_id: OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        :param pulumi.Input['KafkaConnectS2ISpecAuthenticationClientSecretArgs'] client_secret: Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        :param pulumi.Input[bool] disable_tls_hostname_verification: Enable or disable TLS hostname verification. Default value is `false`.
        :param pulumi.Input[int] max_token_expiry_seconds: Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.
        :param pulumi.Input['KafkaConnectS2ISpecAuthenticationPasswordSecretArgs'] password_secret: Reference to the `Secret` which holds the password.
        :param pulumi.Input['KafkaConnectS2ISpecAuthenticationRefreshTokenArgs'] refresh_token: Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
        :param pulumi.Input[str] scope: OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAuthenticationTlsTrustedCertificatesArgs']]] tls_trusted_certificates: Trusted certificates for TLS connection to the OAuth server.
        :param pulumi.Input[str] token_endpoint_uri: Authorization server token endpoint URI.
        :param pulumi.Input[str] username: Username used for the authentication.
        """
        pulumi.set(__self__, "type", type)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if access_token_is_jwt is not None:
            pulumi.set(__self__, "access_token_is_jwt", access_token_is_jwt)
        if certificate_and_key is not None:
            pulumi.set(__self__, "certificate_and_key", certificate_and_key)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if disable_tls_hostname_verification is not None:
            pulumi.set(__self__, "disable_tls_hostname_verification", disable_tls_hostname_verification)
        if max_token_expiry_seconds is not None:
            pulumi.set(__self__, "max_token_expiry_seconds", max_token_expiry_seconds)
        if password_secret is not None:
            pulumi.set(__self__, "password_secret", password_secret)
        if refresh_token is not None:
            pulumi.set(__self__, "refresh_token", refresh_token)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if tls_trusted_certificates is not None:
            pulumi.set(__self__, "tls_trusted_certificates", tls_trusted_certificates)
        if token_endpoint_uri is not None:
            pulumi.set(__self__, "token_endpoint_uri", token_endpoint_uri)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Authentication type. Currently the only supported types are `tls`, `scram-sha-512`, and `plain`. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecAuthenticationAccessTokenArgs']]:
        """
        Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecAuthenticationAccessTokenArgs']]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="accessTokenIsJwt")
    def access_token_is_jwt(self) -> Optional[pulumi.Input[bool]]:
        """
        Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
        """
        return pulumi.get(self, "access_token_is_jwt")

    @access_token_is_jwt.setter
    def access_token_is_jwt(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "access_token_is_jwt", value)

    @property
    @pulumi.getter(name="certificateAndKey")
    def certificate_and_key(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecAuthenticationCertificateAndKeyArgs']]:
        """
        Reference to the `Secret` which holds the certificate and private key pair.
        """
        return pulumi.get(self, "certificate_and_key")

    @certificate_and_key.setter
    def certificate_and_key(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecAuthenticationCertificateAndKeyArgs']]):
        pulumi.set(self, "certificate_and_key", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecAuthenticationClientSecretArgs']]:
        """
        Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecAuthenticationClientSecretArgs']]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="disableTlsHostnameVerification")
    def disable_tls_hostname_verification(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable or disable TLS hostname verification. Default value is `false`.
        """
        return pulumi.get(self, "disable_tls_hostname_verification")

    @disable_tls_hostname_verification.setter
    def disable_tls_hostname_verification(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_tls_hostname_verification", value)

    @property
    @pulumi.getter(name="maxTokenExpirySeconds")
    def max_token_expiry_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.
        """
        return pulumi.get(self, "max_token_expiry_seconds")

    @max_token_expiry_seconds.setter
    def max_token_expiry_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_token_expiry_seconds", value)

    @property
    @pulumi.getter(name="passwordSecret")
    def password_secret(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecAuthenticationPasswordSecretArgs']]:
        """
        Reference to the `Secret` which holds the password.
        """
        return pulumi.get(self, "password_secret")

    @password_secret.setter
    def password_secret(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecAuthenticationPasswordSecretArgs']]):
        pulumi.set(self, "password_secret", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecAuthenticationRefreshTokenArgs']]:
        """
        Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecAuthenticationRefreshTokenArgs']]):
        pulumi.set(self, "refresh_token", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[str]]:
        """
        OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter(name="tlsTrustedCertificates")
    def tls_trusted_certificates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAuthenticationTlsTrustedCertificatesArgs']]]]:
        """
        Trusted certificates for TLS connection to the OAuth server.
        """
        return pulumi.get(self, "tls_trusted_certificates")

    @tls_trusted_certificates.setter
    def tls_trusted_certificates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecAuthenticationTlsTrustedCertificatesArgs']]]]):
        pulumi.set(self, "tls_trusted_certificates", value)

    @property
    @pulumi.getter(name="tokenEndpointUri")
    def token_endpoint_uri(self) -> Optional[pulumi.Input[str]]:
        """
        Authorization server token endpoint URI.
        """
        return pulumi.get(self, "token_endpoint_uri")

    @token_endpoint_uri.setter
    def token_endpoint_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_endpoint_uri", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        Username used for the authentication.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class KafkaConnectS2ISpecAuthenticationAccessTokenArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
        :param pulumi.Input[str] key: The key under which the secret value is stored in the Kubernetes Secret.
        :param pulumi.Input[str] secret_name: The name of the Kubernetes Secret containing the secret value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key under which the secret value is stored in the Kubernetes Secret.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        The name of the Kubernetes Secret containing the secret value.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KafkaConnectS2ISpecAuthenticationCertificateAndKeyArgs:
    def __init__(__self__, *,
                 certificate: pulumi.Input[str],
                 key: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        Reference to the `Secret` which holds the certificate and private key pair.
        :param pulumi.Input[str] certificate: The name of the file certificate in the Secret.
        :param pulumi.Input[str] key: The name of the private key in the Secret.
        :param pulumi.Input[str] secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> pulumi.Input[str]:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The name of the private key in the Secret.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KafkaConnectS2ISpecAuthenticationClientSecretArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        :param pulumi.Input[str] key: The key under which the secret value is stored in the Kubernetes Secret.
        :param pulumi.Input[str] secret_name: The name of the Kubernetes Secret containing the secret value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key under which the secret value is stored in the Kubernetes Secret.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        The name of the Kubernetes Secret containing the secret value.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KafkaConnectS2ISpecAuthenticationPasswordSecretArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        Reference to the `Secret` which holds the password.
        :param pulumi.Input[str] password: The name of the key in the Secret under which the password is stored.
        :param pulumi.Input[str] secret_name: The name of the Secret containing the password.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        The name of the key in the Secret under which the password is stored.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        The name of the Secret containing the password.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KafkaConnectS2ISpecAuthenticationRefreshTokenArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
        :param pulumi.Input[str] key: The key under which the secret value is stored in the Kubernetes Secret.
        :param pulumi.Input[str] secret_name: The name of the Kubernetes Secret containing the secret value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key under which the secret value is stored in the Kubernetes Secret.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        The name of the Kubernetes Secret containing the secret value.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KafkaConnectS2ISpecAuthenticationTlsTrustedCertificatesArgs:
    def __init__(__self__, *,
                 certificate: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] certificate: The name of the file certificate in the Secret.
        :param pulumi.Input[str] secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> pulumi.Input[str]:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KafkaConnectS2ISpecBuildResourcesArgs:
    def __init__(__self__, *,
                 limits: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 requests: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        CPU and memory resources to reserve.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "limits", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "requests", value)


@pulumi.input_type
class KafkaConnectS2ISpecExternalConfigurationArgs:
    def __init__(__self__, *,
                 env: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecExternalConfigurationEnvArgs']]]] = None,
                 volumes: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecExternalConfigurationVolumesArgs']]]] = None):
        """
        Pass data from Secrets or ConfigMaps to the Kafka Connect pods and use them to configure connectors.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecExternalConfigurationEnvArgs']]] env: Allows to pass data from Secret or ConfigMap to the Kafka Connect pods as environment variables.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecExternalConfigurationVolumesArgs']]] volumes: Allows to pass data from Secret or ConfigMap to the Kafka Connect pods as volumes.
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @property
    @pulumi.getter
    def env(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecExternalConfigurationEnvArgs']]]]:
        """
        Allows to pass data from Secret or ConfigMap to the Kafka Connect pods as environment variables.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecExternalConfigurationEnvArgs']]]]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def volumes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecExternalConfigurationVolumesArgs']]]]:
        """
        Allows to pass data from Secret or ConfigMap to the Kafka Connect pods as volumes.
        """
        return pulumi.get(self, "volumes")

    @volumes.setter
    def volumes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecExternalConfigurationVolumesArgs']]]]):
        pulumi.set(self, "volumes", value)


@pulumi.input_type
class KafkaConnectS2ISpecExternalConfigurationEnvArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value_from: pulumi.Input['KafkaConnectS2ISpecExternalConfigurationEnvValueFromArgs']):
        """
        :param pulumi.Input[str] name: Name of the environment variable which will be passed to the Kafka Connect pods. The name of the environment variable cannot start with `KAFKA_` or `STRIMZI_`.
        :param pulumi.Input['KafkaConnectS2ISpecExternalConfigurationEnvValueFromArgs'] value_from: Value of the environment variable which will be passed to the Kafka Connect pods. It can be passed either as a reference to Secret or ConfigMap field. The field has to specify exactly one Secret or ConfigMap.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value_from", value_from)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the environment variable which will be passed to the Kafka Connect pods. The name of the environment variable cannot start with `KAFKA_` or `STRIMZI_`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="valueFrom")
    def value_from(self) -> pulumi.Input['KafkaConnectS2ISpecExternalConfigurationEnvValueFromArgs']:
        """
        Value of the environment variable which will be passed to the Kafka Connect pods. It can be passed either as a reference to Secret or ConfigMap field. The field has to specify exactly one Secret or ConfigMap.
        """
        return pulumi.get(self, "value_from")

    @value_from.setter
    def value_from(self, value: pulumi.Input['KafkaConnectS2ISpecExternalConfigurationEnvValueFromArgs']):
        pulumi.set(self, "value_from", value)


@pulumi.input_type
class KafkaConnectS2ISpecExternalConfigurationEnvValueFromArgs:
    def __init__(__self__, *,
                 config_map_key_ref: Optional[pulumi.Input['KafkaConnectS2ISpecExternalConfigurationEnvValueFromConfigMapKeyRefArgs']] = None,
                 secret_key_ref: Optional[pulumi.Input['KafkaConnectS2ISpecExternalConfigurationEnvValueFromSecretKeyRefArgs']] = None):
        """
        Value of the environment variable which will be passed to the Kafka Connect pods. It can be passed either as a reference to Secret or ConfigMap field. The field has to specify exactly one Secret or ConfigMap.
        :param pulumi.Input['KafkaConnectS2ISpecExternalConfigurationEnvValueFromConfigMapKeyRefArgs'] config_map_key_ref: Refernce to a key in a ConfigMap.
        :param pulumi.Input['KafkaConnectS2ISpecExternalConfigurationEnvValueFromSecretKeyRefArgs'] secret_key_ref: Reference to a key in a Secret.
        """
        if config_map_key_ref is not None:
            pulumi.set(__self__, "config_map_key_ref", config_map_key_ref)
        if secret_key_ref is not None:
            pulumi.set(__self__, "secret_key_ref", secret_key_ref)

    @property
    @pulumi.getter(name="configMapKeyRef")
    def config_map_key_ref(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecExternalConfigurationEnvValueFromConfigMapKeyRefArgs']]:
        """
        Refernce to a key in a ConfigMap.
        """
        return pulumi.get(self, "config_map_key_ref")

    @config_map_key_ref.setter
    def config_map_key_ref(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecExternalConfigurationEnvValueFromConfigMapKeyRefArgs']]):
        pulumi.set(self, "config_map_key_ref", value)

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecExternalConfigurationEnvValueFromSecretKeyRefArgs']]:
        """
        Reference to a key in a Secret.
        """
        return pulumi.get(self, "secret_key_ref")

    @secret_key_ref.setter
    def secret_key_ref(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecExternalConfigurationEnvValueFromSecretKeyRefArgs']]):
        pulumi.set(self, "secret_key_ref", value)


@pulumi.input_type
class KafkaConnectS2ISpecExternalConfigurationEnvValueFromConfigMapKeyRefArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 optional: Optional[pulumi.Input[bool]] = None):
        """
        Refernce to a key in a ConfigMap.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def optional(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "optional")

    @optional.setter
    def optional(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "optional", value)


@pulumi.input_type
class KafkaConnectS2ISpecExternalConfigurationEnvValueFromSecretKeyRefArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 optional: Optional[pulumi.Input[bool]] = None):
        """
        Reference to a key in a Secret.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def optional(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "optional")

    @optional.setter
    def optional(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "optional", value)


@pulumi.input_type
class KafkaConnectS2ISpecExternalConfigurationVolumesArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 config_map: Optional[pulumi.Input['KafkaConnectS2ISpecExternalConfigurationVolumesConfigMapArgs']] = None,
                 secret: Optional[pulumi.Input['KafkaConnectS2ISpecExternalConfigurationVolumesSecretArgs']] = None):
        """
        :param pulumi.Input[str] name: Name of the volume which will be added to the Kafka Connect pods.
        :param pulumi.Input['KafkaConnectS2ISpecExternalConfigurationVolumesConfigMapArgs'] config_map: Reference to a key in a ConfigMap. Exactly one Secret or ConfigMap has to be specified.
        :param pulumi.Input['KafkaConnectS2ISpecExternalConfigurationVolumesSecretArgs'] secret: Reference to a key in a Secret. Exactly one Secret or ConfigMap has to be specified.
        """
        pulumi.set(__self__, "name", name)
        if config_map is not None:
            pulumi.set(__self__, "config_map", config_map)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the volume which will be added to the Kafka Connect pods.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="configMap")
    def config_map(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecExternalConfigurationVolumesConfigMapArgs']]:
        """
        Reference to a key in a ConfigMap. Exactly one Secret or ConfigMap has to be specified.
        """
        return pulumi.get(self, "config_map")

    @config_map.setter
    def config_map(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecExternalConfigurationVolumesConfigMapArgs']]):
        pulumi.set(self, "config_map", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecExternalConfigurationVolumesSecretArgs']]:
        """
        Reference to a key in a Secret. Exactly one Secret or ConfigMap has to be specified.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecExternalConfigurationVolumesSecretArgs']]):
        pulumi.set(self, "secret", value)


@pulumi.input_type
class KafkaConnectS2ISpecExternalConfigurationVolumesConfigMapArgs:
    def __init__(__self__, *,
                 default_mode: Optional[pulumi.Input[int]] = None,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecExternalConfigurationVolumesConfigMapItemsArgs']]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 optional: Optional[pulumi.Input[bool]] = None):
        """
        Reference to a key in a ConfigMap. Exactly one Secret or ConfigMap has to be specified.
        """
        if default_mode is not None:
            pulumi.set(__self__, "default_mode", default_mode)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter(name="defaultMode")
    def default_mode(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "default_mode")

    @default_mode.setter
    def default_mode(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "default_mode", value)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecExternalConfigurationVolumesConfigMapItemsArgs']]]]:
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecExternalConfigurationVolumesConfigMapItemsArgs']]]]):
        pulumi.set(self, "items", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def optional(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "optional")

    @optional.setter
    def optional(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "optional", value)


@pulumi.input_type
class KafkaConnectS2ISpecExternalConfigurationVolumesConfigMapItemsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 mode: Optional[pulumi.Input[int]] = None,
                 path: Optional[pulumi.Input[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


@pulumi.input_type
class KafkaConnectS2ISpecExternalConfigurationVolumesSecretArgs:
    def __init__(__self__, *,
                 default_mode: Optional[pulumi.Input[int]] = None,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecExternalConfigurationVolumesSecretItemsArgs']]]] = None,
                 optional: Optional[pulumi.Input[bool]] = None,
                 secret_name: Optional[pulumi.Input[str]] = None):
        """
        Reference to a key in a Secret. Exactly one Secret or ConfigMap has to be specified.
        """
        if default_mode is not None:
            pulumi.set(__self__, "default_mode", default_mode)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="defaultMode")
    def default_mode(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "default_mode")

    @default_mode.setter
    def default_mode(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "default_mode", value)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecExternalConfigurationVolumesSecretItemsArgs']]]]:
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecExternalConfigurationVolumesSecretItemsArgs']]]]):
        pulumi.set(self, "items", value)

    @property
    @pulumi.getter
    def optional(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "optional")

    @optional.setter
    def optional(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "optional", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KafkaConnectS2ISpecExternalConfigurationVolumesSecretItemsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 mode: Optional[pulumi.Input[int]] = None,
                 path: Optional[pulumi.Input[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


@pulumi.input_type
class KafkaConnectS2ISpecJvmOptionsArgs:
    def __init__(__self__, *,
                 __xx: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 __xms: Optional[pulumi.Input[str]] = None,
                 __xmx: Optional[pulumi.Input[str]] = None,
                 gc_logging_enabled: Optional[pulumi.Input[bool]] = None,
                 java_system_properties: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecJvmOptionsJavaSystemPropertiesArgs']]]] = None):
        """
        JVM Options for pods.
        :param pulumi.Input[Mapping[str, Any]] __xx: A map of -XX options to the JVM.
        :param pulumi.Input[str] __xms: -Xms option to to the JVM.
        :param pulumi.Input[str] __xmx: -Xmx option to to the JVM.
        :param pulumi.Input[bool] gc_logging_enabled: Specifies whether the Garbage Collection logging is enabled. The default is false.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecJvmOptionsJavaSystemPropertiesArgs']]] java_system_properties: A map of additional system properties which will be passed using the `-D` option to the JVM.
        """
        if __xx is not None:
            pulumi.set(__self__, "__xx", __xx)
        if __xms is not None:
            pulumi.set(__self__, "__xms", __xms)
        if __xmx is not None:
            pulumi.set(__self__, "__xmx", __xmx)
        if gc_logging_enabled is not None:
            pulumi.set(__self__, "gc_logging_enabled", gc_logging_enabled)
        if java_system_properties is not None:
            pulumi.set(__self__, "java_system_properties", java_system_properties)

    @property
    @pulumi.getter(name="-XX")
    def __xx(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        A map of -XX options to the JVM.
        """
        return pulumi.get(self, "__xx")

    @__xx.setter
    def __xx(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "__xx", value)

    @property
    @pulumi.getter(name="-Xms")
    def __xms(self) -> Optional[pulumi.Input[str]]:
        """
        -Xms option to to the JVM.
        """
        return pulumi.get(self, "__xms")

    @__xms.setter
    def __xms(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "__xms", value)

    @property
    @pulumi.getter(name="-Xmx")
    def __xmx(self) -> Optional[pulumi.Input[str]]:
        """
        -Xmx option to to the JVM.
        """
        return pulumi.get(self, "__xmx")

    @__xmx.setter
    def __xmx(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "__xmx", value)

    @property
    @pulumi.getter(name="gcLoggingEnabled")
    def gc_logging_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether the Garbage Collection logging is enabled. The default is false.
        """
        return pulumi.get(self, "gc_logging_enabled")

    @gc_logging_enabled.setter
    def gc_logging_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "gc_logging_enabled", value)

    @property
    @pulumi.getter(name="javaSystemProperties")
    def java_system_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecJvmOptionsJavaSystemPropertiesArgs']]]]:
        """
        A map of additional system properties which will be passed using the `-D` option to the JVM.
        """
        return pulumi.get(self, "java_system_properties")

    @java_system_properties.setter
    def java_system_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecJvmOptionsJavaSystemPropertiesArgs']]]]):
        pulumi.set(self, "java_system_properties", value)


@pulumi.input_type
class KafkaConnectS2ISpecJvmOptionsJavaSystemPropertiesArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The system property name.
        :param pulumi.Input[str] value: The system property value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The system property name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The system property value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaConnectS2ISpecLivenessProbeArgs:
    def __init__(__self__, *,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 success_threshold: Optional[pulumi.Input[int]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        Pod liveness checking.
        :param pulumi.Input[int] failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param pulumi.Input[int] initial_delay_seconds: The initial delay before first the health is first checked.
        :param pulumi.Input[int] period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param pulumi.Input[int] success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param pulumi.Input[int] timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "success_threshold", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


@pulumi.input_type
class KafkaConnectS2ISpecLoggingArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 loggers: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        Logging configuration for Kafka Connect.
        :param pulumi.Input[str] type: Logging type, must be either 'inline' or 'external'.
        :param pulumi.Input[Mapping[str, Any]] loggers: A Map from logger name to logger level.
        :param pulumi.Input[str] name: The name of the `ConfigMap` from which to get the logging configuration.
        """
        pulumi.set(__self__, "type", type)
        if loggers is not None:
            pulumi.set(__self__, "loggers", loggers)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Logging type, must be either 'inline' or 'external'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def loggers(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        A Map from logger name to logger level.
        """
        return pulumi.get(self, "loggers")

    @loggers.setter
    def loggers(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "loggers", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the `ConfigMap` from which to get the logging configuration.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class KafkaConnectS2ISpecRackArgs:
    def __init__(__self__, *,
                 topology_key: pulumi.Input[str]):
        """
        Configuration of the node label which will be used as the client.rack consumer configuration.
        :param pulumi.Input[str] topology_key: A key that matches labels assigned to the Kubernetes cluster nodes. The value of the label is used to set the broker's `broker.rack` config.
        """
        pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> pulumi.Input[str]:
        """
        A key that matches labels assigned to the Kubernetes cluster nodes. The value of the label is used to set the broker's `broker.rack` config.
        """
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaConnectS2ISpecReadinessProbeArgs:
    def __init__(__self__, *,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 success_threshold: Optional[pulumi.Input[int]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        Pod readiness checking.
        :param pulumi.Input[int] failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param pulumi.Input[int] initial_delay_seconds: The initial delay before first the health is first checked.
        :param pulumi.Input[int] period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param pulumi.Input[int] success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param pulumi.Input[int] timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "success_threshold", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


@pulumi.input_type
class KafkaConnectS2ISpecResourcesArgs:
    def __init__(__self__, *,
                 limits: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 requests: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        The maximum limits for CPU and memory resources and the requested initial resources.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "limits", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "requests", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplateArgs:
    def __init__(__self__, *,
                 api_service: Optional[pulumi.Input['KafkaConnectS2ISpecTemplateApiServiceArgs']] = None,
                 connect_container: Optional[pulumi.Input['KafkaConnectS2ISpecTemplateConnectContainerArgs']] = None,
                 deployment: Optional[pulumi.Input['KafkaConnectS2ISpecTemplateDeploymentArgs']] = None,
                 init_container: Optional[pulumi.Input['KafkaConnectS2ISpecTemplateInitContainerArgs']] = None,
                 pod: Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodArgs']] = None,
                 pod_disruption_budget: Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodDisruptionBudgetArgs']] = None):
        """
        Template for Kafka Connect and Kafka Connect S2I resources. The template allows users to specify how the `Deployment`, `Pods` and `Service` are generated.
        :param pulumi.Input['KafkaConnectS2ISpecTemplateApiServiceArgs'] api_service: Template for Kafka Connect API `Service`.
        :param pulumi.Input['KafkaConnectS2ISpecTemplateConnectContainerArgs'] connect_container: Template for the Kafka Connect container.
        :param pulumi.Input['KafkaConnectS2ISpecTemplateDeploymentArgs'] deployment: Template for Kafka Connect `Deployment`.
        :param pulumi.Input['KafkaConnectS2ISpecTemplateInitContainerArgs'] init_container: Template for the Kafka init container.
        :param pulumi.Input['KafkaConnectS2ISpecTemplatePodArgs'] pod: Template for Kafka Connect `Pods`.
        :param pulumi.Input['KafkaConnectS2ISpecTemplatePodDisruptionBudgetArgs'] pod_disruption_budget: Template for Kafka Connect `PodDisruptionBudget`.
        """
        if api_service is not None:
            pulumi.set(__self__, "api_service", api_service)
        if connect_container is not None:
            pulumi.set(__self__, "connect_container", connect_container)
        if deployment is not None:
            pulumi.set(__self__, "deployment", deployment)
        if init_container is not None:
            pulumi.set(__self__, "init_container", init_container)
        if pod is not None:
            pulumi.set(__self__, "pod", pod)
        if pod_disruption_budget is not None:
            pulumi.set(__self__, "pod_disruption_budget", pod_disruption_budget)

    @property
    @pulumi.getter(name="apiService")
    def api_service(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecTemplateApiServiceArgs']]:
        """
        Template for Kafka Connect API `Service`.
        """
        return pulumi.get(self, "api_service")

    @api_service.setter
    def api_service(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecTemplateApiServiceArgs']]):
        pulumi.set(self, "api_service", value)

    @property
    @pulumi.getter(name="connectContainer")
    def connect_container(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecTemplateConnectContainerArgs']]:
        """
        Template for the Kafka Connect container.
        """
        return pulumi.get(self, "connect_container")

    @connect_container.setter
    def connect_container(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecTemplateConnectContainerArgs']]):
        pulumi.set(self, "connect_container", value)

    @property
    @pulumi.getter
    def deployment(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecTemplateDeploymentArgs']]:
        """
        Template for Kafka Connect `Deployment`.
        """
        return pulumi.get(self, "deployment")

    @deployment.setter
    def deployment(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecTemplateDeploymentArgs']]):
        pulumi.set(self, "deployment", value)

    @property
    @pulumi.getter(name="initContainer")
    def init_container(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecTemplateInitContainerArgs']]:
        """
        Template for the Kafka init container.
        """
        return pulumi.get(self, "init_container")

    @init_container.setter
    def init_container(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecTemplateInitContainerArgs']]):
        pulumi.set(self, "init_container", value)

    @property
    @pulumi.getter
    def pod(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodArgs']]:
        """
        Template for Kafka Connect `Pods`.
        """
        return pulumi.get(self, "pod")

    @pod.setter
    def pod(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodArgs']]):
        pulumi.set(self, "pod", value)

    @property
    @pulumi.getter(name="podDisruptionBudget")
    def pod_disruption_budget(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodDisruptionBudgetArgs']]:
        """
        Template for Kafka Connect `PodDisruptionBudget`.
        """
        return pulumi.get(self, "pod_disruption_budget")

    @pod_disruption_budget.setter
    def pod_disruption_budget(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodDisruptionBudgetArgs']]):
        pulumi.set(self, "pod_disruption_budget", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplateApiServiceArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input['KafkaConnectS2ISpecTemplateApiServiceMetadataArgs']] = None):
        """
        Template for Kafka Connect API `Service`.
        :param pulumi.Input['KafkaConnectS2ISpecTemplateApiServiceMetadataArgs'] metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecTemplateApiServiceMetadataArgs']]:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecTemplateApiServiceMetadataArgs']]):
        pulumi.set(self, "metadata", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplateApiServiceMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Metadata applied to the resource.
        :param pulumi.Input[Mapping[str, Any]] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param pulumi.Input[Mapping[str, Any]] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplateConnectContainerArgs:
    def __init__(__self__, *,
                 env: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplateConnectContainerEnvArgs']]]] = None,
                 security_context: Optional[pulumi.Input['KafkaConnectS2ISpecTemplateConnectContainerSecurityContextArgs']] = None):
        """
        Template for the Kafka Connect container.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplateConnectContainerEnvArgs']]] env: Environment variables which should be applied to the container.
        :param pulumi.Input['KafkaConnectS2ISpecTemplateConnectContainerSecurityContextArgs'] security_context: Security context for the container.
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)

    @property
    @pulumi.getter
    def env(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplateConnectContainerEnvArgs']]]]:
        """
        Environment variables which should be applied to the container.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplateConnectContainerEnvArgs']]]]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecTemplateConnectContainerSecurityContextArgs']]:
        """
        Security context for the container.
        """
        return pulumi.get(self, "security_context")

    @security_context.setter
    def security_context(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecTemplateConnectContainerSecurityContextArgs']]):
        pulumi.set(self, "security_context", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplateConnectContainerEnvArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The environment variable key.
        :param pulumi.Input[str] value: The environment variable value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The environment variable key.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The environment variable value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplateConnectContainerSecurityContextArgs:
    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[pulumi.Input[bool]] = None,
                 capabilities: Optional[pulumi.Input['KafkaConnectS2ISpecTemplateConnectContainerSecurityContextCapabilitiesArgs']] = None,
                 privileged: Optional[pulumi.Input[bool]] = None,
                 proc_mount: Optional[pulumi.Input[str]] = None,
                 read_only_root_filesystem: Optional[pulumi.Input[bool]] = None,
                 run_as_group: Optional[pulumi.Input[int]] = None,
                 run_as_non_root: Optional[pulumi.Input[bool]] = None,
                 run_as_user: Optional[pulumi.Input[int]] = None,
                 se_linux_options: Optional[pulumi.Input['KafkaConnectS2ISpecTemplateConnectContainerSecurityContextSeLinuxOptionsArgs']] = None,
                 windows_options: Optional[pulumi.Input['KafkaConnectS2ISpecTemplateConnectContainerSecurityContextWindowsOptionsArgs']] = None):
        """
        Security context for the container.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if proc_mount is not None:
            pulumi.set(__self__, "proc_mount", proc_mount)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "allow_privilege_escalation")

    @allow_privilege_escalation.setter
    def allow_privilege_escalation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_privilege_escalation", value)

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecTemplateConnectContainerSecurityContextCapabilitiesArgs']]:
        return pulumi.get(self, "capabilities")

    @capabilities.setter
    def capabilities(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecTemplateConnectContainerSecurityContextCapabilitiesArgs']]):
        pulumi.set(self, "capabilities", value)

    @property
    @pulumi.getter
    def privileged(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "privileged")

    @privileged.setter
    def privileged(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "privileged", value)

    @property
    @pulumi.getter(name="procMount")
    def proc_mount(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "proc_mount")

    @proc_mount.setter
    def proc_mount(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proc_mount", value)

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "read_only_root_filesystem")

    @read_only_root_filesystem.setter
    def read_only_root_filesystem(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "read_only_root_filesystem", value)

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_group")

    @run_as_group.setter
    def run_as_group(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_group", value)

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "run_as_non_root")

    @run_as_non_root.setter
    def run_as_non_root(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_as_non_root", value)

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_user")

    @run_as_user.setter
    def run_as_user(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_user", value)

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecTemplateConnectContainerSecurityContextSeLinuxOptionsArgs']]:
        return pulumi.get(self, "se_linux_options")

    @se_linux_options.setter
    def se_linux_options(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecTemplateConnectContainerSecurityContextSeLinuxOptionsArgs']]):
        pulumi.set(self, "se_linux_options", value)

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecTemplateConnectContainerSecurityContextWindowsOptionsArgs']]:
        return pulumi.get(self, "windows_options")

    @windows_options.setter
    def windows_options(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecTemplateConnectContainerSecurityContextWindowsOptionsArgs']]):
        pulumi.set(self, "windows_options", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplateConnectContainerSecurityContextCapabilitiesArgs:
    def __init__(__self__, *,
                 add: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 drop: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)

    @property
    @pulumi.getter
    def add(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "add")

    @add.setter
    def add(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "add", value)

    @property
    @pulumi.getter
    def drop(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "drop")

    @drop.setter
    def drop(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "drop", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplateConnectContainerSecurityContextSeLinuxOptionsArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplateConnectContainerSecurityContextWindowsOptionsArgs:
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[pulumi.Input[str]] = None,
                 gmsa_credential_spec_name: Optional[pulumi.Input[str]] = None,
                 run_as_user_name: Optional[pulumi.Input[str]] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec")

    @gmsa_credential_spec.setter
    def gmsa_credential_spec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec", value)

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @gmsa_credential_spec_name.setter
    def gmsa_credential_spec_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec_name", value)

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "run_as_user_name")

    @run_as_user_name.setter
    def run_as_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "run_as_user_name", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplateDeploymentArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input['KafkaConnectS2ISpecTemplateDeploymentMetadataArgs']] = None):
        """
        Template for Kafka Connect `Deployment`.
        :param pulumi.Input['KafkaConnectS2ISpecTemplateDeploymentMetadataArgs'] metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecTemplateDeploymentMetadataArgs']]:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecTemplateDeploymentMetadataArgs']]):
        pulumi.set(self, "metadata", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplateDeploymentMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Metadata applied to the resource.
        :param pulumi.Input[Mapping[str, Any]] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param pulumi.Input[Mapping[str, Any]] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplateInitContainerArgs:
    def __init__(__self__, *,
                 env: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplateInitContainerEnvArgs']]]] = None,
                 security_context: Optional[pulumi.Input['KafkaConnectS2ISpecTemplateInitContainerSecurityContextArgs']] = None):
        """
        Template for the Kafka init container.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplateInitContainerEnvArgs']]] env: Environment variables which should be applied to the container.
        :param pulumi.Input['KafkaConnectS2ISpecTemplateInitContainerSecurityContextArgs'] security_context: Security context for the container.
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)

    @property
    @pulumi.getter
    def env(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplateInitContainerEnvArgs']]]]:
        """
        Environment variables which should be applied to the container.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplateInitContainerEnvArgs']]]]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecTemplateInitContainerSecurityContextArgs']]:
        """
        Security context for the container.
        """
        return pulumi.get(self, "security_context")

    @security_context.setter
    def security_context(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecTemplateInitContainerSecurityContextArgs']]):
        pulumi.set(self, "security_context", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplateInitContainerEnvArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The environment variable key.
        :param pulumi.Input[str] value: The environment variable value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The environment variable key.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The environment variable value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplateInitContainerSecurityContextArgs:
    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[pulumi.Input[bool]] = None,
                 capabilities: Optional[pulumi.Input['KafkaConnectS2ISpecTemplateInitContainerSecurityContextCapabilitiesArgs']] = None,
                 privileged: Optional[pulumi.Input[bool]] = None,
                 proc_mount: Optional[pulumi.Input[str]] = None,
                 read_only_root_filesystem: Optional[pulumi.Input[bool]] = None,
                 run_as_group: Optional[pulumi.Input[int]] = None,
                 run_as_non_root: Optional[pulumi.Input[bool]] = None,
                 run_as_user: Optional[pulumi.Input[int]] = None,
                 se_linux_options: Optional[pulumi.Input['KafkaConnectS2ISpecTemplateInitContainerSecurityContextSeLinuxOptionsArgs']] = None,
                 windows_options: Optional[pulumi.Input['KafkaConnectS2ISpecTemplateInitContainerSecurityContextWindowsOptionsArgs']] = None):
        """
        Security context for the container.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if proc_mount is not None:
            pulumi.set(__self__, "proc_mount", proc_mount)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "allow_privilege_escalation")

    @allow_privilege_escalation.setter
    def allow_privilege_escalation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_privilege_escalation", value)

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecTemplateInitContainerSecurityContextCapabilitiesArgs']]:
        return pulumi.get(self, "capabilities")

    @capabilities.setter
    def capabilities(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecTemplateInitContainerSecurityContextCapabilitiesArgs']]):
        pulumi.set(self, "capabilities", value)

    @property
    @pulumi.getter
    def privileged(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "privileged")

    @privileged.setter
    def privileged(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "privileged", value)

    @property
    @pulumi.getter(name="procMount")
    def proc_mount(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "proc_mount")

    @proc_mount.setter
    def proc_mount(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proc_mount", value)

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "read_only_root_filesystem")

    @read_only_root_filesystem.setter
    def read_only_root_filesystem(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "read_only_root_filesystem", value)

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_group")

    @run_as_group.setter
    def run_as_group(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_group", value)

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "run_as_non_root")

    @run_as_non_root.setter
    def run_as_non_root(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_as_non_root", value)

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_user")

    @run_as_user.setter
    def run_as_user(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_user", value)

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecTemplateInitContainerSecurityContextSeLinuxOptionsArgs']]:
        return pulumi.get(self, "se_linux_options")

    @se_linux_options.setter
    def se_linux_options(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecTemplateInitContainerSecurityContextSeLinuxOptionsArgs']]):
        pulumi.set(self, "se_linux_options", value)

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecTemplateInitContainerSecurityContextWindowsOptionsArgs']]:
        return pulumi.get(self, "windows_options")

    @windows_options.setter
    def windows_options(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecTemplateInitContainerSecurityContextWindowsOptionsArgs']]):
        pulumi.set(self, "windows_options", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplateInitContainerSecurityContextCapabilitiesArgs:
    def __init__(__self__, *,
                 add: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 drop: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)

    @property
    @pulumi.getter
    def add(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "add")

    @add.setter
    def add(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "add", value)

    @property
    @pulumi.getter
    def drop(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "drop")

    @drop.setter
    def drop(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "drop", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplateInitContainerSecurityContextSeLinuxOptionsArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplateInitContainerSecurityContextWindowsOptionsArgs:
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[pulumi.Input[str]] = None,
                 gmsa_credential_spec_name: Optional[pulumi.Input[str]] = None,
                 run_as_user_name: Optional[pulumi.Input[str]] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec")

    @gmsa_credential_spec.setter
    def gmsa_credential_spec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec", value)

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @gmsa_credential_spec_name.setter
    def gmsa_credential_spec_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec_name", value)

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "run_as_user_name")

    @run_as_user_name.setter
    def run_as_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "run_as_user_name", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplatePodArgs:
    def __init__(__self__, *,
                 affinity: Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityArgs']] = None,
                 host_aliases: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodHostAliasesArgs']]]] = None,
                 image_pull_secrets: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodImagePullSecretsArgs']]]] = None,
                 metadata: Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodMetadataArgs']] = None,
                 priority_class_name: Optional[pulumi.Input[str]] = None,
                 scheduler_name: Optional[pulumi.Input[str]] = None,
                 security_context: Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodSecurityContextArgs']] = None,
                 termination_grace_period_seconds: Optional[pulumi.Input[int]] = None,
                 tolerations: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodTolerationsArgs']]]] = None):
        """
        Template for Kafka Connect `Pods`.
        :param pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityArgs'] affinity: The pod's affinity rules.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodHostAliasesArgs']]] host_aliases: The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodImagePullSecretsArgs']]] image_pull_secrets: List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
        :param pulumi.Input['KafkaConnectS2ISpecTemplatePodMetadataArgs'] metadata: Metadata applied to the resource.
        :param pulumi.Input[str] priority_class_name: The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
        :param pulumi.Input[str] scheduler_name: The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
        :param pulumi.Input['KafkaConnectS2ISpecTemplatePodSecurityContextArgs'] security_context: Configures pod-level security attributes and common container settings.
        :param pulumi.Input[int] termination_grace_period_seconds: The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodTolerationsArgs']]] tolerations: The pod's tolerations.
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if host_aliases is not None:
            pulumi.set(__self__, "host_aliases", host_aliases)
        if image_pull_secrets is not None:
            pulumi.set(__self__, "image_pull_secrets", image_pull_secrets)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if priority_class_name is not None:
            pulumi.set(__self__, "priority_class_name", priority_class_name)
        if scheduler_name is not None:
            pulumi.set(__self__, "scheduler_name", scheduler_name)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)

    @property
    @pulumi.getter
    def affinity(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityArgs']]:
        """
        The pod's affinity rules.
        """
        return pulumi.get(self, "affinity")

    @affinity.setter
    def affinity(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityArgs']]):
        pulumi.set(self, "affinity", value)

    @property
    @pulumi.getter(name="hostAliases")
    def host_aliases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodHostAliasesArgs']]]]:
        """
        The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
        """
        return pulumi.get(self, "host_aliases")

    @host_aliases.setter
    def host_aliases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodHostAliasesArgs']]]]):
        pulumi.set(self, "host_aliases", value)

    @property
    @pulumi.getter(name="imagePullSecrets")
    def image_pull_secrets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodImagePullSecretsArgs']]]]:
        """
        List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
        """
        return pulumi.get(self, "image_pull_secrets")

    @image_pull_secrets.setter
    def image_pull_secrets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodImagePullSecretsArgs']]]]):
        pulumi.set(self, "image_pull_secrets", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodMetadataArgs']]:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodMetadataArgs']]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter(name="priorityClassName")
    def priority_class_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
        """
        return pulumi.get(self, "priority_class_name")

    @priority_class_name.setter
    def priority_class_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "priority_class_name", value)

    @property
    @pulumi.getter(name="schedulerName")
    def scheduler_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
        """
        return pulumi.get(self, "scheduler_name")

    @scheduler_name.setter
    def scheduler_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scheduler_name", value)

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodSecurityContextArgs']]:
        """
        Configures pod-level security attributes and common container settings.
        """
        return pulumi.get(self, "security_context")

    @security_context.setter
    def security_context(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodSecurityContextArgs']]):
        pulumi.set(self, "security_context", value)

    @property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
        """
        return pulumi.get(self, "termination_grace_period_seconds")

    @termination_grace_period_seconds.setter
    def termination_grace_period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "termination_grace_period_seconds", value)

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodTolerationsArgs']]]]:
        """
        The pod's tolerations.
        """
        return pulumi.get(self, "tolerations")

    @tolerations.setter
    def tolerations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodTolerationsArgs']]]]):
        pulumi.set(self, "tolerations", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplatePodAffinityArgs:
    def __init__(__self__, *,
                 node_affinity: Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityArgs']] = None,
                 pod_affinity: Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAffinityArgs']] = None,
                 pod_anti_affinity: Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityArgs']] = None):
        """
        The pod's affinity rules.
        """
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityArgs']]:
        return pulumi.get(self, "node_affinity")

    @node_affinity.setter
    def node_affinity(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityArgs']]):
        pulumi.set(self, "node_affinity", value)

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAffinityArgs']]:
        return pulumi.get(self, "pod_affinity")

    @pod_affinity.setter
    def pod_affinity(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAffinityArgs']]):
        pulumi.set(self, "pod_affinity", value)

    @property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityArgs']]:
        return pulumi.get(self, "pod_anti_affinity")

    @pod_anti_affinity.setter
    def pod_anti_affinity(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityArgs']]):
        pulumi.set(self, "pod_anti_affinity", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 preference: Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']]:
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]] = None,
                 match_fields: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]]:
        return pulumi.get(self, "match_fields")

    @match_fields.setter
    def match_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]]):
        pulumi.set(self, "match_fields", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 node_selector_terms: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]] = None):
        if node_selector_terms is not None:
            pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]]:
        return pulumi.get(self, "node_selector_terms")

    @node_selector_terms.setter
    def node_selector_terms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]]):
        pulumi.set(self, "node_selector_terms", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]] = None,
                 match_fields: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]]:
        return pulumi.get(self, "match_fields")

    @match_fields.setter
    def match_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]]):
        pulumi.set(self, "match_fields", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplatePodAffinityPodAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 pod_affinity_term: Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]:
        return pulumi.get(self, "pod_affinity_term")

    @pod_affinity_term.setter
    def pod_affinity_term(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]):
        pulumi.set(self, "pod_affinity_term", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 pod_affinity_term: Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]:
        return pulumi.get(self, "pod_affinity_term")

    @pod_affinity_term.setter
    def pod_affinity_term(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]):
        pulumi.set(self, "pod_affinity_term", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplatePodDisruptionBudgetArgs:
    def __init__(__self__, *,
                 max_unavailable: Optional[pulumi.Input[int]] = None,
                 metadata: Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodDisruptionBudgetMetadataArgs']] = None):
        """
        Template for Kafka Connect `PodDisruptionBudget`.
        :param pulumi.Input[int] max_unavailable: Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
        :param pulumi.Input['KafkaConnectS2ISpecTemplatePodDisruptionBudgetMetadataArgs'] metadata: Metadata to apply to the `PodDistruptionBugetTemplate` resource.
        """
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
        """
        return pulumi.get(self, "max_unavailable")

    @max_unavailable.setter
    def max_unavailable(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_unavailable", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodDisruptionBudgetMetadataArgs']]:
        """
        Metadata to apply to the `PodDistruptionBugetTemplate` resource.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodDisruptionBudgetMetadataArgs']]):
        pulumi.set(self, "metadata", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplatePodDisruptionBudgetMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Metadata to apply to the `PodDistruptionBugetTemplate` resource.
        :param pulumi.Input[Mapping[str, Any]] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param pulumi.Input[Mapping[str, Any]] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplatePodHostAliasesArgs:
    def __init__(__self__, *,
                 hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ip: Optional[pulumi.Input[str]] = None):
        if hostnames is not None:
            pulumi.set(__self__, "hostnames", hostnames)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def hostnames(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "hostnames")

    @hostnames.setter
    def hostnames(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hostnames", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplatePodImagePullSecretsArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplatePodMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Metadata applied to the resource.
        :param pulumi.Input[Mapping[str, Any]] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param pulumi.Input[Mapping[str, Any]] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplatePodSecurityContextArgs:
    def __init__(__self__, *,
                 fs_group: Optional[pulumi.Input[int]] = None,
                 fs_group_change_policy: Optional[pulumi.Input[str]] = None,
                 run_as_group: Optional[pulumi.Input[int]] = None,
                 run_as_non_root: Optional[pulumi.Input[bool]] = None,
                 run_as_user: Optional[pulumi.Input[int]] = None,
                 se_linux_options: Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodSecurityContextSeLinuxOptionsArgs']] = None,
                 supplemental_groups: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 sysctls: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodSecurityContextSysctlsArgs']]]] = None,
                 windows_options: Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodSecurityContextWindowsOptionsArgs']] = None):
        """
        Configures pod-level security attributes and common container settings.
        """
        if fs_group is not None:
            pulumi.set(__self__, "fs_group", fs_group)
        if fs_group_change_policy is not None:
            pulumi.set(__self__, "fs_group_change_policy", fs_group_change_policy)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if supplemental_groups is not None:
            pulumi.set(__self__, "supplemental_groups", supplemental_groups)
        if sysctls is not None:
            pulumi.set(__self__, "sysctls", sysctls)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="fsGroup")
    def fs_group(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "fs_group")

    @fs_group.setter
    def fs_group(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "fs_group", value)

    @property
    @pulumi.getter(name="fsGroupChangePolicy")
    def fs_group_change_policy(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "fs_group_change_policy")

    @fs_group_change_policy.setter
    def fs_group_change_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fs_group_change_policy", value)

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_group")

    @run_as_group.setter
    def run_as_group(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_group", value)

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "run_as_non_root")

    @run_as_non_root.setter
    def run_as_non_root(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_as_non_root", value)

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_user")

    @run_as_user.setter
    def run_as_user(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_user", value)

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodSecurityContextSeLinuxOptionsArgs']]:
        return pulumi.get(self, "se_linux_options")

    @se_linux_options.setter
    def se_linux_options(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodSecurityContextSeLinuxOptionsArgs']]):
        pulumi.set(self, "se_linux_options", value)

    @property
    @pulumi.getter(name="supplementalGroups")
    def supplemental_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        return pulumi.get(self, "supplemental_groups")

    @supplemental_groups.setter
    def supplemental_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "supplemental_groups", value)

    @property
    @pulumi.getter
    def sysctls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodSecurityContextSysctlsArgs']]]]:
        return pulumi.get(self, "sysctls")

    @sysctls.setter
    def sysctls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTemplatePodSecurityContextSysctlsArgs']]]]):
        pulumi.set(self, "sysctls", value)

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodSecurityContextWindowsOptionsArgs']]:
        return pulumi.get(self, "windows_options")

    @windows_options.setter
    def windows_options(self, value: Optional[pulumi.Input['KafkaConnectS2ISpecTemplatePodSecurityContextWindowsOptionsArgs']]):
        pulumi.set(self, "windows_options", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplatePodSecurityContextSeLinuxOptionsArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplatePodSecurityContextSysctlsArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplatePodSecurityContextWindowsOptionsArgs:
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[pulumi.Input[str]] = None,
                 gmsa_credential_spec_name: Optional[pulumi.Input[str]] = None,
                 run_as_user_name: Optional[pulumi.Input[str]] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec")

    @gmsa_credential_spec.setter
    def gmsa_credential_spec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec", value)

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @gmsa_credential_spec_name.setter
    def gmsa_credential_spec_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec_name", value)

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "run_as_user_name")

    @run_as_user_name.setter
    def run_as_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "run_as_user_name", value)


@pulumi.input_type
class KafkaConnectS2ISpecTemplatePodTolerationsArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 toleration_seconds: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if toleration_seconds is not None:
            pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "toleration_seconds")

    @toleration_seconds.setter
    def toleration_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "toleration_seconds", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaConnectS2ISpecTlsArgs:
    def __init__(__self__, *,
                 trusted_certificates: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTlsTrustedCertificatesArgs']]]] = None):
        """
        TLS configuration.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTlsTrustedCertificatesArgs']]] trusted_certificates: Trusted certificates for TLS connection.
        """
        if trusted_certificates is not None:
            pulumi.set(__self__, "trusted_certificates", trusted_certificates)

    @property
    @pulumi.getter(name="trustedCertificates")
    def trusted_certificates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTlsTrustedCertificatesArgs']]]]:
        """
        Trusted certificates for TLS connection.
        """
        return pulumi.get(self, "trusted_certificates")

    @trusted_certificates.setter
    def trusted_certificates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2ISpecTlsTrustedCertificatesArgs']]]]):
        pulumi.set(self, "trusted_certificates", value)


@pulumi.input_type
class KafkaConnectS2ISpecTlsTrustedCertificatesArgs:
    def __init__(__self__, *,
                 certificate: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] certificate: The name of the file certificate in the Secret.
        :param pulumi.Input[str] secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> pulumi.Input[str]:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KafkaConnectS2ISpecTolerationsArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 toleration_seconds: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if toleration_seconds is not None:
            pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "toleration_seconds")

    @toleration_seconds.setter
    def toleration_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "toleration_seconds", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaConnectS2ISpecTracingArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str]):
        """
        The configuration of tracing in Kafka Connect.
        :param pulumi.Input[str] type: Type of the tracing used. Currently the only supported type is `jaeger` for Jaeger tracing.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the tracing used. Currently the only supported type is `jaeger` for Jaeger tracing.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class KafkaConnectS2IStatusArgs:
    def __init__(__self__, *,
                 build_config_name: Optional[pulumi.Input[str]] = None,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2IStatusConditionsArgs']]]] = None,
                 connector_plugins: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2IStatusConnectorPluginsArgs']]]] = None,
                 label_selector: Optional[pulumi.Input[str]] = None,
                 observed_generation: Optional[pulumi.Input[int]] = None,
                 replicas: Optional[pulumi.Input[int]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        The status of the Kafka Connect Source-to-Image (S2I) cluster.
        :param pulumi.Input[str] build_config_name: The name of the build configuration.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2IStatusConditionsArgs']]] conditions: List of status conditions.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2IStatusConnectorPluginsArgs']]] connector_plugins: The list of connector plugins available in this Kafka Connect deployment.
        :param pulumi.Input[str] label_selector: Label selector for pods providing this resource.
        :param pulumi.Input[int] observed_generation: The generation of the CRD that was last reconciled by the operator.
        :param pulumi.Input[int] replicas: The current number of pods being used to provide this resource.
        :param pulumi.Input[str] url: The URL of the REST API endpoint for managing and monitoring Kafka Connect connectors.
        """
        if build_config_name is not None:
            pulumi.set(__self__, "build_config_name", build_config_name)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if connector_plugins is not None:
            pulumi.set(__self__, "connector_plugins", connector_plugins)
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="buildConfigName")
    def build_config_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the build configuration.
        """
        return pulumi.get(self, "build_config_name")

    @build_config_name.setter
    def build_config_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "build_config_name", value)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2IStatusConditionsArgs']]]]:
        """
        List of status conditions.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2IStatusConditionsArgs']]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="connectorPlugins")
    def connector_plugins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2IStatusConnectorPluginsArgs']]]]:
        """
        The list of connector plugins available in this Kafka Connect deployment.
        """
        return pulumi.get(self, "connector_plugins")

    @connector_plugins.setter
    def connector_plugins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectS2IStatusConnectorPluginsArgs']]]]):
        pulumi.set(self, "connector_plugins", value)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input[str]]:
        """
        Label selector for pods providing this resource.
        """
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[pulumi.Input[int]]:
        """
        The generation of the CRD that was last reconciled by the operator.
        """
        return pulumi.get(self, "observed_generation")

    @observed_generation.setter
    def observed_generation(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "observed_generation", value)

    @property
    @pulumi.getter
    def replicas(self) -> Optional[pulumi.Input[int]]:
        """
        The current number of pods being used to provide this resource.
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "replicas", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the REST API endpoint for managing and monitoring Kafka Connect connectors.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class KafkaConnectS2IStatusConditionsArgs:
    def __init__(__self__, *,
                 last_transition_time: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] last_transition_time: Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
        :param pulumi.Input[str] message: Human-readable message indicating details about the condition's last transition.
        :param pulumi.Input[str] reason: The reason for the condition's last transition (a single word in CamelCase).
        :param pulumi.Input[str] status: The status of the condition, either True, False or Unknown.
        :param pulumi.Input[str] type: The unique identifier of a condition, used to distinguish between other conditions in the resource.
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[pulumi.Input[str]]:
        """
        Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
        """
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Human-readable message indicating details about the condition's last transition.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        The reason for the condition's last transition (a single word in CamelCase).
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of the condition, either True, False or Unknown.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The unique identifier of a condition, used to distinguish between other conditions in the resource.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class KafkaConnectS2IStatusConnectorPluginsArgs:
    def __init__(__self__, *,
                 class_: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] class_: The class of the connector plugin.
        :param pulumi.Input[str] type: The type of the connector plugin. The available types are `sink` and `source`.
        :param pulumi.Input[str] version: The version of the connector plugin.
        """
        if class_ is not None:
            pulumi.set(__self__, "class_", class_)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="class")
    def class_(self) -> Optional[pulumi.Input[str]]:
        """
        The class of the connector plugin.
        """
        return pulumi.get(self, "class_")

    @class_.setter
    def class_(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "class_", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the connector plugin. The available types are `sink` and `source`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of the connector plugin.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class KafkaConnectSpecArgs:
    def __init__(__self__, *,
                 bootstrap_servers: pulumi.Input[str],
                 affinity: Optional[pulumi.Input['KafkaConnectSpecAffinityArgs']] = None,
                 authentication: Optional[pulumi.Input['KafkaConnectSpecAuthenticationArgs']] = None,
                 client_rack_init_image: Optional[pulumi.Input[str]] = None,
                 config: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 external_configuration: Optional[pulumi.Input['KafkaConnectSpecExternalConfigurationArgs']] = None,
                 image: Optional[pulumi.Input[str]] = None,
                 jvm_options: Optional[pulumi.Input['KafkaConnectSpecJvmOptionsArgs']] = None,
                 liveness_probe: Optional[pulumi.Input['KafkaConnectSpecLivenessProbeArgs']] = None,
                 logging: Optional[pulumi.Input['KafkaConnectSpecLoggingArgs']] = None,
                 metrics: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 rack: Optional[pulumi.Input['KafkaConnectSpecRackArgs']] = None,
                 readiness_probe: Optional[pulumi.Input['KafkaConnectSpecReadinessProbeArgs']] = None,
                 replicas: Optional[pulumi.Input[int]] = None,
                 resources: Optional[pulumi.Input['KafkaConnectSpecResourcesArgs']] = None,
                 template: Optional[pulumi.Input['KafkaConnectSpecTemplateArgs']] = None,
                 tls: Optional[pulumi.Input['KafkaConnectSpecTlsArgs']] = None,
                 tolerations: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTolerationsArgs']]]] = None,
                 tracing: Optional[pulumi.Input['KafkaConnectSpecTracingArgs']] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        The specification of the Kafka Connect cluster.
        :param pulumi.Input[str] bootstrap_servers: Bootstrap servers to connect to. This should be given as a comma separated list of _<hostname>_:_<port>_ pairs.
        :param pulumi.Input['KafkaConnectSpecAffinityArgs'] affinity: The pod's affinity rules.
        :param pulumi.Input['KafkaConnectSpecAuthenticationArgs'] authentication: Authentication configuration for Kafka Connect.
        :param pulumi.Input[str] client_rack_init_image: The image of the init container used for initializing the `client.rack`.
        :param pulumi.Input[Mapping[str, Any]] config: The Kafka Connect configuration. Properties with the following prefixes cannot be set: ssl., sasl., security., listeners, plugin.path, rest., bootstrap.servers, consumer.interceptor.classes, producer.interceptor.classes (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
        :param pulumi.Input['KafkaConnectSpecExternalConfigurationArgs'] external_configuration: Pass data from Secrets or ConfigMaps to the Kafka Connect pods and use them to configure connectors.
        :param pulumi.Input[str] image: The docker image for the pods.
        :param pulumi.Input['KafkaConnectSpecJvmOptionsArgs'] jvm_options: JVM Options for pods.
        :param pulumi.Input['KafkaConnectSpecLivenessProbeArgs'] liveness_probe: Pod liveness checking.
        :param pulumi.Input['KafkaConnectSpecLoggingArgs'] logging: Logging configuration for Kafka Connect.
        :param pulumi.Input[Mapping[str, Any]] metrics: The Prometheus JMX Exporter configuration. See https://github.com/prometheus/jmx_exporter for details of the structure of this configuration.
        :param pulumi.Input['KafkaConnectSpecRackArgs'] rack: Configuration of the node label which will be used as the client.rack consumer configuration.
        :param pulumi.Input['KafkaConnectSpecReadinessProbeArgs'] readiness_probe: Pod readiness checking.
        :param pulumi.Input[int] replicas: The number of pods in the Kafka Connect group.
        :param pulumi.Input['KafkaConnectSpecResourcesArgs'] resources: The maximum limits for CPU and memory resources and the requested initial resources.
        :param pulumi.Input['KafkaConnectSpecTemplateArgs'] template: Template for Kafka Connect and Kafka Connect S2I resources. The template allows users to specify how the `Deployment`, `Pods` and `Service` are generated.
        :param pulumi.Input['KafkaConnectSpecTlsArgs'] tls: TLS configuration.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTolerationsArgs']]] tolerations: The pod's tolerations.
        :param pulumi.Input['KafkaConnectSpecTracingArgs'] tracing: The configuration of tracing in Kafka Connect.
        :param pulumi.Input[str] version: The Kafka Connect version. Defaults to {DefaultKafkaVersion}. Consult the user documentation to understand the process required to upgrade or downgrade the version.
        """
        pulumi.set(__self__, "bootstrap_servers", bootstrap_servers)
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if client_rack_init_image is not None:
            pulumi.set(__self__, "client_rack_init_image", client_rack_init_image)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if external_configuration is not None:
            pulumi.set(__self__, "external_configuration", external_configuration)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if jvm_options is not None:
            pulumi.set(__self__, "jvm_options", jvm_options)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if rack is not None:
            pulumi.set(__self__, "rack", rack)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if template is not None:
            pulumi.set(__self__, "template", template)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)
        if tracing is not None:
            pulumi.set(__self__, "tracing", tracing)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="bootstrapServers")
    def bootstrap_servers(self) -> pulumi.Input[str]:
        """
        Bootstrap servers to connect to. This should be given as a comma separated list of _<hostname>_:_<port>_ pairs.
        """
        return pulumi.get(self, "bootstrap_servers")

    @bootstrap_servers.setter
    def bootstrap_servers(self, value: pulumi.Input[str]):
        pulumi.set(self, "bootstrap_servers", value)

    @property
    @pulumi.getter
    def affinity(self) -> Optional[pulumi.Input['KafkaConnectSpecAffinityArgs']]:
        """
        The pod's affinity rules.
        """
        return pulumi.get(self, "affinity")

    @affinity.setter
    def affinity(self, value: Optional[pulumi.Input['KafkaConnectSpecAffinityArgs']]):
        pulumi.set(self, "affinity", value)

    @property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['KafkaConnectSpecAuthenticationArgs']]:
        """
        Authentication configuration for Kafka Connect.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['KafkaConnectSpecAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @property
    @pulumi.getter(name="clientRackInitImage")
    def client_rack_init_image(self) -> Optional[pulumi.Input[str]]:
        """
        The image of the init container used for initializing the `client.rack`.
        """
        return pulumi.get(self, "client_rack_init_image")

    @client_rack_init_image.setter
    def client_rack_init_image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_rack_init_image", value)

    @property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        The Kafka Connect configuration. Properties with the following prefixes cannot be set: ssl., sasl., security., listeners, plugin.path, rest., bootstrap.servers, consumer.interceptor.classes, producer.interceptor.classes (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "config", value)

    @property
    @pulumi.getter(name="externalConfiguration")
    def external_configuration(self) -> Optional[pulumi.Input['KafkaConnectSpecExternalConfigurationArgs']]:
        """
        Pass data from Secrets or ConfigMaps to the Kafka Connect pods and use them to configure connectors.
        """
        return pulumi.get(self, "external_configuration")

    @external_configuration.setter
    def external_configuration(self, value: Optional[pulumi.Input['KafkaConnectSpecExternalConfigurationArgs']]):
        pulumi.set(self, "external_configuration", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        The docker image for the pods.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="jvmOptions")
    def jvm_options(self) -> Optional[pulumi.Input['KafkaConnectSpecJvmOptionsArgs']]:
        """
        JVM Options for pods.
        """
        return pulumi.get(self, "jvm_options")

    @jvm_options.setter
    def jvm_options(self, value: Optional[pulumi.Input['KafkaConnectSpecJvmOptionsArgs']]):
        pulumi.set(self, "jvm_options", value)

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional[pulumi.Input['KafkaConnectSpecLivenessProbeArgs']]:
        """
        Pod liveness checking.
        """
        return pulumi.get(self, "liveness_probe")

    @liveness_probe.setter
    def liveness_probe(self, value: Optional[pulumi.Input['KafkaConnectSpecLivenessProbeArgs']]):
        pulumi.set(self, "liveness_probe", value)

    @property
    @pulumi.getter
    def logging(self) -> Optional[pulumi.Input['KafkaConnectSpecLoggingArgs']]:
        """
        Logging configuration for Kafka Connect.
        """
        return pulumi.get(self, "logging")

    @logging.setter
    def logging(self, value: Optional[pulumi.Input['KafkaConnectSpecLoggingArgs']]):
        pulumi.set(self, "logging", value)

    @property
    @pulumi.getter
    def metrics(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        The Prometheus JMX Exporter configuration. See https://github.com/prometheus/jmx_exporter for details of the structure of this configuration.
        """
        return pulumi.get(self, "metrics")

    @metrics.setter
    def metrics(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "metrics", value)

    @property
    @pulumi.getter
    def rack(self) -> Optional[pulumi.Input['KafkaConnectSpecRackArgs']]:
        """
        Configuration of the node label which will be used as the client.rack consumer configuration.
        """
        return pulumi.get(self, "rack")

    @rack.setter
    def rack(self, value: Optional[pulumi.Input['KafkaConnectSpecRackArgs']]):
        pulumi.set(self, "rack", value)

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional[pulumi.Input['KafkaConnectSpecReadinessProbeArgs']]:
        """
        Pod readiness checking.
        """
        return pulumi.get(self, "readiness_probe")

    @readiness_probe.setter
    def readiness_probe(self, value: Optional[pulumi.Input['KafkaConnectSpecReadinessProbeArgs']]):
        pulumi.set(self, "readiness_probe", value)

    @property
    @pulumi.getter
    def replicas(self) -> Optional[pulumi.Input[int]]:
        """
        The number of pods in the Kafka Connect group.
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "replicas", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['KafkaConnectSpecResourcesArgs']]:
        """
        The maximum limits for CPU and memory resources and the requested initial resources.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['KafkaConnectSpecResourcesArgs']]):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter
    def template(self) -> Optional[pulumi.Input['KafkaConnectSpecTemplateArgs']]:
        """
        Template for Kafka Connect and Kafka Connect S2I resources. The template allows users to specify how the `Deployment`, `Pods` and `Service` are generated.
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[pulumi.Input['KafkaConnectSpecTemplateArgs']]):
        pulumi.set(self, "template", value)

    @property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input['KafkaConnectSpecTlsArgs']]:
        """
        TLS configuration.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input['KafkaConnectSpecTlsArgs']]):
        pulumi.set(self, "tls", value)

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTolerationsArgs']]]]:
        """
        The pod's tolerations.
        """
        return pulumi.get(self, "tolerations")

    @tolerations.setter
    def tolerations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTolerationsArgs']]]]):
        pulumi.set(self, "tolerations", value)

    @property
    @pulumi.getter
    def tracing(self) -> Optional[pulumi.Input['KafkaConnectSpecTracingArgs']]:
        """
        The configuration of tracing in Kafka Connect.
        """
        return pulumi.get(self, "tracing")

    @tracing.setter
    def tracing(self, value: Optional[pulumi.Input['KafkaConnectSpecTracingArgs']]):
        pulumi.set(self, "tracing", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        The Kafka Connect version. Defaults to {DefaultKafkaVersion}. Consult the user documentation to understand the process required to upgrade or downgrade the version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class KafkaConnectSpecAffinityArgs:
    def __init__(__self__, *,
                 node_affinity: Optional[pulumi.Input['KafkaConnectSpecAffinityNodeAffinityArgs']] = None,
                 pod_affinity: Optional[pulumi.Input['KafkaConnectSpecAffinityPodAffinityArgs']] = None,
                 pod_anti_affinity: Optional[pulumi.Input['KafkaConnectSpecAffinityPodAntiAffinityArgs']] = None):
        """
        The pod's affinity rules.
        """
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional[pulumi.Input['KafkaConnectSpecAffinityNodeAffinityArgs']]:
        return pulumi.get(self, "node_affinity")

    @node_affinity.setter
    def node_affinity(self, value: Optional[pulumi.Input['KafkaConnectSpecAffinityNodeAffinityArgs']]):
        pulumi.set(self, "node_affinity", value)

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional[pulumi.Input['KafkaConnectSpecAffinityPodAffinityArgs']]:
        return pulumi.get(self, "pod_affinity")

    @pod_affinity.setter
    def pod_affinity(self, value: Optional[pulumi.Input['KafkaConnectSpecAffinityPodAffinityArgs']]):
        pulumi.set(self, "pod_affinity", value)

    @property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional[pulumi.Input['KafkaConnectSpecAffinityPodAntiAffinityArgs']]:
        return pulumi.get(self, "pod_anti_affinity")

    @pod_anti_affinity.setter
    def pod_anti_affinity(self, value: Optional[pulumi.Input['KafkaConnectSpecAffinityPodAntiAffinityArgs']]):
        pulumi.set(self, "pod_anti_affinity", value)


@pulumi.input_type
class KafkaConnectSpecAffinityNodeAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input['KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input['KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input['KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 preference: Optional[pulumi.Input['KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input['KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']]:
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input['KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]] = None,
                 match_fields: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]]:
        return pulumi.get(self, "match_fields")

    @match_fields.setter
    def match_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]]):
        pulumi.set(self, "match_fields", value)


@pulumi.input_type
class KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 node_selector_terms: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]] = None):
        if node_selector_terms is not None:
            pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]]:
        return pulumi.get(self, "node_selector_terms")

    @node_selector_terms.setter
    def node_selector_terms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]]):
        pulumi.set(self, "node_selector_terms", value)


@pulumi.input_type
class KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]] = None,
                 match_fields: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]]:
        return pulumi.get(self, "match_fields")

    @match_fields.setter
    def match_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]]):
        pulumi.set(self, "match_fields", value)


@pulumi.input_type
class KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaConnectSpecAffinityPodAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 pod_affinity_term: Optional[pulumi.Input['KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional[pulumi.Input['KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]:
        return pulumi.get(self, "pod_affinity_term")

    @pod_affinity_term.setter
    def pod_affinity_term(self, value: Optional[pulumi.Input['KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]):
        pulumi.set(self, "pod_affinity_term", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaConnectSpecAffinityPodAntiAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 pod_affinity_term: Optional[pulumi.Input['KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional[pulumi.Input['KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]:
        return pulumi.get(self, "pod_affinity_term")

    @pod_affinity_term.setter
    def pod_affinity_term(self, value: Optional[pulumi.Input['KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]):
        pulumi.set(self, "pod_affinity_term", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaConnectSpecAuthenticationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 access_token: Optional[pulumi.Input['KafkaConnectSpecAuthenticationAccessTokenArgs']] = None,
                 access_token_is_jwt: Optional[pulumi.Input[bool]] = None,
                 certificate_and_key: Optional[pulumi.Input['KafkaConnectSpecAuthenticationCertificateAndKeyArgs']] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input['KafkaConnectSpecAuthenticationClientSecretArgs']] = None,
                 disable_tls_hostname_verification: Optional[pulumi.Input[bool]] = None,
                 max_token_expiry_seconds: Optional[pulumi.Input[int]] = None,
                 password_secret: Optional[pulumi.Input['KafkaConnectSpecAuthenticationPasswordSecretArgs']] = None,
                 refresh_token: Optional[pulumi.Input['KafkaConnectSpecAuthenticationRefreshTokenArgs']] = None,
                 scope: Optional[pulumi.Input[str]] = None,
                 tls_trusted_certificates: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAuthenticationTlsTrustedCertificatesArgs']]]] = None,
                 token_endpoint_uri: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        Authentication configuration for Kafka Connect.
        :param pulumi.Input[str] type: Authentication type. Currently the only supported types are `tls`, `scram-sha-512`, and `plain`. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
        :param pulumi.Input['KafkaConnectSpecAuthenticationAccessTokenArgs'] access_token: Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
        :param pulumi.Input[bool] access_token_is_jwt: Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
        :param pulumi.Input['KafkaConnectSpecAuthenticationCertificateAndKeyArgs'] certificate_and_key: Reference to the `Secret` which holds the certificate and private key pair.
        :param pulumi.Input[str] client_id: OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        :param pulumi.Input['KafkaConnectSpecAuthenticationClientSecretArgs'] client_secret: Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        :param pulumi.Input[bool] disable_tls_hostname_verification: Enable or disable TLS hostname verification. Default value is `false`.
        :param pulumi.Input[int] max_token_expiry_seconds: Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.
        :param pulumi.Input['KafkaConnectSpecAuthenticationPasswordSecretArgs'] password_secret: Reference to the `Secret` which holds the password.
        :param pulumi.Input['KafkaConnectSpecAuthenticationRefreshTokenArgs'] refresh_token: Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
        :param pulumi.Input[str] scope: OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAuthenticationTlsTrustedCertificatesArgs']]] tls_trusted_certificates: Trusted certificates for TLS connection to the OAuth server.
        :param pulumi.Input[str] token_endpoint_uri: Authorization server token endpoint URI.
        :param pulumi.Input[str] username: Username used for the authentication.
        """
        pulumi.set(__self__, "type", type)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if access_token_is_jwt is not None:
            pulumi.set(__self__, "access_token_is_jwt", access_token_is_jwt)
        if certificate_and_key is not None:
            pulumi.set(__self__, "certificate_and_key", certificate_and_key)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if disable_tls_hostname_verification is not None:
            pulumi.set(__self__, "disable_tls_hostname_verification", disable_tls_hostname_verification)
        if max_token_expiry_seconds is not None:
            pulumi.set(__self__, "max_token_expiry_seconds", max_token_expiry_seconds)
        if password_secret is not None:
            pulumi.set(__self__, "password_secret", password_secret)
        if refresh_token is not None:
            pulumi.set(__self__, "refresh_token", refresh_token)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if tls_trusted_certificates is not None:
            pulumi.set(__self__, "tls_trusted_certificates", tls_trusted_certificates)
        if token_endpoint_uri is not None:
            pulumi.set(__self__, "token_endpoint_uri", token_endpoint_uri)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Authentication type. Currently the only supported types are `tls`, `scram-sha-512`, and `plain`. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input['KafkaConnectSpecAuthenticationAccessTokenArgs']]:
        """
        Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input['KafkaConnectSpecAuthenticationAccessTokenArgs']]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="accessTokenIsJwt")
    def access_token_is_jwt(self) -> Optional[pulumi.Input[bool]]:
        """
        Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
        """
        return pulumi.get(self, "access_token_is_jwt")

    @access_token_is_jwt.setter
    def access_token_is_jwt(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "access_token_is_jwt", value)

    @property
    @pulumi.getter(name="certificateAndKey")
    def certificate_and_key(self) -> Optional[pulumi.Input['KafkaConnectSpecAuthenticationCertificateAndKeyArgs']]:
        """
        Reference to the `Secret` which holds the certificate and private key pair.
        """
        return pulumi.get(self, "certificate_and_key")

    @certificate_and_key.setter
    def certificate_and_key(self, value: Optional[pulumi.Input['KafkaConnectSpecAuthenticationCertificateAndKeyArgs']]):
        pulumi.set(self, "certificate_and_key", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input['KafkaConnectSpecAuthenticationClientSecretArgs']]:
        """
        Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input['KafkaConnectSpecAuthenticationClientSecretArgs']]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="disableTlsHostnameVerification")
    def disable_tls_hostname_verification(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable or disable TLS hostname verification. Default value is `false`.
        """
        return pulumi.get(self, "disable_tls_hostname_verification")

    @disable_tls_hostname_verification.setter
    def disable_tls_hostname_verification(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_tls_hostname_verification", value)

    @property
    @pulumi.getter(name="maxTokenExpirySeconds")
    def max_token_expiry_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.
        """
        return pulumi.get(self, "max_token_expiry_seconds")

    @max_token_expiry_seconds.setter
    def max_token_expiry_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_token_expiry_seconds", value)

    @property
    @pulumi.getter(name="passwordSecret")
    def password_secret(self) -> Optional[pulumi.Input['KafkaConnectSpecAuthenticationPasswordSecretArgs']]:
        """
        Reference to the `Secret` which holds the password.
        """
        return pulumi.get(self, "password_secret")

    @password_secret.setter
    def password_secret(self, value: Optional[pulumi.Input['KafkaConnectSpecAuthenticationPasswordSecretArgs']]):
        pulumi.set(self, "password_secret", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional[pulumi.Input['KafkaConnectSpecAuthenticationRefreshTokenArgs']]:
        """
        Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: Optional[pulumi.Input['KafkaConnectSpecAuthenticationRefreshTokenArgs']]):
        pulumi.set(self, "refresh_token", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[str]]:
        """
        OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter(name="tlsTrustedCertificates")
    def tls_trusted_certificates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAuthenticationTlsTrustedCertificatesArgs']]]]:
        """
        Trusted certificates for TLS connection to the OAuth server.
        """
        return pulumi.get(self, "tls_trusted_certificates")

    @tls_trusted_certificates.setter
    def tls_trusted_certificates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecAuthenticationTlsTrustedCertificatesArgs']]]]):
        pulumi.set(self, "tls_trusted_certificates", value)

    @property
    @pulumi.getter(name="tokenEndpointUri")
    def token_endpoint_uri(self) -> Optional[pulumi.Input[str]]:
        """
        Authorization server token endpoint URI.
        """
        return pulumi.get(self, "token_endpoint_uri")

    @token_endpoint_uri.setter
    def token_endpoint_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_endpoint_uri", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        Username used for the authentication.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class KafkaConnectSpecAuthenticationAccessTokenArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
        :param pulumi.Input[str] key: The key under which the secret value is stored in the Kubernetes Secret.
        :param pulumi.Input[str] secret_name: The name of the Kubernetes Secret containing the secret value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key under which the secret value is stored in the Kubernetes Secret.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        The name of the Kubernetes Secret containing the secret value.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KafkaConnectSpecAuthenticationCertificateAndKeyArgs:
    def __init__(__self__, *,
                 certificate: pulumi.Input[str],
                 key: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        Reference to the `Secret` which holds the certificate and private key pair.
        :param pulumi.Input[str] certificate: The name of the file certificate in the Secret.
        :param pulumi.Input[str] key: The name of the private key in the Secret.
        :param pulumi.Input[str] secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> pulumi.Input[str]:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The name of the private key in the Secret.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KafkaConnectSpecAuthenticationClientSecretArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        :param pulumi.Input[str] key: The key under which the secret value is stored in the Kubernetes Secret.
        :param pulumi.Input[str] secret_name: The name of the Kubernetes Secret containing the secret value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key under which the secret value is stored in the Kubernetes Secret.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        The name of the Kubernetes Secret containing the secret value.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KafkaConnectSpecAuthenticationPasswordSecretArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        Reference to the `Secret` which holds the password.
        :param pulumi.Input[str] password: The name of the key in the Secret under which the password is stored.
        :param pulumi.Input[str] secret_name: The name of the Secret containing the password.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        The name of the key in the Secret under which the password is stored.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        The name of the Secret containing the password.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KafkaConnectSpecAuthenticationRefreshTokenArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
        :param pulumi.Input[str] key: The key under which the secret value is stored in the Kubernetes Secret.
        :param pulumi.Input[str] secret_name: The name of the Kubernetes Secret containing the secret value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key under which the secret value is stored in the Kubernetes Secret.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        The name of the Kubernetes Secret containing the secret value.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KafkaConnectSpecAuthenticationTlsTrustedCertificatesArgs:
    def __init__(__self__, *,
                 certificate: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] certificate: The name of the file certificate in the Secret.
        :param pulumi.Input[str] secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> pulumi.Input[str]:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KafkaConnectSpecExternalConfigurationArgs:
    def __init__(__self__, *,
                 env: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecExternalConfigurationEnvArgs']]]] = None,
                 volumes: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecExternalConfigurationVolumesArgs']]]] = None):
        """
        Pass data from Secrets or ConfigMaps to the Kafka Connect pods and use them to configure connectors.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecExternalConfigurationEnvArgs']]] env: Allows to pass data from Secret or ConfigMap to the Kafka Connect pods as environment variables.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecExternalConfigurationVolumesArgs']]] volumes: Allows to pass data from Secret or ConfigMap to the Kafka Connect pods as volumes.
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @property
    @pulumi.getter
    def env(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecExternalConfigurationEnvArgs']]]]:
        """
        Allows to pass data from Secret or ConfigMap to the Kafka Connect pods as environment variables.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecExternalConfigurationEnvArgs']]]]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def volumes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecExternalConfigurationVolumesArgs']]]]:
        """
        Allows to pass data from Secret or ConfigMap to the Kafka Connect pods as volumes.
        """
        return pulumi.get(self, "volumes")

    @volumes.setter
    def volumes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecExternalConfigurationVolumesArgs']]]]):
        pulumi.set(self, "volumes", value)


@pulumi.input_type
class KafkaConnectSpecExternalConfigurationEnvArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value_from: pulumi.Input['KafkaConnectSpecExternalConfigurationEnvValueFromArgs']):
        """
        :param pulumi.Input[str] name: Name of the environment variable which will be passed to the Kafka Connect pods. The name of the environment variable cannot start with `KAFKA_` or `STRIMZI_`.
        :param pulumi.Input['KafkaConnectSpecExternalConfigurationEnvValueFromArgs'] value_from: Value of the environment variable which will be passed to the Kafka Connect pods. It can be passed either as a reference to Secret or ConfigMap field. The field has to specify exactly one Secret or ConfigMap.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value_from", value_from)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the environment variable which will be passed to the Kafka Connect pods. The name of the environment variable cannot start with `KAFKA_` or `STRIMZI_`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="valueFrom")
    def value_from(self) -> pulumi.Input['KafkaConnectSpecExternalConfigurationEnvValueFromArgs']:
        """
        Value of the environment variable which will be passed to the Kafka Connect pods. It can be passed either as a reference to Secret or ConfigMap field. The field has to specify exactly one Secret or ConfigMap.
        """
        return pulumi.get(self, "value_from")

    @value_from.setter
    def value_from(self, value: pulumi.Input['KafkaConnectSpecExternalConfigurationEnvValueFromArgs']):
        pulumi.set(self, "value_from", value)


@pulumi.input_type
class KafkaConnectSpecExternalConfigurationEnvValueFromArgs:
    def __init__(__self__, *,
                 config_map_key_ref: Optional[pulumi.Input['KafkaConnectSpecExternalConfigurationEnvValueFromConfigMapKeyRefArgs']] = None,
                 secret_key_ref: Optional[pulumi.Input['KafkaConnectSpecExternalConfigurationEnvValueFromSecretKeyRefArgs']] = None):
        """
        Value of the environment variable which will be passed to the Kafka Connect pods. It can be passed either as a reference to Secret or ConfigMap field. The field has to specify exactly one Secret or ConfigMap.
        :param pulumi.Input['KafkaConnectSpecExternalConfigurationEnvValueFromConfigMapKeyRefArgs'] config_map_key_ref: Refernce to a key in a ConfigMap.
        :param pulumi.Input['KafkaConnectSpecExternalConfigurationEnvValueFromSecretKeyRefArgs'] secret_key_ref: Reference to a key in a Secret.
        """
        if config_map_key_ref is not None:
            pulumi.set(__self__, "config_map_key_ref", config_map_key_ref)
        if secret_key_ref is not None:
            pulumi.set(__self__, "secret_key_ref", secret_key_ref)

    @property
    @pulumi.getter(name="configMapKeyRef")
    def config_map_key_ref(self) -> Optional[pulumi.Input['KafkaConnectSpecExternalConfigurationEnvValueFromConfigMapKeyRefArgs']]:
        """
        Refernce to a key in a ConfigMap.
        """
        return pulumi.get(self, "config_map_key_ref")

    @config_map_key_ref.setter
    def config_map_key_ref(self, value: Optional[pulumi.Input['KafkaConnectSpecExternalConfigurationEnvValueFromConfigMapKeyRefArgs']]):
        pulumi.set(self, "config_map_key_ref", value)

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> Optional[pulumi.Input['KafkaConnectSpecExternalConfigurationEnvValueFromSecretKeyRefArgs']]:
        """
        Reference to a key in a Secret.
        """
        return pulumi.get(self, "secret_key_ref")

    @secret_key_ref.setter
    def secret_key_ref(self, value: Optional[pulumi.Input['KafkaConnectSpecExternalConfigurationEnvValueFromSecretKeyRefArgs']]):
        pulumi.set(self, "secret_key_ref", value)


@pulumi.input_type
class KafkaConnectSpecExternalConfigurationEnvValueFromConfigMapKeyRefArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 optional: Optional[pulumi.Input[bool]] = None):
        """
        Refernce to a key in a ConfigMap.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def optional(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "optional")

    @optional.setter
    def optional(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "optional", value)


@pulumi.input_type
class KafkaConnectSpecExternalConfigurationEnvValueFromSecretKeyRefArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 optional: Optional[pulumi.Input[bool]] = None):
        """
        Reference to a key in a Secret.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def optional(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "optional")

    @optional.setter
    def optional(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "optional", value)


@pulumi.input_type
class KafkaConnectSpecExternalConfigurationVolumesArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 config_map: Optional[pulumi.Input['KafkaConnectSpecExternalConfigurationVolumesConfigMapArgs']] = None,
                 secret: Optional[pulumi.Input['KafkaConnectSpecExternalConfigurationVolumesSecretArgs']] = None):
        """
        :param pulumi.Input[str] name: Name of the volume which will be added to the Kafka Connect pods.
        :param pulumi.Input['KafkaConnectSpecExternalConfigurationVolumesConfigMapArgs'] config_map: Reference to a key in a ConfigMap. Exactly one Secret or ConfigMap has to be specified.
        :param pulumi.Input['KafkaConnectSpecExternalConfigurationVolumesSecretArgs'] secret: Reference to a key in a Secret. Exactly one Secret or ConfigMap has to be specified.
        """
        pulumi.set(__self__, "name", name)
        if config_map is not None:
            pulumi.set(__self__, "config_map", config_map)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the volume which will be added to the Kafka Connect pods.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="configMap")
    def config_map(self) -> Optional[pulumi.Input['KafkaConnectSpecExternalConfigurationVolumesConfigMapArgs']]:
        """
        Reference to a key in a ConfigMap. Exactly one Secret or ConfigMap has to be specified.
        """
        return pulumi.get(self, "config_map")

    @config_map.setter
    def config_map(self, value: Optional[pulumi.Input['KafkaConnectSpecExternalConfigurationVolumesConfigMapArgs']]):
        pulumi.set(self, "config_map", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input['KafkaConnectSpecExternalConfigurationVolumesSecretArgs']]:
        """
        Reference to a key in a Secret. Exactly one Secret or ConfigMap has to be specified.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input['KafkaConnectSpecExternalConfigurationVolumesSecretArgs']]):
        pulumi.set(self, "secret", value)


@pulumi.input_type
class KafkaConnectSpecExternalConfigurationVolumesConfigMapArgs:
    def __init__(__self__, *,
                 default_mode: Optional[pulumi.Input[int]] = None,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecExternalConfigurationVolumesConfigMapItemsArgs']]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 optional: Optional[pulumi.Input[bool]] = None):
        """
        Reference to a key in a ConfigMap. Exactly one Secret or ConfigMap has to be specified.
        """
        if default_mode is not None:
            pulumi.set(__self__, "default_mode", default_mode)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter(name="defaultMode")
    def default_mode(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "default_mode")

    @default_mode.setter
    def default_mode(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "default_mode", value)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecExternalConfigurationVolumesConfigMapItemsArgs']]]]:
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecExternalConfigurationVolumesConfigMapItemsArgs']]]]):
        pulumi.set(self, "items", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def optional(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "optional")

    @optional.setter
    def optional(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "optional", value)


@pulumi.input_type
class KafkaConnectSpecExternalConfigurationVolumesConfigMapItemsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 mode: Optional[pulumi.Input[int]] = None,
                 path: Optional[pulumi.Input[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


@pulumi.input_type
class KafkaConnectSpecExternalConfigurationVolumesSecretArgs:
    def __init__(__self__, *,
                 default_mode: Optional[pulumi.Input[int]] = None,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecExternalConfigurationVolumesSecretItemsArgs']]]] = None,
                 optional: Optional[pulumi.Input[bool]] = None,
                 secret_name: Optional[pulumi.Input[str]] = None):
        """
        Reference to a key in a Secret. Exactly one Secret or ConfigMap has to be specified.
        """
        if default_mode is not None:
            pulumi.set(__self__, "default_mode", default_mode)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="defaultMode")
    def default_mode(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "default_mode")

    @default_mode.setter
    def default_mode(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "default_mode", value)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecExternalConfigurationVolumesSecretItemsArgs']]]]:
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecExternalConfigurationVolumesSecretItemsArgs']]]]):
        pulumi.set(self, "items", value)

    @property
    @pulumi.getter
    def optional(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "optional")

    @optional.setter
    def optional(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "optional", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KafkaConnectSpecExternalConfigurationVolumesSecretItemsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 mode: Optional[pulumi.Input[int]] = None,
                 path: Optional[pulumi.Input[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


@pulumi.input_type
class KafkaConnectSpecJvmOptionsArgs:
    def __init__(__self__, *,
                 __xx: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 __xms: Optional[pulumi.Input[str]] = None,
                 __xmx: Optional[pulumi.Input[str]] = None,
                 gc_logging_enabled: Optional[pulumi.Input[bool]] = None,
                 java_system_properties: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecJvmOptionsJavaSystemPropertiesArgs']]]] = None):
        """
        JVM Options for pods.
        :param pulumi.Input[Mapping[str, Any]] __xx: A map of -XX options to the JVM.
        :param pulumi.Input[str] __xms: -Xms option to to the JVM.
        :param pulumi.Input[str] __xmx: -Xmx option to to the JVM.
        :param pulumi.Input[bool] gc_logging_enabled: Specifies whether the Garbage Collection logging is enabled. The default is false.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecJvmOptionsJavaSystemPropertiesArgs']]] java_system_properties: A map of additional system properties which will be passed using the `-D` option to the JVM.
        """
        if __xx is not None:
            pulumi.set(__self__, "__xx", __xx)
        if __xms is not None:
            pulumi.set(__self__, "__xms", __xms)
        if __xmx is not None:
            pulumi.set(__self__, "__xmx", __xmx)
        if gc_logging_enabled is not None:
            pulumi.set(__self__, "gc_logging_enabled", gc_logging_enabled)
        if java_system_properties is not None:
            pulumi.set(__self__, "java_system_properties", java_system_properties)

    @property
    @pulumi.getter(name="-XX")
    def __xx(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        A map of -XX options to the JVM.
        """
        return pulumi.get(self, "__xx")

    @__xx.setter
    def __xx(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "__xx", value)

    @property
    @pulumi.getter(name="-Xms")
    def __xms(self) -> Optional[pulumi.Input[str]]:
        """
        -Xms option to to the JVM.
        """
        return pulumi.get(self, "__xms")

    @__xms.setter
    def __xms(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "__xms", value)

    @property
    @pulumi.getter(name="-Xmx")
    def __xmx(self) -> Optional[pulumi.Input[str]]:
        """
        -Xmx option to to the JVM.
        """
        return pulumi.get(self, "__xmx")

    @__xmx.setter
    def __xmx(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "__xmx", value)

    @property
    @pulumi.getter(name="gcLoggingEnabled")
    def gc_logging_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether the Garbage Collection logging is enabled. The default is false.
        """
        return pulumi.get(self, "gc_logging_enabled")

    @gc_logging_enabled.setter
    def gc_logging_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "gc_logging_enabled", value)

    @property
    @pulumi.getter(name="javaSystemProperties")
    def java_system_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecJvmOptionsJavaSystemPropertiesArgs']]]]:
        """
        A map of additional system properties which will be passed using the `-D` option to the JVM.
        """
        return pulumi.get(self, "java_system_properties")

    @java_system_properties.setter
    def java_system_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecJvmOptionsJavaSystemPropertiesArgs']]]]):
        pulumi.set(self, "java_system_properties", value)


@pulumi.input_type
class KafkaConnectSpecJvmOptionsJavaSystemPropertiesArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The system property name.
        :param pulumi.Input[str] value: The system property value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The system property name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The system property value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaConnectSpecLivenessProbeArgs:
    def __init__(__self__, *,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 success_threshold: Optional[pulumi.Input[int]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        Pod liveness checking.
        :param pulumi.Input[int] failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param pulumi.Input[int] initial_delay_seconds: The initial delay before first the health is first checked.
        :param pulumi.Input[int] period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param pulumi.Input[int] success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param pulumi.Input[int] timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "success_threshold", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


@pulumi.input_type
class KafkaConnectSpecLoggingArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 loggers: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        Logging configuration for Kafka Connect.
        :param pulumi.Input[str] type: Logging type, must be either 'inline' or 'external'.
        :param pulumi.Input[Mapping[str, Any]] loggers: A Map from logger name to logger level.
        :param pulumi.Input[str] name: The name of the `ConfigMap` from which to get the logging configuration.
        """
        pulumi.set(__self__, "type", type)
        if loggers is not None:
            pulumi.set(__self__, "loggers", loggers)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Logging type, must be either 'inline' or 'external'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def loggers(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        A Map from logger name to logger level.
        """
        return pulumi.get(self, "loggers")

    @loggers.setter
    def loggers(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "loggers", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the `ConfigMap` from which to get the logging configuration.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class KafkaConnectSpecRackArgs:
    def __init__(__self__, *,
                 topology_key: pulumi.Input[str]):
        """
        Configuration of the node label which will be used as the client.rack consumer configuration.
        :param pulumi.Input[str] topology_key: A key that matches labels assigned to the Kubernetes cluster nodes. The value of the label is used to set the broker's `broker.rack` config.
        """
        pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> pulumi.Input[str]:
        """
        A key that matches labels assigned to the Kubernetes cluster nodes. The value of the label is used to set the broker's `broker.rack` config.
        """
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaConnectSpecReadinessProbeArgs:
    def __init__(__self__, *,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 success_threshold: Optional[pulumi.Input[int]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        Pod readiness checking.
        :param pulumi.Input[int] failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param pulumi.Input[int] initial_delay_seconds: The initial delay before first the health is first checked.
        :param pulumi.Input[int] period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param pulumi.Input[int] success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param pulumi.Input[int] timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "success_threshold", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


@pulumi.input_type
class KafkaConnectSpecResourcesArgs:
    def __init__(__self__, *,
                 limits: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 requests: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        The maximum limits for CPU and memory resources and the requested initial resources.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "limits", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "requests", value)


@pulumi.input_type
class KafkaConnectSpecTemplateArgs:
    def __init__(__self__, *,
                 api_service: Optional[pulumi.Input['KafkaConnectSpecTemplateApiServiceArgs']] = None,
                 connect_container: Optional[pulumi.Input['KafkaConnectSpecTemplateConnectContainerArgs']] = None,
                 deployment: Optional[pulumi.Input['KafkaConnectSpecTemplateDeploymentArgs']] = None,
                 init_container: Optional[pulumi.Input['KafkaConnectSpecTemplateInitContainerArgs']] = None,
                 pod: Optional[pulumi.Input['KafkaConnectSpecTemplatePodArgs']] = None,
                 pod_disruption_budget: Optional[pulumi.Input['KafkaConnectSpecTemplatePodDisruptionBudgetArgs']] = None):
        """
        Template for Kafka Connect and Kafka Connect S2I resources. The template allows users to specify how the `Deployment`, `Pods` and `Service` are generated.
        :param pulumi.Input['KafkaConnectSpecTemplateApiServiceArgs'] api_service: Template for Kafka Connect API `Service`.
        :param pulumi.Input['KafkaConnectSpecTemplateConnectContainerArgs'] connect_container: Template for the Kafka Connect container.
        :param pulumi.Input['KafkaConnectSpecTemplateDeploymentArgs'] deployment: Template for Kafka Connect `Deployment`.
        :param pulumi.Input['KafkaConnectSpecTemplateInitContainerArgs'] init_container: Template for the Kafka init container.
        :param pulumi.Input['KafkaConnectSpecTemplatePodArgs'] pod: Template for Kafka Connect `Pods`.
        :param pulumi.Input['KafkaConnectSpecTemplatePodDisruptionBudgetArgs'] pod_disruption_budget: Template for Kafka Connect `PodDisruptionBudget`.
        """
        if api_service is not None:
            pulumi.set(__self__, "api_service", api_service)
        if connect_container is not None:
            pulumi.set(__self__, "connect_container", connect_container)
        if deployment is not None:
            pulumi.set(__self__, "deployment", deployment)
        if init_container is not None:
            pulumi.set(__self__, "init_container", init_container)
        if pod is not None:
            pulumi.set(__self__, "pod", pod)
        if pod_disruption_budget is not None:
            pulumi.set(__self__, "pod_disruption_budget", pod_disruption_budget)

    @property
    @pulumi.getter(name="apiService")
    def api_service(self) -> Optional[pulumi.Input['KafkaConnectSpecTemplateApiServiceArgs']]:
        """
        Template for Kafka Connect API `Service`.
        """
        return pulumi.get(self, "api_service")

    @api_service.setter
    def api_service(self, value: Optional[pulumi.Input['KafkaConnectSpecTemplateApiServiceArgs']]):
        pulumi.set(self, "api_service", value)

    @property
    @pulumi.getter(name="connectContainer")
    def connect_container(self) -> Optional[pulumi.Input['KafkaConnectSpecTemplateConnectContainerArgs']]:
        """
        Template for the Kafka Connect container.
        """
        return pulumi.get(self, "connect_container")

    @connect_container.setter
    def connect_container(self, value: Optional[pulumi.Input['KafkaConnectSpecTemplateConnectContainerArgs']]):
        pulumi.set(self, "connect_container", value)

    @property
    @pulumi.getter
    def deployment(self) -> Optional[pulumi.Input['KafkaConnectSpecTemplateDeploymentArgs']]:
        """
        Template for Kafka Connect `Deployment`.
        """
        return pulumi.get(self, "deployment")

    @deployment.setter
    def deployment(self, value: Optional[pulumi.Input['KafkaConnectSpecTemplateDeploymentArgs']]):
        pulumi.set(self, "deployment", value)

    @property
    @pulumi.getter(name="initContainer")
    def init_container(self) -> Optional[pulumi.Input['KafkaConnectSpecTemplateInitContainerArgs']]:
        """
        Template for the Kafka init container.
        """
        return pulumi.get(self, "init_container")

    @init_container.setter
    def init_container(self, value: Optional[pulumi.Input['KafkaConnectSpecTemplateInitContainerArgs']]):
        pulumi.set(self, "init_container", value)

    @property
    @pulumi.getter
    def pod(self) -> Optional[pulumi.Input['KafkaConnectSpecTemplatePodArgs']]:
        """
        Template for Kafka Connect `Pods`.
        """
        return pulumi.get(self, "pod")

    @pod.setter
    def pod(self, value: Optional[pulumi.Input['KafkaConnectSpecTemplatePodArgs']]):
        pulumi.set(self, "pod", value)

    @property
    @pulumi.getter(name="podDisruptionBudget")
    def pod_disruption_budget(self) -> Optional[pulumi.Input['KafkaConnectSpecTemplatePodDisruptionBudgetArgs']]:
        """
        Template for Kafka Connect `PodDisruptionBudget`.
        """
        return pulumi.get(self, "pod_disruption_budget")

    @pod_disruption_budget.setter
    def pod_disruption_budget(self, value: Optional[pulumi.Input['KafkaConnectSpecTemplatePodDisruptionBudgetArgs']]):
        pulumi.set(self, "pod_disruption_budget", value)


@pulumi.input_type
class KafkaConnectSpecTemplateApiServiceArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input['KafkaConnectSpecTemplateApiServiceMetadataArgs']] = None):
        """
        Template for Kafka Connect API `Service`.
        :param pulumi.Input['KafkaConnectSpecTemplateApiServiceMetadataArgs'] metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['KafkaConnectSpecTemplateApiServiceMetadataArgs']]:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['KafkaConnectSpecTemplateApiServiceMetadataArgs']]):
        pulumi.set(self, "metadata", value)


@pulumi.input_type
class KafkaConnectSpecTemplateApiServiceMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Metadata applied to the resource.
        :param pulumi.Input[Mapping[str, Any]] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param pulumi.Input[Mapping[str, Any]] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class KafkaConnectSpecTemplateConnectContainerArgs:
    def __init__(__self__, *,
                 env: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplateConnectContainerEnvArgs']]]] = None,
                 security_context: Optional[pulumi.Input['KafkaConnectSpecTemplateConnectContainerSecurityContextArgs']] = None):
        """
        Template for the Kafka Connect container.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplateConnectContainerEnvArgs']]] env: Environment variables which should be applied to the container.
        :param pulumi.Input['KafkaConnectSpecTemplateConnectContainerSecurityContextArgs'] security_context: Security context for the container.
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)

    @property
    @pulumi.getter
    def env(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplateConnectContainerEnvArgs']]]]:
        """
        Environment variables which should be applied to the container.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplateConnectContainerEnvArgs']]]]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional[pulumi.Input['KafkaConnectSpecTemplateConnectContainerSecurityContextArgs']]:
        """
        Security context for the container.
        """
        return pulumi.get(self, "security_context")

    @security_context.setter
    def security_context(self, value: Optional[pulumi.Input['KafkaConnectSpecTemplateConnectContainerSecurityContextArgs']]):
        pulumi.set(self, "security_context", value)


@pulumi.input_type
class KafkaConnectSpecTemplateConnectContainerEnvArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The environment variable key.
        :param pulumi.Input[str] value: The environment variable value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The environment variable key.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The environment variable value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaConnectSpecTemplateConnectContainerSecurityContextArgs:
    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[pulumi.Input[bool]] = None,
                 capabilities: Optional[pulumi.Input['KafkaConnectSpecTemplateConnectContainerSecurityContextCapabilitiesArgs']] = None,
                 privileged: Optional[pulumi.Input[bool]] = None,
                 proc_mount: Optional[pulumi.Input[str]] = None,
                 read_only_root_filesystem: Optional[pulumi.Input[bool]] = None,
                 run_as_group: Optional[pulumi.Input[int]] = None,
                 run_as_non_root: Optional[pulumi.Input[bool]] = None,
                 run_as_user: Optional[pulumi.Input[int]] = None,
                 se_linux_options: Optional[pulumi.Input['KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptionsArgs']] = None,
                 windows_options: Optional[pulumi.Input['KafkaConnectSpecTemplateConnectContainerSecurityContextWindowsOptionsArgs']] = None):
        """
        Security context for the container.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if proc_mount is not None:
            pulumi.set(__self__, "proc_mount", proc_mount)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "allow_privilege_escalation")

    @allow_privilege_escalation.setter
    def allow_privilege_escalation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_privilege_escalation", value)

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[pulumi.Input['KafkaConnectSpecTemplateConnectContainerSecurityContextCapabilitiesArgs']]:
        return pulumi.get(self, "capabilities")

    @capabilities.setter
    def capabilities(self, value: Optional[pulumi.Input['KafkaConnectSpecTemplateConnectContainerSecurityContextCapabilitiesArgs']]):
        pulumi.set(self, "capabilities", value)

    @property
    @pulumi.getter
    def privileged(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "privileged")

    @privileged.setter
    def privileged(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "privileged", value)

    @property
    @pulumi.getter(name="procMount")
    def proc_mount(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "proc_mount")

    @proc_mount.setter
    def proc_mount(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proc_mount", value)

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "read_only_root_filesystem")

    @read_only_root_filesystem.setter
    def read_only_root_filesystem(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "read_only_root_filesystem", value)

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_group")

    @run_as_group.setter
    def run_as_group(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_group", value)

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "run_as_non_root")

    @run_as_non_root.setter
    def run_as_non_root(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_as_non_root", value)

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_user")

    @run_as_user.setter
    def run_as_user(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_user", value)

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional[pulumi.Input['KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptionsArgs']]:
        return pulumi.get(self, "se_linux_options")

    @se_linux_options.setter
    def se_linux_options(self, value: Optional[pulumi.Input['KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptionsArgs']]):
        pulumi.set(self, "se_linux_options", value)

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional[pulumi.Input['KafkaConnectSpecTemplateConnectContainerSecurityContextWindowsOptionsArgs']]:
        return pulumi.get(self, "windows_options")

    @windows_options.setter
    def windows_options(self, value: Optional[pulumi.Input['KafkaConnectSpecTemplateConnectContainerSecurityContextWindowsOptionsArgs']]):
        pulumi.set(self, "windows_options", value)


@pulumi.input_type
class KafkaConnectSpecTemplateConnectContainerSecurityContextCapabilitiesArgs:
    def __init__(__self__, *,
                 add: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 drop: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)

    @property
    @pulumi.getter
    def add(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "add")

    @add.setter
    def add(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "add", value)

    @property
    @pulumi.getter
    def drop(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "drop")

    @drop.setter
    def drop(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "drop", value)


@pulumi.input_type
class KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptionsArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


@pulumi.input_type
class KafkaConnectSpecTemplateConnectContainerSecurityContextWindowsOptionsArgs:
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[pulumi.Input[str]] = None,
                 gmsa_credential_spec_name: Optional[pulumi.Input[str]] = None,
                 run_as_user_name: Optional[pulumi.Input[str]] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec")

    @gmsa_credential_spec.setter
    def gmsa_credential_spec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec", value)

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @gmsa_credential_spec_name.setter
    def gmsa_credential_spec_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec_name", value)

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "run_as_user_name")

    @run_as_user_name.setter
    def run_as_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "run_as_user_name", value)


@pulumi.input_type
class KafkaConnectSpecTemplateDeploymentArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input['KafkaConnectSpecTemplateDeploymentMetadataArgs']] = None):
        """
        Template for Kafka Connect `Deployment`.
        :param pulumi.Input['KafkaConnectSpecTemplateDeploymentMetadataArgs'] metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['KafkaConnectSpecTemplateDeploymentMetadataArgs']]:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['KafkaConnectSpecTemplateDeploymentMetadataArgs']]):
        pulumi.set(self, "metadata", value)


@pulumi.input_type
class KafkaConnectSpecTemplateDeploymentMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Metadata applied to the resource.
        :param pulumi.Input[Mapping[str, Any]] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param pulumi.Input[Mapping[str, Any]] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class KafkaConnectSpecTemplateInitContainerArgs:
    def __init__(__self__, *,
                 env: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplateInitContainerEnvArgs']]]] = None,
                 security_context: Optional[pulumi.Input['KafkaConnectSpecTemplateInitContainerSecurityContextArgs']] = None):
        """
        Template for the Kafka init container.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplateInitContainerEnvArgs']]] env: Environment variables which should be applied to the container.
        :param pulumi.Input['KafkaConnectSpecTemplateInitContainerSecurityContextArgs'] security_context: Security context for the container.
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)

    @property
    @pulumi.getter
    def env(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplateInitContainerEnvArgs']]]]:
        """
        Environment variables which should be applied to the container.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplateInitContainerEnvArgs']]]]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional[pulumi.Input['KafkaConnectSpecTemplateInitContainerSecurityContextArgs']]:
        """
        Security context for the container.
        """
        return pulumi.get(self, "security_context")

    @security_context.setter
    def security_context(self, value: Optional[pulumi.Input['KafkaConnectSpecTemplateInitContainerSecurityContextArgs']]):
        pulumi.set(self, "security_context", value)


@pulumi.input_type
class KafkaConnectSpecTemplateInitContainerEnvArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The environment variable key.
        :param pulumi.Input[str] value: The environment variable value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The environment variable key.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The environment variable value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaConnectSpecTemplateInitContainerSecurityContextArgs:
    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[pulumi.Input[bool]] = None,
                 capabilities: Optional[pulumi.Input['KafkaConnectSpecTemplateInitContainerSecurityContextCapabilitiesArgs']] = None,
                 privileged: Optional[pulumi.Input[bool]] = None,
                 proc_mount: Optional[pulumi.Input[str]] = None,
                 read_only_root_filesystem: Optional[pulumi.Input[bool]] = None,
                 run_as_group: Optional[pulumi.Input[int]] = None,
                 run_as_non_root: Optional[pulumi.Input[bool]] = None,
                 run_as_user: Optional[pulumi.Input[int]] = None,
                 se_linux_options: Optional[pulumi.Input['KafkaConnectSpecTemplateInitContainerSecurityContextSeLinuxOptionsArgs']] = None,
                 windows_options: Optional[pulumi.Input['KafkaConnectSpecTemplateInitContainerSecurityContextWindowsOptionsArgs']] = None):
        """
        Security context for the container.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if proc_mount is not None:
            pulumi.set(__self__, "proc_mount", proc_mount)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "allow_privilege_escalation")

    @allow_privilege_escalation.setter
    def allow_privilege_escalation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_privilege_escalation", value)

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[pulumi.Input['KafkaConnectSpecTemplateInitContainerSecurityContextCapabilitiesArgs']]:
        return pulumi.get(self, "capabilities")

    @capabilities.setter
    def capabilities(self, value: Optional[pulumi.Input['KafkaConnectSpecTemplateInitContainerSecurityContextCapabilitiesArgs']]):
        pulumi.set(self, "capabilities", value)

    @property
    @pulumi.getter
    def privileged(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "privileged")

    @privileged.setter
    def privileged(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "privileged", value)

    @property
    @pulumi.getter(name="procMount")
    def proc_mount(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "proc_mount")

    @proc_mount.setter
    def proc_mount(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proc_mount", value)

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "read_only_root_filesystem")

    @read_only_root_filesystem.setter
    def read_only_root_filesystem(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "read_only_root_filesystem", value)

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_group")

    @run_as_group.setter
    def run_as_group(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_group", value)

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "run_as_non_root")

    @run_as_non_root.setter
    def run_as_non_root(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_as_non_root", value)

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_user")

    @run_as_user.setter
    def run_as_user(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_user", value)

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional[pulumi.Input['KafkaConnectSpecTemplateInitContainerSecurityContextSeLinuxOptionsArgs']]:
        return pulumi.get(self, "se_linux_options")

    @se_linux_options.setter
    def se_linux_options(self, value: Optional[pulumi.Input['KafkaConnectSpecTemplateInitContainerSecurityContextSeLinuxOptionsArgs']]):
        pulumi.set(self, "se_linux_options", value)

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional[pulumi.Input['KafkaConnectSpecTemplateInitContainerSecurityContextWindowsOptionsArgs']]:
        return pulumi.get(self, "windows_options")

    @windows_options.setter
    def windows_options(self, value: Optional[pulumi.Input['KafkaConnectSpecTemplateInitContainerSecurityContextWindowsOptionsArgs']]):
        pulumi.set(self, "windows_options", value)


@pulumi.input_type
class KafkaConnectSpecTemplateInitContainerSecurityContextCapabilitiesArgs:
    def __init__(__self__, *,
                 add: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 drop: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)

    @property
    @pulumi.getter
    def add(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "add")

    @add.setter
    def add(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "add", value)

    @property
    @pulumi.getter
    def drop(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "drop")

    @drop.setter
    def drop(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "drop", value)


@pulumi.input_type
class KafkaConnectSpecTemplateInitContainerSecurityContextSeLinuxOptionsArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


@pulumi.input_type
class KafkaConnectSpecTemplateInitContainerSecurityContextWindowsOptionsArgs:
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[pulumi.Input[str]] = None,
                 gmsa_credential_spec_name: Optional[pulumi.Input[str]] = None,
                 run_as_user_name: Optional[pulumi.Input[str]] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec")

    @gmsa_credential_spec.setter
    def gmsa_credential_spec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec", value)

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @gmsa_credential_spec_name.setter
    def gmsa_credential_spec_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec_name", value)

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "run_as_user_name")

    @run_as_user_name.setter
    def run_as_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "run_as_user_name", value)


@pulumi.input_type
class KafkaConnectSpecTemplatePodArgs:
    def __init__(__self__, *,
                 affinity: Optional[pulumi.Input['KafkaConnectSpecTemplatePodAffinityArgs']] = None,
                 host_aliases: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodHostAliasesArgs']]]] = None,
                 image_pull_secrets: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodImagePullSecretsArgs']]]] = None,
                 metadata: Optional[pulumi.Input['KafkaConnectSpecTemplatePodMetadataArgs']] = None,
                 priority_class_name: Optional[pulumi.Input[str]] = None,
                 scheduler_name: Optional[pulumi.Input[str]] = None,
                 security_context: Optional[pulumi.Input['KafkaConnectSpecTemplatePodSecurityContextArgs']] = None,
                 termination_grace_period_seconds: Optional[pulumi.Input[int]] = None,
                 tolerations: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodTolerationsArgs']]]] = None):
        """
        Template for Kafka Connect `Pods`.
        :param pulumi.Input['KafkaConnectSpecTemplatePodAffinityArgs'] affinity: The pod's affinity rules.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodHostAliasesArgs']]] host_aliases: The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodImagePullSecretsArgs']]] image_pull_secrets: List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
        :param pulumi.Input['KafkaConnectSpecTemplatePodMetadataArgs'] metadata: Metadata applied to the resource.
        :param pulumi.Input[str] priority_class_name: The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
        :param pulumi.Input[str] scheduler_name: The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
        :param pulumi.Input['KafkaConnectSpecTemplatePodSecurityContextArgs'] security_context: Configures pod-level security attributes and common container settings.
        :param pulumi.Input[int] termination_grace_period_seconds: The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodTolerationsArgs']]] tolerations: The pod's tolerations.
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if host_aliases is not None:
            pulumi.set(__self__, "host_aliases", host_aliases)
        if image_pull_secrets is not None:
            pulumi.set(__self__, "image_pull_secrets", image_pull_secrets)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if priority_class_name is not None:
            pulumi.set(__self__, "priority_class_name", priority_class_name)
        if scheduler_name is not None:
            pulumi.set(__self__, "scheduler_name", scheduler_name)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)

    @property
    @pulumi.getter
    def affinity(self) -> Optional[pulumi.Input['KafkaConnectSpecTemplatePodAffinityArgs']]:
        """
        The pod's affinity rules.
        """
        return pulumi.get(self, "affinity")

    @affinity.setter
    def affinity(self, value: Optional[pulumi.Input['KafkaConnectSpecTemplatePodAffinityArgs']]):
        pulumi.set(self, "affinity", value)

    @property
    @pulumi.getter(name="hostAliases")
    def host_aliases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodHostAliasesArgs']]]]:
        """
        The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
        """
        return pulumi.get(self, "host_aliases")

    @host_aliases.setter
    def host_aliases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodHostAliasesArgs']]]]):
        pulumi.set(self, "host_aliases", value)

    @property
    @pulumi.getter(name="imagePullSecrets")
    def image_pull_secrets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodImagePullSecretsArgs']]]]:
        """
        List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
        """
        return pulumi.get(self, "image_pull_secrets")

    @image_pull_secrets.setter
    def image_pull_secrets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodImagePullSecretsArgs']]]]):
        pulumi.set(self, "image_pull_secrets", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['KafkaConnectSpecTemplatePodMetadataArgs']]:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['KafkaConnectSpecTemplatePodMetadataArgs']]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter(name="priorityClassName")
    def priority_class_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
        """
        return pulumi.get(self, "priority_class_name")

    @priority_class_name.setter
    def priority_class_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "priority_class_name", value)

    @property
    @pulumi.getter(name="schedulerName")
    def scheduler_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
        """
        return pulumi.get(self, "scheduler_name")

    @scheduler_name.setter
    def scheduler_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scheduler_name", value)

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional[pulumi.Input['KafkaConnectSpecTemplatePodSecurityContextArgs']]:
        """
        Configures pod-level security attributes and common container settings.
        """
        return pulumi.get(self, "security_context")

    @security_context.setter
    def security_context(self, value: Optional[pulumi.Input['KafkaConnectSpecTemplatePodSecurityContextArgs']]):
        pulumi.set(self, "security_context", value)

    @property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
        """
        return pulumi.get(self, "termination_grace_period_seconds")

    @termination_grace_period_seconds.setter
    def termination_grace_period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "termination_grace_period_seconds", value)

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodTolerationsArgs']]]]:
        """
        The pod's tolerations.
        """
        return pulumi.get(self, "tolerations")

    @tolerations.setter
    def tolerations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodTolerationsArgs']]]]):
        pulumi.set(self, "tolerations", value)


@pulumi.input_type
class KafkaConnectSpecTemplatePodAffinityArgs:
    def __init__(__self__, *,
                 node_affinity: Optional[pulumi.Input['KafkaConnectSpecTemplatePodAffinityNodeAffinityArgs']] = None,
                 pod_affinity: Optional[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAffinityArgs']] = None,
                 pod_anti_affinity: Optional[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAntiAffinityArgs']] = None):
        """
        The pod's affinity rules.
        """
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional[pulumi.Input['KafkaConnectSpecTemplatePodAffinityNodeAffinityArgs']]:
        return pulumi.get(self, "node_affinity")

    @node_affinity.setter
    def node_affinity(self, value: Optional[pulumi.Input['KafkaConnectSpecTemplatePodAffinityNodeAffinityArgs']]):
        pulumi.set(self, "node_affinity", value)

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAffinityArgs']]:
        return pulumi.get(self, "pod_affinity")

    @pod_affinity.setter
    def pod_affinity(self, value: Optional[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAffinityArgs']]):
        pulumi.set(self, "pod_affinity", value)

    @property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAntiAffinityArgs']]:
        return pulumi.get(self, "pod_anti_affinity")

    @pod_anti_affinity.setter
    def pod_anti_affinity(self, value: Optional[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAntiAffinityArgs']]):
        pulumi.set(self, "pod_anti_affinity", value)


@pulumi.input_type
class KafkaConnectSpecTemplatePodAffinityNodeAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input['KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input['KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input['KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 preference: Optional[pulumi.Input['KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input['KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']]:
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input['KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]] = None,
                 match_fields: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]]:
        return pulumi.get(self, "match_fields")

    @match_fields.setter
    def match_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]]):
        pulumi.set(self, "match_fields", value)


@pulumi.input_type
class KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 node_selector_terms: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]] = None):
        if node_selector_terms is not None:
            pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]]:
        return pulumi.get(self, "node_selector_terms")

    @node_selector_terms.setter
    def node_selector_terms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]]):
        pulumi.set(self, "node_selector_terms", value)


@pulumi.input_type
class KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]] = None,
                 match_fields: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]]:
        return pulumi.get(self, "match_fields")

    @match_fields.setter
    def match_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]]):
        pulumi.set(self, "match_fields", value)


@pulumi.input_type
class KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaConnectSpecTemplatePodAffinityPodAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 pod_affinity_term: Optional[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]:
        return pulumi.get(self, "pod_affinity_term")

    @pod_affinity_term.setter
    def pod_affinity_term(self, value: Optional[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]):
        pulumi.set(self, "pod_affinity_term", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaConnectSpecTemplatePodAffinityPodAntiAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 pod_affinity_term: Optional[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]:
        return pulumi.get(self, "pod_affinity_term")

    @pod_affinity_term.setter
    def pod_affinity_term(self, value: Optional[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]):
        pulumi.set(self, "pod_affinity_term", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaConnectSpecTemplatePodDisruptionBudgetArgs:
    def __init__(__self__, *,
                 max_unavailable: Optional[pulumi.Input[int]] = None,
                 metadata: Optional[pulumi.Input['KafkaConnectSpecTemplatePodDisruptionBudgetMetadataArgs']] = None):
        """
        Template for Kafka Connect `PodDisruptionBudget`.
        :param pulumi.Input[int] max_unavailable: Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
        :param pulumi.Input['KafkaConnectSpecTemplatePodDisruptionBudgetMetadataArgs'] metadata: Metadata to apply to the `PodDistruptionBugetTemplate` resource.
        """
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
        """
        return pulumi.get(self, "max_unavailable")

    @max_unavailable.setter
    def max_unavailable(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_unavailable", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['KafkaConnectSpecTemplatePodDisruptionBudgetMetadataArgs']]:
        """
        Metadata to apply to the `PodDistruptionBugetTemplate` resource.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['KafkaConnectSpecTemplatePodDisruptionBudgetMetadataArgs']]):
        pulumi.set(self, "metadata", value)


@pulumi.input_type
class KafkaConnectSpecTemplatePodDisruptionBudgetMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Metadata to apply to the `PodDistruptionBugetTemplate` resource.
        :param pulumi.Input[Mapping[str, Any]] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param pulumi.Input[Mapping[str, Any]] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class KafkaConnectSpecTemplatePodHostAliasesArgs:
    def __init__(__self__, *,
                 hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ip: Optional[pulumi.Input[str]] = None):
        if hostnames is not None:
            pulumi.set(__self__, "hostnames", hostnames)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def hostnames(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "hostnames")

    @hostnames.setter
    def hostnames(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hostnames", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)


@pulumi.input_type
class KafkaConnectSpecTemplatePodImagePullSecretsArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class KafkaConnectSpecTemplatePodMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Metadata applied to the resource.
        :param pulumi.Input[Mapping[str, Any]] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param pulumi.Input[Mapping[str, Any]] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class KafkaConnectSpecTemplatePodSecurityContextArgs:
    def __init__(__self__, *,
                 fs_group: Optional[pulumi.Input[int]] = None,
                 fs_group_change_policy: Optional[pulumi.Input[str]] = None,
                 run_as_group: Optional[pulumi.Input[int]] = None,
                 run_as_non_root: Optional[pulumi.Input[bool]] = None,
                 run_as_user: Optional[pulumi.Input[int]] = None,
                 se_linux_options: Optional[pulumi.Input['KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptionsArgs']] = None,
                 supplemental_groups: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 sysctls: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodSecurityContextSysctlsArgs']]]] = None,
                 windows_options: Optional[pulumi.Input['KafkaConnectSpecTemplatePodSecurityContextWindowsOptionsArgs']] = None):
        """
        Configures pod-level security attributes and common container settings.
        """
        if fs_group is not None:
            pulumi.set(__self__, "fs_group", fs_group)
        if fs_group_change_policy is not None:
            pulumi.set(__self__, "fs_group_change_policy", fs_group_change_policy)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if supplemental_groups is not None:
            pulumi.set(__self__, "supplemental_groups", supplemental_groups)
        if sysctls is not None:
            pulumi.set(__self__, "sysctls", sysctls)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="fsGroup")
    def fs_group(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "fs_group")

    @fs_group.setter
    def fs_group(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "fs_group", value)

    @property
    @pulumi.getter(name="fsGroupChangePolicy")
    def fs_group_change_policy(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "fs_group_change_policy")

    @fs_group_change_policy.setter
    def fs_group_change_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fs_group_change_policy", value)

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_group")

    @run_as_group.setter
    def run_as_group(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_group", value)

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "run_as_non_root")

    @run_as_non_root.setter
    def run_as_non_root(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_as_non_root", value)

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_user")

    @run_as_user.setter
    def run_as_user(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_user", value)

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional[pulumi.Input['KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptionsArgs']]:
        return pulumi.get(self, "se_linux_options")

    @se_linux_options.setter
    def se_linux_options(self, value: Optional[pulumi.Input['KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptionsArgs']]):
        pulumi.set(self, "se_linux_options", value)

    @property
    @pulumi.getter(name="supplementalGroups")
    def supplemental_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        return pulumi.get(self, "supplemental_groups")

    @supplemental_groups.setter
    def supplemental_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "supplemental_groups", value)

    @property
    @pulumi.getter
    def sysctls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodSecurityContextSysctlsArgs']]]]:
        return pulumi.get(self, "sysctls")

    @sysctls.setter
    def sysctls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTemplatePodSecurityContextSysctlsArgs']]]]):
        pulumi.set(self, "sysctls", value)

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional[pulumi.Input['KafkaConnectSpecTemplatePodSecurityContextWindowsOptionsArgs']]:
        return pulumi.get(self, "windows_options")

    @windows_options.setter
    def windows_options(self, value: Optional[pulumi.Input['KafkaConnectSpecTemplatePodSecurityContextWindowsOptionsArgs']]):
        pulumi.set(self, "windows_options", value)


@pulumi.input_type
class KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptionsArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


@pulumi.input_type
class KafkaConnectSpecTemplatePodSecurityContextSysctlsArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaConnectSpecTemplatePodSecurityContextWindowsOptionsArgs:
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[pulumi.Input[str]] = None,
                 gmsa_credential_spec_name: Optional[pulumi.Input[str]] = None,
                 run_as_user_name: Optional[pulumi.Input[str]] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec")

    @gmsa_credential_spec.setter
    def gmsa_credential_spec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec", value)

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @gmsa_credential_spec_name.setter
    def gmsa_credential_spec_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec_name", value)

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "run_as_user_name")

    @run_as_user_name.setter
    def run_as_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "run_as_user_name", value)


@pulumi.input_type
class KafkaConnectSpecTemplatePodTolerationsArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 toleration_seconds: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if toleration_seconds is not None:
            pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "toleration_seconds")

    @toleration_seconds.setter
    def toleration_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "toleration_seconds", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaConnectSpecTlsArgs:
    def __init__(__self__, *,
                 trusted_certificates: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTlsTrustedCertificatesArgs']]]] = None):
        """
        TLS configuration.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTlsTrustedCertificatesArgs']]] trusted_certificates: Trusted certificates for TLS connection.
        """
        if trusted_certificates is not None:
            pulumi.set(__self__, "trusted_certificates", trusted_certificates)

    @property
    @pulumi.getter(name="trustedCertificates")
    def trusted_certificates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTlsTrustedCertificatesArgs']]]]:
        """
        Trusted certificates for TLS connection.
        """
        return pulumi.get(self, "trusted_certificates")

    @trusted_certificates.setter
    def trusted_certificates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectSpecTlsTrustedCertificatesArgs']]]]):
        pulumi.set(self, "trusted_certificates", value)


@pulumi.input_type
class KafkaConnectSpecTlsTrustedCertificatesArgs:
    def __init__(__self__, *,
                 certificate: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] certificate: The name of the file certificate in the Secret.
        :param pulumi.Input[str] secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> pulumi.Input[str]:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KafkaConnectSpecTolerationsArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 toleration_seconds: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if toleration_seconds is not None:
            pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "toleration_seconds")

    @toleration_seconds.setter
    def toleration_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "toleration_seconds", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaConnectSpecTracingArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str]):
        """
        The configuration of tracing in Kafka Connect.
        :param pulumi.Input[str] type: Type of the tracing used. Currently the only supported type is `jaeger` for Jaeger tracing.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the tracing used. Currently the only supported type is `jaeger` for Jaeger tracing.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class KafkaConnectStatusArgs:
    def __init__(__self__, *,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectStatusConditionsArgs']]]] = None,
                 connector_plugins: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectStatusConnectorPluginsArgs']]]] = None,
                 label_selector: Optional[pulumi.Input[str]] = None,
                 observed_generation: Optional[pulumi.Input[int]] = None,
                 replicas: Optional[pulumi.Input[int]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        The status of the Kafka Connect cluster.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaConnectStatusConditionsArgs']]] conditions: List of status conditions.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaConnectStatusConnectorPluginsArgs']]] connector_plugins: The list of connector plugins available in this Kafka Connect deployment.
        :param pulumi.Input[str] label_selector: Label selector for pods providing this resource.
        :param pulumi.Input[int] observed_generation: The generation of the CRD that was last reconciled by the operator.
        :param pulumi.Input[int] replicas: The current number of pods being used to provide this resource.
        :param pulumi.Input[str] url: The URL of the REST API endpoint for managing and monitoring Kafka Connect connectors.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if connector_plugins is not None:
            pulumi.set(__self__, "connector_plugins", connector_plugins)
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectStatusConditionsArgs']]]]:
        """
        List of status conditions.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectStatusConditionsArgs']]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="connectorPlugins")
    def connector_plugins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectStatusConnectorPluginsArgs']]]]:
        """
        The list of connector plugins available in this Kafka Connect deployment.
        """
        return pulumi.get(self, "connector_plugins")

    @connector_plugins.setter
    def connector_plugins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaConnectStatusConnectorPluginsArgs']]]]):
        pulumi.set(self, "connector_plugins", value)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input[str]]:
        """
        Label selector for pods providing this resource.
        """
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[pulumi.Input[int]]:
        """
        The generation of the CRD that was last reconciled by the operator.
        """
        return pulumi.get(self, "observed_generation")

    @observed_generation.setter
    def observed_generation(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "observed_generation", value)

    @property
    @pulumi.getter
    def replicas(self) -> Optional[pulumi.Input[int]]:
        """
        The current number of pods being used to provide this resource.
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "replicas", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the REST API endpoint for managing and monitoring Kafka Connect connectors.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class KafkaConnectStatusConditionsArgs:
    def __init__(__self__, *,
                 last_transition_time: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] last_transition_time: Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
        :param pulumi.Input[str] message: Human-readable message indicating details about the condition's last transition.
        :param pulumi.Input[str] reason: The reason for the condition's last transition (a single word in CamelCase).
        :param pulumi.Input[str] status: The status of the condition, either True, False or Unknown.
        :param pulumi.Input[str] type: The unique identifier of a condition, used to distinguish between other conditions in the resource.
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[pulumi.Input[str]]:
        """
        Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
        """
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Human-readable message indicating details about the condition's last transition.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        The reason for the condition's last transition (a single word in CamelCase).
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of the condition, either True, False or Unknown.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The unique identifier of a condition, used to distinguish between other conditions in the resource.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class KafkaConnectStatusConnectorPluginsArgs:
    def __init__(__self__, *,
                 class_: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] class_: The class of the connector plugin.
        :param pulumi.Input[str] type: The type of the connector plugin. The available types are `sink` and `source`.
        :param pulumi.Input[str] version: The version of the connector plugin.
        """
        if class_ is not None:
            pulumi.set(__self__, "class_", class_)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="class")
    def class_(self) -> Optional[pulumi.Input[str]]:
        """
        The class of the connector plugin.
        """
        return pulumi.get(self, "class_")

    @class_.setter
    def class_(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "class_", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the connector plugin. The available types are `sink` and `source`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of the connector plugin.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class KafkaMirrorMakerSpecArgs:
    def __init__(__self__, *,
                 consumer: pulumi.Input['KafkaMirrorMakerSpecConsumerArgs'],
                 producer: pulumi.Input['KafkaMirrorMakerSpecProducerArgs'],
                 replicas: pulumi.Input[int],
                 whitelist: pulumi.Input[str],
                 affinity: Optional[pulumi.Input['KafkaMirrorMakerSpecAffinityArgs']] = None,
                 image: Optional[pulumi.Input[str]] = None,
                 jvm_options: Optional[pulumi.Input['KafkaMirrorMakerSpecJvmOptionsArgs']] = None,
                 liveness_probe: Optional[pulumi.Input['KafkaMirrorMakerSpecLivenessProbeArgs']] = None,
                 logging: Optional[pulumi.Input['KafkaMirrorMakerSpecLoggingArgs']] = None,
                 metrics: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 readiness_probe: Optional[pulumi.Input['KafkaMirrorMakerSpecReadinessProbeArgs']] = None,
                 resources: Optional[pulumi.Input['KafkaMirrorMakerSpecResourcesArgs']] = None,
                 template: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplateArgs']] = None,
                 tolerations: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTolerationsArgs']]]] = None,
                 tracing: Optional[pulumi.Input['KafkaMirrorMakerSpecTracingArgs']] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        The specification of Kafka MirrorMaker.
        :param pulumi.Input['KafkaMirrorMakerSpecConsumerArgs'] consumer: Configuration of source cluster.
        :param pulumi.Input['KafkaMirrorMakerSpecProducerArgs'] producer: Configuration of target cluster.
        :param pulumi.Input[int] replicas: The number of pods in the `Deployment`.
        :param pulumi.Input[str] whitelist: List of topics which are included for mirroring. This option allows any regular expression using Java-style regular expressions. Mirroring two topics named A and B is achieved by using the whitelist `'A\|B'`. Or, as a special case, you can mirror all topics using the whitelist '*'. You can also specify multiple regular expressions separated by commas.
        :param pulumi.Input['KafkaMirrorMakerSpecAffinityArgs'] affinity: The pod's affinity rules.
        :param pulumi.Input[str] image: The docker image for the pods.
        :param pulumi.Input['KafkaMirrorMakerSpecJvmOptionsArgs'] jvm_options: JVM Options for pods.
        :param pulumi.Input['KafkaMirrorMakerSpecLivenessProbeArgs'] liveness_probe: Pod liveness checking.
        :param pulumi.Input['KafkaMirrorMakerSpecLoggingArgs'] logging: Logging configuration for MirrorMaker.
        :param pulumi.Input[Mapping[str, Any]] metrics: The Prometheus JMX Exporter configuration. See {JMXExporter} for details of the structure of this configuration.
        :param pulumi.Input['KafkaMirrorMakerSpecReadinessProbeArgs'] readiness_probe: Pod readiness checking.
        :param pulumi.Input['KafkaMirrorMakerSpecResourcesArgs'] resources: CPU and memory resources to reserve.
        :param pulumi.Input['KafkaMirrorMakerSpecTemplateArgs'] template: Template to specify how Kafka MirrorMaker resources, `Deployments` and `Pods`, are generated.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTolerationsArgs']]] tolerations: The pod's tolerations.
        :param pulumi.Input['KafkaMirrorMakerSpecTracingArgs'] tracing: The configuration of tracing in Kafka MirrorMaker.
        :param pulumi.Input[str] version: The Kafka MirrorMaker version. Defaults to {DefaultKafkaVersion}. Consult the documentation to understand the process required to upgrade or downgrade the version.
        """
        pulumi.set(__self__, "consumer", consumer)
        pulumi.set(__self__, "producer", producer)
        pulumi.set(__self__, "replicas", replicas)
        pulumi.set(__self__, "whitelist", whitelist)
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if jvm_options is not None:
            pulumi.set(__self__, "jvm_options", jvm_options)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if template is not None:
            pulumi.set(__self__, "template", template)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)
        if tracing is not None:
            pulumi.set(__self__, "tracing", tracing)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def consumer(self) -> pulumi.Input['KafkaMirrorMakerSpecConsumerArgs']:
        """
        Configuration of source cluster.
        """
        return pulumi.get(self, "consumer")

    @consumer.setter
    def consumer(self, value: pulumi.Input['KafkaMirrorMakerSpecConsumerArgs']):
        pulumi.set(self, "consumer", value)

    @property
    @pulumi.getter
    def producer(self) -> pulumi.Input['KafkaMirrorMakerSpecProducerArgs']:
        """
        Configuration of target cluster.
        """
        return pulumi.get(self, "producer")

    @producer.setter
    def producer(self, value: pulumi.Input['KafkaMirrorMakerSpecProducerArgs']):
        pulumi.set(self, "producer", value)

    @property
    @pulumi.getter
    def replicas(self) -> pulumi.Input[int]:
        """
        The number of pods in the `Deployment`.
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: pulumi.Input[int]):
        pulumi.set(self, "replicas", value)

    @property
    @pulumi.getter
    def whitelist(self) -> pulumi.Input[str]:
        """
        List of topics which are included for mirroring. This option allows any regular expression using Java-style regular expressions. Mirroring two topics named A and B is achieved by using the whitelist `'A\|B'`. Or, as a special case, you can mirror all topics using the whitelist '*'. You can also specify multiple regular expressions separated by commas.
        """
        return pulumi.get(self, "whitelist")

    @whitelist.setter
    def whitelist(self, value: pulumi.Input[str]):
        pulumi.set(self, "whitelist", value)

    @property
    @pulumi.getter
    def affinity(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecAffinityArgs']]:
        """
        The pod's affinity rules.
        """
        return pulumi.get(self, "affinity")

    @affinity.setter
    def affinity(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecAffinityArgs']]):
        pulumi.set(self, "affinity", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        The docker image for the pods.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="jvmOptions")
    def jvm_options(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecJvmOptionsArgs']]:
        """
        JVM Options for pods.
        """
        return pulumi.get(self, "jvm_options")

    @jvm_options.setter
    def jvm_options(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecJvmOptionsArgs']]):
        pulumi.set(self, "jvm_options", value)

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecLivenessProbeArgs']]:
        """
        Pod liveness checking.
        """
        return pulumi.get(self, "liveness_probe")

    @liveness_probe.setter
    def liveness_probe(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecLivenessProbeArgs']]):
        pulumi.set(self, "liveness_probe", value)

    @property
    @pulumi.getter
    def logging(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecLoggingArgs']]:
        """
        Logging configuration for MirrorMaker.
        """
        return pulumi.get(self, "logging")

    @logging.setter
    def logging(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecLoggingArgs']]):
        pulumi.set(self, "logging", value)

    @property
    @pulumi.getter
    def metrics(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        The Prometheus JMX Exporter configuration. See {JMXExporter} for details of the structure of this configuration.
        """
        return pulumi.get(self, "metrics")

    @metrics.setter
    def metrics(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "metrics", value)

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecReadinessProbeArgs']]:
        """
        Pod readiness checking.
        """
        return pulumi.get(self, "readiness_probe")

    @readiness_probe.setter
    def readiness_probe(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecReadinessProbeArgs']]):
        pulumi.set(self, "readiness_probe", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecResourcesArgs']]:
        """
        CPU and memory resources to reserve.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecResourcesArgs']]):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter
    def template(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecTemplateArgs']]:
        """
        Template to specify how Kafka MirrorMaker resources, `Deployments` and `Pods`, are generated.
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplateArgs']]):
        pulumi.set(self, "template", value)

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTolerationsArgs']]]]:
        """
        The pod's tolerations.
        """
        return pulumi.get(self, "tolerations")

    @tolerations.setter
    def tolerations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTolerationsArgs']]]]):
        pulumi.set(self, "tolerations", value)

    @property
    @pulumi.getter
    def tracing(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecTracingArgs']]:
        """
        The configuration of tracing in Kafka MirrorMaker.
        """
        return pulumi.get(self, "tracing")

    @tracing.setter
    def tracing(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecTracingArgs']]):
        pulumi.set(self, "tracing", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        The Kafka MirrorMaker version. Defaults to {DefaultKafkaVersion}. Consult the documentation to understand the process required to upgrade or downgrade the version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class KafkaMirrorMakerSpecAffinityArgs:
    def __init__(__self__, *,
                 node_affinity: Optional[pulumi.Input['KafkaMirrorMakerSpecAffinityNodeAffinityArgs']] = None,
                 pod_affinity: Optional[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAffinityArgs']] = None,
                 pod_anti_affinity: Optional[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAntiAffinityArgs']] = None):
        """
        The pod's affinity rules.
        """
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecAffinityNodeAffinityArgs']]:
        return pulumi.get(self, "node_affinity")

    @node_affinity.setter
    def node_affinity(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecAffinityNodeAffinityArgs']]):
        pulumi.set(self, "node_affinity", value)

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAffinityArgs']]:
        return pulumi.get(self, "pod_affinity")

    @pod_affinity.setter
    def pod_affinity(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAffinityArgs']]):
        pulumi.set(self, "pod_affinity", value)

    @property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAntiAffinityArgs']]:
        return pulumi.get(self, "pod_anti_affinity")

    @pod_anti_affinity.setter
    def pod_anti_affinity(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAntiAffinityArgs']]):
        pulumi.set(self, "pod_anti_affinity", value)


@pulumi.input_type
class KafkaMirrorMakerSpecAffinityNodeAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input['KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 preference: Optional[pulumi.Input['KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']]:
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]] = None,
                 match_fields: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]]:
        return pulumi.get(self, "match_fields")

    @match_fields.setter
    def match_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]]):
        pulumi.set(self, "match_fields", value)


@pulumi.input_type
class KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 node_selector_terms: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]] = None):
        if node_selector_terms is not None:
            pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]]:
        return pulumi.get(self, "node_selector_terms")

    @node_selector_terms.setter
    def node_selector_terms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]]):
        pulumi.set(self, "node_selector_terms", value)


@pulumi.input_type
class KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]] = None,
                 match_fields: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]]:
        return pulumi.get(self, "match_fields")

    @match_fields.setter
    def match_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]]):
        pulumi.set(self, "match_fields", value)


@pulumi.input_type
class KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaMirrorMakerSpecAffinityPodAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 pod_affinity_term: Optional[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]:
        return pulumi.get(self, "pod_affinity_term")

    @pod_affinity_term.setter
    def pod_affinity_term(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]):
        pulumi.set(self, "pod_affinity_term", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaMirrorMakerSpecAffinityPodAntiAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 pod_affinity_term: Optional[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]:
        return pulumi.get(self, "pod_affinity_term")

    @pod_affinity_term.setter
    def pod_affinity_term(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]):
        pulumi.set(self, "pod_affinity_term", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaMirrorMakerSpecConsumerArgs:
    def __init__(__self__, *,
                 bootstrap_servers: pulumi.Input[str],
                 group_id: pulumi.Input[str],
                 authentication: Optional[pulumi.Input['KafkaMirrorMakerSpecConsumerAuthenticationArgs']] = None,
                 config: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 num_streams: Optional[pulumi.Input[int]] = None,
                 offset_commit_interval: Optional[pulumi.Input[int]] = None,
                 tls: Optional[pulumi.Input['KafkaMirrorMakerSpecConsumerTlsArgs']] = None):
        """
        Configuration of source cluster.
        :param pulumi.Input[str] bootstrap_servers: A list of host:port pairs for establishing the initial connection to the Kafka cluster.
        :param pulumi.Input[str] group_id: A unique string that identifies the consumer group this consumer belongs to.
        :param pulumi.Input['KafkaMirrorMakerSpecConsumerAuthenticationArgs'] authentication: Authentication configuration for connecting to the cluster.
        :param pulumi.Input[Mapping[str, Any]] config: The MirrorMaker consumer config. Properties with the following prefixes cannot be set: ssl., bootstrap.servers, group.id, sasl., security., interceptor.classes (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
        :param pulumi.Input[int] num_streams: Specifies the number of consumer stream threads to create.
        :param pulumi.Input[int] offset_commit_interval: Specifies the offset auto-commit interval in ms. Default value is 60000.
        :param pulumi.Input['KafkaMirrorMakerSpecConsumerTlsArgs'] tls: TLS configuration for connecting MirrorMaker to the cluster.
        """
        pulumi.set(__self__, "bootstrap_servers", bootstrap_servers)
        pulumi.set(__self__, "group_id", group_id)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if num_streams is not None:
            pulumi.set(__self__, "num_streams", num_streams)
        if offset_commit_interval is not None:
            pulumi.set(__self__, "offset_commit_interval", offset_commit_interval)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter(name="bootstrapServers")
    def bootstrap_servers(self) -> pulumi.Input[str]:
        """
        A list of host:port pairs for establishing the initial connection to the Kafka cluster.
        """
        return pulumi.get(self, "bootstrap_servers")

    @bootstrap_servers.setter
    def bootstrap_servers(self, value: pulumi.Input[str]):
        pulumi.set(self, "bootstrap_servers", value)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> pulumi.Input[str]:
        """
        A unique string that identifies the consumer group this consumer belongs to.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecConsumerAuthenticationArgs']]:
        """
        Authentication configuration for connecting to the cluster.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecConsumerAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        The MirrorMaker consumer config. Properties with the following prefixes cannot be set: ssl., bootstrap.servers, group.id, sasl., security., interceptor.classes (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "config", value)

    @property
    @pulumi.getter(name="numStreams")
    def num_streams(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the number of consumer stream threads to create.
        """
        return pulumi.get(self, "num_streams")

    @num_streams.setter
    def num_streams(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_streams", value)

    @property
    @pulumi.getter(name="offsetCommitInterval")
    def offset_commit_interval(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the offset auto-commit interval in ms. Default value is 60000.
        """
        return pulumi.get(self, "offset_commit_interval")

    @offset_commit_interval.setter
    def offset_commit_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "offset_commit_interval", value)

    @property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecConsumerTlsArgs']]:
        """
        TLS configuration for connecting MirrorMaker to the cluster.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecConsumerTlsArgs']]):
        pulumi.set(self, "tls", value)


@pulumi.input_type
class KafkaMirrorMakerSpecConsumerAuthenticationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 access_token: Optional[pulumi.Input['KafkaMirrorMakerSpecConsumerAuthenticationAccessTokenArgs']] = None,
                 access_token_is_jwt: Optional[pulumi.Input[bool]] = None,
                 certificate_and_key: Optional[pulumi.Input['KafkaMirrorMakerSpecConsumerAuthenticationCertificateAndKeyArgs']] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input['KafkaMirrorMakerSpecConsumerAuthenticationClientSecretArgs']] = None,
                 disable_tls_hostname_verification: Optional[pulumi.Input[bool]] = None,
                 max_token_expiry_seconds: Optional[pulumi.Input[int]] = None,
                 password_secret: Optional[pulumi.Input['KafkaMirrorMakerSpecConsumerAuthenticationPasswordSecretArgs']] = None,
                 refresh_token: Optional[pulumi.Input['KafkaMirrorMakerSpecConsumerAuthenticationRefreshTokenArgs']] = None,
                 scope: Optional[pulumi.Input[str]] = None,
                 tls_trusted_certificates: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecConsumerAuthenticationTlsTrustedCertificatesArgs']]]] = None,
                 token_endpoint_uri: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        Authentication configuration for connecting to the cluster.
        :param pulumi.Input[str] type: Authentication type. Currently the only supported types are `tls`, `scram-sha-512`, and `plain`. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
        :param pulumi.Input['KafkaMirrorMakerSpecConsumerAuthenticationAccessTokenArgs'] access_token: Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
        :param pulumi.Input[bool] access_token_is_jwt: Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
        :param pulumi.Input['KafkaMirrorMakerSpecConsumerAuthenticationCertificateAndKeyArgs'] certificate_and_key: Reference to the `Secret` which holds the certificate and private key pair.
        :param pulumi.Input[str] client_id: OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        :param pulumi.Input['KafkaMirrorMakerSpecConsumerAuthenticationClientSecretArgs'] client_secret: Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        :param pulumi.Input[bool] disable_tls_hostname_verification: Enable or disable TLS hostname verification. Default value is `false`.
        :param pulumi.Input[int] max_token_expiry_seconds: Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.
        :param pulumi.Input['KafkaMirrorMakerSpecConsumerAuthenticationPasswordSecretArgs'] password_secret: Reference to the `Secret` which holds the password.
        :param pulumi.Input['KafkaMirrorMakerSpecConsumerAuthenticationRefreshTokenArgs'] refresh_token: Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
        :param pulumi.Input[str] scope: OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecConsumerAuthenticationTlsTrustedCertificatesArgs']]] tls_trusted_certificates: Trusted certificates for TLS connection to the OAuth server.
        :param pulumi.Input[str] token_endpoint_uri: Authorization server token endpoint URI.
        :param pulumi.Input[str] username: Username used for the authentication.
        """
        pulumi.set(__self__, "type", type)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if access_token_is_jwt is not None:
            pulumi.set(__self__, "access_token_is_jwt", access_token_is_jwt)
        if certificate_and_key is not None:
            pulumi.set(__self__, "certificate_and_key", certificate_and_key)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if disable_tls_hostname_verification is not None:
            pulumi.set(__self__, "disable_tls_hostname_verification", disable_tls_hostname_verification)
        if max_token_expiry_seconds is not None:
            pulumi.set(__self__, "max_token_expiry_seconds", max_token_expiry_seconds)
        if password_secret is not None:
            pulumi.set(__self__, "password_secret", password_secret)
        if refresh_token is not None:
            pulumi.set(__self__, "refresh_token", refresh_token)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if tls_trusted_certificates is not None:
            pulumi.set(__self__, "tls_trusted_certificates", tls_trusted_certificates)
        if token_endpoint_uri is not None:
            pulumi.set(__self__, "token_endpoint_uri", token_endpoint_uri)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Authentication type. Currently the only supported types are `tls`, `scram-sha-512`, and `plain`. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecConsumerAuthenticationAccessTokenArgs']]:
        """
        Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecConsumerAuthenticationAccessTokenArgs']]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="accessTokenIsJwt")
    def access_token_is_jwt(self) -> Optional[pulumi.Input[bool]]:
        """
        Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
        """
        return pulumi.get(self, "access_token_is_jwt")

    @access_token_is_jwt.setter
    def access_token_is_jwt(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "access_token_is_jwt", value)

    @property
    @pulumi.getter(name="certificateAndKey")
    def certificate_and_key(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecConsumerAuthenticationCertificateAndKeyArgs']]:
        """
        Reference to the `Secret` which holds the certificate and private key pair.
        """
        return pulumi.get(self, "certificate_and_key")

    @certificate_and_key.setter
    def certificate_and_key(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecConsumerAuthenticationCertificateAndKeyArgs']]):
        pulumi.set(self, "certificate_and_key", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecConsumerAuthenticationClientSecretArgs']]:
        """
        Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecConsumerAuthenticationClientSecretArgs']]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="disableTlsHostnameVerification")
    def disable_tls_hostname_verification(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable or disable TLS hostname verification. Default value is `false`.
        """
        return pulumi.get(self, "disable_tls_hostname_verification")

    @disable_tls_hostname_verification.setter
    def disable_tls_hostname_verification(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_tls_hostname_verification", value)

    @property
    @pulumi.getter(name="maxTokenExpirySeconds")
    def max_token_expiry_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.
        """
        return pulumi.get(self, "max_token_expiry_seconds")

    @max_token_expiry_seconds.setter
    def max_token_expiry_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_token_expiry_seconds", value)

    @property
    @pulumi.getter(name="passwordSecret")
    def password_secret(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecConsumerAuthenticationPasswordSecretArgs']]:
        """
        Reference to the `Secret` which holds the password.
        """
        return pulumi.get(self, "password_secret")

    @password_secret.setter
    def password_secret(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecConsumerAuthenticationPasswordSecretArgs']]):
        pulumi.set(self, "password_secret", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecConsumerAuthenticationRefreshTokenArgs']]:
        """
        Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecConsumerAuthenticationRefreshTokenArgs']]):
        pulumi.set(self, "refresh_token", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[str]]:
        """
        OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter(name="tlsTrustedCertificates")
    def tls_trusted_certificates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecConsumerAuthenticationTlsTrustedCertificatesArgs']]]]:
        """
        Trusted certificates for TLS connection to the OAuth server.
        """
        return pulumi.get(self, "tls_trusted_certificates")

    @tls_trusted_certificates.setter
    def tls_trusted_certificates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecConsumerAuthenticationTlsTrustedCertificatesArgs']]]]):
        pulumi.set(self, "tls_trusted_certificates", value)

    @property
    @pulumi.getter(name="tokenEndpointUri")
    def token_endpoint_uri(self) -> Optional[pulumi.Input[str]]:
        """
        Authorization server token endpoint URI.
        """
        return pulumi.get(self, "token_endpoint_uri")

    @token_endpoint_uri.setter
    def token_endpoint_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_endpoint_uri", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        Username used for the authentication.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class KafkaMirrorMakerSpecConsumerAuthenticationAccessTokenArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
        :param pulumi.Input[str] key: The key under which the secret value is stored in the Kubernetes Secret.
        :param pulumi.Input[str] secret_name: The name of the Kubernetes Secret containing the secret value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key under which the secret value is stored in the Kubernetes Secret.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        The name of the Kubernetes Secret containing the secret value.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KafkaMirrorMakerSpecConsumerAuthenticationCertificateAndKeyArgs:
    def __init__(__self__, *,
                 certificate: pulumi.Input[str],
                 key: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        Reference to the `Secret` which holds the certificate and private key pair.
        :param pulumi.Input[str] certificate: The name of the file certificate in the Secret.
        :param pulumi.Input[str] key: The name of the private key in the Secret.
        :param pulumi.Input[str] secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> pulumi.Input[str]:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The name of the private key in the Secret.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KafkaMirrorMakerSpecConsumerAuthenticationClientSecretArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        :param pulumi.Input[str] key: The key under which the secret value is stored in the Kubernetes Secret.
        :param pulumi.Input[str] secret_name: The name of the Kubernetes Secret containing the secret value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key under which the secret value is stored in the Kubernetes Secret.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        The name of the Kubernetes Secret containing the secret value.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KafkaMirrorMakerSpecConsumerAuthenticationPasswordSecretArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        Reference to the `Secret` which holds the password.
        :param pulumi.Input[str] password: The name of the key in the Secret under which the password is stored.
        :param pulumi.Input[str] secret_name: The name of the Secret containing the password.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        The name of the key in the Secret under which the password is stored.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        The name of the Secret containing the password.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KafkaMirrorMakerSpecConsumerAuthenticationRefreshTokenArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
        :param pulumi.Input[str] key: The key under which the secret value is stored in the Kubernetes Secret.
        :param pulumi.Input[str] secret_name: The name of the Kubernetes Secret containing the secret value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key under which the secret value is stored in the Kubernetes Secret.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        The name of the Kubernetes Secret containing the secret value.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KafkaMirrorMakerSpecConsumerAuthenticationTlsTrustedCertificatesArgs:
    def __init__(__self__, *,
                 certificate: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] certificate: The name of the file certificate in the Secret.
        :param pulumi.Input[str] secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> pulumi.Input[str]:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KafkaMirrorMakerSpecConsumerTlsArgs:
    def __init__(__self__, *,
                 trusted_certificates: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecConsumerTlsTrustedCertificatesArgs']]]] = None):
        """
        TLS configuration for connecting MirrorMaker to the cluster.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecConsumerTlsTrustedCertificatesArgs']]] trusted_certificates: Trusted certificates for TLS connection.
        """
        if trusted_certificates is not None:
            pulumi.set(__self__, "trusted_certificates", trusted_certificates)

    @property
    @pulumi.getter(name="trustedCertificates")
    def trusted_certificates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecConsumerTlsTrustedCertificatesArgs']]]]:
        """
        Trusted certificates for TLS connection.
        """
        return pulumi.get(self, "trusted_certificates")

    @trusted_certificates.setter
    def trusted_certificates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecConsumerTlsTrustedCertificatesArgs']]]]):
        pulumi.set(self, "trusted_certificates", value)


@pulumi.input_type
class KafkaMirrorMakerSpecConsumerTlsTrustedCertificatesArgs:
    def __init__(__self__, *,
                 certificate: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] certificate: The name of the file certificate in the Secret.
        :param pulumi.Input[str] secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> pulumi.Input[str]:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KafkaMirrorMakerSpecJvmOptionsArgs:
    def __init__(__self__, *,
                 __xx: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 __xms: Optional[pulumi.Input[str]] = None,
                 __xmx: Optional[pulumi.Input[str]] = None,
                 gc_logging_enabled: Optional[pulumi.Input[bool]] = None,
                 java_system_properties: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecJvmOptionsJavaSystemPropertiesArgs']]]] = None):
        """
        JVM Options for pods.
        :param pulumi.Input[Mapping[str, Any]] __xx: A map of -XX options to the JVM.
        :param pulumi.Input[str] __xms: -Xms option to to the JVM.
        :param pulumi.Input[str] __xmx: -Xmx option to to the JVM.
        :param pulumi.Input[bool] gc_logging_enabled: Specifies whether the Garbage Collection logging is enabled. The default is false.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecJvmOptionsJavaSystemPropertiesArgs']]] java_system_properties: A map of additional system properties which will be passed using the `-D` option to the JVM.
        """
        if __xx is not None:
            pulumi.set(__self__, "__xx", __xx)
        if __xms is not None:
            pulumi.set(__self__, "__xms", __xms)
        if __xmx is not None:
            pulumi.set(__self__, "__xmx", __xmx)
        if gc_logging_enabled is not None:
            pulumi.set(__self__, "gc_logging_enabled", gc_logging_enabled)
        if java_system_properties is not None:
            pulumi.set(__self__, "java_system_properties", java_system_properties)

    @property
    @pulumi.getter(name="-XX")
    def __xx(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        A map of -XX options to the JVM.
        """
        return pulumi.get(self, "__xx")

    @__xx.setter
    def __xx(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "__xx", value)

    @property
    @pulumi.getter(name="-Xms")
    def __xms(self) -> Optional[pulumi.Input[str]]:
        """
        -Xms option to to the JVM.
        """
        return pulumi.get(self, "__xms")

    @__xms.setter
    def __xms(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "__xms", value)

    @property
    @pulumi.getter(name="-Xmx")
    def __xmx(self) -> Optional[pulumi.Input[str]]:
        """
        -Xmx option to to the JVM.
        """
        return pulumi.get(self, "__xmx")

    @__xmx.setter
    def __xmx(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "__xmx", value)

    @property
    @pulumi.getter(name="gcLoggingEnabled")
    def gc_logging_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether the Garbage Collection logging is enabled. The default is false.
        """
        return pulumi.get(self, "gc_logging_enabled")

    @gc_logging_enabled.setter
    def gc_logging_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "gc_logging_enabled", value)

    @property
    @pulumi.getter(name="javaSystemProperties")
    def java_system_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecJvmOptionsJavaSystemPropertiesArgs']]]]:
        """
        A map of additional system properties which will be passed using the `-D` option to the JVM.
        """
        return pulumi.get(self, "java_system_properties")

    @java_system_properties.setter
    def java_system_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecJvmOptionsJavaSystemPropertiesArgs']]]]):
        pulumi.set(self, "java_system_properties", value)


@pulumi.input_type
class KafkaMirrorMakerSpecJvmOptionsJavaSystemPropertiesArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The system property name.
        :param pulumi.Input[str] value: The system property value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The system property name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The system property value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaMirrorMakerSpecLivenessProbeArgs:
    def __init__(__self__, *,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 success_threshold: Optional[pulumi.Input[int]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        Pod liveness checking.
        :param pulumi.Input[int] failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param pulumi.Input[int] initial_delay_seconds: The initial delay before first the health is first checked.
        :param pulumi.Input[int] period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param pulumi.Input[int] success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param pulumi.Input[int] timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "success_threshold", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


@pulumi.input_type
class KafkaMirrorMakerSpecLoggingArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 loggers: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        Logging configuration for MirrorMaker.
        :param pulumi.Input[str] type: Logging type, must be either 'inline' or 'external'.
        :param pulumi.Input[Mapping[str, Any]] loggers: A Map from logger name to logger level.
        :param pulumi.Input[str] name: The name of the `ConfigMap` from which to get the logging configuration.
        """
        pulumi.set(__self__, "type", type)
        if loggers is not None:
            pulumi.set(__self__, "loggers", loggers)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Logging type, must be either 'inline' or 'external'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def loggers(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        A Map from logger name to logger level.
        """
        return pulumi.get(self, "loggers")

    @loggers.setter
    def loggers(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "loggers", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the `ConfigMap` from which to get the logging configuration.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class KafkaMirrorMakerSpecProducerArgs:
    def __init__(__self__, *,
                 bootstrap_servers: pulumi.Input[str],
                 abort_on_send_failure: Optional[pulumi.Input[bool]] = None,
                 authentication: Optional[pulumi.Input['KafkaMirrorMakerSpecProducerAuthenticationArgs']] = None,
                 config: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 tls: Optional[pulumi.Input['KafkaMirrorMakerSpecProducerTlsArgs']] = None):
        """
        Configuration of target cluster.
        :param pulumi.Input[str] bootstrap_servers: A list of host:port pairs for establishing the initial connection to the Kafka cluster.
        :param pulumi.Input[bool] abort_on_send_failure: Flag to set the MirrorMaker to exit on a failed send. Default value is `true`.
        :param pulumi.Input['KafkaMirrorMakerSpecProducerAuthenticationArgs'] authentication: Authentication configuration for connecting to the cluster.
        :param pulumi.Input[Mapping[str, Any]] config: The MirrorMaker producer config. Properties with the following prefixes cannot be set: ssl., bootstrap.servers, sasl., security., interceptor.classes (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
        :param pulumi.Input['KafkaMirrorMakerSpecProducerTlsArgs'] tls: TLS configuration for connecting MirrorMaker to the cluster.
        """
        pulumi.set(__self__, "bootstrap_servers", bootstrap_servers)
        if abort_on_send_failure is not None:
            pulumi.set(__self__, "abort_on_send_failure", abort_on_send_failure)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter(name="bootstrapServers")
    def bootstrap_servers(self) -> pulumi.Input[str]:
        """
        A list of host:port pairs for establishing the initial connection to the Kafka cluster.
        """
        return pulumi.get(self, "bootstrap_servers")

    @bootstrap_servers.setter
    def bootstrap_servers(self, value: pulumi.Input[str]):
        pulumi.set(self, "bootstrap_servers", value)

    @property
    @pulumi.getter(name="abortOnSendFailure")
    def abort_on_send_failure(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag to set the MirrorMaker to exit on a failed send. Default value is `true`.
        """
        return pulumi.get(self, "abort_on_send_failure")

    @abort_on_send_failure.setter
    def abort_on_send_failure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "abort_on_send_failure", value)

    @property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecProducerAuthenticationArgs']]:
        """
        Authentication configuration for connecting to the cluster.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecProducerAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        The MirrorMaker producer config. Properties with the following prefixes cannot be set: ssl., bootstrap.servers, sasl., security., interceptor.classes (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "config", value)

    @property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecProducerTlsArgs']]:
        """
        TLS configuration for connecting MirrorMaker to the cluster.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecProducerTlsArgs']]):
        pulumi.set(self, "tls", value)


@pulumi.input_type
class KafkaMirrorMakerSpecProducerAuthenticationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 access_token: Optional[pulumi.Input['KafkaMirrorMakerSpecProducerAuthenticationAccessTokenArgs']] = None,
                 access_token_is_jwt: Optional[pulumi.Input[bool]] = None,
                 certificate_and_key: Optional[pulumi.Input['KafkaMirrorMakerSpecProducerAuthenticationCertificateAndKeyArgs']] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input['KafkaMirrorMakerSpecProducerAuthenticationClientSecretArgs']] = None,
                 disable_tls_hostname_verification: Optional[pulumi.Input[bool]] = None,
                 max_token_expiry_seconds: Optional[pulumi.Input[int]] = None,
                 password_secret: Optional[pulumi.Input['KafkaMirrorMakerSpecProducerAuthenticationPasswordSecretArgs']] = None,
                 refresh_token: Optional[pulumi.Input['KafkaMirrorMakerSpecProducerAuthenticationRefreshTokenArgs']] = None,
                 scope: Optional[pulumi.Input[str]] = None,
                 tls_trusted_certificates: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecProducerAuthenticationTlsTrustedCertificatesArgs']]]] = None,
                 token_endpoint_uri: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        Authentication configuration for connecting to the cluster.
        :param pulumi.Input[str] type: Authentication type. Currently the only supported types are `tls`, `scram-sha-512`, and `plain`. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
        :param pulumi.Input['KafkaMirrorMakerSpecProducerAuthenticationAccessTokenArgs'] access_token: Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
        :param pulumi.Input[bool] access_token_is_jwt: Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
        :param pulumi.Input['KafkaMirrorMakerSpecProducerAuthenticationCertificateAndKeyArgs'] certificate_and_key: Reference to the `Secret` which holds the certificate and private key pair.
        :param pulumi.Input[str] client_id: OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        :param pulumi.Input['KafkaMirrorMakerSpecProducerAuthenticationClientSecretArgs'] client_secret: Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        :param pulumi.Input[bool] disable_tls_hostname_verification: Enable or disable TLS hostname verification. Default value is `false`.
        :param pulumi.Input[int] max_token_expiry_seconds: Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.
        :param pulumi.Input['KafkaMirrorMakerSpecProducerAuthenticationPasswordSecretArgs'] password_secret: Reference to the `Secret` which holds the password.
        :param pulumi.Input['KafkaMirrorMakerSpecProducerAuthenticationRefreshTokenArgs'] refresh_token: Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
        :param pulumi.Input[str] scope: OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecProducerAuthenticationTlsTrustedCertificatesArgs']]] tls_trusted_certificates: Trusted certificates for TLS connection to the OAuth server.
        :param pulumi.Input[str] token_endpoint_uri: Authorization server token endpoint URI.
        :param pulumi.Input[str] username: Username used for the authentication.
        """
        pulumi.set(__self__, "type", type)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if access_token_is_jwt is not None:
            pulumi.set(__self__, "access_token_is_jwt", access_token_is_jwt)
        if certificate_and_key is not None:
            pulumi.set(__self__, "certificate_and_key", certificate_and_key)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if disable_tls_hostname_verification is not None:
            pulumi.set(__self__, "disable_tls_hostname_verification", disable_tls_hostname_verification)
        if max_token_expiry_seconds is not None:
            pulumi.set(__self__, "max_token_expiry_seconds", max_token_expiry_seconds)
        if password_secret is not None:
            pulumi.set(__self__, "password_secret", password_secret)
        if refresh_token is not None:
            pulumi.set(__self__, "refresh_token", refresh_token)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if tls_trusted_certificates is not None:
            pulumi.set(__self__, "tls_trusted_certificates", tls_trusted_certificates)
        if token_endpoint_uri is not None:
            pulumi.set(__self__, "token_endpoint_uri", token_endpoint_uri)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Authentication type. Currently the only supported types are `tls`, `scram-sha-512`, and `plain`. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecProducerAuthenticationAccessTokenArgs']]:
        """
        Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecProducerAuthenticationAccessTokenArgs']]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="accessTokenIsJwt")
    def access_token_is_jwt(self) -> Optional[pulumi.Input[bool]]:
        """
        Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
        """
        return pulumi.get(self, "access_token_is_jwt")

    @access_token_is_jwt.setter
    def access_token_is_jwt(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "access_token_is_jwt", value)

    @property
    @pulumi.getter(name="certificateAndKey")
    def certificate_and_key(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecProducerAuthenticationCertificateAndKeyArgs']]:
        """
        Reference to the `Secret` which holds the certificate and private key pair.
        """
        return pulumi.get(self, "certificate_and_key")

    @certificate_and_key.setter
    def certificate_and_key(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecProducerAuthenticationCertificateAndKeyArgs']]):
        pulumi.set(self, "certificate_and_key", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecProducerAuthenticationClientSecretArgs']]:
        """
        Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecProducerAuthenticationClientSecretArgs']]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="disableTlsHostnameVerification")
    def disable_tls_hostname_verification(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable or disable TLS hostname verification. Default value is `false`.
        """
        return pulumi.get(self, "disable_tls_hostname_verification")

    @disable_tls_hostname_verification.setter
    def disable_tls_hostname_verification(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_tls_hostname_verification", value)

    @property
    @pulumi.getter(name="maxTokenExpirySeconds")
    def max_token_expiry_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.
        """
        return pulumi.get(self, "max_token_expiry_seconds")

    @max_token_expiry_seconds.setter
    def max_token_expiry_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_token_expiry_seconds", value)

    @property
    @pulumi.getter(name="passwordSecret")
    def password_secret(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecProducerAuthenticationPasswordSecretArgs']]:
        """
        Reference to the `Secret` which holds the password.
        """
        return pulumi.get(self, "password_secret")

    @password_secret.setter
    def password_secret(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecProducerAuthenticationPasswordSecretArgs']]):
        pulumi.set(self, "password_secret", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecProducerAuthenticationRefreshTokenArgs']]:
        """
        Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecProducerAuthenticationRefreshTokenArgs']]):
        pulumi.set(self, "refresh_token", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[str]]:
        """
        OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter(name="tlsTrustedCertificates")
    def tls_trusted_certificates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecProducerAuthenticationTlsTrustedCertificatesArgs']]]]:
        """
        Trusted certificates for TLS connection to the OAuth server.
        """
        return pulumi.get(self, "tls_trusted_certificates")

    @tls_trusted_certificates.setter
    def tls_trusted_certificates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecProducerAuthenticationTlsTrustedCertificatesArgs']]]]):
        pulumi.set(self, "tls_trusted_certificates", value)

    @property
    @pulumi.getter(name="tokenEndpointUri")
    def token_endpoint_uri(self) -> Optional[pulumi.Input[str]]:
        """
        Authorization server token endpoint URI.
        """
        return pulumi.get(self, "token_endpoint_uri")

    @token_endpoint_uri.setter
    def token_endpoint_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_endpoint_uri", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        Username used for the authentication.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class KafkaMirrorMakerSpecProducerAuthenticationAccessTokenArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
        :param pulumi.Input[str] key: The key under which the secret value is stored in the Kubernetes Secret.
        :param pulumi.Input[str] secret_name: The name of the Kubernetes Secret containing the secret value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key under which the secret value is stored in the Kubernetes Secret.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        The name of the Kubernetes Secret containing the secret value.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KafkaMirrorMakerSpecProducerAuthenticationCertificateAndKeyArgs:
    def __init__(__self__, *,
                 certificate: pulumi.Input[str],
                 key: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        Reference to the `Secret` which holds the certificate and private key pair.
        :param pulumi.Input[str] certificate: The name of the file certificate in the Secret.
        :param pulumi.Input[str] key: The name of the private key in the Secret.
        :param pulumi.Input[str] secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> pulumi.Input[str]:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The name of the private key in the Secret.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KafkaMirrorMakerSpecProducerAuthenticationClientSecretArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        :param pulumi.Input[str] key: The key under which the secret value is stored in the Kubernetes Secret.
        :param pulumi.Input[str] secret_name: The name of the Kubernetes Secret containing the secret value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key under which the secret value is stored in the Kubernetes Secret.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        The name of the Kubernetes Secret containing the secret value.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KafkaMirrorMakerSpecProducerAuthenticationPasswordSecretArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        Reference to the `Secret` which holds the password.
        :param pulumi.Input[str] password: The name of the key in the Secret under which the password is stored.
        :param pulumi.Input[str] secret_name: The name of the Secret containing the password.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        The name of the key in the Secret under which the password is stored.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        The name of the Secret containing the password.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KafkaMirrorMakerSpecProducerAuthenticationRefreshTokenArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
        :param pulumi.Input[str] key: The key under which the secret value is stored in the Kubernetes Secret.
        :param pulumi.Input[str] secret_name: The name of the Kubernetes Secret containing the secret value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key under which the secret value is stored in the Kubernetes Secret.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        The name of the Kubernetes Secret containing the secret value.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KafkaMirrorMakerSpecProducerAuthenticationTlsTrustedCertificatesArgs:
    def __init__(__self__, *,
                 certificate: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] certificate: The name of the file certificate in the Secret.
        :param pulumi.Input[str] secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> pulumi.Input[str]:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KafkaMirrorMakerSpecProducerTlsArgs:
    def __init__(__self__, *,
                 trusted_certificates: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecProducerTlsTrustedCertificatesArgs']]]] = None):
        """
        TLS configuration for connecting MirrorMaker to the cluster.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecProducerTlsTrustedCertificatesArgs']]] trusted_certificates: Trusted certificates for TLS connection.
        """
        if trusted_certificates is not None:
            pulumi.set(__self__, "trusted_certificates", trusted_certificates)

    @property
    @pulumi.getter(name="trustedCertificates")
    def trusted_certificates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecProducerTlsTrustedCertificatesArgs']]]]:
        """
        Trusted certificates for TLS connection.
        """
        return pulumi.get(self, "trusted_certificates")

    @trusted_certificates.setter
    def trusted_certificates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecProducerTlsTrustedCertificatesArgs']]]]):
        pulumi.set(self, "trusted_certificates", value)


@pulumi.input_type
class KafkaMirrorMakerSpecProducerTlsTrustedCertificatesArgs:
    def __init__(__self__, *,
                 certificate: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] certificate: The name of the file certificate in the Secret.
        :param pulumi.Input[str] secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> pulumi.Input[str]:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KafkaMirrorMakerSpecReadinessProbeArgs:
    def __init__(__self__, *,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 success_threshold: Optional[pulumi.Input[int]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        Pod readiness checking.
        :param pulumi.Input[int] failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param pulumi.Input[int] initial_delay_seconds: The initial delay before first the health is first checked.
        :param pulumi.Input[int] period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param pulumi.Input[int] success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param pulumi.Input[int] timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "success_threshold", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


@pulumi.input_type
class KafkaMirrorMakerSpecResourcesArgs:
    def __init__(__self__, *,
                 limits: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 requests: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        CPU and memory resources to reserve.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "limits", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "requests", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplateArgs:
    def __init__(__self__, *,
                 deployment: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplateDeploymentArgs']] = None,
                 mirror_maker_container: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplateMirrorMakerContainerArgs']] = None,
                 pod: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodArgs']] = None,
                 pod_disruption_budget: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodDisruptionBudgetArgs']] = None):
        """
        Template to specify how Kafka MirrorMaker resources, `Deployments` and `Pods`, are generated.
        :param pulumi.Input['KafkaMirrorMakerSpecTemplateDeploymentArgs'] deployment: Template for Kafka MirrorMaker `Deployment`.
        :param pulumi.Input['KafkaMirrorMakerSpecTemplateMirrorMakerContainerArgs'] mirror_maker_container: Template for Kafka MirrorMaker container.
        :param pulumi.Input['KafkaMirrorMakerSpecTemplatePodArgs'] pod: Template for Kafka MirrorMaker `Pods`.
        :param pulumi.Input['KafkaMirrorMakerSpecTemplatePodDisruptionBudgetArgs'] pod_disruption_budget: Template for Kafka MirrorMaker `PodDisruptionBudget`.
        """
        if deployment is not None:
            pulumi.set(__self__, "deployment", deployment)
        if mirror_maker_container is not None:
            pulumi.set(__self__, "mirror_maker_container", mirror_maker_container)
        if pod is not None:
            pulumi.set(__self__, "pod", pod)
        if pod_disruption_budget is not None:
            pulumi.set(__self__, "pod_disruption_budget", pod_disruption_budget)

    @property
    @pulumi.getter
    def deployment(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecTemplateDeploymentArgs']]:
        """
        Template for Kafka MirrorMaker `Deployment`.
        """
        return pulumi.get(self, "deployment")

    @deployment.setter
    def deployment(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplateDeploymentArgs']]):
        pulumi.set(self, "deployment", value)

    @property
    @pulumi.getter(name="mirrorMakerContainer")
    def mirror_maker_container(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecTemplateMirrorMakerContainerArgs']]:
        """
        Template for Kafka MirrorMaker container.
        """
        return pulumi.get(self, "mirror_maker_container")

    @mirror_maker_container.setter
    def mirror_maker_container(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplateMirrorMakerContainerArgs']]):
        pulumi.set(self, "mirror_maker_container", value)

    @property
    @pulumi.getter
    def pod(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodArgs']]:
        """
        Template for Kafka MirrorMaker `Pods`.
        """
        return pulumi.get(self, "pod")

    @pod.setter
    def pod(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodArgs']]):
        pulumi.set(self, "pod", value)

    @property
    @pulumi.getter(name="podDisruptionBudget")
    def pod_disruption_budget(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodDisruptionBudgetArgs']]:
        """
        Template for Kafka MirrorMaker `PodDisruptionBudget`.
        """
        return pulumi.get(self, "pod_disruption_budget")

    @pod_disruption_budget.setter
    def pod_disruption_budget(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodDisruptionBudgetArgs']]):
        pulumi.set(self, "pod_disruption_budget", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplateDeploymentArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplateDeploymentMetadataArgs']] = None):
        """
        Template for Kafka MirrorMaker `Deployment`.
        :param pulumi.Input['KafkaMirrorMakerSpecTemplateDeploymentMetadataArgs'] metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecTemplateDeploymentMetadataArgs']]:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplateDeploymentMetadataArgs']]):
        pulumi.set(self, "metadata", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplateDeploymentMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Metadata applied to the resource.
        :param pulumi.Input[Mapping[str, Any]] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param pulumi.Input[Mapping[str, Any]] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplateMirrorMakerContainerArgs:
    def __init__(__self__, *,
                 env: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplateMirrorMakerContainerEnvArgs']]]] = None,
                 security_context: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextArgs']] = None):
        """
        Template for Kafka MirrorMaker container.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplateMirrorMakerContainerEnvArgs']]] env: Environment variables which should be applied to the container.
        :param pulumi.Input['KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextArgs'] security_context: Security context for the container.
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)

    @property
    @pulumi.getter
    def env(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplateMirrorMakerContainerEnvArgs']]]]:
        """
        Environment variables which should be applied to the container.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplateMirrorMakerContainerEnvArgs']]]]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextArgs']]:
        """
        Security context for the container.
        """
        return pulumi.get(self, "security_context")

    @security_context.setter
    def security_context(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextArgs']]):
        pulumi.set(self, "security_context", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplateMirrorMakerContainerEnvArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The environment variable key.
        :param pulumi.Input[str] value: The environment variable value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The environment variable key.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The environment variable value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextArgs:
    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[pulumi.Input[bool]] = None,
                 capabilities: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextCapabilitiesArgs']] = None,
                 privileged: Optional[pulumi.Input[bool]] = None,
                 proc_mount: Optional[pulumi.Input[str]] = None,
                 read_only_root_filesystem: Optional[pulumi.Input[bool]] = None,
                 run_as_group: Optional[pulumi.Input[int]] = None,
                 run_as_non_root: Optional[pulumi.Input[bool]] = None,
                 run_as_user: Optional[pulumi.Input[int]] = None,
                 se_linux_options: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextSeLinuxOptionsArgs']] = None,
                 windows_options: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextWindowsOptionsArgs']] = None):
        """
        Security context for the container.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if proc_mount is not None:
            pulumi.set(__self__, "proc_mount", proc_mount)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "allow_privilege_escalation")

    @allow_privilege_escalation.setter
    def allow_privilege_escalation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_privilege_escalation", value)

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextCapabilitiesArgs']]:
        return pulumi.get(self, "capabilities")

    @capabilities.setter
    def capabilities(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextCapabilitiesArgs']]):
        pulumi.set(self, "capabilities", value)

    @property
    @pulumi.getter
    def privileged(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "privileged")

    @privileged.setter
    def privileged(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "privileged", value)

    @property
    @pulumi.getter(name="procMount")
    def proc_mount(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "proc_mount")

    @proc_mount.setter
    def proc_mount(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proc_mount", value)

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "read_only_root_filesystem")

    @read_only_root_filesystem.setter
    def read_only_root_filesystem(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "read_only_root_filesystem", value)

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_group")

    @run_as_group.setter
    def run_as_group(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_group", value)

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "run_as_non_root")

    @run_as_non_root.setter
    def run_as_non_root(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_as_non_root", value)

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_user")

    @run_as_user.setter
    def run_as_user(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_user", value)

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextSeLinuxOptionsArgs']]:
        return pulumi.get(self, "se_linux_options")

    @se_linux_options.setter
    def se_linux_options(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextSeLinuxOptionsArgs']]):
        pulumi.set(self, "se_linux_options", value)

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextWindowsOptionsArgs']]:
        return pulumi.get(self, "windows_options")

    @windows_options.setter
    def windows_options(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextWindowsOptionsArgs']]):
        pulumi.set(self, "windows_options", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextCapabilitiesArgs:
    def __init__(__self__, *,
                 add: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 drop: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)

    @property
    @pulumi.getter
    def add(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "add")

    @add.setter
    def add(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "add", value)

    @property
    @pulumi.getter
    def drop(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "drop")

    @drop.setter
    def drop(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "drop", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextSeLinuxOptionsArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextWindowsOptionsArgs:
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[pulumi.Input[str]] = None,
                 gmsa_credential_spec_name: Optional[pulumi.Input[str]] = None,
                 run_as_user_name: Optional[pulumi.Input[str]] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec")

    @gmsa_credential_spec.setter
    def gmsa_credential_spec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec", value)

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @gmsa_credential_spec_name.setter
    def gmsa_credential_spec_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec_name", value)

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "run_as_user_name")

    @run_as_user_name.setter
    def run_as_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "run_as_user_name", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplatePodArgs:
    def __init__(__self__, *,
                 affinity: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityArgs']] = None,
                 host_aliases: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodHostAliasesArgs']]]] = None,
                 image_pull_secrets: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodImagePullSecretsArgs']]]] = None,
                 metadata: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodMetadataArgs']] = None,
                 priority_class_name: Optional[pulumi.Input[str]] = None,
                 scheduler_name: Optional[pulumi.Input[str]] = None,
                 security_context: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodSecurityContextArgs']] = None,
                 termination_grace_period_seconds: Optional[pulumi.Input[int]] = None,
                 tolerations: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodTolerationsArgs']]]] = None):
        """
        Template for Kafka MirrorMaker `Pods`.
        :param pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityArgs'] affinity: The pod's affinity rules.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodHostAliasesArgs']]] host_aliases: The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodImagePullSecretsArgs']]] image_pull_secrets: List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
        :param pulumi.Input['KafkaMirrorMakerSpecTemplatePodMetadataArgs'] metadata: Metadata applied to the resource.
        :param pulumi.Input[str] priority_class_name: The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
        :param pulumi.Input[str] scheduler_name: The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
        :param pulumi.Input['KafkaMirrorMakerSpecTemplatePodSecurityContextArgs'] security_context: Configures pod-level security attributes and common container settings.
        :param pulumi.Input[int] termination_grace_period_seconds: The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodTolerationsArgs']]] tolerations: The pod's tolerations.
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if host_aliases is not None:
            pulumi.set(__self__, "host_aliases", host_aliases)
        if image_pull_secrets is not None:
            pulumi.set(__self__, "image_pull_secrets", image_pull_secrets)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if priority_class_name is not None:
            pulumi.set(__self__, "priority_class_name", priority_class_name)
        if scheduler_name is not None:
            pulumi.set(__self__, "scheduler_name", scheduler_name)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)

    @property
    @pulumi.getter
    def affinity(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityArgs']]:
        """
        The pod's affinity rules.
        """
        return pulumi.get(self, "affinity")

    @affinity.setter
    def affinity(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityArgs']]):
        pulumi.set(self, "affinity", value)

    @property
    @pulumi.getter(name="hostAliases")
    def host_aliases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodHostAliasesArgs']]]]:
        """
        The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
        """
        return pulumi.get(self, "host_aliases")

    @host_aliases.setter
    def host_aliases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodHostAliasesArgs']]]]):
        pulumi.set(self, "host_aliases", value)

    @property
    @pulumi.getter(name="imagePullSecrets")
    def image_pull_secrets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodImagePullSecretsArgs']]]]:
        """
        List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
        """
        return pulumi.get(self, "image_pull_secrets")

    @image_pull_secrets.setter
    def image_pull_secrets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodImagePullSecretsArgs']]]]):
        pulumi.set(self, "image_pull_secrets", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodMetadataArgs']]:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodMetadataArgs']]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter(name="priorityClassName")
    def priority_class_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
        """
        return pulumi.get(self, "priority_class_name")

    @priority_class_name.setter
    def priority_class_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "priority_class_name", value)

    @property
    @pulumi.getter(name="schedulerName")
    def scheduler_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
        """
        return pulumi.get(self, "scheduler_name")

    @scheduler_name.setter
    def scheduler_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scheduler_name", value)

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodSecurityContextArgs']]:
        """
        Configures pod-level security attributes and common container settings.
        """
        return pulumi.get(self, "security_context")

    @security_context.setter
    def security_context(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodSecurityContextArgs']]):
        pulumi.set(self, "security_context", value)

    @property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
        """
        return pulumi.get(self, "termination_grace_period_seconds")

    @termination_grace_period_seconds.setter
    def termination_grace_period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "termination_grace_period_seconds", value)

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodTolerationsArgs']]]]:
        """
        The pod's tolerations.
        """
        return pulumi.get(self, "tolerations")

    @tolerations.setter
    def tolerations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodTolerationsArgs']]]]):
        pulumi.set(self, "tolerations", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplatePodAffinityArgs:
    def __init__(__self__, *,
                 node_affinity: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityArgs']] = None,
                 pod_affinity: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityArgs']] = None,
                 pod_anti_affinity: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityArgs']] = None):
        """
        The pod's affinity rules.
        """
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityArgs']]:
        return pulumi.get(self, "node_affinity")

    @node_affinity.setter
    def node_affinity(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityArgs']]):
        pulumi.set(self, "node_affinity", value)

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityArgs']]:
        return pulumi.get(self, "pod_affinity")

    @pod_affinity.setter
    def pod_affinity(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityArgs']]):
        pulumi.set(self, "pod_affinity", value)

    @property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityArgs']]:
        return pulumi.get(self, "pod_anti_affinity")

    @pod_anti_affinity.setter
    def pod_anti_affinity(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityArgs']]):
        pulumi.set(self, "pod_anti_affinity", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 preference: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']]:
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]] = None,
                 match_fields: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]]:
        return pulumi.get(self, "match_fields")

    @match_fields.setter
    def match_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]]):
        pulumi.set(self, "match_fields", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 node_selector_terms: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]] = None):
        if node_selector_terms is not None:
            pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]]:
        return pulumi.get(self, "node_selector_terms")

    @node_selector_terms.setter
    def node_selector_terms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]]):
        pulumi.set(self, "node_selector_terms", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]] = None,
                 match_fields: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]]:
        return pulumi.get(self, "match_fields")

    @match_fields.setter
    def match_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]]):
        pulumi.set(self, "match_fields", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 pod_affinity_term: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]:
        return pulumi.get(self, "pod_affinity_term")

    @pod_affinity_term.setter
    def pod_affinity_term(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]):
        pulumi.set(self, "pod_affinity_term", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 pod_affinity_term: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]:
        return pulumi.get(self, "pod_affinity_term")

    @pod_affinity_term.setter
    def pod_affinity_term(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]):
        pulumi.set(self, "pod_affinity_term", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplatePodDisruptionBudgetArgs:
    def __init__(__self__, *,
                 max_unavailable: Optional[pulumi.Input[int]] = None,
                 metadata: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodDisruptionBudgetMetadataArgs']] = None):
        """
        Template for Kafka MirrorMaker `PodDisruptionBudget`.
        :param pulumi.Input[int] max_unavailable: Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
        :param pulumi.Input['KafkaMirrorMakerSpecTemplatePodDisruptionBudgetMetadataArgs'] metadata: Metadata to apply to the `PodDistruptionBugetTemplate` resource.
        """
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
        """
        return pulumi.get(self, "max_unavailable")

    @max_unavailable.setter
    def max_unavailable(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_unavailable", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodDisruptionBudgetMetadataArgs']]:
        """
        Metadata to apply to the `PodDistruptionBugetTemplate` resource.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodDisruptionBudgetMetadataArgs']]):
        pulumi.set(self, "metadata", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplatePodDisruptionBudgetMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Metadata to apply to the `PodDistruptionBugetTemplate` resource.
        :param pulumi.Input[Mapping[str, Any]] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param pulumi.Input[Mapping[str, Any]] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplatePodHostAliasesArgs:
    def __init__(__self__, *,
                 hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ip: Optional[pulumi.Input[str]] = None):
        if hostnames is not None:
            pulumi.set(__self__, "hostnames", hostnames)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def hostnames(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "hostnames")

    @hostnames.setter
    def hostnames(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hostnames", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplatePodImagePullSecretsArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplatePodMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Metadata applied to the resource.
        :param pulumi.Input[Mapping[str, Any]] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param pulumi.Input[Mapping[str, Any]] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplatePodSecurityContextArgs:
    def __init__(__self__, *,
                 fs_group: Optional[pulumi.Input[int]] = None,
                 fs_group_change_policy: Optional[pulumi.Input[str]] = None,
                 run_as_group: Optional[pulumi.Input[int]] = None,
                 run_as_non_root: Optional[pulumi.Input[bool]] = None,
                 run_as_user: Optional[pulumi.Input[int]] = None,
                 se_linux_options: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodSecurityContextSeLinuxOptionsArgs']] = None,
                 supplemental_groups: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 sysctls: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodSecurityContextSysctlsArgs']]]] = None,
                 windows_options: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodSecurityContextWindowsOptionsArgs']] = None):
        """
        Configures pod-level security attributes and common container settings.
        """
        if fs_group is not None:
            pulumi.set(__self__, "fs_group", fs_group)
        if fs_group_change_policy is not None:
            pulumi.set(__self__, "fs_group_change_policy", fs_group_change_policy)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if supplemental_groups is not None:
            pulumi.set(__self__, "supplemental_groups", supplemental_groups)
        if sysctls is not None:
            pulumi.set(__self__, "sysctls", sysctls)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="fsGroup")
    def fs_group(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "fs_group")

    @fs_group.setter
    def fs_group(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "fs_group", value)

    @property
    @pulumi.getter(name="fsGroupChangePolicy")
    def fs_group_change_policy(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "fs_group_change_policy")

    @fs_group_change_policy.setter
    def fs_group_change_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fs_group_change_policy", value)

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_group")

    @run_as_group.setter
    def run_as_group(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_group", value)

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "run_as_non_root")

    @run_as_non_root.setter
    def run_as_non_root(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_as_non_root", value)

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_user")

    @run_as_user.setter
    def run_as_user(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_user", value)

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodSecurityContextSeLinuxOptionsArgs']]:
        return pulumi.get(self, "se_linux_options")

    @se_linux_options.setter
    def se_linux_options(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodSecurityContextSeLinuxOptionsArgs']]):
        pulumi.set(self, "se_linux_options", value)

    @property
    @pulumi.getter(name="supplementalGroups")
    def supplemental_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        return pulumi.get(self, "supplemental_groups")

    @supplemental_groups.setter
    def supplemental_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "supplemental_groups", value)

    @property
    @pulumi.getter
    def sysctls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodSecurityContextSysctlsArgs']]]]:
        return pulumi.get(self, "sysctls")

    @sysctls.setter
    def sysctls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerSpecTemplatePodSecurityContextSysctlsArgs']]]]):
        pulumi.set(self, "sysctls", value)

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodSecurityContextWindowsOptionsArgs']]:
        return pulumi.get(self, "windows_options")

    @windows_options.setter
    def windows_options(self, value: Optional[pulumi.Input['KafkaMirrorMakerSpecTemplatePodSecurityContextWindowsOptionsArgs']]):
        pulumi.set(self, "windows_options", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplatePodSecurityContextSeLinuxOptionsArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplatePodSecurityContextSysctlsArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplatePodSecurityContextWindowsOptionsArgs:
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[pulumi.Input[str]] = None,
                 gmsa_credential_spec_name: Optional[pulumi.Input[str]] = None,
                 run_as_user_name: Optional[pulumi.Input[str]] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec")

    @gmsa_credential_spec.setter
    def gmsa_credential_spec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec", value)

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @gmsa_credential_spec_name.setter
    def gmsa_credential_spec_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec_name", value)

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "run_as_user_name")

    @run_as_user_name.setter
    def run_as_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "run_as_user_name", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTemplatePodTolerationsArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 toleration_seconds: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if toleration_seconds is not None:
            pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "toleration_seconds")

    @toleration_seconds.setter
    def toleration_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "toleration_seconds", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTolerationsArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 toleration_seconds: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if toleration_seconds is not None:
            pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "toleration_seconds")

    @toleration_seconds.setter
    def toleration_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "toleration_seconds", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaMirrorMakerSpecTracingArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str]):
        """
        The configuration of tracing in Kafka MirrorMaker.
        :param pulumi.Input[str] type: Type of the tracing used. Currently the only supported type is `jaeger` for Jaeger tracing.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the tracing used. Currently the only supported type is `jaeger` for Jaeger tracing.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class KafkaMirrorMakerStatusArgs:
    def __init__(__self__, *,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerStatusConditionsArgs']]]] = None,
                 label_selector: Optional[pulumi.Input[str]] = None,
                 observed_generation: Optional[pulumi.Input[int]] = None,
                 replicas: Optional[pulumi.Input[int]] = None):
        """
        The status of Kafka MirrorMaker.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerStatusConditionsArgs']]] conditions: List of status conditions.
        :param pulumi.Input[str] label_selector: Label selector for pods providing this resource.
        :param pulumi.Input[int] observed_generation: The generation of the CRD that was last reconciled by the operator.
        :param pulumi.Input[int] replicas: The current number of pods being used to provide this resource.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerStatusConditionsArgs']]]]:
        """
        List of status conditions.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaMirrorMakerStatusConditionsArgs']]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input[str]]:
        """
        Label selector for pods providing this resource.
        """
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[pulumi.Input[int]]:
        """
        The generation of the CRD that was last reconciled by the operator.
        """
        return pulumi.get(self, "observed_generation")

    @observed_generation.setter
    def observed_generation(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "observed_generation", value)

    @property
    @pulumi.getter
    def replicas(self) -> Optional[pulumi.Input[int]]:
        """
        The current number of pods being used to provide this resource.
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "replicas", value)


@pulumi.input_type
class KafkaMirrorMakerStatusConditionsArgs:
    def __init__(__self__, *,
                 last_transition_time: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] last_transition_time: Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
        :param pulumi.Input[str] message: Human-readable message indicating details about the condition's last transition.
        :param pulumi.Input[str] reason: The reason for the condition's last transition (a single word in CamelCase).
        :param pulumi.Input[str] status: The status of the condition, either True, False or Unknown.
        :param pulumi.Input[str] type: The unique identifier of a condition, used to distinguish between other conditions in the resource.
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[pulumi.Input[str]]:
        """
        Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
        """
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Human-readable message indicating details about the condition's last transition.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        The reason for the condition's last transition (a single word in CamelCase).
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of the condition, either True, False or Unknown.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The unique identifier of a condition, used to distinguish between other conditions in the resource.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class KafkaSpecArgs:
    def __init__(__self__, *,
                 kafka: pulumi.Input['KafkaSpecKafkaArgs'],
                 zookeeper: pulumi.Input['KafkaSpecZookeeperArgs'],
                 clients_ca: Optional[pulumi.Input['KafkaSpecClientsCaArgs']] = None,
                 cluster_ca: Optional[pulumi.Input['KafkaSpecClusterCaArgs']] = None,
                 cruise_control: Optional[pulumi.Input['KafkaSpecCruiseControlArgs']] = None,
                 entity_operator: Optional[pulumi.Input['KafkaSpecEntityOperatorArgs']] = None,
                 jmx_trans: Optional[pulumi.Input['KafkaSpecJmxTransArgs']] = None,
                 kafka_exporter: Optional[pulumi.Input['KafkaSpecKafkaExporterArgs']] = None,
                 maintenance_time_windows: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topic_operator: Optional[pulumi.Input['KafkaSpecTopicOperatorArgs']] = None):
        """
        The specification of the Kafka and ZooKeeper clusters, and Topic Operator.
        :param pulumi.Input['KafkaSpecKafkaArgs'] kafka: Configuration of the Kafka cluster.
        :param pulumi.Input['KafkaSpecZookeeperArgs'] zookeeper: Configuration of the ZooKeeper cluster.
        :param pulumi.Input['KafkaSpecClientsCaArgs'] clients_ca: Configuration of the clients certificate authority.
        :param pulumi.Input['KafkaSpecClusterCaArgs'] cluster_ca: Configuration of the cluster certificate authority.
        :param pulumi.Input['KafkaSpecCruiseControlArgs'] cruise_control: Configuration for Cruise Control deployment. Deploys a Cruise Control instance when specified.
        :param pulumi.Input['KafkaSpecEntityOperatorArgs'] entity_operator: Configuration of the Entity Operator.
        :param pulumi.Input['KafkaSpecJmxTransArgs'] jmx_trans: Configuration for JmxTrans. When the property is present a JmxTrans deployment is created for gathering JMX metrics from each Kafka broker. For more information see https://github.com/jmxtrans/jmxtrans[JmxTrans GitHub].
        :param pulumi.Input['KafkaSpecKafkaExporterArgs'] kafka_exporter: Configuration of the Kafka Exporter. Kafka Exporter can provide additional metrics, for example lag of consumer group at topic/partition.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] maintenance_time_windows: A list of time windows for maintenance tasks (that is, certificates renewal). Each time window is defined by a cron expression.
        :param pulumi.Input['KafkaSpecTopicOperatorArgs'] topic_operator: Configuration of the Topic Operator.
        """
        pulumi.set(__self__, "kafka", kafka)
        pulumi.set(__self__, "zookeeper", zookeeper)
        if clients_ca is not None:
            pulumi.set(__self__, "clients_ca", clients_ca)
        if cluster_ca is not None:
            pulumi.set(__self__, "cluster_ca", cluster_ca)
        if cruise_control is not None:
            pulumi.set(__self__, "cruise_control", cruise_control)
        if entity_operator is not None:
            pulumi.set(__self__, "entity_operator", entity_operator)
        if jmx_trans is not None:
            pulumi.set(__self__, "jmx_trans", jmx_trans)
        if kafka_exporter is not None:
            pulumi.set(__self__, "kafka_exporter", kafka_exporter)
        if maintenance_time_windows is not None:
            pulumi.set(__self__, "maintenance_time_windows", maintenance_time_windows)
        if topic_operator is not None:
            pulumi.set(__self__, "topic_operator", topic_operator)

    @property
    @pulumi.getter
    def kafka(self) -> pulumi.Input['KafkaSpecKafkaArgs']:
        """
        Configuration of the Kafka cluster.
        """
        return pulumi.get(self, "kafka")

    @kafka.setter
    def kafka(self, value: pulumi.Input['KafkaSpecKafkaArgs']):
        pulumi.set(self, "kafka", value)

    @property
    @pulumi.getter
    def zookeeper(self) -> pulumi.Input['KafkaSpecZookeeperArgs']:
        """
        Configuration of the ZooKeeper cluster.
        """
        return pulumi.get(self, "zookeeper")

    @zookeeper.setter
    def zookeeper(self, value: pulumi.Input['KafkaSpecZookeeperArgs']):
        pulumi.set(self, "zookeeper", value)

    @property
    @pulumi.getter(name="clientsCa")
    def clients_ca(self) -> Optional[pulumi.Input['KafkaSpecClientsCaArgs']]:
        """
        Configuration of the clients certificate authority.
        """
        return pulumi.get(self, "clients_ca")

    @clients_ca.setter
    def clients_ca(self, value: Optional[pulumi.Input['KafkaSpecClientsCaArgs']]):
        pulumi.set(self, "clients_ca", value)

    @property
    @pulumi.getter(name="clusterCa")
    def cluster_ca(self) -> Optional[pulumi.Input['KafkaSpecClusterCaArgs']]:
        """
        Configuration of the cluster certificate authority.
        """
        return pulumi.get(self, "cluster_ca")

    @cluster_ca.setter
    def cluster_ca(self, value: Optional[pulumi.Input['KafkaSpecClusterCaArgs']]):
        pulumi.set(self, "cluster_ca", value)

    @property
    @pulumi.getter(name="cruiseControl")
    def cruise_control(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlArgs']]:
        """
        Configuration for Cruise Control deployment. Deploys a Cruise Control instance when specified.
        """
        return pulumi.get(self, "cruise_control")

    @cruise_control.setter
    def cruise_control(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlArgs']]):
        pulumi.set(self, "cruise_control", value)

    @property
    @pulumi.getter(name="entityOperator")
    def entity_operator(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorArgs']]:
        """
        Configuration of the Entity Operator.
        """
        return pulumi.get(self, "entity_operator")

    @entity_operator.setter
    def entity_operator(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorArgs']]):
        pulumi.set(self, "entity_operator", value)

    @property
    @pulumi.getter(name="jmxTrans")
    def jmx_trans(self) -> Optional[pulumi.Input['KafkaSpecJmxTransArgs']]:
        """
        Configuration for JmxTrans. When the property is present a JmxTrans deployment is created for gathering JMX metrics from each Kafka broker. For more information see https://github.com/jmxtrans/jmxtrans[JmxTrans GitHub].
        """
        return pulumi.get(self, "jmx_trans")

    @jmx_trans.setter
    def jmx_trans(self, value: Optional[pulumi.Input['KafkaSpecJmxTransArgs']]):
        pulumi.set(self, "jmx_trans", value)

    @property
    @pulumi.getter(name="kafkaExporter")
    def kafka_exporter(self) -> Optional[pulumi.Input['KafkaSpecKafkaExporterArgs']]:
        """
        Configuration of the Kafka Exporter. Kafka Exporter can provide additional metrics, for example lag of consumer group at topic/partition.
        """
        return pulumi.get(self, "kafka_exporter")

    @kafka_exporter.setter
    def kafka_exporter(self, value: Optional[pulumi.Input['KafkaSpecKafkaExporterArgs']]):
        pulumi.set(self, "kafka_exporter", value)

    @property
    @pulumi.getter(name="maintenanceTimeWindows")
    def maintenance_time_windows(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of time windows for maintenance tasks (that is, certificates renewal). Each time window is defined by a cron expression.
        """
        return pulumi.get(self, "maintenance_time_windows")

    @maintenance_time_windows.setter
    def maintenance_time_windows(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "maintenance_time_windows", value)

    @property
    @pulumi.getter(name="topicOperator")
    def topic_operator(self) -> Optional[pulumi.Input['KafkaSpecTopicOperatorArgs']]:
        """
        Configuration of the Topic Operator.
        """
        return pulumi.get(self, "topic_operator")

    @topic_operator.setter
    def topic_operator(self, value: Optional[pulumi.Input['KafkaSpecTopicOperatorArgs']]):
        pulumi.set(self, "topic_operator", value)


@pulumi.input_type
class KafkaSpecClientsCaArgs:
    def __init__(__self__, *,
                 certificate_expiration_policy: Optional[pulumi.Input[str]] = None,
                 generate_certificate_authority: Optional[pulumi.Input[bool]] = None,
                 renewal_days: Optional[pulumi.Input[int]] = None,
                 validity_days: Optional[pulumi.Input[int]] = None):
        """
        Configuration of the clients certificate authority.
        :param pulumi.Input[str] certificate_expiration_policy: How should CA certificate expiration be handled when `generateCertificateAuthority=true`. The default is for a new CA certificate to be generated reusing the existing private key.
        :param pulumi.Input[bool] generate_certificate_authority: If true then Certificate Authority certificates will be generated automatically. Otherwise the user will need to provide a Secret with the CA certificate. Default is true.
        :param pulumi.Input[int] renewal_days: The number of days in the certificate renewal period. This is the number of days before the a certificate expires during which renewal actions may be performed. When `generateCertificateAuthority` is true, this will cause the generation of a new certificate. When `generateCertificateAuthority` is true, this will cause extra logging at WARN level about the pending certificate expiry. Default is 30.
        :param pulumi.Input[int] validity_days: The number of days generated certificates should be valid for. The default is 365.
        """
        if certificate_expiration_policy is not None:
            pulumi.set(__self__, "certificate_expiration_policy", certificate_expiration_policy)
        if generate_certificate_authority is not None:
            pulumi.set(__self__, "generate_certificate_authority", generate_certificate_authority)
        if renewal_days is not None:
            pulumi.set(__self__, "renewal_days", renewal_days)
        if validity_days is not None:
            pulumi.set(__self__, "validity_days", validity_days)

    @property
    @pulumi.getter(name="certificateExpirationPolicy")
    def certificate_expiration_policy(self) -> Optional[pulumi.Input[str]]:
        """
        How should CA certificate expiration be handled when `generateCertificateAuthority=true`. The default is for a new CA certificate to be generated reusing the existing private key.
        """
        return pulumi.get(self, "certificate_expiration_policy")

    @certificate_expiration_policy.setter
    def certificate_expiration_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_expiration_policy", value)

    @property
    @pulumi.getter(name="generateCertificateAuthority")
    def generate_certificate_authority(self) -> Optional[pulumi.Input[bool]]:
        """
        If true then Certificate Authority certificates will be generated automatically. Otherwise the user will need to provide a Secret with the CA certificate. Default is true.
        """
        return pulumi.get(self, "generate_certificate_authority")

    @generate_certificate_authority.setter
    def generate_certificate_authority(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "generate_certificate_authority", value)

    @property
    @pulumi.getter(name="renewalDays")
    def renewal_days(self) -> Optional[pulumi.Input[int]]:
        """
        The number of days in the certificate renewal period. This is the number of days before the a certificate expires during which renewal actions may be performed. When `generateCertificateAuthority` is true, this will cause the generation of a new certificate. When `generateCertificateAuthority` is true, this will cause extra logging at WARN level about the pending certificate expiry. Default is 30.
        """
        return pulumi.get(self, "renewal_days")

    @renewal_days.setter
    def renewal_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "renewal_days", value)

    @property
    @pulumi.getter(name="validityDays")
    def validity_days(self) -> Optional[pulumi.Input[int]]:
        """
        The number of days generated certificates should be valid for. The default is 365.
        """
        return pulumi.get(self, "validity_days")

    @validity_days.setter
    def validity_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "validity_days", value)


@pulumi.input_type
class KafkaSpecClusterCaArgs:
    def __init__(__self__, *,
                 certificate_expiration_policy: Optional[pulumi.Input[str]] = None,
                 generate_certificate_authority: Optional[pulumi.Input[bool]] = None,
                 renewal_days: Optional[pulumi.Input[int]] = None,
                 validity_days: Optional[pulumi.Input[int]] = None):
        """
        Configuration of the cluster certificate authority.
        :param pulumi.Input[str] certificate_expiration_policy: How should CA certificate expiration be handled when `generateCertificateAuthority=true`. The default is for a new CA certificate to be generated reusing the existing private key.
        :param pulumi.Input[bool] generate_certificate_authority: If true then Certificate Authority certificates will be generated automatically. Otherwise the user will need to provide a Secret with the CA certificate. Default is true.
        :param pulumi.Input[int] renewal_days: The number of days in the certificate renewal period. This is the number of days before the a certificate expires during which renewal actions may be performed. When `generateCertificateAuthority` is true, this will cause the generation of a new certificate. When `generateCertificateAuthority` is true, this will cause extra logging at WARN level about the pending certificate expiry. Default is 30.
        :param pulumi.Input[int] validity_days: The number of days generated certificates should be valid for. The default is 365.
        """
        if certificate_expiration_policy is not None:
            pulumi.set(__self__, "certificate_expiration_policy", certificate_expiration_policy)
        if generate_certificate_authority is not None:
            pulumi.set(__self__, "generate_certificate_authority", generate_certificate_authority)
        if renewal_days is not None:
            pulumi.set(__self__, "renewal_days", renewal_days)
        if validity_days is not None:
            pulumi.set(__self__, "validity_days", validity_days)

    @property
    @pulumi.getter(name="certificateExpirationPolicy")
    def certificate_expiration_policy(self) -> Optional[pulumi.Input[str]]:
        """
        How should CA certificate expiration be handled when `generateCertificateAuthority=true`. The default is for a new CA certificate to be generated reusing the existing private key.
        """
        return pulumi.get(self, "certificate_expiration_policy")

    @certificate_expiration_policy.setter
    def certificate_expiration_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_expiration_policy", value)

    @property
    @pulumi.getter(name="generateCertificateAuthority")
    def generate_certificate_authority(self) -> Optional[pulumi.Input[bool]]:
        """
        If true then Certificate Authority certificates will be generated automatically. Otherwise the user will need to provide a Secret with the CA certificate. Default is true.
        """
        return pulumi.get(self, "generate_certificate_authority")

    @generate_certificate_authority.setter
    def generate_certificate_authority(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "generate_certificate_authority", value)

    @property
    @pulumi.getter(name="renewalDays")
    def renewal_days(self) -> Optional[pulumi.Input[int]]:
        """
        The number of days in the certificate renewal period. This is the number of days before the a certificate expires during which renewal actions may be performed. When `generateCertificateAuthority` is true, this will cause the generation of a new certificate. When `generateCertificateAuthority` is true, this will cause extra logging at WARN level about the pending certificate expiry. Default is 30.
        """
        return pulumi.get(self, "renewal_days")

    @renewal_days.setter
    def renewal_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "renewal_days", value)

    @property
    @pulumi.getter(name="validityDays")
    def validity_days(self) -> Optional[pulumi.Input[int]]:
        """
        The number of days generated certificates should be valid for. The default is 365.
        """
        return pulumi.get(self, "validity_days")

    @validity_days.setter
    def validity_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "validity_days", value)


@pulumi.input_type
class KafkaSpecCruiseControlArgs:
    def __init__(__self__, *,
                 broker_capacity: Optional[pulumi.Input['KafkaSpecCruiseControlBrokerCapacityArgs']] = None,
                 config: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 image: Optional[pulumi.Input[str]] = None,
                 jvm_options: Optional[pulumi.Input['KafkaSpecCruiseControlJvmOptionsArgs']] = None,
                 liveness_probe: Optional[pulumi.Input['KafkaSpecCruiseControlLivenessProbeArgs']] = None,
                 logging: Optional[pulumi.Input['KafkaSpecCruiseControlLoggingArgs']] = None,
                 metrics: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 readiness_probe: Optional[pulumi.Input['KafkaSpecCruiseControlReadinessProbeArgs']] = None,
                 resources: Optional[pulumi.Input['KafkaSpecCruiseControlResourcesArgs']] = None,
                 template: Optional[pulumi.Input['KafkaSpecCruiseControlTemplateArgs']] = None,
                 tls_sidecar: Optional[pulumi.Input['KafkaSpecCruiseControlTlsSidecarArgs']] = None):
        """
        Configuration for Cruise Control deployment. Deploys a Cruise Control instance when specified.
        :param pulumi.Input['KafkaSpecCruiseControlBrokerCapacityArgs'] broker_capacity: The Cruise Control `brokerCapacity` configuration.
        :param pulumi.Input[Mapping[str, Any]] config: The Cruise Control configuration. For a full list of configuration options refer to https://github.com/linkedin/cruise-control/wiki/Configurations. Note that properties with the following prefixes cannot be set: bootstrap.servers, client.id, zookeeper., network., security., failed.brokers.zk.path,webserver.http., webserver.api.urlprefix, webserver.session.path, webserver.accesslog., two.step., request.reason.required,metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, partition.metric.sample.store.topic, broker.metric.sample.store.topic,capacity.config.file, self.healing., anomaly.detection., ssl.
        :param pulumi.Input[str] image: The docker image for the pods.
        :param pulumi.Input['KafkaSpecCruiseControlJvmOptionsArgs'] jvm_options: JVM Options for the Cruise Control container.
        :param pulumi.Input['KafkaSpecCruiseControlLivenessProbeArgs'] liveness_probe: Pod liveness checking for the Cruise Control container.
        :param pulumi.Input['KafkaSpecCruiseControlLoggingArgs'] logging: Logging configuration (log4j1) for Cruise Control.
        :param pulumi.Input[Mapping[str, Any]] metrics: The Prometheus JMX Exporter configuration. See https://github.com/prometheus/jmx_exporter for details of the structure of this configuration.
        :param pulumi.Input['KafkaSpecCruiseControlReadinessProbeArgs'] readiness_probe: Pod readiness checking for the Cruise Control container.
        :param pulumi.Input['KafkaSpecCruiseControlResourcesArgs'] resources: CPU and memory resources to reserve for the Cruise Control container.
        :param pulumi.Input['KafkaSpecCruiseControlTemplateArgs'] template: Template to specify how Cruise Control resources, `Deployments` and `Pods`, are generated.
        :param pulumi.Input['KafkaSpecCruiseControlTlsSidecarArgs'] tls_sidecar: TLS sidecar configuration.
        """
        if broker_capacity is not None:
            pulumi.set(__self__, "broker_capacity", broker_capacity)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if jvm_options is not None:
            pulumi.set(__self__, "jvm_options", jvm_options)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if template is not None:
            pulumi.set(__self__, "template", template)
        if tls_sidecar is not None:
            pulumi.set(__self__, "tls_sidecar", tls_sidecar)

    @property
    @pulumi.getter(name="brokerCapacity")
    def broker_capacity(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlBrokerCapacityArgs']]:
        """
        The Cruise Control `brokerCapacity` configuration.
        """
        return pulumi.get(self, "broker_capacity")

    @broker_capacity.setter
    def broker_capacity(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlBrokerCapacityArgs']]):
        pulumi.set(self, "broker_capacity", value)

    @property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        The Cruise Control configuration. For a full list of configuration options refer to https://github.com/linkedin/cruise-control/wiki/Configurations. Note that properties with the following prefixes cannot be set: bootstrap.servers, client.id, zookeeper., network., security., failed.brokers.zk.path,webserver.http., webserver.api.urlprefix, webserver.session.path, webserver.accesslog., two.step., request.reason.required,metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, partition.metric.sample.store.topic, broker.metric.sample.store.topic,capacity.config.file, self.healing., anomaly.detection., ssl.
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "config", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        The docker image for the pods.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="jvmOptions")
    def jvm_options(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlJvmOptionsArgs']]:
        """
        JVM Options for the Cruise Control container.
        """
        return pulumi.get(self, "jvm_options")

    @jvm_options.setter
    def jvm_options(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlJvmOptionsArgs']]):
        pulumi.set(self, "jvm_options", value)

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlLivenessProbeArgs']]:
        """
        Pod liveness checking for the Cruise Control container.
        """
        return pulumi.get(self, "liveness_probe")

    @liveness_probe.setter
    def liveness_probe(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlLivenessProbeArgs']]):
        pulumi.set(self, "liveness_probe", value)

    @property
    @pulumi.getter
    def logging(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlLoggingArgs']]:
        """
        Logging configuration (log4j1) for Cruise Control.
        """
        return pulumi.get(self, "logging")

    @logging.setter
    def logging(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlLoggingArgs']]):
        pulumi.set(self, "logging", value)

    @property
    @pulumi.getter
    def metrics(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        The Prometheus JMX Exporter configuration. See https://github.com/prometheus/jmx_exporter for details of the structure of this configuration.
        """
        return pulumi.get(self, "metrics")

    @metrics.setter
    def metrics(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "metrics", value)

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlReadinessProbeArgs']]:
        """
        Pod readiness checking for the Cruise Control container.
        """
        return pulumi.get(self, "readiness_probe")

    @readiness_probe.setter
    def readiness_probe(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlReadinessProbeArgs']]):
        pulumi.set(self, "readiness_probe", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlResourcesArgs']]:
        """
        CPU and memory resources to reserve for the Cruise Control container.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlResourcesArgs']]):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter
    def template(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlTemplateArgs']]:
        """
        Template to specify how Cruise Control resources, `Deployments` and `Pods`, are generated.
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlTemplateArgs']]):
        pulumi.set(self, "template", value)

    @property
    @pulumi.getter(name="tlsSidecar")
    def tls_sidecar(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlTlsSidecarArgs']]:
        """
        TLS sidecar configuration.
        """
        return pulumi.get(self, "tls_sidecar")

    @tls_sidecar.setter
    def tls_sidecar(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlTlsSidecarArgs']]):
        pulumi.set(self, "tls_sidecar", value)


@pulumi.input_type
class KafkaSpecCruiseControlBrokerCapacityArgs:
    def __init__(__self__, *,
                 cpu_utilization: Optional[pulumi.Input[int]] = None,
                 disk: Optional[pulumi.Input[str]] = None,
                 inbound_network: Optional[pulumi.Input[str]] = None,
                 outbound_network: Optional[pulumi.Input[str]] = None):
        """
        The Cruise Control `brokerCapacity` configuration.
        :param pulumi.Input[int] cpu_utilization: Broker capacity for CPU resource utilization as a percentage (0 - 100).
        :param pulumi.Input[str] disk: Broker capacity for disk in bytes, for example, 100Gi.
        :param pulumi.Input[str] inbound_network: Broker capacity for inbound network throughput in bytes per second, for example, 10000KB/s.
        :param pulumi.Input[str] outbound_network: Broker capacity for outbound network throughput in bytes per second, for example 10000KB/s.
        """
        if cpu_utilization is not None:
            pulumi.set(__self__, "cpu_utilization", cpu_utilization)
        if disk is not None:
            pulumi.set(__self__, "disk", disk)
        if inbound_network is not None:
            pulumi.set(__self__, "inbound_network", inbound_network)
        if outbound_network is not None:
            pulumi.set(__self__, "outbound_network", outbound_network)

    @property
    @pulumi.getter(name="cpuUtilization")
    def cpu_utilization(self) -> Optional[pulumi.Input[int]]:
        """
        Broker capacity for CPU resource utilization as a percentage (0 - 100).
        """
        return pulumi.get(self, "cpu_utilization")

    @cpu_utilization.setter
    def cpu_utilization(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cpu_utilization", value)

    @property
    @pulumi.getter
    def disk(self) -> Optional[pulumi.Input[str]]:
        """
        Broker capacity for disk in bytes, for example, 100Gi.
        """
        return pulumi.get(self, "disk")

    @disk.setter
    def disk(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk", value)

    @property
    @pulumi.getter(name="inboundNetwork")
    def inbound_network(self) -> Optional[pulumi.Input[str]]:
        """
        Broker capacity for inbound network throughput in bytes per second, for example, 10000KB/s.
        """
        return pulumi.get(self, "inbound_network")

    @inbound_network.setter
    def inbound_network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "inbound_network", value)

    @property
    @pulumi.getter(name="outboundNetwork")
    def outbound_network(self) -> Optional[pulumi.Input[str]]:
        """
        Broker capacity for outbound network throughput in bytes per second, for example 10000KB/s.
        """
        return pulumi.get(self, "outbound_network")

    @outbound_network.setter
    def outbound_network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "outbound_network", value)


@pulumi.input_type
class KafkaSpecCruiseControlJvmOptionsArgs:
    def __init__(__self__, *,
                 __xx: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 __xms: Optional[pulumi.Input[str]] = None,
                 __xmx: Optional[pulumi.Input[str]] = None,
                 gc_logging_enabled: Optional[pulumi.Input[bool]] = None,
                 java_system_properties: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlJvmOptionsJavaSystemPropertiesArgs']]]] = None):
        """
        JVM Options for the Cruise Control container.
        :param pulumi.Input[Mapping[str, Any]] __xx: A map of -XX options to the JVM.
        :param pulumi.Input[str] __xms: -Xms option to to the JVM.
        :param pulumi.Input[str] __xmx: -Xmx option to to the JVM.
        :param pulumi.Input[bool] gc_logging_enabled: Specifies whether the Garbage Collection logging is enabled. The default is false.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlJvmOptionsJavaSystemPropertiesArgs']]] java_system_properties: A map of additional system properties which will be passed using the `-D` option to the JVM.
        """
        if __xx is not None:
            pulumi.set(__self__, "__xx", __xx)
        if __xms is not None:
            pulumi.set(__self__, "__xms", __xms)
        if __xmx is not None:
            pulumi.set(__self__, "__xmx", __xmx)
        if gc_logging_enabled is not None:
            pulumi.set(__self__, "gc_logging_enabled", gc_logging_enabled)
        if java_system_properties is not None:
            pulumi.set(__self__, "java_system_properties", java_system_properties)

    @property
    @pulumi.getter(name="-XX")
    def __xx(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        A map of -XX options to the JVM.
        """
        return pulumi.get(self, "__xx")

    @__xx.setter
    def __xx(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "__xx", value)

    @property
    @pulumi.getter(name="-Xms")
    def __xms(self) -> Optional[pulumi.Input[str]]:
        """
        -Xms option to to the JVM.
        """
        return pulumi.get(self, "__xms")

    @__xms.setter
    def __xms(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "__xms", value)

    @property
    @pulumi.getter(name="-Xmx")
    def __xmx(self) -> Optional[pulumi.Input[str]]:
        """
        -Xmx option to to the JVM.
        """
        return pulumi.get(self, "__xmx")

    @__xmx.setter
    def __xmx(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "__xmx", value)

    @property
    @pulumi.getter(name="gcLoggingEnabled")
    def gc_logging_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether the Garbage Collection logging is enabled. The default is false.
        """
        return pulumi.get(self, "gc_logging_enabled")

    @gc_logging_enabled.setter
    def gc_logging_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "gc_logging_enabled", value)

    @property
    @pulumi.getter(name="javaSystemProperties")
    def java_system_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlJvmOptionsJavaSystemPropertiesArgs']]]]:
        """
        A map of additional system properties which will be passed using the `-D` option to the JVM.
        """
        return pulumi.get(self, "java_system_properties")

    @java_system_properties.setter
    def java_system_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlJvmOptionsJavaSystemPropertiesArgs']]]]):
        pulumi.set(self, "java_system_properties", value)


@pulumi.input_type
class KafkaSpecCruiseControlJvmOptionsJavaSystemPropertiesArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The system property name.
        :param pulumi.Input[str] value: The system property value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The system property name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The system property value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaSpecCruiseControlLivenessProbeArgs:
    def __init__(__self__, *,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 success_threshold: Optional[pulumi.Input[int]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        Pod liveness checking for the Cruise Control container.
        :param pulumi.Input[int] failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param pulumi.Input[int] initial_delay_seconds: The initial delay before first the health is first checked.
        :param pulumi.Input[int] period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param pulumi.Input[int] success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param pulumi.Input[int] timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "success_threshold", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


@pulumi.input_type
class KafkaSpecCruiseControlLoggingArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 loggers: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        Logging configuration (log4j1) for Cruise Control.
        :param pulumi.Input[str] type: Logging type, must be either 'inline' or 'external'.
        :param pulumi.Input[Mapping[str, Any]] loggers: A Map from logger name to logger level.
        :param pulumi.Input[str] name: The name of the `ConfigMap` from which to get the logging configuration.
        """
        pulumi.set(__self__, "type", type)
        if loggers is not None:
            pulumi.set(__self__, "loggers", loggers)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Logging type, must be either 'inline' or 'external'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def loggers(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        A Map from logger name to logger level.
        """
        return pulumi.get(self, "loggers")

    @loggers.setter
    def loggers(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "loggers", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the `ConfigMap` from which to get the logging configuration.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class KafkaSpecCruiseControlReadinessProbeArgs:
    def __init__(__self__, *,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 success_threshold: Optional[pulumi.Input[int]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        Pod readiness checking for the Cruise Control container.
        :param pulumi.Input[int] failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param pulumi.Input[int] initial_delay_seconds: The initial delay before first the health is first checked.
        :param pulumi.Input[int] period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param pulumi.Input[int] success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param pulumi.Input[int] timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "success_threshold", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


@pulumi.input_type
class KafkaSpecCruiseControlResourcesArgs:
    def __init__(__self__, *,
                 limits: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 requests: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        CPU and memory resources to reserve for the Cruise Control container.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "limits", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "requests", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplateArgs:
    def __init__(__self__, *,
                 api_service: Optional[pulumi.Input['KafkaSpecCruiseControlTemplateApiServiceArgs']] = None,
                 cruise_control_container: Optional[pulumi.Input['KafkaSpecCruiseControlTemplateCruiseControlContainerArgs']] = None,
                 deployment: Optional[pulumi.Input['KafkaSpecCruiseControlTemplateDeploymentArgs']] = None,
                 pod: Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodArgs']] = None,
                 pod_disruption_budget: Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodDisruptionBudgetArgs']] = None,
                 tls_sidecar_container: Optional[pulumi.Input['KafkaSpecCruiseControlTemplateTlsSidecarContainerArgs']] = None):
        """
        Template to specify how Cruise Control resources, `Deployments` and `Pods`, are generated.
        :param pulumi.Input['KafkaSpecCruiseControlTemplateApiServiceArgs'] api_service: Template for Cruise Control API `Service`.
        :param pulumi.Input['KafkaSpecCruiseControlTemplateCruiseControlContainerArgs'] cruise_control_container: Template for the Cruise Control container.
        :param pulumi.Input['KafkaSpecCruiseControlTemplateDeploymentArgs'] deployment: Template for Cruise Control `Deployment`.
        :param pulumi.Input['KafkaSpecCruiseControlTemplatePodArgs'] pod: Template for Cruise Control `Pods`.
        :param pulumi.Input['KafkaSpecCruiseControlTemplatePodDisruptionBudgetArgs'] pod_disruption_budget: Template for Cruise Control `PodDisruptionBudget`.
        :param pulumi.Input['KafkaSpecCruiseControlTemplateTlsSidecarContainerArgs'] tls_sidecar_container: Template for the Cruise Control TLS sidecar container.
        """
        if api_service is not None:
            pulumi.set(__self__, "api_service", api_service)
        if cruise_control_container is not None:
            pulumi.set(__self__, "cruise_control_container", cruise_control_container)
        if deployment is not None:
            pulumi.set(__self__, "deployment", deployment)
        if pod is not None:
            pulumi.set(__self__, "pod", pod)
        if pod_disruption_budget is not None:
            pulumi.set(__self__, "pod_disruption_budget", pod_disruption_budget)
        if tls_sidecar_container is not None:
            pulumi.set(__self__, "tls_sidecar_container", tls_sidecar_container)

    @property
    @pulumi.getter(name="apiService")
    def api_service(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlTemplateApiServiceArgs']]:
        """
        Template for Cruise Control API `Service`.
        """
        return pulumi.get(self, "api_service")

    @api_service.setter
    def api_service(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlTemplateApiServiceArgs']]):
        pulumi.set(self, "api_service", value)

    @property
    @pulumi.getter(name="cruiseControlContainer")
    def cruise_control_container(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlTemplateCruiseControlContainerArgs']]:
        """
        Template for the Cruise Control container.
        """
        return pulumi.get(self, "cruise_control_container")

    @cruise_control_container.setter
    def cruise_control_container(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlTemplateCruiseControlContainerArgs']]):
        pulumi.set(self, "cruise_control_container", value)

    @property
    @pulumi.getter
    def deployment(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlTemplateDeploymentArgs']]:
        """
        Template for Cruise Control `Deployment`.
        """
        return pulumi.get(self, "deployment")

    @deployment.setter
    def deployment(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlTemplateDeploymentArgs']]):
        pulumi.set(self, "deployment", value)

    @property
    @pulumi.getter
    def pod(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodArgs']]:
        """
        Template for Cruise Control `Pods`.
        """
        return pulumi.get(self, "pod")

    @pod.setter
    def pod(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodArgs']]):
        pulumi.set(self, "pod", value)

    @property
    @pulumi.getter(name="podDisruptionBudget")
    def pod_disruption_budget(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodDisruptionBudgetArgs']]:
        """
        Template for Cruise Control `PodDisruptionBudget`.
        """
        return pulumi.get(self, "pod_disruption_budget")

    @pod_disruption_budget.setter
    def pod_disruption_budget(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodDisruptionBudgetArgs']]):
        pulumi.set(self, "pod_disruption_budget", value)

    @property
    @pulumi.getter(name="tlsSidecarContainer")
    def tls_sidecar_container(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlTemplateTlsSidecarContainerArgs']]:
        """
        Template for the Cruise Control TLS sidecar container.
        """
        return pulumi.get(self, "tls_sidecar_container")

    @tls_sidecar_container.setter
    def tls_sidecar_container(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlTemplateTlsSidecarContainerArgs']]):
        pulumi.set(self, "tls_sidecar_container", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplateApiServiceArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input['KafkaSpecCruiseControlTemplateApiServiceMetadataArgs']] = None):
        """
        Template for Cruise Control API `Service`.
        :param pulumi.Input['KafkaSpecCruiseControlTemplateApiServiceMetadataArgs'] metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlTemplateApiServiceMetadataArgs']]:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlTemplateApiServiceMetadataArgs']]):
        pulumi.set(self, "metadata", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplateApiServiceMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Metadata applied to the resource.
        :param pulumi.Input[Mapping[str, Any]] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param pulumi.Input[Mapping[str, Any]] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplateCruiseControlContainerArgs:
    def __init__(__self__, *,
                 env: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplateCruiseControlContainerEnvArgs']]]] = None,
                 security_context: Optional[pulumi.Input['KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextArgs']] = None):
        """
        Template for the Cruise Control container.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplateCruiseControlContainerEnvArgs']]] env: Environment variables which should be applied to the container.
        :param pulumi.Input['KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextArgs'] security_context: Security context for the container.
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)

    @property
    @pulumi.getter
    def env(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplateCruiseControlContainerEnvArgs']]]]:
        """
        Environment variables which should be applied to the container.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplateCruiseControlContainerEnvArgs']]]]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextArgs']]:
        """
        Security context for the container.
        """
        return pulumi.get(self, "security_context")

    @security_context.setter
    def security_context(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextArgs']]):
        pulumi.set(self, "security_context", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplateCruiseControlContainerEnvArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The environment variable key.
        :param pulumi.Input[str] value: The environment variable value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The environment variable key.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The environment variable value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextArgs:
    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[pulumi.Input[bool]] = None,
                 capabilities: Optional[pulumi.Input['KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextCapabilitiesArgs']] = None,
                 privileged: Optional[pulumi.Input[bool]] = None,
                 proc_mount: Optional[pulumi.Input[str]] = None,
                 read_only_root_filesystem: Optional[pulumi.Input[bool]] = None,
                 run_as_group: Optional[pulumi.Input[int]] = None,
                 run_as_non_root: Optional[pulumi.Input[bool]] = None,
                 run_as_user: Optional[pulumi.Input[int]] = None,
                 se_linux_options: Optional[pulumi.Input['KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptionsArgs']] = None,
                 windows_options: Optional[pulumi.Input['KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptionsArgs']] = None):
        """
        Security context for the container.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if proc_mount is not None:
            pulumi.set(__self__, "proc_mount", proc_mount)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "allow_privilege_escalation")

    @allow_privilege_escalation.setter
    def allow_privilege_escalation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_privilege_escalation", value)

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextCapabilitiesArgs']]:
        return pulumi.get(self, "capabilities")

    @capabilities.setter
    def capabilities(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextCapabilitiesArgs']]):
        pulumi.set(self, "capabilities", value)

    @property
    @pulumi.getter
    def privileged(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "privileged")

    @privileged.setter
    def privileged(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "privileged", value)

    @property
    @pulumi.getter(name="procMount")
    def proc_mount(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "proc_mount")

    @proc_mount.setter
    def proc_mount(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proc_mount", value)

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "read_only_root_filesystem")

    @read_only_root_filesystem.setter
    def read_only_root_filesystem(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "read_only_root_filesystem", value)

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_group")

    @run_as_group.setter
    def run_as_group(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_group", value)

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "run_as_non_root")

    @run_as_non_root.setter
    def run_as_non_root(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_as_non_root", value)

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_user")

    @run_as_user.setter
    def run_as_user(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_user", value)

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptionsArgs']]:
        return pulumi.get(self, "se_linux_options")

    @se_linux_options.setter
    def se_linux_options(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptionsArgs']]):
        pulumi.set(self, "se_linux_options", value)

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptionsArgs']]:
        return pulumi.get(self, "windows_options")

    @windows_options.setter
    def windows_options(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptionsArgs']]):
        pulumi.set(self, "windows_options", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextCapabilitiesArgs:
    def __init__(__self__, *,
                 add: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 drop: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)

    @property
    @pulumi.getter
    def add(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "add")

    @add.setter
    def add(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "add", value)

    @property
    @pulumi.getter
    def drop(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "drop")

    @drop.setter
    def drop(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "drop", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptionsArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptionsArgs:
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[pulumi.Input[str]] = None,
                 gmsa_credential_spec_name: Optional[pulumi.Input[str]] = None,
                 run_as_user_name: Optional[pulumi.Input[str]] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec")

    @gmsa_credential_spec.setter
    def gmsa_credential_spec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec", value)

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @gmsa_credential_spec_name.setter
    def gmsa_credential_spec_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec_name", value)

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "run_as_user_name")

    @run_as_user_name.setter
    def run_as_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "run_as_user_name", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplateDeploymentArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input['KafkaSpecCruiseControlTemplateDeploymentMetadataArgs']] = None):
        """
        Template for Cruise Control `Deployment`.
        :param pulumi.Input['KafkaSpecCruiseControlTemplateDeploymentMetadataArgs'] metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlTemplateDeploymentMetadataArgs']]:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlTemplateDeploymentMetadataArgs']]):
        pulumi.set(self, "metadata", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplateDeploymentMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Metadata applied to the resource.
        :param pulumi.Input[Mapping[str, Any]] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param pulumi.Input[Mapping[str, Any]] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplatePodArgs:
    def __init__(__self__, *,
                 affinity: Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityArgs']] = None,
                 host_aliases: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodHostAliasesArgs']]]] = None,
                 image_pull_secrets: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodImagePullSecretsArgs']]]] = None,
                 metadata: Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodMetadataArgs']] = None,
                 priority_class_name: Optional[pulumi.Input[str]] = None,
                 scheduler_name: Optional[pulumi.Input[str]] = None,
                 security_context: Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodSecurityContextArgs']] = None,
                 termination_grace_period_seconds: Optional[pulumi.Input[int]] = None,
                 tolerations: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodTolerationsArgs']]]] = None):
        """
        Template for Cruise Control `Pods`.
        :param pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityArgs'] affinity: The pod's affinity rules.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodHostAliasesArgs']]] host_aliases: The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodImagePullSecretsArgs']]] image_pull_secrets: List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
        :param pulumi.Input['KafkaSpecCruiseControlTemplatePodMetadataArgs'] metadata: Metadata applied to the resource.
        :param pulumi.Input[str] priority_class_name: The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
        :param pulumi.Input[str] scheduler_name: The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
        :param pulumi.Input['KafkaSpecCruiseControlTemplatePodSecurityContextArgs'] security_context: Configures pod-level security attributes and common container settings.
        :param pulumi.Input[int] termination_grace_period_seconds: The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodTolerationsArgs']]] tolerations: The pod's tolerations.
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if host_aliases is not None:
            pulumi.set(__self__, "host_aliases", host_aliases)
        if image_pull_secrets is not None:
            pulumi.set(__self__, "image_pull_secrets", image_pull_secrets)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if priority_class_name is not None:
            pulumi.set(__self__, "priority_class_name", priority_class_name)
        if scheduler_name is not None:
            pulumi.set(__self__, "scheduler_name", scheduler_name)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)

    @property
    @pulumi.getter
    def affinity(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityArgs']]:
        """
        The pod's affinity rules.
        """
        return pulumi.get(self, "affinity")

    @affinity.setter
    def affinity(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityArgs']]):
        pulumi.set(self, "affinity", value)

    @property
    @pulumi.getter(name="hostAliases")
    def host_aliases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodHostAliasesArgs']]]]:
        """
        The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
        """
        return pulumi.get(self, "host_aliases")

    @host_aliases.setter
    def host_aliases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodHostAliasesArgs']]]]):
        pulumi.set(self, "host_aliases", value)

    @property
    @pulumi.getter(name="imagePullSecrets")
    def image_pull_secrets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodImagePullSecretsArgs']]]]:
        """
        List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
        """
        return pulumi.get(self, "image_pull_secrets")

    @image_pull_secrets.setter
    def image_pull_secrets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodImagePullSecretsArgs']]]]):
        pulumi.set(self, "image_pull_secrets", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodMetadataArgs']]:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodMetadataArgs']]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter(name="priorityClassName")
    def priority_class_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
        """
        return pulumi.get(self, "priority_class_name")

    @priority_class_name.setter
    def priority_class_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "priority_class_name", value)

    @property
    @pulumi.getter(name="schedulerName")
    def scheduler_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
        """
        return pulumi.get(self, "scheduler_name")

    @scheduler_name.setter
    def scheduler_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scheduler_name", value)

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodSecurityContextArgs']]:
        """
        Configures pod-level security attributes and common container settings.
        """
        return pulumi.get(self, "security_context")

    @security_context.setter
    def security_context(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodSecurityContextArgs']]):
        pulumi.set(self, "security_context", value)

    @property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
        """
        return pulumi.get(self, "termination_grace_period_seconds")

    @termination_grace_period_seconds.setter
    def termination_grace_period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "termination_grace_period_seconds", value)

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodTolerationsArgs']]]]:
        """
        The pod's tolerations.
        """
        return pulumi.get(self, "tolerations")

    @tolerations.setter
    def tolerations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodTolerationsArgs']]]]):
        pulumi.set(self, "tolerations", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplatePodAffinityArgs:
    def __init__(__self__, *,
                 node_affinity: Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityArgs']] = None,
                 pod_affinity: Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAffinityArgs']] = None,
                 pod_anti_affinity: Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityArgs']] = None):
        """
        The pod's affinity rules.
        """
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityArgs']]:
        return pulumi.get(self, "node_affinity")

    @node_affinity.setter
    def node_affinity(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityArgs']]):
        pulumi.set(self, "node_affinity", value)

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAffinityArgs']]:
        return pulumi.get(self, "pod_affinity")

    @pod_affinity.setter
    def pod_affinity(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAffinityArgs']]):
        pulumi.set(self, "pod_affinity", value)

    @property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityArgs']]:
        return pulumi.get(self, "pod_anti_affinity")

    @pod_anti_affinity.setter
    def pod_anti_affinity(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityArgs']]):
        pulumi.set(self, "pod_anti_affinity", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 preference: Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']]:
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]] = None,
                 match_fields: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]]:
        return pulumi.get(self, "match_fields")

    @match_fields.setter
    def match_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]]):
        pulumi.set(self, "match_fields", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 node_selector_terms: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]] = None):
        if node_selector_terms is not None:
            pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]]:
        return pulumi.get(self, "node_selector_terms")

    @node_selector_terms.setter
    def node_selector_terms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]]):
        pulumi.set(self, "node_selector_terms", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]] = None,
                 match_fields: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]]:
        return pulumi.get(self, "match_fields")

    @match_fields.setter
    def match_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]]):
        pulumi.set(self, "match_fields", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplatePodAffinityPodAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 pod_affinity_term: Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]:
        return pulumi.get(self, "pod_affinity_term")

    @pod_affinity_term.setter
    def pod_affinity_term(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]):
        pulumi.set(self, "pod_affinity_term", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 pod_affinity_term: Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]:
        return pulumi.get(self, "pod_affinity_term")

    @pod_affinity_term.setter
    def pod_affinity_term(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]):
        pulumi.set(self, "pod_affinity_term", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplatePodDisruptionBudgetArgs:
    def __init__(__self__, *,
                 max_unavailable: Optional[pulumi.Input[int]] = None,
                 metadata: Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadataArgs']] = None):
        """
        Template for Cruise Control `PodDisruptionBudget`.
        :param pulumi.Input[int] max_unavailable: Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
        :param pulumi.Input['KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadataArgs'] metadata: Metadata to apply to the `PodDistruptionBugetTemplate` resource.
        """
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
        """
        return pulumi.get(self, "max_unavailable")

    @max_unavailable.setter
    def max_unavailable(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_unavailable", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadataArgs']]:
        """
        Metadata to apply to the `PodDistruptionBugetTemplate` resource.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadataArgs']]):
        pulumi.set(self, "metadata", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Metadata to apply to the `PodDistruptionBugetTemplate` resource.
        :param pulumi.Input[Mapping[str, Any]] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param pulumi.Input[Mapping[str, Any]] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplatePodHostAliasesArgs:
    def __init__(__self__, *,
                 hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ip: Optional[pulumi.Input[str]] = None):
        if hostnames is not None:
            pulumi.set(__self__, "hostnames", hostnames)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def hostnames(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "hostnames")

    @hostnames.setter
    def hostnames(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hostnames", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplatePodImagePullSecretsArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplatePodMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Metadata applied to the resource.
        :param pulumi.Input[Mapping[str, Any]] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param pulumi.Input[Mapping[str, Any]] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplatePodSecurityContextArgs:
    def __init__(__self__, *,
                 fs_group: Optional[pulumi.Input[int]] = None,
                 fs_group_change_policy: Optional[pulumi.Input[str]] = None,
                 run_as_group: Optional[pulumi.Input[int]] = None,
                 run_as_non_root: Optional[pulumi.Input[bool]] = None,
                 run_as_user: Optional[pulumi.Input[int]] = None,
                 se_linux_options: Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptionsArgs']] = None,
                 supplemental_groups: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 sysctls: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodSecurityContextSysctlsArgs']]]] = None,
                 windows_options: Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptionsArgs']] = None):
        """
        Configures pod-level security attributes and common container settings.
        """
        if fs_group is not None:
            pulumi.set(__self__, "fs_group", fs_group)
        if fs_group_change_policy is not None:
            pulumi.set(__self__, "fs_group_change_policy", fs_group_change_policy)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if supplemental_groups is not None:
            pulumi.set(__self__, "supplemental_groups", supplemental_groups)
        if sysctls is not None:
            pulumi.set(__self__, "sysctls", sysctls)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="fsGroup")
    def fs_group(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "fs_group")

    @fs_group.setter
    def fs_group(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "fs_group", value)

    @property
    @pulumi.getter(name="fsGroupChangePolicy")
    def fs_group_change_policy(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "fs_group_change_policy")

    @fs_group_change_policy.setter
    def fs_group_change_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fs_group_change_policy", value)

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_group")

    @run_as_group.setter
    def run_as_group(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_group", value)

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "run_as_non_root")

    @run_as_non_root.setter
    def run_as_non_root(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_as_non_root", value)

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_user")

    @run_as_user.setter
    def run_as_user(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_user", value)

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptionsArgs']]:
        return pulumi.get(self, "se_linux_options")

    @se_linux_options.setter
    def se_linux_options(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptionsArgs']]):
        pulumi.set(self, "se_linux_options", value)

    @property
    @pulumi.getter(name="supplementalGroups")
    def supplemental_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        return pulumi.get(self, "supplemental_groups")

    @supplemental_groups.setter
    def supplemental_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "supplemental_groups", value)

    @property
    @pulumi.getter
    def sysctls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodSecurityContextSysctlsArgs']]]]:
        return pulumi.get(self, "sysctls")

    @sysctls.setter
    def sysctls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplatePodSecurityContextSysctlsArgs']]]]):
        pulumi.set(self, "sysctls", value)

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptionsArgs']]:
        return pulumi.get(self, "windows_options")

    @windows_options.setter
    def windows_options(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptionsArgs']]):
        pulumi.set(self, "windows_options", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptionsArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplatePodSecurityContextSysctlsArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptionsArgs:
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[pulumi.Input[str]] = None,
                 gmsa_credential_spec_name: Optional[pulumi.Input[str]] = None,
                 run_as_user_name: Optional[pulumi.Input[str]] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec")

    @gmsa_credential_spec.setter
    def gmsa_credential_spec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec", value)

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @gmsa_credential_spec_name.setter
    def gmsa_credential_spec_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec_name", value)

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "run_as_user_name")

    @run_as_user_name.setter
    def run_as_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "run_as_user_name", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplatePodTolerationsArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 toleration_seconds: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if toleration_seconds is not None:
            pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "toleration_seconds")

    @toleration_seconds.setter
    def toleration_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "toleration_seconds", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplateTlsSidecarContainerArgs:
    def __init__(__self__, *,
                 env: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplateTlsSidecarContainerEnvArgs']]]] = None,
                 security_context: Optional[pulumi.Input['KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextArgs']] = None):
        """
        Template for the Cruise Control TLS sidecar container.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplateTlsSidecarContainerEnvArgs']]] env: Environment variables which should be applied to the container.
        :param pulumi.Input['KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextArgs'] security_context: Security context for the container.
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)

    @property
    @pulumi.getter
    def env(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplateTlsSidecarContainerEnvArgs']]]]:
        """
        Environment variables which should be applied to the container.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecCruiseControlTemplateTlsSidecarContainerEnvArgs']]]]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextArgs']]:
        """
        Security context for the container.
        """
        return pulumi.get(self, "security_context")

    @security_context.setter
    def security_context(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextArgs']]):
        pulumi.set(self, "security_context", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplateTlsSidecarContainerEnvArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The environment variable key.
        :param pulumi.Input[str] value: The environment variable value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The environment variable key.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The environment variable value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextArgs:
    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[pulumi.Input[bool]] = None,
                 capabilities: Optional[pulumi.Input['KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextCapabilitiesArgs']] = None,
                 privileged: Optional[pulumi.Input[bool]] = None,
                 proc_mount: Optional[pulumi.Input[str]] = None,
                 read_only_root_filesystem: Optional[pulumi.Input[bool]] = None,
                 run_as_group: Optional[pulumi.Input[int]] = None,
                 run_as_non_root: Optional[pulumi.Input[bool]] = None,
                 run_as_user: Optional[pulumi.Input[int]] = None,
                 se_linux_options: Optional[pulumi.Input['KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptionsArgs']] = None,
                 windows_options: Optional[pulumi.Input['KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptionsArgs']] = None):
        """
        Security context for the container.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if proc_mount is not None:
            pulumi.set(__self__, "proc_mount", proc_mount)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "allow_privilege_escalation")

    @allow_privilege_escalation.setter
    def allow_privilege_escalation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_privilege_escalation", value)

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextCapabilitiesArgs']]:
        return pulumi.get(self, "capabilities")

    @capabilities.setter
    def capabilities(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextCapabilitiesArgs']]):
        pulumi.set(self, "capabilities", value)

    @property
    @pulumi.getter
    def privileged(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "privileged")

    @privileged.setter
    def privileged(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "privileged", value)

    @property
    @pulumi.getter(name="procMount")
    def proc_mount(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "proc_mount")

    @proc_mount.setter
    def proc_mount(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proc_mount", value)

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "read_only_root_filesystem")

    @read_only_root_filesystem.setter
    def read_only_root_filesystem(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "read_only_root_filesystem", value)

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_group")

    @run_as_group.setter
    def run_as_group(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_group", value)

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "run_as_non_root")

    @run_as_non_root.setter
    def run_as_non_root(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_as_non_root", value)

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_user")

    @run_as_user.setter
    def run_as_user(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_user", value)

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptionsArgs']]:
        return pulumi.get(self, "se_linux_options")

    @se_linux_options.setter
    def se_linux_options(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptionsArgs']]):
        pulumi.set(self, "se_linux_options", value)

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptionsArgs']]:
        return pulumi.get(self, "windows_options")

    @windows_options.setter
    def windows_options(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptionsArgs']]):
        pulumi.set(self, "windows_options", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextCapabilitiesArgs:
    def __init__(__self__, *,
                 add: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 drop: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)

    @property
    @pulumi.getter
    def add(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "add")

    @add.setter
    def add(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "add", value)

    @property
    @pulumi.getter
    def drop(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "drop")

    @drop.setter
    def drop(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "drop", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptionsArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


@pulumi.input_type
class KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptionsArgs:
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[pulumi.Input[str]] = None,
                 gmsa_credential_spec_name: Optional[pulumi.Input[str]] = None,
                 run_as_user_name: Optional[pulumi.Input[str]] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec")

    @gmsa_credential_spec.setter
    def gmsa_credential_spec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec", value)

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @gmsa_credential_spec_name.setter
    def gmsa_credential_spec_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec_name", value)

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "run_as_user_name")

    @run_as_user_name.setter
    def run_as_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "run_as_user_name", value)


@pulumi.input_type
class KafkaSpecCruiseControlTlsSidecarArgs:
    def __init__(__self__, *,
                 image: Optional[pulumi.Input[str]] = None,
                 liveness_probe: Optional[pulumi.Input['KafkaSpecCruiseControlTlsSidecarLivenessProbeArgs']] = None,
                 log_level: Optional[pulumi.Input[str]] = None,
                 readiness_probe: Optional[pulumi.Input['KafkaSpecCruiseControlTlsSidecarReadinessProbeArgs']] = None,
                 resources: Optional[pulumi.Input['KafkaSpecCruiseControlTlsSidecarResourcesArgs']] = None):
        """
        TLS sidecar configuration.
        :param pulumi.Input[str] image: The docker image for the container.
        :param pulumi.Input['KafkaSpecCruiseControlTlsSidecarLivenessProbeArgs'] liveness_probe: Pod liveness checking.
        :param pulumi.Input[str] log_level: The log level for the TLS sidecar. Default value is `notice`.
        :param pulumi.Input['KafkaSpecCruiseControlTlsSidecarReadinessProbeArgs'] readiness_probe: Pod readiness checking.
        :param pulumi.Input['KafkaSpecCruiseControlTlsSidecarResourcesArgs'] resources: CPU and memory resources to reserve.
        """
        if image is not None:
            pulumi.set(__self__, "image", image)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        The docker image for the container.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlTlsSidecarLivenessProbeArgs']]:
        """
        Pod liveness checking.
        """
        return pulumi.get(self, "liveness_probe")

    @liveness_probe.setter
    def liveness_probe(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlTlsSidecarLivenessProbeArgs']]):
        pulumi.set(self, "liveness_probe", value)

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[pulumi.Input[str]]:
        """
        The log level for the TLS sidecar. Default value is `notice`.
        """
        return pulumi.get(self, "log_level")

    @log_level.setter
    def log_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_level", value)

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlTlsSidecarReadinessProbeArgs']]:
        """
        Pod readiness checking.
        """
        return pulumi.get(self, "readiness_probe")

    @readiness_probe.setter
    def readiness_probe(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlTlsSidecarReadinessProbeArgs']]):
        pulumi.set(self, "readiness_probe", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['KafkaSpecCruiseControlTlsSidecarResourcesArgs']]:
        """
        CPU and memory resources to reserve.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['KafkaSpecCruiseControlTlsSidecarResourcesArgs']]):
        pulumi.set(self, "resources", value)


@pulumi.input_type
class KafkaSpecCruiseControlTlsSidecarLivenessProbeArgs:
    def __init__(__self__, *,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 success_threshold: Optional[pulumi.Input[int]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        Pod liveness checking.
        :param pulumi.Input[int] failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param pulumi.Input[int] initial_delay_seconds: The initial delay before first the health is first checked.
        :param pulumi.Input[int] period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param pulumi.Input[int] success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param pulumi.Input[int] timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "success_threshold", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


@pulumi.input_type
class KafkaSpecCruiseControlTlsSidecarReadinessProbeArgs:
    def __init__(__self__, *,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 success_threshold: Optional[pulumi.Input[int]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        Pod readiness checking.
        :param pulumi.Input[int] failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param pulumi.Input[int] initial_delay_seconds: The initial delay before first the health is first checked.
        :param pulumi.Input[int] period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param pulumi.Input[int] success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param pulumi.Input[int] timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "success_threshold", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


@pulumi.input_type
class KafkaSpecCruiseControlTlsSidecarResourcesArgs:
    def __init__(__self__, *,
                 limits: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 requests: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        CPU and memory resources to reserve.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "limits", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "requests", value)


@pulumi.input_type
class KafkaSpecEntityOperatorArgs:
    def __init__(__self__, *,
                 affinity: Optional[pulumi.Input['KafkaSpecEntityOperatorAffinityArgs']] = None,
                 template: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateArgs']] = None,
                 tls_sidecar: Optional[pulumi.Input['KafkaSpecEntityOperatorTlsSidecarArgs']] = None,
                 tolerations: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTolerationsArgs']]]] = None,
                 topic_operator: Optional[pulumi.Input['KafkaSpecEntityOperatorTopicOperatorArgs']] = None,
                 user_operator: Optional[pulumi.Input['KafkaSpecEntityOperatorUserOperatorArgs']] = None):
        """
        Configuration of the Entity Operator.
        :param pulumi.Input['KafkaSpecEntityOperatorAffinityArgs'] affinity: The pod's affinity rules.
        :param pulumi.Input['KafkaSpecEntityOperatorTemplateArgs'] template: Template for Entity Operator resources. The template allows users to specify how is the `Deployment` and `Pods` generated.
        :param pulumi.Input['KafkaSpecEntityOperatorTlsSidecarArgs'] tls_sidecar: TLS sidecar configuration.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTolerationsArgs']]] tolerations: The pod's tolerations.
        :param pulumi.Input['KafkaSpecEntityOperatorTopicOperatorArgs'] topic_operator: Configuration of the Topic Operator.
        :param pulumi.Input['KafkaSpecEntityOperatorUserOperatorArgs'] user_operator: Configuration of the User Operator.
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if template is not None:
            pulumi.set(__self__, "template", template)
        if tls_sidecar is not None:
            pulumi.set(__self__, "tls_sidecar", tls_sidecar)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)
        if topic_operator is not None:
            pulumi.set(__self__, "topic_operator", topic_operator)
        if user_operator is not None:
            pulumi.set(__self__, "user_operator", user_operator)

    @property
    @pulumi.getter
    def affinity(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorAffinityArgs']]:
        """
        The pod's affinity rules.
        """
        return pulumi.get(self, "affinity")

    @affinity.setter
    def affinity(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorAffinityArgs']]):
        pulumi.set(self, "affinity", value)

    @property
    @pulumi.getter
    def template(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateArgs']]:
        """
        Template for Entity Operator resources. The template allows users to specify how is the `Deployment` and `Pods` generated.
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateArgs']]):
        pulumi.set(self, "template", value)

    @property
    @pulumi.getter(name="tlsSidecar")
    def tls_sidecar(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTlsSidecarArgs']]:
        """
        TLS sidecar configuration.
        """
        return pulumi.get(self, "tls_sidecar")

    @tls_sidecar.setter
    def tls_sidecar(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTlsSidecarArgs']]):
        pulumi.set(self, "tls_sidecar", value)

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTolerationsArgs']]]]:
        """
        The pod's tolerations.
        """
        return pulumi.get(self, "tolerations")

    @tolerations.setter
    def tolerations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTolerationsArgs']]]]):
        pulumi.set(self, "tolerations", value)

    @property
    @pulumi.getter(name="topicOperator")
    def topic_operator(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTopicOperatorArgs']]:
        """
        Configuration of the Topic Operator.
        """
        return pulumi.get(self, "topic_operator")

    @topic_operator.setter
    def topic_operator(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTopicOperatorArgs']]):
        pulumi.set(self, "topic_operator", value)

    @property
    @pulumi.getter(name="userOperator")
    def user_operator(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorUserOperatorArgs']]:
        """
        Configuration of the User Operator.
        """
        return pulumi.get(self, "user_operator")

    @user_operator.setter
    def user_operator(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorUserOperatorArgs']]):
        pulumi.set(self, "user_operator", value)


@pulumi.input_type
class KafkaSpecEntityOperatorAffinityArgs:
    def __init__(__self__, *,
                 node_affinity: Optional[pulumi.Input['KafkaSpecEntityOperatorAffinityNodeAffinityArgs']] = None,
                 pod_affinity: Optional[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAffinityArgs']] = None,
                 pod_anti_affinity: Optional[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAntiAffinityArgs']] = None):
        """
        The pod's affinity rules.
        """
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorAffinityNodeAffinityArgs']]:
        return pulumi.get(self, "node_affinity")

    @node_affinity.setter
    def node_affinity(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorAffinityNodeAffinityArgs']]):
        pulumi.set(self, "node_affinity", value)

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAffinityArgs']]:
        return pulumi.get(self, "pod_affinity")

    @pod_affinity.setter
    def pod_affinity(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAffinityArgs']]):
        pulumi.set(self, "pod_affinity", value)

    @property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAntiAffinityArgs']]:
        return pulumi.get(self, "pod_anti_affinity")

    @pod_anti_affinity.setter
    def pod_anti_affinity(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAntiAffinityArgs']]):
        pulumi.set(self, "pod_anti_affinity", value)


@pulumi.input_type
class KafkaSpecEntityOperatorAffinityNodeAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input['KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 preference: Optional[pulumi.Input['KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']]:
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]] = None,
                 match_fields: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]]:
        return pulumi.get(self, "match_fields")

    @match_fields.setter
    def match_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]]):
        pulumi.set(self, "match_fields", value)


@pulumi.input_type
class KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 node_selector_terms: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]] = None):
        if node_selector_terms is not None:
            pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]]:
        return pulumi.get(self, "node_selector_terms")

    @node_selector_terms.setter
    def node_selector_terms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]]):
        pulumi.set(self, "node_selector_terms", value)


@pulumi.input_type
class KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]] = None,
                 match_fields: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]]:
        return pulumi.get(self, "match_fields")

    @match_fields.setter
    def match_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]]):
        pulumi.set(self, "match_fields", value)


@pulumi.input_type
class KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecEntityOperatorAffinityPodAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 pod_affinity_term: Optional[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]:
        return pulumi.get(self, "pod_affinity_term")

    @pod_affinity_term.setter
    def pod_affinity_term(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]):
        pulumi.set(self, "pod_affinity_term", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecEntityOperatorAffinityPodAntiAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 pod_affinity_term: Optional[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]:
        return pulumi.get(self, "pod_affinity_term")

    @pod_affinity_term.setter
    def pod_affinity_term(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]):
        pulumi.set(self, "pod_affinity_term", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplateArgs:
    def __init__(__self__, *,
                 deployment: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateDeploymentArgs']] = None,
                 pod: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodArgs']] = None,
                 tls_sidecar_container: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateTlsSidecarContainerArgs']] = None,
                 topic_operator_container: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateTopicOperatorContainerArgs']] = None,
                 user_operator_container: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateUserOperatorContainerArgs']] = None):
        """
        Template for Entity Operator resources. The template allows users to specify how is the `Deployment` and `Pods` generated.
        :param pulumi.Input['KafkaSpecEntityOperatorTemplateDeploymentArgs'] deployment: Template for Entity Operator `Deployment`.
        :param pulumi.Input['KafkaSpecEntityOperatorTemplatePodArgs'] pod: Template for Entity Operator `Pods`.
        :param pulumi.Input['KafkaSpecEntityOperatorTemplateTlsSidecarContainerArgs'] tls_sidecar_container: Template for the Entity Operator TLS sidecar container.
        :param pulumi.Input['KafkaSpecEntityOperatorTemplateTopicOperatorContainerArgs'] topic_operator_container: Template for the Entity Topic Operator container.
        :param pulumi.Input['KafkaSpecEntityOperatorTemplateUserOperatorContainerArgs'] user_operator_container: Template for the Entity User Operator container.
        """
        if deployment is not None:
            pulumi.set(__self__, "deployment", deployment)
        if pod is not None:
            pulumi.set(__self__, "pod", pod)
        if tls_sidecar_container is not None:
            pulumi.set(__self__, "tls_sidecar_container", tls_sidecar_container)
        if topic_operator_container is not None:
            pulumi.set(__self__, "topic_operator_container", topic_operator_container)
        if user_operator_container is not None:
            pulumi.set(__self__, "user_operator_container", user_operator_container)

    @property
    @pulumi.getter
    def deployment(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateDeploymentArgs']]:
        """
        Template for Entity Operator `Deployment`.
        """
        return pulumi.get(self, "deployment")

    @deployment.setter
    def deployment(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateDeploymentArgs']]):
        pulumi.set(self, "deployment", value)

    @property
    @pulumi.getter
    def pod(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodArgs']]:
        """
        Template for Entity Operator `Pods`.
        """
        return pulumi.get(self, "pod")

    @pod.setter
    def pod(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodArgs']]):
        pulumi.set(self, "pod", value)

    @property
    @pulumi.getter(name="tlsSidecarContainer")
    def tls_sidecar_container(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateTlsSidecarContainerArgs']]:
        """
        Template for the Entity Operator TLS sidecar container.
        """
        return pulumi.get(self, "tls_sidecar_container")

    @tls_sidecar_container.setter
    def tls_sidecar_container(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateTlsSidecarContainerArgs']]):
        pulumi.set(self, "tls_sidecar_container", value)

    @property
    @pulumi.getter(name="topicOperatorContainer")
    def topic_operator_container(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateTopicOperatorContainerArgs']]:
        """
        Template for the Entity Topic Operator container.
        """
        return pulumi.get(self, "topic_operator_container")

    @topic_operator_container.setter
    def topic_operator_container(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateTopicOperatorContainerArgs']]):
        pulumi.set(self, "topic_operator_container", value)

    @property
    @pulumi.getter(name="userOperatorContainer")
    def user_operator_container(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateUserOperatorContainerArgs']]:
        """
        Template for the Entity User Operator container.
        """
        return pulumi.get(self, "user_operator_container")

    @user_operator_container.setter
    def user_operator_container(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateUserOperatorContainerArgs']]):
        pulumi.set(self, "user_operator_container", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplateDeploymentArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateDeploymentMetadataArgs']] = None):
        """
        Template for Entity Operator `Deployment`.
        :param pulumi.Input['KafkaSpecEntityOperatorTemplateDeploymentMetadataArgs'] metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateDeploymentMetadataArgs']]:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateDeploymentMetadataArgs']]):
        pulumi.set(self, "metadata", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplateDeploymentMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Metadata applied to the resource.
        :param pulumi.Input[Mapping[str, Any]] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param pulumi.Input[Mapping[str, Any]] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplatePodArgs:
    def __init__(__self__, *,
                 affinity: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityArgs']] = None,
                 host_aliases: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodHostAliasesArgs']]]] = None,
                 image_pull_secrets: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodImagePullSecretsArgs']]]] = None,
                 metadata: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodMetadataArgs']] = None,
                 priority_class_name: Optional[pulumi.Input[str]] = None,
                 scheduler_name: Optional[pulumi.Input[str]] = None,
                 security_context: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodSecurityContextArgs']] = None,
                 termination_grace_period_seconds: Optional[pulumi.Input[int]] = None,
                 tolerations: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodTolerationsArgs']]]] = None):
        """
        Template for Entity Operator `Pods`.
        :param pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityArgs'] affinity: The pod's affinity rules.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodHostAliasesArgs']]] host_aliases: The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodImagePullSecretsArgs']]] image_pull_secrets: List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
        :param pulumi.Input['KafkaSpecEntityOperatorTemplatePodMetadataArgs'] metadata: Metadata applied to the resource.
        :param pulumi.Input[str] priority_class_name: The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
        :param pulumi.Input[str] scheduler_name: The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
        :param pulumi.Input['KafkaSpecEntityOperatorTemplatePodSecurityContextArgs'] security_context: Configures pod-level security attributes and common container settings.
        :param pulumi.Input[int] termination_grace_period_seconds: The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodTolerationsArgs']]] tolerations: The pod's tolerations.
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if host_aliases is not None:
            pulumi.set(__self__, "host_aliases", host_aliases)
        if image_pull_secrets is not None:
            pulumi.set(__self__, "image_pull_secrets", image_pull_secrets)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if priority_class_name is not None:
            pulumi.set(__self__, "priority_class_name", priority_class_name)
        if scheduler_name is not None:
            pulumi.set(__self__, "scheduler_name", scheduler_name)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)

    @property
    @pulumi.getter
    def affinity(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityArgs']]:
        """
        The pod's affinity rules.
        """
        return pulumi.get(self, "affinity")

    @affinity.setter
    def affinity(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityArgs']]):
        pulumi.set(self, "affinity", value)

    @property
    @pulumi.getter(name="hostAliases")
    def host_aliases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodHostAliasesArgs']]]]:
        """
        The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
        """
        return pulumi.get(self, "host_aliases")

    @host_aliases.setter
    def host_aliases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodHostAliasesArgs']]]]):
        pulumi.set(self, "host_aliases", value)

    @property
    @pulumi.getter(name="imagePullSecrets")
    def image_pull_secrets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodImagePullSecretsArgs']]]]:
        """
        List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
        """
        return pulumi.get(self, "image_pull_secrets")

    @image_pull_secrets.setter
    def image_pull_secrets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodImagePullSecretsArgs']]]]):
        pulumi.set(self, "image_pull_secrets", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodMetadataArgs']]:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodMetadataArgs']]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter(name="priorityClassName")
    def priority_class_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
        """
        return pulumi.get(self, "priority_class_name")

    @priority_class_name.setter
    def priority_class_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "priority_class_name", value)

    @property
    @pulumi.getter(name="schedulerName")
    def scheduler_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
        """
        return pulumi.get(self, "scheduler_name")

    @scheduler_name.setter
    def scheduler_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scheduler_name", value)

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodSecurityContextArgs']]:
        """
        Configures pod-level security attributes and common container settings.
        """
        return pulumi.get(self, "security_context")

    @security_context.setter
    def security_context(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodSecurityContextArgs']]):
        pulumi.set(self, "security_context", value)

    @property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
        """
        return pulumi.get(self, "termination_grace_period_seconds")

    @termination_grace_period_seconds.setter
    def termination_grace_period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "termination_grace_period_seconds", value)

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodTolerationsArgs']]]]:
        """
        The pod's tolerations.
        """
        return pulumi.get(self, "tolerations")

    @tolerations.setter
    def tolerations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodTolerationsArgs']]]]):
        pulumi.set(self, "tolerations", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplatePodAffinityArgs:
    def __init__(__self__, *,
                 node_affinity: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityArgs']] = None,
                 pod_affinity: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityArgs']] = None,
                 pod_anti_affinity: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityArgs']] = None):
        """
        The pod's affinity rules.
        """
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityArgs']]:
        return pulumi.get(self, "node_affinity")

    @node_affinity.setter
    def node_affinity(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityArgs']]):
        pulumi.set(self, "node_affinity", value)

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityArgs']]:
        return pulumi.get(self, "pod_affinity")

    @pod_affinity.setter
    def pod_affinity(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityArgs']]):
        pulumi.set(self, "pod_affinity", value)

    @property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityArgs']]:
        return pulumi.get(self, "pod_anti_affinity")

    @pod_anti_affinity.setter
    def pod_anti_affinity(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityArgs']]):
        pulumi.set(self, "pod_anti_affinity", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 preference: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']]:
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]] = None,
                 match_fields: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]]:
        return pulumi.get(self, "match_fields")

    @match_fields.setter
    def match_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]]):
        pulumi.set(self, "match_fields", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 node_selector_terms: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]] = None):
        if node_selector_terms is not None:
            pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]]:
        return pulumi.get(self, "node_selector_terms")

    @node_selector_terms.setter
    def node_selector_terms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]]):
        pulumi.set(self, "node_selector_terms", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]] = None,
                 match_fields: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]]:
        return pulumi.get(self, "match_fields")

    @match_fields.setter
    def match_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]]):
        pulumi.set(self, "match_fields", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 pod_affinity_term: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]:
        return pulumi.get(self, "pod_affinity_term")

    @pod_affinity_term.setter
    def pod_affinity_term(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]):
        pulumi.set(self, "pod_affinity_term", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 pod_affinity_term: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]:
        return pulumi.get(self, "pod_affinity_term")

    @pod_affinity_term.setter
    def pod_affinity_term(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]):
        pulumi.set(self, "pod_affinity_term", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplatePodHostAliasesArgs:
    def __init__(__self__, *,
                 hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ip: Optional[pulumi.Input[str]] = None):
        if hostnames is not None:
            pulumi.set(__self__, "hostnames", hostnames)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def hostnames(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "hostnames")

    @hostnames.setter
    def hostnames(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hostnames", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplatePodImagePullSecretsArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplatePodMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Metadata applied to the resource.
        :param pulumi.Input[Mapping[str, Any]] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param pulumi.Input[Mapping[str, Any]] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplatePodSecurityContextArgs:
    def __init__(__self__, *,
                 fs_group: Optional[pulumi.Input[int]] = None,
                 fs_group_change_policy: Optional[pulumi.Input[str]] = None,
                 run_as_group: Optional[pulumi.Input[int]] = None,
                 run_as_non_root: Optional[pulumi.Input[bool]] = None,
                 run_as_user: Optional[pulumi.Input[int]] = None,
                 se_linux_options: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptionsArgs']] = None,
                 supplemental_groups: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 sysctls: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodSecurityContextSysctlsArgs']]]] = None,
                 windows_options: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptionsArgs']] = None):
        """
        Configures pod-level security attributes and common container settings.
        """
        if fs_group is not None:
            pulumi.set(__self__, "fs_group", fs_group)
        if fs_group_change_policy is not None:
            pulumi.set(__self__, "fs_group_change_policy", fs_group_change_policy)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if supplemental_groups is not None:
            pulumi.set(__self__, "supplemental_groups", supplemental_groups)
        if sysctls is not None:
            pulumi.set(__self__, "sysctls", sysctls)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="fsGroup")
    def fs_group(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "fs_group")

    @fs_group.setter
    def fs_group(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "fs_group", value)

    @property
    @pulumi.getter(name="fsGroupChangePolicy")
    def fs_group_change_policy(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "fs_group_change_policy")

    @fs_group_change_policy.setter
    def fs_group_change_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fs_group_change_policy", value)

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_group")

    @run_as_group.setter
    def run_as_group(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_group", value)

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "run_as_non_root")

    @run_as_non_root.setter
    def run_as_non_root(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_as_non_root", value)

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_user")

    @run_as_user.setter
    def run_as_user(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_user", value)

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptionsArgs']]:
        return pulumi.get(self, "se_linux_options")

    @se_linux_options.setter
    def se_linux_options(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptionsArgs']]):
        pulumi.set(self, "se_linux_options", value)

    @property
    @pulumi.getter(name="supplementalGroups")
    def supplemental_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        return pulumi.get(self, "supplemental_groups")

    @supplemental_groups.setter
    def supplemental_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "supplemental_groups", value)

    @property
    @pulumi.getter
    def sysctls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodSecurityContextSysctlsArgs']]]]:
        return pulumi.get(self, "sysctls")

    @sysctls.setter
    def sysctls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplatePodSecurityContextSysctlsArgs']]]]):
        pulumi.set(self, "sysctls", value)

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptionsArgs']]:
        return pulumi.get(self, "windows_options")

    @windows_options.setter
    def windows_options(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptionsArgs']]):
        pulumi.set(self, "windows_options", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptionsArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplatePodSecurityContextSysctlsArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptionsArgs:
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[pulumi.Input[str]] = None,
                 gmsa_credential_spec_name: Optional[pulumi.Input[str]] = None,
                 run_as_user_name: Optional[pulumi.Input[str]] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec")

    @gmsa_credential_spec.setter
    def gmsa_credential_spec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec", value)

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @gmsa_credential_spec_name.setter
    def gmsa_credential_spec_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec_name", value)

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "run_as_user_name")

    @run_as_user_name.setter
    def run_as_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "run_as_user_name", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplatePodTolerationsArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 toleration_seconds: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if toleration_seconds is not None:
            pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "toleration_seconds")

    @toleration_seconds.setter
    def toleration_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "toleration_seconds", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplateTlsSidecarContainerArgs:
    def __init__(__self__, *,
                 env: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplateTlsSidecarContainerEnvArgs']]]] = None,
                 security_context: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextArgs']] = None):
        """
        Template for the Entity Operator TLS sidecar container.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplateTlsSidecarContainerEnvArgs']]] env: Environment variables which should be applied to the container.
        :param pulumi.Input['KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextArgs'] security_context: Security context for the container.
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)

    @property
    @pulumi.getter
    def env(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplateTlsSidecarContainerEnvArgs']]]]:
        """
        Environment variables which should be applied to the container.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplateTlsSidecarContainerEnvArgs']]]]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextArgs']]:
        """
        Security context for the container.
        """
        return pulumi.get(self, "security_context")

    @security_context.setter
    def security_context(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextArgs']]):
        pulumi.set(self, "security_context", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplateTlsSidecarContainerEnvArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The environment variable key.
        :param pulumi.Input[str] value: The environment variable value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The environment variable key.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The environment variable value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextArgs:
    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[pulumi.Input[bool]] = None,
                 capabilities: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextCapabilitiesArgs']] = None,
                 privileged: Optional[pulumi.Input[bool]] = None,
                 proc_mount: Optional[pulumi.Input[str]] = None,
                 read_only_root_filesystem: Optional[pulumi.Input[bool]] = None,
                 run_as_group: Optional[pulumi.Input[int]] = None,
                 run_as_non_root: Optional[pulumi.Input[bool]] = None,
                 run_as_user: Optional[pulumi.Input[int]] = None,
                 se_linux_options: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptionsArgs']] = None,
                 windows_options: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptionsArgs']] = None):
        """
        Security context for the container.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if proc_mount is not None:
            pulumi.set(__self__, "proc_mount", proc_mount)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "allow_privilege_escalation")

    @allow_privilege_escalation.setter
    def allow_privilege_escalation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_privilege_escalation", value)

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextCapabilitiesArgs']]:
        return pulumi.get(self, "capabilities")

    @capabilities.setter
    def capabilities(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextCapabilitiesArgs']]):
        pulumi.set(self, "capabilities", value)

    @property
    @pulumi.getter
    def privileged(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "privileged")

    @privileged.setter
    def privileged(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "privileged", value)

    @property
    @pulumi.getter(name="procMount")
    def proc_mount(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "proc_mount")

    @proc_mount.setter
    def proc_mount(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proc_mount", value)

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "read_only_root_filesystem")

    @read_only_root_filesystem.setter
    def read_only_root_filesystem(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "read_only_root_filesystem", value)

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_group")

    @run_as_group.setter
    def run_as_group(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_group", value)

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "run_as_non_root")

    @run_as_non_root.setter
    def run_as_non_root(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_as_non_root", value)

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_user")

    @run_as_user.setter
    def run_as_user(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_user", value)

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptionsArgs']]:
        return pulumi.get(self, "se_linux_options")

    @se_linux_options.setter
    def se_linux_options(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptionsArgs']]):
        pulumi.set(self, "se_linux_options", value)

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptionsArgs']]:
        return pulumi.get(self, "windows_options")

    @windows_options.setter
    def windows_options(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptionsArgs']]):
        pulumi.set(self, "windows_options", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextCapabilitiesArgs:
    def __init__(__self__, *,
                 add: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 drop: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)

    @property
    @pulumi.getter
    def add(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "add")

    @add.setter
    def add(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "add", value)

    @property
    @pulumi.getter
    def drop(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "drop")

    @drop.setter
    def drop(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "drop", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptionsArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptionsArgs:
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[pulumi.Input[str]] = None,
                 gmsa_credential_spec_name: Optional[pulumi.Input[str]] = None,
                 run_as_user_name: Optional[pulumi.Input[str]] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec")

    @gmsa_credential_spec.setter
    def gmsa_credential_spec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec", value)

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @gmsa_credential_spec_name.setter
    def gmsa_credential_spec_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec_name", value)

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "run_as_user_name")

    @run_as_user_name.setter
    def run_as_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "run_as_user_name", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplateTopicOperatorContainerArgs:
    def __init__(__self__, *,
                 env: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplateTopicOperatorContainerEnvArgs']]]] = None,
                 security_context: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextArgs']] = None):
        """
        Template for the Entity Topic Operator container.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplateTopicOperatorContainerEnvArgs']]] env: Environment variables which should be applied to the container.
        :param pulumi.Input['KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextArgs'] security_context: Security context for the container.
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)

    @property
    @pulumi.getter
    def env(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplateTopicOperatorContainerEnvArgs']]]]:
        """
        Environment variables which should be applied to the container.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplateTopicOperatorContainerEnvArgs']]]]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextArgs']]:
        """
        Security context for the container.
        """
        return pulumi.get(self, "security_context")

    @security_context.setter
    def security_context(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextArgs']]):
        pulumi.set(self, "security_context", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplateTopicOperatorContainerEnvArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The environment variable key.
        :param pulumi.Input[str] value: The environment variable value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The environment variable key.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The environment variable value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextArgs:
    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[pulumi.Input[bool]] = None,
                 capabilities: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextCapabilitiesArgs']] = None,
                 privileged: Optional[pulumi.Input[bool]] = None,
                 proc_mount: Optional[pulumi.Input[str]] = None,
                 read_only_root_filesystem: Optional[pulumi.Input[bool]] = None,
                 run_as_group: Optional[pulumi.Input[int]] = None,
                 run_as_non_root: Optional[pulumi.Input[bool]] = None,
                 run_as_user: Optional[pulumi.Input[int]] = None,
                 se_linux_options: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptionsArgs']] = None,
                 windows_options: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptionsArgs']] = None):
        """
        Security context for the container.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if proc_mount is not None:
            pulumi.set(__self__, "proc_mount", proc_mount)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "allow_privilege_escalation")

    @allow_privilege_escalation.setter
    def allow_privilege_escalation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_privilege_escalation", value)

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextCapabilitiesArgs']]:
        return pulumi.get(self, "capabilities")

    @capabilities.setter
    def capabilities(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextCapabilitiesArgs']]):
        pulumi.set(self, "capabilities", value)

    @property
    @pulumi.getter
    def privileged(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "privileged")

    @privileged.setter
    def privileged(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "privileged", value)

    @property
    @pulumi.getter(name="procMount")
    def proc_mount(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "proc_mount")

    @proc_mount.setter
    def proc_mount(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proc_mount", value)

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "read_only_root_filesystem")

    @read_only_root_filesystem.setter
    def read_only_root_filesystem(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "read_only_root_filesystem", value)

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_group")

    @run_as_group.setter
    def run_as_group(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_group", value)

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "run_as_non_root")

    @run_as_non_root.setter
    def run_as_non_root(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_as_non_root", value)

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_user")

    @run_as_user.setter
    def run_as_user(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_user", value)

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptionsArgs']]:
        return pulumi.get(self, "se_linux_options")

    @se_linux_options.setter
    def se_linux_options(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptionsArgs']]):
        pulumi.set(self, "se_linux_options", value)

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptionsArgs']]:
        return pulumi.get(self, "windows_options")

    @windows_options.setter
    def windows_options(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptionsArgs']]):
        pulumi.set(self, "windows_options", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextCapabilitiesArgs:
    def __init__(__self__, *,
                 add: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 drop: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)

    @property
    @pulumi.getter
    def add(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "add")

    @add.setter
    def add(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "add", value)

    @property
    @pulumi.getter
    def drop(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "drop")

    @drop.setter
    def drop(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "drop", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptionsArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptionsArgs:
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[pulumi.Input[str]] = None,
                 gmsa_credential_spec_name: Optional[pulumi.Input[str]] = None,
                 run_as_user_name: Optional[pulumi.Input[str]] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec")

    @gmsa_credential_spec.setter
    def gmsa_credential_spec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec", value)

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @gmsa_credential_spec_name.setter
    def gmsa_credential_spec_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec_name", value)

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "run_as_user_name")

    @run_as_user_name.setter
    def run_as_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "run_as_user_name", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplateUserOperatorContainerArgs:
    def __init__(__self__, *,
                 env: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplateUserOperatorContainerEnvArgs']]]] = None,
                 security_context: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextArgs']] = None):
        """
        Template for the Entity User Operator container.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplateUserOperatorContainerEnvArgs']]] env: Environment variables which should be applied to the container.
        :param pulumi.Input['KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextArgs'] security_context: Security context for the container.
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)

    @property
    @pulumi.getter
    def env(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplateUserOperatorContainerEnvArgs']]]]:
        """
        Environment variables which should be applied to the container.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTemplateUserOperatorContainerEnvArgs']]]]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextArgs']]:
        """
        Security context for the container.
        """
        return pulumi.get(self, "security_context")

    @security_context.setter
    def security_context(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextArgs']]):
        pulumi.set(self, "security_context", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplateUserOperatorContainerEnvArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The environment variable key.
        :param pulumi.Input[str] value: The environment variable value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The environment variable key.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The environment variable value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextArgs:
    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[pulumi.Input[bool]] = None,
                 capabilities: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextCapabilitiesArgs']] = None,
                 privileged: Optional[pulumi.Input[bool]] = None,
                 proc_mount: Optional[pulumi.Input[str]] = None,
                 read_only_root_filesystem: Optional[pulumi.Input[bool]] = None,
                 run_as_group: Optional[pulumi.Input[int]] = None,
                 run_as_non_root: Optional[pulumi.Input[bool]] = None,
                 run_as_user: Optional[pulumi.Input[int]] = None,
                 se_linux_options: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptionsArgs']] = None,
                 windows_options: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptionsArgs']] = None):
        """
        Security context for the container.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if proc_mount is not None:
            pulumi.set(__self__, "proc_mount", proc_mount)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "allow_privilege_escalation")

    @allow_privilege_escalation.setter
    def allow_privilege_escalation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_privilege_escalation", value)

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextCapabilitiesArgs']]:
        return pulumi.get(self, "capabilities")

    @capabilities.setter
    def capabilities(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextCapabilitiesArgs']]):
        pulumi.set(self, "capabilities", value)

    @property
    @pulumi.getter
    def privileged(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "privileged")

    @privileged.setter
    def privileged(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "privileged", value)

    @property
    @pulumi.getter(name="procMount")
    def proc_mount(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "proc_mount")

    @proc_mount.setter
    def proc_mount(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proc_mount", value)

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "read_only_root_filesystem")

    @read_only_root_filesystem.setter
    def read_only_root_filesystem(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "read_only_root_filesystem", value)

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_group")

    @run_as_group.setter
    def run_as_group(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_group", value)

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "run_as_non_root")

    @run_as_non_root.setter
    def run_as_non_root(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_as_non_root", value)

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_user")

    @run_as_user.setter
    def run_as_user(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_user", value)

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptionsArgs']]:
        return pulumi.get(self, "se_linux_options")

    @se_linux_options.setter
    def se_linux_options(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptionsArgs']]):
        pulumi.set(self, "se_linux_options", value)

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptionsArgs']]:
        return pulumi.get(self, "windows_options")

    @windows_options.setter
    def windows_options(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptionsArgs']]):
        pulumi.set(self, "windows_options", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextCapabilitiesArgs:
    def __init__(__self__, *,
                 add: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 drop: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)

    @property
    @pulumi.getter
    def add(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "add")

    @add.setter
    def add(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "add", value)

    @property
    @pulumi.getter
    def drop(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "drop")

    @drop.setter
    def drop(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "drop", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptionsArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptionsArgs:
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[pulumi.Input[str]] = None,
                 gmsa_credential_spec_name: Optional[pulumi.Input[str]] = None,
                 run_as_user_name: Optional[pulumi.Input[str]] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec")

    @gmsa_credential_spec.setter
    def gmsa_credential_spec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec", value)

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @gmsa_credential_spec_name.setter
    def gmsa_credential_spec_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec_name", value)

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "run_as_user_name")

    @run_as_user_name.setter
    def run_as_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "run_as_user_name", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTlsSidecarArgs:
    def __init__(__self__, *,
                 image: Optional[pulumi.Input[str]] = None,
                 liveness_probe: Optional[pulumi.Input['KafkaSpecEntityOperatorTlsSidecarLivenessProbeArgs']] = None,
                 log_level: Optional[pulumi.Input[str]] = None,
                 readiness_probe: Optional[pulumi.Input['KafkaSpecEntityOperatorTlsSidecarReadinessProbeArgs']] = None,
                 resources: Optional[pulumi.Input['KafkaSpecEntityOperatorTlsSidecarResourcesArgs']] = None):
        """
        TLS sidecar configuration.
        :param pulumi.Input[str] image: The docker image for the container.
        :param pulumi.Input['KafkaSpecEntityOperatorTlsSidecarLivenessProbeArgs'] liveness_probe: Pod liveness checking.
        :param pulumi.Input[str] log_level: The log level for the TLS sidecar. Default value is `notice`.
        :param pulumi.Input['KafkaSpecEntityOperatorTlsSidecarReadinessProbeArgs'] readiness_probe: Pod readiness checking.
        :param pulumi.Input['KafkaSpecEntityOperatorTlsSidecarResourcesArgs'] resources: CPU and memory resources to reserve.
        """
        if image is not None:
            pulumi.set(__self__, "image", image)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        The docker image for the container.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTlsSidecarLivenessProbeArgs']]:
        """
        Pod liveness checking.
        """
        return pulumi.get(self, "liveness_probe")

    @liveness_probe.setter
    def liveness_probe(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTlsSidecarLivenessProbeArgs']]):
        pulumi.set(self, "liveness_probe", value)

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[pulumi.Input[str]]:
        """
        The log level for the TLS sidecar. Default value is `notice`.
        """
        return pulumi.get(self, "log_level")

    @log_level.setter
    def log_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_level", value)

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTlsSidecarReadinessProbeArgs']]:
        """
        Pod readiness checking.
        """
        return pulumi.get(self, "readiness_probe")

    @readiness_probe.setter
    def readiness_probe(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTlsSidecarReadinessProbeArgs']]):
        pulumi.set(self, "readiness_probe", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTlsSidecarResourcesArgs']]:
        """
        CPU and memory resources to reserve.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTlsSidecarResourcesArgs']]):
        pulumi.set(self, "resources", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTlsSidecarLivenessProbeArgs:
    def __init__(__self__, *,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 success_threshold: Optional[pulumi.Input[int]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        Pod liveness checking.
        :param pulumi.Input[int] failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param pulumi.Input[int] initial_delay_seconds: The initial delay before first the health is first checked.
        :param pulumi.Input[int] period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param pulumi.Input[int] success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param pulumi.Input[int] timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "success_threshold", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTlsSidecarReadinessProbeArgs:
    def __init__(__self__, *,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 success_threshold: Optional[pulumi.Input[int]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        Pod readiness checking.
        :param pulumi.Input[int] failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param pulumi.Input[int] initial_delay_seconds: The initial delay before first the health is first checked.
        :param pulumi.Input[int] period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param pulumi.Input[int] success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param pulumi.Input[int] timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "success_threshold", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTlsSidecarResourcesArgs:
    def __init__(__self__, *,
                 limits: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 requests: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        CPU and memory resources to reserve.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "limits", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "requests", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTolerationsArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 toleration_seconds: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if toleration_seconds is not None:
            pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "toleration_seconds")

    @toleration_seconds.setter
    def toleration_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "toleration_seconds", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTopicOperatorArgs:
    def __init__(__self__, *,
                 image: Optional[pulumi.Input[str]] = None,
                 jvm_options: Optional[pulumi.Input['KafkaSpecEntityOperatorTopicOperatorJvmOptionsArgs']] = None,
                 liveness_probe: Optional[pulumi.Input['KafkaSpecEntityOperatorTopicOperatorLivenessProbeArgs']] = None,
                 logging: Optional[pulumi.Input['KafkaSpecEntityOperatorTopicOperatorLoggingArgs']] = None,
                 readiness_probe: Optional[pulumi.Input['KafkaSpecEntityOperatorTopicOperatorReadinessProbeArgs']] = None,
                 reconciliation_interval_seconds: Optional[pulumi.Input[int]] = None,
                 resources: Optional[pulumi.Input['KafkaSpecEntityOperatorTopicOperatorResourcesArgs']] = None,
                 topic_metadata_max_attempts: Optional[pulumi.Input[int]] = None,
                 watched_namespace: Optional[pulumi.Input[str]] = None,
                 zookeeper_session_timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        Configuration of the Topic Operator.
        :param pulumi.Input[str] image: The image to use for the Topic Operator.
        :param pulumi.Input['KafkaSpecEntityOperatorTopicOperatorJvmOptionsArgs'] jvm_options: JVM Options for pods.
        :param pulumi.Input['KafkaSpecEntityOperatorTopicOperatorLivenessProbeArgs'] liveness_probe: Pod liveness checking.
        :param pulumi.Input['KafkaSpecEntityOperatorTopicOperatorLoggingArgs'] logging: Logging configuration.
        :param pulumi.Input['KafkaSpecEntityOperatorTopicOperatorReadinessProbeArgs'] readiness_probe: Pod readiness checking.
        :param pulumi.Input[int] reconciliation_interval_seconds: Interval between periodic reconciliations.
        :param pulumi.Input['KafkaSpecEntityOperatorTopicOperatorResourcesArgs'] resources: CPU and memory resources to reserve.
        :param pulumi.Input[int] topic_metadata_max_attempts: The number of attempts at getting topic metadata.
        :param pulumi.Input[str] watched_namespace: The namespace the Topic Operator should watch.
        :param pulumi.Input[int] zookeeper_session_timeout_seconds: Timeout for the ZooKeeper session.
        """
        if image is not None:
            pulumi.set(__self__, "image", image)
        if jvm_options is not None:
            pulumi.set(__self__, "jvm_options", jvm_options)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if reconciliation_interval_seconds is not None:
            pulumi.set(__self__, "reconciliation_interval_seconds", reconciliation_interval_seconds)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if topic_metadata_max_attempts is not None:
            pulumi.set(__self__, "topic_metadata_max_attempts", topic_metadata_max_attempts)
        if watched_namespace is not None:
            pulumi.set(__self__, "watched_namespace", watched_namespace)
        if zookeeper_session_timeout_seconds is not None:
            pulumi.set(__self__, "zookeeper_session_timeout_seconds", zookeeper_session_timeout_seconds)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        The image to use for the Topic Operator.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="jvmOptions")
    def jvm_options(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTopicOperatorJvmOptionsArgs']]:
        """
        JVM Options for pods.
        """
        return pulumi.get(self, "jvm_options")

    @jvm_options.setter
    def jvm_options(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTopicOperatorJvmOptionsArgs']]):
        pulumi.set(self, "jvm_options", value)

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTopicOperatorLivenessProbeArgs']]:
        """
        Pod liveness checking.
        """
        return pulumi.get(self, "liveness_probe")

    @liveness_probe.setter
    def liveness_probe(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTopicOperatorLivenessProbeArgs']]):
        pulumi.set(self, "liveness_probe", value)

    @property
    @pulumi.getter
    def logging(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTopicOperatorLoggingArgs']]:
        """
        Logging configuration.
        """
        return pulumi.get(self, "logging")

    @logging.setter
    def logging(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTopicOperatorLoggingArgs']]):
        pulumi.set(self, "logging", value)

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTopicOperatorReadinessProbeArgs']]:
        """
        Pod readiness checking.
        """
        return pulumi.get(self, "readiness_probe")

    @readiness_probe.setter
    def readiness_probe(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTopicOperatorReadinessProbeArgs']]):
        pulumi.set(self, "readiness_probe", value)

    @property
    @pulumi.getter(name="reconciliationIntervalSeconds")
    def reconciliation_interval_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Interval between periodic reconciliations.
        """
        return pulumi.get(self, "reconciliation_interval_seconds")

    @reconciliation_interval_seconds.setter
    def reconciliation_interval_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "reconciliation_interval_seconds", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorTopicOperatorResourcesArgs']]:
        """
        CPU and memory resources to reserve.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorTopicOperatorResourcesArgs']]):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter(name="topicMetadataMaxAttempts")
    def topic_metadata_max_attempts(self) -> Optional[pulumi.Input[int]]:
        """
        The number of attempts at getting topic metadata.
        """
        return pulumi.get(self, "topic_metadata_max_attempts")

    @topic_metadata_max_attempts.setter
    def topic_metadata_max_attempts(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "topic_metadata_max_attempts", value)

    @property
    @pulumi.getter(name="watchedNamespace")
    def watched_namespace(self) -> Optional[pulumi.Input[str]]:
        """
        The namespace the Topic Operator should watch.
        """
        return pulumi.get(self, "watched_namespace")

    @watched_namespace.setter
    def watched_namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "watched_namespace", value)

    @property
    @pulumi.getter(name="zookeeperSessionTimeoutSeconds")
    def zookeeper_session_timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Timeout for the ZooKeeper session.
        """
        return pulumi.get(self, "zookeeper_session_timeout_seconds")

    @zookeeper_session_timeout_seconds.setter
    def zookeeper_session_timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "zookeeper_session_timeout_seconds", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTopicOperatorJvmOptionsArgs:
    def __init__(__self__, *,
                 __xx: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 __xms: Optional[pulumi.Input[str]] = None,
                 __xmx: Optional[pulumi.Input[str]] = None,
                 gc_logging_enabled: Optional[pulumi.Input[bool]] = None,
                 java_system_properties: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTopicOperatorJvmOptionsJavaSystemPropertiesArgs']]]] = None):
        """
        JVM Options for pods.
        :param pulumi.Input[Mapping[str, Any]] __xx: A map of -XX options to the JVM.
        :param pulumi.Input[str] __xms: -Xms option to to the JVM.
        :param pulumi.Input[str] __xmx: -Xmx option to to the JVM.
        :param pulumi.Input[bool] gc_logging_enabled: Specifies whether the Garbage Collection logging is enabled. The default is false.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTopicOperatorJvmOptionsJavaSystemPropertiesArgs']]] java_system_properties: A map of additional system properties which will be passed using the `-D` option to the JVM.
        """
        if __xx is not None:
            pulumi.set(__self__, "__xx", __xx)
        if __xms is not None:
            pulumi.set(__self__, "__xms", __xms)
        if __xmx is not None:
            pulumi.set(__self__, "__xmx", __xmx)
        if gc_logging_enabled is not None:
            pulumi.set(__self__, "gc_logging_enabled", gc_logging_enabled)
        if java_system_properties is not None:
            pulumi.set(__self__, "java_system_properties", java_system_properties)

    @property
    @pulumi.getter(name="-XX")
    def __xx(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        A map of -XX options to the JVM.
        """
        return pulumi.get(self, "__xx")

    @__xx.setter
    def __xx(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "__xx", value)

    @property
    @pulumi.getter(name="-Xms")
    def __xms(self) -> Optional[pulumi.Input[str]]:
        """
        -Xms option to to the JVM.
        """
        return pulumi.get(self, "__xms")

    @__xms.setter
    def __xms(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "__xms", value)

    @property
    @pulumi.getter(name="-Xmx")
    def __xmx(self) -> Optional[pulumi.Input[str]]:
        """
        -Xmx option to to the JVM.
        """
        return pulumi.get(self, "__xmx")

    @__xmx.setter
    def __xmx(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "__xmx", value)

    @property
    @pulumi.getter(name="gcLoggingEnabled")
    def gc_logging_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether the Garbage Collection logging is enabled. The default is false.
        """
        return pulumi.get(self, "gc_logging_enabled")

    @gc_logging_enabled.setter
    def gc_logging_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "gc_logging_enabled", value)

    @property
    @pulumi.getter(name="javaSystemProperties")
    def java_system_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTopicOperatorJvmOptionsJavaSystemPropertiesArgs']]]]:
        """
        A map of additional system properties which will be passed using the `-D` option to the JVM.
        """
        return pulumi.get(self, "java_system_properties")

    @java_system_properties.setter
    def java_system_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorTopicOperatorJvmOptionsJavaSystemPropertiesArgs']]]]):
        pulumi.set(self, "java_system_properties", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTopicOperatorJvmOptionsJavaSystemPropertiesArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The system property name.
        :param pulumi.Input[str] value: The system property value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The system property name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The system property value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTopicOperatorLivenessProbeArgs:
    def __init__(__self__, *,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 success_threshold: Optional[pulumi.Input[int]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        Pod liveness checking.
        :param pulumi.Input[int] failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param pulumi.Input[int] initial_delay_seconds: The initial delay before first the health is first checked.
        :param pulumi.Input[int] period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param pulumi.Input[int] success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param pulumi.Input[int] timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "success_threshold", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTopicOperatorLoggingArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 loggers: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        Logging configuration.
        :param pulumi.Input[str] type: Logging type, must be either 'inline' or 'external'.
        :param pulumi.Input[Mapping[str, Any]] loggers: A Map from logger name to logger level.
        :param pulumi.Input[str] name: The name of the `ConfigMap` from which to get the logging configuration.
        """
        pulumi.set(__self__, "type", type)
        if loggers is not None:
            pulumi.set(__self__, "loggers", loggers)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Logging type, must be either 'inline' or 'external'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def loggers(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        A Map from logger name to logger level.
        """
        return pulumi.get(self, "loggers")

    @loggers.setter
    def loggers(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "loggers", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the `ConfigMap` from which to get the logging configuration.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTopicOperatorReadinessProbeArgs:
    def __init__(__self__, *,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 success_threshold: Optional[pulumi.Input[int]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        Pod readiness checking.
        :param pulumi.Input[int] failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param pulumi.Input[int] initial_delay_seconds: The initial delay before first the health is first checked.
        :param pulumi.Input[int] period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param pulumi.Input[int] success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param pulumi.Input[int] timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "success_threshold", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


@pulumi.input_type
class KafkaSpecEntityOperatorTopicOperatorResourcesArgs:
    def __init__(__self__, *,
                 limits: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 requests: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        CPU and memory resources to reserve.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "limits", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "requests", value)


@pulumi.input_type
class KafkaSpecEntityOperatorUserOperatorArgs:
    def __init__(__self__, *,
                 image: Optional[pulumi.Input[str]] = None,
                 jvm_options: Optional[pulumi.Input['KafkaSpecEntityOperatorUserOperatorJvmOptionsArgs']] = None,
                 liveness_probe: Optional[pulumi.Input['KafkaSpecEntityOperatorUserOperatorLivenessProbeArgs']] = None,
                 logging: Optional[pulumi.Input['KafkaSpecEntityOperatorUserOperatorLoggingArgs']] = None,
                 readiness_probe: Optional[pulumi.Input['KafkaSpecEntityOperatorUserOperatorReadinessProbeArgs']] = None,
                 reconciliation_interval_seconds: Optional[pulumi.Input[int]] = None,
                 resources: Optional[pulumi.Input['KafkaSpecEntityOperatorUserOperatorResourcesArgs']] = None,
                 watched_namespace: Optional[pulumi.Input[str]] = None,
                 zookeeper_session_timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        Configuration of the User Operator.
        :param pulumi.Input[str] image: The image to use for the User Operator.
        :param pulumi.Input['KafkaSpecEntityOperatorUserOperatorJvmOptionsArgs'] jvm_options: JVM Options for pods.
        :param pulumi.Input['KafkaSpecEntityOperatorUserOperatorLivenessProbeArgs'] liveness_probe: Pod liveness checking.
        :param pulumi.Input['KafkaSpecEntityOperatorUserOperatorLoggingArgs'] logging: Logging configuration.
        :param pulumi.Input['KafkaSpecEntityOperatorUserOperatorReadinessProbeArgs'] readiness_probe: Pod readiness checking.
        :param pulumi.Input[int] reconciliation_interval_seconds: Interval between periodic reconciliations.
        :param pulumi.Input['KafkaSpecEntityOperatorUserOperatorResourcesArgs'] resources: CPU and memory resources to reserve.
        :param pulumi.Input[str] watched_namespace: The namespace the User Operator should watch.
        :param pulumi.Input[int] zookeeper_session_timeout_seconds: Timeout for the ZooKeeper session.
        """
        if image is not None:
            pulumi.set(__self__, "image", image)
        if jvm_options is not None:
            pulumi.set(__self__, "jvm_options", jvm_options)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if reconciliation_interval_seconds is not None:
            pulumi.set(__self__, "reconciliation_interval_seconds", reconciliation_interval_seconds)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if watched_namespace is not None:
            pulumi.set(__self__, "watched_namespace", watched_namespace)
        if zookeeper_session_timeout_seconds is not None:
            pulumi.set(__self__, "zookeeper_session_timeout_seconds", zookeeper_session_timeout_seconds)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        The image to use for the User Operator.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="jvmOptions")
    def jvm_options(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorUserOperatorJvmOptionsArgs']]:
        """
        JVM Options for pods.
        """
        return pulumi.get(self, "jvm_options")

    @jvm_options.setter
    def jvm_options(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorUserOperatorJvmOptionsArgs']]):
        pulumi.set(self, "jvm_options", value)

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorUserOperatorLivenessProbeArgs']]:
        """
        Pod liveness checking.
        """
        return pulumi.get(self, "liveness_probe")

    @liveness_probe.setter
    def liveness_probe(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorUserOperatorLivenessProbeArgs']]):
        pulumi.set(self, "liveness_probe", value)

    @property
    @pulumi.getter
    def logging(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorUserOperatorLoggingArgs']]:
        """
        Logging configuration.
        """
        return pulumi.get(self, "logging")

    @logging.setter
    def logging(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorUserOperatorLoggingArgs']]):
        pulumi.set(self, "logging", value)

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorUserOperatorReadinessProbeArgs']]:
        """
        Pod readiness checking.
        """
        return pulumi.get(self, "readiness_probe")

    @readiness_probe.setter
    def readiness_probe(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorUserOperatorReadinessProbeArgs']]):
        pulumi.set(self, "readiness_probe", value)

    @property
    @pulumi.getter(name="reconciliationIntervalSeconds")
    def reconciliation_interval_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Interval between periodic reconciliations.
        """
        return pulumi.get(self, "reconciliation_interval_seconds")

    @reconciliation_interval_seconds.setter
    def reconciliation_interval_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "reconciliation_interval_seconds", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['KafkaSpecEntityOperatorUserOperatorResourcesArgs']]:
        """
        CPU and memory resources to reserve.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['KafkaSpecEntityOperatorUserOperatorResourcesArgs']]):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter(name="watchedNamespace")
    def watched_namespace(self) -> Optional[pulumi.Input[str]]:
        """
        The namespace the User Operator should watch.
        """
        return pulumi.get(self, "watched_namespace")

    @watched_namespace.setter
    def watched_namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "watched_namespace", value)

    @property
    @pulumi.getter(name="zookeeperSessionTimeoutSeconds")
    def zookeeper_session_timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Timeout for the ZooKeeper session.
        """
        return pulumi.get(self, "zookeeper_session_timeout_seconds")

    @zookeeper_session_timeout_seconds.setter
    def zookeeper_session_timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "zookeeper_session_timeout_seconds", value)


@pulumi.input_type
class KafkaSpecEntityOperatorUserOperatorJvmOptionsArgs:
    def __init__(__self__, *,
                 __xx: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 __xms: Optional[pulumi.Input[str]] = None,
                 __xmx: Optional[pulumi.Input[str]] = None,
                 gc_logging_enabled: Optional[pulumi.Input[bool]] = None,
                 java_system_properties: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorUserOperatorJvmOptionsJavaSystemPropertiesArgs']]]] = None):
        """
        JVM Options for pods.
        :param pulumi.Input[Mapping[str, Any]] __xx: A map of -XX options to the JVM.
        :param pulumi.Input[str] __xms: -Xms option to to the JVM.
        :param pulumi.Input[str] __xmx: -Xmx option to to the JVM.
        :param pulumi.Input[bool] gc_logging_enabled: Specifies whether the Garbage Collection logging is enabled. The default is false.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorUserOperatorJvmOptionsJavaSystemPropertiesArgs']]] java_system_properties: A map of additional system properties which will be passed using the `-D` option to the JVM.
        """
        if __xx is not None:
            pulumi.set(__self__, "__xx", __xx)
        if __xms is not None:
            pulumi.set(__self__, "__xms", __xms)
        if __xmx is not None:
            pulumi.set(__self__, "__xmx", __xmx)
        if gc_logging_enabled is not None:
            pulumi.set(__self__, "gc_logging_enabled", gc_logging_enabled)
        if java_system_properties is not None:
            pulumi.set(__self__, "java_system_properties", java_system_properties)

    @property
    @pulumi.getter(name="-XX")
    def __xx(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        A map of -XX options to the JVM.
        """
        return pulumi.get(self, "__xx")

    @__xx.setter
    def __xx(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "__xx", value)

    @property
    @pulumi.getter(name="-Xms")
    def __xms(self) -> Optional[pulumi.Input[str]]:
        """
        -Xms option to to the JVM.
        """
        return pulumi.get(self, "__xms")

    @__xms.setter
    def __xms(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "__xms", value)

    @property
    @pulumi.getter(name="-Xmx")
    def __xmx(self) -> Optional[pulumi.Input[str]]:
        """
        -Xmx option to to the JVM.
        """
        return pulumi.get(self, "__xmx")

    @__xmx.setter
    def __xmx(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "__xmx", value)

    @property
    @pulumi.getter(name="gcLoggingEnabled")
    def gc_logging_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether the Garbage Collection logging is enabled. The default is false.
        """
        return pulumi.get(self, "gc_logging_enabled")

    @gc_logging_enabled.setter
    def gc_logging_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "gc_logging_enabled", value)

    @property
    @pulumi.getter(name="javaSystemProperties")
    def java_system_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorUserOperatorJvmOptionsJavaSystemPropertiesArgs']]]]:
        """
        A map of additional system properties which will be passed using the `-D` option to the JVM.
        """
        return pulumi.get(self, "java_system_properties")

    @java_system_properties.setter
    def java_system_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecEntityOperatorUserOperatorJvmOptionsJavaSystemPropertiesArgs']]]]):
        pulumi.set(self, "java_system_properties", value)


@pulumi.input_type
class KafkaSpecEntityOperatorUserOperatorJvmOptionsJavaSystemPropertiesArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The system property name.
        :param pulumi.Input[str] value: The system property value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The system property name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The system property value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaSpecEntityOperatorUserOperatorLivenessProbeArgs:
    def __init__(__self__, *,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 success_threshold: Optional[pulumi.Input[int]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        Pod liveness checking.
        :param pulumi.Input[int] failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param pulumi.Input[int] initial_delay_seconds: The initial delay before first the health is first checked.
        :param pulumi.Input[int] period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param pulumi.Input[int] success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param pulumi.Input[int] timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "success_threshold", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


@pulumi.input_type
class KafkaSpecEntityOperatorUserOperatorLoggingArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 loggers: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        Logging configuration.
        :param pulumi.Input[str] type: Logging type, must be either 'inline' or 'external'.
        :param pulumi.Input[Mapping[str, Any]] loggers: A Map from logger name to logger level.
        :param pulumi.Input[str] name: The name of the `ConfigMap` from which to get the logging configuration.
        """
        pulumi.set(__self__, "type", type)
        if loggers is not None:
            pulumi.set(__self__, "loggers", loggers)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Logging type, must be either 'inline' or 'external'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def loggers(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        A Map from logger name to logger level.
        """
        return pulumi.get(self, "loggers")

    @loggers.setter
    def loggers(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "loggers", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the `ConfigMap` from which to get the logging configuration.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class KafkaSpecEntityOperatorUserOperatorReadinessProbeArgs:
    def __init__(__self__, *,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 success_threshold: Optional[pulumi.Input[int]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        Pod readiness checking.
        :param pulumi.Input[int] failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param pulumi.Input[int] initial_delay_seconds: The initial delay before first the health is first checked.
        :param pulumi.Input[int] period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param pulumi.Input[int] success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param pulumi.Input[int] timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "success_threshold", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


@pulumi.input_type
class KafkaSpecEntityOperatorUserOperatorResourcesArgs:
    def __init__(__self__, *,
                 limits: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 requests: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        CPU and memory resources to reserve.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "limits", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "requests", value)


@pulumi.input_type
class KafkaSpecJmxTransArgs:
    def __init__(__self__, *,
                 kafka_queries: pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransKafkaQueriesArgs']]],
                 output_definitions: pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransOutputDefinitionsArgs']]],
                 image: Optional[pulumi.Input[str]] = None,
                 log_level: Optional[pulumi.Input[str]] = None,
                 resources: Optional[pulumi.Input['KafkaSpecJmxTransResourcesArgs']] = None,
                 template: Optional[pulumi.Input['KafkaSpecJmxTransTemplateArgs']] = None):
        """
        Configuration for JmxTrans. When the property is present a JmxTrans deployment is created for gathering JMX metrics from each Kafka broker. For more information see https://github.com/jmxtrans/jmxtrans[JmxTrans GitHub].
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransKafkaQueriesArgs']]] kafka_queries: Queries to send to the Kafka brokers to define what data should be read from each broker. For more information on these properties see, xref:type-JmxTransQueryTemplate-reference[`JmxTransQueryTemplate` schema reference].
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransOutputDefinitionsArgs']]] output_definitions: Defines the output hosts that will be referenced later on. For more information on these properties see, xref:type-JmxTransOutputDefinitionTemplate-reference[`JmxTransOutputDefinitionTemplate` schema reference].
        :param pulumi.Input[str] image: The image to use for the JmxTrans.
        :param pulumi.Input[str] log_level: Sets the logging level of the JmxTrans deployment.For more information see, https://github.com/jmxtrans/jmxtrans-agent/wiki/Troubleshooting[JmxTrans Logging Level].
        :param pulumi.Input['KafkaSpecJmxTransResourcesArgs'] resources: CPU and memory resources to reserve.
        :param pulumi.Input['KafkaSpecJmxTransTemplateArgs'] template: Template for JmxTrans resources.
        """
        pulumi.set(__self__, "kafka_queries", kafka_queries)
        pulumi.set(__self__, "output_definitions", output_definitions)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @property
    @pulumi.getter(name="kafkaQueries")
    def kafka_queries(self) -> pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransKafkaQueriesArgs']]]:
        """
        Queries to send to the Kafka brokers to define what data should be read from each broker. For more information on these properties see, xref:type-JmxTransQueryTemplate-reference[`JmxTransQueryTemplate` schema reference].
        """
        return pulumi.get(self, "kafka_queries")

    @kafka_queries.setter
    def kafka_queries(self, value: pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransKafkaQueriesArgs']]]):
        pulumi.set(self, "kafka_queries", value)

    @property
    @pulumi.getter(name="outputDefinitions")
    def output_definitions(self) -> pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransOutputDefinitionsArgs']]]:
        """
        Defines the output hosts that will be referenced later on. For more information on these properties see, xref:type-JmxTransOutputDefinitionTemplate-reference[`JmxTransOutputDefinitionTemplate` schema reference].
        """
        return pulumi.get(self, "output_definitions")

    @output_definitions.setter
    def output_definitions(self, value: pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransOutputDefinitionsArgs']]]):
        pulumi.set(self, "output_definitions", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        The image to use for the JmxTrans.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[pulumi.Input[str]]:
        """
        Sets the logging level of the JmxTrans deployment.For more information see, https://github.com/jmxtrans/jmxtrans-agent/wiki/Troubleshooting[JmxTrans Logging Level].
        """
        return pulumi.get(self, "log_level")

    @log_level.setter
    def log_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_level", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['KafkaSpecJmxTransResourcesArgs']]:
        """
        CPU and memory resources to reserve.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['KafkaSpecJmxTransResourcesArgs']]):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter
    def template(self) -> Optional[pulumi.Input['KafkaSpecJmxTransTemplateArgs']]:
        """
        Template for JmxTrans resources.
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[pulumi.Input['KafkaSpecJmxTransTemplateArgs']]):
        pulumi.set(self, "template", value)


@pulumi.input_type
class KafkaSpecJmxTransKafkaQueriesArgs:
    def __init__(__self__, *,
                 attributes: pulumi.Input[Sequence[pulumi.Input[str]]],
                 outputs: pulumi.Input[Sequence[pulumi.Input[str]]],
                 target_m_bean: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] attributes: Determine which attributes of the targeted MBean should be included.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] outputs: List of the names of output definitions specified in the spec.kafka.jmxTrans.outputDefinitions that have defined where JMX metrics are pushed to, and in which data format.
        :param pulumi.Input[str] target_m_bean: If using wildcards instead of a specific MBean then the data is gathered from multiple MBeans. Otherwise if specifying an MBean then data is gathered from that specified MBean.
        """
        pulumi.set(__self__, "attributes", attributes)
        pulumi.set(__self__, "outputs", outputs)
        pulumi.set(__self__, "target_m_bean", target_m_bean)

    @property
    @pulumi.getter
    def attributes(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Determine which attributes of the targeted MBean should be included.
        """
        return pulumi.get(self, "attributes")

    @attributes.setter
    def attributes(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "attributes", value)

    @property
    @pulumi.getter
    def outputs(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of the names of output definitions specified in the spec.kafka.jmxTrans.outputDefinitions that have defined where JMX metrics are pushed to, and in which data format.
        """
        return pulumi.get(self, "outputs")

    @outputs.setter
    def outputs(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "outputs", value)

    @property
    @pulumi.getter(name="targetMBean")
    def target_m_bean(self) -> pulumi.Input[str]:
        """
        If using wildcards instead of a specific MBean then the data is gathered from multiple MBeans. Otherwise if specifying an MBean then data is gathered from that specified MBean.
        """
        return pulumi.get(self, "target_m_bean")

    @target_m_bean.setter
    def target_m_bean(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_m_bean", value)


@pulumi.input_type
class KafkaSpecJmxTransOutputDefinitionsArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 output_type: pulumi.Input[str],
                 flush_delay_in_seconds: Optional[pulumi.Input[int]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 type_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: Template for setting the name of the output definition. This is used to identify where to send the results of queries should be sent.
        :param pulumi.Input[str] output_type: Template for setting the format of the data that will be pushed.For more information see https://github.com/jmxtrans/jmxtrans/wiki/OutputWriters[JmxTrans OutputWriters].
        :param pulumi.Input[int] flush_delay_in_seconds: How many seconds the JmxTrans waits before pushing a new set of data out.
        :param pulumi.Input[str] host: The DNS/hostname of the remote host that the data is pushed to.
        :param pulumi.Input[int] port: The port of the remote host that the data is pushed to.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] type_names: Template for filtering data to be included in response to a wildcard query. For more information see https://github.com/jmxtrans/jmxtrans/wiki/Queries[JmxTrans queries].
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "output_type", output_type)
        if flush_delay_in_seconds is not None:
            pulumi.set(__self__, "flush_delay_in_seconds", flush_delay_in_seconds)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if type_names is not None:
            pulumi.set(__self__, "type_names", type_names)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Template for setting the name of the output definition. This is used to identify where to send the results of queries should be sent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="outputType")
    def output_type(self) -> pulumi.Input[str]:
        """
        Template for setting the format of the data that will be pushed.For more information see https://github.com/jmxtrans/jmxtrans/wiki/OutputWriters[JmxTrans OutputWriters].
        """
        return pulumi.get(self, "output_type")

    @output_type.setter
    def output_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "output_type", value)

    @property
    @pulumi.getter(name="flushDelayInSeconds")
    def flush_delay_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        How many seconds the JmxTrans waits before pushing a new set of data out.
        """
        return pulumi.get(self, "flush_delay_in_seconds")

    @flush_delay_in_seconds.setter
    def flush_delay_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "flush_delay_in_seconds", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        The DNS/hostname of the remote host that the data is pushed to.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port of the remote host that the data is pushed to.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="typeNames")
    def type_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Template for filtering data to be included in response to a wildcard query. For more information see https://github.com/jmxtrans/jmxtrans/wiki/Queries[JmxTrans queries].
        """
        return pulumi.get(self, "type_names")

    @type_names.setter
    def type_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "type_names", value)


@pulumi.input_type
class KafkaSpecJmxTransResourcesArgs:
    def __init__(__self__, *,
                 limits: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 requests: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        CPU and memory resources to reserve.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "limits", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "requests", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplateArgs:
    def __init__(__self__, *,
                 container: Optional[pulumi.Input['KafkaSpecJmxTransTemplateContainerArgs']] = None,
                 deployment: Optional[pulumi.Input['KafkaSpecJmxTransTemplateDeploymentArgs']] = None,
                 pod: Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodArgs']] = None):
        """
        Template for JmxTrans resources.
        :param pulumi.Input['KafkaSpecJmxTransTemplateContainerArgs'] container: Template for JmxTrans container.
        :param pulumi.Input['KafkaSpecJmxTransTemplateDeploymentArgs'] deployment: Template for JmxTrans `Deployment`.
        :param pulumi.Input['KafkaSpecJmxTransTemplatePodArgs'] pod: Template for JmxTrans `Pods`.
        """
        if container is not None:
            pulumi.set(__self__, "container", container)
        if deployment is not None:
            pulumi.set(__self__, "deployment", deployment)
        if pod is not None:
            pulumi.set(__self__, "pod", pod)

    @property
    @pulumi.getter
    def container(self) -> Optional[pulumi.Input['KafkaSpecJmxTransTemplateContainerArgs']]:
        """
        Template for JmxTrans container.
        """
        return pulumi.get(self, "container")

    @container.setter
    def container(self, value: Optional[pulumi.Input['KafkaSpecJmxTransTemplateContainerArgs']]):
        pulumi.set(self, "container", value)

    @property
    @pulumi.getter
    def deployment(self) -> Optional[pulumi.Input['KafkaSpecJmxTransTemplateDeploymentArgs']]:
        """
        Template for JmxTrans `Deployment`.
        """
        return pulumi.get(self, "deployment")

    @deployment.setter
    def deployment(self, value: Optional[pulumi.Input['KafkaSpecJmxTransTemplateDeploymentArgs']]):
        pulumi.set(self, "deployment", value)

    @property
    @pulumi.getter
    def pod(self) -> Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodArgs']]:
        """
        Template for JmxTrans `Pods`.
        """
        return pulumi.get(self, "pod")

    @pod.setter
    def pod(self, value: Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodArgs']]):
        pulumi.set(self, "pod", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplateContainerArgs:
    def __init__(__self__, *,
                 env: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplateContainerEnvArgs']]]] = None,
                 security_context: Optional[pulumi.Input['KafkaSpecJmxTransTemplateContainerSecurityContextArgs']] = None):
        """
        Template for JmxTrans container.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplateContainerEnvArgs']]] env: Environment variables which should be applied to the container.
        :param pulumi.Input['KafkaSpecJmxTransTemplateContainerSecurityContextArgs'] security_context: Security context for the container.
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)

    @property
    @pulumi.getter
    def env(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplateContainerEnvArgs']]]]:
        """
        Environment variables which should be applied to the container.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplateContainerEnvArgs']]]]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional[pulumi.Input['KafkaSpecJmxTransTemplateContainerSecurityContextArgs']]:
        """
        Security context for the container.
        """
        return pulumi.get(self, "security_context")

    @security_context.setter
    def security_context(self, value: Optional[pulumi.Input['KafkaSpecJmxTransTemplateContainerSecurityContextArgs']]):
        pulumi.set(self, "security_context", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplateContainerEnvArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The environment variable key.
        :param pulumi.Input[str] value: The environment variable value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The environment variable key.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The environment variable value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplateContainerSecurityContextArgs:
    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[pulumi.Input[bool]] = None,
                 capabilities: Optional[pulumi.Input['KafkaSpecJmxTransTemplateContainerSecurityContextCapabilitiesArgs']] = None,
                 privileged: Optional[pulumi.Input[bool]] = None,
                 proc_mount: Optional[pulumi.Input[str]] = None,
                 read_only_root_filesystem: Optional[pulumi.Input[bool]] = None,
                 run_as_group: Optional[pulumi.Input[int]] = None,
                 run_as_non_root: Optional[pulumi.Input[bool]] = None,
                 run_as_user: Optional[pulumi.Input[int]] = None,
                 se_linux_options: Optional[pulumi.Input['KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptionsArgs']] = None,
                 windows_options: Optional[pulumi.Input['KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptionsArgs']] = None):
        """
        Security context for the container.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if proc_mount is not None:
            pulumi.set(__self__, "proc_mount", proc_mount)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "allow_privilege_escalation")

    @allow_privilege_escalation.setter
    def allow_privilege_escalation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_privilege_escalation", value)

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[pulumi.Input['KafkaSpecJmxTransTemplateContainerSecurityContextCapabilitiesArgs']]:
        return pulumi.get(self, "capabilities")

    @capabilities.setter
    def capabilities(self, value: Optional[pulumi.Input['KafkaSpecJmxTransTemplateContainerSecurityContextCapabilitiesArgs']]):
        pulumi.set(self, "capabilities", value)

    @property
    @pulumi.getter
    def privileged(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "privileged")

    @privileged.setter
    def privileged(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "privileged", value)

    @property
    @pulumi.getter(name="procMount")
    def proc_mount(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "proc_mount")

    @proc_mount.setter
    def proc_mount(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proc_mount", value)

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "read_only_root_filesystem")

    @read_only_root_filesystem.setter
    def read_only_root_filesystem(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "read_only_root_filesystem", value)

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_group")

    @run_as_group.setter
    def run_as_group(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_group", value)

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "run_as_non_root")

    @run_as_non_root.setter
    def run_as_non_root(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_as_non_root", value)

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_user")

    @run_as_user.setter
    def run_as_user(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_user", value)

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional[pulumi.Input['KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptionsArgs']]:
        return pulumi.get(self, "se_linux_options")

    @se_linux_options.setter
    def se_linux_options(self, value: Optional[pulumi.Input['KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptionsArgs']]):
        pulumi.set(self, "se_linux_options", value)

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional[pulumi.Input['KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptionsArgs']]:
        return pulumi.get(self, "windows_options")

    @windows_options.setter
    def windows_options(self, value: Optional[pulumi.Input['KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptionsArgs']]):
        pulumi.set(self, "windows_options", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplateContainerSecurityContextCapabilitiesArgs:
    def __init__(__self__, *,
                 add: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 drop: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)

    @property
    @pulumi.getter
    def add(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "add")

    @add.setter
    def add(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "add", value)

    @property
    @pulumi.getter
    def drop(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "drop")

    @drop.setter
    def drop(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "drop", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptionsArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptionsArgs:
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[pulumi.Input[str]] = None,
                 gmsa_credential_spec_name: Optional[pulumi.Input[str]] = None,
                 run_as_user_name: Optional[pulumi.Input[str]] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec")

    @gmsa_credential_spec.setter
    def gmsa_credential_spec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec", value)

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @gmsa_credential_spec_name.setter
    def gmsa_credential_spec_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec_name", value)

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "run_as_user_name")

    @run_as_user_name.setter
    def run_as_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "run_as_user_name", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplateDeploymentArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input['KafkaSpecJmxTransTemplateDeploymentMetadataArgs']] = None):
        """
        Template for JmxTrans `Deployment`.
        :param pulumi.Input['KafkaSpecJmxTransTemplateDeploymentMetadataArgs'] metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['KafkaSpecJmxTransTemplateDeploymentMetadataArgs']]:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['KafkaSpecJmxTransTemplateDeploymentMetadataArgs']]):
        pulumi.set(self, "metadata", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplateDeploymentMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Metadata applied to the resource.
        :param pulumi.Input[Mapping[str, Any]] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param pulumi.Input[Mapping[str, Any]] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplatePodArgs:
    def __init__(__self__, *,
                 affinity: Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityArgs']] = None,
                 host_aliases: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodHostAliasesArgs']]]] = None,
                 image_pull_secrets: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodImagePullSecretsArgs']]]] = None,
                 metadata: Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodMetadataArgs']] = None,
                 priority_class_name: Optional[pulumi.Input[str]] = None,
                 scheduler_name: Optional[pulumi.Input[str]] = None,
                 security_context: Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodSecurityContextArgs']] = None,
                 termination_grace_period_seconds: Optional[pulumi.Input[int]] = None,
                 tolerations: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodTolerationsArgs']]]] = None):
        """
        Template for JmxTrans `Pods`.
        :param pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityArgs'] affinity: The pod's affinity rules.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodHostAliasesArgs']]] host_aliases: The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodImagePullSecretsArgs']]] image_pull_secrets: List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
        :param pulumi.Input['KafkaSpecJmxTransTemplatePodMetadataArgs'] metadata: Metadata applied to the resource.
        :param pulumi.Input[str] priority_class_name: The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
        :param pulumi.Input[str] scheduler_name: The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
        :param pulumi.Input['KafkaSpecJmxTransTemplatePodSecurityContextArgs'] security_context: Configures pod-level security attributes and common container settings.
        :param pulumi.Input[int] termination_grace_period_seconds: The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodTolerationsArgs']]] tolerations: The pod's tolerations.
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if host_aliases is not None:
            pulumi.set(__self__, "host_aliases", host_aliases)
        if image_pull_secrets is not None:
            pulumi.set(__self__, "image_pull_secrets", image_pull_secrets)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if priority_class_name is not None:
            pulumi.set(__self__, "priority_class_name", priority_class_name)
        if scheduler_name is not None:
            pulumi.set(__self__, "scheduler_name", scheduler_name)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)

    @property
    @pulumi.getter
    def affinity(self) -> Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityArgs']]:
        """
        The pod's affinity rules.
        """
        return pulumi.get(self, "affinity")

    @affinity.setter
    def affinity(self, value: Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityArgs']]):
        pulumi.set(self, "affinity", value)

    @property
    @pulumi.getter(name="hostAliases")
    def host_aliases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodHostAliasesArgs']]]]:
        """
        The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
        """
        return pulumi.get(self, "host_aliases")

    @host_aliases.setter
    def host_aliases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodHostAliasesArgs']]]]):
        pulumi.set(self, "host_aliases", value)

    @property
    @pulumi.getter(name="imagePullSecrets")
    def image_pull_secrets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodImagePullSecretsArgs']]]]:
        """
        List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
        """
        return pulumi.get(self, "image_pull_secrets")

    @image_pull_secrets.setter
    def image_pull_secrets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodImagePullSecretsArgs']]]]):
        pulumi.set(self, "image_pull_secrets", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodMetadataArgs']]:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodMetadataArgs']]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter(name="priorityClassName")
    def priority_class_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
        """
        return pulumi.get(self, "priority_class_name")

    @priority_class_name.setter
    def priority_class_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "priority_class_name", value)

    @property
    @pulumi.getter(name="schedulerName")
    def scheduler_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
        """
        return pulumi.get(self, "scheduler_name")

    @scheduler_name.setter
    def scheduler_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scheduler_name", value)

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodSecurityContextArgs']]:
        """
        Configures pod-level security attributes and common container settings.
        """
        return pulumi.get(self, "security_context")

    @security_context.setter
    def security_context(self, value: Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodSecurityContextArgs']]):
        pulumi.set(self, "security_context", value)

    @property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
        """
        return pulumi.get(self, "termination_grace_period_seconds")

    @termination_grace_period_seconds.setter
    def termination_grace_period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "termination_grace_period_seconds", value)

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodTolerationsArgs']]]]:
        """
        The pod's tolerations.
        """
        return pulumi.get(self, "tolerations")

    @tolerations.setter
    def tolerations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodTolerationsArgs']]]]):
        pulumi.set(self, "tolerations", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplatePodAffinityArgs:
    def __init__(__self__, *,
                 node_affinity: Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityNodeAffinityArgs']] = None,
                 pod_affinity: Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAffinityArgs']] = None,
                 pod_anti_affinity: Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityArgs']] = None):
        """
        The pod's affinity rules.
        """
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityNodeAffinityArgs']]:
        return pulumi.get(self, "node_affinity")

    @node_affinity.setter
    def node_affinity(self, value: Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityNodeAffinityArgs']]):
        pulumi.set(self, "node_affinity", value)

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAffinityArgs']]:
        return pulumi.get(self, "pod_affinity")

    @pod_affinity.setter
    def pod_affinity(self, value: Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAffinityArgs']]):
        pulumi.set(self, "pod_affinity", value)

    @property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityArgs']]:
        return pulumi.get(self, "pod_anti_affinity")

    @pod_anti_affinity.setter
    def pod_anti_affinity(self, value: Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityArgs']]):
        pulumi.set(self, "pod_anti_affinity", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplatePodAffinityNodeAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 preference: Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']]:
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]] = None,
                 match_fields: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]]:
        return pulumi.get(self, "match_fields")

    @match_fields.setter
    def match_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]]):
        pulumi.set(self, "match_fields", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 node_selector_terms: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]] = None):
        if node_selector_terms is not None:
            pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]]:
        return pulumi.get(self, "node_selector_terms")

    @node_selector_terms.setter
    def node_selector_terms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]]):
        pulumi.set(self, "node_selector_terms", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]] = None,
                 match_fields: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]]:
        return pulumi.get(self, "match_fields")

    @match_fields.setter
    def match_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]]):
        pulumi.set(self, "match_fields", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplatePodAffinityPodAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 pod_affinity_term: Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]:
        return pulumi.get(self, "pod_affinity_term")

    @pod_affinity_term.setter
    def pod_affinity_term(self, value: Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]):
        pulumi.set(self, "pod_affinity_term", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 pod_affinity_term: Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]:
        return pulumi.get(self, "pod_affinity_term")

    @pod_affinity_term.setter
    def pod_affinity_term(self, value: Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]):
        pulumi.set(self, "pod_affinity_term", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplatePodHostAliasesArgs:
    def __init__(__self__, *,
                 hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ip: Optional[pulumi.Input[str]] = None):
        if hostnames is not None:
            pulumi.set(__self__, "hostnames", hostnames)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def hostnames(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "hostnames")

    @hostnames.setter
    def hostnames(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hostnames", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplatePodImagePullSecretsArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplatePodMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Metadata applied to the resource.
        :param pulumi.Input[Mapping[str, Any]] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param pulumi.Input[Mapping[str, Any]] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplatePodSecurityContextArgs:
    def __init__(__self__, *,
                 fs_group: Optional[pulumi.Input[int]] = None,
                 fs_group_change_policy: Optional[pulumi.Input[str]] = None,
                 run_as_group: Optional[pulumi.Input[int]] = None,
                 run_as_non_root: Optional[pulumi.Input[bool]] = None,
                 run_as_user: Optional[pulumi.Input[int]] = None,
                 se_linux_options: Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptionsArgs']] = None,
                 supplemental_groups: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 sysctls: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodSecurityContextSysctlsArgs']]]] = None,
                 windows_options: Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptionsArgs']] = None):
        """
        Configures pod-level security attributes and common container settings.
        """
        if fs_group is not None:
            pulumi.set(__self__, "fs_group", fs_group)
        if fs_group_change_policy is not None:
            pulumi.set(__self__, "fs_group_change_policy", fs_group_change_policy)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if supplemental_groups is not None:
            pulumi.set(__self__, "supplemental_groups", supplemental_groups)
        if sysctls is not None:
            pulumi.set(__self__, "sysctls", sysctls)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="fsGroup")
    def fs_group(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "fs_group")

    @fs_group.setter
    def fs_group(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "fs_group", value)

    @property
    @pulumi.getter(name="fsGroupChangePolicy")
    def fs_group_change_policy(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "fs_group_change_policy")

    @fs_group_change_policy.setter
    def fs_group_change_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fs_group_change_policy", value)

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_group")

    @run_as_group.setter
    def run_as_group(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_group", value)

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "run_as_non_root")

    @run_as_non_root.setter
    def run_as_non_root(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_as_non_root", value)

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_user")

    @run_as_user.setter
    def run_as_user(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_user", value)

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptionsArgs']]:
        return pulumi.get(self, "se_linux_options")

    @se_linux_options.setter
    def se_linux_options(self, value: Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptionsArgs']]):
        pulumi.set(self, "se_linux_options", value)

    @property
    @pulumi.getter(name="supplementalGroups")
    def supplemental_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        return pulumi.get(self, "supplemental_groups")

    @supplemental_groups.setter
    def supplemental_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "supplemental_groups", value)

    @property
    @pulumi.getter
    def sysctls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodSecurityContextSysctlsArgs']]]]:
        return pulumi.get(self, "sysctls")

    @sysctls.setter
    def sysctls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecJmxTransTemplatePodSecurityContextSysctlsArgs']]]]):
        pulumi.set(self, "sysctls", value)

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptionsArgs']]:
        return pulumi.get(self, "windows_options")

    @windows_options.setter
    def windows_options(self, value: Optional[pulumi.Input['KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptionsArgs']]):
        pulumi.set(self, "windows_options", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptionsArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplatePodSecurityContextSysctlsArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptionsArgs:
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[pulumi.Input[str]] = None,
                 gmsa_credential_spec_name: Optional[pulumi.Input[str]] = None,
                 run_as_user_name: Optional[pulumi.Input[str]] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec")

    @gmsa_credential_spec.setter
    def gmsa_credential_spec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec", value)

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @gmsa_credential_spec_name.setter
    def gmsa_credential_spec_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec_name", value)

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "run_as_user_name")

    @run_as_user_name.setter
    def run_as_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "run_as_user_name", value)


@pulumi.input_type
class KafkaSpecJmxTransTemplatePodTolerationsArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 toleration_seconds: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if toleration_seconds is not None:
            pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "toleration_seconds")

    @toleration_seconds.setter
    def toleration_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "toleration_seconds", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaSpecKafkaArgs:
    def __init__(__self__, *,
                 listeners: pulumi.Input[Union[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf0Args']], 'KafkaSpecKafkaListenersOneOf1Args']],
                 replicas: pulumi.Input[int],
                 storage: pulumi.Input['KafkaSpecKafkaStorageArgs'],
                 affinity: Optional[pulumi.Input['KafkaSpecKafkaAffinityArgs']] = None,
                 authorization: Optional[pulumi.Input['KafkaSpecKafkaAuthorizationArgs']] = None,
                 broker_rack_init_image: Optional[pulumi.Input[str]] = None,
                 config: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 image: Optional[pulumi.Input[str]] = None,
                 jmx_options: Optional[pulumi.Input['KafkaSpecKafkaJmxOptionsArgs']] = None,
                 jvm_options: Optional[pulumi.Input['KafkaSpecKafkaJvmOptionsArgs']] = None,
                 liveness_probe: Optional[pulumi.Input['KafkaSpecKafkaLivenessProbeArgs']] = None,
                 logging: Optional[pulumi.Input['KafkaSpecKafkaLoggingArgs']] = None,
                 metrics: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 rack: Optional[pulumi.Input['KafkaSpecKafkaRackArgs']] = None,
                 readiness_probe: Optional[pulumi.Input['KafkaSpecKafkaReadinessProbeArgs']] = None,
                 resources: Optional[pulumi.Input['KafkaSpecKafkaResourcesArgs']] = None,
                 template: Optional[pulumi.Input['KafkaSpecKafkaTemplateArgs']] = None,
                 tls_sidecar: Optional[pulumi.Input['KafkaSpecKafkaTlsSidecarArgs']] = None,
                 tolerations: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTolerationsArgs']]]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        Configuration of the Kafka cluster.
        :param pulumi.Input[int] replicas: The number of pods in the cluster.
        :param pulumi.Input['KafkaSpecKafkaStorageArgs'] storage: Storage configuration (disk). Cannot be updated.
        :param pulumi.Input['KafkaSpecKafkaAffinityArgs'] affinity: The pod's affinity rules.
        :param pulumi.Input['KafkaSpecKafkaAuthorizationArgs'] authorization: Authorization configuration for Kafka brokers.
        :param pulumi.Input[str] broker_rack_init_image: The image of the init container used for initializing the `broker.rack`.
        :param pulumi.Input[Mapping[str, Any]] config: Kafka broker config properties with the following prefixes cannot be set: listeners, advertised., broker., listener., host.name, port, inter.broker.listener.name, sasl., ssl., security., password., principal.builder.class, log.dir, zookeeper.connect, zookeeper.set.acl, zookeeper.ssl, zookeeper.clientCnxnSocket, authorizer., super.user, cruise.control.metrics.topic, cruise.control.metrics.reporter.bootstrap.servers (with the exception of: zookeeper.connection.timeout.ms, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols,cruise.control.metrics.topic.num.partitions, cruise.control.metrics.topic.replication.factor, cruise.control.metrics.topic.retention.ms,cruise.control.metrics.topic.auto.create.retries, cruise.control.metrics.topic.auto.create.timeout.ms).
        :param pulumi.Input[str] image: The docker image for the pods. The default value depends on the configured `Kafka.spec.kafka.version`.
        :param pulumi.Input['KafkaSpecKafkaJmxOptionsArgs'] jmx_options: JMX Options for Kafka brokers.
        :param pulumi.Input['KafkaSpecKafkaJvmOptionsArgs'] jvm_options: JVM Options for pods.
        :param pulumi.Input['KafkaSpecKafkaLivenessProbeArgs'] liveness_probe: Pod liveness checking.
        :param pulumi.Input['KafkaSpecKafkaLoggingArgs'] logging: Logging configuration for Kafka.
        :param pulumi.Input[Mapping[str, Any]] metrics: The Prometheus JMX Exporter configuration. See https://github.com/prometheus/jmx_exporter for details of the structure of this configuration.
        :param pulumi.Input['KafkaSpecKafkaRackArgs'] rack: Configuration of the `broker.rack` broker config.
        :param pulumi.Input['KafkaSpecKafkaReadinessProbeArgs'] readiness_probe: Pod readiness checking.
        :param pulumi.Input['KafkaSpecKafkaResourcesArgs'] resources: CPU and memory resources to reserve.
        :param pulumi.Input['KafkaSpecKafkaTemplateArgs'] template: Template for Kafka cluster resources. The template allows users to specify how are the `StatefulSet`, `Pods` and `Services` generated.
        :param pulumi.Input['KafkaSpecKafkaTlsSidecarArgs'] tls_sidecar: TLS sidecar configuration.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTolerationsArgs']]] tolerations: The pod's tolerations.
        :param pulumi.Input[str] version: The kafka broker version. Defaults to {DefaultKafkaVersion}. Consult the user documentation to understand the process required to upgrade or downgrade the version.
        """
        pulumi.set(__self__, "listeners", listeners)
        pulumi.set(__self__, "replicas", replicas)
        pulumi.set(__self__, "storage", storage)
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if authorization is not None:
            pulumi.set(__self__, "authorization", authorization)
        if broker_rack_init_image is not None:
            pulumi.set(__self__, "broker_rack_init_image", broker_rack_init_image)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if jmx_options is not None:
            pulumi.set(__self__, "jmx_options", jmx_options)
        if jvm_options is not None:
            pulumi.set(__self__, "jvm_options", jvm_options)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if rack is not None:
            pulumi.set(__self__, "rack", rack)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if template is not None:
            pulumi.set(__self__, "template", template)
        if tls_sidecar is not None:
            pulumi.set(__self__, "tls_sidecar", tls_sidecar)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def listeners(self) -> pulumi.Input[Union[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf0Args']], 'KafkaSpecKafkaListenersOneOf1Args']]:
        return pulumi.get(self, "listeners")

    @listeners.setter
    def listeners(self, value: pulumi.Input[Union[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf0Args']], 'KafkaSpecKafkaListenersOneOf1Args']]):
        pulumi.set(self, "listeners", value)

    @property
    @pulumi.getter
    def replicas(self) -> pulumi.Input[int]:
        """
        The number of pods in the cluster.
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: pulumi.Input[int]):
        pulumi.set(self, "replicas", value)

    @property
    @pulumi.getter
    def storage(self) -> pulumi.Input['KafkaSpecKafkaStorageArgs']:
        """
        Storage configuration (disk). Cannot be updated.
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: pulumi.Input['KafkaSpecKafkaStorageArgs']):
        pulumi.set(self, "storage", value)

    @property
    @pulumi.getter
    def affinity(self) -> Optional[pulumi.Input['KafkaSpecKafkaAffinityArgs']]:
        """
        The pod's affinity rules.
        """
        return pulumi.get(self, "affinity")

    @affinity.setter
    def affinity(self, value: Optional[pulumi.Input['KafkaSpecKafkaAffinityArgs']]):
        pulumi.set(self, "affinity", value)

    @property
    @pulumi.getter
    def authorization(self) -> Optional[pulumi.Input['KafkaSpecKafkaAuthorizationArgs']]:
        """
        Authorization configuration for Kafka brokers.
        """
        return pulumi.get(self, "authorization")

    @authorization.setter
    def authorization(self, value: Optional[pulumi.Input['KafkaSpecKafkaAuthorizationArgs']]):
        pulumi.set(self, "authorization", value)

    @property
    @pulumi.getter(name="brokerRackInitImage")
    def broker_rack_init_image(self) -> Optional[pulumi.Input[str]]:
        """
        The image of the init container used for initializing the `broker.rack`.
        """
        return pulumi.get(self, "broker_rack_init_image")

    @broker_rack_init_image.setter
    def broker_rack_init_image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "broker_rack_init_image", value)

    @property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Kafka broker config properties with the following prefixes cannot be set: listeners, advertised., broker., listener., host.name, port, inter.broker.listener.name, sasl., ssl., security., password., principal.builder.class, log.dir, zookeeper.connect, zookeeper.set.acl, zookeeper.ssl, zookeeper.clientCnxnSocket, authorizer., super.user, cruise.control.metrics.topic, cruise.control.metrics.reporter.bootstrap.servers (with the exception of: zookeeper.connection.timeout.ms, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols,cruise.control.metrics.topic.num.partitions, cruise.control.metrics.topic.replication.factor, cruise.control.metrics.topic.retention.ms,cruise.control.metrics.topic.auto.create.retries, cruise.control.metrics.topic.auto.create.timeout.ms).
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "config", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        The docker image for the pods. The default value depends on the configured `Kafka.spec.kafka.version`.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="jmxOptions")
    def jmx_options(self) -> Optional[pulumi.Input['KafkaSpecKafkaJmxOptionsArgs']]:
        """
        JMX Options for Kafka brokers.
        """
        return pulumi.get(self, "jmx_options")

    @jmx_options.setter
    def jmx_options(self, value: Optional[pulumi.Input['KafkaSpecKafkaJmxOptionsArgs']]):
        pulumi.set(self, "jmx_options", value)

    @property
    @pulumi.getter(name="jvmOptions")
    def jvm_options(self) -> Optional[pulumi.Input['KafkaSpecKafkaJvmOptionsArgs']]:
        """
        JVM Options for pods.
        """
        return pulumi.get(self, "jvm_options")

    @jvm_options.setter
    def jvm_options(self, value: Optional[pulumi.Input['KafkaSpecKafkaJvmOptionsArgs']]):
        pulumi.set(self, "jvm_options", value)

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional[pulumi.Input['KafkaSpecKafkaLivenessProbeArgs']]:
        """
        Pod liveness checking.
        """
        return pulumi.get(self, "liveness_probe")

    @liveness_probe.setter
    def liveness_probe(self, value: Optional[pulumi.Input['KafkaSpecKafkaLivenessProbeArgs']]):
        pulumi.set(self, "liveness_probe", value)

    @property
    @pulumi.getter
    def logging(self) -> Optional[pulumi.Input['KafkaSpecKafkaLoggingArgs']]:
        """
        Logging configuration for Kafka.
        """
        return pulumi.get(self, "logging")

    @logging.setter
    def logging(self, value: Optional[pulumi.Input['KafkaSpecKafkaLoggingArgs']]):
        pulumi.set(self, "logging", value)

    @property
    @pulumi.getter
    def metrics(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        The Prometheus JMX Exporter configuration. See https://github.com/prometheus/jmx_exporter for details of the structure of this configuration.
        """
        return pulumi.get(self, "metrics")

    @metrics.setter
    def metrics(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "metrics", value)

    @property
    @pulumi.getter
    def rack(self) -> Optional[pulumi.Input['KafkaSpecKafkaRackArgs']]:
        """
        Configuration of the `broker.rack` broker config.
        """
        return pulumi.get(self, "rack")

    @rack.setter
    def rack(self, value: Optional[pulumi.Input['KafkaSpecKafkaRackArgs']]):
        pulumi.set(self, "rack", value)

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional[pulumi.Input['KafkaSpecKafkaReadinessProbeArgs']]:
        """
        Pod readiness checking.
        """
        return pulumi.get(self, "readiness_probe")

    @readiness_probe.setter
    def readiness_probe(self, value: Optional[pulumi.Input['KafkaSpecKafkaReadinessProbeArgs']]):
        pulumi.set(self, "readiness_probe", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['KafkaSpecKafkaResourcesArgs']]:
        """
        CPU and memory resources to reserve.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['KafkaSpecKafkaResourcesArgs']]):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter
    def template(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplateArgs']]:
        """
        Template for Kafka cluster resources. The template allows users to specify how are the `StatefulSet`, `Pods` and `Services` generated.
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplateArgs']]):
        pulumi.set(self, "template", value)

    @property
    @pulumi.getter(name="tlsSidecar")
    def tls_sidecar(self) -> Optional[pulumi.Input['KafkaSpecKafkaTlsSidecarArgs']]:
        """
        TLS sidecar configuration.
        """
        return pulumi.get(self, "tls_sidecar")

    @tls_sidecar.setter
    def tls_sidecar(self, value: Optional[pulumi.Input['KafkaSpecKafkaTlsSidecarArgs']]):
        pulumi.set(self, "tls_sidecar", value)

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTolerationsArgs']]]]:
        """
        The pod's tolerations.
        """
        return pulumi.get(self, "tolerations")

    @tolerations.setter
    def tolerations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTolerationsArgs']]]]):
        pulumi.set(self, "tolerations", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        The kafka broker version. Defaults to {DefaultKafkaVersion}. Consult the user documentation to understand the process required to upgrade or downgrade the version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class KafkaSpecKafkaAffinityArgs:
    def __init__(__self__, *,
                 node_affinity: Optional[pulumi.Input['KafkaSpecKafkaAffinityNodeAffinityArgs']] = None,
                 pod_affinity: Optional[pulumi.Input['KafkaSpecKafkaAffinityPodAffinityArgs']] = None,
                 pod_anti_affinity: Optional[pulumi.Input['KafkaSpecKafkaAffinityPodAntiAffinityArgs']] = None):
        """
        The pod's affinity rules.
        """
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional[pulumi.Input['KafkaSpecKafkaAffinityNodeAffinityArgs']]:
        return pulumi.get(self, "node_affinity")

    @node_affinity.setter
    def node_affinity(self, value: Optional[pulumi.Input['KafkaSpecKafkaAffinityNodeAffinityArgs']]):
        pulumi.set(self, "node_affinity", value)

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional[pulumi.Input['KafkaSpecKafkaAffinityPodAffinityArgs']]:
        return pulumi.get(self, "pod_affinity")

    @pod_affinity.setter
    def pod_affinity(self, value: Optional[pulumi.Input['KafkaSpecKafkaAffinityPodAffinityArgs']]):
        pulumi.set(self, "pod_affinity", value)

    @property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional[pulumi.Input['KafkaSpecKafkaAffinityPodAntiAffinityArgs']]:
        return pulumi.get(self, "pod_anti_affinity")

    @pod_anti_affinity.setter
    def pod_anti_affinity(self, value: Optional[pulumi.Input['KafkaSpecKafkaAffinityPodAntiAffinityArgs']]):
        pulumi.set(self, "pod_anti_affinity", value)


@pulumi.input_type
class KafkaSpecKafkaAffinityNodeAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input['KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input['KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input['KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 preference: Optional[pulumi.Input['KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input['KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']]:
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input['KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]] = None,
                 match_fields: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]]:
        return pulumi.get(self, "match_fields")

    @match_fields.setter
    def match_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]]):
        pulumi.set(self, "match_fields", value)


@pulumi.input_type
class KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 node_selector_terms: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]] = None):
        if node_selector_terms is not None:
            pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]]:
        return pulumi.get(self, "node_selector_terms")

    @node_selector_terms.setter
    def node_selector_terms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]]):
        pulumi.set(self, "node_selector_terms", value)


@pulumi.input_type
class KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]] = None,
                 match_fields: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]]:
        return pulumi.get(self, "match_fields")

    @match_fields.setter
    def match_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]]):
        pulumi.set(self, "match_fields", value)


@pulumi.input_type
class KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecKafkaAffinityPodAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 pod_affinity_term: Optional[pulumi.Input['KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional[pulumi.Input['KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]:
        return pulumi.get(self, "pod_affinity_term")

    @pod_affinity_term.setter
    def pod_affinity_term(self, value: Optional[pulumi.Input['KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]):
        pulumi.set(self, "pod_affinity_term", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecKafkaAffinityPodAntiAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 pod_affinity_term: Optional[pulumi.Input['KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional[pulumi.Input['KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]:
        return pulumi.get(self, "pod_affinity_term")

    @pod_affinity_term.setter
    def pod_affinity_term(self, value: Optional[pulumi.Input['KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]):
        pulumi.set(self, "pod_affinity_term", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecKafkaAuthorizationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 allow_on_error: Optional[pulumi.Input[bool]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 delegate_to_kafka_acls: Optional[pulumi.Input[bool]] = None,
                 disable_tls_hostname_verification: Optional[pulumi.Input[bool]] = None,
                 expire_after_ms: Optional[pulumi.Input[int]] = None,
                 grants_refresh_period_seconds: Optional[pulumi.Input[int]] = None,
                 grants_refresh_pool_size: Optional[pulumi.Input[int]] = None,
                 initial_cache_capacity: Optional[pulumi.Input[int]] = None,
                 maximum_cache_size: Optional[pulumi.Input[int]] = None,
                 super_users: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 tls_trusted_certificates: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAuthorizationTlsTrustedCertificatesArgs']]]] = None,
                 token_endpoint_uri: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        Authorization configuration for Kafka brokers.
        :param pulumi.Input[str] type: Authorization type. Currently, the supported types are `simple`, `keycloak`, and `opa`. `simple` authorization type uses Kafka's `kafka.security.authorizer.AclAuthorizer` class for authorization. `keycloak` authorization type uses Keycloak Authorization Services for authorization. `opa` authorization type uses Open Policy Agent based authorization.
        :param pulumi.Input[bool] allow_on_error: Defines whether a Kafka client should be allowed or denied by default when the authorizer fails to query the Open Policy Agent, for example, when it is temporarily unavailable). Defaults to `false` - all actions will be denied.
        :param pulumi.Input[str] client_id: OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        :param pulumi.Input[bool] delegate_to_kafka_acls: Whether authorization decision should be delegated to the 'Simple' authorizer if DENIED by Keycloak Authorization Services policies. Default value is `false`.
        :param pulumi.Input[bool] disable_tls_hostname_verification: Enable or disable TLS hostname verification. Default value is `false`.
        :param pulumi.Input[int] expire_after_ms: The expiration of the records kept in the local cache to avoid querying the Open Policy Agent for every request. Defines how often the cached authorization decisions are reloaded from the Open Policy Agent server. In milliseconds. Defaults to `3600000`.
        :param pulumi.Input[int] grants_refresh_period_seconds: The time between two consecutive grants refresh runs in seconds. The default value is 60.
        :param pulumi.Input[int] grants_refresh_pool_size: The number of threads to use to refresh grants for active sessions. The more threads, the more parallelism, so the sooner the job completes. However, using more threads places a heavier load on the authorization server. The default value is 5.
        :param pulumi.Input[int] initial_cache_capacity: Initial capacity of the local cache used by the authorizer to avoid querying the Open Policy Agent for every request Defaults to `5000`.
        :param pulumi.Input[int] maximum_cache_size: Maximum capacity of the local cache used by the authorizer to avoid querying the Open Policy Agent for every request. Defaults to `50000`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] super_users: List of super users. Should contain list of user principals which should get unlimited access rights.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAuthorizationTlsTrustedCertificatesArgs']]] tls_trusted_certificates: Trusted certificates for TLS connection to the OAuth server.
        :param pulumi.Input[str] token_endpoint_uri: Authorization server token endpoint URI.
        :param pulumi.Input[str] url: The URL used to connect to the Open Policy Agent server. The URL has to include the policy which will be queried by the authorizer. This option is required.
        """
        pulumi.set(__self__, "type", type)
        if allow_on_error is not None:
            pulumi.set(__self__, "allow_on_error", allow_on_error)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if delegate_to_kafka_acls is not None:
            pulumi.set(__self__, "delegate_to_kafka_acls", delegate_to_kafka_acls)
        if disable_tls_hostname_verification is not None:
            pulumi.set(__self__, "disable_tls_hostname_verification", disable_tls_hostname_verification)
        if expire_after_ms is not None:
            pulumi.set(__self__, "expire_after_ms", expire_after_ms)
        if grants_refresh_period_seconds is not None:
            pulumi.set(__self__, "grants_refresh_period_seconds", grants_refresh_period_seconds)
        if grants_refresh_pool_size is not None:
            pulumi.set(__self__, "grants_refresh_pool_size", grants_refresh_pool_size)
        if initial_cache_capacity is not None:
            pulumi.set(__self__, "initial_cache_capacity", initial_cache_capacity)
        if maximum_cache_size is not None:
            pulumi.set(__self__, "maximum_cache_size", maximum_cache_size)
        if super_users is not None:
            pulumi.set(__self__, "super_users", super_users)
        if tls_trusted_certificates is not None:
            pulumi.set(__self__, "tls_trusted_certificates", tls_trusted_certificates)
        if token_endpoint_uri is not None:
            pulumi.set(__self__, "token_endpoint_uri", token_endpoint_uri)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Authorization type. Currently, the supported types are `simple`, `keycloak`, and `opa`. `simple` authorization type uses Kafka's `kafka.security.authorizer.AclAuthorizer` class for authorization. `keycloak` authorization type uses Keycloak Authorization Services for authorization. `opa` authorization type uses Open Policy Agent based authorization.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="allowOnError")
    def allow_on_error(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines whether a Kafka client should be allowed or denied by default when the authorizer fails to query the Open Policy Agent, for example, when it is temporarily unavailable). Defaults to `false` - all actions will be denied.
        """
        return pulumi.get(self, "allow_on_error")

    @allow_on_error.setter
    def allow_on_error(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_on_error", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="delegateToKafkaAcls")
    def delegate_to_kafka_acls(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether authorization decision should be delegated to the 'Simple' authorizer if DENIED by Keycloak Authorization Services policies. Default value is `false`.
        """
        return pulumi.get(self, "delegate_to_kafka_acls")

    @delegate_to_kafka_acls.setter
    def delegate_to_kafka_acls(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delegate_to_kafka_acls", value)

    @property
    @pulumi.getter(name="disableTlsHostnameVerification")
    def disable_tls_hostname_verification(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable or disable TLS hostname verification. Default value is `false`.
        """
        return pulumi.get(self, "disable_tls_hostname_verification")

    @disable_tls_hostname_verification.setter
    def disable_tls_hostname_verification(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_tls_hostname_verification", value)

    @property
    @pulumi.getter(name="expireAfterMs")
    def expire_after_ms(self) -> Optional[pulumi.Input[int]]:
        """
        The expiration of the records kept in the local cache to avoid querying the Open Policy Agent for every request. Defines how often the cached authorization decisions are reloaded from the Open Policy Agent server. In milliseconds. Defaults to `3600000`.
        """
        return pulumi.get(self, "expire_after_ms")

    @expire_after_ms.setter
    def expire_after_ms(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "expire_after_ms", value)

    @property
    @pulumi.getter(name="grantsRefreshPeriodSeconds")
    def grants_refresh_period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The time between two consecutive grants refresh runs in seconds. The default value is 60.
        """
        return pulumi.get(self, "grants_refresh_period_seconds")

    @grants_refresh_period_seconds.setter
    def grants_refresh_period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "grants_refresh_period_seconds", value)

    @property
    @pulumi.getter(name="grantsRefreshPoolSize")
    def grants_refresh_pool_size(self) -> Optional[pulumi.Input[int]]:
        """
        The number of threads to use to refresh grants for active sessions. The more threads, the more parallelism, so the sooner the job completes. However, using more threads places a heavier load on the authorization server. The default value is 5.
        """
        return pulumi.get(self, "grants_refresh_pool_size")

    @grants_refresh_pool_size.setter
    def grants_refresh_pool_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "grants_refresh_pool_size", value)

    @property
    @pulumi.getter(name="initialCacheCapacity")
    def initial_cache_capacity(self) -> Optional[pulumi.Input[int]]:
        """
        Initial capacity of the local cache used by the authorizer to avoid querying the Open Policy Agent for every request Defaults to `5000`.
        """
        return pulumi.get(self, "initial_cache_capacity")

    @initial_cache_capacity.setter
    def initial_cache_capacity(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_cache_capacity", value)

    @property
    @pulumi.getter(name="maximumCacheSize")
    def maximum_cache_size(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum capacity of the local cache used by the authorizer to avoid querying the Open Policy Agent for every request. Defaults to `50000`.
        """
        return pulumi.get(self, "maximum_cache_size")

    @maximum_cache_size.setter
    def maximum_cache_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "maximum_cache_size", value)

    @property
    @pulumi.getter(name="superUsers")
    def super_users(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of super users. Should contain list of user principals which should get unlimited access rights.
        """
        return pulumi.get(self, "super_users")

    @super_users.setter
    def super_users(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "super_users", value)

    @property
    @pulumi.getter(name="tlsTrustedCertificates")
    def tls_trusted_certificates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAuthorizationTlsTrustedCertificatesArgs']]]]:
        """
        Trusted certificates for TLS connection to the OAuth server.
        """
        return pulumi.get(self, "tls_trusted_certificates")

    @tls_trusted_certificates.setter
    def tls_trusted_certificates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaAuthorizationTlsTrustedCertificatesArgs']]]]):
        pulumi.set(self, "tls_trusted_certificates", value)

    @property
    @pulumi.getter(name="tokenEndpointUri")
    def token_endpoint_uri(self) -> Optional[pulumi.Input[str]]:
        """
        Authorization server token endpoint URI.
        """
        return pulumi.get(self, "token_endpoint_uri")

    @token_endpoint_uri.setter
    def token_endpoint_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_endpoint_uri", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL used to connect to the Open Policy Agent server. The URL has to include the policy which will be queried by the authorizer. This option is required.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class KafkaSpecKafkaAuthorizationTlsTrustedCertificatesArgs:
    def __init__(__self__, *,
                 certificate: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] certificate: The name of the file certificate in the Secret.
        :param pulumi.Input[str] secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> pulumi.Input[str]:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KafkaSpecKafkaExporterArgs:
    def __init__(__self__, *,
                 enable_sarama_logging: Optional[pulumi.Input[bool]] = None,
                 group_regex: Optional[pulumi.Input[str]] = None,
                 image: Optional[pulumi.Input[str]] = None,
                 liveness_probe: Optional[pulumi.Input['KafkaSpecKafkaExporterLivenessProbeArgs']] = None,
                 logging: Optional[pulumi.Input[str]] = None,
                 readiness_probe: Optional[pulumi.Input['KafkaSpecKafkaExporterReadinessProbeArgs']] = None,
                 resources: Optional[pulumi.Input['KafkaSpecKafkaExporterResourcesArgs']] = None,
                 template: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplateArgs']] = None,
                 topic_regex: Optional[pulumi.Input[str]] = None):
        """
        Configuration of the Kafka Exporter. Kafka Exporter can provide additional metrics, for example lag of consumer group at topic/partition.
        :param pulumi.Input[bool] enable_sarama_logging: Enable Sarama logging, a Go client library used by the Kafka Exporter.
        :param pulumi.Input[str] group_regex: Regular expression to specify which consumer groups to collect. Default value is `.*`.
        :param pulumi.Input[str] image: The docker image for the pods.
        :param pulumi.Input['KafkaSpecKafkaExporterLivenessProbeArgs'] liveness_probe: Pod liveness check.
        :param pulumi.Input[str] logging: Only log messages with the given severity or above. Valid levels: [`debug`, `info`, `warn`, `error`, `fatal`]. Default log level is `info`.
        :param pulumi.Input['KafkaSpecKafkaExporterReadinessProbeArgs'] readiness_probe: Pod readiness check.
        :param pulumi.Input['KafkaSpecKafkaExporterResourcesArgs'] resources: CPU and memory resources to reserve.
        :param pulumi.Input['KafkaSpecKafkaExporterTemplateArgs'] template: Customization of deployment templates and pods.
        :param pulumi.Input[str] topic_regex: Regular expression to specify which topics to collect. Default value is `.*`.
        """
        if enable_sarama_logging is not None:
            pulumi.set(__self__, "enable_sarama_logging", enable_sarama_logging)
        if group_regex is not None:
            pulumi.set(__self__, "group_regex", group_regex)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if template is not None:
            pulumi.set(__self__, "template", template)
        if topic_regex is not None:
            pulumi.set(__self__, "topic_regex", topic_regex)

    @property
    @pulumi.getter(name="enableSaramaLogging")
    def enable_sarama_logging(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable Sarama logging, a Go client library used by the Kafka Exporter.
        """
        return pulumi.get(self, "enable_sarama_logging")

    @enable_sarama_logging.setter
    def enable_sarama_logging(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_sarama_logging", value)

    @property
    @pulumi.getter(name="groupRegex")
    def group_regex(self) -> Optional[pulumi.Input[str]]:
        """
        Regular expression to specify which consumer groups to collect. Default value is `.*`.
        """
        return pulumi.get(self, "group_regex")

    @group_regex.setter
    def group_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_regex", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        The docker image for the pods.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional[pulumi.Input['KafkaSpecKafkaExporterLivenessProbeArgs']]:
        """
        Pod liveness check.
        """
        return pulumi.get(self, "liveness_probe")

    @liveness_probe.setter
    def liveness_probe(self, value: Optional[pulumi.Input['KafkaSpecKafkaExporterLivenessProbeArgs']]):
        pulumi.set(self, "liveness_probe", value)

    @property
    @pulumi.getter
    def logging(self) -> Optional[pulumi.Input[str]]:
        """
        Only log messages with the given severity or above. Valid levels: [`debug`, `info`, `warn`, `error`, `fatal`]. Default log level is `info`.
        """
        return pulumi.get(self, "logging")

    @logging.setter
    def logging(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logging", value)

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional[pulumi.Input['KafkaSpecKafkaExporterReadinessProbeArgs']]:
        """
        Pod readiness check.
        """
        return pulumi.get(self, "readiness_probe")

    @readiness_probe.setter
    def readiness_probe(self, value: Optional[pulumi.Input['KafkaSpecKafkaExporterReadinessProbeArgs']]):
        pulumi.set(self, "readiness_probe", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['KafkaSpecKafkaExporterResourcesArgs']]:
        """
        CPU and memory resources to reserve.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['KafkaSpecKafkaExporterResourcesArgs']]):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter
    def template(self) -> Optional[pulumi.Input['KafkaSpecKafkaExporterTemplateArgs']]:
        """
        Customization of deployment templates and pods.
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplateArgs']]):
        pulumi.set(self, "template", value)

    @property
    @pulumi.getter(name="topicRegex")
    def topic_regex(self) -> Optional[pulumi.Input[str]]:
        """
        Regular expression to specify which topics to collect. Default value is `.*`.
        """
        return pulumi.get(self, "topic_regex")

    @topic_regex.setter
    def topic_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topic_regex", value)


@pulumi.input_type
class KafkaSpecKafkaExporterLivenessProbeArgs:
    def __init__(__self__, *,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 success_threshold: Optional[pulumi.Input[int]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        Pod liveness check.
        :param pulumi.Input[int] failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param pulumi.Input[int] initial_delay_seconds: The initial delay before first the health is first checked.
        :param pulumi.Input[int] period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param pulumi.Input[int] success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param pulumi.Input[int] timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "success_threshold", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


@pulumi.input_type
class KafkaSpecKafkaExporterReadinessProbeArgs:
    def __init__(__self__, *,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 success_threshold: Optional[pulumi.Input[int]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        Pod readiness check.
        :param pulumi.Input[int] failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param pulumi.Input[int] initial_delay_seconds: The initial delay before first the health is first checked.
        :param pulumi.Input[int] period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param pulumi.Input[int] success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param pulumi.Input[int] timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "success_threshold", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


@pulumi.input_type
class KafkaSpecKafkaExporterResourcesArgs:
    def __init__(__self__, *,
                 limits: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 requests: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        CPU and memory resources to reserve.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "limits", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "requests", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplateArgs:
    def __init__(__self__, *,
                 container: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplateContainerArgs']] = None,
                 deployment: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplateDeploymentArgs']] = None,
                 pod: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodArgs']] = None,
                 service: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplateServiceArgs']] = None):
        """
        Customization of deployment templates and pods.
        :param pulumi.Input['KafkaSpecKafkaExporterTemplateContainerArgs'] container: Template for the Kafka Exporter container.
        :param pulumi.Input['KafkaSpecKafkaExporterTemplateDeploymentArgs'] deployment: Template for Kafka Exporter `Deployment`.
        :param pulumi.Input['KafkaSpecKafkaExporterTemplatePodArgs'] pod: Template for Kafka Exporter `Pods`.
        :param pulumi.Input['KafkaSpecKafkaExporterTemplateServiceArgs'] service: Template for Kafka Exporter `Service`.
        """
        if container is not None:
            pulumi.set(__self__, "container", container)
        if deployment is not None:
            pulumi.set(__self__, "deployment", deployment)
        if pod is not None:
            pulumi.set(__self__, "pod", pod)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def container(self) -> Optional[pulumi.Input['KafkaSpecKafkaExporterTemplateContainerArgs']]:
        """
        Template for the Kafka Exporter container.
        """
        return pulumi.get(self, "container")

    @container.setter
    def container(self, value: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplateContainerArgs']]):
        pulumi.set(self, "container", value)

    @property
    @pulumi.getter
    def deployment(self) -> Optional[pulumi.Input['KafkaSpecKafkaExporterTemplateDeploymentArgs']]:
        """
        Template for Kafka Exporter `Deployment`.
        """
        return pulumi.get(self, "deployment")

    @deployment.setter
    def deployment(self, value: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplateDeploymentArgs']]):
        pulumi.set(self, "deployment", value)

    @property
    @pulumi.getter
    def pod(self) -> Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodArgs']]:
        """
        Template for Kafka Exporter `Pods`.
        """
        return pulumi.get(self, "pod")

    @pod.setter
    def pod(self, value: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodArgs']]):
        pulumi.set(self, "pod", value)

    @property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input['KafkaSpecKafkaExporterTemplateServiceArgs']]:
        """
        Template for Kafka Exporter `Service`.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplateServiceArgs']]):
        pulumi.set(self, "service", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplateContainerArgs:
    def __init__(__self__, *,
                 env: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplateContainerEnvArgs']]]] = None,
                 security_context: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplateContainerSecurityContextArgs']] = None):
        """
        Template for the Kafka Exporter container.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplateContainerEnvArgs']]] env: Environment variables which should be applied to the container.
        :param pulumi.Input['KafkaSpecKafkaExporterTemplateContainerSecurityContextArgs'] security_context: Security context for the container.
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)

    @property
    @pulumi.getter
    def env(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplateContainerEnvArgs']]]]:
        """
        Environment variables which should be applied to the container.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplateContainerEnvArgs']]]]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional[pulumi.Input['KafkaSpecKafkaExporterTemplateContainerSecurityContextArgs']]:
        """
        Security context for the container.
        """
        return pulumi.get(self, "security_context")

    @security_context.setter
    def security_context(self, value: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplateContainerSecurityContextArgs']]):
        pulumi.set(self, "security_context", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplateContainerEnvArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The environment variable key.
        :param pulumi.Input[str] value: The environment variable value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The environment variable key.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The environment variable value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplateContainerSecurityContextArgs:
    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[pulumi.Input[bool]] = None,
                 capabilities: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplateContainerSecurityContextCapabilitiesArgs']] = None,
                 privileged: Optional[pulumi.Input[bool]] = None,
                 proc_mount: Optional[pulumi.Input[str]] = None,
                 read_only_root_filesystem: Optional[pulumi.Input[bool]] = None,
                 run_as_group: Optional[pulumi.Input[int]] = None,
                 run_as_non_root: Optional[pulumi.Input[bool]] = None,
                 run_as_user: Optional[pulumi.Input[int]] = None,
                 se_linux_options: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptionsArgs']] = None,
                 windows_options: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptionsArgs']] = None):
        """
        Security context for the container.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if proc_mount is not None:
            pulumi.set(__self__, "proc_mount", proc_mount)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "allow_privilege_escalation")

    @allow_privilege_escalation.setter
    def allow_privilege_escalation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_privilege_escalation", value)

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[pulumi.Input['KafkaSpecKafkaExporterTemplateContainerSecurityContextCapabilitiesArgs']]:
        return pulumi.get(self, "capabilities")

    @capabilities.setter
    def capabilities(self, value: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplateContainerSecurityContextCapabilitiesArgs']]):
        pulumi.set(self, "capabilities", value)

    @property
    @pulumi.getter
    def privileged(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "privileged")

    @privileged.setter
    def privileged(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "privileged", value)

    @property
    @pulumi.getter(name="procMount")
    def proc_mount(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "proc_mount")

    @proc_mount.setter
    def proc_mount(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proc_mount", value)

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "read_only_root_filesystem")

    @read_only_root_filesystem.setter
    def read_only_root_filesystem(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "read_only_root_filesystem", value)

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_group")

    @run_as_group.setter
    def run_as_group(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_group", value)

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "run_as_non_root")

    @run_as_non_root.setter
    def run_as_non_root(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_as_non_root", value)

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_user")

    @run_as_user.setter
    def run_as_user(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_user", value)

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional[pulumi.Input['KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptionsArgs']]:
        return pulumi.get(self, "se_linux_options")

    @se_linux_options.setter
    def se_linux_options(self, value: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptionsArgs']]):
        pulumi.set(self, "se_linux_options", value)

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional[pulumi.Input['KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptionsArgs']]:
        return pulumi.get(self, "windows_options")

    @windows_options.setter
    def windows_options(self, value: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptionsArgs']]):
        pulumi.set(self, "windows_options", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplateContainerSecurityContextCapabilitiesArgs:
    def __init__(__self__, *,
                 add: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 drop: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)

    @property
    @pulumi.getter
    def add(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "add")

    @add.setter
    def add(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "add", value)

    @property
    @pulumi.getter
    def drop(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "drop")

    @drop.setter
    def drop(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "drop", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptionsArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptionsArgs:
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[pulumi.Input[str]] = None,
                 gmsa_credential_spec_name: Optional[pulumi.Input[str]] = None,
                 run_as_user_name: Optional[pulumi.Input[str]] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec")

    @gmsa_credential_spec.setter
    def gmsa_credential_spec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec", value)

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @gmsa_credential_spec_name.setter
    def gmsa_credential_spec_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec_name", value)

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "run_as_user_name")

    @run_as_user_name.setter
    def run_as_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "run_as_user_name", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplateDeploymentArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplateDeploymentMetadataArgs']] = None):
        """
        Template for Kafka Exporter `Deployment`.
        :param pulumi.Input['KafkaSpecKafkaExporterTemplateDeploymentMetadataArgs'] metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['KafkaSpecKafkaExporterTemplateDeploymentMetadataArgs']]:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplateDeploymentMetadataArgs']]):
        pulumi.set(self, "metadata", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplateDeploymentMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Metadata applied to the resource.
        :param pulumi.Input[Mapping[str, Any]] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param pulumi.Input[Mapping[str, Any]] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplatePodArgs:
    def __init__(__self__, *,
                 affinity: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityArgs']] = None,
                 host_aliases: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodHostAliasesArgs']]]] = None,
                 image_pull_secrets: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodImagePullSecretsArgs']]]] = None,
                 metadata: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodMetadataArgs']] = None,
                 priority_class_name: Optional[pulumi.Input[str]] = None,
                 scheduler_name: Optional[pulumi.Input[str]] = None,
                 security_context: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodSecurityContextArgs']] = None,
                 termination_grace_period_seconds: Optional[pulumi.Input[int]] = None,
                 tolerations: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodTolerationsArgs']]]] = None):
        """
        Template for Kafka Exporter `Pods`.
        :param pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityArgs'] affinity: The pod's affinity rules.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodHostAliasesArgs']]] host_aliases: The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodImagePullSecretsArgs']]] image_pull_secrets: List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
        :param pulumi.Input['KafkaSpecKafkaExporterTemplatePodMetadataArgs'] metadata: Metadata applied to the resource.
        :param pulumi.Input[str] priority_class_name: The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
        :param pulumi.Input[str] scheduler_name: The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
        :param pulumi.Input['KafkaSpecKafkaExporterTemplatePodSecurityContextArgs'] security_context: Configures pod-level security attributes and common container settings.
        :param pulumi.Input[int] termination_grace_period_seconds: The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodTolerationsArgs']]] tolerations: The pod's tolerations.
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if host_aliases is not None:
            pulumi.set(__self__, "host_aliases", host_aliases)
        if image_pull_secrets is not None:
            pulumi.set(__self__, "image_pull_secrets", image_pull_secrets)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if priority_class_name is not None:
            pulumi.set(__self__, "priority_class_name", priority_class_name)
        if scheduler_name is not None:
            pulumi.set(__self__, "scheduler_name", scheduler_name)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)

    @property
    @pulumi.getter
    def affinity(self) -> Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityArgs']]:
        """
        The pod's affinity rules.
        """
        return pulumi.get(self, "affinity")

    @affinity.setter
    def affinity(self, value: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityArgs']]):
        pulumi.set(self, "affinity", value)

    @property
    @pulumi.getter(name="hostAliases")
    def host_aliases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodHostAliasesArgs']]]]:
        """
        The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
        """
        return pulumi.get(self, "host_aliases")

    @host_aliases.setter
    def host_aliases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodHostAliasesArgs']]]]):
        pulumi.set(self, "host_aliases", value)

    @property
    @pulumi.getter(name="imagePullSecrets")
    def image_pull_secrets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodImagePullSecretsArgs']]]]:
        """
        List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
        """
        return pulumi.get(self, "image_pull_secrets")

    @image_pull_secrets.setter
    def image_pull_secrets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodImagePullSecretsArgs']]]]):
        pulumi.set(self, "image_pull_secrets", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodMetadataArgs']]:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodMetadataArgs']]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter(name="priorityClassName")
    def priority_class_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
        """
        return pulumi.get(self, "priority_class_name")

    @priority_class_name.setter
    def priority_class_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "priority_class_name", value)

    @property
    @pulumi.getter(name="schedulerName")
    def scheduler_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
        """
        return pulumi.get(self, "scheduler_name")

    @scheduler_name.setter
    def scheduler_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scheduler_name", value)

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodSecurityContextArgs']]:
        """
        Configures pod-level security attributes and common container settings.
        """
        return pulumi.get(self, "security_context")

    @security_context.setter
    def security_context(self, value: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodSecurityContextArgs']]):
        pulumi.set(self, "security_context", value)

    @property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
        """
        return pulumi.get(self, "termination_grace_period_seconds")

    @termination_grace_period_seconds.setter
    def termination_grace_period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "termination_grace_period_seconds", value)

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodTolerationsArgs']]]]:
        """
        The pod's tolerations.
        """
        return pulumi.get(self, "tolerations")

    @tolerations.setter
    def tolerations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodTolerationsArgs']]]]):
        pulumi.set(self, "tolerations", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplatePodAffinityArgs:
    def __init__(__self__, *,
                 node_affinity: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityArgs']] = None,
                 pod_affinity: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityArgs']] = None,
                 pod_anti_affinity: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityArgs']] = None):
        """
        The pod's affinity rules.
        """
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityArgs']]:
        return pulumi.get(self, "node_affinity")

    @node_affinity.setter
    def node_affinity(self, value: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityArgs']]):
        pulumi.set(self, "node_affinity", value)

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityArgs']]:
        return pulumi.get(self, "pod_affinity")

    @pod_affinity.setter
    def pod_affinity(self, value: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityArgs']]):
        pulumi.set(self, "pod_affinity", value)

    @property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityArgs']]:
        return pulumi.get(self, "pod_anti_affinity")

    @pod_anti_affinity.setter
    def pod_anti_affinity(self, value: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityArgs']]):
        pulumi.set(self, "pod_anti_affinity", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 preference: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']]:
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]] = None,
                 match_fields: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]]:
        return pulumi.get(self, "match_fields")

    @match_fields.setter
    def match_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]]):
        pulumi.set(self, "match_fields", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 node_selector_terms: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]] = None):
        if node_selector_terms is not None:
            pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]]:
        return pulumi.get(self, "node_selector_terms")

    @node_selector_terms.setter
    def node_selector_terms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]]):
        pulumi.set(self, "node_selector_terms", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]] = None,
                 match_fields: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]]:
        return pulumi.get(self, "match_fields")

    @match_fields.setter
    def match_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]]):
        pulumi.set(self, "match_fields", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 pod_affinity_term: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]:
        return pulumi.get(self, "pod_affinity_term")

    @pod_affinity_term.setter
    def pod_affinity_term(self, value: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]):
        pulumi.set(self, "pod_affinity_term", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 pod_affinity_term: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]:
        return pulumi.get(self, "pod_affinity_term")

    @pod_affinity_term.setter
    def pod_affinity_term(self, value: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]):
        pulumi.set(self, "pod_affinity_term", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplatePodHostAliasesArgs:
    def __init__(__self__, *,
                 hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ip: Optional[pulumi.Input[str]] = None):
        if hostnames is not None:
            pulumi.set(__self__, "hostnames", hostnames)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def hostnames(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "hostnames")

    @hostnames.setter
    def hostnames(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hostnames", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplatePodImagePullSecretsArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplatePodMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Metadata applied to the resource.
        :param pulumi.Input[Mapping[str, Any]] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param pulumi.Input[Mapping[str, Any]] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplatePodSecurityContextArgs:
    def __init__(__self__, *,
                 fs_group: Optional[pulumi.Input[int]] = None,
                 fs_group_change_policy: Optional[pulumi.Input[str]] = None,
                 run_as_group: Optional[pulumi.Input[int]] = None,
                 run_as_non_root: Optional[pulumi.Input[bool]] = None,
                 run_as_user: Optional[pulumi.Input[int]] = None,
                 se_linux_options: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptionsArgs']] = None,
                 supplemental_groups: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 sysctls: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodSecurityContextSysctlsArgs']]]] = None,
                 windows_options: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptionsArgs']] = None):
        """
        Configures pod-level security attributes and common container settings.
        """
        if fs_group is not None:
            pulumi.set(__self__, "fs_group", fs_group)
        if fs_group_change_policy is not None:
            pulumi.set(__self__, "fs_group_change_policy", fs_group_change_policy)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if supplemental_groups is not None:
            pulumi.set(__self__, "supplemental_groups", supplemental_groups)
        if sysctls is not None:
            pulumi.set(__self__, "sysctls", sysctls)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="fsGroup")
    def fs_group(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "fs_group")

    @fs_group.setter
    def fs_group(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "fs_group", value)

    @property
    @pulumi.getter(name="fsGroupChangePolicy")
    def fs_group_change_policy(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "fs_group_change_policy")

    @fs_group_change_policy.setter
    def fs_group_change_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fs_group_change_policy", value)

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_group")

    @run_as_group.setter
    def run_as_group(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_group", value)

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "run_as_non_root")

    @run_as_non_root.setter
    def run_as_non_root(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_as_non_root", value)

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_user")

    @run_as_user.setter
    def run_as_user(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_user", value)

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptionsArgs']]:
        return pulumi.get(self, "se_linux_options")

    @se_linux_options.setter
    def se_linux_options(self, value: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptionsArgs']]):
        pulumi.set(self, "se_linux_options", value)

    @property
    @pulumi.getter(name="supplementalGroups")
    def supplemental_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        return pulumi.get(self, "supplemental_groups")

    @supplemental_groups.setter
    def supplemental_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "supplemental_groups", value)

    @property
    @pulumi.getter
    def sysctls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodSecurityContextSysctlsArgs']]]]:
        return pulumi.get(self, "sysctls")

    @sysctls.setter
    def sysctls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaExporterTemplatePodSecurityContextSysctlsArgs']]]]):
        pulumi.set(self, "sysctls", value)

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptionsArgs']]:
        return pulumi.get(self, "windows_options")

    @windows_options.setter
    def windows_options(self, value: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptionsArgs']]):
        pulumi.set(self, "windows_options", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptionsArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplatePodSecurityContextSysctlsArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptionsArgs:
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[pulumi.Input[str]] = None,
                 gmsa_credential_spec_name: Optional[pulumi.Input[str]] = None,
                 run_as_user_name: Optional[pulumi.Input[str]] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec")

    @gmsa_credential_spec.setter
    def gmsa_credential_spec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec", value)

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @gmsa_credential_spec_name.setter
    def gmsa_credential_spec_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec_name", value)

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "run_as_user_name")

    @run_as_user_name.setter
    def run_as_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "run_as_user_name", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplatePodTolerationsArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 toleration_seconds: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if toleration_seconds is not None:
            pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "toleration_seconds")

    @toleration_seconds.setter
    def toleration_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "toleration_seconds", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplateServiceArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplateServiceMetadataArgs']] = None):
        """
        Template for Kafka Exporter `Service`.
        :param pulumi.Input['KafkaSpecKafkaExporterTemplateServiceMetadataArgs'] metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['KafkaSpecKafkaExporterTemplateServiceMetadataArgs']]:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['KafkaSpecKafkaExporterTemplateServiceMetadataArgs']]):
        pulumi.set(self, "metadata", value)


@pulumi.input_type
class KafkaSpecKafkaExporterTemplateServiceMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Metadata applied to the resource.
        :param pulumi.Input[Mapping[str, Any]] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param pulumi.Input[Mapping[str, Any]] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class KafkaSpecKafkaJmxOptionsArgs:
    def __init__(__self__, *,
                 authentication: Optional[pulumi.Input['KafkaSpecKafkaJmxOptionsAuthenticationArgs']] = None):
        """
        JMX Options for Kafka brokers.
        :param pulumi.Input['KafkaSpecKafkaJmxOptionsAuthenticationArgs'] authentication: Authentication configuration for connecting to the Kafka JMX port.
        """
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)

    @property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['KafkaSpecKafkaJmxOptionsAuthenticationArgs']]:
        """
        Authentication configuration for connecting to the Kafka JMX port.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['KafkaSpecKafkaJmxOptionsAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)


@pulumi.input_type
class KafkaSpecKafkaJmxOptionsAuthenticationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str]):
        """
        Authentication configuration for connecting to the Kafka JMX port.
        :param pulumi.Input[str] type: Authentication type. Currently the only supported types are `password`.`password` type creates a username and protected port with no TLS.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Authentication type. Currently the only supported types are `password`.`password` type creates a username and protected port with no TLS.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class KafkaSpecKafkaJvmOptionsArgs:
    def __init__(__self__, *,
                 __xx: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 __xms: Optional[pulumi.Input[str]] = None,
                 __xmx: Optional[pulumi.Input[str]] = None,
                 gc_logging_enabled: Optional[pulumi.Input[bool]] = None,
                 java_system_properties: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaJvmOptionsJavaSystemPropertiesArgs']]]] = None):
        """
        JVM Options for pods.
        :param pulumi.Input[Mapping[str, Any]] __xx: A map of -XX options to the JVM.
        :param pulumi.Input[str] __xms: -Xms option to to the JVM.
        :param pulumi.Input[str] __xmx: -Xmx option to to the JVM.
        :param pulumi.Input[bool] gc_logging_enabled: Specifies whether the Garbage Collection logging is enabled. The default is false.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaJvmOptionsJavaSystemPropertiesArgs']]] java_system_properties: A map of additional system properties which will be passed using the `-D` option to the JVM.
        """
        if __xx is not None:
            pulumi.set(__self__, "__xx", __xx)
        if __xms is not None:
            pulumi.set(__self__, "__xms", __xms)
        if __xmx is not None:
            pulumi.set(__self__, "__xmx", __xmx)
        if gc_logging_enabled is not None:
            pulumi.set(__self__, "gc_logging_enabled", gc_logging_enabled)
        if java_system_properties is not None:
            pulumi.set(__self__, "java_system_properties", java_system_properties)

    @property
    @pulumi.getter(name="-XX")
    def __xx(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        A map of -XX options to the JVM.
        """
        return pulumi.get(self, "__xx")

    @__xx.setter
    def __xx(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "__xx", value)

    @property
    @pulumi.getter(name="-Xms")
    def __xms(self) -> Optional[pulumi.Input[str]]:
        """
        -Xms option to to the JVM.
        """
        return pulumi.get(self, "__xms")

    @__xms.setter
    def __xms(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "__xms", value)

    @property
    @pulumi.getter(name="-Xmx")
    def __xmx(self) -> Optional[pulumi.Input[str]]:
        """
        -Xmx option to to the JVM.
        """
        return pulumi.get(self, "__xmx")

    @__xmx.setter
    def __xmx(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "__xmx", value)

    @property
    @pulumi.getter(name="gcLoggingEnabled")
    def gc_logging_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether the Garbage Collection logging is enabled. The default is false.
        """
        return pulumi.get(self, "gc_logging_enabled")

    @gc_logging_enabled.setter
    def gc_logging_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "gc_logging_enabled", value)

    @property
    @pulumi.getter(name="javaSystemProperties")
    def java_system_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaJvmOptionsJavaSystemPropertiesArgs']]]]:
        """
        A map of additional system properties which will be passed using the `-D` option to the JVM.
        """
        return pulumi.get(self, "java_system_properties")

    @java_system_properties.setter
    def java_system_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaJvmOptionsJavaSystemPropertiesArgs']]]]):
        pulumi.set(self, "java_system_properties", value)


@pulumi.input_type
class KafkaSpecKafkaJvmOptionsJavaSystemPropertiesArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The system property name.
        :param pulumi.Input[str] value: The system property value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The system property name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The system property value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf0Args:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 port: pulumi.Input[int],
                 tls: pulumi.Input[bool],
                 type: pulumi.Input[str],
                 authentication: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf0AuthenticationArgs']] = None,
                 configuration: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf0ConfigurationArgs']] = None,
                 network_policy_peers: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersArgs']]]] = None):
        """
        :param pulumi.Input[str] name: Name of the listener. The name will be used to identify the listener and the related Kubernetes objects. The name has to be unique within given a Kafka cluster. The name can consist of lowercase characters and numbers and be up to 11 characters long.
        :param pulumi.Input[int] port: Port number used by the listener inside Kafka. The port number has to be unique within a given Kafka cluster. Allowed port numbers are 9092 and higher with the exception of ports 9404 and 9999, which are already used for Prometheus and JMX. Depending on the listener type, the port number might not be the same as the port number that connects Kafka clients.
        :param pulumi.Input[bool] tls: Enables TLS encryption on the listener. This is a required property.
        :param pulumi.Input[str] type: Type of the listener. Currently the supported types are `internal`, `route`, `loadbalancer`, `nodeport` and `ingress`. 
               
               * `internal` type exposes Kafka internally only within the Kubernetes cluster.
               * `route` type uses OpenShift Routes to expose Kafka.
               * `loadbalancer` type uses LoadBalancer type services to expose Kafka.
               * `nodeport` type uses NodePort type services to expose Kafka.
               * `ingress` type uses Kubernetes Nginx Ingress to expose Kafka.
               .
        :param pulumi.Input['KafkaSpecKafkaListenersOneOf0AuthenticationArgs'] authentication: Authentication configuration for this listener.
        :param pulumi.Input['KafkaSpecKafkaListenersOneOf0ConfigurationArgs'] configuration: Additional listener configuration.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersArgs']]] network_policy_peers: List of peers which should be able to connect to this listener. Peers in this list are combined using a logical OR operation. If this field is empty or missing, all connections will be allowed for this listener. If this field is present and contains at least one item, the listener only allows the traffic which matches at least one item in this list.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "tls", tls)
        pulumi.set(__self__, "type", type)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if network_policy_peers is not None:
            pulumi.set(__self__, "network_policy_peers", network_policy_peers)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the listener. The name will be used to identify the listener and the related Kubernetes objects. The name has to be unique within given a Kafka cluster. The name can consist of lowercase characters and numbers and be up to 11 characters long.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        Port number used by the listener inside Kafka. The port number has to be unique within a given Kafka cluster. Allowed port numbers are 9092 and higher with the exception of ports 9404 and 9999, which are already used for Prometheus and JMX. Depending on the listener type, the port number might not be the same as the port number that connects Kafka clients.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def tls(self) -> pulumi.Input[bool]:
        """
        Enables TLS encryption on the listener. This is a required property.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: pulumi.Input[bool]):
        pulumi.set(self, "tls", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the listener. Currently the supported types are `internal`, `route`, `loadbalancer`, `nodeport` and `ingress`. 

        * `internal` type exposes Kafka internally only within the Kubernetes cluster.
        * `route` type uses OpenShift Routes to expose Kafka.
        * `loadbalancer` type uses LoadBalancer type services to expose Kafka.
        * `nodeport` type uses NodePort type services to expose Kafka.
        * `ingress` type uses Kubernetes Nginx Ingress to expose Kafka.
        .
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf0AuthenticationArgs']]:
        """
        Authentication configuration for this listener.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf0AuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @property
    @pulumi.getter
    def configuration(self) -> Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf0ConfigurationArgs']]:
        """
        Additional listener configuration.
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf0ConfigurationArgs']]):
        pulumi.set(self, "configuration", value)

    @property
    @pulumi.getter(name="networkPolicyPeers")
    def network_policy_peers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersArgs']]]]:
        """
        List of peers which should be able to connect to this listener. Peers in this list are combined using a logical OR operation. If this field is empty or missing, all connections will be allowed for this listener. If this field is present and contains at least one item, the listener only allows the traffic which matches at least one item in this list.
        """
        return pulumi.get(self, "network_policy_peers")

    @network_policy_peers.setter
    def network_policy_peers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersArgs']]]]):
        pulumi.set(self, "network_policy_peers", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf0AuthenticationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 access_token_is_jwt: Optional[pulumi.Input[bool]] = None,
                 check_access_token_type: Optional[pulumi.Input[bool]] = None,
                 check_issuer: Optional[pulumi.Input[bool]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf0AuthenticationClientSecretArgs']] = None,
                 disable_tls_hostname_verification: Optional[pulumi.Input[bool]] = None,
                 enable_ecdsa: Optional[pulumi.Input[bool]] = None,
                 fallback_user_name_claim: Optional[pulumi.Input[str]] = None,
                 fallback_user_name_prefix: Optional[pulumi.Input[str]] = None,
                 introspection_endpoint_uri: Optional[pulumi.Input[str]] = None,
                 jwks_endpoint_uri: Optional[pulumi.Input[str]] = None,
                 jwks_expiry_seconds: Optional[pulumi.Input[int]] = None,
                 jwks_min_refresh_pause_seconds: Optional[pulumi.Input[int]] = None,
                 jwks_refresh_seconds: Optional[pulumi.Input[int]] = None,
                 max_seconds_without_reauthentication: Optional[pulumi.Input[int]] = None,
                 tls_trusted_certificates: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf0AuthenticationTlsTrustedCertificatesArgs']]]] = None,
                 user_info_endpoint_uri: Optional[pulumi.Input[str]] = None,
                 user_name_claim: Optional[pulumi.Input[str]] = None,
                 valid_issuer_uri: Optional[pulumi.Input[str]] = None,
                 valid_token_type: Optional[pulumi.Input[str]] = None):
        """
        Authentication configuration for this listener.
        :param pulumi.Input[str] type: Authentication type. `oauth` type uses SASL OAUTHBEARER Authentication. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `tls` type uses TLS Client Authentication. `tls` type is supported only on TLS listeners.
        :param pulumi.Input[bool] access_token_is_jwt: Configure whether the access token is treated as JWT. This must be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
        :param pulumi.Input[bool] check_access_token_type: Configure whether the access token type check is performed or not. This should be set to `false` if the authorization server does not include 'typ' claim in JWT token. Defaults to `true`.
        :param pulumi.Input[bool] check_issuer: Enable or disable issuer checking. By default issuer is checked using the value configured by `validIssuerUri`. Default value is `true`.
        :param pulumi.Input[str] client_id: OAuth Client ID which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
        :param pulumi.Input['KafkaSpecKafkaListenersOneOf0AuthenticationClientSecretArgs'] client_secret: Link to Kubernetes Secret containing the OAuth client secret which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
        :param pulumi.Input[bool] disable_tls_hostname_verification: Enable or disable TLS hostname verification. Default value is `false`.
        :param pulumi.Input[bool] enable_ecdsa: Enable or disable ECDSA support by installing BouncyCastle crypto provider. Default value is `false`.
        :param pulumi.Input[str] fallback_user_name_claim: The fallback username claim to be used for the user id if the claim specified by `userNameClaim` is not present. This is useful when `client_credentials` authentication only results in the client id being provided in another claim. It only takes effect if `userNameClaim` is set.
        :param pulumi.Input[str] fallback_user_name_prefix: The prefix to use with the value of `fallbackUserNameClaim` to construct the user id. This only takes effect if `fallbackUserNameClaim` is true, and the value is present for the claim. Mapping usernames and client ids into the same user id space is useful in preventing name collisions.
        :param pulumi.Input[str] introspection_endpoint_uri: URI of the token introspection endpoint which can be used to validate opaque non-JWT tokens.
        :param pulumi.Input[str] jwks_endpoint_uri: URI of the JWKS certificate endpoint, which can be used for local JWT validation.
        :param pulumi.Input[int] jwks_expiry_seconds: Configures how often are the JWKS certificates considered valid. The expiry interval has to be at least 60 seconds longer then the refresh interval specified in `jwksRefreshSeconds`. Defaults to 360 seconds.
        :param pulumi.Input[int] jwks_min_refresh_pause_seconds: The minimum pause between two consecutive refreshes. When an unknown signing key is encountered the refresh is scheduled immediately, but will always wait for this minimum pause. Defaults to 1 second.
        :param pulumi.Input[int] jwks_refresh_seconds: Configures how often are the JWKS certificates refreshed. The refresh interval has to be at least 60 seconds shorter then the expiry interval specified in `jwksExpirySeconds`. Defaults to 300 seconds.
        :param pulumi.Input[int] max_seconds_without_reauthentication: Maximum number of seconds the authenticated session remains valid without re-authentication. This enables Apache Kafka re-authentication feature, and causes sessions to expire when the access token expires. If the access token expires before max time or if max time is reached, the client has to re-authenticate, otherwise the server will drop the connection. Not set by default - the authenticated session does not expire when the access token expires.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf0AuthenticationTlsTrustedCertificatesArgs']]] tls_trusted_certificates: Trusted certificates for TLS connection to the OAuth server.
        :param pulumi.Input[str] user_info_endpoint_uri: URI of the User Info Endpoint to use as a fallback to obtaining the user id when the Introspection Endpoint does not return information that can be used for the user id. 
        :param pulumi.Input[str] user_name_claim: Name of the claim from the JWT authentication token, Introspection Endpoint response or User Info Endpoint response which will be used to extract the user id. Defaults to `sub`.
        :param pulumi.Input[str] valid_issuer_uri: URI of the token issuer used for authentication.
        :param pulumi.Input[str] valid_token_type: Valid value for the `token_type` attribute returned by the Introspection Endpoint. No default value, and not checked by default.
        """
        pulumi.set(__self__, "type", type)
        if access_token_is_jwt is not None:
            pulumi.set(__self__, "access_token_is_jwt", access_token_is_jwt)
        if check_access_token_type is not None:
            pulumi.set(__self__, "check_access_token_type", check_access_token_type)
        if check_issuer is not None:
            pulumi.set(__self__, "check_issuer", check_issuer)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if disable_tls_hostname_verification is not None:
            pulumi.set(__self__, "disable_tls_hostname_verification", disable_tls_hostname_verification)
        if enable_ecdsa is not None:
            pulumi.set(__self__, "enable_ecdsa", enable_ecdsa)
        if fallback_user_name_claim is not None:
            pulumi.set(__self__, "fallback_user_name_claim", fallback_user_name_claim)
        if fallback_user_name_prefix is not None:
            pulumi.set(__self__, "fallback_user_name_prefix", fallback_user_name_prefix)
        if introspection_endpoint_uri is not None:
            pulumi.set(__self__, "introspection_endpoint_uri", introspection_endpoint_uri)
        if jwks_endpoint_uri is not None:
            pulumi.set(__self__, "jwks_endpoint_uri", jwks_endpoint_uri)
        if jwks_expiry_seconds is not None:
            pulumi.set(__self__, "jwks_expiry_seconds", jwks_expiry_seconds)
        if jwks_min_refresh_pause_seconds is not None:
            pulumi.set(__self__, "jwks_min_refresh_pause_seconds", jwks_min_refresh_pause_seconds)
        if jwks_refresh_seconds is not None:
            pulumi.set(__self__, "jwks_refresh_seconds", jwks_refresh_seconds)
        if max_seconds_without_reauthentication is not None:
            pulumi.set(__self__, "max_seconds_without_reauthentication", max_seconds_without_reauthentication)
        if tls_trusted_certificates is not None:
            pulumi.set(__self__, "tls_trusted_certificates", tls_trusted_certificates)
        if user_info_endpoint_uri is not None:
            pulumi.set(__self__, "user_info_endpoint_uri", user_info_endpoint_uri)
        if user_name_claim is not None:
            pulumi.set(__self__, "user_name_claim", user_name_claim)
        if valid_issuer_uri is not None:
            pulumi.set(__self__, "valid_issuer_uri", valid_issuer_uri)
        if valid_token_type is not None:
            pulumi.set(__self__, "valid_token_type", valid_token_type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Authentication type. `oauth` type uses SASL OAUTHBEARER Authentication. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `tls` type uses TLS Client Authentication. `tls` type is supported only on TLS listeners.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="accessTokenIsJwt")
    def access_token_is_jwt(self) -> Optional[pulumi.Input[bool]]:
        """
        Configure whether the access token is treated as JWT. This must be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
        """
        return pulumi.get(self, "access_token_is_jwt")

    @access_token_is_jwt.setter
    def access_token_is_jwt(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "access_token_is_jwt", value)

    @property
    @pulumi.getter(name="checkAccessTokenType")
    def check_access_token_type(self) -> Optional[pulumi.Input[bool]]:
        """
        Configure whether the access token type check is performed or not. This should be set to `false` if the authorization server does not include 'typ' claim in JWT token. Defaults to `true`.
        """
        return pulumi.get(self, "check_access_token_type")

    @check_access_token_type.setter
    def check_access_token_type(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "check_access_token_type", value)

    @property
    @pulumi.getter(name="checkIssuer")
    def check_issuer(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable or disable issuer checking. By default issuer is checked using the value configured by `validIssuerUri`. Default value is `true`.
        """
        return pulumi.get(self, "check_issuer")

    @check_issuer.setter
    def check_issuer(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "check_issuer", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        OAuth Client ID which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf0AuthenticationClientSecretArgs']]:
        """
        Link to Kubernetes Secret containing the OAuth client secret which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf0AuthenticationClientSecretArgs']]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="disableTlsHostnameVerification")
    def disable_tls_hostname_verification(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable or disable TLS hostname verification. Default value is `false`.
        """
        return pulumi.get(self, "disable_tls_hostname_verification")

    @disable_tls_hostname_verification.setter
    def disable_tls_hostname_verification(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_tls_hostname_verification", value)

    @property
    @pulumi.getter(name="enableECDSA")
    def enable_ecdsa(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable or disable ECDSA support by installing BouncyCastle crypto provider. Default value is `false`.
        """
        return pulumi.get(self, "enable_ecdsa")

    @enable_ecdsa.setter
    def enable_ecdsa(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_ecdsa", value)

    @property
    @pulumi.getter(name="fallbackUserNameClaim")
    def fallback_user_name_claim(self) -> Optional[pulumi.Input[str]]:
        """
        The fallback username claim to be used for the user id if the claim specified by `userNameClaim` is not present. This is useful when `client_credentials` authentication only results in the client id being provided in another claim. It only takes effect if `userNameClaim` is set.
        """
        return pulumi.get(self, "fallback_user_name_claim")

    @fallback_user_name_claim.setter
    def fallback_user_name_claim(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fallback_user_name_claim", value)

    @property
    @pulumi.getter(name="fallbackUserNamePrefix")
    def fallback_user_name_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The prefix to use with the value of `fallbackUserNameClaim` to construct the user id. This only takes effect if `fallbackUserNameClaim` is true, and the value is present for the claim. Mapping usernames and client ids into the same user id space is useful in preventing name collisions.
        """
        return pulumi.get(self, "fallback_user_name_prefix")

    @fallback_user_name_prefix.setter
    def fallback_user_name_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fallback_user_name_prefix", value)

    @property
    @pulumi.getter(name="introspectionEndpointUri")
    def introspection_endpoint_uri(self) -> Optional[pulumi.Input[str]]:
        """
        URI of the token introspection endpoint which can be used to validate opaque non-JWT tokens.
        """
        return pulumi.get(self, "introspection_endpoint_uri")

    @introspection_endpoint_uri.setter
    def introspection_endpoint_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "introspection_endpoint_uri", value)

    @property
    @pulumi.getter(name="jwksEndpointUri")
    def jwks_endpoint_uri(self) -> Optional[pulumi.Input[str]]:
        """
        URI of the JWKS certificate endpoint, which can be used for local JWT validation.
        """
        return pulumi.get(self, "jwks_endpoint_uri")

    @jwks_endpoint_uri.setter
    def jwks_endpoint_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jwks_endpoint_uri", value)

    @property
    @pulumi.getter(name="jwksExpirySeconds")
    def jwks_expiry_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Configures how often are the JWKS certificates considered valid. The expiry interval has to be at least 60 seconds longer then the refresh interval specified in `jwksRefreshSeconds`. Defaults to 360 seconds.
        """
        return pulumi.get(self, "jwks_expiry_seconds")

    @jwks_expiry_seconds.setter
    def jwks_expiry_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "jwks_expiry_seconds", value)

    @property
    @pulumi.getter(name="jwksMinRefreshPauseSeconds")
    def jwks_min_refresh_pause_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The minimum pause between two consecutive refreshes. When an unknown signing key is encountered the refresh is scheduled immediately, but will always wait for this minimum pause. Defaults to 1 second.
        """
        return pulumi.get(self, "jwks_min_refresh_pause_seconds")

    @jwks_min_refresh_pause_seconds.setter
    def jwks_min_refresh_pause_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "jwks_min_refresh_pause_seconds", value)

    @property
    @pulumi.getter(name="jwksRefreshSeconds")
    def jwks_refresh_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Configures how often are the JWKS certificates refreshed. The refresh interval has to be at least 60 seconds shorter then the expiry interval specified in `jwksExpirySeconds`. Defaults to 300 seconds.
        """
        return pulumi.get(self, "jwks_refresh_seconds")

    @jwks_refresh_seconds.setter
    def jwks_refresh_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "jwks_refresh_seconds", value)

    @property
    @pulumi.getter(name="maxSecondsWithoutReauthentication")
    def max_seconds_without_reauthentication(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of seconds the authenticated session remains valid without re-authentication. This enables Apache Kafka re-authentication feature, and causes sessions to expire when the access token expires. If the access token expires before max time or if max time is reached, the client has to re-authenticate, otherwise the server will drop the connection. Not set by default - the authenticated session does not expire when the access token expires.
        """
        return pulumi.get(self, "max_seconds_without_reauthentication")

    @max_seconds_without_reauthentication.setter
    def max_seconds_without_reauthentication(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_seconds_without_reauthentication", value)

    @property
    @pulumi.getter(name="tlsTrustedCertificates")
    def tls_trusted_certificates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf0AuthenticationTlsTrustedCertificatesArgs']]]]:
        """
        Trusted certificates for TLS connection to the OAuth server.
        """
        return pulumi.get(self, "tls_trusted_certificates")

    @tls_trusted_certificates.setter
    def tls_trusted_certificates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf0AuthenticationTlsTrustedCertificatesArgs']]]]):
        pulumi.set(self, "tls_trusted_certificates", value)

    @property
    @pulumi.getter(name="userInfoEndpointUri")
    def user_info_endpoint_uri(self) -> Optional[pulumi.Input[str]]:
        """
        URI of the User Info Endpoint to use as a fallback to obtaining the user id when the Introspection Endpoint does not return information that can be used for the user id. 
        """
        return pulumi.get(self, "user_info_endpoint_uri")

    @user_info_endpoint_uri.setter
    def user_info_endpoint_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_info_endpoint_uri", value)

    @property
    @pulumi.getter(name="userNameClaim")
    def user_name_claim(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the claim from the JWT authentication token, Introspection Endpoint response or User Info Endpoint response which will be used to extract the user id. Defaults to `sub`.
        """
        return pulumi.get(self, "user_name_claim")

    @user_name_claim.setter
    def user_name_claim(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_name_claim", value)

    @property
    @pulumi.getter(name="validIssuerUri")
    def valid_issuer_uri(self) -> Optional[pulumi.Input[str]]:
        """
        URI of the token issuer used for authentication.
        """
        return pulumi.get(self, "valid_issuer_uri")

    @valid_issuer_uri.setter
    def valid_issuer_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "valid_issuer_uri", value)

    @property
    @pulumi.getter(name="validTokenType")
    def valid_token_type(self) -> Optional[pulumi.Input[str]]:
        """
        Valid value for the `token_type` attribute returned by the Introspection Endpoint. No default value, and not checked by default.
        """
        return pulumi.get(self, "valid_token_type")

    @valid_token_type.setter
    def valid_token_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "valid_token_type", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf0AuthenticationClientSecretArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        Link to Kubernetes Secret containing the OAuth client secret which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
        :param pulumi.Input[str] key: The key under which the secret value is stored in the Kubernetes Secret.
        :param pulumi.Input[str] secret_name: The name of the Kubernetes Secret containing the secret value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key under which the secret value is stored in the Kubernetes Secret.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        The name of the Kubernetes Secret containing the secret value.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf0AuthenticationTlsTrustedCertificatesArgs:
    def __init__(__self__, *,
                 certificate: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] certificate: The name of the file certificate in the Secret.
        :param pulumi.Input[str] secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> pulumi.Input[str]:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf0ConfigurationArgs:
    def __init__(__self__, *,
                 bootstrap: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf0ConfigurationBootstrapArgs']] = None,
                 broker_cert_chain_and_key: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf0ConfigurationBrokerCertChainAndKeyArgs']] = None,
                 brokers: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf0ConfigurationBrokersArgs']]]] = None,
                 class_: Optional[pulumi.Input[str]] = None,
                 external_traffic_policy: Optional[pulumi.Input[str]] = None,
                 load_balancer_source_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 preferred_node_port_address_type: Optional[pulumi.Input[str]] = None,
                 use_service_dns_domain: Optional[pulumi.Input[bool]] = None):
        """
        Additional listener configuration.
        :param pulumi.Input['KafkaSpecKafkaListenersOneOf0ConfigurationBootstrapArgs'] bootstrap: Bootstrap configuration.
        :param pulumi.Input['KafkaSpecKafkaListenersOneOf0ConfigurationBrokerCertChainAndKeyArgs'] broker_cert_chain_and_key: Reference to the `Secret` which holds the certificate and private key pair which will be used for this listener. The certificate can optionally contain the whole chain. This field can be used only with listeners with enabled TLS encryption.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf0ConfigurationBrokersArgs']]] brokers: Per-broker configurations.
        :param pulumi.Input[str] class_: Configures the `Ingress` class that defines which `Ingress` controller will be used. If not set, the `Ingress` class is set to `nginx`. This field can be used only with `ingress` type listener.
        :param pulumi.Input[str] external_traffic_policy: Specifies whether the service routes external traffic to node-local or cluster-wide endpoints. `Cluster` may cause a second hop to another node and obscures the client source IP. `Local` avoids a second hop for LoadBalancer and Nodeport type services and preserves the client source IP (when supported by the infrastructure). If unspecified, Kubernetes will use `Cluster` as the default.This field can be used only with `loadbalancer` or `nodeport` type listener.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] load_balancer_source_ranges: A list of CIDR ranges (for example `10.0.0.0/8` or `130.211.204.1/32`) from which clients can connect to load balancer type listeners. If supported by the platform, traffic through the loadbalancer is restricted to the specified CIDR ranges. This field is applicable only for loadbalancer type services and is ignored if the cloud provider does not support the feature. For more information, see https://v1-17.docs.kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/. This field can be used only with `loadbalancer` type listener.
        :param pulumi.Input[str] preferred_node_port_address_type: Defines which address type should be used as the node address. Available types are: `ExternalDNS`, `ExternalIP`, `InternalDNS`, `InternalIP` and `Hostname`. By default, the addresses will be used in the following order (the first one found will be used):
               * `ExternalDNS`
               * `ExternalIP`
               * `InternalDNS`
               * `InternalIP`
               * `Hostname`
               
               This field can be used to select the address type which will be used as the preferred type and checked first. In case no address will be found for this address type, the other types will be used in the default order.This field can be used only with `nodeport` type listener..
        :param pulumi.Input[bool] use_service_dns_domain: Configures whether the Kubernetes service DNS domain should be used or not. If set to `true`, the generated addresses with contain the service DNS domain suffix (by default `.cluster.local`, can be configured using environment variable `KUBERNETES_SERVICE_DNS_DOMAIN`). Defaults to `false`.This field can be used only with `internal` type listener.
        """
        if bootstrap is not None:
            pulumi.set(__self__, "bootstrap", bootstrap)
        if broker_cert_chain_and_key is not None:
            pulumi.set(__self__, "broker_cert_chain_and_key", broker_cert_chain_and_key)
        if brokers is not None:
            pulumi.set(__self__, "brokers", brokers)
        if class_ is not None:
            pulumi.set(__self__, "class_", class_)
        if external_traffic_policy is not None:
            pulumi.set(__self__, "external_traffic_policy", external_traffic_policy)
        if load_balancer_source_ranges is not None:
            pulumi.set(__self__, "load_balancer_source_ranges", load_balancer_source_ranges)
        if preferred_node_port_address_type is not None:
            pulumi.set(__self__, "preferred_node_port_address_type", preferred_node_port_address_type)
        if use_service_dns_domain is not None:
            pulumi.set(__self__, "use_service_dns_domain", use_service_dns_domain)

    @property
    @pulumi.getter
    def bootstrap(self) -> Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf0ConfigurationBootstrapArgs']]:
        """
        Bootstrap configuration.
        """
        return pulumi.get(self, "bootstrap")

    @bootstrap.setter
    def bootstrap(self, value: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf0ConfigurationBootstrapArgs']]):
        pulumi.set(self, "bootstrap", value)

    @property
    @pulumi.getter(name="brokerCertChainAndKey")
    def broker_cert_chain_and_key(self) -> Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf0ConfigurationBrokerCertChainAndKeyArgs']]:
        """
        Reference to the `Secret` which holds the certificate and private key pair which will be used for this listener. The certificate can optionally contain the whole chain. This field can be used only with listeners with enabled TLS encryption.
        """
        return pulumi.get(self, "broker_cert_chain_and_key")

    @broker_cert_chain_and_key.setter
    def broker_cert_chain_and_key(self, value: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf0ConfigurationBrokerCertChainAndKeyArgs']]):
        pulumi.set(self, "broker_cert_chain_and_key", value)

    @property
    @pulumi.getter
    def brokers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf0ConfigurationBrokersArgs']]]]:
        """
        Per-broker configurations.
        """
        return pulumi.get(self, "brokers")

    @brokers.setter
    def brokers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf0ConfigurationBrokersArgs']]]]):
        pulumi.set(self, "brokers", value)

    @property
    @pulumi.getter(name="class")
    def class_(self) -> Optional[pulumi.Input[str]]:
        """
        Configures the `Ingress` class that defines which `Ingress` controller will be used. If not set, the `Ingress` class is set to `nginx`. This field can be used only with `ingress` type listener.
        """
        return pulumi.get(self, "class_")

    @class_.setter
    def class_(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "class_", value)

    @property
    @pulumi.getter(name="externalTrafficPolicy")
    def external_traffic_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies whether the service routes external traffic to node-local or cluster-wide endpoints. `Cluster` may cause a second hop to another node and obscures the client source IP. `Local` avoids a second hop for LoadBalancer and Nodeport type services and preserves the client source IP (when supported by the infrastructure). If unspecified, Kubernetes will use `Cluster` as the default.This field can be used only with `loadbalancer` or `nodeport` type listener.
        """
        return pulumi.get(self, "external_traffic_policy")

    @external_traffic_policy.setter
    def external_traffic_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "external_traffic_policy", value)

    @property
    @pulumi.getter(name="loadBalancerSourceRanges")
    def load_balancer_source_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of CIDR ranges (for example `10.0.0.0/8` or `130.211.204.1/32`) from which clients can connect to load balancer type listeners. If supported by the platform, traffic through the loadbalancer is restricted to the specified CIDR ranges. This field is applicable only for loadbalancer type services and is ignored if the cloud provider does not support the feature. For more information, see https://v1-17.docs.kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/. This field can be used only with `loadbalancer` type listener.
        """
        return pulumi.get(self, "load_balancer_source_ranges")

    @load_balancer_source_ranges.setter
    def load_balancer_source_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "load_balancer_source_ranges", value)

    @property
    @pulumi.getter(name="preferredNodePortAddressType")
    def preferred_node_port_address_type(self) -> Optional[pulumi.Input[str]]:
        """
        Defines which address type should be used as the node address. Available types are: `ExternalDNS`, `ExternalIP`, `InternalDNS`, `InternalIP` and `Hostname`. By default, the addresses will be used in the following order (the first one found will be used):
        * `ExternalDNS`
        * `ExternalIP`
        * `InternalDNS`
        * `InternalIP`
        * `Hostname`

        This field can be used to select the address type which will be used as the preferred type and checked first. In case no address will be found for this address type, the other types will be used in the default order.This field can be used only with `nodeport` type listener..
        """
        return pulumi.get(self, "preferred_node_port_address_type")

    @preferred_node_port_address_type.setter
    def preferred_node_port_address_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preferred_node_port_address_type", value)

    @property
    @pulumi.getter(name="useServiceDnsDomain")
    def use_service_dns_domain(self) -> Optional[pulumi.Input[bool]]:
        """
        Configures whether the Kubernetes service DNS domain should be used or not. If set to `true`, the generated addresses with contain the service DNS domain suffix (by default `.cluster.local`, can be configured using environment variable `KUBERNETES_SERVICE_DNS_DOMAIN`). Defaults to `false`.This field can be used only with `internal` type listener.
        """
        return pulumi.get(self, "use_service_dns_domain")

    @use_service_dns_domain.setter
    def use_service_dns_domain(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_service_dns_domain", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf0ConfigurationBootstrapArgs:
    def __init__(__self__, *,
                 alternative_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 load_balancer_ip: Optional[pulumi.Input[str]] = None,
                 node_port: Optional[pulumi.Input[int]] = None):
        """
        Bootstrap configuration.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] alternative_names: Additional alternative names for the bootstrap service. The alternative names will be added to the list of subject alternative names of the TLS certificates.
        :param pulumi.Input[Mapping[str, Any]] annotations: Annotations that will be added to the `Ingress` or `Service` resource. You can use this field to configure DNS providers such as External DNS. This field can be used only with `loadbalancer`, `nodeport`, or `ingress` type listeners.
        :param pulumi.Input[str] host: The bootstrap host. This field will be used in the Ingress resource or in the Route resource to specify the desired hostname. This field can be used only with `route` (optional) or `ingress` (required) type listeners.
        :param pulumi.Input[str] load_balancer_ip: The loadbalancer is requested with the IP address specified in this field. This feature depends on whether the underlying cloud provider supports specifying the `loadBalancerIP` when a load balancer is created. This field is ignored if the cloud provider does not support the feature.This field can be used only with `loadbalancer` type listener.
        :param pulumi.Input[int] node_port: Node port for the bootstrap service. This field can be used only with `nodeport` type listener.
        """
        if alternative_names is not None:
            pulumi.set(__self__, "alternative_names", alternative_names)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if load_balancer_ip is not None:
            pulumi.set(__self__, "load_balancer_ip", load_balancer_ip)
        if node_port is not None:
            pulumi.set(__self__, "node_port", node_port)

    @property
    @pulumi.getter(name="alternativeNames")
    def alternative_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Additional alternative names for the bootstrap service. The alternative names will be added to the list of subject alternative names of the TLS certificates.
        """
        return pulumi.get(self, "alternative_names")

    @alternative_names.setter
    def alternative_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "alternative_names", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations that will be added to the `Ingress` or `Service` resource. You can use this field to configure DNS providers such as External DNS. This field can be used only with `loadbalancer`, `nodeport`, or `ingress` type listeners.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        The bootstrap host. This field will be used in the Ingress resource or in the Route resource to specify the desired hostname. This field can be used only with `route` (optional) or `ingress` (required) type listeners.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="loadBalancerIP")
    def load_balancer_ip(self) -> Optional[pulumi.Input[str]]:
        """
        The loadbalancer is requested with the IP address specified in this field. This feature depends on whether the underlying cloud provider supports specifying the `loadBalancerIP` when a load balancer is created. This field is ignored if the cloud provider does not support the feature.This field can be used only with `loadbalancer` type listener.
        """
        return pulumi.get(self, "load_balancer_ip")

    @load_balancer_ip.setter
    def load_balancer_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "load_balancer_ip", value)

    @property
    @pulumi.getter(name="nodePort")
    def node_port(self) -> Optional[pulumi.Input[int]]:
        """
        Node port for the bootstrap service. This field can be used only with `nodeport` type listener.
        """
        return pulumi.get(self, "node_port")

    @node_port.setter
    def node_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "node_port", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf0ConfigurationBrokerCertChainAndKeyArgs:
    def __init__(__self__, *,
                 certificate: pulumi.Input[str],
                 key: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        Reference to the `Secret` which holds the certificate and private key pair which will be used for this listener. The certificate can optionally contain the whole chain. This field can be used only with listeners with enabled TLS encryption.
        :param pulumi.Input[str] certificate: The name of the file certificate in the Secret.
        :param pulumi.Input[str] key: The name of the private key in the Secret.
        :param pulumi.Input[str] secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> pulumi.Input[str]:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The name of the private key in the Secret.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf0ConfigurationBrokersArgs:
    def __init__(__self__, *,
                 broker: pulumi.Input[int],
                 advertised_host: Optional[pulumi.Input[str]] = None,
                 advertised_port: Optional[pulumi.Input[int]] = None,
                 annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 load_balancer_ip: Optional[pulumi.Input[str]] = None,
                 node_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] broker: ID of the kafka broker (broker identifier). Broker IDs start from 0 and correspond to the number of broker replicas.
        :param pulumi.Input[str] advertised_host: The host name which will be used in the brokers' `advertised.brokers`.
        :param pulumi.Input[int] advertised_port: The port number which will be used in the brokers' `advertised.brokers`.
        :param pulumi.Input[Mapping[str, Any]] annotations: Annotations that will be added to the `Ingress` or `Service` resource. You can use this field to configure DNS providers such as External DNS. This field can be used only with `loadbalancer`, `nodeport`, or `ingress` type listeners.
        :param pulumi.Input[str] host: The broker host. This field will be used in the Ingress resource or in the Route resource to specify the desired hostname. This field can be used only with `route` (optional) or `ingress` (required) type listeners.
        :param pulumi.Input[str] load_balancer_ip: The loadbalancer is requested with the IP address specified in this field. This feature depends on whether the underlying cloud provider supports specifying the `loadBalancerIP` when a load balancer is created. This field is ignored if the cloud provider does not support the feature.This field can be used only with `loadbalancer` type listener.
        :param pulumi.Input[int] node_port: Node port for the per-broker service. This field can be used only with `nodeport` type listener.
        """
        pulumi.set(__self__, "broker", broker)
        if advertised_host is not None:
            pulumi.set(__self__, "advertised_host", advertised_host)
        if advertised_port is not None:
            pulumi.set(__self__, "advertised_port", advertised_port)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if load_balancer_ip is not None:
            pulumi.set(__self__, "load_balancer_ip", load_balancer_ip)
        if node_port is not None:
            pulumi.set(__self__, "node_port", node_port)

    @property
    @pulumi.getter
    def broker(self) -> pulumi.Input[int]:
        """
        ID of the kafka broker (broker identifier). Broker IDs start from 0 and correspond to the number of broker replicas.
        """
        return pulumi.get(self, "broker")

    @broker.setter
    def broker(self, value: pulumi.Input[int]):
        pulumi.set(self, "broker", value)

    @property
    @pulumi.getter(name="advertisedHost")
    def advertised_host(self) -> Optional[pulumi.Input[str]]:
        """
        The host name which will be used in the brokers' `advertised.brokers`.
        """
        return pulumi.get(self, "advertised_host")

    @advertised_host.setter
    def advertised_host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "advertised_host", value)

    @property
    @pulumi.getter(name="advertisedPort")
    def advertised_port(self) -> Optional[pulumi.Input[int]]:
        """
        The port number which will be used in the brokers' `advertised.brokers`.
        """
        return pulumi.get(self, "advertised_port")

    @advertised_port.setter
    def advertised_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "advertised_port", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations that will be added to the `Ingress` or `Service` resource. You can use this field to configure DNS providers such as External DNS. This field can be used only with `loadbalancer`, `nodeport`, or `ingress` type listeners.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        The broker host. This field will be used in the Ingress resource or in the Route resource to specify the desired hostname. This field can be used only with `route` (optional) or `ingress` (required) type listeners.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="loadBalancerIP")
    def load_balancer_ip(self) -> Optional[pulumi.Input[str]]:
        """
        The loadbalancer is requested with the IP address specified in this field. This feature depends on whether the underlying cloud provider supports specifying the `loadBalancerIP` when a load balancer is created. This field is ignored if the cloud provider does not support the feature.This field can be used only with `loadbalancer` type listener.
        """
        return pulumi.get(self, "load_balancer_ip")

    @load_balancer_ip.setter
    def load_balancer_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "load_balancer_ip", value)

    @property
    @pulumi.getter(name="nodePort")
    def node_port(self) -> Optional[pulumi.Input[int]]:
        """
        Node port for the per-broker service. This field can be used only with `nodeport` type listener.
        """
        return pulumi.get(self, "node_port")

    @node_port.setter
    def node_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "node_port", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersArgs:
    def __init__(__self__, *,
                 ip_block: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersIpBlockArgs']] = None,
                 namespace_selector: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersNamespaceSelectorArgs']] = None,
                 pod_selector: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersPodSelectorArgs']] = None):
        if ip_block is not None:
            pulumi.set(__self__, "ip_block", ip_block)
        if namespace_selector is not None:
            pulumi.set(__self__, "namespace_selector", namespace_selector)
        if pod_selector is not None:
            pulumi.set(__self__, "pod_selector", pod_selector)

    @property
    @pulumi.getter(name="ipBlock")
    def ip_block(self) -> Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersIpBlockArgs']]:
        return pulumi.get(self, "ip_block")

    @ip_block.setter
    def ip_block(self, value: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersIpBlockArgs']]):
        pulumi.set(self, "ip_block", value)

    @property
    @pulumi.getter(name="namespaceSelector")
    def namespace_selector(self) -> Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersNamespaceSelectorArgs']]:
        return pulumi.get(self, "namespace_selector")

    @namespace_selector.setter
    def namespace_selector(self, value: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersNamespaceSelectorArgs']]):
        pulumi.set(self, "namespace_selector", value)

    @property
    @pulumi.getter(name="podSelector")
    def pod_selector(self) -> Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersPodSelectorArgs']]:
        return pulumi.get(self, "pod_selector")

    @pod_selector.setter
    def pod_selector(self, value: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersPodSelectorArgs']]):
        pulumi.set(self, "pod_selector", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersIpBlockArgs:
    def __init__(__self__, *,
                 cidr: Optional[pulumi.Input[str]] = None,
                 except_: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if except_ is not None:
            pulumi.set(__self__, "except_", except_)

    @property
    @pulumi.getter
    def cidr(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cidr")

    @cidr.setter
    def cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cidr", value)

    @property
    @pulumi.getter(name="except")
    def except_(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "except_")

    @except_.setter
    def except_(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "except_", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersNamespaceSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersNamespaceSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersNamespaceSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersNamespaceSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersNamespaceSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersPodSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersPodSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersPodSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersPodSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersPodSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf1Args:
    def __init__(__self__, *,
                 external: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalArgs']] = None,
                 plain: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1PlainArgs']] = None,
                 tls: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1TlsArgs']] = None):
        """
        :param pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalArgs'] external: Configures external listener on port 9094.
        :param pulumi.Input['KafkaSpecKafkaListenersOneOf1PlainArgs'] plain: Configures plain listener on port 9092.
        :param pulumi.Input['KafkaSpecKafkaListenersOneOf1TlsArgs'] tls: Configures TLS listener on port 9093.
        """
        if external is not None:
            pulumi.set(__self__, "external", external)
        if plain is not None:
            pulumi.set(__self__, "plain", plain)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter
    def external(self) -> Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalArgs']]:
        """
        Configures external listener on port 9094.
        """
        return pulumi.get(self, "external")

    @external.setter
    def external(self, value: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalArgs']]):
        pulumi.set(self, "external", value)

    @property
    @pulumi.getter
    def plain(self) -> Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1PlainArgs']]:
        """
        Configures plain listener on port 9092.
        """
        return pulumi.get(self, "plain")

    @plain.setter
    def plain(self, value: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1PlainArgs']]):
        pulumi.set(self, "plain", value)

    @property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1TlsArgs']]:
        """
        Configures TLS listener on port 9093.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1TlsArgs']]):
        pulumi.set(self, "tls", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf1ExternalArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 authentication: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalAuthenticationArgs']] = None,
                 class_: Optional[pulumi.Input[str]] = None,
                 configuration: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalConfigurationArgs']] = None,
                 network_policy_peers: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersArgs']]]] = None,
                 overrides: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalOverridesArgs']] = None,
                 tls: Optional[pulumi.Input[bool]] = None):
        """
        Configures external listener on port 9094.
        :param pulumi.Input[str] type: Type of the external listener. Currently the supported types are `route`, `loadbalancer`, and `nodeport`. 
               
               * `route` type uses OpenShift Routes to expose Kafka.* `loadbalancer` type uses LoadBalancer type services to expose Kafka.* `nodeport` type uses NodePort type services to expose Kafka..
        :param pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalAuthenticationArgs'] authentication: Authentication configuration for Kafka brokers.
        :param pulumi.Input[str] class_: Configures the `Ingress` class that defines which `Ingress` controller will be used. If not set, the `Ingress` class is set to `nginx`.
        :param pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalConfigurationArgs'] configuration: External listener configuration.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersArgs']]] network_policy_peers: List of peers which should be able to connect to this listener. Peers in this list are combined using a logical OR operation. If this field is empty or missing, all connections will be allowed for this listener. If this field is present and contains at least one item, the listener only allows the traffic which matches at least one item in this list.
        :param pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalOverridesArgs'] overrides: Overrides for external bootstrap and broker services and externally advertised addresses.
        :param pulumi.Input[bool] tls: Enables TLS encryption on the listener. By default set to `true` for enabled TLS encryption.
        """
        pulumi.set(__self__, "type", type)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if class_ is not None:
            pulumi.set(__self__, "class_", class_)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if network_policy_peers is not None:
            pulumi.set(__self__, "network_policy_peers", network_policy_peers)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the external listener. Currently the supported types are `route`, `loadbalancer`, and `nodeport`. 

        * `route` type uses OpenShift Routes to expose Kafka.* `loadbalancer` type uses LoadBalancer type services to expose Kafka.* `nodeport` type uses NodePort type services to expose Kafka..
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalAuthenticationArgs']]:
        """
        Authentication configuration for Kafka brokers.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @property
    @pulumi.getter(name="class")
    def class_(self) -> Optional[pulumi.Input[str]]:
        """
        Configures the `Ingress` class that defines which `Ingress` controller will be used. If not set, the `Ingress` class is set to `nginx`.
        """
        return pulumi.get(self, "class_")

    @class_.setter
    def class_(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "class_", value)

    @property
    @pulumi.getter
    def configuration(self) -> Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalConfigurationArgs']]:
        """
        External listener configuration.
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalConfigurationArgs']]):
        pulumi.set(self, "configuration", value)

    @property
    @pulumi.getter(name="networkPolicyPeers")
    def network_policy_peers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersArgs']]]]:
        """
        List of peers which should be able to connect to this listener. Peers in this list are combined using a logical OR operation. If this field is empty or missing, all connections will be allowed for this listener. If this field is present and contains at least one item, the listener only allows the traffic which matches at least one item in this list.
        """
        return pulumi.get(self, "network_policy_peers")

    @network_policy_peers.setter
    def network_policy_peers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersArgs']]]]):
        pulumi.set(self, "network_policy_peers", value)

    @property
    @pulumi.getter
    def overrides(self) -> Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalOverridesArgs']]:
        """
        Overrides for external bootstrap and broker services and externally advertised addresses.
        """
        return pulumi.get(self, "overrides")

    @overrides.setter
    def overrides(self, value: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalOverridesArgs']]):
        pulumi.set(self, "overrides", value)

    @property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables TLS encryption on the listener. By default set to `true` for enabled TLS encryption.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "tls", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf1ExternalAuthenticationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 access_token_is_jwt: Optional[pulumi.Input[bool]] = None,
                 check_access_token_type: Optional[pulumi.Input[bool]] = None,
                 check_issuer: Optional[pulumi.Input[bool]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalAuthenticationClientSecretArgs']] = None,
                 disable_tls_hostname_verification: Optional[pulumi.Input[bool]] = None,
                 enable_ecdsa: Optional[pulumi.Input[bool]] = None,
                 fallback_user_name_claim: Optional[pulumi.Input[str]] = None,
                 fallback_user_name_prefix: Optional[pulumi.Input[str]] = None,
                 introspection_endpoint_uri: Optional[pulumi.Input[str]] = None,
                 jwks_endpoint_uri: Optional[pulumi.Input[str]] = None,
                 jwks_expiry_seconds: Optional[pulumi.Input[int]] = None,
                 jwks_min_refresh_pause_seconds: Optional[pulumi.Input[int]] = None,
                 jwks_refresh_seconds: Optional[pulumi.Input[int]] = None,
                 max_seconds_without_reauthentication: Optional[pulumi.Input[int]] = None,
                 tls_trusted_certificates: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalAuthenticationTlsTrustedCertificatesArgs']]]] = None,
                 user_info_endpoint_uri: Optional[pulumi.Input[str]] = None,
                 user_name_claim: Optional[pulumi.Input[str]] = None,
                 valid_issuer_uri: Optional[pulumi.Input[str]] = None,
                 valid_token_type: Optional[pulumi.Input[str]] = None):
        """
        Authentication configuration for Kafka brokers.
        :param pulumi.Input[str] type: Authentication type. `oauth` type uses SASL OAUTHBEARER Authentication. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `tls` type uses TLS Client Authentication. `tls` type is supported only on TLS listeners.
        :param pulumi.Input[bool] access_token_is_jwt: Configure whether the access token is treated as JWT. This must be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
        :param pulumi.Input[bool] check_access_token_type: Configure whether the access token type check is performed or not. This should be set to `false` if the authorization server does not include 'typ' claim in JWT token. Defaults to `true`.
        :param pulumi.Input[bool] check_issuer: Enable or disable issuer checking. By default issuer is checked using the value configured by `validIssuerUri`. Default value is `true`.
        :param pulumi.Input[str] client_id: OAuth Client ID which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
        :param pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalAuthenticationClientSecretArgs'] client_secret: Link to Kubernetes Secret containing the OAuth client secret which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
        :param pulumi.Input[bool] disable_tls_hostname_verification: Enable or disable TLS hostname verification. Default value is `false`.
        :param pulumi.Input[bool] enable_ecdsa: Enable or disable ECDSA support by installing BouncyCastle crypto provider. Default value is `false`.
        :param pulumi.Input[str] fallback_user_name_claim: The fallback username claim to be used for the user id if the claim specified by `userNameClaim` is not present. This is useful when `client_credentials` authentication only results in the client id being provided in another claim. It only takes effect if `userNameClaim` is set.
        :param pulumi.Input[str] fallback_user_name_prefix: The prefix to use with the value of `fallbackUserNameClaim` to construct the user id. This only takes effect if `fallbackUserNameClaim` is true, and the value is present for the claim. Mapping usernames and client ids into the same user id space is useful in preventing name collisions.
        :param pulumi.Input[str] introspection_endpoint_uri: URI of the token introspection endpoint which can be used to validate opaque non-JWT tokens.
        :param pulumi.Input[str] jwks_endpoint_uri: URI of the JWKS certificate endpoint, which can be used for local JWT validation.
        :param pulumi.Input[int] jwks_expiry_seconds: Configures how often are the JWKS certificates considered valid. The expiry interval has to be at least 60 seconds longer then the refresh interval specified in `jwksRefreshSeconds`. Defaults to 360 seconds.
        :param pulumi.Input[int] jwks_min_refresh_pause_seconds: The minimum pause between two consecutive refreshes. When an unknown signing key is encountered the refresh is scheduled immediately, but will always wait for this minimum pause. Defaults to 1 second.
        :param pulumi.Input[int] jwks_refresh_seconds: Configures how often are the JWKS certificates refreshed. The refresh interval has to be at least 60 seconds shorter then the expiry interval specified in `jwksExpirySeconds`. Defaults to 300 seconds.
        :param pulumi.Input[int] max_seconds_without_reauthentication: Maximum number of seconds the authenticated session remains valid without re-authentication. This enables Apache Kafka re-authentication feature, and causes sessions to expire when the access token expires. If the access token expires before max time or if max time is reached, the client has to re-authenticate, otherwise the server will drop the connection. Not set by default - the authenticated session does not expire when the access token expires.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalAuthenticationTlsTrustedCertificatesArgs']]] tls_trusted_certificates: Trusted certificates for TLS connection to the OAuth server.
        :param pulumi.Input[str] user_info_endpoint_uri: URI of the User Info Endpoint to use as a fallback to obtaining the user id when the Introspection Endpoint does not return information that can be used for the user id. 
        :param pulumi.Input[str] user_name_claim: Name of the claim from the JWT authentication token, Introspection Endpoint response or User Info Endpoint response which will be used to extract the user id. Defaults to `sub`.
        :param pulumi.Input[str] valid_issuer_uri: URI of the token issuer used for authentication.
        :param pulumi.Input[str] valid_token_type: Valid value for the `token_type` attribute returned by the Introspection Endpoint. No default value, and not checked by default.
        """
        pulumi.set(__self__, "type", type)
        if access_token_is_jwt is not None:
            pulumi.set(__self__, "access_token_is_jwt", access_token_is_jwt)
        if check_access_token_type is not None:
            pulumi.set(__self__, "check_access_token_type", check_access_token_type)
        if check_issuer is not None:
            pulumi.set(__self__, "check_issuer", check_issuer)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if disable_tls_hostname_verification is not None:
            pulumi.set(__self__, "disable_tls_hostname_verification", disable_tls_hostname_verification)
        if enable_ecdsa is not None:
            pulumi.set(__self__, "enable_ecdsa", enable_ecdsa)
        if fallback_user_name_claim is not None:
            pulumi.set(__self__, "fallback_user_name_claim", fallback_user_name_claim)
        if fallback_user_name_prefix is not None:
            pulumi.set(__self__, "fallback_user_name_prefix", fallback_user_name_prefix)
        if introspection_endpoint_uri is not None:
            pulumi.set(__self__, "introspection_endpoint_uri", introspection_endpoint_uri)
        if jwks_endpoint_uri is not None:
            pulumi.set(__self__, "jwks_endpoint_uri", jwks_endpoint_uri)
        if jwks_expiry_seconds is not None:
            pulumi.set(__self__, "jwks_expiry_seconds", jwks_expiry_seconds)
        if jwks_min_refresh_pause_seconds is not None:
            pulumi.set(__self__, "jwks_min_refresh_pause_seconds", jwks_min_refresh_pause_seconds)
        if jwks_refresh_seconds is not None:
            pulumi.set(__self__, "jwks_refresh_seconds", jwks_refresh_seconds)
        if max_seconds_without_reauthentication is not None:
            pulumi.set(__self__, "max_seconds_without_reauthentication", max_seconds_without_reauthentication)
        if tls_trusted_certificates is not None:
            pulumi.set(__self__, "tls_trusted_certificates", tls_trusted_certificates)
        if user_info_endpoint_uri is not None:
            pulumi.set(__self__, "user_info_endpoint_uri", user_info_endpoint_uri)
        if user_name_claim is not None:
            pulumi.set(__self__, "user_name_claim", user_name_claim)
        if valid_issuer_uri is not None:
            pulumi.set(__self__, "valid_issuer_uri", valid_issuer_uri)
        if valid_token_type is not None:
            pulumi.set(__self__, "valid_token_type", valid_token_type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Authentication type. `oauth` type uses SASL OAUTHBEARER Authentication. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `tls` type uses TLS Client Authentication. `tls` type is supported only on TLS listeners.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="accessTokenIsJwt")
    def access_token_is_jwt(self) -> Optional[pulumi.Input[bool]]:
        """
        Configure whether the access token is treated as JWT. This must be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
        """
        return pulumi.get(self, "access_token_is_jwt")

    @access_token_is_jwt.setter
    def access_token_is_jwt(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "access_token_is_jwt", value)

    @property
    @pulumi.getter(name="checkAccessTokenType")
    def check_access_token_type(self) -> Optional[pulumi.Input[bool]]:
        """
        Configure whether the access token type check is performed or not. This should be set to `false` if the authorization server does not include 'typ' claim in JWT token. Defaults to `true`.
        """
        return pulumi.get(self, "check_access_token_type")

    @check_access_token_type.setter
    def check_access_token_type(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "check_access_token_type", value)

    @property
    @pulumi.getter(name="checkIssuer")
    def check_issuer(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable or disable issuer checking. By default issuer is checked using the value configured by `validIssuerUri`. Default value is `true`.
        """
        return pulumi.get(self, "check_issuer")

    @check_issuer.setter
    def check_issuer(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "check_issuer", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        OAuth Client ID which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalAuthenticationClientSecretArgs']]:
        """
        Link to Kubernetes Secret containing the OAuth client secret which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalAuthenticationClientSecretArgs']]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="disableTlsHostnameVerification")
    def disable_tls_hostname_verification(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable or disable TLS hostname verification. Default value is `false`.
        """
        return pulumi.get(self, "disable_tls_hostname_verification")

    @disable_tls_hostname_verification.setter
    def disable_tls_hostname_verification(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_tls_hostname_verification", value)

    @property
    @pulumi.getter(name="enableECDSA")
    def enable_ecdsa(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable or disable ECDSA support by installing BouncyCastle crypto provider. Default value is `false`.
        """
        return pulumi.get(self, "enable_ecdsa")

    @enable_ecdsa.setter
    def enable_ecdsa(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_ecdsa", value)

    @property
    @pulumi.getter(name="fallbackUserNameClaim")
    def fallback_user_name_claim(self) -> Optional[pulumi.Input[str]]:
        """
        The fallback username claim to be used for the user id if the claim specified by `userNameClaim` is not present. This is useful when `client_credentials` authentication only results in the client id being provided in another claim. It only takes effect if `userNameClaim` is set.
        """
        return pulumi.get(self, "fallback_user_name_claim")

    @fallback_user_name_claim.setter
    def fallback_user_name_claim(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fallback_user_name_claim", value)

    @property
    @pulumi.getter(name="fallbackUserNamePrefix")
    def fallback_user_name_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The prefix to use with the value of `fallbackUserNameClaim` to construct the user id. This only takes effect if `fallbackUserNameClaim` is true, and the value is present for the claim. Mapping usernames and client ids into the same user id space is useful in preventing name collisions.
        """
        return pulumi.get(self, "fallback_user_name_prefix")

    @fallback_user_name_prefix.setter
    def fallback_user_name_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fallback_user_name_prefix", value)

    @property
    @pulumi.getter(name="introspectionEndpointUri")
    def introspection_endpoint_uri(self) -> Optional[pulumi.Input[str]]:
        """
        URI of the token introspection endpoint which can be used to validate opaque non-JWT tokens.
        """
        return pulumi.get(self, "introspection_endpoint_uri")

    @introspection_endpoint_uri.setter
    def introspection_endpoint_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "introspection_endpoint_uri", value)

    @property
    @pulumi.getter(name="jwksEndpointUri")
    def jwks_endpoint_uri(self) -> Optional[pulumi.Input[str]]:
        """
        URI of the JWKS certificate endpoint, which can be used for local JWT validation.
        """
        return pulumi.get(self, "jwks_endpoint_uri")

    @jwks_endpoint_uri.setter
    def jwks_endpoint_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jwks_endpoint_uri", value)

    @property
    @pulumi.getter(name="jwksExpirySeconds")
    def jwks_expiry_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Configures how often are the JWKS certificates considered valid. The expiry interval has to be at least 60 seconds longer then the refresh interval specified in `jwksRefreshSeconds`. Defaults to 360 seconds.
        """
        return pulumi.get(self, "jwks_expiry_seconds")

    @jwks_expiry_seconds.setter
    def jwks_expiry_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "jwks_expiry_seconds", value)

    @property
    @pulumi.getter(name="jwksMinRefreshPauseSeconds")
    def jwks_min_refresh_pause_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The minimum pause between two consecutive refreshes. When an unknown signing key is encountered the refresh is scheduled immediately, but will always wait for this minimum pause. Defaults to 1 second.
        """
        return pulumi.get(self, "jwks_min_refresh_pause_seconds")

    @jwks_min_refresh_pause_seconds.setter
    def jwks_min_refresh_pause_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "jwks_min_refresh_pause_seconds", value)

    @property
    @pulumi.getter(name="jwksRefreshSeconds")
    def jwks_refresh_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Configures how often are the JWKS certificates refreshed. The refresh interval has to be at least 60 seconds shorter then the expiry interval specified in `jwksExpirySeconds`. Defaults to 300 seconds.
        """
        return pulumi.get(self, "jwks_refresh_seconds")

    @jwks_refresh_seconds.setter
    def jwks_refresh_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "jwks_refresh_seconds", value)

    @property
    @pulumi.getter(name="maxSecondsWithoutReauthentication")
    def max_seconds_without_reauthentication(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of seconds the authenticated session remains valid without re-authentication. This enables Apache Kafka re-authentication feature, and causes sessions to expire when the access token expires. If the access token expires before max time or if max time is reached, the client has to re-authenticate, otherwise the server will drop the connection. Not set by default - the authenticated session does not expire when the access token expires.
        """
        return pulumi.get(self, "max_seconds_without_reauthentication")

    @max_seconds_without_reauthentication.setter
    def max_seconds_without_reauthentication(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_seconds_without_reauthentication", value)

    @property
    @pulumi.getter(name="tlsTrustedCertificates")
    def tls_trusted_certificates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalAuthenticationTlsTrustedCertificatesArgs']]]]:
        """
        Trusted certificates for TLS connection to the OAuth server.
        """
        return pulumi.get(self, "tls_trusted_certificates")

    @tls_trusted_certificates.setter
    def tls_trusted_certificates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalAuthenticationTlsTrustedCertificatesArgs']]]]):
        pulumi.set(self, "tls_trusted_certificates", value)

    @property
    @pulumi.getter(name="userInfoEndpointUri")
    def user_info_endpoint_uri(self) -> Optional[pulumi.Input[str]]:
        """
        URI of the User Info Endpoint to use as a fallback to obtaining the user id when the Introspection Endpoint does not return information that can be used for the user id. 
        """
        return pulumi.get(self, "user_info_endpoint_uri")

    @user_info_endpoint_uri.setter
    def user_info_endpoint_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_info_endpoint_uri", value)

    @property
    @pulumi.getter(name="userNameClaim")
    def user_name_claim(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the claim from the JWT authentication token, Introspection Endpoint response or User Info Endpoint response which will be used to extract the user id. Defaults to `sub`.
        """
        return pulumi.get(self, "user_name_claim")

    @user_name_claim.setter
    def user_name_claim(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_name_claim", value)

    @property
    @pulumi.getter(name="validIssuerUri")
    def valid_issuer_uri(self) -> Optional[pulumi.Input[str]]:
        """
        URI of the token issuer used for authentication.
        """
        return pulumi.get(self, "valid_issuer_uri")

    @valid_issuer_uri.setter
    def valid_issuer_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "valid_issuer_uri", value)

    @property
    @pulumi.getter(name="validTokenType")
    def valid_token_type(self) -> Optional[pulumi.Input[str]]:
        """
        Valid value for the `token_type` attribute returned by the Introspection Endpoint. No default value, and not checked by default.
        """
        return pulumi.get(self, "valid_token_type")

    @valid_token_type.setter
    def valid_token_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "valid_token_type", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf1ExternalAuthenticationClientSecretArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        Link to Kubernetes Secret containing the OAuth client secret which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
        :param pulumi.Input[str] key: The key under which the secret value is stored in the Kubernetes Secret.
        :param pulumi.Input[str] secret_name: The name of the Kubernetes Secret containing the secret value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key under which the secret value is stored in the Kubernetes Secret.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        The name of the Kubernetes Secret containing the secret value.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf1ExternalAuthenticationTlsTrustedCertificatesArgs:
    def __init__(__self__, *,
                 certificate: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] certificate: The name of the file certificate in the Secret.
        :param pulumi.Input[str] secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> pulumi.Input[str]:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf1ExternalConfigurationArgs:
    def __init__(__self__, *,
                 bootstrap: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalConfigurationBootstrapArgs']] = None,
                 broker_cert_chain_and_key: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalConfigurationBrokerCertChainAndKeyArgs']] = None,
                 brokers: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalConfigurationBrokersArgs']]]] = None):
        """
        External listener configuration.
        :param pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalConfigurationBootstrapArgs'] bootstrap: External bootstrap ingress configuration.
        :param pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalConfigurationBrokerCertChainAndKeyArgs'] broker_cert_chain_and_key: Reference to the `Secret` which holds the certificate and private key pair. The certificate can optionally contain the whole chain.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalConfigurationBrokersArgs']]] brokers: External broker ingress configuration.
        """
        if bootstrap is not None:
            pulumi.set(__self__, "bootstrap", bootstrap)
        if broker_cert_chain_and_key is not None:
            pulumi.set(__self__, "broker_cert_chain_and_key", broker_cert_chain_and_key)
        if brokers is not None:
            pulumi.set(__self__, "brokers", brokers)

    @property
    @pulumi.getter
    def bootstrap(self) -> Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalConfigurationBootstrapArgs']]:
        """
        External bootstrap ingress configuration.
        """
        return pulumi.get(self, "bootstrap")

    @bootstrap.setter
    def bootstrap(self, value: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalConfigurationBootstrapArgs']]):
        pulumi.set(self, "bootstrap", value)

    @property
    @pulumi.getter(name="brokerCertChainAndKey")
    def broker_cert_chain_and_key(self) -> Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalConfigurationBrokerCertChainAndKeyArgs']]:
        """
        Reference to the `Secret` which holds the certificate and private key pair. The certificate can optionally contain the whole chain.
        """
        return pulumi.get(self, "broker_cert_chain_and_key")

    @broker_cert_chain_and_key.setter
    def broker_cert_chain_and_key(self, value: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalConfigurationBrokerCertChainAndKeyArgs']]):
        pulumi.set(self, "broker_cert_chain_and_key", value)

    @property
    @pulumi.getter
    def brokers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalConfigurationBrokersArgs']]]]:
        """
        External broker ingress configuration.
        """
        return pulumi.get(self, "brokers")

    @brokers.setter
    def brokers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalConfigurationBrokersArgs']]]]):
        pulumi.set(self, "brokers", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf1ExternalConfigurationBootstrapArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[str],
                 address: Optional[pulumi.Input[str]] = None,
                 dns_annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        External bootstrap ingress configuration.
        :param pulumi.Input[str] host: Host for the bootstrap route. This field will be used in the Ingress resource.
        :param pulumi.Input[str] address: Additional address name for the bootstrap service. The address will be added to the list of subject alternative names of the TLS certificates.
        :param pulumi.Input[Mapping[str, Any]] dns_annotations: Annotations that will be added to the `Ingress` resource. You can use this field to configure DNS providers such as External DNS.
        """
        pulumi.set(__self__, "host", host)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if dns_annotations is not None:
            pulumi.set(__self__, "dns_annotations", dns_annotations)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        Host for the bootstrap route. This field will be used in the Ingress resource.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        """
        Additional address name for the bootstrap service. The address will be added to the list of subject alternative names of the TLS certificates.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter(name="dnsAnnotations")
    def dns_annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations that will be added to the `Ingress` resource. You can use this field to configure DNS providers such as External DNS.
        """
        return pulumi.get(self, "dns_annotations")

    @dns_annotations.setter
    def dns_annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "dns_annotations", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf1ExternalConfigurationBrokerCertChainAndKeyArgs:
    def __init__(__self__, *,
                 certificate: pulumi.Input[str],
                 key: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        Reference to the `Secret` which holds the certificate and private key pair. The certificate can optionally contain the whole chain.
        :param pulumi.Input[str] certificate: The name of the file certificate in the Secret.
        :param pulumi.Input[str] key: The name of the private key in the Secret.
        :param pulumi.Input[str] secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> pulumi.Input[str]:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The name of the private key in the Secret.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf1ExternalConfigurationBrokersArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[str],
                 advertised_host: Optional[pulumi.Input[str]] = None,
                 advertised_port: Optional[pulumi.Input[int]] = None,
                 broker: Optional[pulumi.Input[int]] = None,
                 dns_annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        :param pulumi.Input[str] host: Host for the broker ingress. This field will be used in the Ingress resource.
        :param pulumi.Input[str] advertised_host: The host name which will be used in the brokers' `advertised.brokers`.
        :param pulumi.Input[int] advertised_port: The port number which will be used in the brokers' `advertised.brokers`.
        :param pulumi.Input[int] broker: Id of the kafka broker (broker identifier).
        :param pulumi.Input[Mapping[str, Any]] dns_annotations: Annotations that will be added to the `Ingress` resources for individual brokers. You can use this field to configure DNS providers such as External DNS.
        """
        pulumi.set(__self__, "host", host)
        if advertised_host is not None:
            pulumi.set(__self__, "advertised_host", advertised_host)
        if advertised_port is not None:
            pulumi.set(__self__, "advertised_port", advertised_port)
        if broker is not None:
            pulumi.set(__self__, "broker", broker)
        if dns_annotations is not None:
            pulumi.set(__self__, "dns_annotations", dns_annotations)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        Host for the broker ingress. This field will be used in the Ingress resource.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="advertisedHost")
    def advertised_host(self) -> Optional[pulumi.Input[str]]:
        """
        The host name which will be used in the brokers' `advertised.brokers`.
        """
        return pulumi.get(self, "advertised_host")

    @advertised_host.setter
    def advertised_host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "advertised_host", value)

    @property
    @pulumi.getter(name="advertisedPort")
    def advertised_port(self) -> Optional[pulumi.Input[int]]:
        """
        The port number which will be used in the brokers' `advertised.brokers`.
        """
        return pulumi.get(self, "advertised_port")

    @advertised_port.setter
    def advertised_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "advertised_port", value)

    @property
    @pulumi.getter
    def broker(self) -> Optional[pulumi.Input[int]]:
        """
        Id of the kafka broker (broker identifier).
        """
        return pulumi.get(self, "broker")

    @broker.setter
    def broker(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "broker", value)

    @property
    @pulumi.getter(name="dnsAnnotations")
    def dns_annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations that will be added to the `Ingress` resources for individual brokers. You can use this field to configure DNS providers such as External DNS.
        """
        return pulumi.get(self, "dns_annotations")

    @dns_annotations.setter
    def dns_annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "dns_annotations", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersArgs:
    def __init__(__self__, *,
                 ip_block: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersIpBlockArgs']] = None,
                 namespace_selector: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersNamespaceSelectorArgs']] = None,
                 pod_selector: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersPodSelectorArgs']] = None):
        if ip_block is not None:
            pulumi.set(__self__, "ip_block", ip_block)
        if namespace_selector is not None:
            pulumi.set(__self__, "namespace_selector", namespace_selector)
        if pod_selector is not None:
            pulumi.set(__self__, "pod_selector", pod_selector)

    @property
    @pulumi.getter(name="ipBlock")
    def ip_block(self) -> Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersIpBlockArgs']]:
        return pulumi.get(self, "ip_block")

    @ip_block.setter
    def ip_block(self, value: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersIpBlockArgs']]):
        pulumi.set(self, "ip_block", value)

    @property
    @pulumi.getter(name="namespaceSelector")
    def namespace_selector(self) -> Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersNamespaceSelectorArgs']]:
        return pulumi.get(self, "namespace_selector")

    @namespace_selector.setter
    def namespace_selector(self, value: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersNamespaceSelectorArgs']]):
        pulumi.set(self, "namespace_selector", value)

    @property
    @pulumi.getter(name="podSelector")
    def pod_selector(self) -> Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersPodSelectorArgs']]:
        return pulumi.get(self, "pod_selector")

    @pod_selector.setter
    def pod_selector(self, value: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersPodSelectorArgs']]):
        pulumi.set(self, "pod_selector", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersIpBlockArgs:
    def __init__(__self__, *,
                 cidr: Optional[pulumi.Input[str]] = None,
                 except_: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if except_ is not None:
            pulumi.set(__self__, "except_", except_)

    @property
    @pulumi.getter
    def cidr(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cidr")

    @cidr.setter
    def cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cidr", value)

    @property
    @pulumi.getter(name="except")
    def except_(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "except_")

    @except_.setter
    def except_(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "except_", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersNamespaceSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersNamespaceSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersNamespaceSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersNamespaceSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersNamespaceSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersPodSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersPodSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersPodSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersPodSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersPodSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf1ExternalOverridesArgs:
    def __init__(__self__, *,
                 bootstrap: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalOverridesBootstrapArgs']] = None,
                 brokers: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalOverridesBrokersArgs']]]] = None):
        """
        Overrides for external bootstrap and broker services and externally advertised addresses.
        :param pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalOverridesBootstrapArgs'] bootstrap: External bootstrap service configuration.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalOverridesBrokersArgs']]] brokers: External broker services configuration.
        """
        if bootstrap is not None:
            pulumi.set(__self__, "bootstrap", bootstrap)
        if brokers is not None:
            pulumi.set(__self__, "brokers", brokers)

    @property
    @pulumi.getter
    def bootstrap(self) -> Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalOverridesBootstrapArgs']]:
        """
        External bootstrap service configuration.
        """
        return pulumi.get(self, "bootstrap")

    @bootstrap.setter
    def bootstrap(self, value: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalOverridesBootstrapArgs']]):
        pulumi.set(self, "bootstrap", value)

    @property
    @pulumi.getter
    def brokers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalOverridesBrokersArgs']]]]:
        """
        External broker services configuration.
        """
        return pulumi.get(self, "brokers")

    @brokers.setter
    def brokers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1ExternalOverridesBrokersArgs']]]]):
        pulumi.set(self, "brokers", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf1ExternalOverridesBootstrapArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[str]] = None,
                 dns_annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 node_port: Optional[pulumi.Input[int]] = None):
        """
        External bootstrap service configuration.
        :param pulumi.Input[str] address: Additional address name for the bootstrap service. The address will be added to the list of subject alternative names of the TLS certificates.
        :param pulumi.Input[Mapping[str, Any]] dns_annotations: Annotations that will be added to the `Service` resource. You can use this field to configure DNS providers such as External DNS.
        :param pulumi.Input[int] node_port: Node port for the bootstrap service.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if dns_annotations is not None:
            pulumi.set(__self__, "dns_annotations", dns_annotations)
        if node_port is not None:
            pulumi.set(__self__, "node_port", node_port)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        """
        Additional address name for the bootstrap service. The address will be added to the list of subject alternative names of the TLS certificates.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter(name="dnsAnnotations")
    def dns_annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations that will be added to the `Service` resource. You can use this field to configure DNS providers such as External DNS.
        """
        return pulumi.get(self, "dns_annotations")

    @dns_annotations.setter
    def dns_annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "dns_annotations", value)

    @property
    @pulumi.getter(name="nodePort")
    def node_port(self) -> Optional[pulumi.Input[int]]:
        """
        Node port for the bootstrap service.
        """
        return pulumi.get(self, "node_port")

    @node_port.setter
    def node_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "node_port", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf1ExternalOverridesBrokersArgs:
    def __init__(__self__, *,
                 advertised_host: Optional[pulumi.Input[str]] = None,
                 advertised_port: Optional[pulumi.Input[int]] = None,
                 broker: Optional[pulumi.Input[int]] = None,
                 dns_annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 node_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] advertised_host: The host name which will be used in the brokers' `advertised.brokers`.
        :param pulumi.Input[int] advertised_port: The port number which will be used in the brokers' `advertised.brokers`.
        :param pulumi.Input[int] broker: Id of the kafka broker (broker identifier).
        :param pulumi.Input[Mapping[str, Any]] dns_annotations: Annotations that will be added to the `Service` resources for individual brokers. You can use this field to configure DNS providers such as External DNS.
        :param pulumi.Input[int] node_port: Node port for the broker service.
        """
        if advertised_host is not None:
            pulumi.set(__self__, "advertised_host", advertised_host)
        if advertised_port is not None:
            pulumi.set(__self__, "advertised_port", advertised_port)
        if broker is not None:
            pulumi.set(__self__, "broker", broker)
        if dns_annotations is not None:
            pulumi.set(__self__, "dns_annotations", dns_annotations)
        if node_port is not None:
            pulumi.set(__self__, "node_port", node_port)

    @property
    @pulumi.getter(name="advertisedHost")
    def advertised_host(self) -> Optional[pulumi.Input[str]]:
        """
        The host name which will be used in the brokers' `advertised.brokers`.
        """
        return pulumi.get(self, "advertised_host")

    @advertised_host.setter
    def advertised_host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "advertised_host", value)

    @property
    @pulumi.getter(name="advertisedPort")
    def advertised_port(self) -> Optional[pulumi.Input[int]]:
        """
        The port number which will be used in the brokers' `advertised.brokers`.
        """
        return pulumi.get(self, "advertised_port")

    @advertised_port.setter
    def advertised_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "advertised_port", value)

    @property
    @pulumi.getter
    def broker(self) -> Optional[pulumi.Input[int]]:
        """
        Id of the kafka broker (broker identifier).
        """
        return pulumi.get(self, "broker")

    @broker.setter
    def broker(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "broker", value)

    @property
    @pulumi.getter(name="dnsAnnotations")
    def dns_annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations that will be added to the `Service` resources for individual brokers. You can use this field to configure DNS providers such as External DNS.
        """
        return pulumi.get(self, "dns_annotations")

    @dns_annotations.setter
    def dns_annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "dns_annotations", value)

    @property
    @pulumi.getter(name="nodePort")
    def node_port(self) -> Optional[pulumi.Input[int]]:
        """
        Node port for the broker service.
        """
        return pulumi.get(self, "node_port")

    @node_port.setter
    def node_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "node_port", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf1PlainArgs:
    def __init__(__self__, *,
                 authentication: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1PlainAuthenticationArgs']] = None,
                 network_policy_peers: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersArgs']]]] = None):
        """
        Configures plain listener on port 9092.
        :param pulumi.Input['KafkaSpecKafkaListenersOneOf1PlainAuthenticationArgs'] authentication: Authentication configuration for this listener. Since this listener does not use TLS transport you cannot configure an authentication with `type: tls`.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersArgs']]] network_policy_peers: List of peers which should be able to connect to this listener. Peers in this list are combined using a logical OR operation. If this field is empty or missing, all connections will be allowed for this listener. If this field is present and contains at least one item, the listener only allows the traffic which matches at least one item in this list.
        """
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if network_policy_peers is not None:
            pulumi.set(__self__, "network_policy_peers", network_policy_peers)

    @property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1PlainAuthenticationArgs']]:
        """
        Authentication configuration for this listener. Since this listener does not use TLS transport you cannot configure an authentication with `type: tls`.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1PlainAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @property
    @pulumi.getter(name="networkPolicyPeers")
    def network_policy_peers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersArgs']]]]:
        """
        List of peers which should be able to connect to this listener. Peers in this list are combined using a logical OR operation. If this field is empty or missing, all connections will be allowed for this listener. If this field is present and contains at least one item, the listener only allows the traffic which matches at least one item in this list.
        """
        return pulumi.get(self, "network_policy_peers")

    @network_policy_peers.setter
    def network_policy_peers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersArgs']]]]):
        pulumi.set(self, "network_policy_peers", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf1PlainAuthenticationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 access_token_is_jwt: Optional[pulumi.Input[bool]] = None,
                 check_access_token_type: Optional[pulumi.Input[bool]] = None,
                 check_issuer: Optional[pulumi.Input[bool]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1PlainAuthenticationClientSecretArgs']] = None,
                 disable_tls_hostname_verification: Optional[pulumi.Input[bool]] = None,
                 enable_ecdsa: Optional[pulumi.Input[bool]] = None,
                 fallback_user_name_claim: Optional[pulumi.Input[str]] = None,
                 fallback_user_name_prefix: Optional[pulumi.Input[str]] = None,
                 introspection_endpoint_uri: Optional[pulumi.Input[str]] = None,
                 jwks_endpoint_uri: Optional[pulumi.Input[str]] = None,
                 jwks_expiry_seconds: Optional[pulumi.Input[int]] = None,
                 jwks_min_refresh_pause_seconds: Optional[pulumi.Input[int]] = None,
                 jwks_refresh_seconds: Optional[pulumi.Input[int]] = None,
                 max_seconds_without_reauthentication: Optional[pulumi.Input[int]] = None,
                 tls_trusted_certificates: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1PlainAuthenticationTlsTrustedCertificatesArgs']]]] = None,
                 user_info_endpoint_uri: Optional[pulumi.Input[str]] = None,
                 user_name_claim: Optional[pulumi.Input[str]] = None,
                 valid_issuer_uri: Optional[pulumi.Input[str]] = None,
                 valid_token_type: Optional[pulumi.Input[str]] = None):
        """
        Authentication configuration for this listener. Since this listener does not use TLS transport you cannot configure an authentication with `type: tls`.
        :param pulumi.Input[str] type: Authentication type. `oauth` type uses SASL OAUTHBEARER Authentication. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `tls` type uses TLS Client Authentication. `tls` type is supported only on TLS listeners.
        :param pulumi.Input[bool] access_token_is_jwt: Configure whether the access token is treated as JWT. This must be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
        :param pulumi.Input[bool] check_access_token_type: Configure whether the access token type check is performed or not. This should be set to `false` if the authorization server does not include 'typ' claim in JWT token. Defaults to `true`.
        :param pulumi.Input[bool] check_issuer: Enable or disable issuer checking. By default issuer is checked using the value configured by `validIssuerUri`. Default value is `true`.
        :param pulumi.Input[str] client_id: OAuth Client ID which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
        :param pulumi.Input['KafkaSpecKafkaListenersOneOf1PlainAuthenticationClientSecretArgs'] client_secret: Link to Kubernetes Secret containing the OAuth client secret which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
        :param pulumi.Input[bool] disable_tls_hostname_verification: Enable or disable TLS hostname verification. Default value is `false`.
        :param pulumi.Input[bool] enable_ecdsa: Enable or disable ECDSA support by installing BouncyCastle crypto provider. Default value is `false`.
        :param pulumi.Input[str] fallback_user_name_claim: The fallback username claim to be used for the user id if the claim specified by `userNameClaim` is not present. This is useful when `client_credentials` authentication only results in the client id being provided in another claim. It only takes effect if `userNameClaim` is set.
        :param pulumi.Input[str] fallback_user_name_prefix: The prefix to use with the value of `fallbackUserNameClaim` to construct the user id. This only takes effect if `fallbackUserNameClaim` is true, and the value is present for the claim. Mapping usernames and client ids into the same user id space is useful in preventing name collisions.
        :param pulumi.Input[str] introspection_endpoint_uri: URI of the token introspection endpoint which can be used to validate opaque non-JWT tokens.
        :param pulumi.Input[str] jwks_endpoint_uri: URI of the JWKS certificate endpoint, which can be used for local JWT validation.
        :param pulumi.Input[int] jwks_expiry_seconds: Configures how often are the JWKS certificates considered valid. The expiry interval has to be at least 60 seconds longer then the refresh interval specified in `jwksRefreshSeconds`. Defaults to 360 seconds.
        :param pulumi.Input[int] jwks_min_refresh_pause_seconds: The minimum pause between two consecutive refreshes. When an unknown signing key is encountered the refresh is scheduled immediately, but will always wait for this minimum pause. Defaults to 1 second.
        :param pulumi.Input[int] jwks_refresh_seconds: Configures how often are the JWKS certificates refreshed. The refresh interval has to be at least 60 seconds shorter then the expiry interval specified in `jwksExpirySeconds`. Defaults to 300 seconds.
        :param pulumi.Input[int] max_seconds_without_reauthentication: Maximum number of seconds the authenticated session remains valid without re-authentication. This enables Apache Kafka re-authentication feature, and causes sessions to expire when the access token expires. If the access token expires before max time or if max time is reached, the client has to re-authenticate, otherwise the server will drop the connection. Not set by default - the authenticated session does not expire when the access token expires.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1PlainAuthenticationTlsTrustedCertificatesArgs']]] tls_trusted_certificates: Trusted certificates for TLS connection to the OAuth server.
        :param pulumi.Input[str] user_info_endpoint_uri: URI of the User Info Endpoint to use as a fallback to obtaining the user id when the Introspection Endpoint does not return information that can be used for the user id. 
        :param pulumi.Input[str] user_name_claim: Name of the claim from the JWT authentication token, Introspection Endpoint response or User Info Endpoint response which will be used to extract the user id. Defaults to `sub`.
        :param pulumi.Input[str] valid_issuer_uri: URI of the token issuer used for authentication.
        :param pulumi.Input[str] valid_token_type: Valid value for the `token_type` attribute returned by the Introspection Endpoint. No default value, and not checked by default.
        """
        pulumi.set(__self__, "type", type)
        if access_token_is_jwt is not None:
            pulumi.set(__self__, "access_token_is_jwt", access_token_is_jwt)
        if check_access_token_type is not None:
            pulumi.set(__self__, "check_access_token_type", check_access_token_type)
        if check_issuer is not None:
            pulumi.set(__self__, "check_issuer", check_issuer)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if disable_tls_hostname_verification is not None:
            pulumi.set(__self__, "disable_tls_hostname_verification", disable_tls_hostname_verification)
        if enable_ecdsa is not None:
            pulumi.set(__self__, "enable_ecdsa", enable_ecdsa)
        if fallback_user_name_claim is not None:
            pulumi.set(__self__, "fallback_user_name_claim", fallback_user_name_claim)
        if fallback_user_name_prefix is not None:
            pulumi.set(__self__, "fallback_user_name_prefix", fallback_user_name_prefix)
        if introspection_endpoint_uri is not None:
            pulumi.set(__self__, "introspection_endpoint_uri", introspection_endpoint_uri)
        if jwks_endpoint_uri is not None:
            pulumi.set(__self__, "jwks_endpoint_uri", jwks_endpoint_uri)
        if jwks_expiry_seconds is not None:
            pulumi.set(__self__, "jwks_expiry_seconds", jwks_expiry_seconds)
        if jwks_min_refresh_pause_seconds is not None:
            pulumi.set(__self__, "jwks_min_refresh_pause_seconds", jwks_min_refresh_pause_seconds)
        if jwks_refresh_seconds is not None:
            pulumi.set(__self__, "jwks_refresh_seconds", jwks_refresh_seconds)
        if max_seconds_without_reauthentication is not None:
            pulumi.set(__self__, "max_seconds_without_reauthentication", max_seconds_without_reauthentication)
        if tls_trusted_certificates is not None:
            pulumi.set(__self__, "tls_trusted_certificates", tls_trusted_certificates)
        if user_info_endpoint_uri is not None:
            pulumi.set(__self__, "user_info_endpoint_uri", user_info_endpoint_uri)
        if user_name_claim is not None:
            pulumi.set(__self__, "user_name_claim", user_name_claim)
        if valid_issuer_uri is not None:
            pulumi.set(__self__, "valid_issuer_uri", valid_issuer_uri)
        if valid_token_type is not None:
            pulumi.set(__self__, "valid_token_type", valid_token_type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Authentication type. `oauth` type uses SASL OAUTHBEARER Authentication. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `tls` type uses TLS Client Authentication. `tls` type is supported only on TLS listeners.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="accessTokenIsJwt")
    def access_token_is_jwt(self) -> Optional[pulumi.Input[bool]]:
        """
        Configure whether the access token is treated as JWT. This must be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
        """
        return pulumi.get(self, "access_token_is_jwt")

    @access_token_is_jwt.setter
    def access_token_is_jwt(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "access_token_is_jwt", value)

    @property
    @pulumi.getter(name="checkAccessTokenType")
    def check_access_token_type(self) -> Optional[pulumi.Input[bool]]:
        """
        Configure whether the access token type check is performed or not. This should be set to `false` if the authorization server does not include 'typ' claim in JWT token. Defaults to `true`.
        """
        return pulumi.get(self, "check_access_token_type")

    @check_access_token_type.setter
    def check_access_token_type(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "check_access_token_type", value)

    @property
    @pulumi.getter(name="checkIssuer")
    def check_issuer(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable or disable issuer checking. By default issuer is checked using the value configured by `validIssuerUri`. Default value is `true`.
        """
        return pulumi.get(self, "check_issuer")

    @check_issuer.setter
    def check_issuer(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "check_issuer", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        OAuth Client ID which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1PlainAuthenticationClientSecretArgs']]:
        """
        Link to Kubernetes Secret containing the OAuth client secret which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1PlainAuthenticationClientSecretArgs']]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="disableTlsHostnameVerification")
    def disable_tls_hostname_verification(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable or disable TLS hostname verification. Default value is `false`.
        """
        return pulumi.get(self, "disable_tls_hostname_verification")

    @disable_tls_hostname_verification.setter
    def disable_tls_hostname_verification(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_tls_hostname_verification", value)

    @property
    @pulumi.getter(name="enableECDSA")
    def enable_ecdsa(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable or disable ECDSA support by installing BouncyCastle crypto provider. Default value is `false`.
        """
        return pulumi.get(self, "enable_ecdsa")

    @enable_ecdsa.setter
    def enable_ecdsa(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_ecdsa", value)

    @property
    @pulumi.getter(name="fallbackUserNameClaim")
    def fallback_user_name_claim(self) -> Optional[pulumi.Input[str]]:
        """
        The fallback username claim to be used for the user id if the claim specified by `userNameClaim` is not present. This is useful when `client_credentials` authentication only results in the client id being provided in another claim. It only takes effect if `userNameClaim` is set.
        """
        return pulumi.get(self, "fallback_user_name_claim")

    @fallback_user_name_claim.setter
    def fallback_user_name_claim(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fallback_user_name_claim", value)

    @property
    @pulumi.getter(name="fallbackUserNamePrefix")
    def fallback_user_name_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The prefix to use with the value of `fallbackUserNameClaim` to construct the user id. This only takes effect if `fallbackUserNameClaim` is true, and the value is present for the claim. Mapping usernames and client ids into the same user id space is useful in preventing name collisions.
        """
        return pulumi.get(self, "fallback_user_name_prefix")

    @fallback_user_name_prefix.setter
    def fallback_user_name_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fallback_user_name_prefix", value)

    @property
    @pulumi.getter(name="introspectionEndpointUri")
    def introspection_endpoint_uri(self) -> Optional[pulumi.Input[str]]:
        """
        URI of the token introspection endpoint which can be used to validate opaque non-JWT tokens.
        """
        return pulumi.get(self, "introspection_endpoint_uri")

    @introspection_endpoint_uri.setter
    def introspection_endpoint_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "introspection_endpoint_uri", value)

    @property
    @pulumi.getter(name="jwksEndpointUri")
    def jwks_endpoint_uri(self) -> Optional[pulumi.Input[str]]:
        """
        URI of the JWKS certificate endpoint, which can be used for local JWT validation.
        """
        return pulumi.get(self, "jwks_endpoint_uri")

    @jwks_endpoint_uri.setter
    def jwks_endpoint_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jwks_endpoint_uri", value)

    @property
    @pulumi.getter(name="jwksExpirySeconds")
    def jwks_expiry_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Configures how often are the JWKS certificates considered valid. The expiry interval has to be at least 60 seconds longer then the refresh interval specified in `jwksRefreshSeconds`. Defaults to 360 seconds.
        """
        return pulumi.get(self, "jwks_expiry_seconds")

    @jwks_expiry_seconds.setter
    def jwks_expiry_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "jwks_expiry_seconds", value)

    @property
    @pulumi.getter(name="jwksMinRefreshPauseSeconds")
    def jwks_min_refresh_pause_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The minimum pause between two consecutive refreshes. When an unknown signing key is encountered the refresh is scheduled immediately, but will always wait for this minimum pause. Defaults to 1 second.
        """
        return pulumi.get(self, "jwks_min_refresh_pause_seconds")

    @jwks_min_refresh_pause_seconds.setter
    def jwks_min_refresh_pause_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "jwks_min_refresh_pause_seconds", value)

    @property
    @pulumi.getter(name="jwksRefreshSeconds")
    def jwks_refresh_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Configures how often are the JWKS certificates refreshed. The refresh interval has to be at least 60 seconds shorter then the expiry interval specified in `jwksExpirySeconds`. Defaults to 300 seconds.
        """
        return pulumi.get(self, "jwks_refresh_seconds")

    @jwks_refresh_seconds.setter
    def jwks_refresh_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "jwks_refresh_seconds", value)

    @property
    @pulumi.getter(name="maxSecondsWithoutReauthentication")
    def max_seconds_without_reauthentication(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of seconds the authenticated session remains valid without re-authentication. This enables Apache Kafka re-authentication feature, and causes sessions to expire when the access token expires. If the access token expires before max time or if max time is reached, the client has to re-authenticate, otherwise the server will drop the connection. Not set by default - the authenticated session does not expire when the access token expires.
        """
        return pulumi.get(self, "max_seconds_without_reauthentication")

    @max_seconds_without_reauthentication.setter
    def max_seconds_without_reauthentication(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_seconds_without_reauthentication", value)

    @property
    @pulumi.getter(name="tlsTrustedCertificates")
    def tls_trusted_certificates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1PlainAuthenticationTlsTrustedCertificatesArgs']]]]:
        """
        Trusted certificates for TLS connection to the OAuth server.
        """
        return pulumi.get(self, "tls_trusted_certificates")

    @tls_trusted_certificates.setter
    def tls_trusted_certificates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1PlainAuthenticationTlsTrustedCertificatesArgs']]]]):
        pulumi.set(self, "tls_trusted_certificates", value)

    @property
    @pulumi.getter(name="userInfoEndpointUri")
    def user_info_endpoint_uri(self) -> Optional[pulumi.Input[str]]:
        """
        URI of the User Info Endpoint to use as a fallback to obtaining the user id when the Introspection Endpoint does not return information that can be used for the user id. 
        """
        return pulumi.get(self, "user_info_endpoint_uri")

    @user_info_endpoint_uri.setter
    def user_info_endpoint_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_info_endpoint_uri", value)

    @property
    @pulumi.getter(name="userNameClaim")
    def user_name_claim(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the claim from the JWT authentication token, Introspection Endpoint response or User Info Endpoint response which will be used to extract the user id. Defaults to `sub`.
        """
        return pulumi.get(self, "user_name_claim")

    @user_name_claim.setter
    def user_name_claim(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_name_claim", value)

    @property
    @pulumi.getter(name="validIssuerUri")
    def valid_issuer_uri(self) -> Optional[pulumi.Input[str]]:
        """
        URI of the token issuer used for authentication.
        """
        return pulumi.get(self, "valid_issuer_uri")

    @valid_issuer_uri.setter
    def valid_issuer_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "valid_issuer_uri", value)

    @property
    @pulumi.getter(name="validTokenType")
    def valid_token_type(self) -> Optional[pulumi.Input[str]]:
        """
        Valid value for the `token_type` attribute returned by the Introspection Endpoint. No default value, and not checked by default.
        """
        return pulumi.get(self, "valid_token_type")

    @valid_token_type.setter
    def valid_token_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "valid_token_type", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf1PlainAuthenticationClientSecretArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        Link to Kubernetes Secret containing the OAuth client secret which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
        :param pulumi.Input[str] key: The key under which the secret value is stored in the Kubernetes Secret.
        :param pulumi.Input[str] secret_name: The name of the Kubernetes Secret containing the secret value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key under which the secret value is stored in the Kubernetes Secret.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        The name of the Kubernetes Secret containing the secret value.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf1PlainAuthenticationTlsTrustedCertificatesArgs:
    def __init__(__self__, *,
                 certificate: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] certificate: The name of the file certificate in the Secret.
        :param pulumi.Input[str] secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> pulumi.Input[str]:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersArgs:
    def __init__(__self__, *,
                 ip_block: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersIpBlockArgs']] = None,
                 namespace_selector: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersNamespaceSelectorArgs']] = None,
                 pod_selector: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersPodSelectorArgs']] = None):
        if ip_block is not None:
            pulumi.set(__self__, "ip_block", ip_block)
        if namespace_selector is not None:
            pulumi.set(__self__, "namespace_selector", namespace_selector)
        if pod_selector is not None:
            pulumi.set(__self__, "pod_selector", pod_selector)

    @property
    @pulumi.getter(name="ipBlock")
    def ip_block(self) -> Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersIpBlockArgs']]:
        return pulumi.get(self, "ip_block")

    @ip_block.setter
    def ip_block(self, value: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersIpBlockArgs']]):
        pulumi.set(self, "ip_block", value)

    @property
    @pulumi.getter(name="namespaceSelector")
    def namespace_selector(self) -> Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersNamespaceSelectorArgs']]:
        return pulumi.get(self, "namespace_selector")

    @namespace_selector.setter
    def namespace_selector(self, value: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersNamespaceSelectorArgs']]):
        pulumi.set(self, "namespace_selector", value)

    @property
    @pulumi.getter(name="podSelector")
    def pod_selector(self) -> Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersPodSelectorArgs']]:
        return pulumi.get(self, "pod_selector")

    @pod_selector.setter
    def pod_selector(self, value: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersPodSelectorArgs']]):
        pulumi.set(self, "pod_selector", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersIpBlockArgs:
    def __init__(__self__, *,
                 cidr: Optional[pulumi.Input[str]] = None,
                 except_: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if except_ is not None:
            pulumi.set(__self__, "except_", except_)

    @property
    @pulumi.getter
    def cidr(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cidr")

    @cidr.setter
    def cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cidr", value)

    @property
    @pulumi.getter(name="except")
    def except_(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "except_")

    @except_.setter
    def except_(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "except_", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersNamespaceSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersNamespaceSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersNamespaceSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersNamespaceSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersNamespaceSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersPodSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersPodSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersPodSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersPodSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersPodSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf1TlsArgs:
    def __init__(__self__, *,
                 authentication: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1TlsAuthenticationArgs']] = None,
                 configuration: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1TlsConfigurationArgs']] = None,
                 network_policy_peers: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersArgs']]]] = None):
        """
        Configures TLS listener on port 9093.
        :param pulumi.Input['KafkaSpecKafkaListenersOneOf1TlsAuthenticationArgs'] authentication: Authentication configuration for this listener.
        :param pulumi.Input['KafkaSpecKafkaListenersOneOf1TlsConfigurationArgs'] configuration: Configuration of TLS listener.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersArgs']]] network_policy_peers: List of peers which should be able to connect to this listener. Peers in this list are combined using a logical OR operation. If this field is empty or missing, all connections will be allowed for this listener. If this field is present and contains at least one item, the listener only allows the traffic which matches at least one item in this list.
        """
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if network_policy_peers is not None:
            pulumi.set(__self__, "network_policy_peers", network_policy_peers)

    @property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1TlsAuthenticationArgs']]:
        """
        Authentication configuration for this listener.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1TlsAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @property
    @pulumi.getter
    def configuration(self) -> Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1TlsConfigurationArgs']]:
        """
        Configuration of TLS listener.
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1TlsConfigurationArgs']]):
        pulumi.set(self, "configuration", value)

    @property
    @pulumi.getter(name="networkPolicyPeers")
    def network_policy_peers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersArgs']]]]:
        """
        List of peers which should be able to connect to this listener. Peers in this list are combined using a logical OR operation. If this field is empty or missing, all connections will be allowed for this listener. If this field is present and contains at least one item, the listener only allows the traffic which matches at least one item in this list.
        """
        return pulumi.get(self, "network_policy_peers")

    @network_policy_peers.setter
    def network_policy_peers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersArgs']]]]):
        pulumi.set(self, "network_policy_peers", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf1TlsAuthenticationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 access_token_is_jwt: Optional[pulumi.Input[bool]] = None,
                 check_access_token_type: Optional[pulumi.Input[bool]] = None,
                 check_issuer: Optional[pulumi.Input[bool]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1TlsAuthenticationClientSecretArgs']] = None,
                 disable_tls_hostname_verification: Optional[pulumi.Input[bool]] = None,
                 enable_ecdsa: Optional[pulumi.Input[bool]] = None,
                 fallback_user_name_claim: Optional[pulumi.Input[str]] = None,
                 fallback_user_name_prefix: Optional[pulumi.Input[str]] = None,
                 introspection_endpoint_uri: Optional[pulumi.Input[str]] = None,
                 jwks_endpoint_uri: Optional[pulumi.Input[str]] = None,
                 jwks_expiry_seconds: Optional[pulumi.Input[int]] = None,
                 jwks_min_refresh_pause_seconds: Optional[pulumi.Input[int]] = None,
                 jwks_refresh_seconds: Optional[pulumi.Input[int]] = None,
                 max_seconds_without_reauthentication: Optional[pulumi.Input[int]] = None,
                 tls_trusted_certificates: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1TlsAuthenticationTlsTrustedCertificatesArgs']]]] = None,
                 user_info_endpoint_uri: Optional[pulumi.Input[str]] = None,
                 user_name_claim: Optional[pulumi.Input[str]] = None,
                 valid_issuer_uri: Optional[pulumi.Input[str]] = None,
                 valid_token_type: Optional[pulumi.Input[str]] = None):
        """
        Authentication configuration for this listener.
        :param pulumi.Input[str] type: Authentication type. `oauth` type uses SASL OAUTHBEARER Authentication. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `tls` type uses TLS Client Authentication. `tls` type is supported only on TLS listeners.
        :param pulumi.Input[bool] access_token_is_jwt: Configure whether the access token is treated as JWT. This must be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
        :param pulumi.Input[bool] check_access_token_type: Configure whether the access token type check is performed or not. This should be set to `false` if the authorization server does not include 'typ' claim in JWT token. Defaults to `true`.
        :param pulumi.Input[bool] check_issuer: Enable or disable issuer checking. By default issuer is checked using the value configured by `validIssuerUri`. Default value is `true`.
        :param pulumi.Input[str] client_id: OAuth Client ID which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
        :param pulumi.Input['KafkaSpecKafkaListenersOneOf1TlsAuthenticationClientSecretArgs'] client_secret: Link to Kubernetes Secret containing the OAuth client secret which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
        :param pulumi.Input[bool] disable_tls_hostname_verification: Enable or disable TLS hostname verification. Default value is `false`.
        :param pulumi.Input[bool] enable_ecdsa: Enable or disable ECDSA support by installing BouncyCastle crypto provider. Default value is `false`.
        :param pulumi.Input[str] fallback_user_name_claim: The fallback username claim to be used for the user id if the claim specified by `userNameClaim` is not present. This is useful when `client_credentials` authentication only results in the client id being provided in another claim. It only takes effect if `userNameClaim` is set.
        :param pulumi.Input[str] fallback_user_name_prefix: The prefix to use with the value of `fallbackUserNameClaim` to construct the user id. This only takes effect if `fallbackUserNameClaim` is true, and the value is present for the claim. Mapping usernames and client ids into the same user id space is useful in preventing name collisions.
        :param pulumi.Input[str] introspection_endpoint_uri: URI of the token introspection endpoint which can be used to validate opaque non-JWT tokens.
        :param pulumi.Input[str] jwks_endpoint_uri: URI of the JWKS certificate endpoint, which can be used for local JWT validation.
        :param pulumi.Input[int] jwks_expiry_seconds: Configures how often are the JWKS certificates considered valid. The expiry interval has to be at least 60 seconds longer then the refresh interval specified in `jwksRefreshSeconds`. Defaults to 360 seconds.
        :param pulumi.Input[int] jwks_min_refresh_pause_seconds: The minimum pause between two consecutive refreshes. When an unknown signing key is encountered the refresh is scheduled immediately, but will always wait for this minimum pause. Defaults to 1 second.
        :param pulumi.Input[int] jwks_refresh_seconds: Configures how often are the JWKS certificates refreshed. The refresh interval has to be at least 60 seconds shorter then the expiry interval specified in `jwksExpirySeconds`. Defaults to 300 seconds.
        :param pulumi.Input[int] max_seconds_without_reauthentication: Maximum number of seconds the authenticated session remains valid without re-authentication. This enables Apache Kafka re-authentication feature, and causes sessions to expire when the access token expires. If the access token expires before max time or if max time is reached, the client has to re-authenticate, otherwise the server will drop the connection. Not set by default - the authenticated session does not expire when the access token expires.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1TlsAuthenticationTlsTrustedCertificatesArgs']]] tls_trusted_certificates: Trusted certificates for TLS connection to the OAuth server.
        :param pulumi.Input[str] user_info_endpoint_uri: URI of the User Info Endpoint to use as a fallback to obtaining the user id when the Introspection Endpoint does not return information that can be used for the user id. 
        :param pulumi.Input[str] user_name_claim: Name of the claim from the JWT authentication token, Introspection Endpoint response or User Info Endpoint response which will be used to extract the user id. Defaults to `sub`.
        :param pulumi.Input[str] valid_issuer_uri: URI of the token issuer used for authentication.
        :param pulumi.Input[str] valid_token_type: Valid value for the `token_type` attribute returned by the Introspection Endpoint. No default value, and not checked by default.
        """
        pulumi.set(__self__, "type", type)
        if access_token_is_jwt is not None:
            pulumi.set(__self__, "access_token_is_jwt", access_token_is_jwt)
        if check_access_token_type is not None:
            pulumi.set(__self__, "check_access_token_type", check_access_token_type)
        if check_issuer is not None:
            pulumi.set(__self__, "check_issuer", check_issuer)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if disable_tls_hostname_verification is not None:
            pulumi.set(__self__, "disable_tls_hostname_verification", disable_tls_hostname_verification)
        if enable_ecdsa is not None:
            pulumi.set(__self__, "enable_ecdsa", enable_ecdsa)
        if fallback_user_name_claim is not None:
            pulumi.set(__self__, "fallback_user_name_claim", fallback_user_name_claim)
        if fallback_user_name_prefix is not None:
            pulumi.set(__self__, "fallback_user_name_prefix", fallback_user_name_prefix)
        if introspection_endpoint_uri is not None:
            pulumi.set(__self__, "introspection_endpoint_uri", introspection_endpoint_uri)
        if jwks_endpoint_uri is not None:
            pulumi.set(__self__, "jwks_endpoint_uri", jwks_endpoint_uri)
        if jwks_expiry_seconds is not None:
            pulumi.set(__self__, "jwks_expiry_seconds", jwks_expiry_seconds)
        if jwks_min_refresh_pause_seconds is not None:
            pulumi.set(__self__, "jwks_min_refresh_pause_seconds", jwks_min_refresh_pause_seconds)
        if jwks_refresh_seconds is not None:
            pulumi.set(__self__, "jwks_refresh_seconds", jwks_refresh_seconds)
        if max_seconds_without_reauthentication is not None:
            pulumi.set(__self__, "max_seconds_without_reauthentication", max_seconds_without_reauthentication)
        if tls_trusted_certificates is not None:
            pulumi.set(__self__, "tls_trusted_certificates", tls_trusted_certificates)
        if user_info_endpoint_uri is not None:
            pulumi.set(__self__, "user_info_endpoint_uri", user_info_endpoint_uri)
        if user_name_claim is not None:
            pulumi.set(__self__, "user_name_claim", user_name_claim)
        if valid_issuer_uri is not None:
            pulumi.set(__self__, "valid_issuer_uri", valid_issuer_uri)
        if valid_token_type is not None:
            pulumi.set(__self__, "valid_token_type", valid_token_type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Authentication type. `oauth` type uses SASL OAUTHBEARER Authentication. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `tls` type uses TLS Client Authentication. `tls` type is supported only on TLS listeners.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="accessTokenIsJwt")
    def access_token_is_jwt(self) -> Optional[pulumi.Input[bool]]:
        """
        Configure whether the access token is treated as JWT. This must be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
        """
        return pulumi.get(self, "access_token_is_jwt")

    @access_token_is_jwt.setter
    def access_token_is_jwt(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "access_token_is_jwt", value)

    @property
    @pulumi.getter(name="checkAccessTokenType")
    def check_access_token_type(self) -> Optional[pulumi.Input[bool]]:
        """
        Configure whether the access token type check is performed or not. This should be set to `false` if the authorization server does not include 'typ' claim in JWT token. Defaults to `true`.
        """
        return pulumi.get(self, "check_access_token_type")

    @check_access_token_type.setter
    def check_access_token_type(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "check_access_token_type", value)

    @property
    @pulumi.getter(name="checkIssuer")
    def check_issuer(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable or disable issuer checking. By default issuer is checked using the value configured by `validIssuerUri`. Default value is `true`.
        """
        return pulumi.get(self, "check_issuer")

    @check_issuer.setter
    def check_issuer(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "check_issuer", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        OAuth Client ID which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1TlsAuthenticationClientSecretArgs']]:
        """
        Link to Kubernetes Secret containing the OAuth client secret which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1TlsAuthenticationClientSecretArgs']]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="disableTlsHostnameVerification")
    def disable_tls_hostname_verification(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable or disable TLS hostname verification. Default value is `false`.
        """
        return pulumi.get(self, "disable_tls_hostname_verification")

    @disable_tls_hostname_verification.setter
    def disable_tls_hostname_verification(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_tls_hostname_verification", value)

    @property
    @pulumi.getter(name="enableECDSA")
    def enable_ecdsa(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable or disable ECDSA support by installing BouncyCastle crypto provider. Default value is `false`.
        """
        return pulumi.get(self, "enable_ecdsa")

    @enable_ecdsa.setter
    def enable_ecdsa(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_ecdsa", value)

    @property
    @pulumi.getter(name="fallbackUserNameClaim")
    def fallback_user_name_claim(self) -> Optional[pulumi.Input[str]]:
        """
        The fallback username claim to be used for the user id if the claim specified by `userNameClaim` is not present. This is useful when `client_credentials` authentication only results in the client id being provided in another claim. It only takes effect if `userNameClaim` is set.
        """
        return pulumi.get(self, "fallback_user_name_claim")

    @fallback_user_name_claim.setter
    def fallback_user_name_claim(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fallback_user_name_claim", value)

    @property
    @pulumi.getter(name="fallbackUserNamePrefix")
    def fallback_user_name_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The prefix to use with the value of `fallbackUserNameClaim` to construct the user id. This only takes effect if `fallbackUserNameClaim` is true, and the value is present for the claim. Mapping usernames and client ids into the same user id space is useful in preventing name collisions.
        """
        return pulumi.get(self, "fallback_user_name_prefix")

    @fallback_user_name_prefix.setter
    def fallback_user_name_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fallback_user_name_prefix", value)

    @property
    @pulumi.getter(name="introspectionEndpointUri")
    def introspection_endpoint_uri(self) -> Optional[pulumi.Input[str]]:
        """
        URI of the token introspection endpoint which can be used to validate opaque non-JWT tokens.
        """
        return pulumi.get(self, "introspection_endpoint_uri")

    @introspection_endpoint_uri.setter
    def introspection_endpoint_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "introspection_endpoint_uri", value)

    @property
    @pulumi.getter(name="jwksEndpointUri")
    def jwks_endpoint_uri(self) -> Optional[pulumi.Input[str]]:
        """
        URI of the JWKS certificate endpoint, which can be used for local JWT validation.
        """
        return pulumi.get(self, "jwks_endpoint_uri")

    @jwks_endpoint_uri.setter
    def jwks_endpoint_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jwks_endpoint_uri", value)

    @property
    @pulumi.getter(name="jwksExpirySeconds")
    def jwks_expiry_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Configures how often are the JWKS certificates considered valid. The expiry interval has to be at least 60 seconds longer then the refresh interval specified in `jwksRefreshSeconds`. Defaults to 360 seconds.
        """
        return pulumi.get(self, "jwks_expiry_seconds")

    @jwks_expiry_seconds.setter
    def jwks_expiry_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "jwks_expiry_seconds", value)

    @property
    @pulumi.getter(name="jwksMinRefreshPauseSeconds")
    def jwks_min_refresh_pause_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The minimum pause between two consecutive refreshes. When an unknown signing key is encountered the refresh is scheduled immediately, but will always wait for this minimum pause. Defaults to 1 second.
        """
        return pulumi.get(self, "jwks_min_refresh_pause_seconds")

    @jwks_min_refresh_pause_seconds.setter
    def jwks_min_refresh_pause_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "jwks_min_refresh_pause_seconds", value)

    @property
    @pulumi.getter(name="jwksRefreshSeconds")
    def jwks_refresh_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Configures how often are the JWKS certificates refreshed. The refresh interval has to be at least 60 seconds shorter then the expiry interval specified in `jwksExpirySeconds`. Defaults to 300 seconds.
        """
        return pulumi.get(self, "jwks_refresh_seconds")

    @jwks_refresh_seconds.setter
    def jwks_refresh_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "jwks_refresh_seconds", value)

    @property
    @pulumi.getter(name="maxSecondsWithoutReauthentication")
    def max_seconds_without_reauthentication(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of seconds the authenticated session remains valid without re-authentication. This enables Apache Kafka re-authentication feature, and causes sessions to expire when the access token expires. If the access token expires before max time or if max time is reached, the client has to re-authenticate, otherwise the server will drop the connection. Not set by default - the authenticated session does not expire when the access token expires.
        """
        return pulumi.get(self, "max_seconds_without_reauthentication")

    @max_seconds_without_reauthentication.setter
    def max_seconds_without_reauthentication(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_seconds_without_reauthentication", value)

    @property
    @pulumi.getter(name="tlsTrustedCertificates")
    def tls_trusted_certificates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1TlsAuthenticationTlsTrustedCertificatesArgs']]]]:
        """
        Trusted certificates for TLS connection to the OAuth server.
        """
        return pulumi.get(self, "tls_trusted_certificates")

    @tls_trusted_certificates.setter
    def tls_trusted_certificates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1TlsAuthenticationTlsTrustedCertificatesArgs']]]]):
        pulumi.set(self, "tls_trusted_certificates", value)

    @property
    @pulumi.getter(name="userInfoEndpointUri")
    def user_info_endpoint_uri(self) -> Optional[pulumi.Input[str]]:
        """
        URI of the User Info Endpoint to use as a fallback to obtaining the user id when the Introspection Endpoint does not return information that can be used for the user id. 
        """
        return pulumi.get(self, "user_info_endpoint_uri")

    @user_info_endpoint_uri.setter
    def user_info_endpoint_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_info_endpoint_uri", value)

    @property
    @pulumi.getter(name="userNameClaim")
    def user_name_claim(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the claim from the JWT authentication token, Introspection Endpoint response or User Info Endpoint response which will be used to extract the user id. Defaults to `sub`.
        """
        return pulumi.get(self, "user_name_claim")

    @user_name_claim.setter
    def user_name_claim(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_name_claim", value)

    @property
    @pulumi.getter(name="validIssuerUri")
    def valid_issuer_uri(self) -> Optional[pulumi.Input[str]]:
        """
        URI of the token issuer used for authentication.
        """
        return pulumi.get(self, "valid_issuer_uri")

    @valid_issuer_uri.setter
    def valid_issuer_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "valid_issuer_uri", value)

    @property
    @pulumi.getter(name="validTokenType")
    def valid_token_type(self) -> Optional[pulumi.Input[str]]:
        """
        Valid value for the `token_type` attribute returned by the Introspection Endpoint. No default value, and not checked by default.
        """
        return pulumi.get(self, "valid_token_type")

    @valid_token_type.setter
    def valid_token_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "valid_token_type", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf1TlsAuthenticationClientSecretArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        Link to Kubernetes Secret containing the OAuth client secret which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
        :param pulumi.Input[str] key: The key under which the secret value is stored in the Kubernetes Secret.
        :param pulumi.Input[str] secret_name: The name of the Kubernetes Secret containing the secret value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key under which the secret value is stored in the Kubernetes Secret.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        The name of the Kubernetes Secret containing the secret value.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf1TlsAuthenticationTlsTrustedCertificatesArgs:
    def __init__(__self__, *,
                 certificate: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] certificate: The name of the file certificate in the Secret.
        :param pulumi.Input[str] secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> pulumi.Input[str]:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf1TlsConfigurationArgs:
    def __init__(__self__, *,
                 broker_cert_chain_and_key: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1TlsConfigurationBrokerCertChainAndKeyArgs']] = None):
        """
        Configuration of TLS listener.
        :param pulumi.Input['KafkaSpecKafkaListenersOneOf1TlsConfigurationBrokerCertChainAndKeyArgs'] broker_cert_chain_and_key: Reference to the `Secret` which holds the certificate and private key pair. The certificate can optionally contain the whole chain.
        """
        if broker_cert_chain_and_key is not None:
            pulumi.set(__self__, "broker_cert_chain_and_key", broker_cert_chain_and_key)

    @property
    @pulumi.getter(name="brokerCertChainAndKey")
    def broker_cert_chain_and_key(self) -> Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1TlsConfigurationBrokerCertChainAndKeyArgs']]:
        """
        Reference to the `Secret` which holds the certificate and private key pair. The certificate can optionally contain the whole chain.
        """
        return pulumi.get(self, "broker_cert_chain_and_key")

    @broker_cert_chain_and_key.setter
    def broker_cert_chain_and_key(self, value: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1TlsConfigurationBrokerCertChainAndKeyArgs']]):
        pulumi.set(self, "broker_cert_chain_and_key", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf1TlsConfigurationBrokerCertChainAndKeyArgs:
    def __init__(__self__, *,
                 certificate: pulumi.Input[str],
                 key: pulumi.Input[str],
                 secret_name: pulumi.Input[str]):
        """
        Reference to the `Secret` which holds the certificate and private key pair. The certificate can optionally contain the whole chain.
        :param pulumi.Input[str] certificate: The name of the file certificate in the Secret.
        :param pulumi.Input[str] key: The name of the private key in the Secret.
        :param pulumi.Input[str] secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> pulumi.Input[str]:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The name of the private key in the Secret.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersArgs:
    def __init__(__self__, *,
                 ip_block: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersIpBlockArgs']] = None,
                 namespace_selector: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersNamespaceSelectorArgs']] = None,
                 pod_selector: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersPodSelectorArgs']] = None):
        if ip_block is not None:
            pulumi.set(__self__, "ip_block", ip_block)
        if namespace_selector is not None:
            pulumi.set(__self__, "namespace_selector", namespace_selector)
        if pod_selector is not None:
            pulumi.set(__self__, "pod_selector", pod_selector)

    @property
    @pulumi.getter(name="ipBlock")
    def ip_block(self) -> Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersIpBlockArgs']]:
        return pulumi.get(self, "ip_block")

    @ip_block.setter
    def ip_block(self, value: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersIpBlockArgs']]):
        pulumi.set(self, "ip_block", value)

    @property
    @pulumi.getter(name="namespaceSelector")
    def namespace_selector(self) -> Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersNamespaceSelectorArgs']]:
        return pulumi.get(self, "namespace_selector")

    @namespace_selector.setter
    def namespace_selector(self, value: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersNamespaceSelectorArgs']]):
        pulumi.set(self, "namespace_selector", value)

    @property
    @pulumi.getter(name="podSelector")
    def pod_selector(self) -> Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersPodSelectorArgs']]:
        return pulumi.get(self, "pod_selector")

    @pod_selector.setter
    def pod_selector(self, value: Optional[pulumi.Input['KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersPodSelectorArgs']]):
        pulumi.set(self, "pod_selector", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersIpBlockArgs:
    def __init__(__self__, *,
                 cidr: Optional[pulumi.Input[str]] = None,
                 except_: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if except_ is not None:
            pulumi.set(__self__, "except_", except_)

    @property
    @pulumi.getter
    def cidr(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cidr")

    @cidr.setter
    def cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cidr", value)

    @property
    @pulumi.getter(name="except")
    def except_(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "except_")

    @except_.setter
    def except_(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "except_", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersNamespaceSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersNamespaceSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersNamespaceSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersNamespaceSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersNamespaceSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersPodSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersPodSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersPodSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersPodSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersPodSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecKafkaLivenessProbeArgs:
    def __init__(__self__, *,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 success_threshold: Optional[pulumi.Input[int]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        Pod liveness checking.
        :param pulumi.Input[int] failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param pulumi.Input[int] initial_delay_seconds: The initial delay before first the health is first checked.
        :param pulumi.Input[int] period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param pulumi.Input[int] success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param pulumi.Input[int] timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "success_threshold", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


@pulumi.input_type
class KafkaSpecKafkaLoggingArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 loggers: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        Logging configuration for Kafka.
        :param pulumi.Input[str] type: Logging type, must be either 'inline' or 'external'.
        :param pulumi.Input[Mapping[str, Any]] loggers: A Map from logger name to logger level.
        :param pulumi.Input[str] name: The name of the `ConfigMap` from which to get the logging configuration.
        """
        pulumi.set(__self__, "type", type)
        if loggers is not None:
            pulumi.set(__self__, "loggers", loggers)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Logging type, must be either 'inline' or 'external'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def loggers(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        A Map from logger name to logger level.
        """
        return pulumi.get(self, "loggers")

    @loggers.setter
    def loggers(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "loggers", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the `ConfigMap` from which to get the logging configuration.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class KafkaSpecKafkaRackArgs:
    def __init__(__self__, *,
                 topology_key: pulumi.Input[str]):
        """
        Configuration of the `broker.rack` broker config.
        :param pulumi.Input[str] topology_key: A key that matches labels assigned to the Kubernetes cluster nodes. The value of the label is used to set the broker's `broker.rack` config.
        """
        pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> pulumi.Input[str]:
        """
        A key that matches labels assigned to the Kubernetes cluster nodes. The value of the label is used to set the broker's `broker.rack` config.
        """
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaSpecKafkaReadinessProbeArgs:
    def __init__(__self__, *,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 success_threshold: Optional[pulumi.Input[int]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        Pod readiness checking.
        :param pulumi.Input[int] failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param pulumi.Input[int] initial_delay_seconds: The initial delay before first the health is first checked.
        :param pulumi.Input[int] period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param pulumi.Input[int] success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param pulumi.Input[int] timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "success_threshold", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


@pulumi.input_type
class KafkaSpecKafkaResourcesArgs:
    def __init__(__self__, *,
                 limits: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 requests: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        CPU and memory resources to reserve.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "limits", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "requests", value)


@pulumi.input_type
class KafkaSpecKafkaStorageArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 class_: Optional[pulumi.Input[str]] = None,
                 delete_claim: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[int]] = None,
                 overrides: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaStorageOverridesArgs']]]] = None,
                 selector: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 size: Optional[pulumi.Input[str]] = None,
                 size_limit: Optional[pulumi.Input[str]] = None,
                 volumes: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaStorageVolumesArgs']]]] = None):
        """
        Storage configuration (disk). Cannot be updated.
        :param pulumi.Input[str] type: Storage type, must be either 'ephemeral', 'persistent-claim', or 'jbod'.
        :param pulumi.Input[str] class_: The storage class to use for dynamic volume allocation.
        :param pulumi.Input[bool] delete_claim: Specifies if the persistent volume claim has to be deleted when the cluster is un-deployed.
        :param pulumi.Input[int] id: Storage identification number. It is mandatory only for storage volumes defined in a storage of type 'jbod'.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaStorageOverridesArgs']]] overrides: Overrides for individual brokers. The `overrides` field allows to specify a different configuration for different brokers.
        :param pulumi.Input[Mapping[str, Any]] selector: Specifies a specific persistent volume to use. It contains key:value pairs representing labels for selecting such a volume.
        :param pulumi.Input[str] size: When type=persistent-claim, defines the size of the persistent volume claim (i.e 1Gi). Mandatory when type=persistent-claim.
        :param pulumi.Input[str] size_limit: When type=ephemeral, defines the total amount of local storage required for this EmptyDir volume (for example 1Gi).
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaStorageVolumesArgs']]] volumes: List of volumes as Storage objects representing the JBOD disks array.
        """
        pulumi.set(__self__, "type", type)
        if class_ is not None:
            pulumi.set(__self__, "class_", class_)
        if delete_claim is not None:
            pulumi.set(__self__, "delete_claim", delete_claim)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if size_limit is not None:
            pulumi.set(__self__, "size_limit", size_limit)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Storage type, must be either 'ephemeral', 'persistent-claim', or 'jbod'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="class")
    def class_(self) -> Optional[pulumi.Input[str]]:
        """
        The storage class to use for dynamic volume allocation.
        """
        return pulumi.get(self, "class_")

    @class_.setter
    def class_(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "class_", value)

    @property
    @pulumi.getter(name="deleteClaim")
    def delete_claim(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies if the persistent volume claim has to be deleted when the cluster is un-deployed.
        """
        return pulumi.get(self, "delete_claim")

    @delete_claim.setter
    def delete_claim(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_claim", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[int]]:
        """
        Storage identification number. It is mandatory only for storage volumes defined in a storage of type 'jbod'.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaStorageOverridesArgs']]]]:
        """
        Overrides for individual brokers. The `overrides` field allows to specify a different configuration for different brokers.
        """
        return pulumi.get(self, "overrides")

    @overrides.setter
    def overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaStorageOverridesArgs']]]]):
        pulumi.set(self, "overrides", value)

    @property
    @pulumi.getter
    def selector(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Specifies a specific persistent volume to use. It contains key:value pairs representing labels for selecting such a volume.
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "selector", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[str]]:
        """
        When type=persistent-claim, defines the size of the persistent volume claim (i.e 1Gi). Mandatory when type=persistent-claim.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="sizeLimit")
    def size_limit(self) -> Optional[pulumi.Input[str]]:
        """
        When type=ephemeral, defines the total amount of local storage required for this EmptyDir volume (for example 1Gi).
        """
        return pulumi.get(self, "size_limit")

    @size_limit.setter
    def size_limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "size_limit", value)

    @property
    @pulumi.getter
    def volumes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaStorageVolumesArgs']]]]:
        """
        List of volumes as Storage objects representing the JBOD disks array.
        """
        return pulumi.get(self, "volumes")

    @volumes.setter
    def volumes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaStorageVolumesArgs']]]]):
        pulumi.set(self, "volumes", value)


@pulumi.input_type
class KafkaSpecKafkaStorageOverridesArgs:
    def __init__(__self__, *,
                 broker: Optional[pulumi.Input[int]] = None,
                 class_: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] broker: Id of the kafka broker (broker identifier).
        :param pulumi.Input[str] class_: The storage class to use for dynamic volume allocation for this broker.
        """
        if broker is not None:
            pulumi.set(__self__, "broker", broker)
        if class_ is not None:
            pulumi.set(__self__, "class_", class_)

    @property
    @pulumi.getter
    def broker(self) -> Optional[pulumi.Input[int]]:
        """
        Id of the kafka broker (broker identifier).
        """
        return pulumi.get(self, "broker")

    @broker.setter
    def broker(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "broker", value)

    @property
    @pulumi.getter(name="class")
    def class_(self) -> Optional[pulumi.Input[str]]:
        """
        The storage class to use for dynamic volume allocation for this broker.
        """
        return pulumi.get(self, "class_")

    @class_.setter
    def class_(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "class_", value)


@pulumi.input_type
class KafkaSpecKafkaStorageVolumesArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 class_: Optional[pulumi.Input[str]] = None,
                 delete_claim: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[int]] = None,
                 overrides: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaStorageVolumesOverridesArgs']]]] = None,
                 selector: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 size: Optional[pulumi.Input[str]] = None,
                 size_limit: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Storage type, must be either 'ephemeral' or 'persistent-claim'.
        :param pulumi.Input[str] class_: The storage class to use for dynamic volume allocation.
        :param pulumi.Input[bool] delete_claim: Specifies if the persistent volume claim has to be deleted when the cluster is un-deployed.
        :param pulumi.Input[int] id: Storage identification number. It is mandatory only for storage volumes defined in a storage of type 'jbod'.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaStorageVolumesOverridesArgs']]] overrides: Overrides for individual brokers. The `overrides` field allows to specify a different configuration for different brokers.
        :param pulumi.Input[Mapping[str, Any]] selector: Specifies a specific persistent volume to use. It contains key:value pairs representing labels for selecting such a volume.
        :param pulumi.Input[str] size: When type=persistent-claim, defines the size of the persistent volume claim (i.e 1Gi). Mandatory when type=persistent-claim.
        :param pulumi.Input[str] size_limit: When type=ephemeral, defines the total amount of local storage required for this EmptyDir volume (for example 1Gi).
        """
        pulumi.set(__self__, "type", type)
        if class_ is not None:
            pulumi.set(__self__, "class_", class_)
        if delete_claim is not None:
            pulumi.set(__self__, "delete_claim", delete_claim)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if size_limit is not None:
            pulumi.set(__self__, "size_limit", size_limit)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Storage type, must be either 'ephemeral' or 'persistent-claim'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="class")
    def class_(self) -> Optional[pulumi.Input[str]]:
        """
        The storage class to use for dynamic volume allocation.
        """
        return pulumi.get(self, "class_")

    @class_.setter
    def class_(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "class_", value)

    @property
    @pulumi.getter(name="deleteClaim")
    def delete_claim(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies if the persistent volume claim has to be deleted when the cluster is un-deployed.
        """
        return pulumi.get(self, "delete_claim")

    @delete_claim.setter
    def delete_claim(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_claim", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[int]]:
        """
        Storage identification number. It is mandatory only for storage volumes defined in a storage of type 'jbod'.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaStorageVolumesOverridesArgs']]]]:
        """
        Overrides for individual brokers. The `overrides` field allows to specify a different configuration for different brokers.
        """
        return pulumi.get(self, "overrides")

    @overrides.setter
    def overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaStorageVolumesOverridesArgs']]]]):
        pulumi.set(self, "overrides", value)

    @property
    @pulumi.getter
    def selector(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Specifies a specific persistent volume to use. It contains key:value pairs representing labels for selecting such a volume.
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "selector", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[str]]:
        """
        When type=persistent-claim, defines the size of the persistent volume claim (i.e 1Gi). Mandatory when type=persistent-claim.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="sizeLimit")
    def size_limit(self) -> Optional[pulumi.Input[str]]:
        """
        When type=ephemeral, defines the total amount of local storage required for this EmptyDir volume (for example 1Gi).
        """
        return pulumi.get(self, "size_limit")

    @size_limit.setter
    def size_limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "size_limit", value)


@pulumi.input_type
class KafkaSpecKafkaStorageVolumesOverridesArgs:
    def __init__(__self__, *,
                 broker: Optional[pulumi.Input[int]] = None,
                 class_: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] broker: Id of the kafka broker (broker identifier).
        :param pulumi.Input[str] class_: The storage class to use for dynamic volume allocation for this broker.
        """
        if broker is not None:
            pulumi.set(__self__, "broker", broker)
        if class_ is not None:
            pulumi.set(__self__, "class_", class_)

    @property
    @pulumi.getter
    def broker(self) -> Optional[pulumi.Input[int]]:
        """
        Id of the kafka broker (broker identifier).
        """
        return pulumi.get(self, "broker")

    @broker.setter
    def broker(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "broker", value)

    @property
    @pulumi.getter(name="class")
    def class_(self) -> Optional[pulumi.Input[str]]:
        """
        The storage class to use for dynamic volume allocation for this broker.
        """
        return pulumi.get(self, "class_")

    @class_.setter
    def class_(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "class_", value)


@pulumi.input_type
class KafkaSpecKafkaTemplateArgs:
    def __init__(__self__, *,
                 bootstrap_service: Optional[pulumi.Input['KafkaSpecKafkaTemplateBootstrapServiceArgs']] = None,
                 brokers_service: Optional[pulumi.Input['KafkaSpecKafkaTemplateBrokersServiceArgs']] = None,
                 external_bootstrap_ingress: Optional[pulumi.Input['KafkaSpecKafkaTemplateExternalBootstrapIngressArgs']] = None,
                 external_bootstrap_route: Optional[pulumi.Input['KafkaSpecKafkaTemplateExternalBootstrapRouteArgs']] = None,
                 external_bootstrap_service: Optional[pulumi.Input['KafkaSpecKafkaTemplateExternalBootstrapServiceArgs']] = None,
                 init_container: Optional[pulumi.Input['KafkaSpecKafkaTemplateInitContainerArgs']] = None,
                 kafka_container: Optional[pulumi.Input['KafkaSpecKafkaTemplateKafkaContainerArgs']] = None,
                 per_pod_ingress: Optional[pulumi.Input['KafkaSpecKafkaTemplatePerPodIngressArgs']] = None,
                 per_pod_route: Optional[pulumi.Input['KafkaSpecKafkaTemplatePerPodRouteArgs']] = None,
                 per_pod_service: Optional[pulumi.Input['KafkaSpecKafkaTemplatePerPodServiceArgs']] = None,
                 persistent_volume_claim: Optional[pulumi.Input['KafkaSpecKafkaTemplatePersistentVolumeClaimArgs']] = None,
                 pod: Optional[pulumi.Input['KafkaSpecKafkaTemplatePodArgs']] = None,
                 pod_disruption_budget: Optional[pulumi.Input['KafkaSpecKafkaTemplatePodDisruptionBudgetArgs']] = None,
                 statefulset: Optional[pulumi.Input['KafkaSpecKafkaTemplateStatefulsetArgs']] = None,
                 tls_sidecar_container: Optional[pulumi.Input['KafkaSpecKafkaTemplateTlsSidecarContainerArgs']] = None):
        """
        Template for Kafka cluster resources. The template allows users to specify how are the `StatefulSet`, `Pods` and `Services` generated.
        :param pulumi.Input['KafkaSpecKafkaTemplateBootstrapServiceArgs'] bootstrap_service: Template for Kafka bootstrap `Service`.
        :param pulumi.Input['KafkaSpecKafkaTemplateBrokersServiceArgs'] brokers_service: Template for Kafka broker `Service`.
        :param pulumi.Input['KafkaSpecKafkaTemplateExternalBootstrapIngressArgs'] external_bootstrap_ingress: Template for Kafka external bootstrap `Ingress`.
        :param pulumi.Input['KafkaSpecKafkaTemplateExternalBootstrapRouteArgs'] external_bootstrap_route: Template for Kafka external bootstrap `Route`.
        :param pulumi.Input['KafkaSpecKafkaTemplateExternalBootstrapServiceArgs'] external_bootstrap_service: Template for Kafka external bootstrap `Service`.
        :param pulumi.Input['KafkaSpecKafkaTemplateInitContainerArgs'] init_container: Template for the Kafka init container.
        :param pulumi.Input['KafkaSpecKafkaTemplateKafkaContainerArgs'] kafka_container: Template for the Kafka broker container.
        :param pulumi.Input['KafkaSpecKafkaTemplatePerPodIngressArgs'] per_pod_ingress: Template for Kafka per-pod `Ingress` used for access from outside of Kubernetes.
        :param pulumi.Input['KafkaSpecKafkaTemplatePerPodRouteArgs'] per_pod_route: Template for Kafka per-pod `Routes` used for access from outside of OpenShift.
        :param pulumi.Input['KafkaSpecKafkaTemplatePerPodServiceArgs'] per_pod_service: Template for Kafka per-pod `Services` used for access from outside of Kubernetes.
        :param pulumi.Input['KafkaSpecKafkaTemplatePersistentVolumeClaimArgs'] persistent_volume_claim: Template for all Kafka `PersistentVolumeClaims`.
        :param pulumi.Input['KafkaSpecKafkaTemplatePodArgs'] pod: Template for Kafka `Pods`.
        :param pulumi.Input['KafkaSpecKafkaTemplatePodDisruptionBudgetArgs'] pod_disruption_budget: Template for Kafka `PodDisruptionBudget`.
        :param pulumi.Input['KafkaSpecKafkaTemplateStatefulsetArgs'] statefulset: Template for Kafka `StatefulSet`.
        :param pulumi.Input['KafkaSpecKafkaTemplateTlsSidecarContainerArgs'] tls_sidecar_container: Template for the Kafka broker TLS sidecar container.
        """
        if bootstrap_service is not None:
            pulumi.set(__self__, "bootstrap_service", bootstrap_service)
        if brokers_service is not None:
            pulumi.set(__self__, "brokers_service", brokers_service)
        if external_bootstrap_ingress is not None:
            pulumi.set(__self__, "external_bootstrap_ingress", external_bootstrap_ingress)
        if external_bootstrap_route is not None:
            pulumi.set(__self__, "external_bootstrap_route", external_bootstrap_route)
        if external_bootstrap_service is not None:
            pulumi.set(__self__, "external_bootstrap_service", external_bootstrap_service)
        if init_container is not None:
            pulumi.set(__self__, "init_container", init_container)
        if kafka_container is not None:
            pulumi.set(__self__, "kafka_container", kafka_container)
        if per_pod_ingress is not None:
            pulumi.set(__self__, "per_pod_ingress", per_pod_ingress)
        if per_pod_route is not None:
            pulumi.set(__self__, "per_pod_route", per_pod_route)
        if per_pod_service is not None:
            pulumi.set(__self__, "per_pod_service", per_pod_service)
        if persistent_volume_claim is not None:
            pulumi.set(__self__, "persistent_volume_claim", persistent_volume_claim)
        if pod is not None:
            pulumi.set(__self__, "pod", pod)
        if pod_disruption_budget is not None:
            pulumi.set(__self__, "pod_disruption_budget", pod_disruption_budget)
        if statefulset is not None:
            pulumi.set(__self__, "statefulset", statefulset)
        if tls_sidecar_container is not None:
            pulumi.set(__self__, "tls_sidecar_container", tls_sidecar_container)

    @property
    @pulumi.getter(name="bootstrapService")
    def bootstrap_service(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplateBootstrapServiceArgs']]:
        """
        Template for Kafka bootstrap `Service`.
        """
        return pulumi.get(self, "bootstrap_service")

    @bootstrap_service.setter
    def bootstrap_service(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplateBootstrapServiceArgs']]):
        pulumi.set(self, "bootstrap_service", value)

    @property
    @pulumi.getter(name="brokersService")
    def brokers_service(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplateBrokersServiceArgs']]:
        """
        Template for Kafka broker `Service`.
        """
        return pulumi.get(self, "brokers_service")

    @brokers_service.setter
    def brokers_service(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplateBrokersServiceArgs']]):
        pulumi.set(self, "brokers_service", value)

    @property
    @pulumi.getter(name="externalBootstrapIngress")
    def external_bootstrap_ingress(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplateExternalBootstrapIngressArgs']]:
        """
        Template for Kafka external bootstrap `Ingress`.
        """
        return pulumi.get(self, "external_bootstrap_ingress")

    @external_bootstrap_ingress.setter
    def external_bootstrap_ingress(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplateExternalBootstrapIngressArgs']]):
        pulumi.set(self, "external_bootstrap_ingress", value)

    @property
    @pulumi.getter(name="externalBootstrapRoute")
    def external_bootstrap_route(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplateExternalBootstrapRouteArgs']]:
        """
        Template for Kafka external bootstrap `Route`.
        """
        return pulumi.get(self, "external_bootstrap_route")

    @external_bootstrap_route.setter
    def external_bootstrap_route(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplateExternalBootstrapRouteArgs']]):
        pulumi.set(self, "external_bootstrap_route", value)

    @property
    @pulumi.getter(name="externalBootstrapService")
    def external_bootstrap_service(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplateExternalBootstrapServiceArgs']]:
        """
        Template for Kafka external bootstrap `Service`.
        """
        return pulumi.get(self, "external_bootstrap_service")

    @external_bootstrap_service.setter
    def external_bootstrap_service(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplateExternalBootstrapServiceArgs']]):
        pulumi.set(self, "external_bootstrap_service", value)

    @property
    @pulumi.getter(name="initContainer")
    def init_container(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplateInitContainerArgs']]:
        """
        Template for the Kafka init container.
        """
        return pulumi.get(self, "init_container")

    @init_container.setter
    def init_container(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplateInitContainerArgs']]):
        pulumi.set(self, "init_container", value)

    @property
    @pulumi.getter(name="kafkaContainer")
    def kafka_container(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplateKafkaContainerArgs']]:
        """
        Template for the Kafka broker container.
        """
        return pulumi.get(self, "kafka_container")

    @kafka_container.setter
    def kafka_container(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplateKafkaContainerArgs']]):
        pulumi.set(self, "kafka_container", value)

    @property
    @pulumi.getter(name="perPodIngress")
    def per_pod_ingress(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplatePerPodIngressArgs']]:
        """
        Template for Kafka per-pod `Ingress` used for access from outside of Kubernetes.
        """
        return pulumi.get(self, "per_pod_ingress")

    @per_pod_ingress.setter
    def per_pod_ingress(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplatePerPodIngressArgs']]):
        pulumi.set(self, "per_pod_ingress", value)

    @property
    @pulumi.getter(name="perPodRoute")
    def per_pod_route(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplatePerPodRouteArgs']]:
        """
        Template for Kafka per-pod `Routes` used for access from outside of OpenShift.
        """
        return pulumi.get(self, "per_pod_route")

    @per_pod_route.setter
    def per_pod_route(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplatePerPodRouteArgs']]):
        pulumi.set(self, "per_pod_route", value)

    @property
    @pulumi.getter(name="perPodService")
    def per_pod_service(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplatePerPodServiceArgs']]:
        """
        Template for Kafka per-pod `Services` used for access from outside of Kubernetes.
        """
        return pulumi.get(self, "per_pod_service")

    @per_pod_service.setter
    def per_pod_service(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplatePerPodServiceArgs']]):
        pulumi.set(self, "per_pod_service", value)

    @property
    @pulumi.getter(name="persistentVolumeClaim")
    def persistent_volume_claim(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplatePersistentVolumeClaimArgs']]:
        """
        Template for all Kafka `PersistentVolumeClaims`.
        """
        return pulumi.get(self, "persistent_volume_claim")

    @persistent_volume_claim.setter
    def persistent_volume_claim(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplatePersistentVolumeClaimArgs']]):
        pulumi.set(self, "persistent_volume_claim", value)

    @property
    @pulumi.getter
    def pod(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplatePodArgs']]:
        """
        Template for Kafka `Pods`.
        """
        return pulumi.get(self, "pod")

    @pod.setter
    def pod(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplatePodArgs']]):
        pulumi.set(self, "pod", value)

    @property
    @pulumi.getter(name="podDisruptionBudget")
    def pod_disruption_budget(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplatePodDisruptionBudgetArgs']]:
        """
        Template for Kafka `PodDisruptionBudget`.
        """
        return pulumi.get(self, "pod_disruption_budget")

    @pod_disruption_budget.setter
    def pod_disruption_budget(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplatePodDisruptionBudgetArgs']]):
        pulumi.set(self, "pod_disruption_budget", value)

    @property
    @pulumi.getter
    def statefulset(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplateStatefulsetArgs']]:
        """
        Template for Kafka `StatefulSet`.
        """
        return pulumi.get(self, "statefulset")

    @statefulset.setter
    def statefulset(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplateStatefulsetArgs']]):
        pulumi.set(self, "statefulset", value)

    @property
    @pulumi.getter(name="tlsSidecarContainer")
    def tls_sidecar_container(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplateTlsSidecarContainerArgs']]:
        """
        Template for the Kafka broker TLS sidecar container.
        """
        return pulumi.get(self, "tls_sidecar_container")

    @tls_sidecar_container.setter
    def tls_sidecar_container(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplateTlsSidecarContainerArgs']]):
        pulumi.set(self, "tls_sidecar_container", value)


@pulumi.input_type
class KafkaSpecKafkaTemplateBootstrapServiceArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input['KafkaSpecKafkaTemplateBootstrapServiceMetadataArgs']] = None):
        """
        Template for Kafka bootstrap `Service`.
        :param pulumi.Input['KafkaSpecKafkaTemplateBootstrapServiceMetadataArgs'] metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplateBootstrapServiceMetadataArgs']]:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplateBootstrapServiceMetadataArgs']]):
        pulumi.set(self, "metadata", value)


@pulumi.input_type
class KafkaSpecKafkaTemplateBootstrapServiceMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Metadata applied to the resource.
        :param pulumi.Input[Mapping[str, Any]] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param pulumi.Input[Mapping[str, Any]] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class KafkaSpecKafkaTemplateBrokersServiceArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input['KafkaSpecKafkaTemplateBrokersServiceMetadataArgs']] = None):
        """
        Template for Kafka broker `Service`.
        :param pulumi.Input['KafkaSpecKafkaTemplateBrokersServiceMetadataArgs'] metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplateBrokersServiceMetadataArgs']]:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplateBrokersServiceMetadataArgs']]):
        pulumi.set(self, "metadata", value)


@pulumi.input_type
class KafkaSpecKafkaTemplateBrokersServiceMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Metadata applied to the resource.
        :param pulumi.Input[Mapping[str, Any]] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param pulumi.Input[Mapping[str, Any]] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class KafkaSpecKafkaTemplateExternalBootstrapIngressArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input['KafkaSpecKafkaTemplateExternalBootstrapIngressMetadataArgs']] = None):
        """
        Template for Kafka external bootstrap `Ingress`.
        :param pulumi.Input['KafkaSpecKafkaTemplateExternalBootstrapIngressMetadataArgs'] metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplateExternalBootstrapIngressMetadataArgs']]:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplateExternalBootstrapIngressMetadataArgs']]):
        pulumi.set(self, "metadata", value)


@pulumi.input_type
class KafkaSpecKafkaTemplateExternalBootstrapIngressMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Metadata applied to the resource.
        :param pulumi.Input[Mapping[str, Any]] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param pulumi.Input[Mapping[str, Any]] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class KafkaSpecKafkaTemplateExternalBootstrapRouteArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input['KafkaSpecKafkaTemplateExternalBootstrapRouteMetadataArgs']] = None):
        """
        Template for Kafka external bootstrap `Route`.
        :param pulumi.Input['KafkaSpecKafkaTemplateExternalBootstrapRouteMetadataArgs'] metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplateExternalBootstrapRouteMetadataArgs']]:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplateExternalBootstrapRouteMetadataArgs']]):
        pulumi.set(self, "metadata", value)


@pulumi.input_type
class KafkaSpecKafkaTemplateExternalBootstrapRouteMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Metadata applied to the resource.
        :param pulumi.Input[Mapping[str, Any]] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param pulumi.Input[Mapping[str, Any]] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class KafkaSpecKafkaTemplateExternalBootstrapServiceArgs:
    def __init__(__self__, *,
                 external_traffic_policy: Optional[pulumi.Input[str]] = None,
                 load_balancer_source_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 metadata: Optional[pulumi.Input['KafkaSpecKafkaTemplateExternalBootstrapServiceMetadataArgs']] = None):
        """
        Template for Kafka external bootstrap `Service`.
        :param pulumi.Input[str] external_traffic_policy: Specifies whether the service routes external traffic to node-local or cluster-wide endpoints. `Cluster` may cause a second hop to another node and obscures the client source IP. `Local` avoids a second hop for LoadBalancer and Nodeport type services and preserves the client source IP (when supported by the infrastructure). If unspecified, Kubernetes will use `Cluster` as the default.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] load_balancer_source_ranges: A list of CIDR ranges (for example `10.0.0.0/8` or `130.211.204.1/32`) from which clients can connect to load balancer type listeners. If supported by the platform, traffic through the loadbalancer is restricted to the specified CIDR ranges. This field is applicable only for loadbalancer type services and is ignored if the cloud provider does not support the feature. For more information, see https://v1-17.docs.kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/. 
        :param pulumi.Input['KafkaSpecKafkaTemplateExternalBootstrapServiceMetadataArgs'] metadata: Metadata applied to the resource.
        """
        if external_traffic_policy is not None:
            pulumi.set(__self__, "external_traffic_policy", external_traffic_policy)
        if load_balancer_source_ranges is not None:
            pulumi.set(__self__, "load_balancer_source_ranges", load_balancer_source_ranges)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter(name="externalTrafficPolicy")
    def external_traffic_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies whether the service routes external traffic to node-local or cluster-wide endpoints. `Cluster` may cause a second hop to another node and obscures the client source IP. `Local` avoids a second hop for LoadBalancer and Nodeport type services and preserves the client source IP (when supported by the infrastructure). If unspecified, Kubernetes will use `Cluster` as the default.
        """
        return pulumi.get(self, "external_traffic_policy")

    @external_traffic_policy.setter
    def external_traffic_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "external_traffic_policy", value)

    @property
    @pulumi.getter(name="loadBalancerSourceRanges")
    def load_balancer_source_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of CIDR ranges (for example `10.0.0.0/8` or `130.211.204.1/32`) from which clients can connect to load balancer type listeners. If supported by the platform, traffic through the loadbalancer is restricted to the specified CIDR ranges. This field is applicable only for loadbalancer type services and is ignored if the cloud provider does not support the feature. For more information, see https://v1-17.docs.kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/. 
        """
        return pulumi.get(self, "load_balancer_source_ranges")

    @load_balancer_source_ranges.setter
    def load_balancer_source_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "load_balancer_source_ranges", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplateExternalBootstrapServiceMetadataArgs']]:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplateExternalBootstrapServiceMetadataArgs']]):
        pulumi.set(self, "metadata", value)


@pulumi.input_type
class KafkaSpecKafkaTemplateExternalBootstrapServiceMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Metadata applied to the resource.
        :param pulumi.Input[Mapping[str, Any]] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param pulumi.Input[Mapping[str, Any]] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class KafkaSpecKafkaTemplateInitContainerArgs:
    def __init__(__self__, *,
                 env: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplateInitContainerEnvArgs']]]] = None,
                 security_context: Optional[pulumi.Input['KafkaSpecKafkaTemplateInitContainerSecurityContextArgs']] = None):
        """
        Template for the Kafka init container.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplateInitContainerEnvArgs']]] env: Environment variables which should be applied to the container.
        :param pulumi.Input['KafkaSpecKafkaTemplateInitContainerSecurityContextArgs'] security_context: Security context for the container.
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)

    @property
    @pulumi.getter
    def env(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplateInitContainerEnvArgs']]]]:
        """
        Environment variables which should be applied to the container.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplateInitContainerEnvArgs']]]]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplateInitContainerSecurityContextArgs']]:
        """
        Security context for the container.
        """
        return pulumi.get(self, "security_context")

    @security_context.setter
    def security_context(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplateInitContainerSecurityContextArgs']]):
        pulumi.set(self, "security_context", value)


@pulumi.input_type
class KafkaSpecKafkaTemplateInitContainerEnvArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The environment variable key.
        :param pulumi.Input[str] value: The environment variable value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The environment variable key.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The environment variable value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaSpecKafkaTemplateInitContainerSecurityContextArgs:
    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[pulumi.Input[bool]] = None,
                 capabilities: Optional[pulumi.Input['KafkaSpecKafkaTemplateInitContainerSecurityContextCapabilitiesArgs']] = None,
                 privileged: Optional[pulumi.Input[bool]] = None,
                 proc_mount: Optional[pulumi.Input[str]] = None,
                 read_only_root_filesystem: Optional[pulumi.Input[bool]] = None,
                 run_as_group: Optional[pulumi.Input[int]] = None,
                 run_as_non_root: Optional[pulumi.Input[bool]] = None,
                 run_as_user: Optional[pulumi.Input[int]] = None,
                 se_linux_options: Optional[pulumi.Input['KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptionsArgs']] = None,
                 windows_options: Optional[pulumi.Input['KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptionsArgs']] = None):
        """
        Security context for the container.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if proc_mount is not None:
            pulumi.set(__self__, "proc_mount", proc_mount)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "allow_privilege_escalation")

    @allow_privilege_escalation.setter
    def allow_privilege_escalation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_privilege_escalation", value)

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplateInitContainerSecurityContextCapabilitiesArgs']]:
        return pulumi.get(self, "capabilities")

    @capabilities.setter
    def capabilities(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplateInitContainerSecurityContextCapabilitiesArgs']]):
        pulumi.set(self, "capabilities", value)

    @property
    @pulumi.getter
    def privileged(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "privileged")

    @privileged.setter
    def privileged(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "privileged", value)

    @property
    @pulumi.getter(name="procMount")
    def proc_mount(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "proc_mount")

    @proc_mount.setter
    def proc_mount(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proc_mount", value)

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "read_only_root_filesystem")

    @read_only_root_filesystem.setter
    def read_only_root_filesystem(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "read_only_root_filesystem", value)

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_group")

    @run_as_group.setter
    def run_as_group(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_group", value)

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "run_as_non_root")

    @run_as_non_root.setter
    def run_as_non_root(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_as_non_root", value)

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_user")

    @run_as_user.setter
    def run_as_user(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_user", value)

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptionsArgs']]:
        return pulumi.get(self, "se_linux_options")

    @se_linux_options.setter
    def se_linux_options(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptionsArgs']]):
        pulumi.set(self, "se_linux_options", value)

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptionsArgs']]:
        return pulumi.get(self, "windows_options")

    @windows_options.setter
    def windows_options(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptionsArgs']]):
        pulumi.set(self, "windows_options", value)


@pulumi.input_type
class KafkaSpecKafkaTemplateInitContainerSecurityContextCapabilitiesArgs:
    def __init__(__self__, *,
                 add: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 drop: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)

    @property
    @pulumi.getter
    def add(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "add")

    @add.setter
    def add(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "add", value)

    @property
    @pulumi.getter
    def drop(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "drop")

    @drop.setter
    def drop(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "drop", value)


@pulumi.input_type
class KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptionsArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


@pulumi.input_type
class KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptionsArgs:
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[pulumi.Input[str]] = None,
                 gmsa_credential_spec_name: Optional[pulumi.Input[str]] = None,
                 run_as_user_name: Optional[pulumi.Input[str]] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec")

    @gmsa_credential_spec.setter
    def gmsa_credential_spec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec", value)

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @gmsa_credential_spec_name.setter
    def gmsa_credential_spec_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec_name", value)

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "run_as_user_name")

    @run_as_user_name.setter
    def run_as_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "run_as_user_name", value)


@pulumi.input_type
class KafkaSpecKafkaTemplateKafkaContainerArgs:
    def __init__(__self__, *,
                 env: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplateKafkaContainerEnvArgs']]]] = None,
                 security_context: Optional[pulumi.Input['KafkaSpecKafkaTemplateKafkaContainerSecurityContextArgs']] = None):
        """
        Template for the Kafka broker container.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplateKafkaContainerEnvArgs']]] env: Environment variables which should be applied to the container.
        :param pulumi.Input['KafkaSpecKafkaTemplateKafkaContainerSecurityContextArgs'] security_context: Security context for the container.
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)

    @property
    @pulumi.getter
    def env(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplateKafkaContainerEnvArgs']]]]:
        """
        Environment variables which should be applied to the container.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplateKafkaContainerEnvArgs']]]]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplateKafkaContainerSecurityContextArgs']]:
        """
        Security context for the container.
        """
        return pulumi.get(self, "security_context")

    @security_context.setter
    def security_context(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplateKafkaContainerSecurityContextArgs']]):
        pulumi.set(self, "security_context", value)


@pulumi.input_type
class KafkaSpecKafkaTemplateKafkaContainerEnvArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The environment variable key.
        :param pulumi.Input[str] value: The environment variable value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The environment variable key.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The environment variable value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaSpecKafkaTemplateKafkaContainerSecurityContextArgs:
    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[pulumi.Input[bool]] = None,
                 capabilities: Optional[pulumi.Input['KafkaSpecKafkaTemplateKafkaContainerSecurityContextCapabilitiesArgs']] = None,
                 privileged: Optional[pulumi.Input[bool]] = None,
                 proc_mount: Optional[pulumi.Input[str]] = None,
                 read_only_root_filesystem: Optional[pulumi.Input[bool]] = None,
                 run_as_group: Optional[pulumi.Input[int]] = None,
                 run_as_non_root: Optional[pulumi.Input[bool]] = None,
                 run_as_user: Optional[pulumi.Input[int]] = None,
                 se_linux_options: Optional[pulumi.Input['KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptionsArgs']] = None,
                 windows_options: Optional[pulumi.Input['KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptionsArgs']] = None):
        """
        Security context for the container.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if proc_mount is not None:
            pulumi.set(__self__, "proc_mount", proc_mount)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "allow_privilege_escalation")

    @allow_privilege_escalation.setter
    def allow_privilege_escalation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_privilege_escalation", value)

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplateKafkaContainerSecurityContextCapabilitiesArgs']]:
        return pulumi.get(self, "capabilities")

    @capabilities.setter
    def capabilities(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplateKafkaContainerSecurityContextCapabilitiesArgs']]):
        pulumi.set(self, "capabilities", value)

    @property
    @pulumi.getter
    def privileged(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "privileged")

    @privileged.setter
    def privileged(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "privileged", value)

    @property
    @pulumi.getter(name="procMount")
    def proc_mount(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "proc_mount")

    @proc_mount.setter
    def proc_mount(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proc_mount", value)

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "read_only_root_filesystem")

    @read_only_root_filesystem.setter
    def read_only_root_filesystem(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "read_only_root_filesystem", value)

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_group")

    @run_as_group.setter
    def run_as_group(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_group", value)

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "run_as_non_root")

    @run_as_non_root.setter
    def run_as_non_root(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_as_non_root", value)

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_user")

    @run_as_user.setter
    def run_as_user(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_user", value)

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptionsArgs']]:
        return pulumi.get(self, "se_linux_options")

    @se_linux_options.setter
    def se_linux_options(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptionsArgs']]):
        pulumi.set(self, "se_linux_options", value)

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptionsArgs']]:
        return pulumi.get(self, "windows_options")

    @windows_options.setter
    def windows_options(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptionsArgs']]):
        pulumi.set(self, "windows_options", value)


@pulumi.input_type
class KafkaSpecKafkaTemplateKafkaContainerSecurityContextCapabilitiesArgs:
    def __init__(__self__, *,
                 add: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 drop: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)

    @property
    @pulumi.getter
    def add(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "add")

    @add.setter
    def add(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "add", value)

    @property
    @pulumi.getter
    def drop(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "drop")

    @drop.setter
    def drop(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "drop", value)


@pulumi.input_type
class KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptionsArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


@pulumi.input_type
class KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptionsArgs:
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[pulumi.Input[str]] = None,
                 gmsa_credential_spec_name: Optional[pulumi.Input[str]] = None,
                 run_as_user_name: Optional[pulumi.Input[str]] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec")

    @gmsa_credential_spec.setter
    def gmsa_credential_spec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec", value)

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @gmsa_credential_spec_name.setter
    def gmsa_credential_spec_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec_name", value)

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "run_as_user_name")

    @run_as_user_name.setter
    def run_as_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "run_as_user_name", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePerPodIngressArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input['KafkaSpecKafkaTemplatePerPodIngressMetadataArgs']] = None):
        """
        Template for Kafka per-pod `Ingress` used for access from outside of Kubernetes.
        :param pulumi.Input['KafkaSpecKafkaTemplatePerPodIngressMetadataArgs'] metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplatePerPodIngressMetadataArgs']]:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplatePerPodIngressMetadataArgs']]):
        pulumi.set(self, "metadata", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePerPodIngressMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Metadata applied to the resource.
        :param pulumi.Input[Mapping[str, Any]] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param pulumi.Input[Mapping[str, Any]] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePerPodRouteArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input['KafkaSpecKafkaTemplatePerPodRouteMetadataArgs']] = None):
        """
        Template for Kafka per-pod `Routes` used for access from outside of OpenShift.
        :param pulumi.Input['KafkaSpecKafkaTemplatePerPodRouteMetadataArgs'] metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplatePerPodRouteMetadataArgs']]:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplatePerPodRouteMetadataArgs']]):
        pulumi.set(self, "metadata", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePerPodRouteMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Metadata applied to the resource.
        :param pulumi.Input[Mapping[str, Any]] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param pulumi.Input[Mapping[str, Any]] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePerPodServiceArgs:
    def __init__(__self__, *,
                 external_traffic_policy: Optional[pulumi.Input[str]] = None,
                 load_balancer_source_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 metadata: Optional[pulumi.Input['KafkaSpecKafkaTemplatePerPodServiceMetadataArgs']] = None):
        """
        Template for Kafka per-pod `Services` used for access from outside of Kubernetes.
        :param pulumi.Input[str] external_traffic_policy: Specifies whether the service routes external traffic to node-local or cluster-wide endpoints. `Cluster` may cause a second hop to another node and obscures the client source IP. `Local` avoids a second hop for LoadBalancer and Nodeport type services and preserves the client source IP (when supported by the infrastructure). If unspecified, Kubernetes will use `Cluster` as the default.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] load_balancer_source_ranges: A list of CIDR ranges (for example `10.0.0.0/8` or `130.211.204.1/32`) from which clients can connect to load balancer type listeners. If supported by the platform, traffic through the loadbalancer is restricted to the specified CIDR ranges. This field is applicable only for loadbalancer type services and is ignored if the cloud provider does not support the feature. For more information, see https://v1-17.docs.kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/. 
        :param pulumi.Input['KafkaSpecKafkaTemplatePerPodServiceMetadataArgs'] metadata: Metadata applied to the resource.
        """
        if external_traffic_policy is not None:
            pulumi.set(__self__, "external_traffic_policy", external_traffic_policy)
        if load_balancer_source_ranges is not None:
            pulumi.set(__self__, "load_balancer_source_ranges", load_balancer_source_ranges)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter(name="externalTrafficPolicy")
    def external_traffic_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies whether the service routes external traffic to node-local or cluster-wide endpoints. `Cluster` may cause a second hop to another node and obscures the client source IP. `Local` avoids a second hop for LoadBalancer and Nodeport type services and preserves the client source IP (when supported by the infrastructure). If unspecified, Kubernetes will use `Cluster` as the default.
        """
        return pulumi.get(self, "external_traffic_policy")

    @external_traffic_policy.setter
    def external_traffic_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "external_traffic_policy", value)

    @property
    @pulumi.getter(name="loadBalancerSourceRanges")
    def load_balancer_source_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of CIDR ranges (for example `10.0.0.0/8` or `130.211.204.1/32`) from which clients can connect to load balancer type listeners. If supported by the platform, traffic through the loadbalancer is restricted to the specified CIDR ranges. This field is applicable only for loadbalancer type services and is ignored if the cloud provider does not support the feature. For more information, see https://v1-17.docs.kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/. 
        """
        return pulumi.get(self, "load_balancer_source_ranges")

    @load_balancer_source_ranges.setter
    def load_balancer_source_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "load_balancer_source_ranges", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplatePerPodServiceMetadataArgs']]:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplatePerPodServiceMetadataArgs']]):
        pulumi.set(self, "metadata", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePerPodServiceMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Metadata applied to the resource.
        :param pulumi.Input[Mapping[str, Any]] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param pulumi.Input[Mapping[str, Any]] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePersistentVolumeClaimArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input['KafkaSpecKafkaTemplatePersistentVolumeClaimMetadataArgs']] = None):
        """
        Template for all Kafka `PersistentVolumeClaims`.
        :param pulumi.Input['KafkaSpecKafkaTemplatePersistentVolumeClaimMetadataArgs'] metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplatePersistentVolumeClaimMetadataArgs']]:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplatePersistentVolumeClaimMetadataArgs']]):
        pulumi.set(self, "metadata", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePersistentVolumeClaimMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Metadata applied to the resource.
        :param pulumi.Input[Mapping[str, Any]] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param pulumi.Input[Mapping[str, Any]] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePodArgs:
    def __init__(__self__, *,
                 affinity: Optional[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityArgs']] = None,
                 host_aliases: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodHostAliasesArgs']]]] = None,
                 image_pull_secrets: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodImagePullSecretsArgs']]]] = None,
                 metadata: Optional[pulumi.Input['KafkaSpecKafkaTemplatePodMetadataArgs']] = None,
                 priority_class_name: Optional[pulumi.Input[str]] = None,
                 scheduler_name: Optional[pulumi.Input[str]] = None,
                 security_context: Optional[pulumi.Input['KafkaSpecKafkaTemplatePodSecurityContextArgs']] = None,
                 termination_grace_period_seconds: Optional[pulumi.Input[int]] = None,
                 tolerations: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodTolerationsArgs']]]] = None):
        """
        Template for Kafka `Pods`.
        :param pulumi.Input['KafkaSpecKafkaTemplatePodAffinityArgs'] affinity: The pod's affinity rules.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodHostAliasesArgs']]] host_aliases: The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodImagePullSecretsArgs']]] image_pull_secrets: List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
        :param pulumi.Input['KafkaSpecKafkaTemplatePodMetadataArgs'] metadata: Metadata applied to the resource.
        :param pulumi.Input[str] priority_class_name: The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
        :param pulumi.Input[str] scheduler_name: The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
        :param pulumi.Input['KafkaSpecKafkaTemplatePodSecurityContextArgs'] security_context: Configures pod-level security attributes and common container settings.
        :param pulumi.Input[int] termination_grace_period_seconds: The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodTolerationsArgs']]] tolerations: The pod's tolerations.
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if host_aliases is not None:
            pulumi.set(__self__, "host_aliases", host_aliases)
        if image_pull_secrets is not None:
            pulumi.set(__self__, "image_pull_secrets", image_pull_secrets)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if priority_class_name is not None:
            pulumi.set(__self__, "priority_class_name", priority_class_name)
        if scheduler_name is not None:
            pulumi.set(__self__, "scheduler_name", scheduler_name)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)

    @property
    @pulumi.getter
    def affinity(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityArgs']]:
        """
        The pod's affinity rules.
        """
        return pulumi.get(self, "affinity")

    @affinity.setter
    def affinity(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityArgs']]):
        pulumi.set(self, "affinity", value)

    @property
    @pulumi.getter(name="hostAliases")
    def host_aliases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodHostAliasesArgs']]]]:
        """
        The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
        """
        return pulumi.get(self, "host_aliases")

    @host_aliases.setter
    def host_aliases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodHostAliasesArgs']]]]):
        pulumi.set(self, "host_aliases", value)

    @property
    @pulumi.getter(name="imagePullSecrets")
    def image_pull_secrets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodImagePullSecretsArgs']]]]:
        """
        List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
        """
        return pulumi.get(self, "image_pull_secrets")

    @image_pull_secrets.setter
    def image_pull_secrets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodImagePullSecretsArgs']]]]):
        pulumi.set(self, "image_pull_secrets", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplatePodMetadataArgs']]:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplatePodMetadataArgs']]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter(name="priorityClassName")
    def priority_class_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
        """
        return pulumi.get(self, "priority_class_name")

    @priority_class_name.setter
    def priority_class_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "priority_class_name", value)

    @property
    @pulumi.getter(name="schedulerName")
    def scheduler_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
        """
        return pulumi.get(self, "scheduler_name")

    @scheduler_name.setter
    def scheduler_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scheduler_name", value)

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplatePodSecurityContextArgs']]:
        """
        Configures pod-level security attributes and common container settings.
        """
        return pulumi.get(self, "security_context")

    @security_context.setter
    def security_context(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplatePodSecurityContextArgs']]):
        pulumi.set(self, "security_context", value)

    @property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
        """
        return pulumi.get(self, "termination_grace_period_seconds")

    @termination_grace_period_seconds.setter
    def termination_grace_period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "termination_grace_period_seconds", value)

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodTolerationsArgs']]]]:
        """
        The pod's tolerations.
        """
        return pulumi.get(self, "tolerations")

    @tolerations.setter
    def tolerations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodTolerationsArgs']]]]):
        pulumi.set(self, "tolerations", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePodAffinityArgs:
    def __init__(__self__, *,
                 node_affinity: Optional[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityNodeAffinityArgs']] = None,
                 pod_affinity: Optional[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAffinityArgs']] = None,
                 pod_anti_affinity: Optional[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityArgs']] = None):
        """
        The pod's affinity rules.
        """
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityNodeAffinityArgs']]:
        return pulumi.get(self, "node_affinity")

    @node_affinity.setter
    def node_affinity(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityNodeAffinityArgs']]):
        pulumi.set(self, "node_affinity", value)

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAffinityArgs']]:
        return pulumi.get(self, "pod_affinity")

    @pod_affinity.setter
    def pod_affinity(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAffinityArgs']]):
        pulumi.set(self, "pod_affinity", value)

    @property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityArgs']]:
        return pulumi.get(self, "pod_anti_affinity")

    @pod_anti_affinity.setter
    def pod_anti_affinity(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityArgs']]):
        pulumi.set(self, "pod_anti_affinity", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePodAffinityNodeAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 preference: Optional[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']]:
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]] = None,
                 match_fields: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]]:
        return pulumi.get(self, "match_fields")

    @match_fields.setter
    def match_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]]):
        pulumi.set(self, "match_fields", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 node_selector_terms: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]] = None):
        if node_selector_terms is not None:
            pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]]:
        return pulumi.get(self, "node_selector_terms")

    @node_selector_terms.setter
    def node_selector_terms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]]):
        pulumi.set(self, "node_selector_terms", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]] = None,
                 match_fields: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]]:
        return pulumi.get(self, "match_fields")

    @match_fields.setter
    def match_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]]):
        pulumi.set(self, "match_fields", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePodAffinityPodAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 pod_affinity_term: Optional[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]:
        return pulumi.get(self, "pod_affinity_term")

    @pod_affinity_term.setter
    def pod_affinity_term(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]):
        pulumi.set(self, "pod_affinity_term", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 pod_affinity_term: Optional[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]:
        return pulumi.get(self, "pod_affinity_term")

    @pod_affinity_term.setter
    def pod_affinity_term(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]):
        pulumi.set(self, "pod_affinity_term", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePodDisruptionBudgetArgs:
    def __init__(__self__, *,
                 max_unavailable: Optional[pulumi.Input[int]] = None,
                 metadata: Optional[pulumi.Input['KafkaSpecKafkaTemplatePodDisruptionBudgetMetadataArgs']] = None):
        """
        Template for Kafka `PodDisruptionBudget`.
        :param pulumi.Input[int] max_unavailable: Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
        :param pulumi.Input['KafkaSpecKafkaTemplatePodDisruptionBudgetMetadataArgs'] metadata: Metadata to apply to the `PodDistruptionBugetTemplate` resource.
        """
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
        """
        return pulumi.get(self, "max_unavailable")

    @max_unavailable.setter
    def max_unavailable(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_unavailable", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplatePodDisruptionBudgetMetadataArgs']]:
        """
        Metadata to apply to the `PodDistruptionBugetTemplate` resource.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplatePodDisruptionBudgetMetadataArgs']]):
        pulumi.set(self, "metadata", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePodDisruptionBudgetMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Metadata to apply to the `PodDistruptionBugetTemplate` resource.
        :param pulumi.Input[Mapping[str, Any]] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param pulumi.Input[Mapping[str, Any]] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePodHostAliasesArgs:
    def __init__(__self__, *,
                 hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ip: Optional[pulumi.Input[str]] = None):
        if hostnames is not None:
            pulumi.set(__self__, "hostnames", hostnames)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def hostnames(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "hostnames")

    @hostnames.setter
    def hostnames(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hostnames", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePodImagePullSecretsArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePodMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Metadata applied to the resource.
        :param pulumi.Input[Mapping[str, Any]] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param pulumi.Input[Mapping[str, Any]] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePodSecurityContextArgs:
    def __init__(__self__, *,
                 fs_group: Optional[pulumi.Input[int]] = None,
                 fs_group_change_policy: Optional[pulumi.Input[str]] = None,
                 run_as_group: Optional[pulumi.Input[int]] = None,
                 run_as_non_root: Optional[pulumi.Input[bool]] = None,
                 run_as_user: Optional[pulumi.Input[int]] = None,
                 se_linux_options: Optional[pulumi.Input['KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptionsArgs']] = None,
                 supplemental_groups: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 sysctls: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodSecurityContextSysctlsArgs']]]] = None,
                 windows_options: Optional[pulumi.Input['KafkaSpecKafkaTemplatePodSecurityContextWindowsOptionsArgs']] = None):
        """
        Configures pod-level security attributes and common container settings.
        """
        if fs_group is not None:
            pulumi.set(__self__, "fs_group", fs_group)
        if fs_group_change_policy is not None:
            pulumi.set(__self__, "fs_group_change_policy", fs_group_change_policy)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if supplemental_groups is not None:
            pulumi.set(__self__, "supplemental_groups", supplemental_groups)
        if sysctls is not None:
            pulumi.set(__self__, "sysctls", sysctls)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="fsGroup")
    def fs_group(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "fs_group")

    @fs_group.setter
    def fs_group(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "fs_group", value)

    @property
    @pulumi.getter(name="fsGroupChangePolicy")
    def fs_group_change_policy(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "fs_group_change_policy")

    @fs_group_change_policy.setter
    def fs_group_change_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fs_group_change_policy", value)

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_group")

    @run_as_group.setter
    def run_as_group(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_group", value)

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "run_as_non_root")

    @run_as_non_root.setter
    def run_as_non_root(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_as_non_root", value)

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_user")

    @run_as_user.setter
    def run_as_user(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_user", value)

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptionsArgs']]:
        return pulumi.get(self, "se_linux_options")

    @se_linux_options.setter
    def se_linux_options(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptionsArgs']]):
        pulumi.set(self, "se_linux_options", value)

    @property
    @pulumi.getter(name="supplementalGroups")
    def supplemental_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        return pulumi.get(self, "supplemental_groups")

    @supplemental_groups.setter
    def supplemental_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "supplemental_groups", value)

    @property
    @pulumi.getter
    def sysctls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodSecurityContextSysctlsArgs']]]]:
        return pulumi.get(self, "sysctls")

    @sysctls.setter
    def sysctls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplatePodSecurityContextSysctlsArgs']]]]):
        pulumi.set(self, "sysctls", value)

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplatePodSecurityContextWindowsOptionsArgs']]:
        return pulumi.get(self, "windows_options")

    @windows_options.setter
    def windows_options(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplatePodSecurityContextWindowsOptionsArgs']]):
        pulumi.set(self, "windows_options", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptionsArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePodSecurityContextSysctlsArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePodSecurityContextWindowsOptionsArgs:
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[pulumi.Input[str]] = None,
                 gmsa_credential_spec_name: Optional[pulumi.Input[str]] = None,
                 run_as_user_name: Optional[pulumi.Input[str]] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec")

    @gmsa_credential_spec.setter
    def gmsa_credential_spec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec", value)

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @gmsa_credential_spec_name.setter
    def gmsa_credential_spec_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec_name", value)

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "run_as_user_name")

    @run_as_user_name.setter
    def run_as_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "run_as_user_name", value)


@pulumi.input_type
class KafkaSpecKafkaTemplatePodTolerationsArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 toleration_seconds: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if toleration_seconds is not None:
            pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "toleration_seconds")

    @toleration_seconds.setter
    def toleration_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "toleration_seconds", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaSpecKafkaTemplateStatefulsetArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input['KafkaSpecKafkaTemplateStatefulsetMetadataArgs']] = None,
                 pod_management_policy: Optional[pulumi.Input[str]] = None):
        """
        Template for Kafka `StatefulSet`.
        :param pulumi.Input['KafkaSpecKafkaTemplateStatefulsetMetadataArgs'] metadata: Metadata applied to the resource.
        :param pulumi.Input[str] pod_management_policy: PodManagementPolicy which will be used for this StatefulSet. Valid values are `Parallel` and `OrderedReady`. Defaults to `Parallel`.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if pod_management_policy is not None:
            pulumi.set(__self__, "pod_management_policy", pod_management_policy)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplateStatefulsetMetadataArgs']]:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplateStatefulsetMetadataArgs']]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter(name="podManagementPolicy")
    def pod_management_policy(self) -> Optional[pulumi.Input[str]]:
        """
        PodManagementPolicy which will be used for this StatefulSet. Valid values are `Parallel` and `OrderedReady`. Defaults to `Parallel`.
        """
        return pulumi.get(self, "pod_management_policy")

    @pod_management_policy.setter
    def pod_management_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pod_management_policy", value)


@pulumi.input_type
class KafkaSpecKafkaTemplateStatefulsetMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Metadata applied to the resource.
        :param pulumi.Input[Mapping[str, Any]] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param pulumi.Input[Mapping[str, Any]] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class KafkaSpecKafkaTemplateTlsSidecarContainerArgs:
    def __init__(__self__, *,
                 env: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplateTlsSidecarContainerEnvArgs']]]] = None,
                 security_context: Optional[pulumi.Input['KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextArgs']] = None):
        """
        Template for the Kafka broker TLS sidecar container.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplateTlsSidecarContainerEnvArgs']]] env: Environment variables which should be applied to the container.
        :param pulumi.Input['KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextArgs'] security_context: Security context for the container.
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)

    @property
    @pulumi.getter
    def env(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplateTlsSidecarContainerEnvArgs']]]]:
        """
        Environment variables which should be applied to the container.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecKafkaTemplateTlsSidecarContainerEnvArgs']]]]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextArgs']]:
        """
        Security context for the container.
        """
        return pulumi.get(self, "security_context")

    @security_context.setter
    def security_context(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextArgs']]):
        pulumi.set(self, "security_context", value)


@pulumi.input_type
class KafkaSpecKafkaTemplateTlsSidecarContainerEnvArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The environment variable key.
        :param pulumi.Input[str] value: The environment variable value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The environment variable key.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The environment variable value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextArgs:
    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[pulumi.Input[bool]] = None,
                 capabilities: Optional[pulumi.Input['KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextCapabilitiesArgs']] = None,
                 privileged: Optional[pulumi.Input[bool]] = None,
                 proc_mount: Optional[pulumi.Input[str]] = None,
                 read_only_root_filesystem: Optional[pulumi.Input[bool]] = None,
                 run_as_group: Optional[pulumi.Input[int]] = None,
                 run_as_non_root: Optional[pulumi.Input[bool]] = None,
                 run_as_user: Optional[pulumi.Input[int]] = None,
                 se_linux_options: Optional[pulumi.Input['KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextSeLinuxOptionsArgs']] = None,
                 windows_options: Optional[pulumi.Input['KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextWindowsOptionsArgs']] = None):
        """
        Security context for the container.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if proc_mount is not None:
            pulumi.set(__self__, "proc_mount", proc_mount)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "allow_privilege_escalation")

    @allow_privilege_escalation.setter
    def allow_privilege_escalation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_privilege_escalation", value)

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextCapabilitiesArgs']]:
        return pulumi.get(self, "capabilities")

    @capabilities.setter
    def capabilities(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextCapabilitiesArgs']]):
        pulumi.set(self, "capabilities", value)

    @property
    @pulumi.getter
    def privileged(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "privileged")

    @privileged.setter
    def privileged(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "privileged", value)

    @property
    @pulumi.getter(name="procMount")
    def proc_mount(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "proc_mount")

    @proc_mount.setter
    def proc_mount(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proc_mount", value)

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "read_only_root_filesystem")

    @read_only_root_filesystem.setter
    def read_only_root_filesystem(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "read_only_root_filesystem", value)

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_group")

    @run_as_group.setter
    def run_as_group(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_group", value)

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "run_as_non_root")

    @run_as_non_root.setter
    def run_as_non_root(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_as_non_root", value)

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_user")

    @run_as_user.setter
    def run_as_user(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_user", value)

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextSeLinuxOptionsArgs']]:
        return pulumi.get(self, "se_linux_options")

    @se_linux_options.setter
    def se_linux_options(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextSeLinuxOptionsArgs']]):
        pulumi.set(self, "se_linux_options", value)

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional[pulumi.Input['KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextWindowsOptionsArgs']]:
        return pulumi.get(self, "windows_options")

    @windows_options.setter
    def windows_options(self, value: Optional[pulumi.Input['KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextWindowsOptionsArgs']]):
        pulumi.set(self, "windows_options", value)


@pulumi.input_type
class KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextCapabilitiesArgs:
    def __init__(__self__, *,
                 add: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 drop: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)

    @property
    @pulumi.getter
    def add(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "add")

    @add.setter
    def add(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "add", value)

    @property
    @pulumi.getter
    def drop(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "drop")

    @drop.setter
    def drop(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "drop", value)


@pulumi.input_type
class KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextSeLinuxOptionsArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


@pulumi.input_type
class KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextWindowsOptionsArgs:
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[pulumi.Input[str]] = None,
                 gmsa_credential_spec_name: Optional[pulumi.Input[str]] = None,
                 run_as_user_name: Optional[pulumi.Input[str]] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec")

    @gmsa_credential_spec.setter
    def gmsa_credential_spec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec", value)

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @gmsa_credential_spec_name.setter
    def gmsa_credential_spec_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec_name", value)

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "run_as_user_name")

    @run_as_user_name.setter
    def run_as_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "run_as_user_name", value)


@pulumi.input_type
class KafkaSpecKafkaTlsSidecarArgs:
    def __init__(__self__, *,
                 image: Optional[pulumi.Input[str]] = None,
                 liveness_probe: Optional[pulumi.Input['KafkaSpecKafkaTlsSidecarLivenessProbeArgs']] = None,
                 log_level: Optional[pulumi.Input[str]] = None,
                 readiness_probe: Optional[pulumi.Input['KafkaSpecKafkaTlsSidecarReadinessProbeArgs']] = None,
                 resources: Optional[pulumi.Input['KafkaSpecKafkaTlsSidecarResourcesArgs']] = None):
        """
        TLS sidecar configuration.
        :param pulumi.Input[str] image: The docker image for the container.
        :param pulumi.Input['KafkaSpecKafkaTlsSidecarLivenessProbeArgs'] liveness_probe: Pod liveness checking.
        :param pulumi.Input[str] log_level: The log level for the TLS sidecar. Default value is `notice`.
        :param pulumi.Input['KafkaSpecKafkaTlsSidecarReadinessProbeArgs'] readiness_probe: Pod readiness checking.
        :param pulumi.Input['KafkaSpecKafkaTlsSidecarResourcesArgs'] resources: CPU and memory resources to reserve.
        """
        if image is not None:
            pulumi.set(__self__, "image", image)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        The docker image for the container.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional[pulumi.Input['KafkaSpecKafkaTlsSidecarLivenessProbeArgs']]:
        """
        Pod liveness checking.
        """
        return pulumi.get(self, "liveness_probe")

    @liveness_probe.setter
    def liveness_probe(self, value: Optional[pulumi.Input['KafkaSpecKafkaTlsSidecarLivenessProbeArgs']]):
        pulumi.set(self, "liveness_probe", value)

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[pulumi.Input[str]]:
        """
        The log level for the TLS sidecar. Default value is `notice`.
        """
        return pulumi.get(self, "log_level")

    @log_level.setter
    def log_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_level", value)

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional[pulumi.Input['KafkaSpecKafkaTlsSidecarReadinessProbeArgs']]:
        """
        Pod readiness checking.
        """
        return pulumi.get(self, "readiness_probe")

    @readiness_probe.setter
    def readiness_probe(self, value: Optional[pulumi.Input['KafkaSpecKafkaTlsSidecarReadinessProbeArgs']]):
        pulumi.set(self, "readiness_probe", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['KafkaSpecKafkaTlsSidecarResourcesArgs']]:
        """
        CPU and memory resources to reserve.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['KafkaSpecKafkaTlsSidecarResourcesArgs']]):
        pulumi.set(self, "resources", value)


@pulumi.input_type
class KafkaSpecKafkaTlsSidecarLivenessProbeArgs:
    def __init__(__self__, *,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 success_threshold: Optional[pulumi.Input[int]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        Pod liveness checking.
        :param pulumi.Input[int] failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param pulumi.Input[int] initial_delay_seconds: The initial delay before first the health is first checked.
        :param pulumi.Input[int] period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param pulumi.Input[int] success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param pulumi.Input[int] timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "success_threshold", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


@pulumi.input_type
class KafkaSpecKafkaTlsSidecarReadinessProbeArgs:
    def __init__(__self__, *,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 success_threshold: Optional[pulumi.Input[int]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        Pod readiness checking.
        :param pulumi.Input[int] failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param pulumi.Input[int] initial_delay_seconds: The initial delay before first the health is first checked.
        :param pulumi.Input[int] period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param pulumi.Input[int] success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param pulumi.Input[int] timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "success_threshold", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


@pulumi.input_type
class KafkaSpecKafkaTlsSidecarResourcesArgs:
    def __init__(__self__, *,
                 limits: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 requests: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        CPU and memory resources to reserve.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "limits", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "requests", value)


@pulumi.input_type
class KafkaSpecKafkaTolerationsArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 toleration_seconds: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if toleration_seconds is not None:
            pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "toleration_seconds")

    @toleration_seconds.setter
    def toleration_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "toleration_seconds", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaSpecTopicOperatorArgs:
    def __init__(__self__, *,
                 affinity: Optional[pulumi.Input['KafkaSpecTopicOperatorAffinityArgs']] = None,
                 image: Optional[pulumi.Input[str]] = None,
                 jvm_options: Optional[pulumi.Input['KafkaSpecTopicOperatorJvmOptionsArgs']] = None,
                 liveness_probe: Optional[pulumi.Input['KafkaSpecTopicOperatorLivenessProbeArgs']] = None,
                 logging: Optional[pulumi.Input['KafkaSpecTopicOperatorLoggingArgs']] = None,
                 readiness_probe: Optional[pulumi.Input['KafkaSpecTopicOperatorReadinessProbeArgs']] = None,
                 reconciliation_interval_seconds: Optional[pulumi.Input[int]] = None,
                 resources: Optional[pulumi.Input['KafkaSpecTopicOperatorResourcesArgs']] = None,
                 tls_sidecar: Optional[pulumi.Input['KafkaSpecTopicOperatorTlsSidecarArgs']] = None,
                 topic_metadata_max_attempts: Optional[pulumi.Input[int]] = None,
                 watched_namespace: Optional[pulumi.Input[str]] = None,
                 zookeeper_session_timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        Configuration of the Topic Operator.
        :param pulumi.Input['KafkaSpecTopicOperatorAffinityArgs'] affinity: Pod affinity rules.
        :param pulumi.Input[str] image: The image to use for the Topic Operator.
        :param pulumi.Input['KafkaSpecTopicOperatorJvmOptionsArgs'] jvm_options: JVM Options for pods.
        :param pulumi.Input['KafkaSpecTopicOperatorLivenessProbeArgs'] liveness_probe: Pod liveness checking.
        :param pulumi.Input['KafkaSpecTopicOperatorLoggingArgs'] logging: Logging configuration.
        :param pulumi.Input['KafkaSpecTopicOperatorReadinessProbeArgs'] readiness_probe: Pod readiness checking.
        :param pulumi.Input[int] reconciliation_interval_seconds: Interval between periodic reconciliations.
        :param pulumi.Input['KafkaSpecTopicOperatorResourcesArgs'] resources: CPU and memory resources to reserve.
        :param pulumi.Input['KafkaSpecTopicOperatorTlsSidecarArgs'] tls_sidecar: TLS sidecar configuration.
        :param pulumi.Input[int] topic_metadata_max_attempts: The number of attempts at getting topic metadata.
        :param pulumi.Input[str] watched_namespace: The namespace the Topic Operator should watch.
        :param pulumi.Input[int] zookeeper_session_timeout_seconds: Timeout for the ZooKeeper session.
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if jvm_options is not None:
            pulumi.set(__self__, "jvm_options", jvm_options)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if reconciliation_interval_seconds is not None:
            pulumi.set(__self__, "reconciliation_interval_seconds", reconciliation_interval_seconds)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if tls_sidecar is not None:
            pulumi.set(__self__, "tls_sidecar", tls_sidecar)
        if topic_metadata_max_attempts is not None:
            pulumi.set(__self__, "topic_metadata_max_attempts", topic_metadata_max_attempts)
        if watched_namespace is not None:
            pulumi.set(__self__, "watched_namespace", watched_namespace)
        if zookeeper_session_timeout_seconds is not None:
            pulumi.set(__self__, "zookeeper_session_timeout_seconds", zookeeper_session_timeout_seconds)

    @property
    @pulumi.getter
    def affinity(self) -> Optional[pulumi.Input['KafkaSpecTopicOperatorAffinityArgs']]:
        """
        Pod affinity rules.
        """
        return pulumi.get(self, "affinity")

    @affinity.setter
    def affinity(self, value: Optional[pulumi.Input['KafkaSpecTopicOperatorAffinityArgs']]):
        pulumi.set(self, "affinity", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        The image to use for the Topic Operator.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="jvmOptions")
    def jvm_options(self) -> Optional[pulumi.Input['KafkaSpecTopicOperatorJvmOptionsArgs']]:
        """
        JVM Options for pods.
        """
        return pulumi.get(self, "jvm_options")

    @jvm_options.setter
    def jvm_options(self, value: Optional[pulumi.Input['KafkaSpecTopicOperatorJvmOptionsArgs']]):
        pulumi.set(self, "jvm_options", value)

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional[pulumi.Input['KafkaSpecTopicOperatorLivenessProbeArgs']]:
        """
        Pod liveness checking.
        """
        return pulumi.get(self, "liveness_probe")

    @liveness_probe.setter
    def liveness_probe(self, value: Optional[pulumi.Input['KafkaSpecTopicOperatorLivenessProbeArgs']]):
        pulumi.set(self, "liveness_probe", value)

    @property
    @pulumi.getter
    def logging(self) -> Optional[pulumi.Input['KafkaSpecTopicOperatorLoggingArgs']]:
        """
        Logging configuration.
        """
        return pulumi.get(self, "logging")

    @logging.setter
    def logging(self, value: Optional[pulumi.Input['KafkaSpecTopicOperatorLoggingArgs']]):
        pulumi.set(self, "logging", value)

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional[pulumi.Input['KafkaSpecTopicOperatorReadinessProbeArgs']]:
        """
        Pod readiness checking.
        """
        return pulumi.get(self, "readiness_probe")

    @readiness_probe.setter
    def readiness_probe(self, value: Optional[pulumi.Input['KafkaSpecTopicOperatorReadinessProbeArgs']]):
        pulumi.set(self, "readiness_probe", value)

    @property
    @pulumi.getter(name="reconciliationIntervalSeconds")
    def reconciliation_interval_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Interval between periodic reconciliations.
        """
        return pulumi.get(self, "reconciliation_interval_seconds")

    @reconciliation_interval_seconds.setter
    def reconciliation_interval_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "reconciliation_interval_seconds", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['KafkaSpecTopicOperatorResourcesArgs']]:
        """
        CPU and memory resources to reserve.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['KafkaSpecTopicOperatorResourcesArgs']]):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter(name="tlsSidecar")
    def tls_sidecar(self) -> Optional[pulumi.Input['KafkaSpecTopicOperatorTlsSidecarArgs']]:
        """
        TLS sidecar configuration.
        """
        return pulumi.get(self, "tls_sidecar")

    @tls_sidecar.setter
    def tls_sidecar(self, value: Optional[pulumi.Input['KafkaSpecTopicOperatorTlsSidecarArgs']]):
        pulumi.set(self, "tls_sidecar", value)

    @property
    @pulumi.getter(name="topicMetadataMaxAttempts")
    def topic_metadata_max_attempts(self) -> Optional[pulumi.Input[int]]:
        """
        The number of attempts at getting topic metadata.
        """
        return pulumi.get(self, "topic_metadata_max_attempts")

    @topic_metadata_max_attempts.setter
    def topic_metadata_max_attempts(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "topic_metadata_max_attempts", value)

    @property
    @pulumi.getter(name="watchedNamespace")
    def watched_namespace(self) -> Optional[pulumi.Input[str]]:
        """
        The namespace the Topic Operator should watch.
        """
        return pulumi.get(self, "watched_namespace")

    @watched_namespace.setter
    def watched_namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "watched_namespace", value)

    @property
    @pulumi.getter(name="zookeeperSessionTimeoutSeconds")
    def zookeeper_session_timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Timeout for the ZooKeeper session.
        """
        return pulumi.get(self, "zookeeper_session_timeout_seconds")

    @zookeeper_session_timeout_seconds.setter
    def zookeeper_session_timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "zookeeper_session_timeout_seconds", value)


@pulumi.input_type
class KafkaSpecTopicOperatorAffinityArgs:
    def __init__(__self__, *,
                 node_affinity: Optional[pulumi.Input['KafkaSpecTopicOperatorAffinityNodeAffinityArgs']] = None,
                 pod_affinity: Optional[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAffinityArgs']] = None,
                 pod_anti_affinity: Optional[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAntiAffinityArgs']] = None):
        """
        Pod affinity rules.
        """
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional[pulumi.Input['KafkaSpecTopicOperatorAffinityNodeAffinityArgs']]:
        return pulumi.get(self, "node_affinity")

    @node_affinity.setter
    def node_affinity(self, value: Optional[pulumi.Input['KafkaSpecTopicOperatorAffinityNodeAffinityArgs']]):
        pulumi.set(self, "node_affinity", value)

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAffinityArgs']]:
        return pulumi.get(self, "pod_affinity")

    @pod_affinity.setter
    def pod_affinity(self, value: Optional[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAffinityArgs']]):
        pulumi.set(self, "pod_affinity", value)

    @property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAntiAffinityArgs']]:
        return pulumi.get(self, "pod_anti_affinity")

    @pod_anti_affinity.setter
    def pod_anti_affinity(self, value: Optional[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAntiAffinityArgs']]):
        pulumi.set(self, "pod_anti_affinity", value)


@pulumi.input_type
class KafkaSpecTopicOperatorAffinityNodeAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input['KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input['KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input['KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 preference: Optional[pulumi.Input['KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input['KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']]:
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input['KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]] = None,
                 match_fields: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]]:
        return pulumi.get(self, "match_fields")

    @match_fields.setter
    def match_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]]):
        pulumi.set(self, "match_fields", value)


@pulumi.input_type
class KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 node_selector_terms: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]] = None):
        if node_selector_terms is not None:
            pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]]:
        return pulumi.get(self, "node_selector_terms")

    @node_selector_terms.setter
    def node_selector_terms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]]):
        pulumi.set(self, "node_selector_terms", value)


@pulumi.input_type
class KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]] = None,
                 match_fields: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]]:
        return pulumi.get(self, "match_fields")

    @match_fields.setter
    def match_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]]):
        pulumi.set(self, "match_fields", value)


@pulumi.input_type
class KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecTopicOperatorAffinityPodAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 pod_affinity_term: Optional[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]:
        return pulumi.get(self, "pod_affinity_term")

    @pod_affinity_term.setter
    def pod_affinity_term(self, value: Optional[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]):
        pulumi.set(self, "pod_affinity_term", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecTopicOperatorAffinityPodAntiAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 pod_affinity_term: Optional[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]:
        return pulumi.get(self, "pod_affinity_term")

    @pod_affinity_term.setter
    def pod_affinity_term(self, value: Optional[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]):
        pulumi.set(self, "pod_affinity_term", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecTopicOperatorJvmOptionsArgs:
    def __init__(__self__, *,
                 __xx: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 __xms: Optional[pulumi.Input[str]] = None,
                 __xmx: Optional[pulumi.Input[str]] = None,
                 gc_logging_enabled: Optional[pulumi.Input[bool]] = None,
                 java_system_properties: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorJvmOptionsJavaSystemPropertiesArgs']]]] = None):
        """
        JVM Options for pods.
        :param pulumi.Input[Mapping[str, Any]] __xx: A map of -XX options to the JVM.
        :param pulumi.Input[str] __xms: -Xms option to to the JVM.
        :param pulumi.Input[str] __xmx: -Xmx option to to the JVM.
        :param pulumi.Input[bool] gc_logging_enabled: Specifies whether the Garbage Collection logging is enabled. The default is false.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorJvmOptionsJavaSystemPropertiesArgs']]] java_system_properties: A map of additional system properties which will be passed using the `-D` option to the JVM.
        """
        if __xx is not None:
            pulumi.set(__self__, "__xx", __xx)
        if __xms is not None:
            pulumi.set(__self__, "__xms", __xms)
        if __xmx is not None:
            pulumi.set(__self__, "__xmx", __xmx)
        if gc_logging_enabled is not None:
            pulumi.set(__self__, "gc_logging_enabled", gc_logging_enabled)
        if java_system_properties is not None:
            pulumi.set(__self__, "java_system_properties", java_system_properties)

    @property
    @pulumi.getter(name="-XX")
    def __xx(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        A map of -XX options to the JVM.
        """
        return pulumi.get(self, "__xx")

    @__xx.setter
    def __xx(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "__xx", value)

    @property
    @pulumi.getter(name="-Xms")
    def __xms(self) -> Optional[pulumi.Input[str]]:
        """
        -Xms option to to the JVM.
        """
        return pulumi.get(self, "__xms")

    @__xms.setter
    def __xms(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "__xms", value)

    @property
    @pulumi.getter(name="-Xmx")
    def __xmx(self) -> Optional[pulumi.Input[str]]:
        """
        -Xmx option to to the JVM.
        """
        return pulumi.get(self, "__xmx")

    @__xmx.setter
    def __xmx(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "__xmx", value)

    @property
    @pulumi.getter(name="gcLoggingEnabled")
    def gc_logging_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether the Garbage Collection logging is enabled. The default is false.
        """
        return pulumi.get(self, "gc_logging_enabled")

    @gc_logging_enabled.setter
    def gc_logging_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "gc_logging_enabled", value)

    @property
    @pulumi.getter(name="javaSystemProperties")
    def java_system_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorJvmOptionsJavaSystemPropertiesArgs']]]]:
        """
        A map of additional system properties which will be passed using the `-D` option to the JVM.
        """
        return pulumi.get(self, "java_system_properties")

    @java_system_properties.setter
    def java_system_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecTopicOperatorJvmOptionsJavaSystemPropertiesArgs']]]]):
        pulumi.set(self, "java_system_properties", value)


@pulumi.input_type
class KafkaSpecTopicOperatorJvmOptionsJavaSystemPropertiesArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The system property name.
        :param pulumi.Input[str] value: The system property value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The system property name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The system property value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaSpecTopicOperatorLivenessProbeArgs:
    def __init__(__self__, *,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 success_threshold: Optional[pulumi.Input[int]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        Pod liveness checking.
        :param pulumi.Input[int] failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param pulumi.Input[int] initial_delay_seconds: The initial delay before first the health is first checked.
        :param pulumi.Input[int] period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param pulumi.Input[int] success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param pulumi.Input[int] timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "success_threshold", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


@pulumi.input_type
class KafkaSpecTopicOperatorLoggingArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 loggers: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        Logging configuration.
        :param pulumi.Input[str] type: Logging type, must be either 'inline' or 'external'.
        :param pulumi.Input[Mapping[str, Any]] loggers: A Map from logger name to logger level.
        :param pulumi.Input[str] name: The name of the `ConfigMap` from which to get the logging configuration.
        """
        pulumi.set(__self__, "type", type)
        if loggers is not None:
            pulumi.set(__self__, "loggers", loggers)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Logging type, must be either 'inline' or 'external'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def loggers(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        A Map from logger name to logger level.
        """
        return pulumi.get(self, "loggers")

    @loggers.setter
    def loggers(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "loggers", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the `ConfigMap` from which to get the logging configuration.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class KafkaSpecTopicOperatorReadinessProbeArgs:
    def __init__(__self__, *,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 success_threshold: Optional[pulumi.Input[int]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        Pod readiness checking.
        :param pulumi.Input[int] failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param pulumi.Input[int] initial_delay_seconds: The initial delay before first the health is first checked.
        :param pulumi.Input[int] period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param pulumi.Input[int] success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param pulumi.Input[int] timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "success_threshold", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


@pulumi.input_type
class KafkaSpecTopicOperatorResourcesArgs:
    def __init__(__self__, *,
                 limits: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 requests: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        CPU and memory resources to reserve.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "limits", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "requests", value)


@pulumi.input_type
class KafkaSpecTopicOperatorTlsSidecarArgs:
    def __init__(__self__, *,
                 image: Optional[pulumi.Input[str]] = None,
                 liveness_probe: Optional[pulumi.Input['KafkaSpecTopicOperatorTlsSidecarLivenessProbeArgs']] = None,
                 log_level: Optional[pulumi.Input[str]] = None,
                 readiness_probe: Optional[pulumi.Input['KafkaSpecTopicOperatorTlsSidecarReadinessProbeArgs']] = None,
                 resources: Optional[pulumi.Input['KafkaSpecTopicOperatorTlsSidecarResourcesArgs']] = None):
        """
        TLS sidecar configuration.
        :param pulumi.Input[str] image: The docker image for the container.
        :param pulumi.Input['KafkaSpecTopicOperatorTlsSidecarLivenessProbeArgs'] liveness_probe: Pod liveness checking.
        :param pulumi.Input[str] log_level: The log level for the TLS sidecar. Default value is `notice`.
        :param pulumi.Input['KafkaSpecTopicOperatorTlsSidecarReadinessProbeArgs'] readiness_probe: Pod readiness checking.
        :param pulumi.Input['KafkaSpecTopicOperatorTlsSidecarResourcesArgs'] resources: CPU and memory resources to reserve.
        """
        if image is not None:
            pulumi.set(__self__, "image", image)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        The docker image for the container.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional[pulumi.Input['KafkaSpecTopicOperatorTlsSidecarLivenessProbeArgs']]:
        """
        Pod liveness checking.
        """
        return pulumi.get(self, "liveness_probe")

    @liveness_probe.setter
    def liveness_probe(self, value: Optional[pulumi.Input['KafkaSpecTopicOperatorTlsSidecarLivenessProbeArgs']]):
        pulumi.set(self, "liveness_probe", value)

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[pulumi.Input[str]]:
        """
        The log level for the TLS sidecar. Default value is `notice`.
        """
        return pulumi.get(self, "log_level")

    @log_level.setter
    def log_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_level", value)

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional[pulumi.Input['KafkaSpecTopicOperatorTlsSidecarReadinessProbeArgs']]:
        """
        Pod readiness checking.
        """
        return pulumi.get(self, "readiness_probe")

    @readiness_probe.setter
    def readiness_probe(self, value: Optional[pulumi.Input['KafkaSpecTopicOperatorTlsSidecarReadinessProbeArgs']]):
        pulumi.set(self, "readiness_probe", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['KafkaSpecTopicOperatorTlsSidecarResourcesArgs']]:
        """
        CPU and memory resources to reserve.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['KafkaSpecTopicOperatorTlsSidecarResourcesArgs']]):
        pulumi.set(self, "resources", value)


@pulumi.input_type
class KafkaSpecTopicOperatorTlsSidecarLivenessProbeArgs:
    def __init__(__self__, *,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 success_threshold: Optional[pulumi.Input[int]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        Pod liveness checking.
        :param pulumi.Input[int] failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param pulumi.Input[int] initial_delay_seconds: The initial delay before first the health is first checked.
        :param pulumi.Input[int] period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param pulumi.Input[int] success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param pulumi.Input[int] timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "success_threshold", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


@pulumi.input_type
class KafkaSpecTopicOperatorTlsSidecarReadinessProbeArgs:
    def __init__(__self__, *,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 success_threshold: Optional[pulumi.Input[int]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        Pod readiness checking.
        :param pulumi.Input[int] failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param pulumi.Input[int] initial_delay_seconds: The initial delay before first the health is first checked.
        :param pulumi.Input[int] period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param pulumi.Input[int] success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param pulumi.Input[int] timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "success_threshold", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


@pulumi.input_type
class KafkaSpecTopicOperatorTlsSidecarResourcesArgs:
    def __init__(__self__, *,
                 limits: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 requests: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        CPU and memory resources to reserve.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "limits", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "requests", value)


@pulumi.input_type
class KafkaSpecZookeeperArgs:
    def __init__(__self__, *,
                 replicas: pulumi.Input[int],
                 storage: pulumi.Input['KafkaSpecZookeeperStorageArgs'],
                 affinity: Optional[pulumi.Input['KafkaSpecZookeeperAffinityArgs']] = None,
                 config: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 image: Optional[pulumi.Input[str]] = None,
                 jvm_options: Optional[pulumi.Input['KafkaSpecZookeeperJvmOptionsArgs']] = None,
                 liveness_probe: Optional[pulumi.Input['KafkaSpecZookeeperLivenessProbeArgs']] = None,
                 logging: Optional[pulumi.Input['KafkaSpecZookeeperLoggingArgs']] = None,
                 metrics: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 readiness_probe: Optional[pulumi.Input['KafkaSpecZookeeperReadinessProbeArgs']] = None,
                 resources: Optional[pulumi.Input['KafkaSpecZookeeperResourcesArgs']] = None,
                 template: Optional[pulumi.Input['KafkaSpecZookeeperTemplateArgs']] = None,
                 tls_sidecar: Optional[pulumi.Input['KafkaSpecZookeeperTlsSidecarArgs']] = None,
                 tolerations: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTolerationsArgs']]]] = None):
        """
        Configuration of the ZooKeeper cluster.
        :param pulumi.Input[int] replicas: The number of pods in the cluster.
        :param pulumi.Input['KafkaSpecZookeeperStorageArgs'] storage: Storage configuration (disk). Cannot be updated.
        :param pulumi.Input['KafkaSpecZookeeperAffinityArgs'] affinity: The pod's affinity rules.
        :param pulumi.Input[Mapping[str, Any]] config: The ZooKeeper broker config. Properties with the following prefixes cannot be set: server., dataDir, dataLogDir, clientPort, authProvider, quorum.auth, requireClientAuthScheme, snapshot.trust.empty, standaloneEnabled, reconfigEnabled, 4lw.commands.whitelist, secureClientPort, ssl., serverCnxnFactory, sslQuorum (with the exception of: ssl.protocol, ssl.quorum.protocol, ssl.enabledProtocols, ssl.quorum.enabledProtocols, ssl.ciphersuites, ssl.quorum.ciphersuites, ssl.hostnameVerification, ssl.quorum.hostnameVerification).
        :param pulumi.Input[str] image: The docker image for the pods.
        :param pulumi.Input['KafkaSpecZookeeperJvmOptionsArgs'] jvm_options: JVM Options for pods.
        :param pulumi.Input['KafkaSpecZookeeperLivenessProbeArgs'] liveness_probe: Pod liveness checking.
        :param pulumi.Input['KafkaSpecZookeeperLoggingArgs'] logging: Logging configuration for ZooKeeper.
        :param pulumi.Input[Mapping[str, Any]] metrics: The Prometheus JMX Exporter configuration. See https://github.com/prometheus/jmx_exporter for details of the structure of this configuration.
        :param pulumi.Input['KafkaSpecZookeeperReadinessProbeArgs'] readiness_probe: Pod readiness checking.
        :param pulumi.Input['KafkaSpecZookeeperResourcesArgs'] resources: CPU and memory resources to reserve.
        :param pulumi.Input['KafkaSpecZookeeperTemplateArgs'] template: Template for ZooKeeper cluster resources. The template allows users to specify how are the `StatefulSet`, `Pods` and `Services` generated.
        :param pulumi.Input['KafkaSpecZookeeperTlsSidecarArgs'] tls_sidecar: TLS sidecar configuration. The TLS sidecar is not used anymore and this option will be ignored.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTolerationsArgs']]] tolerations: The pod's tolerations.
        """
        pulumi.set(__self__, "replicas", replicas)
        pulumi.set(__self__, "storage", storage)
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if jvm_options is not None:
            pulumi.set(__self__, "jvm_options", jvm_options)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if template is not None:
            pulumi.set(__self__, "template", template)
        if tls_sidecar is not None:
            pulumi.set(__self__, "tls_sidecar", tls_sidecar)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)

    @property
    @pulumi.getter
    def replicas(self) -> pulumi.Input[int]:
        """
        The number of pods in the cluster.
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: pulumi.Input[int]):
        pulumi.set(self, "replicas", value)

    @property
    @pulumi.getter
    def storage(self) -> pulumi.Input['KafkaSpecZookeeperStorageArgs']:
        """
        Storage configuration (disk). Cannot be updated.
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: pulumi.Input['KafkaSpecZookeeperStorageArgs']):
        pulumi.set(self, "storage", value)

    @property
    @pulumi.getter
    def affinity(self) -> Optional[pulumi.Input['KafkaSpecZookeeperAffinityArgs']]:
        """
        The pod's affinity rules.
        """
        return pulumi.get(self, "affinity")

    @affinity.setter
    def affinity(self, value: Optional[pulumi.Input['KafkaSpecZookeeperAffinityArgs']]):
        pulumi.set(self, "affinity", value)

    @property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        The ZooKeeper broker config. Properties with the following prefixes cannot be set: server., dataDir, dataLogDir, clientPort, authProvider, quorum.auth, requireClientAuthScheme, snapshot.trust.empty, standaloneEnabled, reconfigEnabled, 4lw.commands.whitelist, secureClientPort, ssl., serverCnxnFactory, sslQuorum (with the exception of: ssl.protocol, ssl.quorum.protocol, ssl.enabledProtocols, ssl.quorum.enabledProtocols, ssl.ciphersuites, ssl.quorum.ciphersuites, ssl.hostnameVerification, ssl.quorum.hostnameVerification).
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "config", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        The docker image for the pods.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="jvmOptions")
    def jvm_options(self) -> Optional[pulumi.Input['KafkaSpecZookeeperJvmOptionsArgs']]:
        """
        JVM Options for pods.
        """
        return pulumi.get(self, "jvm_options")

    @jvm_options.setter
    def jvm_options(self, value: Optional[pulumi.Input['KafkaSpecZookeeperJvmOptionsArgs']]):
        pulumi.set(self, "jvm_options", value)

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional[pulumi.Input['KafkaSpecZookeeperLivenessProbeArgs']]:
        """
        Pod liveness checking.
        """
        return pulumi.get(self, "liveness_probe")

    @liveness_probe.setter
    def liveness_probe(self, value: Optional[pulumi.Input['KafkaSpecZookeeperLivenessProbeArgs']]):
        pulumi.set(self, "liveness_probe", value)

    @property
    @pulumi.getter
    def logging(self) -> Optional[pulumi.Input['KafkaSpecZookeeperLoggingArgs']]:
        """
        Logging configuration for ZooKeeper.
        """
        return pulumi.get(self, "logging")

    @logging.setter
    def logging(self, value: Optional[pulumi.Input['KafkaSpecZookeeperLoggingArgs']]):
        pulumi.set(self, "logging", value)

    @property
    @pulumi.getter
    def metrics(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        The Prometheus JMX Exporter configuration. See https://github.com/prometheus/jmx_exporter for details of the structure of this configuration.
        """
        return pulumi.get(self, "metrics")

    @metrics.setter
    def metrics(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "metrics", value)

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional[pulumi.Input['KafkaSpecZookeeperReadinessProbeArgs']]:
        """
        Pod readiness checking.
        """
        return pulumi.get(self, "readiness_probe")

    @readiness_probe.setter
    def readiness_probe(self, value: Optional[pulumi.Input['KafkaSpecZookeeperReadinessProbeArgs']]):
        pulumi.set(self, "readiness_probe", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['KafkaSpecZookeeperResourcesArgs']]:
        """
        CPU and memory resources to reserve.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['KafkaSpecZookeeperResourcesArgs']]):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter
    def template(self) -> Optional[pulumi.Input['KafkaSpecZookeeperTemplateArgs']]:
        """
        Template for ZooKeeper cluster resources. The template allows users to specify how are the `StatefulSet`, `Pods` and `Services` generated.
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[pulumi.Input['KafkaSpecZookeeperTemplateArgs']]):
        pulumi.set(self, "template", value)

    @property
    @pulumi.getter(name="tlsSidecar")
    def tls_sidecar(self) -> Optional[pulumi.Input['KafkaSpecZookeeperTlsSidecarArgs']]:
        """
        TLS sidecar configuration. The TLS sidecar is not used anymore and this option will be ignored.
        """
        return pulumi.get(self, "tls_sidecar")

    @tls_sidecar.setter
    def tls_sidecar(self, value: Optional[pulumi.Input['KafkaSpecZookeeperTlsSidecarArgs']]):
        pulumi.set(self, "tls_sidecar", value)

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTolerationsArgs']]]]:
        """
        The pod's tolerations.
        """
        return pulumi.get(self, "tolerations")

    @tolerations.setter
    def tolerations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTolerationsArgs']]]]):
        pulumi.set(self, "tolerations", value)


@pulumi.input_type
class KafkaSpecZookeeperAffinityArgs:
    def __init__(__self__, *,
                 node_affinity: Optional[pulumi.Input['KafkaSpecZookeeperAffinityNodeAffinityArgs']] = None,
                 pod_affinity: Optional[pulumi.Input['KafkaSpecZookeeperAffinityPodAffinityArgs']] = None,
                 pod_anti_affinity: Optional[pulumi.Input['KafkaSpecZookeeperAffinityPodAntiAffinityArgs']] = None):
        """
        The pod's affinity rules.
        """
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional[pulumi.Input['KafkaSpecZookeeperAffinityNodeAffinityArgs']]:
        return pulumi.get(self, "node_affinity")

    @node_affinity.setter
    def node_affinity(self, value: Optional[pulumi.Input['KafkaSpecZookeeperAffinityNodeAffinityArgs']]):
        pulumi.set(self, "node_affinity", value)

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional[pulumi.Input['KafkaSpecZookeeperAffinityPodAffinityArgs']]:
        return pulumi.get(self, "pod_affinity")

    @pod_affinity.setter
    def pod_affinity(self, value: Optional[pulumi.Input['KafkaSpecZookeeperAffinityPodAffinityArgs']]):
        pulumi.set(self, "pod_affinity", value)

    @property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional[pulumi.Input['KafkaSpecZookeeperAffinityPodAntiAffinityArgs']]:
        return pulumi.get(self, "pod_anti_affinity")

    @pod_anti_affinity.setter
    def pod_anti_affinity(self, value: Optional[pulumi.Input['KafkaSpecZookeeperAffinityPodAntiAffinityArgs']]):
        pulumi.set(self, "pod_anti_affinity", value)


@pulumi.input_type
class KafkaSpecZookeeperAffinityNodeAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input['KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input['KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input['KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 preference: Optional[pulumi.Input['KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input['KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']]:
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input['KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]] = None,
                 match_fields: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]]:
        return pulumi.get(self, "match_fields")

    @match_fields.setter
    def match_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]]):
        pulumi.set(self, "match_fields", value)


@pulumi.input_type
class KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 node_selector_terms: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]] = None):
        if node_selector_terms is not None:
            pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]]:
        return pulumi.get(self, "node_selector_terms")

    @node_selector_terms.setter
    def node_selector_terms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]]):
        pulumi.set(self, "node_selector_terms", value)


@pulumi.input_type
class KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]] = None,
                 match_fields: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]]:
        return pulumi.get(self, "match_fields")

    @match_fields.setter
    def match_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]]):
        pulumi.set(self, "match_fields", value)


@pulumi.input_type
class KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecZookeeperAffinityPodAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 pod_affinity_term: Optional[pulumi.Input['KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional[pulumi.Input['KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]:
        return pulumi.get(self, "pod_affinity_term")

    @pod_affinity_term.setter
    def pod_affinity_term(self, value: Optional[pulumi.Input['KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]):
        pulumi.set(self, "pod_affinity_term", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecZookeeperAffinityPodAntiAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 pod_affinity_term: Optional[pulumi.Input['KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional[pulumi.Input['KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]:
        return pulumi.get(self, "pod_affinity_term")

    @pod_affinity_term.setter
    def pod_affinity_term(self, value: Optional[pulumi.Input['KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]):
        pulumi.set(self, "pod_affinity_term", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecZookeeperJvmOptionsArgs:
    def __init__(__self__, *,
                 __xx: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 __xms: Optional[pulumi.Input[str]] = None,
                 __xmx: Optional[pulumi.Input[str]] = None,
                 gc_logging_enabled: Optional[pulumi.Input[bool]] = None,
                 java_system_properties: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperJvmOptionsJavaSystemPropertiesArgs']]]] = None):
        """
        JVM Options for pods.
        :param pulumi.Input[Mapping[str, Any]] __xx: A map of -XX options to the JVM.
        :param pulumi.Input[str] __xms: -Xms option to to the JVM.
        :param pulumi.Input[str] __xmx: -Xmx option to to the JVM.
        :param pulumi.Input[bool] gc_logging_enabled: Specifies whether the Garbage Collection logging is enabled. The default is false.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperJvmOptionsJavaSystemPropertiesArgs']]] java_system_properties: A map of additional system properties which will be passed using the `-D` option to the JVM.
        """
        if __xx is not None:
            pulumi.set(__self__, "__xx", __xx)
        if __xms is not None:
            pulumi.set(__self__, "__xms", __xms)
        if __xmx is not None:
            pulumi.set(__self__, "__xmx", __xmx)
        if gc_logging_enabled is not None:
            pulumi.set(__self__, "gc_logging_enabled", gc_logging_enabled)
        if java_system_properties is not None:
            pulumi.set(__self__, "java_system_properties", java_system_properties)

    @property
    @pulumi.getter(name="-XX")
    def __xx(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        A map of -XX options to the JVM.
        """
        return pulumi.get(self, "__xx")

    @__xx.setter
    def __xx(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "__xx", value)

    @property
    @pulumi.getter(name="-Xms")
    def __xms(self) -> Optional[pulumi.Input[str]]:
        """
        -Xms option to to the JVM.
        """
        return pulumi.get(self, "__xms")

    @__xms.setter
    def __xms(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "__xms", value)

    @property
    @pulumi.getter(name="-Xmx")
    def __xmx(self) -> Optional[pulumi.Input[str]]:
        """
        -Xmx option to to the JVM.
        """
        return pulumi.get(self, "__xmx")

    @__xmx.setter
    def __xmx(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "__xmx", value)

    @property
    @pulumi.getter(name="gcLoggingEnabled")
    def gc_logging_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether the Garbage Collection logging is enabled. The default is false.
        """
        return pulumi.get(self, "gc_logging_enabled")

    @gc_logging_enabled.setter
    def gc_logging_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "gc_logging_enabled", value)

    @property
    @pulumi.getter(name="javaSystemProperties")
    def java_system_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperJvmOptionsJavaSystemPropertiesArgs']]]]:
        """
        A map of additional system properties which will be passed using the `-D` option to the JVM.
        """
        return pulumi.get(self, "java_system_properties")

    @java_system_properties.setter
    def java_system_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperJvmOptionsJavaSystemPropertiesArgs']]]]):
        pulumi.set(self, "java_system_properties", value)


@pulumi.input_type
class KafkaSpecZookeeperJvmOptionsJavaSystemPropertiesArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The system property name.
        :param pulumi.Input[str] value: The system property value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The system property name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The system property value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaSpecZookeeperLivenessProbeArgs:
    def __init__(__self__, *,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 success_threshold: Optional[pulumi.Input[int]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        Pod liveness checking.
        :param pulumi.Input[int] failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param pulumi.Input[int] initial_delay_seconds: The initial delay before first the health is first checked.
        :param pulumi.Input[int] period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param pulumi.Input[int] success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param pulumi.Input[int] timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "success_threshold", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


@pulumi.input_type
class KafkaSpecZookeeperLoggingArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 loggers: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        Logging configuration for ZooKeeper.
        :param pulumi.Input[str] type: Logging type, must be either 'inline' or 'external'.
        :param pulumi.Input[Mapping[str, Any]] loggers: A Map from logger name to logger level.
        :param pulumi.Input[str] name: The name of the `ConfigMap` from which to get the logging configuration.
        """
        pulumi.set(__self__, "type", type)
        if loggers is not None:
            pulumi.set(__self__, "loggers", loggers)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Logging type, must be either 'inline' or 'external'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def loggers(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        A Map from logger name to logger level.
        """
        return pulumi.get(self, "loggers")

    @loggers.setter
    def loggers(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "loggers", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the `ConfigMap` from which to get the logging configuration.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class KafkaSpecZookeeperReadinessProbeArgs:
    def __init__(__self__, *,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 success_threshold: Optional[pulumi.Input[int]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        Pod readiness checking.
        :param pulumi.Input[int] failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param pulumi.Input[int] initial_delay_seconds: The initial delay before first the health is first checked.
        :param pulumi.Input[int] period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param pulumi.Input[int] success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param pulumi.Input[int] timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "success_threshold", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


@pulumi.input_type
class KafkaSpecZookeeperResourcesArgs:
    def __init__(__self__, *,
                 limits: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 requests: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        CPU and memory resources to reserve.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "limits", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "requests", value)


@pulumi.input_type
class KafkaSpecZookeeperStorageArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 class_: Optional[pulumi.Input[str]] = None,
                 delete_claim: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[int]] = None,
                 overrides: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperStorageOverridesArgs']]]] = None,
                 selector: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 size: Optional[pulumi.Input[str]] = None,
                 size_limit: Optional[pulumi.Input[str]] = None):
        """
        Storage configuration (disk). Cannot be updated.
        :param pulumi.Input[str] type: Storage type, must be either 'ephemeral' or 'persistent-claim'.
        :param pulumi.Input[str] class_: The storage class to use for dynamic volume allocation.
        :param pulumi.Input[bool] delete_claim: Specifies if the persistent volume claim has to be deleted when the cluster is un-deployed.
        :param pulumi.Input[int] id: Storage identification number. It is mandatory only for storage volumes defined in a storage of type 'jbod'.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperStorageOverridesArgs']]] overrides: Overrides for individual brokers. The `overrides` field allows to specify a different configuration for different brokers.
        :param pulumi.Input[Mapping[str, Any]] selector: Specifies a specific persistent volume to use. It contains key:value pairs representing labels for selecting such a volume.
        :param pulumi.Input[str] size: When type=persistent-claim, defines the size of the persistent volume claim (i.e 1Gi). Mandatory when type=persistent-claim.
        :param pulumi.Input[str] size_limit: When type=ephemeral, defines the total amount of local storage required for this EmptyDir volume (for example 1Gi).
        """
        pulumi.set(__self__, "type", type)
        if class_ is not None:
            pulumi.set(__self__, "class_", class_)
        if delete_claim is not None:
            pulumi.set(__self__, "delete_claim", delete_claim)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if size_limit is not None:
            pulumi.set(__self__, "size_limit", size_limit)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Storage type, must be either 'ephemeral' or 'persistent-claim'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="class")
    def class_(self) -> Optional[pulumi.Input[str]]:
        """
        The storage class to use for dynamic volume allocation.
        """
        return pulumi.get(self, "class_")

    @class_.setter
    def class_(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "class_", value)

    @property
    @pulumi.getter(name="deleteClaim")
    def delete_claim(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies if the persistent volume claim has to be deleted when the cluster is un-deployed.
        """
        return pulumi.get(self, "delete_claim")

    @delete_claim.setter
    def delete_claim(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_claim", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[int]]:
        """
        Storage identification number. It is mandatory only for storage volumes defined in a storage of type 'jbod'.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperStorageOverridesArgs']]]]:
        """
        Overrides for individual brokers. The `overrides` field allows to specify a different configuration for different brokers.
        """
        return pulumi.get(self, "overrides")

    @overrides.setter
    def overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperStorageOverridesArgs']]]]):
        pulumi.set(self, "overrides", value)

    @property
    @pulumi.getter
    def selector(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Specifies a specific persistent volume to use. It contains key:value pairs representing labels for selecting such a volume.
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "selector", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[str]]:
        """
        When type=persistent-claim, defines the size of the persistent volume claim (i.e 1Gi). Mandatory when type=persistent-claim.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="sizeLimit")
    def size_limit(self) -> Optional[pulumi.Input[str]]:
        """
        When type=ephemeral, defines the total amount of local storage required for this EmptyDir volume (for example 1Gi).
        """
        return pulumi.get(self, "size_limit")

    @size_limit.setter
    def size_limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "size_limit", value)


@pulumi.input_type
class KafkaSpecZookeeperStorageOverridesArgs:
    def __init__(__self__, *,
                 broker: Optional[pulumi.Input[int]] = None,
                 class_: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] broker: Id of the kafka broker (broker identifier).
        :param pulumi.Input[str] class_: The storage class to use for dynamic volume allocation for this broker.
        """
        if broker is not None:
            pulumi.set(__self__, "broker", broker)
        if class_ is not None:
            pulumi.set(__self__, "class_", class_)

    @property
    @pulumi.getter
    def broker(self) -> Optional[pulumi.Input[int]]:
        """
        Id of the kafka broker (broker identifier).
        """
        return pulumi.get(self, "broker")

    @broker.setter
    def broker(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "broker", value)

    @property
    @pulumi.getter(name="class")
    def class_(self) -> Optional[pulumi.Input[str]]:
        """
        The storage class to use for dynamic volume allocation for this broker.
        """
        return pulumi.get(self, "class_")

    @class_.setter
    def class_(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "class_", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplateArgs:
    def __init__(__self__, *,
                 client_service: Optional[pulumi.Input['KafkaSpecZookeeperTemplateClientServiceArgs']] = None,
                 nodes_service: Optional[pulumi.Input['KafkaSpecZookeeperTemplateNodesServiceArgs']] = None,
                 persistent_volume_claim: Optional[pulumi.Input['KafkaSpecZookeeperTemplatePersistentVolumeClaimArgs']] = None,
                 pod: Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodArgs']] = None,
                 pod_disruption_budget: Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodDisruptionBudgetArgs']] = None,
                 statefulset: Optional[pulumi.Input['KafkaSpecZookeeperTemplateStatefulsetArgs']] = None,
                 tls_sidecar_container: Optional[pulumi.Input['KafkaSpecZookeeperTemplateTlsSidecarContainerArgs']] = None,
                 zookeeper_container: Optional[pulumi.Input['KafkaSpecZookeeperTemplateZookeeperContainerArgs']] = None):
        """
        Template for ZooKeeper cluster resources. The template allows users to specify how are the `StatefulSet`, `Pods` and `Services` generated.
        :param pulumi.Input['KafkaSpecZookeeperTemplateClientServiceArgs'] client_service: Template for ZooKeeper client `Service`.
        :param pulumi.Input['KafkaSpecZookeeperTemplateNodesServiceArgs'] nodes_service: Template for ZooKeeper nodes `Service`.
        :param pulumi.Input['KafkaSpecZookeeperTemplatePersistentVolumeClaimArgs'] persistent_volume_claim: Template for all ZooKeeper `PersistentVolumeClaims`.
        :param pulumi.Input['KafkaSpecZookeeperTemplatePodArgs'] pod: Template for ZooKeeper `Pods`.
        :param pulumi.Input['KafkaSpecZookeeperTemplatePodDisruptionBudgetArgs'] pod_disruption_budget: Template for ZooKeeper `PodDisruptionBudget`.
        :param pulumi.Input['KafkaSpecZookeeperTemplateStatefulsetArgs'] statefulset: Template for ZooKeeper `StatefulSet`.
        :param pulumi.Input['KafkaSpecZookeeperTemplateTlsSidecarContainerArgs'] tls_sidecar_container: Template for the Zookeeper server TLS sidecar container. The TLS sidecar is not used anymore and this option will be ignored.
        :param pulumi.Input['KafkaSpecZookeeperTemplateZookeeperContainerArgs'] zookeeper_container: Template for the ZooKeeper container.
        """
        if client_service is not None:
            pulumi.set(__self__, "client_service", client_service)
        if nodes_service is not None:
            pulumi.set(__self__, "nodes_service", nodes_service)
        if persistent_volume_claim is not None:
            pulumi.set(__self__, "persistent_volume_claim", persistent_volume_claim)
        if pod is not None:
            pulumi.set(__self__, "pod", pod)
        if pod_disruption_budget is not None:
            pulumi.set(__self__, "pod_disruption_budget", pod_disruption_budget)
        if statefulset is not None:
            pulumi.set(__self__, "statefulset", statefulset)
        if tls_sidecar_container is not None:
            pulumi.set(__self__, "tls_sidecar_container", tls_sidecar_container)
        if zookeeper_container is not None:
            pulumi.set(__self__, "zookeeper_container", zookeeper_container)

    @property
    @pulumi.getter(name="clientService")
    def client_service(self) -> Optional[pulumi.Input['KafkaSpecZookeeperTemplateClientServiceArgs']]:
        """
        Template for ZooKeeper client `Service`.
        """
        return pulumi.get(self, "client_service")

    @client_service.setter
    def client_service(self, value: Optional[pulumi.Input['KafkaSpecZookeeperTemplateClientServiceArgs']]):
        pulumi.set(self, "client_service", value)

    @property
    @pulumi.getter(name="nodesService")
    def nodes_service(self) -> Optional[pulumi.Input['KafkaSpecZookeeperTemplateNodesServiceArgs']]:
        """
        Template for ZooKeeper nodes `Service`.
        """
        return pulumi.get(self, "nodes_service")

    @nodes_service.setter
    def nodes_service(self, value: Optional[pulumi.Input['KafkaSpecZookeeperTemplateNodesServiceArgs']]):
        pulumi.set(self, "nodes_service", value)

    @property
    @pulumi.getter(name="persistentVolumeClaim")
    def persistent_volume_claim(self) -> Optional[pulumi.Input['KafkaSpecZookeeperTemplatePersistentVolumeClaimArgs']]:
        """
        Template for all ZooKeeper `PersistentVolumeClaims`.
        """
        return pulumi.get(self, "persistent_volume_claim")

    @persistent_volume_claim.setter
    def persistent_volume_claim(self, value: Optional[pulumi.Input['KafkaSpecZookeeperTemplatePersistentVolumeClaimArgs']]):
        pulumi.set(self, "persistent_volume_claim", value)

    @property
    @pulumi.getter
    def pod(self) -> Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodArgs']]:
        """
        Template for ZooKeeper `Pods`.
        """
        return pulumi.get(self, "pod")

    @pod.setter
    def pod(self, value: Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodArgs']]):
        pulumi.set(self, "pod", value)

    @property
    @pulumi.getter(name="podDisruptionBudget")
    def pod_disruption_budget(self) -> Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodDisruptionBudgetArgs']]:
        """
        Template for ZooKeeper `PodDisruptionBudget`.
        """
        return pulumi.get(self, "pod_disruption_budget")

    @pod_disruption_budget.setter
    def pod_disruption_budget(self, value: Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodDisruptionBudgetArgs']]):
        pulumi.set(self, "pod_disruption_budget", value)

    @property
    @pulumi.getter
    def statefulset(self) -> Optional[pulumi.Input['KafkaSpecZookeeperTemplateStatefulsetArgs']]:
        """
        Template for ZooKeeper `StatefulSet`.
        """
        return pulumi.get(self, "statefulset")

    @statefulset.setter
    def statefulset(self, value: Optional[pulumi.Input['KafkaSpecZookeeperTemplateStatefulsetArgs']]):
        pulumi.set(self, "statefulset", value)

    @property
    @pulumi.getter(name="tlsSidecarContainer")
    def tls_sidecar_container(self) -> Optional[pulumi.Input['KafkaSpecZookeeperTemplateTlsSidecarContainerArgs']]:
        """
        Template for the Zookeeper server TLS sidecar container. The TLS sidecar is not used anymore and this option will be ignored.
        """
        return pulumi.get(self, "tls_sidecar_container")

    @tls_sidecar_container.setter
    def tls_sidecar_container(self, value: Optional[pulumi.Input['KafkaSpecZookeeperTemplateTlsSidecarContainerArgs']]):
        pulumi.set(self, "tls_sidecar_container", value)

    @property
    @pulumi.getter(name="zookeeperContainer")
    def zookeeper_container(self) -> Optional[pulumi.Input['KafkaSpecZookeeperTemplateZookeeperContainerArgs']]:
        """
        Template for the ZooKeeper container.
        """
        return pulumi.get(self, "zookeeper_container")

    @zookeeper_container.setter
    def zookeeper_container(self, value: Optional[pulumi.Input['KafkaSpecZookeeperTemplateZookeeperContainerArgs']]):
        pulumi.set(self, "zookeeper_container", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplateClientServiceArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input['KafkaSpecZookeeperTemplateClientServiceMetadataArgs']] = None):
        """
        Template for ZooKeeper client `Service`.
        :param pulumi.Input['KafkaSpecZookeeperTemplateClientServiceMetadataArgs'] metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['KafkaSpecZookeeperTemplateClientServiceMetadataArgs']]:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['KafkaSpecZookeeperTemplateClientServiceMetadataArgs']]):
        pulumi.set(self, "metadata", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplateClientServiceMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Metadata applied to the resource.
        :param pulumi.Input[Mapping[str, Any]] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param pulumi.Input[Mapping[str, Any]] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplateNodesServiceArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input['KafkaSpecZookeeperTemplateNodesServiceMetadataArgs']] = None):
        """
        Template for ZooKeeper nodes `Service`.
        :param pulumi.Input['KafkaSpecZookeeperTemplateNodesServiceMetadataArgs'] metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['KafkaSpecZookeeperTemplateNodesServiceMetadataArgs']]:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['KafkaSpecZookeeperTemplateNodesServiceMetadataArgs']]):
        pulumi.set(self, "metadata", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplateNodesServiceMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Metadata applied to the resource.
        :param pulumi.Input[Mapping[str, Any]] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param pulumi.Input[Mapping[str, Any]] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplatePersistentVolumeClaimArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input['KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadataArgs']] = None):
        """
        Template for all ZooKeeper `PersistentVolumeClaims`.
        :param pulumi.Input['KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadataArgs'] metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadataArgs']]:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadataArgs']]):
        pulumi.set(self, "metadata", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Metadata applied to the resource.
        :param pulumi.Input[Mapping[str, Any]] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param pulumi.Input[Mapping[str, Any]] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplatePodArgs:
    def __init__(__self__, *,
                 affinity: Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityArgs']] = None,
                 host_aliases: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodHostAliasesArgs']]]] = None,
                 image_pull_secrets: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodImagePullSecretsArgs']]]] = None,
                 metadata: Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodMetadataArgs']] = None,
                 priority_class_name: Optional[pulumi.Input[str]] = None,
                 scheduler_name: Optional[pulumi.Input[str]] = None,
                 security_context: Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodSecurityContextArgs']] = None,
                 termination_grace_period_seconds: Optional[pulumi.Input[int]] = None,
                 tolerations: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodTolerationsArgs']]]] = None):
        """
        Template for ZooKeeper `Pods`.
        :param pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityArgs'] affinity: The pod's affinity rules.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodHostAliasesArgs']]] host_aliases: The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodImagePullSecretsArgs']]] image_pull_secrets: List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
        :param pulumi.Input['KafkaSpecZookeeperTemplatePodMetadataArgs'] metadata: Metadata applied to the resource.
        :param pulumi.Input[str] priority_class_name: The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
        :param pulumi.Input[str] scheduler_name: The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
        :param pulumi.Input['KafkaSpecZookeeperTemplatePodSecurityContextArgs'] security_context: Configures pod-level security attributes and common container settings.
        :param pulumi.Input[int] termination_grace_period_seconds: The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodTolerationsArgs']]] tolerations: The pod's tolerations.
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if host_aliases is not None:
            pulumi.set(__self__, "host_aliases", host_aliases)
        if image_pull_secrets is not None:
            pulumi.set(__self__, "image_pull_secrets", image_pull_secrets)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if priority_class_name is not None:
            pulumi.set(__self__, "priority_class_name", priority_class_name)
        if scheduler_name is not None:
            pulumi.set(__self__, "scheduler_name", scheduler_name)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)

    @property
    @pulumi.getter
    def affinity(self) -> Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityArgs']]:
        """
        The pod's affinity rules.
        """
        return pulumi.get(self, "affinity")

    @affinity.setter
    def affinity(self, value: Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityArgs']]):
        pulumi.set(self, "affinity", value)

    @property
    @pulumi.getter(name="hostAliases")
    def host_aliases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodHostAliasesArgs']]]]:
        """
        The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
        """
        return pulumi.get(self, "host_aliases")

    @host_aliases.setter
    def host_aliases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodHostAliasesArgs']]]]):
        pulumi.set(self, "host_aliases", value)

    @property
    @pulumi.getter(name="imagePullSecrets")
    def image_pull_secrets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodImagePullSecretsArgs']]]]:
        """
        List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
        """
        return pulumi.get(self, "image_pull_secrets")

    @image_pull_secrets.setter
    def image_pull_secrets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodImagePullSecretsArgs']]]]):
        pulumi.set(self, "image_pull_secrets", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodMetadataArgs']]:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodMetadataArgs']]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter(name="priorityClassName")
    def priority_class_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
        """
        return pulumi.get(self, "priority_class_name")

    @priority_class_name.setter
    def priority_class_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "priority_class_name", value)

    @property
    @pulumi.getter(name="schedulerName")
    def scheduler_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
        """
        return pulumi.get(self, "scheduler_name")

    @scheduler_name.setter
    def scheduler_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scheduler_name", value)

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodSecurityContextArgs']]:
        """
        Configures pod-level security attributes and common container settings.
        """
        return pulumi.get(self, "security_context")

    @security_context.setter
    def security_context(self, value: Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodSecurityContextArgs']]):
        pulumi.set(self, "security_context", value)

    @property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
        """
        return pulumi.get(self, "termination_grace_period_seconds")

    @termination_grace_period_seconds.setter
    def termination_grace_period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "termination_grace_period_seconds", value)

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodTolerationsArgs']]]]:
        """
        The pod's tolerations.
        """
        return pulumi.get(self, "tolerations")

    @tolerations.setter
    def tolerations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodTolerationsArgs']]]]):
        pulumi.set(self, "tolerations", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplatePodAffinityArgs:
    def __init__(__self__, *,
                 node_affinity: Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityNodeAffinityArgs']] = None,
                 pod_affinity: Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAffinityArgs']] = None,
                 pod_anti_affinity: Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityArgs']] = None):
        """
        The pod's affinity rules.
        """
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityNodeAffinityArgs']]:
        return pulumi.get(self, "node_affinity")

    @node_affinity.setter
    def node_affinity(self, value: Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityNodeAffinityArgs']]):
        pulumi.set(self, "node_affinity", value)

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAffinityArgs']]:
        return pulumi.get(self, "pod_affinity")

    @pod_affinity.setter
    def pod_affinity(self, value: Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAffinityArgs']]):
        pulumi.set(self, "pod_affinity", value)

    @property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityArgs']]:
        return pulumi.get(self, "pod_anti_affinity")

    @pod_anti_affinity.setter
    def pod_anti_affinity(self, value: Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityArgs']]):
        pulumi.set(self, "pod_anti_affinity", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplatePodAffinityNodeAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 preference: Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']]:
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs']]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]] = None,
                 match_fields: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]]:
        return pulumi.get(self, "match_fields")

    @match_fields.setter
    def match_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs']]]]):
        pulumi.set(self, "match_fields", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 node_selector_terms: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]] = None):
        if node_selector_terms is not None:
            pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]]:
        return pulumi.get(self, "node_selector_terms")

    @node_selector_terms.setter
    def node_selector_terms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs']]]]):
        pulumi.set(self, "node_selector_terms", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]] = None,
                 match_fields: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]]:
        return pulumi.get(self, "match_fields")

    @match_fields.setter
    def match_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs']]]]):
        pulumi.set(self, "match_fields", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplatePodAffinityPodAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 pod_affinity_term: Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]:
        return pulumi.get(self, "pod_affinity_term")

    @pod_affinity_term.setter
    def pod_affinity_term(self, value: Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]):
        pulumi.set(self, "pod_affinity_term", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityArgs:
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None,
                 required_during_scheduling_ignored_during_execution: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @preferred_during_scheduling_ignored_during_execution.setter
    def preferred_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "preferred_during_scheduling_ignored_during_execution", value)

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    @required_during_scheduling_ignored_during_execution.setter
    def required_during_scheduling_ignored_during_execution(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs']]]]):
        pulumi.set(self, "required_during_scheduling_ignored_during_execution", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 pod_affinity_term: Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]:
        return pulumi.get(self, "pod_affinity_term")

    @pod_affinity_term.setter
    def pod_affinity_term(self, value: Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs']]):
        pulumi.set(self, "pod_affinity_term", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs:
    def __init__(__self__, *,
                 label_selector: Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 topology_key: Optional[pulumi.Input[str]] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]:
        return pulumi.get(self, "label_selector")

    @label_selector.setter
    def label_selector(self, value: Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs']]):
        pulumi.set(self, "label_selector", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology_key")

    @topology_key.setter
    def topology_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology_key", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]:
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplatePodDisruptionBudgetArgs:
    def __init__(__self__, *,
                 max_unavailable: Optional[pulumi.Input[int]] = None,
                 metadata: Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadataArgs']] = None):
        """
        Template for ZooKeeper `PodDisruptionBudget`.
        :param pulumi.Input[int] max_unavailable: Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
        :param pulumi.Input['KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadataArgs'] metadata: Metadata to apply to the `PodDistruptionBugetTemplate` resource.
        """
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
        """
        return pulumi.get(self, "max_unavailable")

    @max_unavailable.setter
    def max_unavailable(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_unavailable", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadataArgs']]:
        """
        Metadata to apply to the `PodDistruptionBugetTemplate` resource.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadataArgs']]):
        pulumi.set(self, "metadata", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Metadata to apply to the `PodDistruptionBugetTemplate` resource.
        :param pulumi.Input[Mapping[str, Any]] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param pulumi.Input[Mapping[str, Any]] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplatePodHostAliasesArgs:
    def __init__(__self__, *,
                 hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ip: Optional[pulumi.Input[str]] = None):
        if hostnames is not None:
            pulumi.set(__self__, "hostnames", hostnames)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def hostnames(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "hostnames")

    @hostnames.setter
    def hostnames(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hostnames", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplatePodImagePullSecretsArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplatePodMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Metadata applied to the resource.
        :param pulumi.Input[Mapping[str, Any]] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param pulumi.Input[Mapping[str, Any]] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplatePodSecurityContextArgs:
    def __init__(__self__, *,
                 fs_group: Optional[pulumi.Input[int]] = None,
                 fs_group_change_policy: Optional[pulumi.Input[str]] = None,
                 run_as_group: Optional[pulumi.Input[int]] = None,
                 run_as_non_root: Optional[pulumi.Input[bool]] = None,
                 run_as_user: Optional[pulumi.Input[int]] = None,
                 se_linux_options: Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptionsArgs']] = None,
                 supplemental_groups: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 sysctls: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodSecurityContextSysctlsArgs']]]] = None,
                 windows_options: Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptionsArgs']] = None):
        """
        Configures pod-level security attributes and common container settings.
        """
        if fs_group is not None:
            pulumi.set(__self__, "fs_group", fs_group)
        if fs_group_change_policy is not None:
            pulumi.set(__self__, "fs_group_change_policy", fs_group_change_policy)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if supplemental_groups is not None:
            pulumi.set(__self__, "supplemental_groups", supplemental_groups)
        if sysctls is not None:
            pulumi.set(__self__, "sysctls", sysctls)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="fsGroup")
    def fs_group(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "fs_group")

    @fs_group.setter
    def fs_group(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "fs_group", value)

    @property
    @pulumi.getter(name="fsGroupChangePolicy")
    def fs_group_change_policy(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "fs_group_change_policy")

    @fs_group_change_policy.setter
    def fs_group_change_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fs_group_change_policy", value)

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_group")

    @run_as_group.setter
    def run_as_group(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_group", value)

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "run_as_non_root")

    @run_as_non_root.setter
    def run_as_non_root(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_as_non_root", value)

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_user")

    @run_as_user.setter
    def run_as_user(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_user", value)

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptionsArgs']]:
        return pulumi.get(self, "se_linux_options")

    @se_linux_options.setter
    def se_linux_options(self, value: Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptionsArgs']]):
        pulumi.set(self, "se_linux_options", value)

    @property
    @pulumi.getter(name="supplementalGroups")
    def supplemental_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        return pulumi.get(self, "supplemental_groups")

    @supplemental_groups.setter
    def supplemental_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "supplemental_groups", value)

    @property
    @pulumi.getter
    def sysctls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodSecurityContextSysctlsArgs']]]]:
        return pulumi.get(self, "sysctls")

    @sysctls.setter
    def sysctls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplatePodSecurityContextSysctlsArgs']]]]):
        pulumi.set(self, "sysctls", value)

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptionsArgs']]:
        return pulumi.get(self, "windows_options")

    @windows_options.setter
    def windows_options(self, value: Optional[pulumi.Input['KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptionsArgs']]):
        pulumi.set(self, "windows_options", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptionsArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplatePodSecurityContextSysctlsArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptionsArgs:
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[pulumi.Input[str]] = None,
                 gmsa_credential_spec_name: Optional[pulumi.Input[str]] = None,
                 run_as_user_name: Optional[pulumi.Input[str]] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec")

    @gmsa_credential_spec.setter
    def gmsa_credential_spec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec", value)

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @gmsa_credential_spec_name.setter
    def gmsa_credential_spec_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec_name", value)

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "run_as_user_name")

    @run_as_user_name.setter
    def run_as_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "run_as_user_name", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplatePodTolerationsArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 toleration_seconds: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if toleration_seconds is not None:
            pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "toleration_seconds")

    @toleration_seconds.setter
    def toleration_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "toleration_seconds", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplateStatefulsetArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input['KafkaSpecZookeeperTemplateStatefulsetMetadataArgs']] = None,
                 pod_management_policy: Optional[pulumi.Input[str]] = None):
        """
        Template for ZooKeeper `StatefulSet`.
        :param pulumi.Input['KafkaSpecZookeeperTemplateStatefulsetMetadataArgs'] metadata: Metadata applied to the resource.
        :param pulumi.Input[str] pod_management_policy: PodManagementPolicy which will be used for this StatefulSet. Valid values are `Parallel` and `OrderedReady`. Defaults to `Parallel`.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if pod_management_policy is not None:
            pulumi.set(__self__, "pod_management_policy", pod_management_policy)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['KafkaSpecZookeeperTemplateStatefulsetMetadataArgs']]:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['KafkaSpecZookeeperTemplateStatefulsetMetadataArgs']]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter(name="podManagementPolicy")
    def pod_management_policy(self) -> Optional[pulumi.Input[str]]:
        """
        PodManagementPolicy which will be used for this StatefulSet. Valid values are `Parallel` and `OrderedReady`. Defaults to `Parallel`.
        """
        return pulumi.get(self, "pod_management_policy")

    @pod_management_policy.setter
    def pod_management_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pod_management_policy", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplateStatefulsetMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Metadata applied to the resource.
        :param pulumi.Input[Mapping[str, Any]] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param pulumi.Input[Mapping[str, Any]] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplateTlsSidecarContainerArgs:
    def __init__(__self__, *,
                 env: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplateTlsSidecarContainerEnvArgs']]]] = None,
                 security_context: Optional[pulumi.Input['KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextArgs']] = None):
        """
        Template for the Zookeeper server TLS sidecar container. The TLS sidecar is not used anymore and this option will be ignored.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplateTlsSidecarContainerEnvArgs']]] env: Environment variables which should be applied to the container.
        :param pulumi.Input['KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextArgs'] security_context: Security context for the container.
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)

    @property
    @pulumi.getter
    def env(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplateTlsSidecarContainerEnvArgs']]]]:
        """
        Environment variables which should be applied to the container.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplateTlsSidecarContainerEnvArgs']]]]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional[pulumi.Input['KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextArgs']]:
        """
        Security context for the container.
        """
        return pulumi.get(self, "security_context")

    @security_context.setter
    def security_context(self, value: Optional[pulumi.Input['KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextArgs']]):
        pulumi.set(self, "security_context", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplateTlsSidecarContainerEnvArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The environment variable key.
        :param pulumi.Input[str] value: The environment variable value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The environment variable key.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The environment variable value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextArgs:
    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[pulumi.Input[bool]] = None,
                 capabilities: Optional[pulumi.Input['KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextCapabilitiesArgs']] = None,
                 privileged: Optional[pulumi.Input[bool]] = None,
                 proc_mount: Optional[pulumi.Input[str]] = None,
                 read_only_root_filesystem: Optional[pulumi.Input[bool]] = None,
                 run_as_group: Optional[pulumi.Input[int]] = None,
                 run_as_non_root: Optional[pulumi.Input[bool]] = None,
                 run_as_user: Optional[pulumi.Input[int]] = None,
                 se_linux_options: Optional[pulumi.Input['KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextSeLinuxOptionsArgs']] = None,
                 windows_options: Optional[pulumi.Input['KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextWindowsOptionsArgs']] = None):
        """
        Security context for the container.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if proc_mount is not None:
            pulumi.set(__self__, "proc_mount", proc_mount)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "allow_privilege_escalation")

    @allow_privilege_escalation.setter
    def allow_privilege_escalation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_privilege_escalation", value)

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[pulumi.Input['KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextCapabilitiesArgs']]:
        return pulumi.get(self, "capabilities")

    @capabilities.setter
    def capabilities(self, value: Optional[pulumi.Input['KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextCapabilitiesArgs']]):
        pulumi.set(self, "capabilities", value)

    @property
    @pulumi.getter
    def privileged(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "privileged")

    @privileged.setter
    def privileged(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "privileged", value)

    @property
    @pulumi.getter(name="procMount")
    def proc_mount(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "proc_mount")

    @proc_mount.setter
    def proc_mount(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proc_mount", value)

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "read_only_root_filesystem")

    @read_only_root_filesystem.setter
    def read_only_root_filesystem(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "read_only_root_filesystem", value)

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_group")

    @run_as_group.setter
    def run_as_group(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_group", value)

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "run_as_non_root")

    @run_as_non_root.setter
    def run_as_non_root(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_as_non_root", value)

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_user")

    @run_as_user.setter
    def run_as_user(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_user", value)

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional[pulumi.Input['KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextSeLinuxOptionsArgs']]:
        return pulumi.get(self, "se_linux_options")

    @se_linux_options.setter
    def se_linux_options(self, value: Optional[pulumi.Input['KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextSeLinuxOptionsArgs']]):
        pulumi.set(self, "se_linux_options", value)

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional[pulumi.Input['KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextWindowsOptionsArgs']]:
        return pulumi.get(self, "windows_options")

    @windows_options.setter
    def windows_options(self, value: Optional[pulumi.Input['KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextWindowsOptionsArgs']]):
        pulumi.set(self, "windows_options", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextCapabilitiesArgs:
    def __init__(__self__, *,
                 add: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 drop: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)

    @property
    @pulumi.getter
    def add(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "add")

    @add.setter
    def add(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "add", value)

    @property
    @pulumi.getter
    def drop(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "drop")

    @drop.setter
    def drop(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "drop", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextSeLinuxOptionsArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextWindowsOptionsArgs:
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[pulumi.Input[str]] = None,
                 gmsa_credential_spec_name: Optional[pulumi.Input[str]] = None,
                 run_as_user_name: Optional[pulumi.Input[str]] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec")

    @gmsa_credential_spec.setter
    def gmsa_credential_spec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec", value)

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @gmsa_credential_spec_name.setter
    def gmsa_credential_spec_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec_name", value)

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "run_as_user_name")

    @run_as_user_name.setter
    def run_as_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "run_as_user_name", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplateZookeeperContainerArgs:
    def __init__(__self__, *,
                 env: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplateZookeeperContainerEnvArgs']]]] = None,
                 security_context: Optional[pulumi.Input['KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextArgs']] = None):
        """
        Template for the ZooKeeper container.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplateZookeeperContainerEnvArgs']]] env: Environment variables which should be applied to the container.
        :param pulumi.Input['KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextArgs'] security_context: Security context for the container.
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)

    @property
    @pulumi.getter
    def env(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplateZookeeperContainerEnvArgs']]]]:
        """
        Environment variables which should be applied to the container.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaSpecZookeeperTemplateZookeeperContainerEnvArgs']]]]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional[pulumi.Input['KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextArgs']]:
        """
        Security context for the container.
        """
        return pulumi.get(self, "security_context")

    @security_context.setter
    def security_context(self, value: Optional[pulumi.Input['KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextArgs']]):
        pulumi.set(self, "security_context", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplateZookeeperContainerEnvArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The environment variable key.
        :param pulumi.Input[str] value: The environment variable value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The environment variable key.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The environment variable value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextArgs:
    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[pulumi.Input[bool]] = None,
                 capabilities: Optional[pulumi.Input['KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextCapabilitiesArgs']] = None,
                 privileged: Optional[pulumi.Input[bool]] = None,
                 proc_mount: Optional[pulumi.Input[str]] = None,
                 read_only_root_filesystem: Optional[pulumi.Input[bool]] = None,
                 run_as_group: Optional[pulumi.Input[int]] = None,
                 run_as_non_root: Optional[pulumi.Input[bool]] = None,
                 run_as_user: Optional[pulumi.Input[int]] = None,
                 se_linux_options: Optional[pulumi.Input['KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptionsArgs']] = None,
                 windows_options: Optional[pulumi.Input['KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptionsArgs']] = None):
        """
        Security context for the container.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if proc_mount is not None:
            pulumi.set(__self__, "proc_mount", proc_mount)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "allow_privilege_escalation")

    @allow_privilege_escalation.setter
    def allow_privilege_escalation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_privilege_escalation", value)

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[pulumi.Input['KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextCapabilitiesArgs']]:
        return pulumi.get(self, "capabilities")

    @capabilities.setter
    def capabilities(self, value: Optional[pulumi.Input['KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextCapabilitiesArgs']]):
        pulumi.set(self, "capabilities", value)

    @property
    @pulumi.getter
    def privileged(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "privileged")

    @privileged.setter
    def privileged(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "privileged", value)

    @property
    @pulumi.getter(name="procMount")
    def proc_mount(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "proc_mount")

    @proc_mount.setter
    def proc_mount(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proc_mount", value)

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "read_only_root_filesystem")

    @read_only_root_filesystem.setter
    def read_only_root_filesystem(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "read_only_root_filesystem", value)

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_group")

    @run_as_group.setter
    def run_as_group(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_group", value)

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "run_as_non_root")

    @run_as_non_root.setter
    def run_as_non_root(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_as_non_root", value)

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "run_as_user")

    @run_as_user.setter
    def run_as_user(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "run_as_user", value)

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional[pulumi.Input['KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptionsArgs']]:
        return pulumi.get(self, "se_linux_options")

    @se_linux_options.setter
    def se_linux_options(self, value: Optional[pulumi.Input['KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptionsArgs']]):
        pulumi.set(self, "se_linux_options", value)

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional[pulumi.Input['KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptionsArgs']]:
        return pulumi.get(self, "windows_options")

    @windows_options.setter
    def windows_options(self, value: Optional[pulumi.Input['KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptionsArgs']]):
        pulumi.set(self, "windows_options", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextCapabilitiesArgs:
    def __init__(__self__, *,
                 add: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 drop: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)

    @property
    @pulumi.getter
    def add(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "add")

    @add.setter
    def add(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "add", value)

    @property
    @pulumi.getter
    def drop(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "drop")

    @drop.setter
    def drop(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "drop", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptionsArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


@pulumi.input_type
class KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptionsArgs:
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[pulumi.Input[str]] = None,
                 gmsa_credential_spec_name: Optional[pulumi.Input[str]] = None,
                 run_as_user_name: Optional[pulumi.Input[str]] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec")

    @gmsa_credential_spec.setter
    def gmsa_credential_spec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec", value)

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @gmsa_credential_spec_name.setter
    def gmsa_credential_spec_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gmsa_credential_spec_name", value)

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "run_as_user_name")

    @run_as_user_name.setter
    def run_as_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "run_as_user_name", value)


@pulumi.input_type
class KafkaSpecZookeeperTlsSidecarArgs:
    def __init__(__self__, *,
                 image: Optional[pulumi.Input[str]] = None,
                 liveness_probe: Optional[pulumi.Input['KafkaSpecZookeeperTlsSidecarLivenessProbeArgs']] = None,
                 log_level: Optional[pulumi.Input[str]] = None,
                 readiness_probe: Optional[pulumi.Input['KafkaSpecZookeeperTlsSidecarReadinessProbeArgs']] = None,
                 resources: Optional[pulumi.Input['KafkaSpecZookeeperTlsSidecarResourcesArgs']] = None):
        """
        TLS sidecar configuration. The TLS sidecar is not used anymore and this option will be ignored.
        :param pulumi.Input[str] image: The docker image for the container.
        :param pulumi.Input['KafkaSpecZookeeperTlsSidecarLivenessProbeArgs'] liveness_probe: Pod liveness checking.
        :param pulumi.Input[str] log_level: The log level for the TLS sidecar. Default value is `notice`.
        :param pulumi.Input['KafkaSpecZookeeperTlsSidecarReadinessProbeArgs'] readiness_probe: Pod readiness checking.
        :param pulumi.Input['KafkaSpecZookeeperTlsSidecarResourcesArgs'] resources: CPU and memory resources to reserve.
        """
        if image is not None:
            pulumi.set(__self__, "image", image)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        The docker image for the container.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional[pulumi.Input['KafkaSpecZookeeperTlsSidecarLivenessProbeArgs']]:
        """
        Pod liveness checking.
        """
        return pulumi.get(self, "liveness_probe")

    @liveness_probe.setter
    def liveness_probe(self, value: Optional[pulumi.Input['KafkaSpecZookeeperTlsSidecarLivenessProbeArgs']]):
        pulumi.set(self, "liveness_probe", value)

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[pulumi.Input[str]]:
        """
        The log level for the TLS sidecar. Default value is `notice`.
        """
        return pulumi.get(self, "log_level")

    @log_level.setter
    def log_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_level", value)

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional[pulumi.Input['KafkaSpecZookeeperTlsSidecarReadinessProbeArgs']]:
        """
        Pod readiness checking.
        """
        return pulumi.get(self, "readiness_probe")

    @readiness_probe.setter
    def readiness_probe(self, value: Optional[pulumi.Input['KafkaSpecZookeeperTlsSidecarReadinessProbeArgs']]):
        pulumi.set(self, "readiness_probe", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['KafkaSpecZookeeperTlsSidecarResourcesArgs']]:
        """
        CPU and memory resources to reserve.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['KafkaSpecZookeeperTlsSidecarResourcesArgs']]):
        pulumi.set(self, "resources", value)


@pulumi.input_type
class KafkaSpecZookeeperTlsSidecarLivenessProbeArgs:
    def __init__(__self__, *,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 success_threshold: Optional[pulumi.Input[int]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        Pod liveness checking.
        :param pulumi.Input[int] failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param pulumi.Input[int] initial_delay_seconds: The initial delay before first the health is first checked.
        :param pulumi.Input[int] period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param pulumi.Input[int] success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param pulumi.Input[int] timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "success_threshold", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


@pulumi.input_type
class KafkaSpecZookeeperTlsSidecarReadinessProbeArgs:
    def __init__(__self__, *,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 success_threshold: Optional[pulumi.Input[int]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        Pod readiness checking.
        :param pulumi.Input[int] failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param pulumi.Input[int] initial_delay_seconds: The initial delay before first the health is first checked.
        :param pulumi.Input[int] period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param pulumi.Input[int] success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param pulumi.Input[int] timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "success_threshold", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


@pulumi.input_type
class KafkaSpecZookeeperTlsSidecarResourcesArgs:
    def __init__(__self__, *,
                 limits: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 requests: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        CPU and memory resources to reserve.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "limits", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "requests", value)


@pulumi.input_type
class KafkaSpecZookeeperTolerationsArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 toleration_seconds: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if toleration_seconds is not None:
            pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "toleration_seconds")

    @toleration_seconds.setter
    def toleration_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "toleration_seconds", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class KafkaStatusArgs:
    def __init__(__self__, *,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaStatusConditionsArgs']]]] = None,
                 listeners: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaStatusListenersArgs']]]] = None,
                 observed_generation: Optional[pulumi.Input[int]] = None):
        """
        The status of the Kafka and ZooKeeper clusters, and Topic Operator.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaStatusConditionsArgs']]] conditions: List of status conditions.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaStatusListenersArgs']]] listeners: Addresses of the internal and external listeners.
        :param pulumi.Input[int] observed_generation: The generation of the CRD that was last reconciled by the operator.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if listeners is not None:
            pulumi.set(__self__, "listeners", listeners)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaStatusConditionsArgs']]]]:
        """
        List of status conditions.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaStatusConditionsArgs']]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter
    def listeners(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaStatusListenersArgs']]]]:
        """
        Addresses of the internal and external listeners.
        """
        return pulumi.get(self, "listeners")

    @listeners.setter
    def listeners(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaStatusListenersArgs']]]]):
        pulumi.set(self, "listeners", value)

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[pulumi.Input[int]]:
        """
        The generation of the CRD that was last reconciled by the operator.
        """
        return pulumi.get(self, "observed_generation")

    @observed_generation.setter
    def observed_generation(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "observed_generation", value)


@pulumi.input_type
class KafkaStatusConditionsArgs:
    def __init__(__self__, *,
                 last_transition_time: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] last_transition_time: Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
        :param pulumi.Input[str] message: Human-readable message indicating details about the condition's last transition.
        :param pulumi.Input[str] reason: The reason for the condition's last transition (a single word in CamelCase).
        :param pulumi.Input[str] status: The status of the condition, either True, False or Unknown.
        :param pulumi.Input[str] type: The unique identifier of a condition, used to distinguish between other conditions in the resource.
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[pulumi.Input[str]]:
        """
        Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
        """
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Human-readable message indicating details about the condition's last transition.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        The reason for the condition's last transition (a single word in CamelCase).
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of the condition, either True, False or Unknown.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The unique identifier of a condition, used to distinguish between other conditions in the resource.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class KafkaStatusListenersArgs:
    def __init__(__self__, *,
                 addresses: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaStatusListenersAddressesArgs']]]] = None,
                 bootstrap_servers: Optional[pulumi.Input[str]] = None,
                 certificates: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['KafkaStatusListenersAddressesArgs']]] addresses: A list of the addresses for this listener.
        :param pulumi.Input[str] bootstrap_servers: A comma-separated list of `host:port` pairs for connecting to the Kafka cluster using this listener.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] certificates: A list of TLS certificates which can be used to verify the identity of the server when connecting to the given listener. Set only for `tls` and `external` listeners.
        :param pulumi.Input[str] type: The type of the listener. Can be one of the following three types: `plain`, `tls`, and `external`.
        """
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)
        if bootstrap_servers is not None:
            pulumi.set(__self__, "bootstrap_servers", bootstrap_servers)
        if certificates is not None:
            pulumi.set(__self__, "certificates", certificates)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaStatusListenersAddressesArgs']]]]:
        """
        A list of the addresses for this listener.
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaStatusListenersAddressesArgs']]]]):
        pulumi.set(self, "addresses", value)

    @property
    @pulumi.getter(name="bootstrapServers")
    def bootstrap_servers(self) -> Optional[pulumi.Input[str]]:
        """
        A comma-separated list of `host:port` pairs for connecting to the Kafka cluster using this listener.
        """
        return pulumi.get(self, "bootstrap_servers")

    @bootstrap_servers.setter
    def bootstrap_servers(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bootstrap_servers", value)

    @property
    @pulumi.getter
    def certificates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of TLS certificates which can be used to verify the identity of the server when connecting to the given listener. Set only for `tls` and `external` listeners.
        """
        return pulumi.get(self, "certificates")

    @certificates.setter
    def certificates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "certificates", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the listener. Can be one of the following three types: `plain`, `tls`, and `external`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class KafkaStatusListenersAddressesArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] host: The DNS name or IP address of the Kafka bootstrap service.
        :param pulumi.Input[int] port: The port of the Kafka bootstrap service.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        The DNS name or IP address of the Kafka bootstrap service.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port of the Kafka bootstrap service.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


@pulumi.input_type
class KafkaTopicSpecArgs:
    def __init__(__self__, *,
                 partitions: pulumi.Input[int],
                 replicas: pulumi.Input[int],
                 config: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 topic_name: Optional[pulumi.Input[str]] = None):
        """
        The specification of the topic.
        :param pulumi.Input[int] partitions: The number of partitions the topic should have. This cannot be decreased after topic creation. It can be increased after topic creation, but it is important to understand the consequences that has, especially for topics with semantic partitioning.
        :param pulumi.Input[int] replicas: The number of replicas the topic should have.
        :param pulumi.Input[Mapping[str, Any]] config: The topic configuration.
        :param pulumi.Input[str] topic_name: The name of the topic. When absent this will default to the metadata.name of the topic. It is recommended to not set this unless the topic name is not a valid Kubernetes resource name.
        """
        pulumi.set(__self__, "partitions", partitions)
        pulumi.set(__self__, "replicas", replicas)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if topic_name is not None:
            pulumi.set(__self__, "topic_name", topic_name)

    @property
    @pulumi.getter
    def partitions(self) -> pulumi.Input[int]:
        """
        The number of partitions the topic should have. This cannot be decreased after topic creation. It can be increased after topic creation, but it is important to understand the consequences that has, especially for topics with semantic partitioning.
        """
        return pulumi.get(self, "partitions")

    @partitions.setter
    def partitions(self, value: pulumi.Input[int]):
        pulumi.set(self, "partitions", value)

    @property
    @pulumi.getter
    def replicas(self) -> pulumi.Input[int]:
        """
        The number of replicas the topic should have.
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: pulumi.Input[int]):
        pulumi.set(self, "replicas", value)

    @property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        The topic configuration.
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "config", value)

    @property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the topic. When absent this will default to the metadata.name of the topic. It is recommended to not set this unless the topic name is not a valid Kubernetes resource name.
        """
        return pulumi.get(self, "topic_name")

    @topic_name.setter
    def topic_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topic_name", value)


@pulumi.input_type
class KafkaTopicStatusArgs:
    def __init__(__self__, *,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaTopicStatusConditionsArgs']]]] = None,
                 observed_generation: Optional[pulumi.Input[int]] = None):
        """
        The status of the topic.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaTopicStatusConditionsArgs']]] conditions: List of status conditions.
        :param pulumi.Input[int] observed_generation: The generation of the CRD that was last reconciled by the operator.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaTopicStatusConditionsArgs']]]]:
        """
        List of status conditions.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaTopicStatusConditionsArgs']]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[pulumi.Input[int]]:
        """
        The generation of the CRD that was last reconciled by the operator.
        """
        return pulumi.get(self, "observed_generation")

    @observed_generation.setter
    def observed_generation(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "observed_generation", value)


@pulumi.input_type
class KafkaTopicStatusConditionsArgs:
    def __init__(__self__, *,
                 last_transition_time: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] last_transition_time: Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
        :param pulumi.Input[str] message: Human-readable message indicating details about the condition's last transition.
        :param pulumi.Input[str] reason: The reason for the condition's last transition (a single word in CamelCase).
        :param pulumi.Input[str] status: The status of the condition, either True, False or Unknown.
        :param pulumi.Input[str] type: The unique identifier of a condition, used to distinguish between other conditions in the resource.
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[pulumi.Input[str]]:
        """
        Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
        """
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Human-readable message indicating details about the condition's last transition.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        The reason for the condition's last transition (a single word in CamelCase).
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of the condition, either True, False or Unknown.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The unique identifier of a condition, used to distinguish between other conditions in the resource.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class KafkaUserSpecArgs:
    def __init__(__self__, *,
                 authentication: Optional[pulumi.Input['KafkaUserSpecAuthenticationArgs']] = None,
                 authorization: Optional[pulumi.Input['KafkaUserSpecAuthorizationArgs']] = None,
                 quotas: Optional[pulumi.Input['KafkaUserSpecQuotasArgs']] = None,
                 template: Optional[pulumi.Input['KafkaUserSpecTemplateArgs']] = None):
        """
        The specification of the user.
        :param pulumi.Input['KafkaUserSpecAuthenticationArgs'] authentication: Authentication mechanism enabled for this Kafka user.
        :param pulumi.Input['KafkaUserSpecAuthorizationArgs'] authorization: Authorization rules for this Kafka user.
        :param pulumi.Input['KafkaUserSpecQuotasArgs'] quotas: Quotas on requests to control the broker resources used by clients. Network bandwidth and request rate quotas can be enforced.Kafka documentation for Kafka User quotas can be found at http://kafka.apache.org/documentation/#design_quotas.
        :param pulumi.Input['KafkaUserSpecTemplateArgs'] template: Template to specify how Kafka User `Secrets` are generated.
        """
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if authorization is not None:
            pulumi.set(__self__, "authorization", authorization)
        if quotas is not None:
            pulumi.set(__self__, "quotas", quotas)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['KafkaUserSpecAuthenticationArgs']]:
        """
        Authentication mechanism enabled for this Kafka user.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['KafkaUserSpecAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @property
    @pulumi.getter
    def authorization(self) -> Optional[pulumi.Input['KafkaUserSpecAuthorizationArgs']]:
        """
        Authorization rules for this Kafka user.
        """
        return pulumi.get(self, "authorization")

    @authorization.setter
    def authorization(self, value: Optional[pulumi.Input['KafkaUserSpecAuthorizationArgs']]):
        pulumi.set(self, "authorization", value)

    @property
    @pulumi.getter
    def quotas(self) -> Optional[pulumi.Input['KafkaUserSpecQuotasArgs']]:
        """
        Quotas on requests to control the broker resources used by clients. Network bandwidth and request rate quotas can be enforced.Kafka documentation for Kafka User quotas can be found at http://kafka.apache.org/documentation/#design_quotas.
        """
        return pulumi.get(self, "quotas")

    @quotas.setter
    def quotas(self, value: Optional[pulumi.Input['KafkaUserSpecQuotasArgs']]):
        pulumi.set(self, "quotas", value)

    @property
    @pulumi.getter
    def template(self) -> Optional[pulumi.Input['KafkaUserSpecTemplateArgs']]:
        """
        Template to specify how Kafka User `Secrets` are generated.
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[pulumi.Input['KafkaUserSpecTemplateArgs']]):
        pulumi.set(self, "template", value)


@pulumi.input_type
class KafkaUserSpecAuthenticationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str]):
        """
        Authentication mechanism enabled for this Kafka user.
        :param pulumi.Input[str] type: Authentication type.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Authentication type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class KafkaUserSpecAuthorizationArgs:
    def __init__(__self__, *,
                 acls: pulumi.Input[Sequence[pulumi.Input['KafkaUserSpecAuthorizationAclsArgs']]],
                 type: pulumi.Input[str]):
        """
        Authorization rules for this Kafka user.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaUserSpecAuthorizationAclsArgs']]] acls: List of ACL rules which should be applied to this user.
        :param pulumi.Input[str] type: Authorization type. Currently the only supported type is `simple`. `simple` authorization type uses Kafka's `kafka.security.authorizer.AclAuthorizer` class for authorization.
        """
        pulumi.set(__self__, "acls", acls)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def acls(self) -> pulumi.Input[Sequence[pulumi.Input['KafkaUserSpecAuthorizationAclsArgs']]]:
        """
        List of ACL rules which should be applied to this user.
        """
        return pulumi.get(self, "acls")

    @acls.setter
    def acls(self, value: pulumi.Input[Sequence[pulumi.Input['KafkaUserSpecAuthorizationAclsArgs']]]):
        pulumi.set(self, "acls", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Authorization type. Currently the only supported type is `simple`. `simple` authorization type uses Kafka's `kafka.security.authorizer.AclAuthorizer` class for authorization.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class KafkaUserSpecAuthorizationAclsArgs:
    def __init__(__self__, *,
                 operation: pulumi.Input[str],
                 resource: pulumi.Input['KafkaUserSpecAuthorizationAclsResourceArgs'],
                 host: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] operation: Operation which will be allowed or denied. Supported operations are: Read, Write, Create, Delete, Alter, Describe, ClusterAction, AlterConfigs, DescribeConfigs, IdempotentWrite and All.
        :param pulumi.Input['KafkaUserSpecAuthorizationAclsResourceArgs'] resource: Indicates the resource for which given ACL rule applies.
        :param pulumi.Input[str] host: The host from which the action described in the ACL rule is allowed or denied.
        :param pulumi.Input[str] type: The type of the rule. Currently the only supported type is `allow`. ACL rules with type `allow` are used to allow user to execute the specified operations. Default value is `allow`.
        """
        pulumi.set(__self__, "operation", operation)
        pulumi.set(__self__, "resource", resource)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def operation(self) -> pulumi.Input[str]:
        """
        Operation which will be allowed or denied. Supported operations are: Read, Write, Create, Delete, Alter, Describe, ClusterAction, AlterConfigs, DescribeConfigs, IdempotentWrite and All.
        """
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: pulumi.Input[str]):
        pulumi.set(self, "operation", value)

    @property
    @pulumi.getter
    def resource(self) -> pulumi.Input['KafkaUserSpecAuthorizationAclsResourceArgs']:
        """
        Indicates the resource for which given ACL rule applies.
        """
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: pulumi.Input['KafkaUserSpecAuthorizationAclsResourceArgs']):
        pulumi.set(self, "resource", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        The host from which the action described in the ACL rule is allowed or denied.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the rule. Currently the only supported type is `allow`. ACL rules with type `allow` are used to allow user to execute the specified operations. Default value is `allow`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class KafkaUserSpecAuthorizationAclsResourceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None,
                 pattern_type: Optional[pulumi.Input[str]] = None):
        """
        Indicates the resource for which given ACL rule applies.
        :param pulumi.Input[str] type: Resource type. The available resource types are `topic`, `group`, `cluster`, and `transactionalId`.
        :param pulumi.Input[str] name: Name of resource for which given ACL rule applies. Can be combined with `patternType` field to use prefix pattern.
        :param pulumi.Input[str] pattern_type: Describes the pattern used in the resource field. The supported types are `literal` and `prefix`. With `literal` pattern type, the resource field will be used as a definition of a full name. With `prefix` pattern type, the resource name will be used only as a prefix. Default value is `literal`.
        """
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if pattern_type is not None:
            pulumi.set(__self__, "pattern_type", pattern_type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Resource type. The available resource types are `topic`, `group`, `cluster`, and `transactionalId`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of resource for which given ACL rule applies. Can be combined with `patternType` field to use prefix pattern.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="patternType")
    def pattern_type(self) -> Optional[pulumi.Input[str]]:
        """
        Describes the pattern used in the resource field. The supported types are `literal` and `prefix`. With `literal` pattern type, the resource field will be used as a definition of a full name. With `prefix` pattern type, the resource name will be used only as a prefix. Default value is `literal`.
        """
        return pulumi.get(self, "pattern_type")

    @pattern_type.setter
    def pattern_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pattern_type", value)


@pulumi.input_type
class KafkaUserSpecQuotasArgs:
    def __init__(__self__, *,
                 consumer_byte_rate: Optional[pulumi.Input[int]] = None,
                 producer_byte_rate: Optional[pulumi.Input[int]] = None,
                 request_percentage: Optional[pulumi.Input[int]] = None):
        """
        Quotas on requests to control the broker resources used by clients. Network bandwidth and request rate quotas can be enforced.Kafka documentation for Kafka User quotas can be found at http://kafka.apache.org/documentation/#design_quotas.
        :param pulumi.Input[int] consumer_byte_rate: A quota on the maximum bytes per-second that each client group can fetch from a broker before the clients in the group are throttled. Defined on a per-broker basis.
        :param pulumi.Input[int] producer_byte_rate: A quota on the maximum bytes per-second that each client group can publish to a broker before the clients in the group are throttled. Defined on a per-broker basis.
        :param pulumi.Input[int] request_percentage: A quota on the maximum CPU utilization of each client group as a percentage of network and I/O threads.
        """
        if consumer_byte_rate is not None:
            pulumi.set(__self__, "consumer_byte_rate", consumer_byte_rate)
        if producer_byte_rate is not None:
            pulumi.set(__self__, "producer_byte_rate", producer_byte_rate)
        if request_percentage is not None:
            pulumi.set(__self__, "request_percentage", request_percentage)

    @property
    @pulumi.getter(name="consumerByteRate")
    def consumer_byte_rate(self) -> Optional[pulumi.Input[int]]:
        """
        A quota on the maximum bytes per-second that each client group can fetch from a broker before the clients in the group are throttled. Defined on a per-broker basis.
        """
        return pulumi.get(self, "consumer_byte_rate")

    @consumer_byte_rate.setter
    def consumer_byte_rate(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "consumer_byte_rate", value)

    @property
    @pulumi.getter(name="producerByteRate")
    def producer_byte_rate(self) -> Optional[pulumi.Input[int]]:
        """
        A quota on the maximum bytes per-second that each client group can publish to a broker before the clients in the group are throttled. Defined on a per-broker basis.
        """
        return pulumi.get(self, "producer_byte_rate")

    @producer_byte_rate.setter
    def producer_byte_rate(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "producer_byte_rate", value)

    @property
    @pulumi.getter(name="requestPercentage")
    def request_percentage(self) -> Optional[pulumi.Input[int]]:
        """
        A quota on the maximum CPU utilization of each client group as a percentage of network and I/O threads.
        """
        return pulumi.get(self, "request_percentage")

    @request_percentage.setter
    def request_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "request_percentage", value)


@pulumi.input_type
class KafkaUserSpecTemplateArgs:
    def __init__(__self__, *,
                 secret: Optional[pulumi.Input['KafkaUserSpecTemplateSecretArgs']] = None):
        """
        Template to specify how Kafka User `Secrets` are generated.
        :param pulumi.Input['KafkaUserSpecTemplateSecretArgs'] secret: Template for KafkaUser resources. The template allows users to specify how the `Secret` with password or TLS certificates is generated.
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input['KafkaUserSpecTemplateSecretArgs']]:
        """
        Template for KafkaUser resources. The template allows users to specify how the `Secret` with password or TLS certificates is generated.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input['KafkaUserSpecTemplateSecretArgs']]):
        pulumi.set(self, "secret", value)


@pulumi.input_type
class KafkaUserSpecTemplateSecretArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input['KafkaUserSpecTemplateSecretMetadataArgs']] = None):
        """
        Template for KafkaUser resources. The template allows users to specify how the `Secret` with password or TLS certificates is generated.
        :param pulumi.Input['KafkaUserSpecTemplateSecretMetadataArgs'] metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['KafkaUserSpecTemplateSecretMetadataArgs']]:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['KafkaUserSpecTemplateSecretMetadataArgs']]):
        pulumi.set(self, "metadata", value)


@pulumi.input_type
class KafkaUserSpecTemplateSecretMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        Metadata applied to the resource.
        :param pulumi.Input[Mapping[str, Any]] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param pulumi.Input[Mapping[str, Any]] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class KafkaUserStatusArgs:
    def __init__(__self__, *,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaUserStatusConditionsArgs']]]] = None,
                 observed_generation: Optional[pulumi.Input[int]] = None,
                 secret: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        The status of the Kafka User.
        :param pulumi.Input[Sequence[pulumi.Input['KafkaUserStatusConditionsArgs']]] conditions: List of status conditions.
        :param pulumi.Input[int] observed_generation: The generation of the CRD that was last reconciled by the operator.
        :param pulumi.Input[str] secret: The name of `Secret` where the credentials are stored.
        :param pulumi.Input[str] username: Username.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KafkaUserStatusConditionsArgs']]]]:
        """
        List of status conditions.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KafkaUserStatusConditionsArgs']]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[pulumi.Input[int]]:
        """
        The generation of the CRD that was last reconciled by the operator.
        """
        return pulumi.get(self, "observed_generation")

    @observed_generation.setter
    def observed_generation(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "observed_generation", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        """
        The name of `Secret` where the credentials are stored.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        Username.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class KafkaUserStatusConditionsArgs:
    def __init__(__self__, *,
                 last_transition_time: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] last_transition_time: Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
        :param pulumi.Input[str] message: Human-readable message indicating details about the condition's last transition.
        :param pulumi.Input[str] reason: The reason for the condition's last transition (a single word in CamelCase).
        :param pulumi.Input[str] status: The status of the condition, either True, False or Unknown.
        :param pulumi.Input[str] type: The unique identifier of a condition, used to distinguish between other conditions in the resource.
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[pulumi.Input[str]]:
        """
        Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
        """
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Human-readable message indicating details about the condition's last transition.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        The reason for the condition's last transition (a single word in CamelCase).
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of the condition, either True, False or Unknown.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The unique identifier of a condition, used to distinguish between other conditions in the resource.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


