# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from ... import _utilities, _tables
from . import outputs

__all__ = [
    'KafkaConnectS2ISpec',
    'KafkaConnectS2ISpecAffinity',
    'KafkaConnectS2ISpecAffinityNodeAffinity',
    'KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference',
    'KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions',
    'KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields',
    'KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms',
    'KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions',
    'KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields',
    'KafkaConnectS2ISpecAffinityPodAffinity',
    'KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions',
    'KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions',
    'KafkaConnectS2ISpecAffinityPodAntiAffinity',
    'KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions',
    'KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions',
    'KafkaConnectS2ISpecAuthentication',
    'KafkaConnectS2ISpecAuthenticationAccessToken',
    'KafkaConnectS2ISpecAuthenticationCertificateAndKey',
    'KafkaConnectS2ISpecAuthenticationClientSecret',
    'KafkaConnectS2ISpecAuthenticationPasswordSecret',
    'KafkaConnectS2ISpecAuthenticationRefreshToken',
    'KafkaConnectS2ISpecAuthenticationTlsTrustedCertificates',
    'KafkaConnectS2ISpecBuildResources',
    'KafkaConnectS2ISpecExternalConfiguration',
    'KafkaConnectS2ISpecExternalConfigurationEnv',
    'KafkaConnectS2ISpecExternalConfigurationEnvValueFrom',
    'KafkaConnectS2ISpecExternalConfigurationEnvValueFromConfigMapKeyRef',
    'KafkaConnectS2ISpecExternalConfigurationEnvValueFromSecretKeyRef',
    'KafkaConnectS2ISpecExternalConfigurationVolumes',
    'KafkaConnectS2ISpecExternalConfigurationVolumesConfigMap',
    'KafkaConnectS2ISpecExternalConfigurationVolumesConfigMapItems',
    'KafkaConnectS2ISpecExternalConfigurationVolumesSecret',
    'KafkaConnectS2ISpecExternalConfigurationVolumesSecretItems',
    'KafkaConnectS2ISpecJvmOptions',
    'KafkaConnectS2ISpecJvmOptionsJavaSystemProperties',
    'KafkaConnectS2ISpecLivenessProbe',
    'KafkaConnectS2ISpecLogging',
    'KafkaConnectS2ISpecRack',
    'KafkaConnectS2ISpecReadinessProbe',
    'KafkaConnectS2ISpecResources',
    'KafkaConnectS2ISpecTemplate',
    'KafkaConnectS2ISpecTemplateApiService',
    'KafkaConnectS2ISpecTemplateApiServiceMetadata',
    'KafkaConnectS2ISpecTemplateConnectContainer',
    'KafkaConnectS2ISpecTemplateConnectContainerEnv',
    'KafkaConnectS2ISpecTemplateConnectContainerSecurityContext',
    'KafkaConnectS2ISpecTemplateConnectContainerSecurityContextCapabilities',
    'KafkaConnectS2ISpecTemplateConnectContainerSecurityContextSeLinuxOptions',
    'KafkaConnectS2ISpecTemplateConnectContainerSecurityContextWindowsOptions',
    'KafkaConnectS2ISpecTemplateDeployment',
    'KafkaConnectS2ISpecTemplateDeploymentMetadata',
    'KafkaConnectS2ISpecTemplateInitContainer',
    'KafkaConnectS2ISpecTemplateInitContainerEnv',
    'KafkaConnectS2ISpecTemplateInitContainerSecurityContext',
    'KafkaConnectS2ISpecTemplateInitContainerSecurityContextCapabilities',
    'KafkaConnectS2ISpecTemplateInitContainerSecurityContextSeLinuxOptions',
    'KafkaConnectS2ISpecTemplateInitContainerSecurityContextWindowsOptions',
    'KafkaConnectS2ISpecTemplatePod',
    'KafkaConnectS2ISpecTemplatePodAffinity',
    'KafkaConnectS2ISpecTemplatePodAffinityNodeAffinity',
    'KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference',
    'KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions',
    'KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields',
    'KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms',
    'KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions',
    'KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields',
    'KafkaConnectS2ISpecTemplatePodAffinityPodAffinity',
    'KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions',
    'KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions',
    'KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinity',
    'KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions',
    'KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions',
    'KafkaConnectS2ISpecTemplatePodDisruptionBudget',
    'KafkaConnectS2ISpecTemplatePodDisruptionBudgetMetadata',
    'KafkaConnectS2ISpecTemplatePodHostAliases',
    'KafkaConnectS2ISpecTemplatePodImagePullSecrets',
    'KafkaConnectS2ISpecTemplatePodMetadata',
    'KafkaConnectS2ISpecTemplatePodSecurityContext',
    'KafkaConnectS2ISpecTemplatePodSecurityContextSeLinuxOptions',
    'KafkaConnectS2ISpecTemplatePodSecurityContextSysctls',
    'KafkaConnectS2ISpecTemplatePodSecurityContextWindowsOptions',
    'KafkaConnectS2ISpecTemplatePodTolerations',
    'KafkaConnectS2ISpecTls',
    'KafkaConnectS2ISpecTlsTrustedCertificates',
    'KafkaConnectS2ISpecTolerations',
    'KafkaConnectS2ISpecTracing',
    'KafkaConnectS2IStatus',
    'KafkaConnectS2IStatusConditions',
    'KafkaConnectS2IStatusConnectorPlugins',
    'KafkaConnectSpec',
    'KafkaConnectSpecAffinity',
    'KafkaConnectSpecAffinityNodeAffinity',
    'KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference',
    'KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions',
    'KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields',
    'KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms',
    'KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions',
    'KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields',
    'KafkaConnectSpecAffinityPodAffinity',
    'KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions',
    'KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions',
    'KafkaConnectSpecAffinityPodAntiAffinity',
    'KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions',
    'KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions',
    'KafkaConnectSpecAuthentication',
    'KafkaConnectSpecAuthenticationAccessToken',
    'KafkaConnectSpecAuthenticationCertificateAndKey',
    'KafkaConnectSpecAuthenticationClientSecret',
    'KafkaConnectSpecAuthenticationPasswordSecret',
    'KafkaConnectSpecAuthenticationRefreshToken',
    'KafkaConnectSpecAuthenticationTlsTrustedCertificates',
    'KafkaConnectSpecExternalConfiguration',
    'KafkaConnectSpecExternalConfigurationEnv',
    'KafkaConnectSpecExternalConfigurationEnvValueFrom',
    'KafkaConnectSpecExternalConfigurationEnvValueFromConfigMapKeyRef',
    'KafkaConnectSpecExternalConfigurationEnvValueFromSecretKeyRef',
    'KafkaConnectSpecExternalConfigurationVolumes',
    'KafkaConnectSpecExternalConfigurationVolumesConfigMap',
    'KafkaConnectSpecExternalConfigurationVolumesConfigMapItems',
    'KafkaConnectSpecExternalConfigurationVolumesSecret',
    'KafkaConnectSpecExternalConfigurationVolumesSecretItems',
    'KafkaConnectSpecJvmOptions',
    'KafkaConnectSpecJvmOptionsJavaSystemProperties',
    'KafkaConnectSpecLivenessProbe',
    'KafkaConnectSpecLogging',
    'KafkaConnectSpecRack',
    'KafkaConnectSpecReadinessProbe',
    'KafkaConnectSpecResources',
    'KafkaConnectSpecTemplate',
    'KafkaConnectSpecTemplateApiService',
    'KafkaConnectSpecTemplateApiServiceMetadata',
    'KafkaConnectSpecTemplateConnectContainer',
    'KafkaConnectSpecTemplateConnectContainerEnv',
    'KafkaConnectSpecTemplateConnectContainerSecurityContext',
    'KafkaConnectSpecTemplateConnectContainerSecurityContextCapabilities',
    'KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptions',
    'KafkaConnectSpecTemplateConnectContainerSecurityContextWindowsOptions',
    'KafkaConnectSpecTemplateDeployment',
    'KafkaConnectSpecTemplateDeploymentMetadata',
    'KafkaConnectSpecTemplateInitContainer',
    'KafkaConnectSpecTemplateInitContainerEnv',
    'KafkaConnectSpecTemplateInitContainerSecurityContext',
    'KafkaConnectSpecTemplateInitContainerSecurityContextCapabilities',
    'KafkaConnectSpecTemplateInitContainerSecurityContextSeLinuxOptions',
    'KafkaConnectSpecTemplateInitContainerSecurityContextWindowsOptions',
    'KafkaConnectSpecTemplatePod',
    'KafkaConnectSpecTemplatePodAffinity',
    'KafkaConnectSpecTemplatePodAffinityNodeAffinity',
    'KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference',
    'KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions',
    'KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields',
    'KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms',
    'KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions',
    'KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields',
    'KafkaConnectSpecTemplatePodAffinityPodAffinity',
    'KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions',
    'KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions',
    'KafkaConnectSpecTemplatePodAffinityPodAntiAffinity',
    'KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions',
    'KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions',
    'KafkaConnectSpecTemplatePodDisruptionBudget',
    'KafkaConnectSpecTemplatePodDisruptionBudgetMetadata',
    'KafkaConnectSpecTemplatePodHostAliases',
    'KafkaConnectSpecTemplatePodImagePullSecrets',
    'KafkaConnectSpecTemplatePodMetadata',
    'KafkaConnectSpecTemplatePodSecurityContext',
    'KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptions',
    'KafkaConnectSpecTemplatePodSecurityContextSysctls',
    'KafkaConnectSpecTemplatePodSecurityContextWindowsOptions',
    'KafkaConnectSpecTemplatePodTolerations',
    'KafkaConnectSpecTls',
    'KafkaConnectSpecTlsTrustedCertificates',
    'KafkaConnectSpecTolerations',
    'KafkaConnectSpecTracing',
    'KafkaConnectStatus',
    'KafkaConnectStatusConditions',
    'KafkaConnectStatusConnectorPlugins',
    'KafkaMirrorMakerSpec',
    'KafkaMirrorMakerSpecAffinity',
    'KafkaMirrorMakerSpecAffinityNodeAffinity',
    'KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference',
    'KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions',
    'KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields',
    'KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms',
    'KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions',
    'KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields',
    'KafkaMirrorMakerSpecAffinityPodAffinity',
    'KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions',
    'KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions',
    'KafkaMirrorMakerSpecAffinityPodAntiAffinity',
    'KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions',
    'KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions',
    'KafkaMirrorMakerSpecConsumer',
    'KafkaMirrorMakerSpecConsumerAuthentication',
    'KafkaMirrorMakerSpecConsumerAuthenticationAccessToken',
    'KafkaMirrorMakerSpecConsumerAuthenticationCertificateAndKey',
    'KafkaMirrorMakerSpecConsumerAuthenticationClientSecret',
    'KafkaMirrorMakerSpecConsumerAuthenticationPasswordSecret',
    'KafkaMirrorMakerSpecConsumerAuthenticationRefreshToken',
    'KafkaMirrorMakerSpecConsumerAuthenticationTlsTrustedCertificates',
    'KafkaMirrorMakerSpecConsumerTls',
    'KafkaMirrorMakerSpecConsumerTlsTrustedCertificates',
    'KafkaMirrorMakerSpecJvmOptions',
    'KafkaMirrorMakerSpecJvmOptionsJavaSystemProperties',
    'KafkaMirrorMakerSpecLivenessProbe',
    'KafkaMirrorMakerSpecLogging',
    'KafkaMirrorMakerSpecProducer',
    'KafkaMirrorMakerSpecProducerAuthentication',
    'KafkaMirrorMakerSpecProducerAuthenticationAccessToken',
    'KafkaMirrorMakerSpecProducerAuthenticationCertificateAndKey',
    'KafkaMirrorMakerSpecProducerAuthenticationClientSecret',
    'KafkaMirrorMakerSpecProducerAuthenticationPasswordSecret',
    'KafkaMirrorMakerSpecProducerAuthenticationRefreshToken',
    'KafkaMirrorMakerSpecProducerAuthenticationTlsTrustedCertificates',
    'KafkaMirrorMakerSpecProducerTls',
    'KafkaMirrorMakerSpecProducerTlsTrustedCertificates',
    'KafkaMirrorMakerSpecReadinessProbe',
    'KafkaMirrorMakerSpecResources',
    'KafkaMirrorMakerSpecTemplate',
    'KafkaMirrorMakerSpecTemplateDeployment',
    'KafkaMirrorMakerSpecTemplateDeploymentMetadata',
    'KafkaMirrorMakerSpecTemplateMirrorMakerContainer',
    'KafkaMirrorMakerSpecTemplateMirrorMakerContainerEnv',
    'KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContext',
    'KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextCapabilities',
    'KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextSeLinuxOptions',
    'KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextWindowsOptions',
    'KafkaMirrorMakerSpecTemplatePod',
    'KafkaMirrorMakerSpecTemplatePodAffinity',
    'KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinity',
    'KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference',
    'KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions',
    'KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields',
    'KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms',
    'KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions',
    'KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields',
    'KafkaMirrorMakerSpecTemplatePodAffinityPodAffinity',
    'KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions',
    'KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions',
    'KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinity',
    'KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions',
    'KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions',
    'KafkaMirrorMakerSpecTemplatePodDisruptionBudget',
    'KafkaMirrorMakerSpecTemplatePodDisruptionBudgetMetadata',
    'KafkaMirrorMakerSpecTemplatePodHostAliases',
    'KafkaMirrorMakerSpecTemplatePodImagePullSecrets',
    'KafkaMirrorMakerSpecTemplatePodMetadata',
    'KafkaMirrorMakerSpecTemplatePodSecurityContext',
    'KafkaMirrorMakerSpecTemplatePodSecurityContextSeLinuxOptions',
    'KafkaMirrorMakerSpecTemplatePodSecurityContextSysctls',
    'KafkaMirrorMakerSpecTemplatePodSecurityContextWindowsOptions',
    'KafkaMirrorMakerSpecTemplatePodTolerations',
    'KafkaMirrorMakerSpecTolerations',
    'KafkaMirrorMakerSpecTracing',
    'KafkaMirrorMakerStatus',
    'KafkaMirrorMakerStatusConditions',
    'KafkaSpec',
    'KafkaSpecClientsCa',
    'KafkaSpecClusterCa',
    'KafkaSpecCruiseControl',
    'KafkaSpecCruiseControlBrokerCapacity',
    'KafkaSpecCruiseControlJvmOptions',
    'KafkaSpecCruiseControlJvmOptionsJavaSystemProperties',
    'KafkaSpecCruiseControlLivenessProbe',
    'KafkaSpecCruiseControlLogging',
    'KafkaSpecCruiseControlReadinessProbe',
    'KafkaSpecCruiseControlResources',
    'KafkaSpecCruiseControlTemplate',
    'KafkaSpecCruiseControlTemplateApiService',
    'KafkaSpecCruiseControlTemplateApiServiceMetadata',
    'KafkaSpecCruiseControlTemplateCruiseControlContainer',
    'KafkaSpecCruiseControlTemplateCruiseControlContainerEnv',
    'KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext',
    'KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextCapabilities',
    'KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions',
    'KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptions',
    'KafkaSpecCruiseControlTemplateDeployment',
    'KafkaSpecCruiseControlTemplateDeploymentMetadata',
    'KafkaSpecCruiseControlTemplatePod',
    'KafkaSpecCruiseControlTemplatePodAffinity',
    'KafkaSpecCruiseControlTemplatePodAffinityNodeAffinity',
    'KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference',
    'KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions',
    'KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields',
    'KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms',
    'KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions',
    'KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields',
    'KafkaSpecCruiseControlTemplatePodAffinityPodAffinity',
    'KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions',
    'KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions',
    'KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinity',
    'KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions',
    'KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions',
    'KafkaSpecCruiseControlTemplatePodDisruptionBudget',
    'KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadata',
    'KafkaSpecCruiseControlTemplatePodHostAliases',
    'KafkaSpecCruiseControlTemplatePodImagePullSecrets',
    'KafkaSpecCruiseControlTemplatePodMetadata',
    'KafkaSpecCruiseControlTemplatePodSecurityContext',
    'KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions',
    'KafkaSpecCruiseControlTemplatePodSecurityContextSysctls',
    'KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptions',
    'KafkaSpecCruiseControlTemplatePodTolerations',
    'KafkaSpecCruiseControlTemplateTlsSidecarContainer',
    'KafkaSpecCruiseControlTemplateTlsSidecarContainerEnv',
    'KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext',
    'KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextCapabilities',
    'KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions',
    'KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptions',
    'KafkaSpecCruiseControlTlsSidecar',
    'KafkaSpecCruiseControlTlsSidecarLivenessProbe',
    'KafkaSpecCruiseControlTlsSidecarReadinessProbe',
    'KafkaSpecCruiseControlTlsSidecarResources',
    'KafkaSpecEntityOperator',
    'KafkaSpecEntityOperatorAffinity',
    'KafkaSpecEntityOperatorAffinityNodeAffinity',
    'KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference',
    'KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions',
    'KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields',
    'KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms',
    'KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions',
    'KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields',
    'KafkaSpecEntityOperatorAffinityPodAffinity',
    'KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions',
    'KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions',
    'KafkaSpecEntityOperatorAffinityPodAntiAffinity',
    'KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions',
    'KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions',
    'KafkaSpecEntityOperatorTemplate',
    'KafkaSpecEntityOperatorTemplateDeployment',
    'KafkaSpecEntityOperatorTemplateDeploymentMetadata',
    'KafkaSpecEntityOperatorTemplatePod',
    'KafkaSpecEntityOperatorTemplatePodAffinity',
    'KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinity',
    'KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference',
    'KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions',
    'KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields',
    'KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms',
    'KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions',
    'KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields',
    'KafkaSpecEntityOperatorTemplatePodAffinityPodAffinity',
    'KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions',
    'KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions',
    'KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinity',
    'KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions',
    'KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions',
    'KafkaSpecEntityOperatorTemplatePodHostAliases',
    'KafkaSpecEntityOperatorTemplatePodImagePullSecrets',
    'KafkaSpecEntityOperatorTemplatePodMetadata',
    'KafkaSpecEntityOperatorTemplatePodSecurityContext',
    'KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions',
    'KafkaSpecEntityOperatorTemplatePodSecurityContextSysctls',
    'KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptions',
    'KafkaSpecEntityOperatorTemplatePodTolerations',
    'KafkaSpecEntityOperatorTemplateTlsSidecarContainer',
    'KafkaSpecEntityOperatorTemplateTlsSidecarContainerEnv',
    'KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext',
    'KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextCapabilities',
    'KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions',
    'KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptions',
    'KafkaSpecEntityOperatorTemplateTopicOperatorContainer',
    'KafkaSpecEntityOperatorTemplateTopicOperatorContainerEnv',
    'KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext',
    'KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextCapabilities',
    'KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions',
    'KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptions',
    'KafkaSpecEntityOperatorTemplateUserOperatorContainer',
    'KafkaSpecEntityOperatorTemplateUserOperatorContainerEnv',
    'KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext',
    'KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextCapabilities',
    'KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions',
    'KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptions',
    'KafkaSpecEntityOperatorTlsSidecar',
    'KafkaSpecEntityOperatorTlsSidecarLivenessProbe',
    'KafkaSpecEntityOperatorTlsSidecarReadinessProbe',
    'KafkaSpecEntityOperatorTlsSidecarResources',
    'KafkaSpecEntityOperatorTolerations',
    'KafkaSpecEntityOperatorTopicOperator',
    'KafkaSpecEntityOperatorTopicOperatorJvmOptions',
    'KafkaSpecEntityOperatorTopicOperatorJvmOptionsJavaSystemProperties',
    'KafkaSpecEntityOperatorTopicOperatorLivenessProbe',
    'KafkaSpecEntityOperatorTopicOperatorLogging',
    'KafkaSpecEntityOperatorTopicOperatorReadinessProbe',
    'KafkaSpecEntityOperatorTopicOperatorResources',
    'KafkaSpecEntityOperatorUserOperator',
    'KafkaSpecEntityOperatorUserOperatorJvmOptions',
    'KafkaSpecEntityOperatorUserOperatorJvmOptionsJavaSystemProperties',
    'KafkaSpecEntityOperatorUserOperatorLivenessProbe',
    'KafkaSpecEntityOperatorUserOperatorLogging',
    'KafkaSpecEntityOperatorUserOperatorReadinessProbe',
    'KafkaSpecEntityOperatorUserOperatorResources',
    'KafkaSpecJmxTrans',
    'KafkaSpecJmxTransKafkaQueries',
    'KafkaSpecJmxTransOutputDefinitions',
    'KafkaSpecJmxTransResources',
    'KafkaSpecJmxTransTemplate',
    'KafkaSpecJmxTransTemplateContainer',
    'KafkaSpecJmxTransTemplateContainerEnv',
    'KafkaSpecJmxTransTemplateContainerSecurityContext',
    'KafkaSpecJmxTransTemplateContainerSecurityContextCapabilities',
    'KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions',
    'KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptions',
    'KafkaSpecJmxTransTemplateDeployment',
    'KafkaSpecJmxTransTemplateDeploymentMetadata',
    'KafkaSpecJmxTransTemplatePod',
    'KafkaSpecJmxTransTemplatePodAffinity',
    'KafkaSpecJmxTransTemplatePodAffinityNodeAffinity',
    'KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference',
    'KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions',
    'KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields',
    'KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms',
    'KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions',
    'KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields',
    'KafkaSpecJmxTransTemplatePodAffinityPodAffinity',
    'KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions',
    'KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions',
    'KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinity',
    'KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions',
    'KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions',
    'KafkaSpecJmxTransTemplatePodHostAliases',
    'KafkaSpecJmxTransTemplatePodImagePullSecrets',
    'KafkaSpecJmxTransTemplatePodMetadata',
    'KafkaSpecJmxTransTemplatePodSecurityContext',
    'KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions',
    'KafkaSpecJmxTransTemplatePodSecurityContextSysctls',
    'KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptions',
    'KafkaSpecJmxTransTemplatePodTolerations',
    'KafkaSpecKafka',
    'KafkaSpecKafkaAffinity',
    'KafkaSpecKafkaAffinityNodeAffinity',
    'KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference',
    'KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions',
    'KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields',
    'KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms',
    'KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions',
    'KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields',
    'KafkaSpecKafkaAffinityPodAffinity',
    'KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions',
    'KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions',
    'KafkaSpecKafkaAffinityPodAntiAffinity',
    'KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions',
    'KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions',
    'KafkaSpecKafkaAuthorization',
    'KafkaSpecKafkaAuthorizationTlsTrustedCertificates',
    'KafkaSpecKafkaExporter',
    'KafkaSpecKafkaExporterLivenessProbe',
    'KafkaSpecKafkaExporterReadinessProbe',
    'KafkaSpecKafkaExporterResources',
    'KafkaSpecKafkaExporterTemplate',
    'KafkaSpecKafkaExporterTemplateContainer',
    'KafkaSpecKafkaExporterTemplateContainerEnv',
    'KafkaSpecKafkaExporterTemplateContainerSecurityContext',
    'KafkaSpecKafkaExporterTemplateContainerSecurityContextCapabilities',
    'KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions',
    'KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptions',
    'KafkaSpecKafkaExporterTemplateDeployment',
    'KafkaSpecKafkaExporterTemplateDeploymentMetadata',
    'KafkaSpecKafkaExporterTemplatePod',
    'KafkaSpecKafkaExporterTemplatePodAffinity',
    'KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinity',
    'KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference',
    'KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions',
    'KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields',
    'KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms',
    'KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions',
    'KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields',
    'KafkaSpecKafkaExporterTemplatePodAffinityPodAffinity',
    'KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions',
    'KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions',
    'KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinity',
    'KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions',
    'KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions',
    'KafkaSpecKafkaExporterTemplatePodHostAliases',
    'KafkaSpecKafkaExporterTemplatePodImagePullSecrets',
    'KafkaSpecKafkaExporterTemplatePodMetadata',
    'KafkaSpecKafkaExporterTemplatePodSecurityContext',
    'KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions',
    'KafkaSpecKafkaExporterTemplatePodSecurityContextSysctls',
    'KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptions',
    'KafkaSpecKafkaExporterTemplatePodTolerations',
    'KafkaSpecKafkaExporterTemplateService',
    'KafkaSpecKafkaExporterTemplateServiceMetadata',
    'KafkaSpecKafkaJmxOptions',
    'KafkaSpecKafkaJmxOptionsAuthentication',
    'KafkaSpecKafkaJvmOptions',
    'KafkaSpecKafkaJvmOptionsJavaSystemProperties',
    'KafkaSpecKafkaListenersOneOf0',
    'KafkaSpecKafkaListenersOneOf0Authentication',
    'KafkaSpecKafkaListenersOneOf0AuthenticationClientSecret',
    'KafkaSpecKafkaListenersOneOf0AuthenticationTlsTrustedCertificates',
    'KafkaSpecKafkaListenersOneOf0Configuration',
    'KafkaSpecKafkaListenersOneOf0ConfigurationBootstrap',
    'KafkaSpecKafkaListenersOneOf0ConfigurationBrokerCertChainAndKey',
    'KafkaSpecKafkaListenersOneOf0ConfigurationBrokers',
    'KafkaSpecKafkaListenersOneOf0NetworkPolicyPeers',
    'KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersIpBlock',
    'KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersNamespaceSelector',
    'KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersNamespaceSelectorMatchExpressions',
    'KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersPodSelector',
    'KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersPodSelectorMatchExpressions',
    'KafkaSpecKafkaListenersOneOf1',
    'KafkaSpecKafkaListenersOneOf1External',
    'KafkaSpecKafkaListenersOneOf1ExternalAuthentication',
    'KafkaSpecKafkaListenersOneOf1ExternalAuthenticationClientSecret',
    'KafkaSpecKafkaListenersOneOf1ExternalAuthenticationTlsTrustedCertificates',
    'KafkaSpecKafkaListenersOneOf1ExternalConfiguration',
    'KafkaSpecKafkaListenersOneOf1ExternalConfigurationBootstrap',
    'KafkaSpecKafkaListenersOneOf1ExternalConfigurationBrokerCertChainAndKey',
    'KafkaSpecKafkaListenersOneOf1ExternalConfigurationBrokers',
    'KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeers',
    'KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersIpBlock',
    'KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersNamespaceSelector',
    'KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersNamespaceSelectorMatchExpressions',
    'KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersPodSelector',
    'KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersPodSelectorMatchExpressions',
    'KafkaSpecKafkaListenersOneOf1ExternalOverrides',
    'KafkaSpecKafkaListenersOneOf1ExternalOverridesBootstrap',
    'KafkaSpecKafkaListenersOneOf1ExternalOverridesBrokers',
    'KafkaSpecKafkaListenersOneOf1Plain',
    'KafkaSpecKafkaListenersOneOf1PlainAuthentication',
    'KafkaSpecKafkaListenersOneOf1PlainAuthenticationClientSecret',
    'KafkaSpecKafkaListenersOneOf1PlainAuthenticationTlsTrustedCertificates',
    'KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeers',
    'KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersIpBlock',
    'KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersNamespaceSelector',
    'KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersNamespaceSelectorMatchExpressions',
    'KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersPodSelector',
    'KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersPodSelectorMatchExpressions',
    'KafkaSpecKafkaListenersOneOf1Tls',
    'KafkaSpecKafkaListenersOneOf1TlsAuthentication',
    'KafkaSpecKafkaListenersOneOf1TlsAuthenticationClientSecret',
    'KafkaSpecKafkaListenersOneOf1TlsAuthenticationTlsTrustedCertificates',
    'KafkaSpecKafkaListenersOneOf1TlsConfiguration',
    'KafkaSpecKafkaListenersOneOf1TlsConfigurationBrokerCertChainAndKey',
    'KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeers',
    'KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersIpBlock',
    'KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersNamespaceSelector',
    'KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersNamespaceSelectorMatchExpressions',
    'KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersPodSelector',
    'KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersPodSelectorMatchExpressions',
    'KafkaSpecKafkaLivenessProbe',
    'KafkaSpecKafkaLogging',
    'KafkaSpecKafkaRack',
    'KafkaSpecKafkaReadinessProbe',
    'KafkaSpecKafkaResources',
    'KafkaSpecKafkaStorage',
    'KafkaSpecKafkaStorageOverrides',
    'KafkaSpecKafkaStorageVolumes',
    'KafkaSpecKafkaStorageVolumesOverrides',
    'KafkaSpecKafkaTemplate',
    'KafkaSpecKafkaTemplateBootstrapService',
    'KafkaSpecKafkaTemplateBootstrapServiceMetadata',
    'KafkaSpecKafkaTemplateBrokersService',
    'KafkaSpecKafkaTemplateBrokersServiceMetadata',
    'KafkaSpecKafkaTemplateExternalBootstrapIngress',
    'KafkaSpecKafkaTemplateExternalBootstrapIngressMetadata',
    'KafkaSpecKafkaTemplateExternalBootstrapRoute',
    'KafkaSpecKafkaTemplateExternalBootstrapRouteMetadata',
    'KafkaSpecKafkaTemplateExternalBootstrapService',
    'KafkaSpecKafkaTemplateExternalBootstrapServiceMetadata',
    'KafkaSpecKafkaTemplateInitContainer',
    'KafkaSpecKafkaTemplateInitContainerEnv',
    'KafkaSpecKafkaTemplateInitContainerSecurityContext',
    'KafkaSpecKafkaTemplateInitContainerSecurityContextCapabilities',
    'KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions',
    'KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptions',
    'KafkaSpecKafkaTemplateKafkaContainer',
    'KafkaSpecKafkaTemplateKafkaContainerEnv',
    'KafkaSpecKafkaTemplateKafkaContainerSecurityContext',
    'KafkaSpecKafkaTemplateKafkaContainerSecurityContextCapabilities',
    'KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions',
    'KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptions',
    'KafkaSpecKafkaTemplatePerPodIngress',
    'KafkaSpecKafkaTemplatePerPodIngressMetadata',
    'KafkaSpecKafkaTemplatePerPodRoute',
    'KafkaSpecKafkaTemplatePerPodRouteMetadata',
    'KafkaSpecKafkaTemplatePerPodService',
    'KafkaSpecKafkaTemplatePerPodServiceMetadata',
    'KafkaSpecKafkaTemplatePersistentVolumeClaim',
    'KafkaSpecKafkaTemplatePersistentVolumeClaimMetadata',
    'KafkaSpecKafkaTemplatePod',
    'KafkaSpecKafkaTemplatePodAffinity',
    'KafkaSpecKafkaTemplatePodAffinityNodeAffinity',
    'KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference',
    'KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions',
    'KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields',
    'KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms',
    'KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions',
    'KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields',
    'KafkaSpecKafkaTemplatePodAffinityPodAffinity',
    'KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions',
    'KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions',
    'KafkaSpecKafkaTemplatePodAffinityPodAntiAffinity',
    'KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions',
    'KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions',
    'KafkaSpecKafkaTemplatePodDisruptionBudget',
    'KafkaSpecKafkaTemplatePodDisruptionBudgetMetadata',
    'KafkaSpecKafkaTemplatePodHostAliases',
    'KafkaSpecKafkaTemplatePodImagePullSecrets',
    'KafkaSpecKafkaTemplatePodMetadata',
    'KafkaSpecKafkaTemplatePodSecurityContext',
    'KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions',
    'KafkaSpecKafkaTemplatePodSecurityContextSysctls',
    'KafkaSpecKafkaTemplatePodSecurityContextWindowsOptions',
    'KafkaSpecKafkaTemplatePodTolerations',
    'KafkaSpecKafkaTemplateStatefulset',
    'KafkaSpecKafkaTemplateStatefulsetMetadata',
    'KafkaSpecKafkaTemplateTlsSidecarContainer',
    'KafkaSpecKafkaTemplateTlsSidecarContainerEnv',
    'KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContext',
    'KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextCapabilities',
    'KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextSeLinuxOptions',
    'KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextWindowsOptions',
    'KafkaSpecKafkaTlsSidecar',
    'KafkaSpecKafkaTlsSidecarLivenessProbe',
    'KafkaSpecKafkaTlsSidecarReadinessProbe',
    'KafkaSpecKafkaTlsSidecarResources',
    'KafkaSpecKafkaTolerations',
    'KafkaSpecTopicOperator',
    'KafkaSpecTopicOperatorAffinity',
    'KafkaSpecTopicOperatorAffinityNodeAffinity',
    'KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference',
    'KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions',
    'KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields',
    'KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms',
    'KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions',
    'KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields',
    'KafkaSpecTopicOperatorAffinityPodAffinity',
    'KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions',
    'KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions',
    'KafkaSpecTopicOperatorAffinityPodAntiAffinity',
    'KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions',
    'KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions',
    'KafkaSpecTopicOperatorJvmOptions',
    'KafkaSpecTopicOperatorJvmOptionsJavaSystemProperties',
    'KafkaSpecTopicOperatorLivenessProbe',
    'KafkaSpecTopicOperatorLogging',
    'KafkaSpecTopicOperatorReadinessProbe',
    'KafkaSpecTopicOperatorResources',
    'KafkaSpecTopicOperatorTlsSidecar',
    'KafkaSpecTopicOperatorTlsSidecarLivenessProbe',
    'KafkaSpecTopicOperatorTlsSidecarReadinessProbe',
    'KafkaSpecTopicOperatorTlsSidecarResources',
    'KafkaSpecZookeeper',
    'KafkaSpecZookeeperAffinity',
    'KafkaSpecZookeeperAffinityNodeAffinity',
    'KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference',
    'KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions',
    'KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields',
    'KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms',
    'KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions',
    'KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields',
    'KafkaSpecZookeeperAffinityPodAffinity',
    'KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions',
    'KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions',
    'KafkaSpecZookeeperAffinityPodAntiAffinity',
    'KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions',
    'KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions',
    'KafkaSpecZookeeperJvmOptions',
    'KafkaSpecZookeeperJvmOptionsJavaSystemProperties',
    'KafkaSpecZookeeperLivenessProbe',
    'KafkaSpecZookeeperLogging',
    'KafkaSpecZookeeperReadinessProbe',
    'KafkaSpecZookeeperResources',
    'KafkaSpecZookeeperStorage',
    'KafkaSpecZookeeperStorageOverrides',
    'KafkaSpecZookeeperTemplate',
    'KafkaSpecZookeeperTemplateClientService',
    'KafkaSpecZookeeperTemplateClientServiceMetadata',
    'KafkaSpecZookeeperTemplateNodesService',
    'KafkaSpecZookeeperTemplateNodesServiceMetadata',
    'KafkaSpecZookeeperTemplatePersistentVolumeClaim',
    'KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadata',
    'KafkaSpecZookeeperTemplatePod',
    'KafkaSpecZookeeperTemplatePodAffinity',
    'KafkaSpecZookeeperTemplatePodAffinityNodeAffinity',
    'KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference',
    'KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions',
    'KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields',
    'KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms',
    'KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions',
    'KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields',
    'KafkaSpecZookeeperTemplatePodAffinityPodAffinity',
    'KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions',
    'KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions',
    'KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinity',
    'KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm',
    'KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector',
    'KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions',
    'KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution',
    'KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector',
    'KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions',
    'KafkaSpecZookeeperTemplatePodDisruptionBudget',
    'KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadata',
    'KafkaSpecZookeeperTemplatePodHostAliases',
    'KafkaSpecZookeeperTemplatePodImagePullSecrets',
    'KafkaSpecZookeeperTemplatePodMetadata',
    'KafkaSpecZookeeperTemplatePodSecurityContext',
    'KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions',
    'KafkaSpecZookeeperTemplatePodSecurityContextSysctls',
    'KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptions',
    'KafkaSpecZookeeperTemplatePodTolerations',
    'KafkaSpecZookeeperTemplateStatefulset',
    'KafkaSpecZookeeperTemplateStatefulsetMetadata',
    'KafkaSpecZookeeperTemplateTlsSidecarContainer',
    'KafkaSpecZookeeperTemplateTlsSidecarContainerEnv',
    'KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContext',
    'KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextCapabilities',
    'KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextSeLinuxOptions',
    'KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextWindowsOptions',
    'KafkaSpecZookeeperTemplateZookeeperContainer',
    'KafkaSpecZookeeperTemplateZookeeperContainerEnv',
    'KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext',
    'KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextCapabilities',
    'KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions',
    'KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptions',
    'KafkaSpecZookeeperTlsSidecar',
    'KafkaSpecZookeeperTlsSidecarLivenessProbe',
    'KafkaSpecZookeeperTlsSidecarReadinessProbe',
    'KafkaSpecZookeeperTlsSidecarResources',
    'KafkaSpecZookeeperTolerations',
    'KafkaStatus',
    'KafkaStatusConditions',
    'KafkaStatusListeners',
    'KafkaStatusListenersAddresses',
    'KafkaTopicSpec',
    'KafkaTopicStatus',
    'KafkaTopicStatusConditions',
    'KafkaUserSpec',
    'KafkaUserSpecAuthentication',
    'KafkaUserSpecAuthorization',
    'KafkaUserSpecAuthorizationAcls',
    'KafkaUserSpecAuthorizationAclsResource',
    'KafkaUserSpecQuotas',
    'KafkaUserSpecTemplate',
    'KafkaUserSpecTemplateSecret',
    'KafkaUserSpecTemplateSecretMetadata',
    'KafkaUserStatus',
    'KafkaUserStatusConditions',
]

@pulumi.output_type
class KafkaConnectS2ISpec(dict):
    """
    The specification of the Kafka Connect Source-to-Image (S2I) cluster.
    """
    def __init__(__self__, *,
                 bootstrap_servers: str,
                 affinity: Optional['outputs.KafkaConnectS2ISpecAffinity'] = None,
                 authentication: Optional['outputs.KafkaConnectS2ISpecAuthentication'] = None,
                 build_resources: Optional['outputs.KafkaConnectS2ISpecBuildResources'] = None,
                 client_rack_init_image: Optional[str] = None,
                 config: Optional[Mapping[str, Any]] = None,
                 external_configuration: Optional['outputs.KafkaConnectS2ISpecExternalConfiguration'] = None,
                 image: Optional[str] = None,
                 insecure_source_repository: Optional[bool] = None,
                 jvm_options: Optional['outputs.KafkaConnectS2ISpecJvmOptions'] = None,
                 liveness_probe: Optional['outputs.KafkaConnectS2ISpecLivenessProbe'] = None,
                 logging: Optional['outputs.KafkaConnectS2ISpecLogging'] = None,
                 metrics: Optional[Mapping[str, Any]] = None,
                 rack: Optional['outputs.KafkaConnectS2ISpecRack'] = None,
                 readiness_probe: Optional['outputs.KafkaConnectS2ISpecReadinessProbe'] = None,
                 replicas: Optional[int] = None,
                 resources: Optional['outputs.KafkaConnectS2ISpecResources'] = None,
                 template: Optional['outputs.KafkaConnectS2ISpecTemplate'] = None,
                 tls: Optional['outputs.KafkaConnectS2ISpecTls'] = None,
                 tolerations: Optional[Sequence['outputs.KafkaConnectS2ISpecTolerations']] = None,
                 tracing: Optional['outputs.KafkaConnectS2ISpecTracing'] = None,
                 version: Optional[str] = None):
        """
        The specification of the Kafka Connect Source-to-Image (S2I) cluster.
        :param str bootstrap_servers: Bootstrap servers to connect to. This should be given as a comma separated list of _<hostname>_:‍_<port>_ pairs.
        :param 'KafkaConnectS2ISpecAffinityArgs' affinity: The pod's affinity rules.
        :param 'KafkaConnectS2ISpecAuthenticationArgs' authentication: Authentication configuration for Kafka Connect.
        :param 'KafkaConnectS2ISpecBuildResourcesArgs' build_resources: CPU and memory resources to reserve.
        :param str client_rack_init_image: The image of the init container used for initializing the `client.rack`.
        :param Mapping[str, Any] config: The Kafka Connect configuration. Properties with the following prefixes cannot be set: ssl., sasl., security., listeners, plugin.path, rest., bootstrap.servers, consumer.interceptor.classes, producer.interceptor.classes (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
        :param 'KafkaConnectS2ISpecExternalConfigurationArgs' external_configuration: Pass data from Secrets or ConfigMaps to the Kafka Connect pods and use them to configure connectors.
        :param str image: The docker image for the pods.
        :param bool insecure_source_repository: When true this configures the source repository with the 'Local' reference policy and an import policy that accepts insecure source tags.
        :param 'KafkaConnectS2ISpecJvmOptionsArgs' jvm_options: JVM Options for pods.
        :param 'KafkaConnectS2ISpecLivenessProbeArgs' liveness_probe: Pod liveness checking.
        :param 'KafkaConnectS2ISpecLoggingArgs' logging: Logging configuration for Kafka Connect.
        :param Mapping[str, Any] metrics: The Prometheus JMX Exporter configuration. See https://github.com/prometheus/jmx_exporter for details of the structure of this configuration.
        :param 'KafkaConnectS2ISpecRackArgs' rack: Configuration of the node label which will be used as the client.rack consumer configuration.
        :param 'KafkaConnectS2ISpecReadinessProbeArgs' readiness_probe: Pod readiness checking.
        :param int replicas: The number of pods in the Kafka Connect group.
        :param 'KafkaConnectS2ISpecResourcesArgs' resources: The maximum limits for CPU and memory resources and the requested initial resources.
        :param 'KafkaConnectS2ISpecTemplateArgs' template: Template for Kafka Connect and Kafka Connect S2I resources. The template allows users to specify how the `Deployment`, `Pods` and `Service` are generated.
        :param 'KafkaConnectS2ISpecTlsArgs' tls: TLS configuration.
        :param Sequence['KafkaConnectS2ISpecTolerationsArgs'] tolerations: The pod's tolerations.
        :param 'KafkaConnectS2ISpecTracingArgs' tracing: The configuration of tracing in Kafka Connect.
        :param str version: The Kafka Connect version. Defaults to {DefaultKafkaVersion}. Consult the user documentation to understand the process required to upgrade or downgrade the version.
        """
        pulumi.set(__self__, "bootstrap_servers", bootstrap_servers)
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if build_resources is not None:
            pulumi.set(__self__, "build_resources", build_resources)
        if client_rack_init_image is not None:
            pulumi.set(__self__, "client_rack_init_image", client_rack_init_image)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if external_configuration is not None:
            pulumi.set(__self__, "external_configuration", external_configuration)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if insecure_source_repository is not None:
            pulumi.set(__self__, "insecure_source_repository", insecure_source_repository)
        if jvm_options is not None:
            pulumi.set(__self__, "jvm_options", jvm_options)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if rack is not None:
            pulumi.set(__self__, "rack", rack)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if template is not None:
            pulumi.set(__self__, "template", template)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)
        if tracing is not None:
            pulumi.set(__self__, "tracing", tracing)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="bootstrapServers")
    def bootstrap_servers(self) -> str:
        """
        Bootstrap servers to connect to. This should be given as a comma separated list of _<hostname>_:‍_<port>_ pairs.
        """
        return pulumi.get(self, "bootstrap_servers")

    @property
    @pulumi.getter
    def affinity(self) -> Optional['outputs.KafkaConnectS2ISpecAffinity']:
        """
        The pod's affinity rules.
        """
        return pulumi.get(self, "affinity")

    @property
    @pulumi.getter
    def authentication(self) -> Optional['outputs.KafkaConnectS2ISpecAuthentication']:
        """
        Authentication configuration for Kafka Connect.
        """
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter(name="buildResources")
    def build_resources(self) -> Optional['outputs.KafkaConnectS2ISpecBuildResources']:
        """
        CPU and memory resources to reserve.
        """
        return pulumi.get(self, "build_resources")

    @property
    @pulumi.getter(name="clientRackInitImage")
    def client_rack_init_image(self) -> Optional[str]:
        """
        The image of the init container used for initializing the `client.rack`.
        """
        return pulumi.get(self, "client_rack_init_image")

    @property
    @pulumi.getter
    def config(self) -> Optional[Mapping[str, Any]]:
        """
        The Kafka Connect configuration. Properties with the following prefixes cannot be set: ssl., sasl., security., listeners, plugin.path, rest., bootstrap.servers, consumer.interceptor.classes, producer.interceptor.classes (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter(name="externalConfiguration")
    def external_configuration(self) -> Optional['outputs.KafkaConnectS2ISpecExternalConfiguration']:
        """
        Pass data from Secrets or ConfigMaps to the Kafka Connect pods and use them to configure connectors.
        """
        return pulumi.get(self, "external_configuration")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        The docker image for the pods.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="insecureSourceRepository")
    def insecure_source_repository(self) -> Optional[bool]:
        """
        When true this configures the source repository with the 'Local' reference policy and an import policy that accepts insecure source tags.
        """
        return pulumi.get(self, "insecure_source_repository")

    @property
    @pulumi.getter(name="jvmOptions")
    def jvm_options(self) -> Optional['outputs.KafkaConnectS2ISpecJvmOptions']:
        """
        JVM Options for pods.
        """
        return pulumi.get(self, "jvm_options")

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional['outputs.KafkaConnectS2ISpecLivenessProbe']:
        """
        Pod liveness checking.
        """
        return pulumi.get(self, "liveness_probe")

    @property
    @pulumi.getter
    def logging(self) -> Optional['outputs.KafkaConnectS2ISpecLogging']:
        """
        Logging configuration for Kafka Connect.
        """
        return pulumi.get(self, "logging")

    @property
    @pulumi.getter
    def metrics(self) -> Optional[Mapping[str, Any]]:
        """
        The Prometheus JMX Exporter configuration. See https://github.com/prometheus/jmx_exporter for details of the structure of this configuration.
        """
        return pulumi.get(self, "metrics")

    @property
    @pulumi.getter
    def rack(self) -> Optional['outputs.KafkaConnectS2ISpecRack']:
        """
        Configuration of the node label which will be used as the client.rack consumer configuration.
        """
        return pulumi.get(self, "rack")

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional['outputs.KafkaConnectS2ISpecReadinessProbe']:
        """
        Pod readiness checking.
        """
        return pulumi.get(self, "readiness_probe")

    @property
    @pulumi.getter
    def replicas(self) -> Optional[int]:
        """
        The number of pods in the Kafka Connect group.
        """
        return pulumi.get(self, "replicas")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.KafkaConnectS2ISpecResources']:
        """
        The maximum limits for CPU and memory resources and the requested initial resources.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter
    def template(self) -> Optional['outputs.KafkaConnectS2ISpecTemplate']:
        """
        Template for Kafka Connect and Kafka Connect S2I resources. The template allows users to specify how the `Deployment`, `Pods` and `Service` are generated.
        """
        return pulumi.get(self, "template")

    @property
    @pulumi.getter
    def tls(self) -> Optional['outputs.KafkaConnectS2ISpecTls']:
        """
        TLS configuration.
        """
        return pulumi.get(self, "tls")

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[Sequence['outputs.KafkaConnectS2ISpecTolerations']]:
        """
        The pod's tolerations.
        """
        return pulumi.get(self, "tolerations")

    @property
    @pulumi.getter
    def tracing(self) -> Optional['outputs.KafkaConnectS2ISpecTracing']:
        """
        The configuration of tracing in Kafka Connect.
        """
        return pulumi.get(self, "tracing")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        The Kafka Connect version. Defaults to {DefaultKafkaVersion}. Consult the user documentation to understand the process required to upgrade or downgrade the version.
        """
        return pulumi.get(self, "version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecAffinity(dict):
    """
    The pod's affinity rules.
    """
    def __init__(__self__, *,
                 node_affinity: Optional['outputs.KafkaConnectS2ISpecAffinityNodeAffinity'] = None,
                 pod_affinity: Optional['outputs.KafkaConnectS2ISpecAffinityPodAffinity'] = None,
                 pod_anti_affinity: Optional['outputs.KafkaConnectS2ISpecAffinityPodAntiAffinity'] = None):
        """
        The pod's affinity rules.
        """
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional['outputs.KafkaConnectS2ISpecAffinityNodeAffinity']:
        return pulumi.get(self, "node_affinity")

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional['outputs.KafkaConnectS2ISpecAffinityPodAffinity']:
        return pulumi.get(self, "pod_affinity")

    @property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional['outputs.KafkaConnectS2ISpecAffinityPodAntiAffinity']:
        return pulumi.get(self, "pod_anti_affinity")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecAffinityNodeAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional['outputs.KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution'] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional['outputs.KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution']:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 preference: Optional['outputs.KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference'] = None,
                 weight: Optional[int] = None):
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preference(self) -> Optional['outputs.KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference']:
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions']] = None,
                 match_fields: Optional[Sequence['outputs.KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields']] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields']]:
        return pulumi.get(self, "match_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 node_selector_terms: Optional[Sequence['outputs.KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms']] = None):
        if node_selector_terms is not None:
            pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> Optional[Sequence['outputs.KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms']]:
        return pulumi.get(self, "node_selector_terms")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions']] = None,
                 match_fields: Optional[Sequence['outputs.KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields']] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields']]:
        return pulumi.get(self, "match_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecAffinityPodAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 pod_affinity_term: Optional['outputs.KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm'] = None,
                 weight: Optional[int] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional['outputs.KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm']:
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecAffinityPodAntiAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 pod_affinity_term: Optional['outputs.KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm'] = None,
                 weight: Optional[int] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional['outputs.KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm']:
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecAuthentication(dict):
    """
    Authentication configuration for Kafka Connect.
    """
    def __init__(__self__, *,
                 type: str,
                 access_token: Optional['outputs.KafkaConnectS2ISpecAuthenticationAccessToken'] = None,
                 access_token_is_jwt: Optional[bool] = None,
                 certificate_and_key: Optional['outputs.KafkaConnectS2ISpecAuthenticationCertificateAndKey'] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional['outputs.KafkaConnectS2ISpecAuthenticationClientSecret'] = None,
                 disable_tls_hostname_verification: Optional[bool] = None,
                 max_token_expiry_seconds: Optional[int] = None,
                 password_secret: Optional['outputs.KafkaConnectS2ISpecAuthenticationPasswordSecret'] = None,
                 refresh_token: Optional['outputs.KafkaConnectS2ISpecAuthenticationRefreshToken'] = None,
                 scope: Optional[str] = None,
                 tls_trusted_certificates: Optional[Sequence['outputs.KafkaConnectS2ISpecAuthenticationTlsTrustedCertificates']] = None,
                 token_endpoint_uri: Optional[str] = None,
                 username: Optional[str] = None):
        """
        Authentication configuration for Kafka Connect.
        :param str type: Authentication type. Currently the only supported types are `tls`, `scram-sha-512`, and `plain`. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
        :param 'KafkaConnectS2ISpecAuthenticationAccessTokenArgs' access_token: Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
        :param bool access_token_is_jwt: Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
        :param 'KafkaConnectS2ISpecAuthenticationCertificateAndKeyArgs' certificate_and_key: Reference to the `Secret` which holds the certificate and private key pair.
        :param str client_id: OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        :param 'KafkaConnectS2ISpecAuthenticationClientSecretArgs' client_secret: Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        :param bool disable_tls_hostname_verification: Enable or disable TLS hostname verification. Default value is `false`.
        :param int max_token_expiry_seconds: Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.
        :param 'KafkaConnectS2ISpecAuthenticationPasswordSecretArgs' password_secret: Reference to the `Secret` which holds the password.
        :param 'KafkaConnectS2ISpecAuthenticationRefreshTokenArgs' refresh_token: Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
        :param str scope: OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.
        :param Sequence['KafkaConnectS2ISpecAuthenticationTlsTrustedCertificatesArgs'] tls_trusted_certificates: Trusted certificates for TLS connection to the OAuth server.
        :param str token_endpoint_uri: Authorization server token endpoint URI.
        :param str username: Username used for the authentication.
        """
        pulumi.set(__self__, "type", type)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if access_token_is_jwt is not None:
            pulumi.set(__self__, "access_token_is_jwt", access_token_is_jwt)
        if certificate_and_key is not None:
            pulumi.set(__self__, "certificate_and_key", certificate_and_key)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if disable_tls_hostname_verification is not None:
            pulumi.set(__self__, "disable_tls_hostname_verification", disable_tls_hostname_verification)
        if max_token_expiry_seconds is not None:
            pulumi.set(__self__, "max_token_expiry_seconds", max_token_expiry_seconds)
        if password_secret is not None:
            pulumi.set(__self__, "password_secret", password_secret)
        if refresh_token is not None:
            pulumi.set(__self__, "refresh_token", refresh_token)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if tls_trusted_certificates is not None:
            pulumi.set(__self__, "tls_trusted_certificates", tls_trusted_certificates)
        if token_endpoint_uri is not None:
            pulumi.set(__self__, "token_endpoint_uri", token_endpoint_uri)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Authentication type. Currently the only supported types are `tls`, `scram-sha-512`, and `plain`. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional['outputs.KafkaConnectS2ISpecAuthenticationAccessToken']:
        """
        Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="accessTokenIsJwt")
    def access_token_is_jwt(self) -> Optional[bool]:
        """
        Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
        """
        return pulumi.get(self, "access_token_is_jwt")

    @property
    @pulumi.getter(name="certificateAndKey")
    def certificate_and_key(self) -> Optional['outputs.KafkaConnectS2ISpecAuthenticationCertificateAndKey']:
        """
        Reference to the `Secret` which holds the certificate and private key pair.
        """
        return pulumi.get(self, "certificate_and_key")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional['outputs.KafkaConnectS2ISpecAuthenticationClientSecret']:
        """
        Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="disableTlsHostnameVerification")
    def disable_tls_hostname_verification(self) -> Optional[bool]:
        """
        Enable or disable TLS hostname verification. Default value is `false`.
        """
        return pulumi.get(self, "disable_tls_hostname_verification")

    @property
    @pulumi.getter(name="maxTokenExpirySeconds")
    def max_token_expiry_seconds(self) -> Optional[int]:
        """
        Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.
        """
        return pulumi.get(self, "max_token_expiry_seconds")

    @property
    @pulumi.getter(name="passwordSecret")
    def password_secret(self) -> Optional['outputs.KafkaConnectS2ISpecAuthenticationPasswordSecret']:
        """
        Reference to the `Secret` which holds the password.
        """
        return pulumi.get(self, "password_secret")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional['outputs.KafkaConnectS2ISpecAuthenticationRefreshToken']:
        """
        Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
        """
        return pulumi.get(self, "refresh_token")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter(name="tlsTrustedCertificates")
    def tls_trusted_certificates(self) -> Optional[Sequence['outputs.KafkaConnectS2ISpecAuthenticationTlsTrustedCertificates']]:
        """
        Trusted certificates for TLS connection to the OAuth server.
        """
        return pulumi.get(self, "tls_trusted_certificates")

    @property
    @pulumi.getter(name="tokenEndpointUri")
    def token_endpoint_uri(self) -> Optional[str]:
        """
        Authorization server token endpoint URI.
        """
        return pulumi.get(self, "token_endpoint_uri")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username used for the authentication.
        """
        return pulumi.get(self, "username")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecAuthenticationAccessToken(dict):
    """
    Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
    """
    def __init__(__self__, *,
                 key: str,
                 secret_name: str):
        """
        Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
        :param str key: The key under which the secret value is stored in the Kubernetes Secret.
        :param str secret_name: The name of the Kubernetes Secret containing the secret value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key under which the secret value is stored in the Kubernetes Secret.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Kubernetes Secret containing the secret value.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecAuthenticationCertificateAndKey(dict):
    """
    Reference to the `Secret` which holds the certificate and private key pair.
    """
    def __init__(__self__, *,
                 certificate: str,
                 key: str,
                 secret_name: str):
        """
        Reference to the `Secret` which holds the certificate and private key pair.
        :param str certificate: The name of the file certificate in the Secret.
        :param str key: The name of the private key in the Secret.
        :param str secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> str:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The name of the private key in the Secret.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecAuthenticationClientSecret(dict):
    """
    Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
    """
    def __init__(__self__, *,
                 key: str,
                 secret_name: str):
        """
        Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        :param str key: The key under which the secret value is stored in the Kubernetes Secret.
        :param str secret_name: The name of the Kubernetes Secret containing the secret value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key under which the secret value is stored in the Kubernetes Secret.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Kubernetes Secret containing the secret value.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecAuthenticationPasswordSecret(dict):
    """
    Reference to the `Secret` which holds the password.
    """
    def __init__(__self__, *,
                 password: str,
                 secret_name: str):
        """
        Reference to the `Secret` which holds the password.
        :param str password: The name of the key in the Secret under which the password is stored.
        :param str secret_name: The name of the Secret containing the password.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The name of the key in the Secret under which the password is stored.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Secret containing the password.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecAuthenticationRefreshToken(dict):
    """
    Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
    """
    def __init__(__self__, *,
                 key: str,
                 secret_name: str):
        """
        Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
        :param str key: The key under which the secret value is stored in the Kubernetes Secret.
        :param str secret_name: The name of the Kubernetes Secret containing the secret value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key under which the secret value is stored in the Kubernetes Secret.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Kubernetes Secret containing the secret value.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecAuthenticationTlsTrustedCertificates(dict):
    def __init__(__self__, *,
                 certificate: str,
                 secret_name: str):
        """
        :param str certificate: The name of the file certificate in the Secret.
        :param str secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> str:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecBuildResources(dict):
    """
    CPU and memory resources to reserve.
    """
    def __init__(__self__, *,
                 limits: Optional[Mapping[str, Any]] = None,
                 requests: Optional[Mapping[str, Any]] = None):
        """
        CPU and memory resources to reserve.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "requests")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecExternalConfiguration(dict):
    """
    Pass data from Secrets or ConfigMaps to the Kafka Connect pods and use them to configure connectors.
    """
    def __init__(__self__, *,
                 env: Optional[Sequence['outputs.KafkaConnectS2ISpecExternalConfigurationEnv']] = None,
                 volumes: Optional[Sequence['outputs.KafkaConnectS2ISpecExternalConfigurationVolumes']] = None):
        """
        Pass data from Secrets or ConfigMaps to the Kafka Connect pods and use them to configure connectors.
        :param Sequence['KafkaConnectS2ISpecExternalConfigurationEnvArgs'] env: Allows to pass data from Secret or ConfigMap to the Kafka Connect pods as environment variables.
        :param Sequence['KafkaConnectS2ISpecExternalConfigurationVolumesArgs'] volumes: Allows to pass data from Secret or ConfigMap to the Kafka Connect pods as volumes.
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @property
    @pulumi.getter
    def env(self) -> Optional[Sequence['outputs.KafkaConnectS2ISpecExternalConfigurationEnv']]:
        """
        Allows to pass data from Secret or ConfigMap to the Kafka Connect pods as environment variables.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def volumes(self) -> Optional[Sequence['outputs.KafkaConnectS2ISpecExternalConfigurationVolumes']]:
        """
        Allows to pass data from Secret or ConfigMap to the Kafka Connect pods as volumes.
        """
        return pulumi.get(self, "volumes")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecExternalConfigurationEnv(dict):
    def __init__(__self__, *,
                 name: str,
                 value_from: 'outputs.KafkaConnectS2ISpecExternalConfigurationEnvValueFrom'):
        """
        :param str name: Name of the environment variable which will be passed to the Kafka Connect pods. The name of the environment variable cannot start with `KAFKA_` or `STRIMZI_`.
        :param 'KafkaConnectS2ISpecExternalConfigurationEnvValueFromArgs' value_from: Value of the environment variable which will be passed to the Kafka Connect pods. It can be passed either as a reference to Secret or ConfigMap field. The field has to specify exactly one Secret or ConfigMap.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value_from", value_from)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the environment variable which will be passed to the Kafka Connect pods. The name of the environment variable cannot start with `KAFKA_` or `STRIMZI_`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="valueFrom")
    def value_from(self) -> 'outputs.KafkaConnectS2ISpecExternalConfigurationEnvValueFrom':
        """
        Value of the environment variable which will be passed to the Kafka Connect pods. It can be passed either as a reference to Secret or ConfigMap field. The field has to specify exactly one Secret or ConfigMap.
        """
        return pulumi.get(self, "value_from")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecExternalConfigurationEnvValueFrom(dict):
    """
    Value of the environment variable which will be passed to the Kafka Connect pods. It can be passed either as a reference to Secret or ConfigMap field. The field has to specify exactly one Secret or ConfigMap.
    """
    def __init__(__self__, *,
                 config_map_key_ref: Optional['outputs.KafkaConnectS2ISpecExternalConfigurationEnvValueFromConfigMapKeyRef'] = None,
                 secret_key_ref: Optional['outputs.KafkaConnectS2ISpecExternalConfigurationEnvValueFromSecretKeyRef'] = None):
        """
        Value of the environment variable which will be passed to the Kafka Connect pods. It can be passed either as a reference to Secret or ConfigMap field. The field has to specify exactly one Secret or ConfigMap.
        :param 'KafkaConnectS2ISpecExternalConfigurationEnvValueFromConfigMapKeyRefArgs' config_map_key_ref: Refernce to a key in a ConfigMap.
        :param 'KafkaConnectS2ISpecExternalConfigurationEnvValueFromSecretKeyRefArgs' secret_key_ref: Reference to a key in a Secret.
        """
        if config_map_key_ref is not None:
            pulumi.set(__self__, "config_map_key_ref", config_map_key_ref)
        if secret_key_ref is not None:
            pulumi.set(__self__, "secret_key_ref", secret_key_ref)

    @property
    @pulumi.getter(name="configMapKeyRef")
    def config_map_key_ref(self) -> Optional['outputs.KafkaConnectS2ISpecExternalConfigurationEnvValueFromConfigMapKeyRef']:
        """
        Refernce to a key in a ConfigMap.
        """
        return pulumi.get(self, "config_map_key_ref")

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> Optional['outputs.KafkaConnectS2ISpecExternalConfigurationEnvValueFromSecretKeyRef']:
        """
        Reference to a key in a Secret.
        """
        return pulumi.get(self, "secret_key_ref")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecExternalConfigurationEnvValueFromConfigMapKeyRef(dict):
    """
    Refernce to a key in a ConfigMap.
    """
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        Refernce to a key in a ConfigMap.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        return pulumi.get(self, "optional")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecExternalConfigurationEnvValueFromSecretKeyRef(dict):
    """
    Reference to a key in a Secret.
    """
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        Reference to a key in a Secret.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        return pulumi.get(self, "optional")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecExternalConfigurationVolumes(dict):
    def __init__(__self__, *,
                 name: str,
                 config_map: Optional['outputs.KafkaConnectS2ISpecExternalConfigurationVolumesConfigMap'] = None,
                 secret: Optional['outputs.KafkaConnectS2ISpecExternalConfigurationVolumesSecret'] = None):
        """
        :param str name: Name of the volume which will be added to the Kafka Connect pods.
        :param 'KafkaConnectS2ISpecExternalConfigurationVolumesConfigMapArgs' config_map: Reference to a key in a ConfigMap. Exactly one Secret or ConfigMap has to be specified.
        :param 'KafkaConnectS2ISpecExternalConfigurationVolumesSecretArgs' secret: Reference to a key in a Secret. Exactly one Secret or ConfigMap has to be specified.
        """
        pulumi.set(__self__, "name", name)
        if config_map is not None:
            pulumi.set(__self__, "config_map", config_map)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the volume which will be added to the Kafka Connect pods.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="configMap")
    def config_map(self) -> Optional['outputs.KafkaConnectS2ISpecExternalConfigurationVolumesConfigMap']:
        """
        Reference to a key in a ConfigMap. Exactly one Secret or ConfigMap has to be specified.
        """
        return pulumi.get(self, "config_map")

    @property
    @pulumi.getter
    def secret(self) -> Optional['outputs.KafkaConnectS2ISpecExternalConfigurationVolumesSecret']:
        """
        Reference to a key in a Secret. Exactly one Secret or ConfigMap has to be specified.
        """
        return pulumi.get(self, "secret")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecExternalConfigurationVolumesConfigMap(dict):
    """
    Reference to a key in a ConfigMap. Exactly one Secret or ConfigMap has to be specified.
    """
    def __init__(__self__, *,
                 default_mode: Optional[int] = None,
                 items: Optional[Sequence['outputs.KafkaConnectS2ISpecExternalConfigurationVolumesConfigMapItems']] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        Reference to a key in a ConfigMap. Exactly one Secret or ConfigMap has to be specified.
        """
        if default_mode is not None:
            pulumi.set(__self__, "default_mode", default_mode)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter(name="defaultMode")
    def default_mode(self) -> Optional[int]:
        return pulumi.get(self, "default_mode")

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.KafkaConnectS2ISpecExternalConfigurationVolumesConfigMapItems']]:
        return pulumi.get(self, "items")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        return pulumi.get(self, "optional")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecExternalConfigurationVolumesConfigMapItems(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 mode: Optional[int] = None,
                 path: Optional[str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def mode(self) -> Optional[int]:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecExternalConfigurationVolumesSecret(dict):
    """
    Reference to a key in a Secret. Exactly one Secret or ConfigMap has to be specified.
    """
    def __init__(__self__, *,
                 default_mode: Optional[int] = None,
                 items: Optional[Sequence['outputs.KafkaConnectS2ISpecExternalConfigurationVolumesSecretItems']] = None,
                 optional: Optional[bool] = None,
                 secret_name: Optional[str] = None):
        """
        Reference to a key in a Secret. Exactly one Secret or ConfigMap has to be specified.
        """
        if default_mode is not None:
            pulumi.set(__self__, "default_mode", default_mode)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="defaultMode")
    def default_mode(self) -> Optional[int]:
        return pulumi.get(self, "default_mode")

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.KafkaConnectS2ISpecExternalConfigurationVolumesSecretItems']]:
        return pulumi.get(self, "items")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        return pulumi.get(self, "optional")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[str]:
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecExternalConfigurationVolumesSecretItems(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 mode: Optional[int] = None,
                 path: Optional[str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def mode(self) -> Optional[int]:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecJvmOptions(dict):
    """
    JVM Options for pods.
    """
    def __init__(__self__, *,
                 __xx: Optional[Mapping[str, Any]] = None,
                 __xms: Optional[str] = None,
                 __xmx: Optional[str] = None,
                 gc_logging_enabled: Optional[bool] = None,
                 java_system_properties: Optional[Sequence['outputs.KafkaConnectS2ISpecJvmOptionsJavaSystemProperties']] = None):
        """
        JVM Options for pods.
        :param Mapping[str, Any] __xx: A map of -XX options to the JVM.
        :param str __xms: -Xms option to to the JVM.
        :param str __xmx: -Xmx option to to the JVM.
        :param bool gc_logging_enabled: Specifies whether the Garbage Collection logging is enabled. The default is false.
        :param Sequence['KafkaConnectS2ISpecJvmOptionsJavaSystemPropertiesArgs'] java_system_properties: A map of additional system properties which will be passed using the `-D` option to the JVM.
        """
        if __xx is not None:
            pulumi.set(__self__, "__xx", __xx)
        if __xms is not None:
            pulumi.set(__self__, "__xms", __xms)
        if __xmx is not None:
            pulumi.set(__self__, "__xmx", __xmx)
        if gc_logging_enabled is not None:
            pulumi.set(__self__, "gc_logging_enabled", gc_logging_enabled)
        if java_system_properties is not None:
            pulumi.set(__self__, "java_system_properties", java_system_properties)

    @property
    @pulumi.getter(name="-XX")
    def __xx(self) -> Optional[Mapping[str, Any]]:
        """
        A map of -XX options to the JVM.
        """
        return pulumi.get(self, "__xx")

    @property
    @pulumi.getter(name="-Xms")
    def __xms(self) -> Optional[str]:
        """
        -Xms option to to the JVM.
        """
        return pulumi.get(self, "__xms")

    @property
    @pulumi.getter(name="-Xmx")
    def __xmx(self) -> Optional[str]:
        """
        -Xmx option to to the JVM.
        """
        return pulumi.get(self, "__xmx")

    @property
    @pulumi.getter(name="gcLoggingEnabled")
    def gc_logging_enabled(self) -> Optional[bool]:
        """
        Specifies whether the Garbage Collection logging is enabled. The default is false.
        """
        return pulumi.get(self, "gc_logging_enabled")

    @property
    @pulumi.getter(name="javaSystemProperties")
    def java_system_properties(self) -> Optional[Sequence['outputs.KafkaConnectS2ISpecJvmOptionsJavaSystemProperties']]:
        """
        A map of additional system properties which will be passed using the `-D` option to the JVM.
        """
        return pulumi.get(self, "java_system_properties")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecJvmOptionsJavaSystemProperties(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The system property name.
        :param str value: The system property value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The system property name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The system property value.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecLivenessProbe(dict):
    """
    Pod liveness checking.
    """
    def __init__(__self__, *,
                 failure_threshold: Optional[int] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 timeout_seconds: Optional[int] = None):
        """
        Pod liveness checking.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param int initial_delay_seconds: The initial delay before first the health is first checked.
        :param int period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param int timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecLogging(dict):
    """
    Logging configuration for Kafka Connect.
    """
    def __init__(__self__, *,
                 type: str,
                 loggers: Optional[Mapping[str, Any]] = None,
                 name: Optional[str] = None):
        """
        Logging configuration for Kafka Connect.
        :param str type: Logging type, must be either 'inline' or 'external'.
        :param Mapping[str, Any] loggers: A Map from logger name to logger level.
        :param str name: The name of the `ConfigMap` from which to get the logging configuration.
        """
        pulumi.set(__self__, "type", type)
        if loggers is not None:
            pulumi.set(__self__, "loggers", loggers)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Logging type, must be either 'inline' or 'external'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def loggers(self) -> Optional[Mapping[str, Any]]:
        """
        A Map from logger name to logger level.
        """
        return pulumi.get(self, "loggers")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the `ConfigMap` from which to get the logging configuration.
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecRack(dict):
    """
    Configuration of the node label which will be used as the client.rack consumer configuration.
    """
    def __init__(__self__, *,
                 topology_key: str):
        """
        Configuration of the node label which will be used as the client.rack consumer configuration.
        :param str topology_key: A key that matches labels assigned to the Kubernetes cluster nodes. The value of the label is used to set the broker's `broker.rack` config.
        """
        pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> str:
        """
        A key that matches labels assigned to the Kubernetes cluster nodes. The value of the label is used to set the broker's `broker.rack` config.
        """
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecReadinessProbe(dict):
    """
    Pod readiness checking.
    """
    def __init__(__self__, *,
                 failure_threshold: Optional[int] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 timeout_seconds: Optional[int] = None):
        """
        Pod readiness checking.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param int initial_delay_seconds: The initial delay before first the health is first checked.
        :param int period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param int timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecResources(dict):
    """
    The maximum limits for CPU and memory resources and the requested initial resources.
    """
    def __init__(__self__, *,
                 limits: Optional[Mapping[str, Any]] = None,
                 requests: Optional[Mapping[str, Any]] = None):
        """
        The maximum limits for CPU and memory resources and the requested initial resources.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "requests")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplate(dict):
    """
    Template for Kafka Connect and Kafka Connect S2I resources. The template allows users to specify how the `Deployment`, `Pods` and `Service` are generated.
    """
    def __init__(__self__, *,
                 api_service: Optional['outputs.KafkaConnectS2ISpecTemplateApiService'] = None,
                 connect_container: Optional['outputs.KafkaConnectS2ISpecTemplateConnectContainer'] = None,
                 deployment: Optional['outputs.KafkaConnectS2ISpecTemplateDeployment'] = None,
                 init_container: Optional['outputs.KafkaConnectS2ISpecTemplateInitContainer'] = None,
                 pod: Optional['outputs.KafkaConnectS2ISpecTemplatePod'] = None,
                 pod_disruption_budget: Optional['outputs.KafkaConnectS2ISpecTemplatePodDisruptionBudget'] = None):
        """
        Template for Kafka Connect and Kafka Connect S2I resources. The template allows users to specify how the `Deployment`, `Pods` and `Service` are generated.
        :param 'KafkaConnectS2ISpecTemplateApiServiceArgs' api_service: Template for Kafka Connect API `Service`.
        :param 'KafkaConnectS2ISpecTemplateConnectContainerArgs' connect_container: Template for the Kafka Connect container.
        :param 'KafkaConnectS2ISpecTemplateDeploymentArgs' deployment: Template for Kafka Connect `Deployment`.
        :param 'KafkaConnectS2ISpecTemplateInitContainerArgs' init_container: Template for the Kafka init container.
        :param 'KafkaConnectS2ISpecTemplatePodArgs' pod: Template for Kafka Connect `Pods`.
        :param 'KafkaConnectS2ISpecTemplatePodDisruptionBudgetArgs' pod_disruption_budget: Template for Kafka Connect `PodDisruptionBudget`.
        """
        if api_service is not None:
            pulumi.set(__self__, "api_service", api_service)
        if connect_container is not None:
            pulumi.set(__self__, "connect_container", connect_container)
        if deployment is not None:
            pulumi.set(__self__, "deployment", deployment)
        if init_container is not None:
            pulumi.set(__self__, "init_container", init_container)
        if pod is not None:
            pulumi.set(__self__, "pod", pod)
        if pod_disruption_budget is not None:
            pulumi.set(__self__, "pod_disruption_budget", pod_disruption_budget)

    @property
    @pulumi.getter(name="apiService")
    def api_service(self) -> Optional['outputs.KafkaConnectS2ISpecTemplateApiService']:
        """
        Template for Kafka Connect API `Service`.
        """
        return pulumi.get(self, "api_service")

    @property
    @pulumi.getter(name="connectContainer")
    def connect_container(self) -> Optional['outputs.KafkaConnectS2ISpecTemplateConnectContainer']:
        """
        Template for the Kafka Connect container.
        """
        return pulumi.get(self, "connect_container")

    @property
    @pulumi.getter
    def deployment(self) -> Optional['outputs.KafkaConnectS2ISpecTemplateDeployment']:
        """
        Template for Kafka Connect `Deployment`.
        """
        return pulumi.get(self, "deployment")

    @property
    @pulumi.getter(name="initContainer")
    def init_container(self) -> Optional['outputs.KafkaConnectS2ISpecTemplateInitContainer']:
        """
        Template for the Kafka init container.
        """
        return pulumi.get(self, "init_container")

    @property
    @pulumi.getter
    def pod(self) -> Optional['outputs.KafkaConnectS2ISpecTemplatePod']:
        """
        Template for Kafka Connect `Pods`.
        """
        return pulumi.get(self, "pod")

    @property
    @pulumi.getter(name="podDisruptionBudget")
    def pod_disruption_budget(self) -> Optional['outputs.KafkaConnectS2ISpecTemplatePodDisruptionBudget']:
        """
        Template for Kafka Connect `PodDisruptionBudget`.
        """
        return pulumi.get(self, "pod_disruption_budget")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplateApiService(dict):
    """
    Template for Kafka Connect API `Service`.
    """
    def __init__(__self__, *,
                 metadata: Optional['outputs.KafkaConnectS2ISpecTemplateApiServiceMetadata'] = None):
        """
        Template for Kafka Connect API `Service`.
        :param 'KafkaConnectS2ISpecTemplateApiServiceMetadataArgs' metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaConnectS2ISpecTemplateApiServiceMetadata']:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplateApiServiceMetadata(dict):
    """
    Metadata applied to the resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata applied to the resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplateConnectContainer(dict):
    """
    Template for the Kafka Connect container.
    """
    def __init__(__self__, *,
                 env: Optional[Sequence['outputs.KafkaConnectS2ISpecTemplateConnectContainerEnv']] = None,
                 security_context: Optional['outputs.KafkaConnectS2ISpecTemplateConnectContainerSecurityContext'] = None):
        """
        Template for the Kafka Connect container.
        :param Sequence['KafkaConnectS2ISpecTemplateConnectContainerEnvArgs'] env: Environment variables which should be applied to the container.
        :param 'KafkaConnectS2ISpecTemplateConnectContainerSecurityContextArgs' security_context: Security context for the container.
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)

    @property
    @pulumi.getter
    def env(self) -> Optional[Sequence['outputs.KafkaConnectS2ISpecTemplateConnectContainerEnv']]:
        """
        Environment variables which should be applied to the container.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional['outputs.KafkaConnectS2ISpecTemplateConnectContainerSecurityContext']:
        """
        Security context for the container.
        """
        return pulumi.get(self, "security_context")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplateConnectContainerEnv(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The environment variable key.
        :param str value: The environment variable value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The environment variable key.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The environment variable value.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplateConnectContainerSecurityContext(dict):
    """
    Security context for the container.
    """
    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[bool] = None,
                 capabilities: Optional['outputs.KafkaConnectS2ISpecTemplateConnectContainerSecurityContextCapabilities'] = None,
                 privileged: Optional[bool] = None,
                 proc_mount: Optional[str] = None,
                 read_only_root_filesystem: Optional[bool] = None,
                 run_as_group: Optional[int] = None,
                 run_as_non_root: Optional[bool] = None,
                 run_as_user: Optional[int] = None,
                 se_linux_options: Optional['outputs.KafkaConnectS2ISpecTemplateConnectContainerSecurityContextSeLinuxOptions'] = None,
                 windows_options: Optional['outputs.KafkaConnectS2ISpecTemplateConnectContainerSecurityContextWindowsOptions'] = None):
        """
        Security context for the container.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if proc_mount is not None:
            pulumi.set(__self__, "proc_mount", proc_mount)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[bool]:
        return pulumi.get(self, "allow_privilege_escalation")

    @property
    @pulumi.getter
    def capabilities(self) -> Optional['outputs.KafkaConnectS2ISpecTemplateConnectContainerSecurityContextCapabilities']:
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def privileged(self) -> Optional[bool]:
        return pulumi.get(self, "privileged")

    @property
    @pulumi.getter(name="procMount")
    def proc_mount(self) -> Optional[str]:
        return pulumi.get(self, "proc_mount")

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[bool]:
        return pulumi.get(self, "read_only_root_filesystem")

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[int]:
        return pulumi.get(self, "run_as_group")

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[bool]:
        return pulumi.get(self, "run_as_non_root")

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[int]:
        return pulumi.get(self, "run_as_user")

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional['outputs.KafkaConnectS2ISpecTemplateConnectContainerSecurityContextSeLinuxOptions']:
        return pulumi.get(self, "se_linux_options")

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional['outputs.KafkaConnectS2ISpecTemplateConnectContainerSecurityContextWindowsOptions']:
        return pulumi.get(self, "windows_options")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplateConnectContainerSecurityContextCapabilities(dict):
    def __init__(__self__, *,
                 add: Optional[Sequence[str]] = None,
                 drop: Optional[Sequence[str]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)

    @property
    @pulumi.getter
    def add(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def drop(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "drop")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplateConnectContainerSecurityContextSeLinuxOptions(dict):
    def __init__(__self__, *,
                 level: Optional[str] = None,
                 role: Optional[str] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        return pulumi.get(self, "user")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplateConnectContainerSecurityContextWindowsOptions(dict):
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[str] = None,
                 gmsa_credential_spec_name: Optional[str] = None,
                 run_as_user_name: Optional[str] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec")

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[str]:
        return pulumi.get(self, "run_as_user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplateDeployment(dict):
    """
    Template for Kafka Connect `Deployment`.
    """
    def __init__(__self__, *,
                 metadata: Optional['outputs.KafkaConnectS2ISpecTemplateDeploymentMetadata'] = None):
        """
        Template for Kafka Connect `Deployment`.
        :param 'KafkaConnectS2ISpecTemplateDeploymentMetadataArgs' metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaConnectS2ISpecTemplateDeploymentMetadata']:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplateDeploymentMetadata(dict):
    """
    Metadata applied to the resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata applied to the resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplateInitContainer(dict):
    """
    Template for the Kafka init container.
    """
    def __init__(__self__, *,
                 env: Optional[Sequence['outputs.KafkaConnectS2ISpecTemplateInitContainerEnv']] = None,
                 security_context: Optional['outputs.KafkaConnectS2ISpecTemplateInitContainerSecurityContext'] = None):
        """
        Template for the Kafka init container.
        :param Sequence['KafkaConnectS2ISpecTemplateInitContainerEnvArgs'] env: Environment variables which should be applied to the container.
        :param 'KafkaConnectS2ISpecTemplateInitContainerSecurityContextArgs' security_context: Security context for the container.
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)

    @property
    @pulumi.getter
    def env(self) -> Optional[Sequence['outputs.KafkaConnectS2ISpecTemplateInitContainerEnv']]:
        """
        Environment variables which should be applied to the container.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional['outputs.KafkaConnectS2ISpecTemplateInitContainerSecurityContext']:
        """
        Security context for the container.
        """
        return pulumi.get(self, "security_context")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplateInitContainerEnv(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The environment variable key.
        :param str value: The environment variable value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The environment variable key.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The environment variable value.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplateInitContainerSecurityContext(dict):
    """
    Security context for the container.
    """
    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[bool] = None,
                 capabilities: Optional['outputs.KafkaConnectS2ISpecTemplateInitContainerSecurityContextCapabilities'] = None,
                 privileged: Optional[bool] = None,
                 proc_mount: Optional[str] = None,
                 read_only_root_filesystem: Optional[bool] = None,
                 run_as_group: Optional[int] = None,
                 run_as_non_root: Optional[bool] = None,
                 run_as_user: Optional[int] = None,
                 se_linux_options: Optional['outputs.KafkaConnectS2ISpecTemplateInitContainerSecurityContextSeLinuxOptions'] = None,
                 windows_options: Optional['outputs.KafkaConnectS2ISpecTemplateInitContainerSecurityContextWindowsOptions'] = None):
        """
        Security context for the container.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if proc_mount is not None:
            pulumi.set(__self__, "proc_mount", proc_mount)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[bool]:
        return pulumi.get(self, "allow_privilege_escalation")

    @property
    @pulumi.getter
    def capabilities(self) -> Optional['outputs.KafkaConnectS2ISpecTemplateInitContainerSecurityContextCapabilities']:
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def privileged(self) -> Optional[bool]:
        return pulumi.get(self, "privileged")

    @property
    @pulumi.getter(name="procMount")
    def proc_mount(self) -> Optional[str]:
        return pulumi.get(self, "proc_mount")

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[bool]:
        return pulumi.get(self, "read_only_root_filesystem")

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[int]:
        return pulumi.get(self, "run_as_group")

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[bool]:
        return pulumi.get(self, "run_as_non_root")

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[int]:
        return pulumi.get(self, "run_as_user")

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional['outputs.KafkaConnectS2ISpecTemplateInitContainerSecurityContextSeLinuxOptions']:
        return pulumi.get(self, "se_linux_options")

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional['outputs.KafkaConnectS2ISpecTemplateInitContainerSecurityContextWindowsOptions']:
        return pulumi.get(self, "windows_options")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplateInitContainerSecurityContextCapabilities(dict):
    def __init__(__self__, *,
                 add: Optional[Sequence[str]] = None,
                 drop: Optional[Sequence[str]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)

    @property
    @pulumi.getter
    def add(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def drop(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "drop")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplateInitContainerSecurityContextSeLinuxOptions(dict):
    def __init__(__self__, *,
                 level: Optional[str] = None,
                 role: Optional[str] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        return pulumi.get(self, "user")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplateInitContainerSecurityContextWindowsOptions(dict):
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[str] = None,
                 gmsa_credential_spec_name: Optional[str] = None,
                 run_as_user_name: Optional[str] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec")

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[str]:
        return pulumi.get(self, "run_as_user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplatePod(dict):
    """
    Template for Kafka Connect `Pods`.
    """
    def __init__(__self__, *,
                 affinity: Optional['outputs.KafkaConnectS2ISpecTemplatePodAffinity'] = None,
                 host_aliases: Optional[Sequence['outputs.KafkaConnectS2ISpecTemplatePodHostAliases']] = None,
                 image_pull_secrets: Optional[Sequence['outputs.KafkaConnectS2ISpecTemplatePodImagePullSecrets']] = None,
                 metadata: Optional['outputs.KafkaConnectS2ISpecTemplatePodMetadata'] = None,
                 priority_class_name: Optional[str] = None,
                 scheduler_name: Optional[str] = None,
                 security_context: Optional['outputs.KafkaConnectS2ISpecTemplatePodSecurityContext'] = None,
                 termination_grace_period_seconds: Optional[int] = None,
                 tolerations: Optional[Sequence['outputs.KafkaConnectS2ISpecTemplatePodTolerations']] = None):
        """
        Template for Kafka Connect `Pods`.
        :param 'KafkaConnectS2ISpecTemplatePodAffinityArgs' affinity: The pod's affinity rules.
        :param Sequence['KafkaConnectS2ISpecTemplatePodHostAliasesArgs'] host_aliases: The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
        :param Sequence['KafkaConnectS2ISpecTemplatePodImagePullSecretsArgs'] image_pull_secrets: List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
        :param 'KafkaConnectS2ISpecTemplatePodMetadataArgs' metadata: Metadata applied to the resource.
        :param str priority_class_name: The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
        :param str scheduler_name: The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
        :param 'KafkaConnectS2ISpecTemplatePodSecurityContextArgs' security_context: Configures pod-level security attributes and common container settings.
        :param int termination_grace_period_seconds: The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
        :param Sequence['KafkaConnectS2ISpecTemplatePodTolerationsArgs'] tolerations: The pod's tolerations.
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if host_aliases is not None:
            pulumi.set(__self__, "host_aliases", host_aliases)
        if image_pull_secrets is not None:
            pulumi.set(__self__, "image_pull_secrets", image_pull_secrets)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if priority_class_name is not None:
            pulumi.set(__self__, "priority_class_name", priority_class_name)
        if scheduler_name is not None:
            pulumi.set(__self__, "scheduler_name", scheduler_name)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)

    @property
    @pulumi.getter
    def affinity(self) -> Optional['outputs.KafkaConnectS2ISpecTemplatePodAffinity']:
        """
        The pod's affinity rules.
        """
        return pulumi.get(self, "affinity")

    @property
    @pulumi.getter(name="hostAliases")
    def host_aliases(self) -> Optional[Sequence['outputs.KafkaConnectS2ISpecTemplatePodHostAliases']]:
        """
        The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
        """
        return pulumi.get(self, "host_aliases")

    @property
    @pulumi.getter(name="imagePullSecrets")
    def image_pull_secrets(self) -> Optional[Sequence['outputs.KafkaConnectS2ISpecTemplatePodImagePullSecrets']]:
        """
        List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
        """
        return pulumi.get(self, "image_pull_secrets")

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaConnectS2ISpecTemplatePodMetadata']:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter(name="priorityClassName")
    def priority_class_name(self) -> Optional[str]:
        """
        The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
        """
        return pulumi.get(self, "priority_class_name")

    @property
    @pulumi.getter(name="schedulerName")
    def scheduler_name(self) -> Optional[str]:
        """
        The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
        """
        return pulumi.get(self, "scheduler_name")

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional['outputs.KafkaConnectS2ISpecTemplatePodSecurityContext']:
        """
        Configures pod-level security attributes and common container settings.
        """
        return pulumi.get(self, "security_context")

    @property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[int]:
        """
        The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
        """
        return pulumi.get(self, "termination_grace_period_seconds")

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[Sequence['outputs.KafkaConnectS2ISpecTemplatePodTolerations']]:
        """
        The pod's tolerations.
        """
        return pulumi.get(self, "tolerations")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplatePodAffinity(dict):
    """
    The pod's affinity rules.
    """
    def __init__(__self__, *,
                 node_affinity: Optional['outputs.KafkaConnectS2ISpecTemplatePodAffinityNodeAffinity'] = None,
                 pod_affinity: Optional['outputs.KafkaConnectS2ISpecTemplatePodAffinityPodAffinity'] = None,
                 pod_anti_affinity: Optional['outputs.KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinity'] = None):
        """
        The pod's affinity rules.
        """
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional['outputs.KafkaConnectS2ISpecTemplatePodAffinityNodeAffinity']:
        return pulumi.get(self, "node_affinity")

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional['outputs.KafkaConnectS2ISpecTemplatePodAffinityPodAffinity']:
        return pulumi.get(self, "pod_affinity")

    @property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional['outputs.KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinity']:
        return pulumi.get(self, "pod_anti_affinity")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplatePodAffinityNodeAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional['outputs.KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution'] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional['outputs.KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution']:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 preference: Optional['outputs.KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference'] = None,
                 weight: Optional[int] = None):
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preference(self) -> Optional['outputs.KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference']:
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions']] = None,
                 match_fields: Optional[Sequence['outputs.KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields']] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields']]:
        return pulumi.get(self, "match_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 node_selector_terms: Optional[Sequence['outputs.KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms']] = None):
        if node_selector_terms is not None:
            pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> Optional[Sequence['outputs.KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms']]:
        return pulumi.get(self, "node_selector_terms")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions']] = None,
                 match_fields: Optional[Sequence['outputs.KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields']] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields']]:
        return pulumi.get(self, "match_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplatePodAffinityPodAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 pod_affinity_term: Optional['outputs.KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm'] = None,
                 weight: Optional[int] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional['outputs.KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm']:
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 pod_affinity_term: Optional['outputs.KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm'] = None,
                 weight: Optional[int] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional['outputs.KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm']:
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplatePodDisruptionBudget(dict):
    """
    Template for Kafka Connect `PodDisruptionBudget`.
    """
    def __init__(__self__, *,
                 max_unavailable: Optional[int] = None,
                 metadata: Optional['outputs.KafkaConnectS2ISpecTemplatePodDisruptionBudgetMetadata'] = None):
        """
        Template for Kafka Connect `PodDisruptionBudget`.
        :param int max_unavailable: Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
        :param 'KafkaConnectS2ISpecTemplatePodDisruptionBudgetMetadataArgs' metadata: Metadata to apply to the `PodDistruptionBugetTemplate` resource.
        """
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[int]:
        """
        Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
        """
        return pulumi.get(self, "max_unavailable")

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaConnectS2ISpecTemplatePodDisruptionBudgetMetadata']:
        """
        Metadata to apply to the `PodDistruptionBugetTemplate` resource.
        """
        return pulumi.get(self, "metadata")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplatePodDisruptionBudgetMetadata(dict):
    """
    Metadata to apply to the `PodDistruptionBugetTemplate` resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata to apply to the `PodDistruptionBugetTemplate` resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplatePodHostAliases(dict):
    def __init__(__self__, *,
                 hostnames: Optional[Sequence[str]] = None,
                 ip: Optional[str] = None):
        if hostnames is not None:
            pulumi.set(__self__, "hostnames", hostnames)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def hostnames(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "hostnames")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        return pulumi.get(self, "ip")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplatePodImagePullSecrets(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplatePodMetadata(dict):
    """
    Metadata applied to the resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata applied to the resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplatePodSecurityContext(dict):
    """
    Configures pod-level security attributes and common container settings.
    """
    def __init__(__self__, *,
                 fs_group: Optional[int] = None,
                 fs_group_change_policy: Optional[str] = None,
                 run_as_group: Optional[int] = None,
                 run_as_non_root: Optional[bool] = None,
                 run_as_user: Optional[int] = None,
                 se_linux_options: Optional['outputs.KafkaConnectS2ISpecTemplatePodSecurityContextSeLinuxOptions'] = None,
                 supplemental_groups: Optional[Sequence[int]] = None,
                 sysctls: Optional[Sequence['outputs.KafkaConnectS2ISpecTemplatePodSecurityContextSysctls']] = None,
                 windows_options: Optional['outputs.KafkaConnectS2ISpecTemplatePodSecurityContextWindowsOptions'] = None):
        """
        Configures pod-level security attributes and common container settings.
        """
        if fs_group is not None:
            pulumi.set(__self__, "fs_group", fs_group)
        if fs_group_change_policy is not None:
            pulumi.set(__self__, "fs_group_change_policy", fs_group_change_policy)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if supplemental_groups is not None:
            pulumi.set(__self__, "supplemental_groups", supplemental_groups)
        if sysctls is not None:
            pulumi.set(__self__, "sysctls", sysctls)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="fsGroup")
    def fs_group(self) -> Optional[int]:
        return pulumi.get(self, "fs_group")

    @property
    @pulumi.getter(name="fsGroupChangePolicy")
    def fs_group_change_policy(self) -> Optional[str]:
        return pulumi.get(self, "fs_group_change_policy")

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[int]:
        return pulumi.get(self, "run_as_group")

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[bool]:
        return pulumi.get(self, "run_as_non_root")

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[int]:
        return pulumi.get(self, "run_as_user")

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional['outputs.KafkaConnectS2ISpecTemplatePodSecurityContextSeLinuxOptions']:
        return pulumi.get(self, "se_linux_options")

    @property
    @pulumi.getter(name="supplementalGroups")
    def supplemental_groups(self) -> Optional[Sequence[int]]:
        return pulumi.get(self, "supplemental_groups")

    @property
    @pulumi.getter
    def sysctls(self) -> Optional[Sequence['outputs.KafkaConnectS2ISpecTemplatePodSecurityContextSysctls']]:
        return pulumi.get(self, "sysctls")

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional['outputs.KafkaConnectS2ISpecTemplatePodSecurityContextWindowsOptions']:
        return pulumi.get(self, "windows_options")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplatePodSecurityContextSeLinuxOptions(dict):
    def __init__(__self__, *,
                 level: Optional[str] = None,
                 role: Optional[str] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        return pulumi.get(self, "user")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplatePodSecurityContextSysctls(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplatePodSecurityContextWindowsOptions(dict):
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[str] = None,
                 gmsa_credential_spec_name: Optional[str] = None,
                 run_as_user_name: Optional[str] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec")

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[str]:
        return pulumi.get(self, "run_as_user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTemplatePodTolerations(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 toleration_seconds: Optional[int] = None,
                 value: Optional[str] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if toleration_seconds is not None:
            pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> Optional[int]:
        return pulumi.get(self, "toleration_seconds")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTls(dict):
    """
    TLS configuration.
    """
    def __init__(__self__, *,
                 trusted_certificates: Optional[Sequence['outputs.KafkaConnectS2ISpecTlsTrustedCertificates']] = None):
        """
        TLS configuration.
        :param Sequence['KafkaConnectS2ISpecTlsTrustedCertificatesArgs'] trusted_certificates: Trusted certificates for TLS connection.
        """
        if trusted_certificates is not None:
            pulumi.set(__self__, "trusted_certificates", trusted_certificates)

    @property
    @pulumi.getter(name="trustedCertificates")
    def trusted_certificates(self) -> Optional[Sequence['outputs.KafkaConnectS2ISpecTlsTrustedCertificates']]:
        """
        Trusted certificates for TLS connection.
        """
        return pulumi.get(self, "trusted_certificates")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTlsTrustedCertificates(dict):
    def __init__(__self__, *,
                 certificate: str,
                 secret_name: str):
        """
        :param str certificate: The name of the file certificate in the Secret.
        :param str secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> str:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTolerations(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 toleration_seconds: Optional[int] = None,
                 value: Optional[str] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if toleration_seconds is not None:
            pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> Optional[int]:
        return pulumi.get(self, "toleration_seconds")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2ISpecTracing(dict):
    """
    The configuration of tracing in Kafka Connect.
    """
    def __init__(__self__, *,
                 type: str):
        """
        The configuration of tracing in Kafka Connect.
        :param str type: Type of the tracing used. Currently the only supported type is `jaeger` for Jaeger tracing.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the tracing used. Currently the only supported type is `jaeger` for Jaeger tracing.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2IStatus(dict):
    """
    The status of the Kafka Connect Source-to-Image (S2I) cluster.
    """
    def __init__(__self__, *,
                 build_config_name: Optional[str] = None,
                 conditions: Optional[Sequence['outputs.KafkaConnectS2IStatusConditions']] = None,
                 connector_plugins: Optional[Sequence['outputs.KafkaConnectS2IStatusConnectorPlugins']] = None,
                 label_selector: Optional[str] = None,
                 observed_generation: Optional[int] = None,
                 replicas: Optional[int] = None,
                 url: Optional[str] = None):
        """
        The status of the Kafka Connect Source-to-Image (S2I) cluster.
        :param str build_config_name: The name of the build configuration.
        :param Sequence['KafkaConnectS2IStatusConditionsArgs'] conditions: List of status conditions.
        :param Sequence['KafkaConnectS2IStatusConnectorPluginsArgs'] connector_plugins: The list of connector plugins available in this Kafka Connect deployment.
        :param str label_selector: Label selector for pods providing this resource.
        :param int observed_generation: The generation of the CRD that was last reconciled by the operator.
        :param int replicas: The current number of pods being used to provide this resource.
        :param str url: The URL of the REST API endpoint for managing and monitoring Kafka Connect connectors.
        """
        if build_config_name is not None:
            pulumi.set(__self__, "build_config_name", build_config_name)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if connector_plugins is not None:
            pulumi.set(__self__, "connector_plugins", connector_plugins)
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="buildConfigName")
    def build_config_name(self) -> Optional[str]:
        """
        The name of the build configuration.
        """
        return pulumi.get(self, "build_config_name")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.KafkaConnectS2IStatusConditions']]:
        """
        List of status conditions.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="connectorPlugins")
    def connector_plugins(self) -> Optional[Sequence['outputs.KafkaConnectS2IStatusConnectorPlugins']]:
        """
        The list of connector plugins available in this Kafka Connect deployment.
        """
        return pulumi.get(self, "connector_plugins")

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[str]:
        """
        Label selector for pods providing this resource.
        """
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[int]:
        """
        The generation of the CRD that was last reconciled by the operator.
        """
        return pulumi.get(self, "observed_generation")

    @property
    @pulumi.getter
    def replicas(self) -> Optional[int]:
        """
        The current number of pods being used to provide this resource.
        """
        return pulumi.get(self, "replicas")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The URL of the REST API endpoint for managing and monitoring Kafka Connect connectors.
        """
        return pulumi.get(self, "url")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2IStatusConditions(dict):
    def __init__(__self__, *,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None,
                 status: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str last_transition_time: Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
        :param str message: Human-readable message indicating details about the condition's last transition.
        :param str reason: The reason for the condition's last transition (a single word in CamelCase).
        :param str status: The status of the condition, either True, False or Unknown.
        :param str type: The unique identifier of a condition, used to distinguish between other conditions in the resource.
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Human-readable message indicating details about the condition's last transition.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        The reason for the condition's last transition (a single word in CamelCase).
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The status of the condition, either True, False or Unknown.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The unique identifier of a condition, used to distinguish between other conditions in the resource.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectS2IStatusConnectorPlugins(dict):
    def __init__(__self__, *,
                 class_: Optional[str] = None,
                 type: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str class_: The class of the connector plugin.
        :param str type: The type of the connector plugin. The available types are `sink` and `source`.
        :param str version: The version of the connector plugin.
        """
        if class_ is not None:
            pulumi.set(__self__, "class_", class_)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="class")
    def class_(self) -> Optional[str]:
        """
        The class of the connector plugin.
        """
        return pulumi.get(self, "class_")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of the connector plugin. The available types are `sink` and `source`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        The version of the connector plugin.
        """
        return pulumi.get(self, "version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpec(dict):
    """
    The specification of the Kafka Connect cluster.
    """
    def __init__(__self__, *,
                 bootstrap_servers: str,
                 affinity: Optional['outputs.KafkaConnectSpecAffinity'] = None,
                 authentication: Optional['outputs.KafkaConnectSpecAuthentication'] = None,
                 client_rack_init_image: Optional[str] = None,
                 config: Optional[Mapping[str, Any]] = None,
                 external_configuration: Optional['outputs.KafkaConnectSpecExternalConfiguration'] = None,
                 image: Optional[str] = None,
                 jvm_options: Optional['outputs.KafkaConnectSpecJvmOptions'] = None,
                 liveness_probe: Optional['outputs.KafkaConnectSpecLivenessProbe'] = None,
                 logging: Optional['outputs.KafkaConnectSpecLogging'] = None,
                 metrics: Optional[Mapping[str, Any]] = None,
                 rack: Optional['outputs.KafkaConnectSpecRack'] = None,
                 readiness_probe: Optional['outputs.KafkaConnectSpecReadinessProbe'] = None,
                 replicas: Optional[int] = None,
                 resources: Optional['outputs.KafkaConnectSpecResources'] = None,
                 template: Optional['outputs.KafkaConnectSpecTemplate'] = None,
                 tls: Optional['outputs.KafkaConnectSpecTls'] = None,
                 tolerations: Optional[Sequence['outputs.KafkaConnectSpecTolerations']] = None,
                 tracing: Optional['outputs.KafkaConnectSpecTracing'] = None,
                 version: Optional[str] = None):
        """
        The specification of the Kafka Connect cluster.
        :param str bootstrap_servers: Bootstrap servers to connect to. This should be given as a comma separated list of _<hostname>_:‍_<port>_ pairs.
        :param 'KafkaConnectSpecAffinityArgs' affinity: The pod's affinity rules.
        :param 'KafkaConnectSpecAuthenticationArgs' authentication: Authentication configuration for Kafka Connect.
        :param str client_rack_init_image: The image of the init container used for initializing the `client.rack`.
        :param Mapping[str, Any] config: The Kafka Connect configuration. Properties with the following prefixes cannot be set: ssl., sasl., security., listeners, plugin.path, rest., bootstrap.servers, consumer.interceptor.classes, producer.interceptor.classes (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
        :param 'KafkaConnectSpecExternalConfigurationArgs' external_configuration: Pass data from Secrets or ConfigMaps to the Kafka Connect pods and use them to configure connectors.
        :param str image: The docker image for the pods.
        :param 'KafkaConnectSpecJvmOptionsArgs' jvm_options: JVM Options for pods.
        :param 'KafkaConnectSpecLivenessProbeArgs' liveness_probe: Pod liveness checking.
        :param 'KafkaConnectSpecLoggingArgs' logging: Logging configuration for Kafka Connect.
        :param Mapping[str, Any] metrics: The Prometheus JMX Exporter configuration. See https://github.com/prometheus/jmx_exporter for details of the structure of this configuration.
        :param 'KafkaConnectSpecRackArgs' rack: Configuration of the node label which will be used as the client.rack consumer configuration.
        :param 'KafkaConnectSpecReadinessProbeArgs' readiness_probe: Pod readiness checking.
        :param int replicas: The number of pods in the Kafka Connect group.
        :param 'KafkaConnectSpecResourcesArgs' resources: The maximum limits for CPU and memory resources and the requested initial resources.
        :param 'KafkaConnectSpecTemplateArgs' template: Template for Kafka Connect and Kafka Connect S2I resources. The template allows users to specify how the `Deployment`, `Pods` and `Service` are generated.
        :param 'KafkaConnectSpecTlsArgs' tls: TLS configuration.
        :param Sequence['KafkaConnectSpecTolerationsArgs'] tolerations: The pod's tolerations.
        :param 'KafkaConnectSpecTracingArgs' tracing: The configuration of tracing in Kafka Connect.
        :param str version: The Kafka Connect version. Defaults to {DefaultKafkaVersion}. Consult the user documentation to understand the process required to upgrade or downgrade the version.
        """
        pulumi.set(__self__, "bootstrap_servers", bootstrap_servers)
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if client_rack_init_image is not None:
            pulumi.set(__self__, "client_rack_init_image", client_rack_init_image)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if external_configuration is not None:
            pulumi.set(__self__, "external_configuration", external_configuration)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if jvm_options is not None:
            pulumi.set(__self__, "jvm_options", jvm_options)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if rack is not None:
            pulumi.set(__self__, "rack", rack)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if template is not None:
            pulumi.set(__self__, "template", template)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)
        if tracing is not None:
            pulumi.set(__self__, "tracing", tracing)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="bootstrapServers")
    def bootstrap_servers(self) -> str:
        """
        Bootstrap servers to connect to. This should be given as a comma separated list of _<hostname>_:‍_<port>_ pairs.
        """
        return pulumi.get(self, "bootstrap_servers")

    @property
    @pulumi.getter
    def affinity(self) -> Optional['outputs.KafkaConnectSpecAffinity']:
        """
        The pod's affinity rules.
        """
        return pulumi.get(self, "affinity")

    @property
    @pulumi.getter
    def authentication(self) -> Optional['outputs.KafkaConnectSpecAuthentication']:
        """
        Authentication configuration for Kafka Connect.
        """
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter(name="clientRackInitImage")
    def client_rack_init_image(self) -> Optional[str]:
        """
        The image of the init container used for initializing the `client.rack`.
        """
        return pulumi.get(self, "client_rack_init_image")

    @property
    @pulumi.getter
    def config(self) -> Optional[Mapping[str, Any]]:
        """
        The Kafka Connect configuration. Properties with the following prefixes cannot be set: ssl., sasl., security., listeners, plugin.path, rest., bootstrap.servers, consumer.interceptor.classes, producer.interceptor.classes (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter(name="externalConfiguration")
    def external_configuration(self) -> Optional['outputs.KafkaConnectSpecExternalConfiguration']:
        """
        Pass data from Secrets or ConfigMaps to the Kafka Connect pods and use them to configure connectors.
        """
        return pulumi.get(self, "external_configuration")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        The docker image for the pods.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="jvmOptions")
    def jvm_options(self) -> Optional['outputs.KafkaConnectSpecJvmOptions']:
        """
        JVM Options for pods.
        """
        return pulumi.get(self, "jvm_options")

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional['outputs.KafkaConnectSpecLivenessProbe']:
        """
        Pod liveness checking.
        """
        return pulumi.get(self, "liveness_probe")

    @property
    @pulumi.getter
    def logging(self) -> Optional['outputs.KafkaConnectSpecLogging']:
        """
        Logging configuration for Kafka Connect.
        """
        return pulumi.get(self, "logging")

    @property
    @pulumi.getter
    def metrics(self) -> Optional[Mapping[str, Any]]:
        """
        The Prometheus JMX Exporter configuration. See https://github.com/prometheus/jmx_exporter for details of the structure of this configuration.
        """
        return pulumi.get(self, "metrics")

    @property
    @pulumi.getter
    def rack(self) -> Optional['outputs.KafkaConnectSpecRack']:
        """
        Configuration of the node label which will be used as the client.rack consumer configuration.
        """
        return pulumi.get(self, "rack")

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional['outputs.KafkaConnectSpecReadinessProbe']:
        """
        Pod readiness checking.
        """
        return pulumi.get(self, "readiness_probe")

    @property
    @pulumi.getter
    def replicas(self) -> Optional[int]:
        """
        The number of pods in the Kafka Connect group.
        """
        return pulumi.get(self, "replicas")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.KafkaConnectSpecResources']:
        """
        The maximum limits for CPU and memory resources and the requested initial resources.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter
    def template(self) -> Optional['outputs.KafkaConnectSpecTemplate']:
        """
        Template for Kafka Connect and Kafka Connect S2I resources. The template allows users to specify how the `Deployment`, `Pods` and `Service` are generated.
        """
        return pulumi.get(self, "template")

    @property
    @pulumi.getter
    def tls(self) -> Optional['outputs.KafkaConnectSpecTls']:
        """
        TLS configuration.
        """
        return pulumi.get(self, "tls")

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[Sequence['outputs.KafkaConnectSpecTolerations']]:
        """
        The pod's tolerations.
        """
        return pulumi.get(self, "tolerations")

    @property
    @pulumi.getter
    def tracing(self) -> Optional['outputs.KafkaConnectSpecTracing']:
        """
        The configuration of tracing in Kafka Connect.
        """
        return pulumi.get(self, "tracing")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        The Kafka Connect version. Defaults to {DefaultKafkaVersion}. Consult the user documentation to understand the process required to upgrade or downgrade the version.
        """
        return pulumi.get(self, "version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecAffinity(dict):
    """
    The pod's affinity rules.
    """
    def __init__(__self__, *,
                 node_affinity: Optional['outputs.KafkaConnectSpecAffinityNodeAffinity'] = None,
                 pod_affinity: Optional['outputs.KafkaConnectSpecAffinityPodAffinity'] = None,
                 pod_anti_affinity: Optional['outputs.KafkaConnectSpecAffinityPodAntiAffinity'] = None):
        """
        The pod's affinity rules.
        """
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional['outputs.KafkaConnectSpecAffinityNodeAffinity']:
        return pulumi.get(self, "node_affinity")

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional['outputs.KafkaConnectSpecAffinityPodAffinity']:
        return pulumi.get(self, "pod_affinity")

    @property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional['outputs.KafkaConnectSpecAffinityPodAntiAffinity']:
        return pulumi.get(self, "pod_anti_affinity")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecAffinityNodeAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional['outputs.KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution'] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional['outputs.KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution']:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 preference: Optional['outputs.KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference'] = None,
                 weight: Optional[int] = None):
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preference(self) -> Optional['outputs.KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference']:
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions']] = None,
                 match_fields: Optional[Sequence['outputs.KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields']] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields']]:
        return pulumi.get(self, "match_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 node_selector_terms: Optional[Sequence['outputs.KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms']] = None):
        if node_selector_terms is not None:
            pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> Optional[Sequence['outputs.KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms']]:
        return pulumi.get(self, "node_selector_terms")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions']] = None,
                 match_fields: Optional[Sequence['outputs.KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields']] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields']]:
        return pulumi.get(self, "match_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecAffinityPodAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 pod_affinity_term: Optional['outputs.KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm'] = None,
                 weight: Optional[int] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional['outputs.KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm']:
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecAffinityPodAntiAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 pod_affinity_term: Optional['outputs.KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm'] = None,
                 weight: Optional[int] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional['outputs.KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm']:
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecAuthentication(dict):
    """
    Authentication configuration for Kafka Connect.
    """
    def __init__(__self__, *,
                 type: str,
                 access_token: Optional['outputs.KafkaConnectSpecAuthenticationAccessToken'] = None,
                 access_token_is_jwt: Optional[bool] = None,
                 certificate_and_key: Optional['outputs.KafkaConnectSpecAuthenticationCertificateAndKey'] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional['outputs.KafkaConnectSpecAuthenticationClientSecret'] = None,
                 disable_tls_hostname_verification: Optional[bool] = None,
                 max_token_expiry_seconds: Optional[int] = None,
                 password_secret: Optional['outputs.KafkaConnectSpecAuthenticationPasswordSecret'] = None,
                 refresh_token: Optional['outputs.KafkaConnectSpecAuthenticationRefreshToken'] = None,
                 scope: Optional[str] = None,
                 tls_trusted_certificates: Optional[Sequence['outputs.KafkaConnectSpecAuthenticationTlsTrustedCertificates']] = None,
                 token_endpoint_uri: Optional[str] = None,
                 username: Optional[str] = None):
        """
        Authentication configuration for Kafka Connect.
        :param str type: Authentication type. Currently the only supported types are `tls`, `scram-sha-512`, and `plain`. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
        :param 'KafkaConnectSpecAuthenticationAccessTokenArgs' access_token: Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
        :param bool access_token_is_jwt: Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
        :param 'KafkaConnectSpecAuthenticationCertificateAndKeyArgs' certificate_and_key: Reference to the `Secret` which holds the certificate and private key pair.
        :param str client_id: OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        :param 'KafkaConnectSpecAuthenticationClientSecretArgs' client_secret: Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        :param bool disable_tls_hostname_verification: Enable or disable TLS hostname verification. Default value is `false`.
        :param int max_token_expiry_seconds: Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.
        :param 'KafkaConnectSpecAuthenticationPasswordSecretArgs' password_secret: Reference to the `Secret` which holds the password.
        :param 'KafkaConnectSpecAuthenticationRefreshTokenArgs' refresh_token: Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
        :param str scope: OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.
        :param Sequence['KafkaConnectSpecAuthenticationTlsTrustedCertificatesArgs'] tls_trusted_certificates: Trusted certificates for TLS connection to the OAuth server.
        :param str token_endpoint_uri: Authorization server token endpoint URI.
        :param str username: Username used for the authentication.
        """
        pulumi.set(__self__, "type", type)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if access_token_is_jwt is not None:
            pulumi.set(__self__, "access_token_is_jwt", access_token_is_jwt)
        if certificate_and_key is not None:
            pulumi.set(__self__, "certificate_and_key", certificate_and_key)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if disable_tls_hostname_verification is not None:
            pulumi.set(__self__, "disable_tls_hostname_verification", disable_tls_hostname_verification)
        if max_token_expiry_seconds is not None:
            pulumi.set(__self__, "max_token_expiry_seconds", max_token_expiry_seconds)
        if password_secret is not None:
            pulumi.set(__self__, "password_secret", password_secret)
        if refresh_token is not None:
            pulumi.set(__self__, "refresh_token", refresh_token)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if tls_trusted_certificates is not None:
            pulumi.set(__self__, "tls_trusted_certificates", tls_trusted_certificates)
        if token_endpoint_uri is not None:
            pulumi.set(__self__, "token_endpoint_uri", token_endpoint_uri)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Authentication type. Currently the only supported types are `tls`, `scram-sha-512`, and `plain`. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional['outputs.KafkaConnectSpecAuthenticationAccessToken']:
        """
        Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="accessTokenIsJwt")
    def access_token_is_jwt(self) -> Optional[bool]:
        """
        Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
        """
        return pulumi.get(self, "access_token_is_jwt")

    @property
    @pulumi.getter(name="certificateAndKey")
    def certificate_and_key(self) -> Optional['outputs.KafkaConnectSpecAuthenticationCertificateAndKey']:
        """
        Reference to the `Secret` which holds the certificate and private key pair.
        """
        return pulumi.get(self, "certificate_and_key")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional['outputs.KafkaConnectSpecAuthenticationClientSecret']:
        """
        Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="disableTlsHostnameVerification")
    def disable_tls_hostname_verification(self) -> Optional[bool]:
        """
        Enable or disable TLS hostname verification. Default value is `false`.
        """
        return pulumi.get(self, "disable_tls_hostname_verification")

    @property
    @pulumi.getter(name="maxTokenExpirySeconds")
    def max_token_expiry_seconds(self) -> Optional[int]:
        """
        Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.
        """
        return pulumi.get(self, "max_token_expiry_seconds")

    @property
    @pulumi.getter(name="passwordSecret")
    def password_secret(self) -> Optional['outputs.KafkaConnectSpecAuthenticationPasswordSecret']:
        """
        Reference to the `Secret` which holds the password.
        """
        return pulumi.get(self, "password_secret")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional['outputs.KafkaConnectSpecAuthenticationRefreshToken']:
        """
        Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
        """
        return pulumi.get(self, "refresh_token")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter(name="tlsTrustedCertificates")
    def tls_trusted_certificates(self) -> Optional[Sequence['outputs.KafkaConnectSpecAuthenticationTlsTrustedCertificates']]:
        """
        Trusted certificates for TLS connection to the OAuth server.
        """
        return pulumi.get(self, "tls_trusted_certificates")

    @property
    @pulumi.getter(name="tokenEndpointUri")
    def token_endpoint_uri(self) -> Optional[str]:
        """
        Authorization server token endpoint URI.
        """
        return pulumi.get(self, "token_endpoint_uri")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username used for the authentication.
        """
        return pulumi.get(self, "username")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecAuthenticationAccessToken(dict):
    """
    Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
    """
    def __init__(__self__, *,
                 key: str,
                 secret_name: str):
        """
        Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
        :param str key: The key under which the secret value is stored in the Kubernetes Secret.
        :param str secret_name: The name of the Kubernetes Secret containing the secret value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key under which the secret value is stored in the Kubernetes Secret.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Kubernetes Secret containing the secret value.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecAuthenticationCertificateAndKey(dict):
    """
    Reference to the `Secret` which holds the certificate and private key pair.
    """
    def __init__(__self__, *,
                 certificate: str,
                 key: str,
                 secret_name: str):
        """
        Reference to the `Secret` which holds the certificate and private key pair.
        :param str certificate: The name of the file certificate in the Secret.
        :param str key: The name of the private key in the Secret.
        :param str secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> str:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The name of the private key in the Secret.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecAuthenticationClientSecret(dict):
    """
    Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
    """
    def __init__(__self__, *,
                 key: str,
                 secret_name: str):
        """
        Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        :param str key: The key under which the secret value is stored in the Kubernetes Secret.
        :param str secret_name: The name of the Kubernetes Secret containing the secret value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key under which the secret value is stored in the Kubernetes Secret.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Kubernetes Secret containing the secret value.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecAuthenticationPasswordSecret(dict):
    """
    Reference to the `Secret` which holds the password.
    """
    def __init__(__self__, *,
                 password: str,
                 secret_name: str):
        """
        Reference to the `Secret` which holds the password.
        :param str password: The name of the key in the Secret under which the password is stored.
        :param str secret_name: The name of the Secret containing the password.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The name of the key in the Secret under which the password is stored.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Secret containing the password.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecAuthenticationRefreshToken(dict):
    """
    Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
    """
    def __init__(__self__, *,
                 key: str,
                 secret_name: str):
        """
        Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
        :param str key: The key under which the secret value is stored in the Kubernetes Secret.
        :param str secret_name: The name of the Kubernetes Secret containing the secret value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key under which the secret value is stored in the Kubernetes Secret.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Kubernetes Secret containing the secret value.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecAuthenticationTlsTrustedCertificates(dict):
    def __init__(__self__, *,
                 certificate: str,
                 secret_name: str):
        """
        :param str certificate: The name of the file certificate in the Secret.
        :param str secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> str:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecExternalConfiguration(dict):
    """
    Pass data from Secrets or ConfigMaps to the Kafka Connect pods and use them to configure connectors.
    """
    def __init__(__self__, *,
                 env: Optional[Sequence['outputs.KafkaConnectSpecExternalConfigurationEnv']] = None,
                 volumes: Optional[Sequence['outputs.KafkaConnectSpecExternalConfigurationVolumes']] = None):
        """
        Pass data from Secrets or ConfigMaps to the Kafka Connect pods and use them to configure connectors.
        :param Sequence['KafkaConnectSpecExternalConfigurationEnvArgs'] env: Allows to pass data from Secret or ConfigMap to the Kafka Connect pods as environment variables.
        :param Sequence['KafkaConnectSpecExternalConfigurationVolumesArgs'] volumes: Allows to pass data from Secret or ConfigMap to the Kafka Connect pods as volumes.
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @property
    @pulumi.getter
    def env(self) -> Optional[Sequence['outputs.KafkaConnectSpecExternalConfigurationEnv']]:
        """
        Allows to pass data from Secret or ConfigMap to the Kafka Connect pods as environment variables.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def volumes(self) -> Optional[Sequence['outputs.KafkaConnectSpecExternalConfigurationVolumes']]:
        """
        Allows to pass data from Secret or ConfigMap to the Kafka Connect pods as volumes.
        """
        return pulumi.get(self, "volumes")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecExternalConfigurationEnv(dict):
    def __init__(__self__, *,
                 name: str,
                 value_from: 'outputs.KafkaConnectSpecExternalConfigurationEnvValueFrom'):
        """
        :param str name: Name of the environment variable which will be passed to the Kafka Connect pods. The name of the environment variable cannot start with `KAFKA_` or `STRIMZI_`.
        :param 'KafkaConnectSpecExternalConfigurationEnvValueFromArgs' value_from: Value of the environment variable which will be passed to the Kafka Connect pods. It can be passed either as a reference to Secret or ConfigMap field. The field has to specify exactly one Secret or ConfigMap.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value_from", value_from)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the environment variable which will be passed to the Kafka Connect pods. The name of the environment variable cannot start with `KAFKA_` or `STRIMZI_`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="valueFrom")
    def value_from(self) -> 'outputs.KafkaConnectSpecExternalConfigurationEnvValueFrom':
        """
        Value of the environment variable which will be passed to the Kafka Connect pods. It can be passed either as a reference to Secret or ConfigMap field. The field has to specify exactly one Secret or ConfigMap.
        """
        return pulumi.get(self, "value_from")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecExternalConfigurationEnvValueFrom(dict):
    """
    Value of the environment variable which will be passed to the Kafka Connect pods. It can be passed either as a reference to Secret or ConfigMap field. The field has to specify exactly one Secret or ConfigMap.
    """
    def __init__(__self__, *,
                 config_map_key_ref: Optional['outputs.KafkaConnectSpecExternalConfigurationEnvValueFromConfigMapKeyRef'] = None,
                 secret_key_ref: Optional['outputs.KafkaConnectSpecExternalConfigurationEnvValueFromSecretKeyRef'] = None):
        """
        Value of the environment variable which will be passed to the Kafka Connect pods. It can be passed either as a reference to Secret or ConfigMap field. The field has to specify exactly one Secret or ConfigMap.
        :param 'KafkaConnectSpecExternalConfigurationEnvValueFromConfigMapKeyRefArgs' config_map_key_ref: Refernce to a key in a ConfigMap.
        :param 'KafkaConnectSpecExternalConfigurationEnvValueFromSecretKeyRefArgs' secret_key_ref: Reference to a key in a Secret.
        """
        if config_map_key_ref is not None:
            pulumi.set(__self__, "config_map_key_ref", config_map_key_ref)
        if secret_key_ref is not None:
            pulumi.set(__self__, "secret_key_ref", secret_key_ref)

    @property
    @pulumi.getter(name="configMapKeyRef")
    def config_map_key_ref(self) -> Optional['outputs.KafkaConnectSpecExternalConfigurationEnvValueFromConfigMapKeyRef']:
        """
        Refernce to a key in a ConfigMap.
        """
        return pulumi.get(self, "config_map_key_ref")

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> Optional['outputs.KafkaConnectSpecExternalConfigurationEnvValueFromSecretKeyRef']:
        """
        Reference to a key in a Secret.
        """
        return pulumi.get(self, "secret_key_ref")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecExternalConfigurationEnvValueFromConfigMapKeyRef(dict):
    """
    Refernce to a key in a ConfigMap.
    """
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        Refernce to a key in a ConfigMap.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        return pulumi.get(self, "optional")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecExternalConfigurationEnvValueFromSecretKeyRef(dict):
    """
    Reference to a key in a Secret.
    """
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        Reference to a key in a Secret.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        return pulumi.get(self, "optional")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecExternalConfigurationVolumes(dict):
    def __init__(__self__, *,
                 name: str,
                 config_map: Optional['outputs.KafkaConnectSpecExternalConfigurationVolumesConfigMap'] = None,
                 secret: Optional['outputs.KafkaConnectSpecExternalConfigurationVolumesSecret'] = None):
        """
        :param str name: Name of the volume which will be added to the Kafka Connect pods.
        :param 'KafkaConnectSpecExternalConfigurationVolumesConfigMapArgs' config_map: Reference to a key in a ConfigMap. Exactly one Secret or ConfigMap has to be specified.
        :param 'KafkaConnectSpecExternalConfigurationVolumesSecretArgs' secret: Reference to a key in a Secret. Exactly one Secret or ConfigMap has to be specified.
        """
        pulumi.set(__self__, "name", name)
        if config_map is not None:
            pulumi.set(__self__, "config_map", config_map)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the volume which will be added to the Kafka Connect pods.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="configMap")
    def config_map(self) -> Optional['outputs.KafkaConnectSpecExternalConfigurationVolumesConfigMap']:
        """
        Reference to a key in a ConfigMap. Exactly one Secret or ConfigMap has to be specified.
        """
        return pulumi.get(self, "config_map")

    @property
    @pulumi.getter
    def secret(self) -> Optional['outputs.KafkaConnectSpecExternalConfigurationVolumesSecret']:
        """
        Reference to a key in a Secret. Exactly one Secret or ConfigMap has to be specified.
        """
        return pulumi.get(self, "secret")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecExternalConfigurationVolumesConfigMap(dict):
    """
    Reference to a key in a ConfigMap. Exactly one Secret or ConfigMap has to be specified.
    """
    def __init__(__self__, *,
                 default_mode: Optional[int] = None,
                 items: Optional[Sequence['outputs.KafkaConnectSpecExternalConfigurationVolumesConfigMapItems']] = None,
                 name: Optional[str] = None,
                 optional: Optional[bool] = None):
        """
        Reference to a key in a ConfigMap. Exactly one Secret or ConfigMap has to be specified.
        """
        if default_mode is not None:
            pulumi.set(__self__, "default_mode", default_mode)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @property
    @pulumi.getter(name="defaultMode")
    def default_mode(self) -> Optional[int]:
        return pulumi.get(self, "default_mode")

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.KafkaConnectSpecExternalConfigurationVolumesConfigMapItems']]:
        return pulumi.get(self, "items")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        return pulumi.get(self, "optional")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecExternalConfigurationVolumesConfigMapItems(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 mode: Optional[int] = None,
                 path: Optional[str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def mode(self) -> Optional[int]:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecExternalConfigurationVolumesSecret(dict):
    """
    Reference to a key in a Secret. Exactly one Secret or ConfigMap has to be specified.
    """
    def __init__(__self__, *,
                 default_mode: Optional[int] = None,
                 items: Optional[Sequence['outputs.KafkaConnectSpecExternalConfigurationVolumesSecretItems']] = None,
                 optional: Optional[bool] = None,
                 secret_name: Optional[str] = None):
        """
        Reference to a key in a Secret. Exactly one Secret or ConfigMap has to be specified.
        """
        if default_mode is not None:
            pulumi.set(__self__, "default_mode", default_mode)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="defaultMode")
    def default_mode(self) -> Optional[int]:
        return pulumi.get(self, "default_mode")

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.KafkaConnectSpecExternalConfigurationVolumesSecretItems']]:
        return pulumi.get(self, "items")

    @property
    @pulumi.getter
    def optional(self) -> Optional[bool]:
        return pulumi.get(self, "optional")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[str]:
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecExternalConfigurationVolumesSecretItems(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 mode: Optional[int] = None,
                 path: Optional[str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def mode(self) -> Optional[int]:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecJvmOptions(dict):
    """
    JVM Options for pods.
    """
    def __init__(__self__, *,
                 __xx: Optional[Mapping[str, Any]] = None,
                 __xms: Optional[str] = None,
                 __xmx: Optional[str] = None,
                 gc_logging_enabled: Optional[bool] = None,
                 java_system_properties: Optional[Sequence['outputs.KafkaConnectSpecJvmOptionsJavaSystemProperties']] = None):
        """
        JVM Options for pods.
        :param Mapping[str, Any] __xx: A map of -XX options to the JVM.
        :param str __xms: -Xms option to to the JVM.
        :param str __xmx: -Xmx option to to the JVM.
        :param bool gc_logging_enabled: Specifies whether the Garbage Collection logging is enabled. The default is false.
        :param Sequence['KafkaConnectSpecJvmOptionsJavaSystemPropertiesArgs'] java_system_properties: A map of additional system properties which will be passed using the `-D` option to the JVM.
        """
        if __xx is not None:
            pulumi.set(__self__, "__xx", __xx)
        if __xms is not None:
            pulumi.set(__self__, "__xms", __xms)
        if __xmx is not None:
            pulumi.set(__self__, "__xmx", __xmx)
        if gc_logging_enabled is not None:
            pulumi.set(__self__, "gc_logging_enabled", gc_logging_enabled)
        if java_system_properties is not None:
            pulumi.set(__self__, "java_system_properties", java_system_properties)

    @property
    @pulumi.getter(name="-XX")
    def __xx(self) -> Optional[Mapping[str, Any]]:
        """
        A map of -XX options to the JVM.
        """
        return pulumi.get(self, "__xx")

    @property
    @pulumi.getter(name="-Xms")
    def __xms(self) -> Optional[str]:
        """
        -Xms option to to the JVM.
        """
        return pulumi.get(self, "__xms")

    @property
    @pulumi.getter(name="-Xmx")
    def __xmx(self) -> Optional[str]:
        """
        -Xmx option to to the JVM.
        """
        return pulumi.get(self, "__xmx")

    @property
    @pulumi.getter(name="gcLoggingEnabled")
    def gc_logging_enabled(self) -> Optional[bool]:
        """
        Specifies whether the Garbage Collection logging is enabled. The default is false.
        """
        return pulumi.get(self, "gc_logging_enabled")

    @property
    @pulumi.getter(name="javaSystemProperties")
    def java_system_properties(self) -> Optional[Sequence['outputs.KafkaConnectSpecJvmOptionsJavaSystemProperties']]:
        """
        A map of additional system properties which will be passed using the `-D` option to the JVM.
        """
        return pulumi.get(self, "java_system_properties")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecJvmOptionsJavaSystemProperties(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The system property name.
        :param str value: The system property value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The system property name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The system property value.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecLivenessProbe(dict):
    """
    Pod liveness checking.
    """
    def __init__(__self__, *,
                 failure_threshold: Optional[int] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 timeout_seconds: Optional[int] = None):
        """
        Pod liveness checking.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param int initial_delay_seconds: The initial delay before first the health is first checked.
        :param int period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param int timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecLogging(dict):
    """
    Logging configuration for Kafka Connect.
    """
    def __init__(__self__, *,
                 type: str,
                 loggers: Optional[Mapping[str, Any]] = None,
                 name: Optional[str] = None):
        """
        Logging configuration for Kafka Connect.
        :param str type: Logging type, must be either 'inline' or 'external'.
        :param Mapping[str, Any] loggers: A Map from logger name to logger level.
        :param str name: The name of the `ConfigMap` from which to get the logging configuration.
        """
        pulumi.set(__self__, "type", type)
        if loggers is not None:
            pulumi.set(__self__, "loggers", loggers)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Logging type, must be either 'inline' or 'external'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def loggers(self) -> Optional[Mapping[str, Any]]:
        """
        A Map from logger name to logger level.
        """
        return pulumi.get(self, "loggers")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the `ConfigMap` from which to get the logging configuration.
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecRack(dict):
    """
    Configuration of the node label which will be used as the client.rack consumer configuration.
    """
    def __init__(__self__, *,
                 topology_key: str):
        """
        Configuration of the node label which will be used as the client.rack consumer configuration.
        :param str topology_key: A key that matches labels assigned to the Kubernetes cluster nodes. The value of the label is used to set the broker's `broker.rack` config.
        """
        pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> str:
        """
        A key that matches labels assigned to the Kubernetes cluster nodes. The value of the label is used to set the broker's `broker.rack` config.
        """
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecReadinessProbe(dict):
    """
    Pod readiness checking.
    """
    def __init__(__self__, *,
                 failure_threshold: Optional[int] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 timeout_seconds: Optional[int] = None):
        """
        Pod readiness checking.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param int initial_delay_seconds: The initial delay before first the health is first checked.
        :param int period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param int timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecResources(dict):
    """
    The maximum limits for CPU and memory resources and the requested initial resources.
    """
    def __init__(__self__, *,
                 limits: Optional[Mapping[str, Any]] = None,
                 requests: Optional[Mapping[str, Any]] = None):
        """
        The maximum limits for CPU and memory resources and the requested initial resources.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "requests")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplate(dict):
    """
    Template for Kafka Connect and Kafka Connect S2I resources. The template allows users to specify how the `Deployment`, `Pods` and `Service` are generated.
    """
    def __init__(__self__, *,
                 api_service: Optional['outputs.KafkaConnectSpecTemplateApiService'] = None,
                 connect_container: Optional['outputs.KafkaConnectSpecTemplateConnectContainer'] = None,
                 deployment: Optional['outputs.KafkaConnectSpecTemplateDeployment'] = None,
                 init_container: Optional['outputs.KafkaConnectSpecTemplateInitContainer'] = None,
                 pod: Optional['outputs.KafkaConnectSpecTemplatePod'] = None,
                 pod_disruption_budget: Optional['outputs.KafkaConnectSpecTemplatePodDisruptionBudget'] = None):
        """
        Template for Kafka Connect and Kafka Connect S2I resources. The template allows users to specify how the `Deployment`, `Pods` and `Service` are generated.
        :param 'KafkaConnectSpecTemplateApiServiceArgs' api_service: Template for Kafka Connect API `Service`.
        :param 'KafkaConnectSpecTemplateConnectContainerArgs' connect_container: Template for the Kafka Connect container.
        :param 'KafkaConnectSpecTemplateDeploymentArgs' deployment: Template for Kafka Connect `Deployment`.
        :param 'KafkaConnectSpecTemplateInitContainerArgs' init_container: Template for the Kafka init container.
        :param 'KafkaConnectSpecTemplatePodArgs' pod: Template for Kafka Connect `Pods`.
        :param 'KafkaConnectSpecTemplatePodDisruptionBudgetArgs' pod_disruption_budget: Template for Kafka Connect `PodDisruptionBudget`.
        """
        if api_service is not None:
            pulumi.set(__self__, "api_service", api_service)
        if connect_container is not None:
            pulumi.set(__self__, "connect_container", connect_container)
        if deployment is not None:
            pulumi.set(__self__, "deployment", deployment)
        if init_container is not None:
            pulumi.set(__self__, "init_container", init_container)
        if pod is not None:
            pulumi.set(__self__, "pod", pod)
        if pod_disruption_budget is not None:
            pulumi.set(__self__, "pod_disruption_budget", pod_disruption_budget)

    @property
    @pulumi.getter(name="apiService")
    def api_service(self) -> Optional['outputs.KafkaConnectSpecTemplateApiService']:
        """
        Template for Kafka Connect API `Service`.
        """
        return pulumi.get(self, "api_service")

    @property
    @pulumi.getter(name="connectContainer")
    def connect_container(self) -> Optional['outputs.KafkaConnectSpecTemplateConnectContainer']:
        """
        Template for the Kafka Connect container.
        """
        return pulumi.get(self, "connect_container")

    @property
    @pulumi.getter
    def deployment(self) -> Optional['outputs.KafkaConnectSpecTemplateDeployment']:
        """
        Template for Kafka Connect `Deployment`.
        """
        return pulumi.get(self, "deployment")

    @property
    @pulumi.getter(name="initContainer")
    def init_container(self) -> Optional['outputs.KafkaConnectSpecTemplateInitContainer']:
        """
        Template for the Kafka init container.
        """
        return pulumi.get(self, "init_container")

    @property
    @pulumi.getter
    def pod(self) -> Optional['outputs.KafkaConnectSpecTemplatePod']:
        """
        Template for Kafka Connect `Pods`.
        """
        return pulumi.get(self, "pod")

    @property
    @pulumi.getter(name="podDisruptionBudget")
    def pod_disruption_budget(self) -> Optional['outputs.KafkaConnectSpecTemplatePodDisruptionBudget']:
        """
        Template for Kafka Connect `PodDisruptionBudget`.
        """
        return pulumi.get(self, "pod_disruption_budget")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplateApiService(dict):
    """
    Template for Kafka Connect API `Service`.
    """
    def __init__(__self__, *,
                 metadata: Optional['outputs.KafkaConnectSpecTemplateApiServiceMetadata'] = None):
        """
        Template for Kafka Connect API `Service`.
        :param 'KafkaConnectSpecTemplateApiServiceMetadataArgs' metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaConnectSpecTemplateApiServiceMetadata']:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplateApiServiceMetadata(dict):
    """
    Metadata applied to the resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata applied to the resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplateConnectContainer(dict):
    """
    Template for the Kafka Connect container.
    """
    def __init__(__self__, *,
                 env: Optional[Sequence['outputs.KafkaConnectSpecTemplateConnectContainerEnv']] = None,
                 security_context: Optional['outputs.KafkaConnectSpecTemplateConnectContainerSecurityContext'] = None):
        """
        Template for the Kafka Connect container.
        :param Sequence['KafkaConnectSpecTemplateConnectContainerEnvArgs'] env: Environment variables which should be applied to the container.
        :param 'KafkaConnectSpecTemplateConnectContainerSecurityContextArgs' security_context: Security context for the container.
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)

    @property
    @pulumi.getter
    def env(self) -> Optional[Sequence['outputs.KafkaConnectSpecTemplateConnectContainerEnv']]:
        """
        Environment variables which should be applied to the container.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional['outputs.KafkaConnectSpecTemplateConnectContainerSecurityContext']:
        """
        Security context for the container.
        """
        return pulumi.get(self, "security_context")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplateConnectContainerEnv(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The environment variable key.
        :param str value: The environment variable value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The environment variable key.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The environment variable value.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplateConnectContainerSecurityContext(dict):
    """
    Security context for the container.
    """
    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[bool] = None,
                 capabilities: Optional['outputs.KafkaConnectSpecTemplateConnectContainerSecurityContextCapabilities'] = None,
                 privileged: Optional[bool] = None,
                 proc_mount: Optional[str] = None,
                 read_only_root_filesystem: Optional[bool] = None,
                 run_as_group: Optional[int] = None,
                 run_as_non_root: Optional[bool] = None,
                 run_as_user: Optional[int] = None,
                 se_linux_options: Optional['outputs.KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptions'] = None,
                 windows_options: Optional['outputs.KafkaConnectSpecTemplateConnectContainerSecurityContextWindowsOptions'] = None):
        """
        Security context for the container.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if proc_mount is not None:
            pulumi.set(__self__, "proc_mount", proc_mount)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[bool]:
        return pulumi.get(self, "allow_privilege_escalation")

    @property
    @pulumi.getter
    def capabilities(self) -> Optional['outputs.KafkaConnectSpecTemplateConnectContainerSecurityContextCapabilities']:
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def privileged(self) -> Optional[bool]:
        return pulumi.get(self, "privileged")

    @property
    @pulumi.getter(name="procMount")
    def proc_mount(self) -> Optional[str]:
        return pulumi.get(self, "proc_mount")

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[bool]:
        return pulumi.get(self, "read_only_root_filesystem")

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[int]:
        return pulumi.get(self, "run_as_group")

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[bool]:
        return pulumi.get(self, "run_as_non_root")

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[int]:
        return pulumi.get(self, "run_as_user")

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional['outputs.KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptions']:
        return pulumi.get(self, "se_linux_options")

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional['outputs.KafkaConnectSpecTemplateConnectContainerSecurityContextWindowsOptions']:
        return pulumi.get(self, "windows_options")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplateConnectContainerSecurityContextCapabilities(dict):
    def __init__(__self__, *,
                 add: Optional[Sequence[str]] = None,
                 drop: Optional[Sequence[str]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)

    @property
    @pulumi.getter
    def add(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def drop(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "drop")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptions(dict):
    def __init__(__self__, *,
                 level: Optional[str] = None,
                 role: Optional[str] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        return pulumi.get(self, "user")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplateConnectContainerSecurityContextWindowsOptions(dict):
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[str] = None,
                 gmsa_credential_spec_name: Optional[str] = None,
                 run_as_user_name: Optional[str] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec")

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[str]:
        return pulumi.get(self, "run_as_user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplateDeployment(dict):
    """
    Template for Kafka Connect `Deployment`.
    """
    def __init__(__self__, *,
                 metadata: Optional['outputs.KafkaConnectSpecTemplateDeploymentMetadata'] = None):
        """
        Template for Kafka Connect `Deployment`.
        :param 'KafkaConnectSpecTemplateDeploymentMetadataArgs' metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaConnectSpecTemplateDeploymentMetadata']:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplateDeploymentMetadata(dict):
    """
    Metadata applied to the resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata applied to the resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplateInitContainer(dict):
    """
    Template for the Kafka init container.
    """
    def __init__(__self__, *,
                 env: Optional[Sequence['outputs.KafkaConnectSpecTemplateInitContainerEnv']] = None,
                 security_context: Optional['outputs.KafkaConnectSpecTemplateInitContainerSecurityContext'] = None):
        """
        Template for the Kafka init container.
        :param Sequence['KafkaConnectSpecTemplateInitContainerEnvArgs'] env: Environment variables which should be applied to the container.
        :param 'KafkaConnectSpecTemplateInitContainerSecurityContextArgs' security_context: Security context for the container.
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)

    @property
    @pulumi.getter
    def env(self) -> Optional[Sequence['outputs.KafkaConnectSpecTemplateInitContainerEnv']]:
        """
        Environment variables which should be applied to the container.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional['outputs.KafkaConnectSpecTemplateInitContainerSecurityContext']:
        """
        Security context for the container.
        """
        return pulumi.get(self, "security_context")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplateInitContainerEnv(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The environment variable key.
        :param str value: The environment variable value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The environment variable key.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The environment variable value.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplateInitContainerSecurityContext(dict):
    """
    Security context for the container.
    """
    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[bool] = None,
                 capabilities: Optional['outputs.KafkaConnectSpecTemplateInitContainerSecurityContextCapabilities'] = None,
                 privileged: Optional[bool] = None,
                 proc_mount: Optional[str] = None,
                 read_only_root_filesystem: Optional[bool] = None,
                 run_as_group: Optional[int] = None,
                 run_as_non_root: Optional[bool] = None,
                 run_as_user: Optional[int] = None,
                 se_linux_options: Optional['outputs.KafkaConnectSpecTemplateInitContainerSecurityContextSeLinuxOptions'] = None,
                 windows_options: Optional['outputs.KafkaConnectSpecTemplateInitContainerSecurityContextWindowsOptions'] = None):
        """
        Security context for the container.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if proc_mount is not None:
            pulumi.set(__self__, "proc_mount", proc_mount)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[bool]:
        return pulumi.get(self, "allow_privilege_escalation")

    @property
    @pulumi.getter
    def capabilities(self) -> Optional['outputs.KafkaConnectSpecTemplateInitContainerSecurityContextCapabilities']:
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def privileged(self) -> Optional[bool]:
        return pulumi.get(self, "privileged")

    @property
    @pulumi.getter(name="procMount")
    def proc_mount(self) -> Optional[str]:
        return pulumi.get(self, "proc_mount")

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[bool]:
        return pulumi.get(self, "read_only_root_filesystem")

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[int]:
        return pulumi.get(self, "run_as_group")

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[bool]:
        return pulumi.get(self, "run_as_non_root")

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[int]:
        return pulumi.get(self, "run_as_user")

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional['outputs.KafkaConnectSpecTemplateInitContainerSecurityContextSeLinuxOptions']:
        return pulumi.get(self, "se_linux_options")

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional['outputs.KafkaConnectSpecTemplateInitContainerSecurityContextWindowsOptions']:
        return pulumi.get(self, "windows_options")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplateInitContainerSecurityContextCapabilities(dict):
    def __init__(__self__, *,
                 add: Optional[Sequence[str]] = None,
                 drop: Optional[Sequence[str]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)

    @property
    @pulumi.getter
    def add(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def drop(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "drop")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplateInitContainerSecurityContextSeLinuxOptions(dict):
    def __init__(__self__, *,
                 level: Optional[str] = None,
                 role: Optional[str] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        return pulumi.get(self, "user")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplateInitContainerSecurityContextWindowsOptions(dict):
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[str] = None,
                 gmsa_credential_spec_name: Optional[str] = None,
                 run_as_user_name: Optional[str] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec")

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[str]:
        return pulumi.get(self, "run_as_user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplatePod(dict):
    """
    Template for Kafka Connect `Pods`.
    """
    def __init__(__self__, *,
                 affinity: Optional['outputs.KafkaConnectSpecTemplatePodAffinity'] = None,
                 host_aliases: Optional[Sequence['outputs.KafkaConnectSpecTemplatePodHostAliases']] = None,
                 image_pull_secrets: Optional[Sequence['outputs.KafkaConnectSpecTemplatePodImagePullSecrets']] = None,
                 metadata: Optional['outputs.KafkaConnectSpecTemplatePodMetadata'] = None,
                 priority_class_name: Optional[str] = None,
                 scheduler_name: Optional[str] = None,
                 security_context: Optional['outputs.KafkaConnectSpecTemplatePodSecurityContext'] = None,
                 termination_grace_period_seconds: Optional[int] = None,
                 tolerations: Optional[Sequence['outputs.KafkaConnectSpecTemplatePodTolerations']] = None):
        """
        Template for Kafka Connect `Pods`.
        :param 'KafkaConnectSpecTemplatePodAffinityArgs' affinity: The pod's affinity rules.
        :param Sequence['KafkaConnectSpecTemplatePodHostAliasesArgs'] host_aliases: The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
        :param Sequence['KafkaConnectSpecTemplatePodImagePullSecretsArgs'] image_pull_secrets: List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
        :param 'KafkaConnectSpecTemplatePodMetadataArgs' metadata: Metadata applied to the resource.
        :param str priority_class_name: The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
        :param str scheduler_name: The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
        :param 'KafkaConnectSpecTemplatePodSecurityContextArgs' security_context: Configures pod-level security attributes and common container settings.
        :param int termination_grace_period_seconds: The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
        :param Sequence['KafkaConnectSpecTemplatePodTolerationsArgs'] tolerations: The pod's tolerations.
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if host_aliases is not None:
            pulumi.set(__self__, "host_aliases", host_aliases)
        if image_pull_secrets is not None:
            pulumi.set(__self__, "image_pull_secrets", image_pull_secrets)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if priority_class_name is not None:
            pulumi.set(__self__, "priority_class_name", priority_class_name)
        if scheduler_name is not None:
            pulumi.set(__self__, "scheduler_name", scheduler_name)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)

    @property
    @pulumi.getter
    def affinity(self) -> Optional['outputs.KafkaConnectSpecTemplatePodAffinity']:
        """
        The pod's affinity rules.
        """
        return pulumi.get(self, "affinity")

    @property
    @pulumi.getter(name="hostAliases")
    def host_aliases(self) -> Optional[Sequence['outputs.KafkaConnectSpecTemplatePodHostAliases']]:
        """
        The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
        """
        return pulumi.get(self, "host_aliases")

    @property
    @pulumi.getter(name="imagePullSecrets")
    def image_pull_secrets(self) -> Optional[Sequence['outputs.KafkaConnectSpecTemplatePodImagePullSecrets']]:
        """
        List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
        """
        return pulumi.get(self, "image_pull_secrets")

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaConnectSpecTemplatePodMetadata']:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter(name="priorityClassName")
    def priority_class_name(self) -> Optional[str]:
        """
        The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
        """
        return pulumi.get(self, "priority_class_name")

    @property
    @pulumi.getter(name="schedulerName")
    def scheduler_name(self) -> Optional[str]:
        """
        The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
        """
        return pulumi.get(self, "scheduler_name")

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional['outputs.KafkaConnectSpecTemplatePodSecurityContext']:
        """
        Configures pod-level security attributes and common container settings.
        """
        return pulumi.get(self, "security_context")

    @property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[int]:
        """
        The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
        """
        return pulumi.get(self, "termination_grace_period_seconds")

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[Sequence['outputs.KafkaConnectSpecTemplatePodTolerations']]:
        """
        The pod's tolerations.
        """
        return pulumi.get(self, "tolerations")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplatePodAffinity(dict):
    """
    The pod's affinity rules.
    """
    def __init__(__self__, *,
                 node_affinity: Optional['outputs.KafkaConnectSpecTemplatePodAffinityNodeAffinity'] = None,
                 pod_affinity: Optional['outputs.KafkaConnectSpecTemplatePodAffinityPodAffinity'] = None,
                 pod_anti_affinity: Optional['outputs.KafkaConnectSpecTemplatePodAffinityPodAntiAffinity'] = None):
        """
        The pod's affinity rules.
        """
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional['outputs.KafkaConnectSpecTemplatePodAffinityNodeAffinity']:
        return pulumi.get(self, "node_affinity")

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional['outputs.KafkaConnectSpecTemplatePodAffinityPodAffinity']:
        return pulumi.get(self, "pod_affinity")

    @property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional['outputs.KafkaConnectSpecTemplatePodAffinityPodAntiAffinity']:
        return pulumi.get(self, "pod_anti_affinity")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplatePodAffinityNodeAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional['outputs.KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution'] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional['outputs.KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution']:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 preference: Optional['outputs.KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference'] = None,
                 weight: Optional[int] = None):
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preference(self) -> Optional['outputs.KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference']:
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions']] = None,
                 match_fields: Optional[Sequence['outputs.KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields']] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields']]:
        return pulumi.get(self, "match_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 node_selector_terms: Optional[Sequence['outputs.KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms']] = None):
        if node_selector_terms is not None:
            pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> Optional[Sequence['outputs.KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms']]:
        return pulumi.get(self, "node_selector_terms")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions']] = None,
                 match_fields: Optional[Sequence['outputs.KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields']] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields']]:
        return pulumi.get(self, "match_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplatePodAffinityPodAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 pod_affinity_term: Optional['outputs.KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm'] = None,
                 weight: Optional[int] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional['outputs.KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm']:
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplatePodAffinityPodAntiAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 pod_affinity_term: Optional['outputs.KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm'] = None,
                 weight: Optional[int] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional['outputs.KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm']:
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplatePodDisruptionBudget(dict):
    """
    Template for Kafka Connect `PodDisruptionBudget`.
    """
    def __init__(__self__, *,
                 max_unavailable: Optional[int] = None,
                 metadata: Optional['outputs.KafkaConnectSpecTemplatePodDisruptionBudgetMetadata'] = None):
        """
        Template for Kafka Connect `PodDisruptionBudget`.
        :param int max_unavailable: Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
        :param 'KafkaConnectSpecTemplatePodDisruptionBudgetMetadataArgs' metadata: Metadata to apply to the `PodDistruptionBugetTemplate` resource.
        """
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[int]:
        """
        Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
        """
        return pulumi.get(self, "max_unavailable")

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaConnectSpecTemplatePodDisruptionBudgetMetadata']:
        """
        Metadata to apply to the `PodDistruptionBugetTemplate` resource.
        """
        return pulumi.get(self, "metadata")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplatePodDisruptionBudgetMetadata(dict):
    """
    Metadata to apply to the `PodDistruptionBugetTemplate` resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata to apply to the `PodDistruptionBugetTemplate` resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplatePodHostAliases(dict):
    def __init__(__self__, *,
                 hostnames: Optional[Sequence[str]] = None,
                 ip: Optional[str] = None):
        if hostnames is not None:
            pulumi.set(__self__, "hostnames", hostnames)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def hostnames(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "hostnames")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        return pulumi.get(self, "ip")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplatePodImagePullSecrets(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplatePodMetadata(dict):
    """
    Metadata applied to the resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata applied to the resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplatePodSecurityContext(dict):
    """
    Configures pod-level security attributes and common container settings.
    """
    def __init__(__self__, *,
                 fs_group: Optional[int] = None,
                 fs_group_change_policy: Optional[str] = None,
                 run_as_group: Optional[int] = None,
                 run_as_non_root: Optional[bool] = None,
                 run_as_user: Optional[int] = None,
                 se_linux_options: Optional['outputs.KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptions'] = None,
                 supplemental_groups: Optional[Sequence[int]] = None,
                 sysctls: Optional[Sequence['outputs.KafkaConnectSpecTemplatePodSecurityContextSysctls']] = None,
                 windows_options: Optional['outputs.KafkaConnectSpecTemplatePodSecurityContextWindowsOptions'] = None):
        """
        Configures pod-level security attributes and common container settings.
        """
        if fs_group is not None:
            pulumi.set(__self__, "fs_group", fs_group)
        if fs_group_change_policy is not None:
            pulumi.set(__self__, "fs_group_change_policy", fs_group_change_policy)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if supplemental_groups is not None:
            pulumi.set(__self__, "supplemental_groups", supplemental_groups)
        if sysctls is not None:
            pulumi.set(__self__, "sysctls", sysctls)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="fsGroup")
    def fs_group(self) -> Optional[int]:
        return pulumi.get(self, "fs_group")

    @property
    @pulumi.getter(name="fsGroupChangePolicy")
    def fs_group_change_policy(self) -> Optional[str]:
        return pulumi.get(self, "fs_group_change_policy")

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[int]:
        return pulumi.get(self, "run_as_group")

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[bool]:
        return pulumi.get(self, "run_as_non_root")

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[int]:
        return pulumi.get(self, "run_as_user")

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional['outputs.KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptions']:
        return pulumi.get(self, "se_linux_options")

    @property
    @pulumi.getter(name="supplementalGroups")
    def supplemental_groups(self) -> Optional[Sequence[int]]:
        return pulumi.get(self, "supplemental_groups")

    @property
    @pulumi.getter
    def sysctls(self) -> Optional[Sequence['outputs.KafkaConnectSpecTemplatePodSecurityContextSysctls']]:
        return pulumi.get(self, "sysctls")

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional['outputs.KafkaConnectSpecTemplatePodSecurityContextWindowsOptions']:
        return pulumi.get(self, "windows_options")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptions(dict):
    def __init__(__self__, *,
                 level: Optional[str] = None,
                 role: Optional[str] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        return pulumi.get(self, "user")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplatePodSecurityContextSysctls(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplatePodSecurityContextWindowsOptions(dict):
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[str] = None,
                 gmsa_credential_spec_name: Optional[str] = None,
                 run_as_user_name: Optional[str] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec")

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[str]:
        return pulumi.get(self, "run_as_user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTemplatePodTolerations(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 toleration_seconds: Optional[int] = None,
                 value: Optional[str] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if toleration_seconds is not None:
            pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> Optional[int]:
        return pulumi.get(self, "toleration_seconds")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTls(dict):
    """
    TLS configuration.
    """
    def __init__(__self__, *,
                 trusted_certificates: Optional[Sequence['outputs.KafkaConnectSpecTlsTrustedCertificates']] = None):
        """
        TLS configuration.
        :param Sequence['KafkaConnectSpecTlsTrustedCertificatesArgs'] trusted_certificates: Trusted certificates for TLS connection.
        """
        if trusted_certificates is not None:
            pulumi.set(__self__, "trusted_certificates", trusted_certificates)

    @property
    @pulumi.getter(name="trustedCertificates")
    def trusted_certificates(self) -> Optional[Sequence['outputs.KafkaConnectSpecTlsTrustedCertificates']]:
        """
        Trusted certificates for TLS connection.
        """
        return pulumi.get(self, "trusted_certificates")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTlsTrustedCertificates(dict):
    def __init__(__self__, *,
                 certificate: str,
                 secret_name: str):
        """
        :param str certificate: The name of the file certificate in the Secret.
        :param str secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> str:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTolerations(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 toleration_seconds: Optional[int] = None,
                 value: Optional[str] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if toleration_seconds is not None:
            pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> Optional[int]:
        return pulumi.get(self, "toleration_seconds")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectSpecTracing(dict):
    """
    The configuration of tracing in Kafka Connect.
    """
    def __init__(__self__, *,
                 type: str):
        """
        The configuration of tracing in Kafka Connect.
        :param str type: Type of the tracing used. Currently the only supported type is `jaeger` for Jaeger tracing.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the tracing used. Currently the only supported type is `jaeger` for Jaeger tracing.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectStatus(dict):
    """
    The status of the Kafka Connect cluster.
    """
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.KafkaConnectStatusConditions']] = None,
                 connector_plugins: Optional[Sequence['outputs.KafkaConnectStatusConnectorPlugins']] = None,
                 label_selector: Optional[str] = None,
                 observed_generation: Optional[int] = None,
                 replicas: Optional[int] = None,
                 url: Optional[str] = None):
        """
        The status of the Kafka Connect cluster.
        :param Sequence['KafkaConnectStatusConditionsArgs'] conditions: List of status conditions.
        :param Sequence['KafkaConnectStatusConnectorPluginsArgs'] connector_plugins: The list of connector plugins available in this Kafka Connect deployment.
        :param str label_selector: Label selector for pods providing this resource.
        :param int observed_generation: The generation of the CRD that was last reconciled by the operator.
        :param int replicas: The current number of pods being used to provide this resource.
        :param str url: The URL of the REST API endpoint for managing and monitoring Kafka Connect connectors.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if connector_plugins is not None:
            pulumi.set(__self__, "connector_plugins", connector_plugins)
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.KafkaConnectStatusConditions']]:
        """
        List of status conditions.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="connectorPlugins")
    def connector_plugins(self) -> Optional[Sequence['outputs.KafkaConnectStatusConnectorPlugins']]:
        """
        The list of connector plugins available in this Kafka Connect deployment.
        """
        return pulumi.get(self, "connector_plugins")

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[str]:
        """
        Label selector for pods providing this resource.
        """
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[int]:
        """
        The generation of the CRD that was last reconciled by the operator.
        """
        return pulumi.get(self, "observed_generation")

    @property
    @pulumi.getter
    def replicas(self) -> Optional[int]:
        """
        The current number of pods being used to provide this resource.
        """
        return pulumi.get(self, "replicas")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The URL of the REST API endpoint for managing and monitoring Kafka Connect connectors.
        """
        return pulumi.get(self, "url")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectStatusConditions(dict):
    def __init__(__self__, *,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None,
                 status: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str last_transition_time: Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
        :param str message: Human-readable message indicating details about the condition's last transition.
        :param str reason: The reason for the condition's last transition (a single word in CamelCase).
        :param str status: The status of the condition, either True, False or Unknown.
        :param str type: The unique identifier of a condition, used to distinguish between other conditions in the resource.
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Human-readable message indicating details about the condition's last transition.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        The reason for the condition's last transition (a single word in CamelCase).
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The status of the condition, either True, False or Unknown.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The unique identifier of a condition, used to distinguish between other conditions in the resource.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaConnectStatusConnectorPlugins(dict):
    def __init__(__self__, *,
                 class_: Optional[str] = None,
                 type: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str class_: The class of the connector plugin.
        :param str type: The type of the connector plugin. The available types are `sink` and `source`.
        :param str version: The version of the connector plugin.
        """
        if class_ is not None:
            pulumi.set(__self__, "class_", class_)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="class")
    def class_(self) -> Optional[str]:
        """
        The class of the connector plugin.
        """
        return pulumi.get(self, "class_")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of the connector plugin. The available types are `sink` and `source`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        The version of the connector plugin.
        """
        return pulumi.get(self, "version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpec(dict):
    """
    The specification of Kafka MirrorMaker.
    """
    def __init__(__self__, *,
                 consumer: 'outputs.KafkaMirrorMakerSpecConsumer',
                 producer: 'outputs.KafkaMirrorMakerSpecProducer',
                 replicas: int,
                 whitelist: str,
                 affinity: Optional['outputs.KafkaMirrorMakerSpecAffinity'] = None,
                 image: Optional[str] = None,
                 jvm_options: Optional['outputs.KafkaMirrorMakerSpecJvmOptions'] = None,
                 liveness_probe: Optional['outputs.KafkaMirrorMakerSpecLivenessProbe'] = None,
                 logging: Optional['outputs.KafkaMirrorMakerSpecLogging'] = None,
                 metrics: Optional[Mapping[str, Any]] = None,
                 readiness_probe: Optional['outputs.KafkaMirrorMakerSpecReadinessProbe'] = None,
                 resources: Optional['outputs.KafkaMirrorMakerSpecResources'] = None,
                 template: Optional['outputs.KafkaMirrorMakerSpecTemplate'] = None,
                 tolerations: Optional[Sequence['outputs.KafkaMirrorMakerSpecTolerations']] = None,
                 tracing: Optional['outputs.KafkaMirrorMakerSpecTracing'] = None,
                 version: Optional[str] = None):
        """
        The specification of Kafka MirrorMaker.
        :param 'KafkaMirrorMakerSpecConsumerArgs' consumer: Configuration of source cluster.
        :param 'KafkaMirrorMakerSpecProducerArgs' producer: Configuration of target cluster.
        :param int replicas: The number of pods in the `Deployment`.
        :param str whitelist: List of topics which are included for mirroring. This option allows any regular expression using Java-style regular expressions. Mirroring two topics named A and B is achieved by using the whitelist `'A\|B'`. Or, as a special case, you can mirror all topics using the whitelist '*'. You can also specify multiple regular expressions separated by commas.
        :param 'KafkaMirrorMakerSpecAffinityArgs' affinity: The pod's affinity rules.
        :param str image: The docker image for the pods.
        :param 'KafkaMirrorMakerSpecJvmOptionsArgs' jvm_options: JVM Options for pods.
        :param 'KafkaMirrorMakerSpecLivenessProbeArgs' liveness_probe: Pod liveness checking.
        :param 'KafkaMirrorMakerSpecLoggingArgs' logging: Logging configuration for MirrorMaker.
        :param Mapping[str, Any] metrics: The Prometheus JMX Exporter configuration. See {JMXExporter} for details of the structure of this configuration.
        :param 'KafkaMirrorMakerSpecReadinessProbeArgs' readiness_probe: Pod readiness checking.
        :param 'KafkaMirrorMakerSpecResourcesArgs' resources: CPU and memory resources to reserve.
        :param 'KafkaMirrorMakerSpecTemplateArgs' template: Template to specify how Kafka MirrorMaker resources, `Deployments` and `Pods`, are generated.
        :param Sequence['KafkaMirrorMakerSpecTolerationsArgs'] tolerations: The pod's tolerations.
        :param 'KafkaMirrorMakerSpecTracingArgs' tracing: The configuration of tracing in Kafka MirrorMaker.
        :param str version: The Kafka MirrorMaker version. Defaults to {DefaultKafkaVersion}. Consult the documentation to understand the process required to upgrade or downgrade the version.
        """
        pulumi.set(__self__, "consumer", consumer)
        pulumi.set(__self__, "producer", producer)
        pulumi.set(__self__, "replicas", replicas)
        pulumi.set(__self__, "whitelist", whitelist)
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if jvm_options is not None:
            pulumi.set(__self__, "jvm_options", jvm_options)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if template is not None:
            pulumi.set(__self__, "template", template)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)
        if tracing is not None:
            pulumi.set(__self__, "tracing", tracing)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def consumer(self) -> 'outputs.KafkaMirrorMakerSpecConsumer':
        """
        Configuration of source cluster.
        """
        return pulumi.get(self, "consumer")

    @property
    @pulumi.getter
    def producer(self) -> 'outputs.KafkaMirrorMakerSpecProducer':
        """
        Configuration of target cluster.
        """
        return pulumi.get(self, "producer")

    @property
    @pulumi.getter
    def replicas(self) -> int:
        """
        The number of pods in the `Deployment`.
        """
        return pulumi.get(self, "replicas")

    @property
    @pulumi.getter
    def whitelist(self) -> str:
        """
        List of topics which are included for mirroring. This option allows any regular expression using Java-style regular expressions. Mirroring two topics named A and B is achieved by using the whitelist `'A\|B'`. Or, as a special case, you can mirror all topics using the whitelist '*'. You can also specify multiple regular expressions separated by commas.
        """
        return pulumi.get(self, "whitelist")

    @property
    @pulumi.getter
    def affinity(self) -> Optional['outputs.KafkaMirrorMakerSpecAffinity']:
        """
        The pod's affinity rules.
        """
        return pulumi.get(self, "affinity")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        The docker image for the pods.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="jvmOptions")
    def jvm_options(self) -> Optional['outputs.KafkaMirrorMakerSpecJvmOptions']:
        """
        JVM Options for pods.
        """
        return pulumi.get(self, "jvm_options")

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional['outputs.KafkaMirrorMakerSpecLivenessProbe']:
        """
        Pod liveness checking.
        """
        return pulumi.get(self, "liveness_probe")

    @property
    @pulumi.getter
    def logging(self) -> Optional['outputs.KafkaMirrorMakerSpecLogging']:
        """
        Logging configuration for MirrorMaker.
        """
        return pulumi.get(self, "logging")

    @property
    @pulumi.getter
    def metrics(self) -> Optional[Mapping[str, Any]]:
        """
        The Prometheus JMX Exporter configuration. See {JMXExporter} for details of the structure of this configuration.
        """
        return pulumi.get(self, "metrics")

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional['outputs.KafkaMirrorMakerSpecReadinessProbe']:
        """
        Pod readiness checking.
        """
        return pulumi.get(self, "readiness_probe")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.KafkaMirrorMakerSpecResources']:
        """
        CPU and memory resources to reserve.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter
    def template(self) -> Optional['outputs.KafkaMirrorMakerSpecTemplate']:
        """
        Template to specify how Kafka MirrorMaker resources, `Deployments` and `Pods`, are generated.
        """
        return pulumi.get(self, "template")

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[Sequence['outputs.KafkaMirrorMakerSpecTolerations']]:
        """
        The pod's tolerations.
        """
        return pulumi.get(self, "tolerations")

    @property
    @pulumi.getter
    def tracing(self) -> Optional['outputs.KafkaMirrorMakerSpecTracing']:
        """
        The configuration of tracing in Kafka MirrorMaker.
        """
        return pulumi.get(self, "tracing")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        The Kafka MirrorMaker version. Defaults to {DefaultKafkaVersion}. Consult the documentation to understand the process required to upgrade or downgrade the version.
        """
        return pulumi.get(self, "version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecAffinity(dict):
    """
    The pod's affinity rules.
    """
    def __init__(__self__, *,
                 node_affinity: Optional['outputs.KafkaMirrorMakerSpecAffinityNodeAffinity'] = None,
                 pod_affinity: Optional['outputs.KafkaMirrorMakerSpecAffinityPodAffinity'] = None,
                 pod_anti_affinity: Optional['outputs.KafkaMirrorMakerSpecAffinityPodAntiAffinity'] = None):
        """
        The pod's affinity rules.
        """
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional['outputs.KafkaMirrorMakerSpecAffinityNodeAffinity']:
        return pulumi.get(self, "node_affinity")

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional['outputs.KafkaMirrorMakerSpecAffinityPodAffinity']:
        return pulumi.get(self, "pod_affinity")

    @property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional['outputs.KafkaMirrorMakerSpecAffinityPodAntiAffinity']:
        return pulumi.get(self, "pod_anti_affinity")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecAffinityNodeAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional['outputs.KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution'] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional['outputs.KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution']:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 preference: Optional['outputs.KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference'] = None,
                 weight: Optional[int] = None):
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preference(self) -> Optional['outputs.KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference']:
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions']] = None,
                 match_fields: Optional[Sequence['outputs.KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields']] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields']]:
        return pulumi.get(self, "match_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 node_selector_terms: Optional[Sequence['outputs.KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms']] = None):
        if node_selector_terms is not None:
            pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> Optional[Sequence['outputs.KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms']]:
        return pulumi.get(self, "node_selector_terms")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions']] = None,
                 match_fields: Optional[Sequence['outputs.KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields']] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields']]:
        return pulumi.get(self, "match_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecAffinityPodAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 pod_affinity_term: Optional['outputs.KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm'] = None,
                 weight: Optional[int] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional['outputs.KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm']:
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecAffinityPodAntiAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 pod_affinity_term: Optional['outputs.KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm'] = None,
                 weight: Optional[int] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional['outputs.KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm']:
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecConsumer(dict):
    """
    Configuration of source cluster.
    """
    def __init__(__self__, *,
                 bootstrap_servers: str,
                 group_id: str,
                 authentication: Optional['outputs.KafkaMirrorMakerSpecConsumerAuthentication'] = None,
                 config: Optional[Mapping[str, Any]] = None,
                 num_streams: Optional[int] = None,
                 offset_commit_interval: Optional[int] = None,
                 tls: Optional['outputs.KafkaMirrorMakerSpecConsumerTls'] = None):
        """
        Configuration of source cluster.
        :param str bootstrap_servers: A list of host:port pairs for establishing the initial connection to the Kafka cluster.
        :param str group_id: A unique string that identifies the consumer group this consumer belongs to.
        :param 'KafkaMirrorMakerSpecConsumerAuthenticationArgs' authentication: Authentication configuration for connecting to the cluster.
        :param Mapping[str, Any] config: The MirrorMaker consumer config. Properties with the following prefixes cannot be set: ssl., bootstrap.servers, group.id, sasl., security., interceptor.classes (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
        :param int num_streams: Specifies the number of consumer stream threads to create.
        :param int offset_commit_interval: Specifies the offset auto-commit interval in ms. Default value is 60000.
        :param 'KafkaMirrorMakerSpecConsumerTlsArgs' tls: TLS configuration for connecting MirrorMaker to the cluster.
        """
        pulumi.set(__self__, "bootstrap_servers", bootstrap_servers)
        pulumi.set(__self__, "group_id", group_id)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if num_streams is not None:
            pulumi.set(__self__, "num_streams", num_streams)
        if offset_commit_interval is not None:
            pulumi.set(__self__, "offset_commit_interval", offset_commit_interval)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter(name="bootstrapServers")
    def bootstrap_servers(self) -> str:
        """
        A list of host:port pairs for establishing the initial connection to the Kafka cluster.
        """
        return pulumi.get(self, "bootstrap_servers")

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> str:
        """
        A unique string that identifies the consumer group this consumer belongs to.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter
    def authentication(self) -> Optional['outputs.KafkaMirrorMakerSpecConsumerAuthentication']:
        """
        Authentication configuration for connecting to the cluster.
        """
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter
    def config(self) -> Optional[Mapping[str, Any]]:
        """
        The MirrorMaker consumer config. Properties with the following prefixes cannot be set: ssl., bootstrap.servers, group.id, sasl., security., interceptor.classes (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter(name="numStreams")
    def num_streams(self) -> Optional[int]:
        """
        Specifies the number of consumer stream threads to create.
        """
        return pulumi.get(self, "num_streams")

    @property
    @pulumi.getter(name="offsetCommitInterval")
    def offset_commit_interval(self) -> Optional[int]:
        """
        Specifies the offset auto-commit interval in ms. Default value is 60000.
        """
        return pulumi.get(self, "offset_commit_interval")

    @property
    @pulumi.getter
    def tls(self) -> Optional['outputs.KafkaMirrorMakerSpecConsumerTls']:
        """
        TLS configuration for connecting MirrorMaker to the cluster.
        """
        return pulumi.get(self, "tls")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecConsumerAuthentication(dict):
    """
    Authentication configuration for connecting to the cluster.
    """
    def __init__(__self__, *,
                 type: str,
                 access_token: Optional['outputs.KafkaMirrorMakerSpecConsumerAuthenticationAccessToken'] = None,
                 access_token_is_jwt: Optional[bool] = None,
                 certificate_and_key: Optional['outputs.KafkaMirrorMakerSpecConsumerAuthenticationCertificateAndKey'] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional['outputs.KafkaMirrorMakerSpecConsumerAuthenticationClientSecret'] = None,
                 disable_tls_hostname_verification: Optional[bool] = None,
                 max_token_expiry_seconds: Optional[int] = None,
                 password_secret: Optional['outputs.KafkaMirrorMakerSpecConsumerAuthenticationPasswordSecret'] = None,
                 refresh_token: Optional['outputs.KafkaMirrorMakerSpecConsumerAuthenticationRefreshToken'] = None,
                 scope: Optional[str] = None,
                 tls_trusted_certificates: Optional[Sequence['outputs.KafkaMirrorMakerSpecConsumerAuthenticationTlsTrustedCertificates']] = None,
                 token_endpoint_uri: Optional[str] = None,
                 username: Optional[str] = None):
        """
        Authentication configuration for connecting to the cluster.
        :param str type: Authentication type. Currently the only supported types are `tls`, `scram-sha-512`, and `plain`. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
        :param 'KafkaMirrorMakerSpecConsumerAuthenticationAccessTokenArgs' access_token: Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
        :param bool access_token_is_jwt: Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
        :param 'KafkaMirrorMakerSpecConsumerAuthenticationCertificateAndKeyArgs' certificate_and_key: Reference to the `Secret` which holds the certificate and private key pair.
        :param str client_id: OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        :param 'KafkaMirrorMakerSpecConsumerAuthenticationClientSecretArgs' client_secret: Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        :param bool disable_tls_hostname_verification: Enable or disable TLS hostname verification. Default value is `false`.
        :param int max_token_expiry_seconds: Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.
        :param 'KafkaMirrorMakerSpecConsumerAuthenticationPasswordSecretArgs' password_secret: Reference to the `Secret` which holds the password.
        :param 'KafkaMirrorMakerSpecConsumerAuthenticationRefreshTokenArgs' refresh_token: Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
        :param str scope: OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.
        :param Sequence['KafkaMirrorMakerSpecConsumerAuthenticationTlsTrustedCertificatesArgs'] tls_trusted_certificates: Trusted certificates for TLS connection to the OAuth server.
        :param str token_endpoint_uri: Authorization server token endpoint URI.
        :param str username: Username used for the authentication.
        """
        pulumi.set(__self__, "type", type)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if access_token_is_jwt is not None:
            pulumi.set(__self__, "access_token_is_jwt", access_token_is_jwt)
        if certificate_and_key is not None:
            pulumi.set(__self__, "certificate_and_key", certificate_and_key)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if disable_tls_hostname_verification is not None:
            pulumi.set(__self__, "disable_tls_hostname_verification", disable_tls_hostname_verification)
        if max_token_expiry_seconds is not None:
            pulumi.set(__self__, "max_token_expiry_seconds", max_token_expiry_seconds)
        if password_secret is not None:
            pulumi.set(__self__, "password_secret", password_secret)
        if refresh_token is not None:
            pulumi.set(__self__, "refresh_token", refresh_token)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if tls_trusted_certificates is not None:
            pulumi.set(__self__, "tls_trusted_certificates", tls_trusted_certificates)
        if token_endpoint_uri is not None:
            pulumi.set(__self__, "token_endpoint_uri", token_endpoint_uri)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Authentication type. Currently the only supported types are `tls`, `scram-sha-512`, and `plain`. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional['outputs.KafkaMirrorMakerSpecConsumerAuthenticationAccessToken']:
        """
        Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="accessTokenIsJwt")
    def access_token_is_jwt(self) -> Optional[bool]:
        """
        Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
        """
        return pulumi.get(self, "access_token_is_jwt")

    @property
    @pulumi.getter(name="certificateAndKey")
    def certificate_and_key(self) -> Optional['outputs.KafkaMirrorMakerSpecConsumerAuthenticationCertificateAndKey']:
        """
        Reference to the `Secret` which holds the certificate and private key pair.
        """
        return pulumi.get(self, "certificate_and_key")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional['outputs.KafkaMirrorMakerSpecConsumerAuthenticationClientSecret']:
        """
        Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="disableTlsHostnameVerification")
    def disable_tls_hostname_verification(self) -> Optional[bool]:
        """
        Enable or disable TLS hostname verification. Default value is `false`.
        """
        return pulumi.get(self, "disable_tls_hostname_verification")

    @property
    @pulumi.getter(name="maxTokenExpirySeconds")
    def max_token_expiry_seconds(self) -> Optional[int]:
        """
        Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.
        """
        return pulumi.get(self, "max_token_expiry_seconds")

    @property
    @pulumi.getter(name="passwordSecret")
    def password_secret(self) -> Optional['outputs.KafkaMirrorMakerSpecConsumerAuthenticationPasswordSecret']:
        """
        Reference to the `Secret` which holds the password.
        """
        return pulumi.get(self, "password_secret")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional['outputs.KafkaMirrorMakerSpecConsumerAuthenticationRefreshToken']:
        """
        Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
        """
        return pulumi.get(self, "refresh_token")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter(name="tlsTrustedCertificates")
    def tls_trusted_certificates(self) -> Optional[Sequence['outputs.KafkaMirrorMakerSpecConsumerAuthenticationTlsTrustedCertificates']]:
        """
        Trusted certificates for TLS connection to the OAuth server.
        """
        return pulumi.get(self, "tls_trusted_certificates")

    @property
    @pulumi.getter(name="tokenEndpointUri")
    def token_endpoint_uri(self) -> Optional[str]:
        """
        Authorization server token endpoint URI.
        """
        return pulumi.get(self, "token_endpoint_uri")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username used for the authentication.
        """
        return pulumi.get(self, "username")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecConsumerAuthenticationAccessToken(dict):
    """
    Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
    """
    def __init__(__self__, *,
                 key: str,
                 secret_name: str):
        """
        Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
        :param str key: The key under which the secret value is stored in the Kubernetes Secret.
        :param str secret_name: The name of the Kubernetes Secret containing the secret value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key under which the secret value is stored in the Kubernetes Secret.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Kubernetes Secret containing the secret value.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecConsumerAuthenticationCertificateAndKey(dict):
    """
    Reference to the `Secret` which holds the certificate and private key pair.
    """
    def __init__(__self__, *,
                 certificate: str,
                 key: str,
                 secret_name: str):
        """
        Reference to the `Secret` which holds the certificate and private key pair.
        :param str certificate: The name of the file certificate in the Secret.
        :param str key: The name of the private key in the Secret.
        :param str secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> str:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The name of the private key in the Secret.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecConsumerAuthenticationClientSecret(dict):
    """
    Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
    """
    def __init__(__self__, *,
                 key: str,
                 secret_name: str):
        """
        Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        :param str key: The key under which the secret value is stored in the Kubernetes Secret.
        :param str secret_name: The name of the Kubernetes Secret containing the secret value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key under which the secret value is stored in the Kubernetes Secret.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Kubernetes Secret containing the secret value.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecConsumerAuthenticationPasswordSecret(dict):
    """
    Reference to the `Secret` which holds the password.
    """
    def __init__(__self__, *,
                 password: str,
                 secret_name: str):
        """
        Reference to the `Secret` which holds the password.
        :param str password: The name of the key in the Secret under which the password is stored.
        :param str secret_name: The name of the Secret containing the password.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The name of the key in the Secret under which the password is stored.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Secret containing the password.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecConsumerAuthenticationRefreshToken(dict):
    """
    Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
    """
    def __init__(__self__, *,
                 key: str,
                 secret_name: str):
        """
        Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
        :param str key: The key under which the secret value is stored in the Kubernetes Secret.
        :param str secret_name: The name of the Kubernetes Secret containing the secret value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key under which the secret value is stored in the Kubernetes Secret.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Kubernetes Secret containing the secret value.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecConsumerAuthenticationTlsTrustedCertificates(dict):
    def __init__(__self__, *,
                 certificate: str,
                 secret_name: str):
        """
        :param str certificate: The name of the file certificate in the Secret.
        :param str secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> str:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecConsumerTls(dict):
    """
    TLS configuration for connecting MirrorMaker to the cluster.
    """
    def __init__(__self__, *,
                 trusted_certificates: Optional[Sequence['outputs.KafkaMirrorMakerSpecConsumerTlsTrustedCertificates']] = None):
        """
        TLS configuration for connecting MirrorMaker to the cluster.
        :param Sequence['KafkaMirrorMakerSpecConsumerTlsTrustedCertificatesArgs'] trusted_certificates: Trusted certificates for TLS connection.
        """
        if trusted_certificates is not None:
            pulumi.set(__self__, "trusted_certificates", trusted_certificates)

    @property
    @pulumi.getter(name="trustedCertificates")
    def trusted_certificates(self) -> Optional[Sequence['outputs.KafkaMirrorMakerSpecConsumerTlsTrustedCertificates']]:
        """
        Trusted certificates for TLS connection.
        """
        return pulumi.get(self, "trusted_certificates")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecConsumerTlsTrustedCertificates(dict):
    def __init__(__self__, *,
                 certificate: str,
                 secret_name: str):
        """
        :param str certificate: The name of the file certificate in the Secret.
        :param str secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> str:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecJvmOptions(dict):
    """
    JVM Options for pods.
    """
    def __init__(__self__, *,
                 __xx: Optional[Mapping[str, Any]] = None,
                 __xms: Optional[str] = None,
                 __xmx: Optional[str] = None,
                 gc_logging_enabled: Optional[bool] = None,
                 java_system_properties: Optional[Sequence['outputs.KafkaMirrorMakerSpecJvmOptionsJavaSystemProperties']] = None):
        """
        JVM Options for pods.
        :param Mapping[str, Any] __xx: A map of -XX options to the JVM.
        :param str __xms: -Xms option to to the JVM.
        :param str __xmx: -Xmx option to to the JVM.
        :param bool gc_logging_enabled: Specifies whether the Garbage Collection logging is enabled. The default is false.
        :param Sequence['KafkaMirrorMakerSpecJvmOptionsJavaSystemPropertiesArgs'] java_system_properties: A map of additional system properties which will be passed using the `-D` option to the JVM.
        """
        if __xx is not None:
            pulumi.set(__self__, "__xx", __xx)
        if __xms is not None:
            pulumi.set(__self__, "__xms", __xms)
        if __xmx is not None:
            pulumi.set(__self__, "__xmx", __xmx)
        if gc_logging_enabled is not None:
            pulumi.set(__self__, "gc_logging_enabled", gc_logging_enabled)
        if java_system_properties is not None:
            pulumi.set(__self__, "java_system_properties", java_system_properties)

    @property
    @pulumi.getter(name="-XX")
    def __xx(self) -> Optional[Mapping[str, Any]]:
        """
        A map of -XX options to the JVM.
        """
        return pulumi.get(self, "__xx")

    @property
    @pulumi.getter(name="-Xms")
    def __xms(self) -> Optional[str]:
        """
        -Xms option to to the JVM.
        """
        return pulumi.get(self, "__xms")

    @property
    @pulumi.getter(name="-Xmx")
    def __xmx(self) -> Optional[str]:
        """
        -Xmx option to to the JVM.
        """
        return pulumi.get(self, "__xmx")

    @property
    @pulumi.getter(name="gcLoggingEnabled")
    def gc_logging_enabled(self) -> Optional[bool]:
        """
        Specifies whether the Garbage Collection logging is enabled. The default is false.
        """
        return pulumi.get(self, "gc_logging_enabled")

    @property
    @pulumi.getter(name="javaSystemProperties")
    def java_system_properties(self) -> Optional[Sequence['outputs.KafkaMirrorMakerSpecJvmOptionsJavaSystemProperties']]:
        """
        A map of additional system properties which will be passed using the `-D` option to the JVM.
        """
        return pulumi.get(self, "java_system_properties")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecJvmOptionsJavaSystemProperties(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The system property name.
        :param str value: The system property value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The system property name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The system property value.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecLivenessProbe(dict):
    """
    Pod liveness checking.
    """
    def __init__(__self__, *,
                 failure_threshold: Optional[int] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 timeout_seconds: Optional[int] = None):
        """
        Pod liveness checking.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param int initial_delay_seconds: The initial delay before first the health is first checked.
        :param int period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param int timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecLogging(dict):
    """
    Logging configuration for MirrorMaker.
    """
    def __init__(__self__, *,
                 type: str,
                 loggers: Optional[Mapping[str, Any]] = None,
                 name: Optional[str] = None):
        """
        Logging configuration for MirrorMaker.
        :param str type: Logging type, must be either 'inline' or 'external'.
        :param Mapping[str, Any] loggers: A Map from logger name to logger level.
        :param str name: The name of the `ConfigMap` from which to get the logging configuration.
        """
        pulumi.set(__self__, "type", type)
        if loggers is not None:
            pulumi.set(__self__, "loggers", loggers)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Logging type, must be either 'inline' or 'external'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def loggers(self) -> Optional[Mapping[str, Any]]:
        """
        A Map from logger name to logger level.
        """
        return pulumi.get(self, "loggers")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the `ConfigMap` from which to get the logging configuration.
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecProducer(dict):
    """
    Configuration of target cluster.
    """
    def __init__(__self__, *,
                 bootstrap_servers: str,
                 abort_on_send_failure: Optional[bool] = None,
                 authentication: Optional['outputs.KafkaMirrorMakerSpecProducerAuthentication'] = None,
                 config: Optional[Mapping[str, Any]] = None,
                 tls: Optional['outputs.KafkaMirrorMakerSpecProducerTls'] = None):
        """
        Configuration of target cluster.
        :param str bootstrap_servers: A list of host:port pairs for establishing the initial connection to the Kafka cluster.
        :param bool abort_on_send_failure: Flag to set the MirrorMaker to exit on a failed send. Default value is `true`.
        :param 'KafkaMirrorMakerSpecProducerAuthenticationArgs' authentication: Authentication configuration for connecting to the cluster.
        :param Mapping[str, Any] config: The MirrorMaker producer config. Properties with the following prefixes cannot be set: ssl., bootstrap.servers, sasl., security., interceptor.classes (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
        :param 'KafkaMirrorMakerSpecProducerTlsArgs' tls: TLS configuration for connecting MirrorMaker to the cluster.
        """
        pulumi.set(__self__, "bootstrap_servers", bootstrap_servers)
        if abort_on_send_failure is not None:
            pulumi.set(__self__, "abort_on_send_failure", abort_on_send_failure)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter(name="bootstrapServers")
    def bootstrap_servers(self) -> str:
        """
        A list of host:port pairs for establishing the initial connection to the Kafka cluster.
        """
        return pulumi.get(self, "bootstrap_servers")

    @property
    @pulumi.getter(name="abortOnSendFailure")
    def abort_on_send_failure(self) -> Optional[bool]:
        """
        Flag to set the MirrorMaker to exit on a failed send. Default value is `true`.
        """
        return pulumi.get(self, "abort_on_send_failure")

    @property
    @pulumi.getter
    def authentication(self) -> Optional['outputs.KafkaMirrorMakerSpecProducerAuthentication']:
        """
        Authentication configuration for connecting to the cluster.
        """
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter
    def config(self) -> Optional[Mapping[str, Any]]:
        """
        The MirrorMaker producer config. Properties with the following prefixes cannot be set: ssl., bootstrap.servers, sasl., security., interceptor.classes (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter
    def tls(self) -> Optional['outputs.KafkaMirrorMakerSpecProducerTls']:
        """
        TLS configuration for connecting MirrorMaker to the cluster.
        """
        return pulumi.get(self, "tls")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecProducerAuthentication(dict):
    """
    Authentication configuration for connecting to the cluster.
    """
    def __init__(__self__, *,
                 type: str,
                 access_token: Optional['outputs.KafkaMirrorMakerSpecProducerAuthenticationAccessToken'] = None,
                 access_token_is_jwt: Optional[bool] = None,
                 certificate_and_key: Optional['outputs.KafkaMirrorMakerSpecProducerAuthenticationCertificateAndKey'] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional['outputs.KafkaMirrorMakerSpecProducerAuthenticationClientSecret'] = None,
                 disable_tls_hostname_verification: Optional[bool] = None,
                 max_token_expiry_seconds: Optional[int] = None,
                 password_secret: Optional['outputs.KafkaMirrorMakerSpecProducerAuthenticationPasswordSecret'] = None,
                 refresh_token: Optional['outputs.KafkaMirrorMakerSpecProducerAuthenticationRefreshToken'] = None,
                 scope: Optional[str] = None,
                 tls_trusted_certificates: Optional[Sequence['outputs.KafkaMirrorMakerSpecProducerAuthenticationTlsTrustedCertificates']] = None,
                 token_endpoint_uri: Optional[str] = None,
                 username: Optional[str] = None):
        """
        Authentication configuration for connecting to the cluster.
        :param str type: Authentication type. Currently the only supported types are `tls`, `scram-sha-512`, and `plain`. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
        :param 'KafkaMirrorMakerSpecProducerAuthenticationAccessTokenArgs' access_token: Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
        :param bool access_token_is_jwt: Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
        :param 'KafkaMirrorMakerSpecProducerAuthenticationCertificateAndKeyArgs' certificate_and_key: Reference to the `Secret` which holds the certificate and private key pair.
        :param str client_id: OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        :param 'KafkaMirrorMakerSpecProducerAuthenticationClientSecretArgs' client_secret: Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        :param bool disable_tls_hostname_verification: Enable or disable TLS hostname verification. Default value is `false`.
        :param int max_token_expiry_seconds: Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.
        :param 'KafkaMirrorMakerSpecProducerAuthenticationPasswordSecretArgs' password_secret: Reference to the `Secret` which holds the password.
        :param 'KafkaMirrorMakerSpecProducerAuthenticationRefreshTokenArgs' refresh_token: Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
        :param str scope: OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.
        :param Sequence['KafkaMirrorMakerSpecProducerAuthenticationTlsTrustedCertificatesArgs'] tls_trusted_certificates: Trusted certificates for TLS connection to the OAuth server.
        :param str token_endpoint_uri: Authorization server token endpoint URI.
        :param str username: Username used for the authentication.
        """
        pulumi.set(__self__, "type", type)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if access_token_is_jwt is not None:
            pulumi.set(__self__, "access_token_is_jwt", access_token_is_jwt)
        if certificate_and_key is not None:
            pulumi.set(__self__, "certificate_and_key", certificate_and_key)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if disable_tls_hostname_verification is not None:
            pulumi.set(__self__, "disable_tls_hostname_verification", disable_tls_hostname_verification)
        if max_token_expiry_seconds is not None:
            pulumi.set(__self__, "max_token_expiry_seconds", max_token_expiry_seconds)
        if password_secret is not None:
            pulumi.set(__self__, "password_secret", password_secret)
        if refresh_token is not None:
            pulumi.set(__self__, "refresh_token", refresh_token)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if tls_trusted_certificates is not None:
            pulumi.set(__self__, "tls_trusted_certificates", tls_trusted_certificates)
        if token_endpoint_uri is not None:
            pulumi.set(__self__, "token_endpoint_uri", token_endpoint_uri)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Authentication type. Currently the only supported types are `tls`, `scram-sha-512`, and `plain`. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional['outputs.KafkaMirrorMakerSpecProducerAuthenticationAccessToken']:
        """
        Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="accessTokenIsJwt")
    def access_token_is_jwt(self) -> Optional[bool]:
        """
        Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
        """
        return pulumi.get(self, "access_token_is_jwt")

    @property
    @pulumi.getter(name="certificateAndKey")
    def certificate_and_key(self) -> Optional['outputs.KafkaMirrorMakerSpecProducerAuthenticationCertificateAndKey']:
        """
        Reference to the `Secret` which holds the certificate and private key pair.
        """
        return pulumi.get(self, "certificate_and_key")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional['outputs.KafkaMirrorMakerSpecProducerAuthenticationClientSecret']:
        """
        Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="disableTlsHostnameVerification")
    def disable_tls_hostname_verification(self) -> Optional[bool]:
        """
        Enable or disable TLS hostname verification. Default value is `false`.
        """
        return pulumi.get(self, "disable_tls_hostname_verification")

    @property
    @pulumi.getter(name="maxTokenExpirySeconds")
    def max_token_expiry_seconds(self) -> Optional[int]:
        """
        Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.
        """
        return pulumi.get(self, "max_token_expiry_seconds")

    @property
    @pulumi.getter(name="passwordSecret")
    def password_secret(self) -> Optional['outputs.KafkaMirrorMakerSpecProducerAuthenticationPasswordSecret']:
        """
        Reference to the `Secret` which holds the password.
        """
        return pulumi.get(self, "password_secret")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional['outputs.KafkaMirrorMakerSpecProducerAuthenticationRefreshToken']:
        """
        Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
        """
        return pulumi.get(self, "refresh_token")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter(name="tlsTrustedCertificates")
    def tls_trusted_certificates(self) -> Optional[Sequence['outputs.KafkaMirrorMakerSpecProducerAuthenticationTlsTrustedCertificates']]:
        """
        Trusted certificates for TLS connection to the OAuth server.
        """
        return pulumi.get(self, "tls_trusted_certificates")

    @property
    @pulumi.getter(name="tokenEndpointUri")
    def token_endpoint_uri(self) -> Optional[str]:
        """
        Authorization server token endpoint URI.
        """
        return pulumi.get(self, "token_endpoint_uri")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username used for the authentication.
        """
        return pulumi.get(self, "username")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecProducerAuthenticationAccessToken(dict):
    """
    Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
    """
    def __init__(__self__, *,
                 key: str,
                 secret_name: str):
        """
        Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
        :param str key: The key under which the secret value is stored in the Kubernetes Secret.
        :param str secret_name: The name of the Kubernetes Secret containing the secret value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key under which the secret value is stored in the Kubernetes Secret.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Kubernetes Secret containing the secret value.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecProducerAuthenticationCertificateAndKey(dict):
    """
    Reference to the `Secret` which holds the certificate and private key pair.
    """
    def __init__(__self__, *,
                 certificate: str,
                 key: str,
                 secret_name: str):
        """
        Reference to the `Secret` which holds the certificate and private key pair.
        :param str certificate: The name of the file certificate in the Secret.
        :param str key: The name of the private key in the Secret.
        :param str secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> str:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The name of the private key in the Secret.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecProducerAuthenticationClientSecret(dict):
    """
    Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
    """
    def __init__(__self__, *,
                 key: str,
                 secret_name: str):
        """
        Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        :param str key: The key under which the secret value is stored in the Kubernetes Secret.
        :param str secret_name: The name of the Kubernetes Secret containing the secret value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key under which the secret value is stored in the Kubernetes Secret.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Kubernetes Secret containing the secret value.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecProducerAuthenticationPasswordSecret(dict):
    """
    Reference to the `Secret` which holds the password.
    """
    def __init__(__self__, *,
                 password: str,
                 secret_name: str):
        """
        Reference to the `Secret` which holds the password.
        :param str password: The name of the key in the Secret under which the password is stored.
        :param str secret_name: The name of the Secret containing the password.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The name of the key in the Secret under which the password is stored.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Secret containing the password.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecProducerAuthenticationRefreshToken(dict):
    """
    Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
    """
    def __init__(__self__, *,
                 key: str,
                 secret_name: str):
        """
        Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
        :param str key: The key under which the secret value is stored in the Kubernetes Secret.
        :param str secret_name: The name of the Kubernetes Secret containing the secret value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key under which the secret value is stored in the Kubernetes Secret.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Kubernetes Secret containing the secret value.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecProducerAuthenticationTlsTrustedCertificates(dict):
    def __init__(__self__, *,
                 certificate: str,
                 secret_name: str):
        """
        :param str certificate: The name of the file certificate in the Secret.
        :param str secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> str:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecProducerTls(dict):
    """
    TLS configuration for connecting MirrorMaker to the cluster.
    """
    def __init__(__self__, *,
                 trusted_certificates: Optional[Sequence['outputs.KafkaMirrorMakerSpecProducerTlsTrustedCertificates']] = None):
        """
        TLS configuration for connecting MirrorMaker to the cluster.
        :param Sequence['KafkaMirrorMakerSpecProducerTlsTrustedCertificatesArgs'] trusted_certificates: Trusted certificates for TLS connection.
        """
        if trusted_certificates is not None:
            pulumi.set(__self__, "trusted_certificates", trusted_certificates)

    @property
    @pulumi.getter(name="trustedCertificates")
    def trusted_certificates(self) -> Optional[Sequence['outputs.KafkaMirrorMakerSpecProducerTlsTrustedCertificates']]:
        """
        Trusted certificates for TLS connection.
        """
        return pulumi.get(self, "trusted_certificates")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecProducerTlsTrustedCertificates(dict):
    def __init__(__self__, *,
                 certificate: str,
                 secret_name: str):
        """
        :param str certificate: The name of the file certificate in the Secret.
        :param str secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> str:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecReadinessProbe(dict):
    """
    Pod readiness checking.
    """
    def __init__(__self__, *,
                 failure_threshold: Optional[int] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 timeout_seconds: Optional[int] = None):
        """
        Pod readiness checking.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param int initial_delay_seconds: The initial delay before first the health is first checked.
        :param int period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param int timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecResources(dict):
    """
    CPU and memory resources to reserve.
    """
    def __init__(__self__, *,
                 limits: Optional[Mapping[str, Any]] = None,
                 requests: Optional[Mapping[str, Any]] = None):
        """
        CPU and memory resources to reserve.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "requests")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplate(dict):
    """
    Template to specify how Kafka MirrorMaker resources, `Deployments` and `Pods`, are generated.
    """
    def __init__(__self__, *,
                 deployment: Optional['outputs.KafkaMirrorMakerSpecTemplateDeployment'] = None,
                 mirror_maker_container: Optional['outputs.KafkaMirrorMakerSpecTemplateMirrorMakerContainer'] = None,
                 pod: Optional['outputs.KafkaMirrorMakerSpecTemplatePod'] = None,
                 pod_disruption_budget: Optional['outputs.KafkaMirrorMakerSpecTemplatePodDisruptionBudget'] = None):
        """
        Template to specify how Kafka MirrorMaker resources, `Deployments` and `Pods`, are generated.
        :param 'KafkaMirrorMakerSpecTemplateDeploymentArgs' deployment: Template for Kafka MirrorMaker `Deployment`.
        :param 'KafkaMirrorMakerSpecTemplateMirrorMakerContainerArgs' mirror_maker_container: Template for Kafka MirrorMaker container.
        :param 'KafkaMirrorMakerSpecTemplatePodArgs' pod: Template for Kafka MirrorMaker `Pods`.
        :param 'KafkaMirrorMakerSpecTemplatePodDisruptionBudgetArgs' pod_disruption_budget: Template for Kafka MirrorMaker `PodDisruptionBudget`.
        """
        if deployment is not None:
            pulumi.set(__self__, "deployment", deployment)
        if mirror_maker_container is not None:
            pulumi.set(__self__, "mirror_maker_container", mirror_maker_container)
        if pod is not None:
            pulumi.set(__self__, "pod", pod)
        if pod_disruption_budget is not None:
            pulumi.set(__self__, "pod_disruption_budget", pod_disruption_budget)

    @property
    @pulumi.getter
    def deployment(self) -> Optional['outputs.KafkaMirrorMakerSpecTemplateDeployment']:
        """
        Template for Kafka MirrorMaker `Deployment`.
        """
        return pulumi.get(self, "deployment")

    @property
    @pulumi.getter(name="mirrorMakerContainer")
    def mirror_maker_container(self) -> Optional['outputs.KafkaMirrorMakerSpecTemplateMirrorMakerContainer']:
        """
        Template for Kafka MirrorMaker container.
        """
        return pulumi.get(self, "mirror_maker_container")

    @property
    @pulumi.getter
    def pod(self) -> Optional['outputs.KafkaMirrorMakerSpecTemplatePod']:
        """
        Template for Kafka MirrorMaker `Pods`.
        """
        return pulumi.get(self, "pod")

    @property
    @pulumi.getter(name="podDisruptionBudget")
    def pod_disruption_budget(self) -> Optional['outputs.KafkaMirrorMakerSpecTemplatePodDisruptionBudget']:
        """
        Template for Kafka MirrorMaker `PodDisruptionBudget`.
        """
        return pulumi.get(self, "pod_disruption_budget")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplateDeployment(dict):
    """
    Template for Kafka MirrorMaker `Deployment`.
    """
    def __init__(__self__, *,
                 metadata: Optional['outputs.KafkaMirrorMakerSpecTemplateDeploymentMetadata'] = None):
        """
        Template for Kafka MirrorMaker `Deployment`.
        :param 'KafkaMirrorMakerSpecTemplateDeploymentMetadataArgs' metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaMirrorMakerSpecTemplateDeploymentMetadata']:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplateDeploymentMetadata(dict):
    """
    Metadata applied to the resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata applied to the resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplateMirrorMakerContainer(dict):
    """
    Template for Kafka MirrorMaker container.
    """
    def __init__(__self__, *,
                 env: Optional[Sequence['outputs.KafkaMirrorMakerSpecTemplateMirrorMakerContainerEnv']] = None,
                 security_context: Optional['outputs.KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContext'] = None):
        """
        Template for Kafka MirrorMaker container.
        :param Sequence['KafkaMirrorMakerSpecTemplateMirrorMakerContainerEnvArgs'] env: Environment variables which should be applied to the container.
        :param 'KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextArgs' security_context: Security context for the container.
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)

    @property
    @pulumi.getter
    def env(self) -> Optional[Sequence['outputs.KafkaMirrorMakerSpecTemplateMirrorMakerContainerEnv']]:
        """
        Environment variables which should be applied to the container.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional['outputs.KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContext']:
        """
        Security context for the container.
        """
        return pulumi.get(self, "security_context")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplateMirrorMakerContainerEnv(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The environment variable key.
        :param str value: The environment variable value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The environment variable key.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The environment variable value.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContext(dict):
    """
    Security context for the container.
    """
    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[bool] = None,
                 capabilities: Optional['outputs.KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextCapabilities'] = None,
                 privileged: Optional[bool] = None,
                 proc_mount: Optional[str] = None,
                 read_only_root_filesystem: Optional[bool] = None,
                 run_as_group: Optional[int] = None,
                 run_as_non_root: Optional[bool] = None,
                 run_as_user: Optional[int] = None,
                 se_linux_options: Optional['outputs.KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextSeLinuxOptions'] = None,
                 windows_options: Optional['outputs.KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextWindowsOptions'] = None):
        """
        Security context for the container.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if proc_mount is not None:
            pulumi.set(__self__, "proc_mount", proc_mount)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[bool]:
        return pulumi.get(self, "allow_privilege_escalation")

    @property
    @pulumi.getter
    def capabilities(self) -> Optional['outputs.KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextCapabilities']:
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def privileged(self) -> Optional[bool]:
        return pulumi.get(self, "privileged")

    @property
    @pulumi.getter(name="procMount")
    def proc_mount(self) -> Optional[str]:
        return pulumi.get(self, "proc_mount")

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[bool]:
        return pulumi.get(self, "read_only_root_filesystem")

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[int]:
        return pulumi.get(self, "run_as_group")

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[bool]:
        return pulumi.get(self, "run_as_non_root")

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[int]:
        return pulumi.get(self, "run_as_user")

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional['outputs.KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextSeLinuxOptions']:
        return pulumi.get(self, "se_linux_options")

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional['outputs.KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextWindowsOptions']:
        return pulumi.get(self, "windows_options")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextCapabilities(dict):
    def __init__(__self__, *,
                 add: Optional[Sequence[str]] = None,
                 drop: Optional[Sequence[str]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)

    @property
    @pulumi.getter
    def add(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def drop(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "drop")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextSeLinuxOptions(dict):
    def __init__(__self__, *,
                 level: Optional[str] = None,
                 role: Optional[str] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        return pulumi.get(self, "user")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextWindowsOptions(dict):
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[str] = None,
                 gmsa_credential_spec_name: Optional[str] = None,
                 run_as_user_name: Optional[str] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec")

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[str]:
        return pulumi.get(self, "run_as_user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplatePod(dict):
    """
    Template for Kafka MirrorMaker `Pods`.
    """
    def __init__(__self__, *,
                 affinity: Optional['outputs.KafkaMirrorMakerSpecTemplatePodAffinity'] = None,
                 host_aliases: Optional[Sequence['outputs.KafkaMirrorMakerSpecTemplatePodHostAliases']] = None,
                 image_pull_secrets: Optional[Sequence['outputs.KafkaMirrorMakerSpecTemplatePodImagePullSecrets']] = None,
                 metadata: Optional['outputs.KafkaMirrorMakerSpecTemplatePodMetadata'] = None,
                 priority_class_name: Optional[str] = None,
                 scheduler_name: Optional[str] = None,
                 security_context: Optional['outputs.KafkaMirrorMakerSpecTemplatePodSecurityContext'] = None,
                 termination_grace_period_seconds: Optional[int] = None,
                 tolerations: Optional[Sequence['outputs.KafkaMirrorMakerSpecTemplatePodTolerations']] = None):
        """
        Template for Kafka MirrorMaker `Pods`.
        :param 'KafkaMirrorMakerSpecTemplatePodAffinityArgs' affinity: The pod's affinity rules.
        :param Sequence['KafkaMirrorMakerSpecTemplatePodHostAliasesArgs'] host_aliases: The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
        :param Sequence['KafkaMirrorMakerSpecTemplatePodImagePullSecretsArgs'] image_pull_secrets: List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
        :param 'KafkaMirrorMakerSpecTemplatePodMetadataArgs' metadata: Metadata applied to the resource.
        :param str priority_class_name: The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
        :param str scheduler_name: The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
        :param 'KafkaMirrorMakerSpecTemplatePodSecurityContextArgs' security_context: Configures pod-level security attributes and common container settings.
        :param int termination_grace_period_seconds: The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
        :param Sequence['KafkaMirrorMakerSpecTemplatePodTolerationsArgs'] tolerations: The pod's tolerations.
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if host_aliases is not None:
            pulumi.set(__self__, "host_aliases", host_aliases)
        if image_pull_secrets is not None:
            pulumi.set(__self__, "image_pull_secrets", image_pull_secrets)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if priority_class_name is not None:
            pulumi.set(__self__, "priority_class_name", priority_class_name)
        if scheduler_name is not None:
            pulumi.set(__self__, "scheduler_name", scheduler_name)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)

    @property
    @pulumi.getter
    def affinity(self) -> Optional['outputs.KafkaMirrorMakerSpecTemplatePodAffinity']:
        """
        The pod's affinity rules.
        """
        return pulumi.get(self, "affinity")

    @property
    @pulumi.getter(name="hostAliases")
    def host_aliases(self) -> Optional[Sequence['outputs.KafkaMirrorMakerSpecTemplatePodHostAliases']]:
        """
        The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
        """
        return pulumi.get(self, "host_aliases")

    @property
    @pulumi.getter(name="imagePullSecrets")
    def image_pull_secrets(self) -> Optional[Sequence['outputs.KafkaMirrorMakerSpecTemplatePodImagePullSecrets']]:
        """
        List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
        """
        return pulumi.get(self, "image_pull_secrets")

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaMirrorMakerSpecTemplatePodMetadata']:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter(name="priorityClassName")
    def priority_class_name(self) -> Optional[str]:
        """
        The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
        """
        return pulumi.get(self, "priority_class_name")

    @property
    @pulumi.getter(name="schedulerName")
    def scheduler_name(self) -> Optional[str]:
        """
        The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
        """
        return pulumi.get(self, "scheduler_name")

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional['outputs.KafkaMirrorMakerSpecTemplatePodSecurityContext']:
        """
        Configures pod-level security attributes and common container settings.
        """
        return pulumi.get(self, "security_context")

    @property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[int]:
        """
        The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
        """
        return pulumi.get(self, "termination_grace_period_seconds")

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[Sequence['outputs.KafkaMirrorMakerSpecTemplatePodTolerations']]:
        """
        The pod's tolerations.
        """
        return pulumi.get(self, "tolerations")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplatePodAffinity(dict):
    """
    The pod's affinity rules.
    """
    def __init__(__self__, *,
                 node_affinity: Optional['outputs.KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinity'] = None,
                 pod_affinity: Optional['outputs.KafkaMirrorMakerSpecTemplatePodAffinityPodAffinity'] = None,
                 pod_anti_affinity: Optional['outputs.KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinity'] = None):
        """
        The pod's affinity rules.
        """
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional['outputs.KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinity']:
        return pulumi.get(self, "node_affinity")

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional['outputs.KafkaMirrorMakerSpecTemplatePodAffinityPodAffinity']:
        return pulumi.get(self, "pod_affinity")

    @property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional['outputs.KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinity']:
        return pulumi.get(self, "pod_anti_affinity")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional['outputs.KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution'] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional['outputs.KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution']:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 preference: Optional['outputs.KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference'] = None,
                 weight: Optional[int] = None):
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preference(self) -> Optional['outputs.KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference']:
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions']] = None,
                 match_fields: Optional[Sequence['outputs.KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields']] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields']]:
        return pulumi.get(self, "match_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 node_selector_terms: Optional[Sequence['outputs.KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms']] = None):
        if node_selector_terms is not None:
            pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> Optional[Sequence['outputs.KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms']]:
        return pulumi.get(self, "node_selector_terms")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions']] = None,
                 match_fields: Optional[Sequence['outputs.KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields']] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields']]:
        return pulumi.get(self, "match_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplatePodAffinityPodAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 pod_affinity_term: Optional['outputs.KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm'] = None,
                 weight: Optional[int] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional['outputs.KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm']:
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 pod_affinity_term: Optional['outputs.KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm'] = None,
                 weight: Optional[int] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional['outputs.KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm']:
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplatePodDisruptionBudget(dict):
    """
    Template for Kafka MirrorMaker `PodDisruptionBudget`.
    """
    def __init__(__self__, *,
                 max_unavailable: Optional[int] = None,
                 metadata: Optional['outputs.KafkaMirrorMakerSpecTemplatePodDisruptionBudgetMetadata'] = None):
        """
        Template for Kafka MirrorMaker `PodDisruptionBudget`.
        :param int max_unavailable: Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
        :param 'KafkaMirrorMakerSpecTemplatePodDisruptionBudgetMetadataArgs' metadata: Metadata to apply to the `PodDistruptionBugetTemplate` resource.
        """
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[int]:
        """
        Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
        """
        return pulumi.get(self, "max_unavailable")

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaMirrorMakerSpecTemplatePodDisruptionBudgetMetadata']:
        """
        Metadata to apply to the `PodDistruptionBugetTemplate` resource.
        """
        return pulumi.get(self, "metadata")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplatePodDisruptionBudgetMetadata(dict):
    """
    Metadata to apply to the `PodDistruptionBugetTemplate` resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata to apply to the `PodDistruptionBugetTemplate` resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplatePodHostAliases(dict):
    def __init__(__self__, *,
                 hostnames: Optional[Sequence[str]] = None,
                 ip: Optional[str] = None):
        if hostnames is not None:
            pulumi.set(__self__, "hostnames", hostnames)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def hostnames(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "hostnames")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        return pulumi.get(self, "ip")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplatePodImagePullSecrets(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplatePodMetadata(dict):
    """
    Metadata applied to the resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata applied to the resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplatePodSecurityContext(dict):
    """
    Configures pod-level security attributes and common container settings.
    """
    def __init__(__self__, *,
                 fs_group: Optional[int] = None,
                 fs_group_change_policy: Optional[str] = None,
                 run_as_group: Optional[int] = None,
                 run_as_non_root: Optional[bool] = None,
                 run_as_user: Optional[int] = None,
                 se_linux_options: Optional['outputs.KafkaMirrorMakerSpecTemplatePodSecurityContextSeLinuxOptions'] = None,
                 supplemental_groups: Optional[Sequence[int]] = None,
                 sysctls: Optional[Sequence['outputs.KafkaMirrorMakerSpecTemplatePodSecurityContextSysctls']] = None,
                 windows_options: Optional['outputs.KafkaMirrorMakerSpecTemplatePodSecurityContextWindowsOptions'] = None):
        """
        Configures pod-level security attributes and common container settings.
        """
        if fs_group is not None:
            pulumi.set(__self__, "fs_group", fs_group)
        if fs_group_change_policy is not None:
            pulumi.set(__self__, "fs_group_change_policy", fs_group_change_policy)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if supplemental_groups is not None:
            pulumi.set(__self__, "supplemental_groups", supplemental_groups)
        if sysctls is not None:
            pulumi.set(__self__, "sysctls", sysctls)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="fsGroup")
    def fs_group(self) -> Optional[int]:
        return pulumi.get(self, "fs_group")

    @property
    @pulumi.getter(name="fsGroupChangePolicy")
    def fs_group_change_policy(self) -> Optional[str]:
        return pulumi.get(self, "fs_group_change_policy")

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[int]:
        return pulumi.get(self, "run_as_group")

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[bool]:
        return pulumi.get(self, "run_as_non_root")

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[int]:
        return pulumi.get(self, "run_as_user")

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional['outputs.KafkaMirrorMakerSpecTemplatePodSecurityContextSeLinuxOptions']:
        return pulumi.get(self, "se_linux_options")

    @property
    @pulumi.getter(name="supplementalGroups")
    def supplemental_groups(self) -> Optional[Sequence[int]]:
        return pulumi.get(self, "supplemental_groups")

    @property
    @pulumi.getter
    def sysctls(self) -> Optional[Sequence['outputs.KafkaMirrorMakerSpecTemplatePodSecurityContextSysctls']]:
        return pulumi.get(self, "sysctls")

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional['outputs.KafkaMirrorMakerSpecTemplatePodSecurityContextWindowsOptions']:
        return pulumi.get(self, "windows_options")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplatePodSecurityContextSeLinuxOptions(dict):
    def __init__(__self__, *,
                 level: Optional[str] = None,
                 role: Optional[str] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        return pulumi.get(self, "user")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplatePodSecurityContextSysctls(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplatePodSecurityContextWindowsOptions(dict):
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[str] = None,
                 gmsa_credential_spec_name: Optional[str] = None,
                 run_as_user_name: Optional[str] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec")

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[str]:
        return pulumi.get(self, "run_as_user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTemplatePodTolerations(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 toleration_seconds: Optional[int] = None,
                 value: Optional[str] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if toleration_seconds is not None:
            pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> Optional[int]:
        return pulumi.get(self, "toleration_seconds")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTolerations(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 toleration_seconds: Optional[int] = None,
                 value: Optional[str] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if toleration_seconds is not None:
            pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> Optional[int]:
        return pulumi.get(self, "toleration_seconds")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerSpecTracing(dict):
    """
    The configuration of tracing in Kafka MirrorMaker.
    """
    def __init__(__self__, *,
                 type: str):
        """
        The configuration of tracing in Kafka MirrorMaker.
        :param str type: Type of the tracing used. Currently the only supported type is `jaeger` for Jaeger tracing.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the tracing used. Currently the only supported type is `jaeger` for Jaeger tracing.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerStatus(dict):
    """
    The status of Kafka MirrorMaker.
    """
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.KafkaMirrorMakerStatusConditions']] = None,
                 label_selector: Optional[str] = None,
                 observed_generation: Optional[int] = None,
                 replicas: Optional[int] = None):
        """
        The status of Kafka MirrorMaker.
        :param Sequence['KafkaMirrorMakerStatusConditionsArgs'] conditions: List of status conditions.
        :param str label_selector: Label selector for pods providing this resource.
        :param int observed_generation: The generation of the CRD that was last reconciled by the operator.
        :param int replicas: The current number of pods being used to provide this resource.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.KafkaMirrorMakerStatusConditions']]:
        """
        List of status conditions.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional[str]:
        """
        Label selector for pods providing this resource.
        """
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[int]:
        """
        The generation of the CRD that was last reconciled by the operator.
        """
        return pulumi.get(self, "observed_generation")

    @property
    @pulumi.getter
    def replicas(self) -> Optional[int]:
        """
        The current number of pods being used to provide this resource.
        """
        return pulumi.get(self, "replicas")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaMirrorMakerStatusConditions(dict):
    def __init__(__self__, *,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None,
                 status: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str last_transition_time: Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
        :param str message: Human-readable message indicating details about the condition's last transition.
        :param str reason: The reason for the condition's last transition (a single word in CamelCase).
        :param str status: The status of the condition, either True, False or Unknown.
        :param str type: The unique identifier of a condition, used to distinguish between other conditions in the resource.
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Human-readable message indicating details about the condition's last transition.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        The reason for the condition's last transition (a single word in CamelCase).
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The status of the condition, either True, False or Unknown.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The unique identifier of a condition, used to distinguish between other conditions in the resource.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpec(dict):
    """
    The specification of the Kafka and ZooKeeper clusters, and Topic Operator.
    """
    def __init__(__self__, *,
                 kafka: 'outputs.KafkaSpecKafka',
                 zookeeper: 'outputs.KafkaSpecZookeeper',
                 clients_ca: Optional['outputs.KafkaSpecClientsCa'] = None,
                 cluster_ca: Optional['outputs.KafkaSpecClusterCa'] = None,
                 cruise_control: Optional['outputs.KafkaSpecCruiseControl'] = None,
                 entity_operator: Optional['outputs.KafkaSpecEntityOperator'] = None,
                 jmx_trans: Optional['outputs.KafkaSpecJmxTrans'] = None,
                 kafka_exporter: Optional['outputs.KafkaSpecKafkaExporter'] = None,
                 maintenance_time_windows: Optional[Sequence[str]] = None,
                 topic_operator: Optional['outputs.KafkaSpecTopicOperator'] = None):
        """
        The specification of the Kafka and ZooKeeper clusters, and Topic Operator.
        :param 'KafkaSpecKafkaArgs' kafka: Configuration of the Kafka cluster.
        :param 'KafkaSpecZookeeperArgs' zookeeper: Configuration of the ZooKeeper cluster.
        :param 'KafkaSpecClientsCaArgs' clients_ca: Configuration of the clients certificate authority.
        :param 'KafkaSpecClusterCaArgs' cluster_ca: Configuration of the cluster certificate authority.
        :param 'KafkaSpecCruiseControlArgs' cruise_control: Configuration for Cruise Control deployment. Deploys a Cruise Control instance when specified.
        :param 'KafkaSpecEntityOperatorArgs' entity_operator: Configuration of the Entity Operator.
        :param 'KafkaSpecJmxTransArgs' jmx_trans: Configuration for JmxTrans. When the property is present a JmxTrans deployment is created for gathering JMX metrics from each Kafka broker. For more information see https://github.com/jmxtrans/jmxtrans[JmxTrans GitHub].
        :param 'KafkaSpecKafkaExporterArgs' kafka_exporter: Configuration of the Kafka Exporter. Kafka Exporter can provide additional metrics, for example lag of consumer group at topic/partition.
        :param Sequence[str] maintenance_time_windows: A list of time windows for maintenance tasks (that is, certificates renewal). Each time window is defined by a cron expression.
        :param 'KafkaSpecTopicOperatorArgs' topic_operator: Configuration of the Topic Operator.
        """
        pulumi.set(__self__, "kafka", kafka)
        pulumi.set(__self__, "zookeeper", zookeeper)
        if clients_ca is not None:
            pulumi.set(__self__, "clients_ca", clients_ca)
        if cluster_ca is not None:
            pulumi.set(__self__, "cluster_ca", cluster_ca)
        if cruise_control is not None:
            pulumi.set(__self__, "cruise_control", cruise_control)
        if entity_operator is not None:
            pulumi.set(__self__, "entity_operator", entity_operator)
        if jmx_trans is not None:
            pulumi.set(__self__, "jmx_trans", jmx_trans)
        if kafka_exporter is not None:
            pulumi.set(__self__, "kafka_exporter", kafka_exporter)
        if maintenance_time_windows is not None:
            pulumi.set(__self__, "maintenance_time_windows", maintenance_time_windows)
        if topic_operator is not None:
            pulumi.set(__self__, "topic_operator", topic_operator)

    @property
    @pulumi.getter
    def kafka(self) -> 'outputs.KafkaSpecKafka':
        """
        Configuration of the Kafka cluster.
        """
        return pulumi.get(self, "kafka")

    @property
    @pulumi.getter
    def zookeeper(self) -> 'outputs.KafkaSpecZookeeper':
        """
        Configuration of the ZooKeeper cluster.
        """
        return pulumi.get(self, "zookeeper")

    @property
    @pulumi.getter(name="clientsCa")
    def clients_ca(self) -> Optional['outputs.KafkaSpecClientsCa']:
        """
        Configuration of the clients certificate authority.
        """
        return pulumi.get(self, "clients_ca")

    @property
    @pulumi.getter(name="clusterCa")
    def cluster_ca(self) -> Optional['outputs.KafkaSpecClusterCa']:
        """
        Configuration of the cluster certificate authority.
        """
        return pulumi.get(self, "cluster_ca")

    @property
    @pulumi.getter(name="cruiseControl")
    def cruise_control(self) -> Optional['outputs.KafkaSpecCruiseControl']:
        """
        Configuration for Cruise Control deployment. Deploys a Cruise Control instance when specified.
        """
        return pulumi.get(self, "cruise_control")

    @property
    @pulumi.getter(name="entityOperator")
    def entity_operator(self) -> Optional['outputs.KafkaSpecEntityOperator']:
        """
        Configuration of the Entity Operator.
        """
        return pulumi.get(self, "entity_operator")

    @property
    @pulumi.getter(name="jmxTrans")
    def jmx_trans(self) -> Optional['outputs.KafkaSpecJmxTrans']:
        """
        Configuration for JmxTrans. When the property is present a JmxTrans deployment is created for gathering JMX metrics from each Kafka broker. For more information see https://github.com/jmxtrans/jmxtrans[JmxTrans GitHub].
        """
        return pulumi.get(self, "jmx_trans")

    @property
    @pulumi.getter(name="kafkaExporter")
    def kafka_exporter(self) -> Optional['outputs.KafkaSpecKafkaExporter']:
        """
        Configuration of the Kafka Exporter. Kafka Exporter can provide additional metrics, for example lag of consumer group at topic/partition.
        """
        return pulumi.get(self, "kafka_exporter")

    @property
    @pulumi.getter(name="maintenanceTimeWindows")
    def maintenance_time_windows(self) -> Optional[Sequence[str]]:
        """
        A list of time windows for maintenance tasks (that is, certificates renewal). Each time window is defined by a cron expression.
        """
        return pulumi.get(self, "maintenance_time_windows")

    @property
    @pulumi.getter(name="topicOperator")
    def topic_operator(self) -> Optional['outputs.KafkaSpecTopicOperator']:
        """
        Configuration of the Topic Operator.
        """
        return pulumi.get(self, "topic_operator")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecClientsCa(dict):
    """
    Configuration of the clients certificate authority.
    """
    def __init__(__self__, *,
                 certificate_expiration_policy: Optional[str] = None,
                 generate_certificate_authority: Optional[bool] = None,
                 renewal_days: Optional[int] = None,
                 validity_days: Optional[int] = None):
        """
        Configuration of the clients certificate authority.
        :param str certificate_expiration_policy: How should CA certificate expiration be handled when `generateCertificateAuthority=true`. The default is for a new CA certificate to be generated reusing the existing private key.
        :param bool generate_certificate_authority: If true then Certificate Authority certificates will be generated automatically. Otherwise the user will need to provide a Secret with the CA certificate. Default is true.
        :param int renewal_days: The number of days in the certificate renewal period. This is the number of days before the a certificate expires during which renewal actions may be performed. When `generateCertificateAuthority` is true, this will cause the generation of a new certificate. When `generateCertificateAuthority` is true, this will cause extra logging at WARN level about the pending certificate expiry. Default is 30.
        :param int validity_days: The number of days generated certificates should be valid for. The default is 365.
        """
        if certificate_expiration_policy is not None:
            pulumi.set(__self__, "certificate_expiration_policy", certificate_expiration_policy)
        if generate_certificate_authority is not None:
            pulumi.set(__self__, "generate_certificate_authority", generate_certificate_authority)
        if renewal_days is not None:
            pulumi.set(__self__, "renewal_days", renewal_days)
        if validity_days is not None:
            pulumi.set(__self__, "validity_days", validity_days)

    @property
    @pulumi.getter(name="certificateExpirationPolicy")
    def certificate_expiration_policy(self) -> Optional[str]:
        """
        How should CA certificate expiration be handled when `generateCertificateAuthority=true`. The default is for a new CA certificate to be generated reusing the existing private key.
        """
        return pulumi.get(self, "certificate_expiration_policy")

    @property
    @pulumi.getter(name="generateCertificateAuthority")
    def generate_certificate_authority(self) -> Optional[bool]:
        """
        If true then Certificate Authority certificates will be generated automatically. Otherwise the user will need to provide a Secret with the CA certificate. Default is true.
        """
        return pulumi.get(self, "generate_certificate_authority")

    @property
    @pulumi.getter(name="renewalDays")
    def renewal_days(self) -> Optional[int]:
        """
        The number of days in the certificate renewal period. This is the number of days before the a certificate expires during which renewal actions may be performed. When `generateCertificateAuthority` is true, this will cause the generation of a new certificate. When `generateCertificateAuthority` is true, this will cause extra logging at WARN level about the pending certificate expiry. Default is 30.
        """
        return pulumi.get(self, "renewal_days")

    @property
    @pulumi.getter(name="validityDays")
    def validity_days(self) -> Optional[int]:
        """
        The number of days generated certificates should be valid for. The default is 365.
        """
        return pulumi.get(self, "validity_days")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecClusterCa(dict):
    """
    Configuration of the cluster certificate authority.
    """
    def __init__(__self__, *,
                 certificate_expiration_policy: Optional[str] = None,
                 generate_certificate_authority: Optional[bool] = None,
                 renewal_days: Optional[int] = None,
                 validity_days: Optional[int] = None):
        """
        Configuration of the cluster certificate authority.
        :param str certificate_expiration_policy: How should CA certificate expiration be handled when `generateCertificateAuthority=true`. The default is for a new CA certificate to be generated reusing the existing private key.
        :param bool generate_certificate_authority: If true then Certificate Authority certificates will be generated automatically. Otherwise the user will need to provide a Secret with the CA certificate. Default is true.
        :param int renewal_days: The number of days in the certificate renewal period. This is the number of days before the a certificate expires during which renewal actions may be performed. When `generateCertificateAuthority` is true, this will cause the generation of a new certificate. When `generateCertificateAuthority` is true, this will cause extra logging at WARN level about the pending certificate expiry. Default is 30.
        :param int validity_days: The number of days generated certificates should be valid for. The default is 365.
        """
        if certificate_expiration_policy is not None:
            pulumi.set(__self__, "certificate_expiration_policy", certificate_expiration_policy)
        if generate_certificate_authority is not None:
            pulumi.set(__self__, "generate_certificate_authority", generate_certificate_authority)
        if renewal_days is not None:
            pulumi.set(__self__, "renewal_days", renewal_days)
        if validity_days is not None:
            pulumi.set(__self__, "validity_days", validity_days)

    @property
    @pulumi.getter(name="certificateExpirationPolicy")
    def certificate_expiration_policy(self) -> Optional[str]:
        """
        How should CA certificate expiration be handled when `generateCertificateAuthority=true`. The default is for a new CA certificate to be generated reusing the existing private key.
        """
        return pulumi.get(self, "certificate_expiration_policy")

    @property
    @pulumi.getter(name="generateCertificateAuthority")
    def generate_certificate_authority(self) -> Optional[bool]:
        """
        If true then Certificate Authority certificates will be generated automatically. Otherwise the user will need to provide a Secret with the CA certificate. Default is true.
        """
        return pulumi.get(self, "generate_certificate_authority")

    @property
    @pulumi.getter(name="renewalDays")
    def renewal_days(self) -> Optional[int]:
        """
        The number of days in the certificate renewal period. This is the number of days before the a certificate expires during which renewal actions may be performed. When `generateCertificateAuthority` is true, this will cause the generation of a new certificate. When `generateCertificateAuthority` is true, this will cause extra logging at WARN level about the pending certificate expiry. Default is 30.
        """
        return pulumi.get(self, "renewal_days")

    @property
    @pulumi.getter(name="validityDays")
    def validity_days(self) -> Optional[int]:
        """
        The number of days generated certificates should be valid for. The default is 365.
        """
        return pulumi.get(self, "validity_days")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControl(dict):
    """
    Configuration for Cruise Control deployment. Deploys a Cruise Control instance when specified.
    """
    def __init__(__self__, *,
                 broker_capacity: Optional['outputs.KafkaSpecCruiseControlBrokerCapacity'] = None,
                 config: Optional[Mapping[str, Any]] = None,
                 image: Optional[str] = None,
                 jvm_options: Optional['outputs.KafkaSpecCruiseControlJvmOptions'] = None,
                 liveness_probe: Optional['outputs.KafkaSpecCruiseControlLivenessProbe'] = None,
                 logging: Optional['outputs.KafkaSpecCruiseControlLogging'] = None,
                 metrics: Optional[Mapping[str, Any]] = None,
                 readiness_probe: Optional['outputs.KafkaSpecCruiseControlReadinessProbe'] = None,
                 resources: Optional['outputs.KafkaSpecCruiseControlResources'] = None,
                 template: Optional['outputs.KafkaSpecCruiseControlTemplate'] = None,
                 tls_sidecar: Optional['outputs.KafkaSpecCruiseControlTlsSidecar'] = None):
        """
        Configuration for Cruise Control deployment. Deploys a Cruise Control instance when specified.
        :param 'KafkaSpecCruiseControlBrokerCapacityArgs' broker_capacity: The Cruise Control `brokerCapacity` configuration.
        :param Mapping[str, Any] config: The Cruise Control configuration. For a full list of configuration options refer to https://github.com/linkedin/cruise-control/wiki/Configurations. Note that properties with the following prefixes cannot be set: bootstrap.servers, client.id, zookeeper., network., security., failed.brokers.zk.path,webserver.http., webserver.api.urlprefix, webserver.session.path, webserver.accesslog., two.step., request.reason.required,metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, partition.metric.sample.store.topic, broker.metric.sample.store.topic,capacity.config.file, self.healing., anomaly.detection., ssl.
        :param str image: The docker image for the pods.
        :param 'KafkaSpecCruiseControlJvmOptionsArgs' jvm_options: JVM Options for the Cruise Control container.
        :param 'KafkaSpecCruiseControlLivenessProbeArgs' liveness_probe: Pod liveness checking for the Cruise Control container.
        :param 'KafkaSpecCruiseControlLoggingArgs' logging: Logging configuration (log4j1) for Cruise Control.
        :param Mapping[str, Any] metrics: The Prometheus JMX Exporter configuration. See https://github.com/prometheus/jmx_exporter for details of the structure of this configuration.
        :param 'KafkaSpecCruiseControlReadinessProbeArgs' readiness_probe: Pod readiness checking for the Cruise Control container.
        :param 'KafkaSpecCruiseControlResourcesArgs' resources: CPU and memory resources to reserve for the Cruise Control container.
        :param 'KafkaSpecCruiseControlTemplateArgs' template: Template to specify how Cruise Control resources, `Deployments` and `Pods`, are generated.
        :param 'KafkaSpecCruiseControlTlsSidecarArgs' tls_sidecar: TLS sidecar configuration.
        """
        if broker_capacity is not None:
            pulumi.set(__self__, "broker_capacity", broker_capacity)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if jvm_options is not None:
            pulumi.set(__self__, "jvm_options", jvm_options)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if template is not None:
            pulumi.set(__self__, "template", template)
        if tls_sidecar is not None:
            pulumi.set(__self__, "tls_sidecar", tls_sidecar)

    @property
    @pulumi.getter(name="brokerCapacity")
    def broker_capacity(self) -> Optional['outputs.KafkaSpecCruiseControlBrokerCapacity']:
        """
        The Cruise Control `brokerCapacity` configuration.
        """
        return pulumi.get(self, "broker_capacity")

    @property
    @pulumi.getter
    def config(self) -> Optional[Mapping[str, Any]]:
        """
        The Cruise Control configuration. For a full list of configuration options refer to https://github.com/linkedin/cruise-control/wiki/Configurations. Note that properties with the following prefixes cannot be set: bootstrap.servers, client.id, zookeeper., network., security., failed.brokers.zk.path,webserver.http., webserver.api.urlprefix, webserver.session.path, webserver.accesslog., two.step., request.reason.required,metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, partition.metric.sample.store.topic, broker.metric.sample.store.topic,capacity.config.file, self.healing., anomaly.detection., ssl.
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        The docker image for the pods.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="jvmOptions")
    def jvm_options(self) -> Optional['outputs.KafkaSpecCruiseControlJvmOptions']:
        """
        JVM Options for the Cruise Control container.
        """
        return pulumi.get(self, "jvm_options")

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional['outputs.KafkaSpecCruiseControlLivenessProbe']:
        """
        Pod liveness checking for the Cruise Control container.
        """
        return pulumi.get(self, "liveness_probe")

    @property
    @pulumi.getter
    def logging(self) -> Optional['outputs.KafkaSpecCruiseControlLogging']:
        """
        Logging configuration (log4j1) for Cruise Control.
        """
        return pulumi.get(self, "logging")

    @property
    @pulumi.getter
    def metrics(self) -> Optional[Mapping[str, Any]]:
        """
        The Prometheus JMX Exporter configuration. See https://github.com/prometheus/jmx_exporter for details of the structure of this configuration.
        """
        return pulumi.get(self, "metrics")

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional['outputs.KafkaSpecCruiseControlReadinessProbe']:
        """
        Pod readiness checking for the Cruise Control container.
        """
        return pulumi.get(self, "readiness_probe")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.KafkaSpecCruiseControlResources']:
        """
        CPU and memory resources to reserve for the Cruise Control container.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter
    def template(self) -> Optional['outputs.KafkaSpecCruiseControlTemplate']:
        """
        Template to specify how Cruise Control resources, `Deployments` and `Pods`, are generated.
        """
        return pulumi.get(self, "template")

    @property
    @pulumi.getter(name="tlsSidecar")
    def tls_sidecar(self) -> Optional['outputs.KafkaSpecCruiseControlTlsSidecar']:
        """
        TLS sidecar configuration.
        """
        return pulumi.get(self, "tls_sidecar")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlBrokerCapacity(dict):
    """
    The Cruise Control `brokerCapacity` configuration.
    """
    def __init__(__self__, *,
                 cpu_utilization: Optional[int] = None,
                 disk: Optional[str] = None,
                 inbound_network: Optional[str] = None,
                 outbound_network: Optional[str] = None):
        """
        The Cruise Control `brokerCapacity` configuration.
        :param int cpu_utilization: Broker capacity for CPU resource utilization as a percentage (0 - 100).
        :param str disk: Broker capacity for disk in bytes, for example, 100Gi.
        :param str inbound_network: Broker capacity for inbound network throughput in bytes per second, for example, 10000KB/s.
        :param str outbound_network: Broker capacity for outbound network throughput in bytes per second, for example 10000KB/s.
        """
        if cpu_utilization is not None:
            pulumi.set(__self__, "cpu_utilization", cpu_utilization)
        if disk is not None:
            pulumi.set(__self__, "disk", disk)
        if inbound_network is not None:
            pulumi.set(__self__, "inbound_network", inbound_network)
        if outbound_network is not None:
            pulumi.set(__self__, "outbound_network", outbound_network)

    @property
    @pulumi.getter(name="cpuUtilization")
    def cpu_utilization(self) -> Optional[int]:
        """
        Broker capacity for CPU resource utilization as a percentage (0 - 100).
        """
        return pulumi.get(self, "cpu_utilization")

    @property
    @pulumi.getter
    def disk(self) -> Optional[str]:
        """
        Broker capacity for disk in bytes, for example, 100Gi.
        """
        return pulumi.get(self, "disk")

    @property
    @pulumi.getter(name="inboundNetwork")
    def inbound_network(self) -> Optional[str]:
        """
        Broker capacity for inbound network throughput in bytes per second, for example, 10000KB/s.
        """
        return pulumi.get(self, "inbound_network")

    @property
    @pulumi.getter(name="outboundNetwork")
    def outbound_network(self) -> Optional[str]:
        """
        Broker capacity for outbound network throughput in bytes per second, for example 10000KB/s.
        """
        return pulumi.get(self, "outbound_network")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlJvmOptions(dict):
    """
    JVM Options for the Cruise Control container.
    """
    def __init__(__self__, *,
                 __xx: Optional[Mapping[str, Any]] = None,
                 __xms: Optional[str] = None,
                 __xmx: Optional[str] = None,
                 gc_logging_enabled: Optional[bool] = None,
                 java_system_properties: Optional[Sequence['outputs.KafkaSpecCruiseControlJvmOptionsJavaSystemProperties']] = None):
        """
        JVM Options for the Cruise Control container.
        :param Mapping[str, Any] __xx: A map of -XX options to the JVM.
        :param str __xms: -Xms option to to the JVM.
        :param str __xmx: -Xmx option to to the JVM.
        :param bool gc_logging_enabled: Specifies whether the Garbage Collection logging is enabled. The default is false.
        :param Sequence['KafkaSpecCruiseControlJvmOptionsJavaSystemPropertiesArgs'] java_system_properties: A map of additional system properties which will be passed using the `-D` option to the JVM.
        """
        if __xx is not None:
            pulumi.set(__self__, "__xx", __xx)
        if __xms is not None:
            pulumi.set(__self__, "__xms", __xms)
        if __xmx is not None:
            pulumi.set(__self__, "__xmx", __xmx)
        if gc_logging_enabled is not None:
            pulumi.set(__self__, "gc_logging_enabled", gc_logging_enabled)
        if java_system_properties is not None:
            pulumi.set(__self__, "java_system_properties", java_system_properties)

    @property
    @pulumi.getter(name="-XX")
    def __xx(self) -> Optional[Mapping[str, Any]]:
        """
        A map of -XX options to the JVM.
        """
        return pulumi.get(self, "__xx")

    @property
    @pulumi.getter(name="-Xms")
    def __xms(self) -> Optional[str]:
        """
        -Xms option to to the JVM.
        """
        return pulumi.get(self, "__xms")

    @property
    @pulumi.getter(name="-Xmx")
    def __xmx(self) -> Optional[str]:
        """
        -Xmx option to to the JVM.
        """
        return pulumi.get(self, "__xmx")

    @property
    @pulumi.getter(name="gcLoggingEnabled")
    def gc_logging_enabled(self) -> Optional[bool]:
        """
        Specifies whether the Garbage Collection logging is enabled. The default is false.
        """
        return pulumi.get(self, "gc_logging_enabled")

    @property
    @pulumi.getter(name="javaSystemProperties")
    def java_system_properties(self) -> Optional[Sequence['outputs.KafkaSpecCruiseControlJvmOptionsJavaSystemProperties']]:
        """
        A map of additional system properties which will be passed using the `-D` option to the JVM.
        """
        return pulumi.get(self, "java_system_properties")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlJvmOptionsJavaSystemProperties(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The system property name.
        :param str value: The system property value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The system property name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The system property value.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlLivenessProbe(dict):
    """
    Pod liveness checking for the Cruise Control container.
    """
    def __init__(__self__, *,
                 failure_threshold: Optional[int] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 timeout_seconds: Optional[int] = None):
        """
        Pod liveness checking for the Cruise Control container.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param int initial_delay_seconds: The initial delay before first the health is first checked.
        :param int period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param int timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlLogging(dict):
    """
    Logging configuration (log4j1) for Cruise Control.
    """
    def __init__(__self__, *,
                 type: str,
                 loggers: Optional[Mapping[str, Any]] = None,
                 name: Optional[str] = None):
        """
        Logging configuration (log4j1) for Cruise Control.
        :param str type: Logging type, must be either 'inline' or 'external'.
        :param Mapping[str, Any] loggers: A Map from logger name to logger level.
        :param str name: The name of the `ConfigMap` from which to get the logging configuration.
        """
        pulumi.set(__self__, "type", type)
        if loggers is not None:
            pulumi.set(__self__, "loggers", loggers)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Logging type, must be either 'inline' or 'external'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def loggers(self) -> Optional[Mapping[str, Any]]:
        """
        A Map from logger name to logger level.
        """
        return pulumi.get(self, "loggers")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the `ConfigMap` from which to get the logging configuration.
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlReadinessProbe(dict):
    """
    Pod readiness checking for the Cruise Control container.
    """
    def __init__(__self__, *,
                 failure_threshold: Optional[int] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 timeout_seconds: Optional[int] = None):
        """
        Pod readiness checking for the Cruise Control container.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param int initial_delay_seconds: The initial delay before first the health is first checked.
        :param int period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param int timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlResources(dict):
    """
    CPU and memory resources to reserve for the Cruise Control container.
    """
    def __init__(__self__, *,
                 limits: Optional[Mapping[str, Any]] = None,
                 requests: Optional[Mapping[str, Any]] = None):
        """
        CPU and memory resources to reserve for the Cruise Control container.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "requests")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplate(dict):
    """
    Template to specify how Cruise Control resources, `Deployments` and `Pods`, are generated.
    """
    def __init__(__self__, *,
                 api_service: Optional['outputs.KafkaSpecCruiseControlTemplateApiService'] = None,
                 cruise_control_container: Optional['outputs.KafkaSpecCruiseControlTemplateCruiseControlContainer'] = None,
                 deployment: Optional['outputs.KafkaSpecCruiseControlTemplateDeployment'] = None,
                 pod: Optional['outputs.KafkaSpecCruiseControlTemplatePod'] = None,
                 pod_disruption_budget: Optional['outputs.KafkaSpecCruiseControlTemplatePodDisruptionBudget'] = None,
                 tls_sidecar_container: Optional['outputs.KafkaSpecCruiseControlTemplateTlsSidecarContainer'] = None):
        """
        Template to specify how Cruise Control resources, `Deployments` and `Pods`, are generated.
        :param 'KafkaSpecCruiseControlTemplateApiServiceArgs' api_service: Template for Cruise Control API `Service`.
        :param 'KafkaSpecCruiseControlTemplateCruiseControlContainerArgs' cruise_control_container: Template for the Cruise Control container.
        :param 'KafkaSpecCruiseControlTemplateDeploymentArgs' deployment: Template for Cruise Control `Deployment`.
        :param 'KafkaSpecCruiseControlTemplatePodArgs' pod: Template for Cruise Control `Pods`.
        :param 'KafkaSpecCruiseControlTemplatePodDisruptionBudgetArgs' pod_disruption_budget: Template for Cruise Control `PodDisruptionBudget`.
        :param 'KafkaSpecCruiseControlTemplateTlsSidecarContainerArgs' tls_sidecar_container: Template for the Cruise Control TLS sidecar container.
        """
        if api_service is not None:
            pulumi.set(__self__, "api_service", api_service)
        if cruise_control_container is not None:
            pulumi.set(__self__, "cruise_control_container", cruise_control_container)
        if deployment is not None:
            pulumi.set(__self__, "deployment", deployment)
        if pod is not None:
            pulumi.set(__self__, "pod", pod)
        if pod_disruption_budget is not None:
            pulumi.set(__self__, "pod_disruption_budget", pod_disruption_budget)
        if tls_sidecar_container is not None:
            pulumi.set(__self__, "tls_sidecar_container", tls_sidecar_container)

    @property
    @pulumi.getter(name="apiService")
    def api_service(self) -> Optional['outputs.KafkaSpecCruiseControlTemplateApiService']:
        """
        Template for Cruise Control API `Service`.
        """
        return pulumi.get(self, "api_service")

    @property
    @pulumi.getter(name="cruiseControlContainer")
    def cruise_control_container(self) -> Optional['outputs.KafkaSpecCruiseControlTemplateCruiseControlContainer']:
        """
        Template for the Cruise Control container.
        """
        return pulumi.get(self, "cruise_control_container")

    @property
    @pulumi.getter
    def deployment(self) -> Optional['outputs.KafkaSpecCruiseControlTemplateDeployment']:
        """
        Template for Cruise Control `Deployment`.
        """
        return pulumi.get(self, "deployment")

    @property
    @pulumi.getter
    def pod(self) -> Optional['outputs.KafkaSpecCruiseControlTemplatePod']:
        """
        Template for Cruise Control `Pods`.
        """
        return pulumi.get(self, "pod")

    @property
    @pulumi.getter(name="podDisruptionBudget")
    def pod_disruption_budget(self) -> Optional['outputs.KafkaSpecCruiseControlTemplatePodDisruptionBudget']:
        """
        Template for Cruise Control `PodDisruptionBudget`.
        """
        return pulumi.get(self, "pod_disruption_budget")

    @property
    @pulumi.getter(name="tlsSidecarContainer")
    def tls_sidecar_container(self) -> Optional['outputs.KafkaSpecCruiseControlTemplateTlsSidecarContainer']:
        """
        Template for the Cruise Control TLS sidecar container.
        """
        return pulumi.get(self, "tls_sidecar_container")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplateApiService(dict):
    """
    Template for Cruise Control API `Service`.
    """
    def __init__(__self__, *,
                 metadata: Optional['outputs.KafkaSpecCruiseControlTemplateApiServiceMetadata'] = None):
        """
        Template for Cruise Control API `Service`.
        :param 'KafkaSpecCruiseControlTemplateApiServiceMetadataArgs' metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaSpecCruiseControlTemplateApiServiceMetadata']:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplateApiServiceMetadata(dict):
    """
    Metadata applied to the resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata applied to the resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplateCruiseControlContainer(dict):
    """
    Template for the Cruise Control container.
    """
    def __init__(__self__, *,
                 env: Optional[Sequence['outputs.KafkaSpecCruiseControlTemplateCruiseControlContainerEnv']] = None,
                 security_context: Optional['outputs.KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext'] = None):
        """
        Template for the Cruise Control container.
        :param Sequence['KafkaSpecCruiseControlTemplateCruiseControlContainerEnvArgs'] env: Environment variables which should be applied to the container.
        :param 'KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextArgs' security_context: Security context for the container.
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)

    @property
    @pulumi.getter
    def env(self) -> Optional[Sequence['outputs.KafkaSpecCruiseControlTemplateCruiseControlContainerEnv']]:
        """
        Environment variables which should be applied to the container.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional['outputs.KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext']:
        """
        Security context for the container.
        """
        return pulumi.get(self, "security_context")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplateCruiseControlContainerEnv(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The environment variable key.
        :param str value: The environment variable value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The environment variable key.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The environment variable value.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext(dict):
    """
    Security context for the container.
    """
    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[bool] = None,
                 capabilities: Optional['outputs.KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextCapabilities'] = None,
                 privileged: Optional[bool] = None,
                 proc_mount: Optional[str] = None,
                 read_only_root_filesystem: Optional[bool] = None,
                 run_as_group: Optional[int] = None,
                 run_as_non_root: Optional[bool] = None,
                 run_as_user: Optional[int] = None,
                 se_linux_options: Optional['outputs.KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions'] = None,
                 windows_options: Optional['outputs.KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptions'] = None):
        """
        Security context for the container.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if proc_mount is not None:
            pulumi.set(__self__, "proc_mount", proc_mount)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[bool]:
        return pulumi.get(self, "allow_privilege_escalation")

    @property
    @pulumi.getter
    def capabilities(self) -> Optional['outputs.KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextCapabilities']:
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def privileged(self) -> Optional[bool]:
        return pulumi.get(self, "privileged")

    @property
    @pulumi.getter(name="procMount")
    def proc_mount(self) -> Optional[str]:
        return pulumi.get(self, "proc_mount")

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[bool]:
        return pulumi.get(self, "read_only_root_filesystem")

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[int]:
        return pulumi.get(self, "run_as_group")

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[bool]:
        return pulumi.get(self, "run_as_non_root")

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[int]:
        return pulumi.get(self, "run_as_user")

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional['outputs.KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions']:
        return pulumi.get(self, "se_linux_options")

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional['outputs.KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptions']:
        return pulumi.get(self, "windows_options")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextCapabilities(dict):
    def __init__(__self__, *,
                 add: Optional[Sequence[str]] = None,
                 drop: Optional[Sequence[str]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)

    @property
    @pulumi.getter
    def add(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def drop(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "drop")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions(dict):
    def __init__(__self__, *,
                 level: Optional[str] = None,
                 role: Optional[str] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        return pulumi.get(self, "user")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptions(dict):
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[str] = None,
                 gmsa_credential_spec_name: Optional[str] = None,
                 run_as_user_name: Optional[str] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec")

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[str]:
        return pulumi.get(self, "run_as_user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplateDeployment(dict):
    """
    Template for Cruise Control `Deployment`.
    """
    def __init__(__self__, *,
                 metadata: Optional['outputs.KafkaSpecCruiseControlTemplateDeploymentMetadata'] = None):
        """
        Template for Cruise Control `Deployment`.
        :param 'KafkaSpecCruiseControlTemplateDeploymentMetadataArgs' metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaSpecCruiseControlTemplateDeploymentMetadata']:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplateDeploymentMetadata(dict):
    """
    Metadata applied to the resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata applied to the resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplatePod(dict):
    """
    Template for Cruise Control `Pods`.
    """
    def __init__(__self__, *,
                 affinity: Optional['outputs.KafkaSpecCruiseControlTemplatePodAffinity'] = None,
                 host_aliases: Optional[Sequence['outputs.KafkaSpecCruiseControlTemplatePodHostAliases']] = None,
                 image_pull_secrets: Optional[Sequence['outputs.KafkaSpecCruiseControlTemplatePodImagePullSecrets']] = None,
                 metadata: Optional['outputs.KafkaSpecCruiseControlTemplatePodMetadata'] = None,
                 priority_class_name: Optional[str] = None,
                 scheduler_name: Optional[str] = None,
                 security_context: Optional['outputs.KafkaSpecCruiseControlTemplatePodSecurityContext'] = None,
                 termination_grace_period_seconds: Optional[int] = None,
                 tolerations: Optional[Sequence['outputs.KafkaSpecCruiseControlTemplatePodTolerations']] = None):
        """
        Template for Cruise Control `Pods`.
        :param 'KafkaSpecCruiseControlTemplatePodAffinityArgs' affinity: The pod's affinity rules.
        :param Sequence['KafkaSpecCruiseControlTemplatePodHostAliasesArgs'] host_aliases: The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
        :param Sequence['KafkaSpecCruiseControlTemplatePodImagePullSecretsArgs'] image_pull_secrets: List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
        :param 'KafkaSpecCruiseControlTemplatePodMetadataArgs' metadata: Metadata applied to the resource.
        :param str priority_class_name: The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
        :param str scheduler_name: The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
        :param 'KafkaSpecCruiseControlTemplatePodSecurityContextArgs' security_context: Configures pod-level security attributes and common container settings.
        :param int termination_grace_period_seconds: The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
        :param Sequence['KafkaSpecCruiseControlTemplatePodTolerationsArgs'] tolerations: The pod's tolerations.
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if host_aliases is not None:
            pulumi.set(__self__, "host_aliases", host_aliases)
        if image_pull_secrets is not None:
            pulumi.set(__self__, "image_pull_secrets", image_pull_secrets)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if priority_class_name is not None:
            pulumi.set(__self__, "priority_class_name", priority_class_name)
        if scheduler_name is not None:
            pulumi.set(__self__, "scheduler_name", scheduler_name)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)

    @property
    @pulumi.getter
    def affinity(self) -> Optional['outputs.KafkaSpecCruiseControlTemplatePodAffinity']:
        """
        The pod's affinity rules.
        """
        return pulumi.get(self, "affinity")

    @property
    @pulumi.getter(name="hostAliases")
    def host_aliases(self) -> Optional[Sequence['outputs.KafkaSpecCruiseControlTemplatePodHostAliases']]:
        """
        The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
        """
        return pulumi.get(self, "host_aliases")

    @property
    @pulumi.getter(name="imagePullSecrets")
    def image_pull_secrets(self) -> Optional[Sequence['outputs.KafkaSpecCruiseControlTemplatePodImagePullSecrets']]:
        """
        List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
        """
        return pulumi.get(self, "image_pull_secrets")

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaSpecCruiseControlTemplatePodMetadata']:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter(name="priorityClassName")
    def priority_class_name(self) -> Optional[str]:
        """
        The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
        """
        return pulumi.get(self, "priority_class_name")

    @property
    @pulumi.getter(name="schedulerName")
    def scheduler_name(self) -> Optional[str]:
        """
        The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
        """
        return pulumi.get(self, "scheduler_name")

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional['outputs.KafkaSpecCruiseControlTemplatePodSecurityContext']:
        """
        Configures pod-level security attributes and common container settings.
        """
        return pulumi.get(self, "security_context")

    @property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[int]:
        """
        The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
        """
        return pulumi.get(self, "termination_grace_period_seconds")

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[Sequence['outputs.KafkaSpecCruiseControlTemplatePodTolerations']]:
        """
        The pod's tolerations.
        """
        return pulumi.get(self, "tolerations")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplatePodAffinity(dict):
    """
    The pod's affinity rules.
    """
    def __init__(__self__, *,
                 node_affinity: Optional['outputs.KafkaSpecCruiseControlTemplatePodAffinityNodeAffinity'] = None,
                 pod_affinity: Optional['outputs.KafkaSpecCruiseControlTemplatePodAffinityPodAffinity'] = None,
                 pod_anti_affinity: Optional['outputs.KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinity'] = None):
        """
        The pod's affinity rules.
        """
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional['outputs.KafkaSpecCruiseControlTemplatePodAffinityNodeAffinity']:
        return pulumi.get(self, "node_affinity")

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional['outputs.KafkaSpecCruiseControlTemplatePodAffinityPodAffinity']:
        return pulumi.get(self, "pod_affinity")

    @property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional['outputs.KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinity']:
        return pulumi.get(self, "pod_anti_affinity")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplatePodAffinityNodeAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional['outputs.KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution'] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional['outputs.KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution']:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 preference: Optional['outputs.KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference'] = None,
                 weight: Optional[int] = None):
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preference(self) -> Optional['outputs.KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference']:
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions']] = None,
                 match_fields: Optional[Sequence['outputs.KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields']] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields']]:
        return pulumi.get(self, "match_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 node_selector_terms: Optional[Sequence['outputs.KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms']] = None):
        if node_selector_terms is not None:
            pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> Optional[Sequence['outputs.KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms']]:
        return pulumi.get(self, "node_selector_terms")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions']] = None,
                 match_fields: Optional[Sequence['outputs.KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields']] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields']]:
        return pulumi.get(self, "match_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplatePodAffinityPodAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 pod_affinity_term: Optional['outputs.KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm'] = None,
                 weight: Optional[int] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional['outputs.KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm']:
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 pod_affinity_term: Optional['outputs.KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm'] = None,
                 weight: Optional[int] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional['outputs.KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm']:
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplatePodDisruptionBudget(dict):
    """
    Template for Cruise Control `PodDisruptionBudget`.
    """
    def __init__(__self__, *,
                 max_unavailable: Optional[int] = None,
                 metadata: Optional['outputs.KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadata'] = None):
        """
        Template for Cruise Control `PodDisruptionBudget`.
        :param int max_unavailable: Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
        :param 'KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadataArgs' metadata: Metadata to apply to the `PodDistruptionBugetTemplate` resource.
        """
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[int]:
        """
        Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
        """
        return pulumi.get(self, "max_unavailable")

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadata']:
        """
        Metadata to apply to the `PodDistruptionBugetTemplate` resource.
        """
        return pulumi.get(self, "metadata")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadata(dict):
    """
    Metadata to apply to the `PodDistruptionBugetTemplate` resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata to apply to the `PodDistruptionBugetTemplate` resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplatePodHostAliases(dict):
    def __init__(__self__, *,
                 hostnames: Optional[Sequence[str]] = None,
                 ip: Optional[str] = None):
        if hostnames is not None:
            pulumi.set(__self__, "hostnames", hostnames)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def hostnames(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "hostnames")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        return pulumi.get(self, "ip")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplatePodImagePullSecrets(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplatePodMetadata(dict):
    """
    Metadata applied to the resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata applied to the resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplatePodSecurityContext(dict):
    """
    Configures pod-level security attributes and common container settings.
    """
    def __init__(__self__, *,
                 fs_group: Optional[int] = None,
                 fs_group_change_policy: Optional[str] = None,
                 run_as_group: Optional[int] = None,
                 run_as_non_root: Optional[bool] = None,
                 run_as_user: Optional[int] = None,
                 se_linux_options: Optional['outputs.KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions'] = None,
                 supplemental_groups: Optional[Sequence[int]] = None,
                 sysctls: Optional[Sequence['outputs.KafkaSpecCruiseControlTemplatePodSecurityContextSysctls']] = None,
                 windows_options: Optional['outputs.KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptions'] = None):
        """
        Configures pod-level security attributes and common container settings.
        """
        if fs_group is not None:
            pulumi.set(__self__, "fs_group", fs_group)
        if fs_group_change_policy is not None:
            pulumi.set(__self__, "fs_group_change_policy", fs_group_change_policy)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if supplemental_groups is not None:
            pulumi.set(__self__, "supplemental_groups", supplemental_groups)
        if sysctls is not None:
            pulumi.set(__self__, "sysctls", sysctls)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="fsGroup")
    def fs_group(self) -> Optional[int]:
        return pulumi.get(self, "fs_group")

    @property
    @pulumi.getter(name="fsGroupChangePolicy")
    def fs_group_change_policy(self) -> Optional[str]:
        return pulumi.get(self, "fs_group_change_policy")

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[int]:
        return pulumi.get(self, "run_as_group")

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[bool]:
        return pulumi.get(self, "run_as_non_root")

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[int]:
        return pulumi.get(self, "run_as_user")

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional['outputs.KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions']:
        return pulumi.get(self, "se_linux_options")

    @property
    @pulumi.getter(name="supplementalGroups")
    def supplemental_groups(self) -> Optional[Sequence[int]]:
        return pulumi.get(self, "supplemental_groups")

    @property
    @pulumi.getter
    def sysctls(self) -> Optional[Sequence['outputs.KafkaSpecCruiseControlTemplatePodSecurityContextSysctls']]:
        return pulumi.get(self, "sysctls")

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional['outputs.KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptions']:
        return pulumi.get(self, "windows_options")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions(dict):
    def __init__(__self__, *,
                 level: Optional[str] = None,
                 role: Optional[str] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        return pulumi.get(self, "user")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplatePodSecurityContextSysctls(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptions(dict):
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[str] = None,
                 gmsa_credential_spec_name: Optional[str] = None,
                 run_as_user_name: Optional[str] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec")

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[str]:
        return pulumi.get(self, "run_as_user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplatePodTolerations(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 toleration_seconds: Optional[int] = None,
                 value: Optional[str] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if toleration_seconds is not None:
            pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> Optional[int]:
        return pulumi.get(self, "toleration_seconds")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplateTlsSidecarContainer(dict):
    """
    Template for the Cruise Control TLS sidecar container.
    """
    def __init__(__self__, *,
                 env: Optional[Sequence['outputs.KafkaSpecCruiseControlTemplateTlsSidecarContainerEnv']] = None,
                 security_context: Optional['outputs.KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext'] = None):
        """
        Template for the Cruise Control TLS sidecar container.
        :param Sequence['KafkaSpecCruiseControlTemplateTlsSidecarContainerEnvArgs'] env: Environment variables which should be applied to the container.
        :param 'KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextArgs' security_context: Security context for the container.
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)

    @property
    @pulumi.getter
    def env(self) -> Optional[Sequence['outputs.KafkaSpecCruiseControlTemplateTlsSidecarContainerEnv']]:
        """
        Environment variables which should be applied to the container.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional['outputs.KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext']:
        """
        Security context for the container.
        """
        return pulumi.get(self, "security_context")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplateTlsSidecarContainerEnv(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The environment variable key.
        :param str value: The environment variable value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The environment variable key.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The environment variable value.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext(dict):
    """
    Security context for the container.
    """
    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[bool] = None,
                 capabilities: Optional['outputs.KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextCapabilities'] = None,
                 privileged: Optional[bool] = None,
                 proc_mount: Optional[str] = None,
                 read_only_root_filesystem: Optional[bool] = None,
                 run_as_group: Optional[int] = None,
                 run_as_non_root: Optional[bool] = None,
                 run_as_user: Optional[int] = None,
                 se_linux_options: Optional['outputs.KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions'] = None,
                 windows_options: Optional['outputs.KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptions'] = None):
        """
        Security context for the container.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if proc_mount is not None:
            pulumi.set(__self__, "proc_mount", proc_mount)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[bool]:
        return pulumi.get(self, "allow_privilege_escalation")

    @property
    @pulumi.getter
    def capabilities(self) -> Optional['outputs.KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextCapabilities']:
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def privileged(self) -> Optional[bool]:
        return pulumi.get(self, "privileged")

    @property
    @pulumi.getter(name="procMount")
    def proc_mount(self) -> Optional[str]:
        return pulumi.get(self, "proc_mount")

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[bool]:
        return pulumi.get(self, "read_only_root_filesystem")

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[int]:
        return pulumi.get(self, "run_as_group")

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[bool]:
        return pulumi.get(self, "run_as_non_root")

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[int]:
        return pulumi.get(self, "run_as_user")

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional['outputs.KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions']:
        return pulumi.get(self, "se_linux_options")

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional['outputs.KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptions']:
        return pulumi.get(self, "windows_options")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextCapabilities(dict):
    def __init__(__self__, *,
                 add: Optional[Sequence[str]] = None,
                 drop: Optional[Sequence[str]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)

    @property
    @pulumi.getter
    def add(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def drop(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "drop")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions(dict):
    def __init__(__self__, *,
                 level: Optional[str] = None,
                 role: Optional[str] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        return pulumi.get(self, "user")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptions(dict):
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[str] = None,
                 gmsa_credential_spec_name: Optional[str] = None,
                 run_as_user_name: Optional[str] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec")

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[str]:
        return pulumi.get(self, "run_as_user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTlsSidecar(dict):
    """
    TLS sidecar configuration.
    """
    def __init__(__self__, *,
                 image: Optional[str] = None,
                 liveness_probe: Optional['outputs.KafkaSpecCruiseControlTlsSidecarLivenessProbe'] = None,
                 log_level: Optional[str] = None,
                 readiness_probe: Optional['outputs.KafkaSpecCruiseControlTlsSidecarReadinessProbe'] = None,
                 resources: Optional['outputs.KafkaSpecCruiseControlTlsSidecarResources'] = None):
        """
        TLS sidecar configuration.
        :param str image: The docker image for the container.
        :param 'KafkaSpecCruiseControlTlsSidecarLivenessProbeArgs' liveness_probe: Pod liveness checking.
        :param str log_level: The log level for the TLS sidecar. Default value is `notice`.
        :param 'KafkaSpecCruiseControlTlsSidecarReadinessProbeArgs' readiness_probe: Pod readiness checking.
        :param 'KafkaSpecCruiseControlTlsSidecarResourcesArgs' resources: CPU and memory resources to reserve.
        """
        if image is not None:
            pulumi.set(__self__, "image", image)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        The docker image for the container.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional['outputs.KafkaSpecCruiseControlTlsSidecarLivenessProbe']:
        """
        Pod liveness checking.
        """
        return pulumi.get(self, "liveness_probe")

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[str]:
        """
        The log level for the TLS sidecar. Default value is `notice`.
        """
        return pulumi.get(self, "log_level")

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional['outputs.KafkaSpecCruiseControlTlsSidecarReadinessProbe']:
        """
        Pod readiness checking.
        """
        return pulumi.get(self, "readiness_probe")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.KafkaSpecCruiseControlTlsSidecarResources']:
        """
        CPU and memory resources to reserve.
        """
        return pulumi.get(self, "resources")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTlsSidecarLivenessProbe(dict):
    """
    Pod liveness checking.
    """
    def __init__(__self__, *,
                 failure_threshold: Optional[int] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 timeout_seconds: Optional[int] = None):
        """
        Pod liveness checking.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param int initial_delay_seconds: The initial delay before first the health is first checked.
        :param int period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param int timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTlsSidecarReadinessProbe(dict):
    """
    Pod readiness checking.
    """
    def __init__(__self__, *,
                 failure_threshold: Optional[int] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 timeout_seconds: Optional[int] = None):
        """
        Pod readiness checking.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param int initial_delay_seconds: The initial delay before first the health is first checked.
        :param int period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param int timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecCruiseControlTlsSidecarResources(dict):
    """
    CPU and memory resources to reserve.
    """
    def __init__(__self__, *,
                 limits: Optional[Mapping[str, Any]] = None,
                 requests: Optional[Mapping[str, Any]] = None):
        """
        CPU and memory resources to reserve.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "requests")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperator(dict):
    """
    Configuration of the Entity Operator.
    """
    def __init__(__self__, *,
                 affinity: Optional['outputs.KafkaSpecEntityOperatorAffinity'] = None,
                 template: Optional['outputs.KafkaSpecEntityOperatorTemplate'] = None,
                 tls_sidecar: Optional['outputs.KafkaSpecEntityOperatorTlsSidecar'] = None,
                 tolerations: Optional[Sequence['outputs.KafkaSpecEntityOperatorTolerations']] = None,
                 topic_operator: Optional['outputs.KafkaSpecEntityOperatorTopicOperator'] = None,
                 user_operator: Optional['outputs.KafkaSpecEntityOperatorUserOperator'] = None):
        """
        Configuration of the Entity Operator.
        :param 'KafkaSpecEntityOperatorAffinityArgs' affinity: The pod's affinity rules.
        :param 'KafkaSpecEntityOperatorTemplateArgs' template: Template for Entity Operator resources. The template allows users to specify how is the `Deployment` and `Pods` generated.
        :param 'KafkaSpecEntityOperatorTlsSidecarArgs' tls_sidecar: TLS sidecar configuration.
        :param Sequence['KafkaSpecEntityOperatorTolerationsArgs'] tolerations: The pod's tolerations.
        :param 'KafkaSpecEntityOperatorTopicOperatorArgs' topic_operator: Configuration of the Topic Operator.
        :param 'KafkaSpecEntityOperatorUserOperatorArgs' user_operator: Configuration of the User Operator.
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if template is not None:
            pulumi.set(__self__, "template", template)
        if tls_sidecar is not None:
            pulumi.set(__self__, "tls_sidecar", tls_sidecar)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)
        if topic_operator is not None:
            pulumi.set(__self__, "topic_operator", topic_operator)
        if user_operator is not None:
            pulumi.set(__self__, "user_operator", user_operator)

    @property
    @pulumi.getter
    def affinity(self) -> Optional['outputs.KafkaSpecEntityOperatorAffinity']:
        """
        The pod's affinity rules.
        """
        return pulumi.get(self, "affinity")

    @property
    @pulumi.getter
    def template(self) -> Optional['outputs.KafkaSpecEntityOperatorTemplate']:
        """
        Template for Entity Operator resources. The template allows users to specify how is the `Deployment` and `Pods` generated.
        """
        return pulumi.get(self, "template")

    @property
    @pulumi.getter(name="tlsSidecar")
    def tls_sidecar(self) -> Optional['outputs.KafkaSpecEntityOperatorTlsSidecar']:
        """
        TLS sidecar configuration.
        """
        return pulumi.get(self, "tls_sidecar")

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[Sequence['outputs.KafkaSpecEntityOperatorTolerations']]:
        """
        The pod's tolerations.
        """
        return pulumi.get(self, "tolerations")

    @property
    @pulumi.getter(name="topicOperator")
    def topic_operator(self) -> Optional['outputs.KafkaSpecEntityOperatorTopicOperator']:
        """
        Configuration of the Topic Operator.
        """
        return pulumi.get(self, "topic_operator")

    @property
    @pulumi.getter(name="userOperator")
    def user_operator(self) -> Optional['outputs.KafkaSpecEntityOperatorUserOperator']:
        """
        Configuration of the User Operator.
        """
        return pulumi.get(self, "user_operator")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorAffinity(dict):
    """
    The pod's affinity rules.
    """
    def __init__(__self__, *,
                 node_affinity: Optional['outputs.KafkaSpecEntityOperatorAffinityNodeAffinity'] = None,
                 pod_affinity: Optional['outputs.KafkaSpecEntityOperatorAffinityPodAffinity'] = None,
                 pod_anti_affinity: Optional['outputs.KafkaSpecEntityOperatorAffinityPodAntiAffinity'] = None):
        """
        The pod's affinity rules.
        """
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional['outputs.KafkaSpecEntityOperatorAffinityNodeAffinity']:
        return pulumi.get(self, "node_affinity")

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional['outputs.KafkaSpecEntityOperatorAffinityPodAffinity']:
        return pulumi.get(self, "pod_affinity")

    @property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional['outputs.KafkaSpecEntityOperatorAffinityPodAntiAffinity']:
        return pulumi.get(self, "pod_anti_affinity")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorAffinityNodeAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional['outputs.KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution'] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional['outputs.KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution']:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 preference: Optional['outputs.KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference'] = None,
                 weight: Optional[int] = None):
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preference(self) -> Optional['outputs.KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference']:
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions']] = None,
                 match_fields: Optional[Sequence['outputs.KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields']] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields']]:
        return pulumi.get(self, "match_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 node_selector_terms: Optional[Sequence['outputs.KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms']] = None):
        if node_selector_terms is not None:
            pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> Optional[Sequence['outputs.KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms']]:
        return pulumi.get(self, "node_selector_terms")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions']] = None,
                 match_fields: Optional[Sequence['outputs.KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields']] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields']]:
        return pulumi.get(self, "match_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorAffinityPodAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 pod_affinity_term: Optional['outputs.KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm'] = None,
                 weight: Optional[int] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional['outputs.KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm']:
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorAffinityPodAntiAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 pod_affinity_term: Optional['outputs.KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm'] = None,
                 weight: Optional[int] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional['outputs.KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm']:
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplate(dict):
    """
    Template for Entity Operator resources. The template allows users to specify how is the `Deployment` and `Pods` generated.
    """
    def __init__(__self__, *,
                 deployment: Optional['outputs.KafkaSpecEntityOperatorTemplateDeployment'] = None,
                 pod: Optional['outputs.KafkaSpecEntityOperatorTemplatePod'] = None,
                 tls_sidecar_container: Optional['outputs.KafkaSpecEntityOperatorTemplateTlsSidecarContainer'] = None,
                 topic_operator_container: Optional['outputs.KafkaSpecEntityOperatorTemplateTopicOperatorContainer'] = None,
                 user_operator_container: Optional['outputs.KafkaSpecEntityOperatorTemplateUserOperatorContainer'] = None):
        """
        Template for Entity Operator resources. The template allows users to specify how is the `Deployment` and `Pods` generated.
        :param 'KafkaSpecEntityOperatorTemplateDeploymentArgs' deployment: Template for Entity Operator `Deployment`.
        :param 'KafkaSpecEntityOperatorTemplatePodArgs' pod: Template for Entity Operator `Pods`.
        :param 'KafkaSpecEntityOperatorTemplateTlsSidecarContainerArgs' tls_sidecar_container: Template for the Entity Operator TLS sidecar container.
        :param 'KafkaSpecEntityOperatorTemplateTopicOperatorContainerArgs' topic_operator_container: Template for the Entity Topic Operator container.
        :param 'KafkaSpecEntityOperatorTemplateUserOperatorContainerArgs' user_operator_container: Template for the Entity User Operator container.
        """
        if deployment is not None:
            pulumi.set(__self__, "deployment", deployment)
        if pod is not None:
            pulumi.set(__self__, "pod", pod)
        if tls_sidecar_container is not None:
            pulumi.set(__self__, "tls_sidecar_container", tls_sidecar_container)
        if topic_operator_container is not None:
            pulumi.set(__self__, "topic_operator_container", topic_operator_container)
        if user_operator_container is not None:
            pulumi.set(__self__, "user_operator_container", user_operator_container)

    @property
    @pulumi.getter
    def deployment(self) -> Optional['outputs.KafkaSpecEntityOperatorTemplateDeployment']:
        """
        Template for Entity Operator `Deployment`.
        """
        return pulumi.get(self, "deployment")

    @property
    @pulumi.getter
    def pod(self) -> Optional['outputs.KafkaSpecEntityOperatorTemplatePod']:
        """
        Template for Entity Operator `Pods`.
        """
        return pulumi.get(self, "pod")

    @property
    @pulumi.getter(name="tlsSidecarContainer")
    def tls_sidecar_container(self) -> Optional['outputs.KafkaSpecEntityOperatorTemplateTlsSidecarContainer']:
        """
        Template for the Entity Operator TLS sidecar container.
        """
        return pulumi.get(self, "tls_sidecar_container")

    @property
    @pulumi.getter(name="topicOperatorContainer")
    def topic_operator_container(self) -> Optional['outputs.KafkaSpecEntityOperatorTemplateTopicOperatorContainer']:
        """
        Template for the Entity Topic Operator container.
        """
        return pulumi.get(self, "topic_operator_container")

    @property
    @pulumi.getter(name="userOperatorContainer")
    def user_operator_container(self) -> Optional['outputs.KafkaSpecEntityOperatorTemplateUserOperatorContainer']:
        """
        Template for the Entity User Operator container.
        """
        return pulumi.get(self, "user_operator_container")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplateDeployment(dict):
    """
    Template for Entity Operator `Deployment`.
    """
    def __init__(__self__, *,
                 metadata: Optional['outputs.KafkaSpecEntityOperatorTemplateDeploymentMetadata'] = None):
        """
        Template for Entity Operator `Deployment`.
        :param 'KafkaSpecEntityOperatorTemplateDeploymentMetadataArgs' metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaSpecEntityOperatorTemplateDeploymentMetadata']:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplateDeploymentMetadata(dict):
    """
    Metadata applied to the resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata applied to the resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplatePod(dict):
    """
    Template for Entity Operator `Pods`.
    """
    def __init__(__self__, *,
                 affinity: Optional['outputs.KafkaSpecEntityOperatorTemplatePodAffinity'] = None,
                 host_aliases: Optional[Sequence['outputs.KafkaSpecEntityOperatorTemplatePodHostAliases']] = None,
                 image_pull_secrets: Optional[Sequence['outputs.KafkaSpecEntityOperatorTemplatePodImagePullSecrets']] = None,
                 metadata: Optional['outputs.KafkaSpecEntityOperatorTemplatePodMetadata'] = None,
                 priority_class_name: Optional[str] = None,
                 scheduler_name: Optional[str] = None,
                 security_context: Optional['outputs.KafkaSpecEntityOperatorTemplatePodSecurityContext'] = None,
                 termination_grace_period_seconds: Optional[int] = None,
                 tolerations: Optional[Sequence['outputs.KafkaSpecEntityOperatorTemplatePodTolerations']] = None):
        """
        Template for Entity Operator `Pods`.
        :param 'KafkaSpecEntityOperatorTemplatePodAffinityArgs' affinity: The pod's affinity rules.
        :param Sequence['KafkaSpecEntityOperatorTemplatePodHostAliasesArgs'] host_aliases: The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
        :param Sequence['KafkaSpecEntityOperatorTemplatePodImagePullSecretsArgs'] image_pull_secrets: List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
        :param 'KafkaSpecEntityOperatorTemplatePodMetadataArgs' metadata: Metadata applied to the resource.
        :param str priority_class_name: The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
        :param str scheduler_name: The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
        :param 'KafkaSpecEntityOperatorTemplatePodSecurityContextArgs' security_context: Configures pod-level security attributes and common container settings.
        :param int termination_grace_period_seconds: The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
        :param Sequence['KafkaSpecEntityOperatorTemplatePodTolerationsArgs'] tolerations: The pod's tolerations.
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if host_aliases is not None:
            pulumi.set(__self__, "host_aliases", host_aliases)
        if image_pull_secrets is not None:
            pulumi.set(__self__, "image_pull_secrets", image_pull_secrets)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if priority_class_name is not None:
            pulumi.set(__self__, "priority_class_name", priority_class_name)
        if scheduler_name is not None:
            pulumi.set(__self__, "scheduler_name", scheduler_name)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)

    @property
    @pulumi.getter
    def affinity(self) -> Optional['outputs.KafkaSpecEntityOperatorTemplatePodAffinity']:
        """
        The pod's affinity rules.
        """
        return pulumi.get(self, "affinity")

    @property
    @pulumi.getter(name="hostAliases")
    def host_aliases(self) -> Optional[Sequence['outputs.KafkaSpecEntityOperatorTemplatePodHostAliases']]:
        """
        The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
        """
        return pulumi.get(self, "host_aliases")

    @property
    @pulumi.getter(name="imagePullSecrets")
    def image_pull_secrets(self) -> Optional[Sequence['outputs.KafkaSpecEntityOperatorTemplatePodImagePullSecrets']]:
        """
        List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
        """
        return pulumi.get(self, "image_pull_secrets")

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaSpecEntityOperatorTemplatePodMetadata']:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter(name="priorityClassName")
    def priority_class_name(self) -> Optional[str]:
        """
        The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
        """
        return pulumi.get(self, "priority_class_name")

    @property
    @pulumi.getter(name="schedulerName")
    def scheduler_name(self) -> Optional[str]:
        """
        The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
        """
        return pulumi.get(self, "scheduler_name")

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional['outputs.KafkaSpecEntityOperatorTemplatePodSecurityContext']:
        """
        Configures pod-level security attributes and common container settings.
        """
        return pulumi.get(self, "security_context")

    @property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[int]:
        """
        The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
        """
        return pulumi.get(self, "termination_grace_period_seconds")

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[Sequence['outputs.KafkaSpecEntityOperatorTemplatePodTolerations']]:
        """
        The pod's tolerations.
        """
        return pulumi.get(self, "tolerations")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplatePodAffinity(dict):
    """
    The pod's affinity rules.
    """
    def __init__(__self__, *,
                 node_affinity: Optional['outputs.KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinity'] = None,
                 pod_affinity: Optional['outputs.KafkaSpecEntityOperatorTemplatePodAffinityPodAffinity'] = None,
                 pod_anti_affinity: Optional['outputs.KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinity'] = None):
        """
        The pod's affinity rules.
        """
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional['outputs.KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinity']:
        return pulumi.get(self, "node_affinity")

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional['outputs.KafkaSpecEntityOperatorTemplatePodAffinityPodAffinity']:
        return pulumi.get(self, "pod_affinity")

    @property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional['outputs.KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinity']:
        return pulumi.get(self, "pod_anti_affinity")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional['outputs.KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution'] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional['outputs.KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution']:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 preference: Optional['outputs.KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference'] = None,
                 weight: Optional[int] = None):
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preference(self) -> Optional['outputs.KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference']:
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions']] = None,
                 match_fields: Optional[Sequence['outputs.KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields']] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields']]:
        return pulumi.get(self, "match_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 node_selector_terms: Optional[Sequence['outputs.KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms']] = None):
        if node_selector_terms is not None:
            pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> Optional[Sequence['outputs.KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms']]:
        return pulumi.get(self, "node_selector_terms")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions']] = None,
                 match_fields: Optional[Sequence['outputs.KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields']] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields']]:
        return pulumi.get(self, "match_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplatePodAffinityPodAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 pod_affinity_term: Optional['outputs.KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm'] = None,
                 weight: Optional[int] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional['outputs.KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm']:
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 pod_affinity_term: Optional['outputs.KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm'] = None,
                 weight: Optional[int] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional['outputs.KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm']:
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplatePodHostAliases(dict):
    def __init__(__self__, *,
                 hostnames: Optional[Sequence[str]] = None,
                 ip: Optional[str] = None):
        if hostnames is not None:
            pulumi.set(__self__, "hostnames", hostnames)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def hostnames(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "hostnames")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        return pulumi.get(self, "ip")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplatePodImagePullSecrets(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplatePodMetadata(dict):
    """
    Metadata applied to the resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata applied to the resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplatePodSecurityContext(dict):
    """
    Configures pod-level security attributes and common container settings.
    """
    def __init__(__self__, *,
                 fs_group: Optional[int] = None,
                 fs_group_change_policy: Optional[str] = None,
                 run_as_group: Optional[int] = None,
                 run_as_non_root: Optional[bool] = None,
                 run_as_user: Optional[int] = None,
                 se_linux_options: Optional['outputs.KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions'] = None,
                 supplemental_groups: Optional[Sequence[int]] = None,
                 sysctls: Optional[Sequence['outputs.KafkaSpecEntityOperatorTemplatePodSecurityContextSysctls']] = None,
                 windows_options: Optional['outputs.KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptions'] = None):
        """
        Configures pod-level security attributes and common container settings.
        """
        if fs_group is not None:
            pulumi.set(__self__, "fs_group", fs_group)
        if fs_group_change_policy is not None:
            pulumi.set(__self__, "fs_group_change_policy", fs_group_change_policy)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if supplemental_groups is not None:
            pulumi.set(__self__, "supplemental_groups", supplemental_groups)
        if sysctls is not None:
            pulumi.set(__self__, "sysctls", sysctls)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="fsGroup")
    def fs_group(self) -> Optional[int]:
        return pulumi.get(self, "fs_group")

    @property
    @pulumi.getter(name="fsGroupChangePolicy")
    def fs_group_change_policy(self) -> Optional[str]:
        return pulumi.get(self, "fs_group_change_policy")

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[int]:
        return pulumi.get(self, "run_as_group")

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[bool]:
        return pulumi.get(self, "run_as_non_root")

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[int]:
        return pulumi.get(self, "run_as_user")

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional['outputs.KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions']:
        return pulumi.get(self, "se_linux_options")

    @property
    @pulumi.getter(name="supplementalGroups")
    def supplemental_groups(self) -> Optional[Sequence[int]]:
        return pulumi.get(self, "supplemental_groups")

    @property
    @pulumi.getter
    def sysctls(self) -> Optional[Sequence['outputs.KafkaSpecEntityOperatorTemplatePodSecurityContextSysctls']]:
        return pulumi.get(self, "sysctls")

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional['outputs.KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptions']:
        return pulumi.get(self, "windows_options")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions(dict):
    def __init__(__self__, *,
                 level: Optional[str] = None,
                 role: Optional[str] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        return pulumi.get(self, "user")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplatePodSecurityContextSysctls(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptions(dict):
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[str] = None,
                 gmsa_credential_spec_name: Optional[str] = None,
                 run_as_user_name: Optional[str] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec")

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[str]:
        return pulumi.get(self, "run_as_user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplatePodTolerations(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 toleration_seconds: Optional[int] = None,
                 value: Optional[str] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if toleration_seconds is not None:
            pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> Optional[int]:
        return pulumi.get(self, "toleration_seconds")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplateTlsSidecarContainer(dict):
    """
    Template for the Entity Operator TLS sidecar container.
    """
    def __init__(__self__, *,
                 env: Optional[Sequence['outputs.KafkaSpecEntityOperatorTemplateTlsSidecarContainerEnv']] = None,
                 security_context: Optional['outputs.KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext'] = None):
        """
        Template for the Entity Operator TLS sidecar container.
        :param Sequence['KafkaSpecEntityOperatorTemplateTlsSidecarContainerEnvArgs'] env: Environment variables which should be applied to the container.
        :param 'KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextArgs' security_context: Security context for the container.
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)

    @property
    @pulumi.getter
    def env(self) -> Optional[Sequence['outputs.KafkaSpecEntityOperatorTemplateTlsSidecarContainerEnv']]:
        """
        Environment variables which should be applied to the container.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional['outputs.KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext']:
        """
        Security context for the container.
        """
        return pulumi.get(self, "security_context")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplateTlsSidecarContainerEnv(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The environment variable key.
        :param str value: The environment variable value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The environment variable key.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The environment variable value.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext(dict):
    """
    Security context for the container.
    """
    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[bool] = None,
                 capabilities: Optional['outputs.KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextCapabilities'] = None,
                 privileged: Optional[bool] = None,
                 proc_mount: Optional[str] = None,
                 read_only_root_filesystem: Optional[bool] = None,
                 run_as_group: Optional[int] = None,
                 run_as_non_root: Optional[bool] = None,
                 run_as_user: Optional[int] = None,
                 se_linux_options: Optional['outputs.KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions'] = None,
                 windows_options: Optional['outputs.KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptions'] = None):
        """
        Security context for the container.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if proc_mount is not None:
            pulumi.set(__self__, "proc_mount", proc_mount)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[bool]:
        return pulumi.get(self, "allow_privilege_escalation")

    @property
    @pulumi.getter
    def capabilities(self) -> Optional['outputs.KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextCapabilities']:
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def privileged(self) -> Optional[bool]:
        return pulumi.get(self, "privileged")

    @property
    @pulumi.getter(name="procMount")
    def proc_mount(self) -> Optional[str]:
        return pulumi.get(self, "proc_mount")

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[bool]:
        return pulumi.get(self, "read_only_root_filesystem")

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[int]:
        return pulumi.get(self, "run_as_group")

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[bool]:
        return pulumi.get(self, "run_as_non_root")

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[int]:
        return pulumi.get(self, "run_as_user")

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional['outputs.KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions']:
        return pulumi.get(self, "se_linux_options")

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional['outputs.KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptions']:
        return pulumi.get(self, "windows_options")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextCapabilities(dict):
    def __init__(__self__, *,
                 add: Optional[Sequence[str]] = None,
                 drop: Optional[Sequence[str]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)

    @property
    @pulumi.getter
    def add(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def drop(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "drop")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions(dict):
    def __init__(__self__, *,
                 level: Optional[str] = None,
                 role: Optional[str] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        return pulumi.get(self, "user")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptions(dict):
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[str] = None,
                 gmsa_credential_spec_name: Optional[str] = None,
                 run_as_user_name: Optional[str] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec")

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[str]:
        return pulumi.get(self, "run_as_user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplateTopicOperatorContainer(dict):
    """
    Template for the Entity Topic Operator container.
    """
    def __init__(__self__, *,
                 env: Optional[Sequence['outputs.KafkaSpecEntityOperatorTemplateTopicOperatorContainerEnv']] = None,
                 security_context: Optional['outputs.KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext'] = None):
        """
        Template for the Entity Topic Operator container.
        :param Sequence['KafkaSpecEntityOperatorTemplateTopicOperatorContainerEnvArgs'] env: Environment variables which should be applied to the container.
        :param 'KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextArgs' security_context: Security context for the container.
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)

    @property
    @pulumi.getter
    def env(self) -> Optional[Sequence['outputs.KafkaSpecEntityOperatorTemplateTopicOperatorContainerEnv']]:
        """
        Environment variables which should be applied to the container.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional['outputs.KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext']:
        """
        Security context for the container.
        """
        return pulumi.get(self, "security_context")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplateTopicOperatorContainerEnv(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The environment variable key.
        :param str value: The environment variable value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The environment variable key.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The environment variable value.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext(dict):
    """
    Security context for the container.
    """
    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[bool] = None,
                 capabilities: Optional['outputs.KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextCapabilities'] = None,
                 privileged: Optional[bool] = None,
                 proc_mount: Optional[str] = None,
                 read_only_root_filesystem: Optional[bool] = None,
                 run_as_group: Optional[int] = None,
                 run_as_non_root: Optional[bool] = None,
                 run_as_user: Optional[int] = None,
                 se_linux_options: Optional['outputs.KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions'] = None,
                 windows_options: Optional['outputs.KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptions'] = None):
        """
        Security context for the container.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if proc_mount is not None:
            pulumi.set(__self__, "proc_mount", proc_mount)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[bool]:
        return pulumi.get(self, "allow_privilege_escalation")

    @property
    @pulumi.getter
    def capabilities(self) -> Optional['outputs.KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextCapabilities']:
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def privileged(self) -> Optional[bool]:
        return pulumi.get(self, "privileged")

    @property
    @pulumi.getter(name="procMount")
    def proc_mount(self) -> Optional[str]:
        return pulumi.get(self, "proc_mount")

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[bool]:
        return pulumi.get(self, "read_only_root_filesystem")

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[int]:
        return pulumi.get(self, "run_as_group")

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[bool]:
        return pulumi.get(self, "run_as_non_root")

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[int]:
        return pulumi.get(self, "run_as_user")

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional['outputs.KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions']:
        return pulumi.get(self, "se_linux_options")

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional['outputs.KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptions']:
        return pulumi.get(self, "windows_options")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextCapabilities(dict):
    def __init__(__self__, *,
                 add: Optional[Sequence[str]] = None,
                 drop: Optional[Sequence[str]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)

    @property
    @pulumi.getter
    def add(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def drop(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "drop")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions(dict):
    def __init__(__self__, *,
                 level: Optional[str] = None,
                 role: Optional[str] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        return pulumi.get(self, "user")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptions(dict):
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[str] = None,
                 gmsa_credential_spec_name: Optional[str] = None,
                 run_as_user_name: Optional[str] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec")

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[str]:
        return pulumi.get(self, "run_as_user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplateUserOperatorContainer(dict):
    """
    Template for the Entity User Operator container.
    """
    def __init__(__self__, *,
                 env: Optional[Sequence['outputs.KafkaSpecEntityOperatorTemplateUserOperatorContainerEnv']] = None,
                 security_context: Optional['outputs.KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext'] = None):
        """
        Template for the Entity User Operator container.
        :param Sequence['KafkaSpecEntityOperatorTemplateUserOperatorContainerEnvArgs'] env: Environment variables which should be applied to the container.
        :param 'KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextArgs' security_context: Security context for the container.
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)

    @property
    @pulumi.getter
    def env(self) -> Optional[Sequence['outputs.KafkaSpecEntityOperatorTemplateUserOperatorContainerEnv']]:
        """
        Environment variables which should be applied to the container.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional['outputs.KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext']:
        """
        Security context for the container.
        """
        return pulumi.get(self, "security_context")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplateUserOperatorContainerEnv(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The environment variable key.
        :param str value: The environment variable value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The environment variable key.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The environment variable value.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext(dict):
    """
    Security context for the container.
    """
    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[bool] = None,
                 capabilities: Optional['outputs.KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextCapabilities'] = None,
                 privileged: Optional[bool] = None,
                 proc_mount: Optional[str] = None,
                 read_only_root_filesystem: Optional[bool] = None,
                 run_as_group: Optional[int] = None,
                 run_as_non_root: Optional[bool] = None,
                 run_as_user: Optional[int] = None,
                 se_linux_options: Optional['outputs.KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions'] = None,
                 windows_options: Optional['outputs.KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptions'] = None):
        """
        Security context for the container.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if proc_mount is not None:
            pulumi.set(__self__, "proc_mount", proc_mount)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[bool]:
        return pulumi.get(self, "allow_privilege_escalation")

    @property
    @pulumi.getter
    def capabilities(self) -> Optional['outputs.KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextCapabilities']:
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def privileged(self) -> Optional[bool]:
        return pulumi.get(self, "privileged")

    @property
    @pulumi.getter(name="procMount")
    def proc_mount(self) -> Optional[str]:
        return pulumi.get(self, "proc_mount")

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[bool]:
        return pulumi.get(self, "read_only_root_filesystem")

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[int]:
        return pulumi.get(self, "run_as_group")

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[bool]:
        return pulumi.get(self, "run_as_non_root")

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[int]:
        return pulumi.get(self, "run_as_user")

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional['outputs.KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions']:
        return pulumi.get(self, "se_linux_options")

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional['outputs.KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptions']:
        return pulumi.get(self, "windows_options")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextCapabilities(dict):
    def __init__(__self__, *,
                 add: Optional[Sequence[str]] = None,
                 drop: Optional[Sequence[str]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)

    @property
    @pulumi.getter
    def add(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def drop(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "drop")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions(dict):
    def __init__(__self__, *,
                 level: Optional[str] = None,
                 role: Optional[str] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        return pulumi.get(self, "user")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptions(dict):
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[str] = None,
                 gmsa_credential_spec_name: Optional[str] = None,
                 run_as_user_name: Optional[str] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec")

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[str]:
        return pulumi.get(self, "run_as_user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTlsSidecar(dict):
    """
    TLS sidecar configuration.
    """
    def __init__(__self__, *,
                 image: Optional[str] = None,
                 liveness_probe: Optional['outputs.KafkaSpecEntityOperatorTlsSidecarLivenessProbe'] = None,
                 log_level: Optional[str] = None,
                 readiness_probe: Optional['outputs.KafkaSpecEntityOperatorTlsSidecarReadinessProbe'] = None,
                 resources: Optional['outputs.KafkaSpecEntityOperatorTlsSidecarResources'] = None):
        """
        TLS sidecar configuration.
        :param str image: The docker image for the container.
        :param 'KafkaSpecEntityOperatorTlsSidecarLivenessProbeArgs' liveness_probe: Pod liveness checking.
        :param str log_level: The log level for the TLS sidecar. Default value is `notice`.
        :param 'KafkaSpecEntityOperatorTlsSidecarReadinessProbeArgs' readiness_probe: Pod readiness checking.
        :param 'KafkaSpecEntityOperatorTlsSidecarResourcesArgs' resources: CPU and memory resources to reserve.
        """
        if image is not None:
            pulumi.set(__self__, "image", image)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        The docker image for the container.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional['outputs.KafkaSpecEntityOperatorTlsSidecarLivenessProbe']:
        """
        Pod liveness checking.
        """
        return pulumi.get(self, "liveness_probe")

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[str]:
        """
        The log level for the TLS sidecar. Default value is `notice`.
        """
        return pulumi.get(self, "log_level")

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional['outputs.KafkaSpecEntityOperatorTlsSidecarReadinessProbe']:
        """
        Pod readiness checking.
        """
        return pulumi.get(self, "readiness_probe")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.KafkaSpecEntityOperatorTlsSidecarResources']:
        """
        CPU and memory resources to reserve.
        """
        return pulumi.get(self, "resources")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTlsSidecarLivenessProbe(dict):
    """
    Pod liveness checking.
    """
    def __init__(__self__, *,
                 failure_threshold: Optional[int] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 timeout_seconds: Optional[int] = None):
        """
        Pod liveness checking.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param int initial_delay_seconds: The initial delay before first the health is first checked.
        :param int period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param int timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTlsSidecarReadinessProbe(dict):
    """
    Pod readiness checking.
    """
    def __init__(__self__, *,
                 failure_threshold: Optional[int] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 timeout_seconds: Optional[int] = None):
        """
        Pod readiness checking.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param int initial_delay_seconds: The initial delay before first the health is first checked.
        :param int period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param int timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTlsSidecarResources(dict):
    """
    CPU and memory resources to reserve.
    """
    def __init__(__self__, *,
                 limits: Optional[Mapping[str, Any]] = None,
                 requests: Optional[Mapping[str, Any]] = None):
        """
        CPU and memory resources to reserve.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "requests")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTolerations(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 toleration_seconds: Optional[int] = None,
                 value: Optional[str] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if toleration_seconds is not None:
            pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> Optional[int]:
        return pulumi.get(self, "toleration_seconds")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTopicOperator(dict):
    """
    Configuration of the Topic Operator.
    """
    def __init__(__self__, *,
                 image: Optional[str] = None,
                 jvm_options: Optional['outputs.KafkaSpecEntityOperatorTopicOperatorJvmOptions'] = None,
                 liveness_probe: Optional['outputs.KafkaSpecEntityOperatorTopicOperatorLivenessProbe'] = None,
                 logging: Optional['outputs.KafkaSpecEntityOperatorTopicOperatorLogging'] = None,
                 readiness_probe: Optional['outputs.KafkaSpecEntityOperatorTopicOperatorReadinessProbe'] = None,
                 reconciliation_interval_seconds: Optional[int] = None,
                 resources: Optional['outputs.KafkaSpecEntityOperatorTopicOperatorResources'] = None,
                 topic_metadata_max_attempts: Optional[int] = None,
                 watched_namespace: Optional[str] = None,
                 zookeeper_session_timeout_seconds: Optional[int] = None):
        """
        Configuration of the Topic Operator.
        :param str image: The image to use for the Topic Operator.
        :param 'KafkaSpecEntityOperatorTopicOperatorJvmOptionsArgs' jvm_options: JVM Options for pods.
        :param 'KafkaSpecEntityOperatorTopicOperatorLivenessProbeArgs' liveness_probe: Pod liveness checking.
        :param 'KafkaSpecEntityOperatorTopicOperatorLoggingArgs' logging: Logging configuration.
        :param 'KafkaSpecEntityOperatorTopicOperatorReadinessProbeArgs' readiness_probe: Pod readiness checking.
        :param int reconciliation_interval_seconds: Interval between periodic reconciliations.
        :param 'KafkaSpecEntityOperatorTopicOperatorResourcesArgs' resources: CPU and memory resources to reserve.
        :param int topic_metadata_max_attempts: The number of attempts at getting topic metadata.
        :param str watched_namespace: The namespace the Topic Operator should watch.
        :param int zookeeper_session_timeout_seconds: Timeout for the ZooKeeper session.
        """
        if image is not None:
            pulumi.set(__self__, "image", image)
        if jvm_options is not None:
            pulumi.set(__self__, "jvm_options", jvm_options)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if reconciliation_interval_seconds is not None:
            pulumi.set(__self__, "reconciliation_interval_seconds", reconciliation_interval_seconds)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if topic_metadata_max_attempts is not None:
            pulumi.set(__self__, "topic_metadata_max_attempts", topic_metadata_max_attempts)
        if watched_namespace is not None:
            pulumi.set(__self__, "watched_namespace", watched_namespace)
        if zookeeper_session_timeout_seconds is not None:
            pulumi.set(__self__, "zookeeper_session_timeout_seconds", zookeeper_session_timeout_seconds)

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        The image to use for the Topic Operator.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="jvmOptions")
    def jvm_options(self) -> Optional['outputs.KafkaSpecEntityOperatorTopicOperatorJvmOptions']:
        """
        JVM Options for pods.
        """
        return pulumi.get(self, "jvm_options")

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional['outputs.KafkaSpecEntityOperatorTopicOperatorLivenessProbe']:
        """
        Pod liveness checking.
        """
        return pulumi.get(self, "liveness_probe")

    @property
    @pulumi.getter
    def logging(self) -> Optional['outputs.KafkaSpecEntityOperatorTopicOperatorLogging']:
        """
        Logging configuration.
        """
        return pulumi.get(self, "logging")

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional['outputs.KafkaSpecEntityOperatorTopicOperatorReadinessProbe']:
        """
        Pod readiness checking.
        """
        return pulumi.get(self, "readiness_probe")

    @property
    @pulumi.getter(name="reconciliationIntervalSeconds")
    def reconciliation_interval_seconds(self) -> Optional[int]:
        """
        Interval between periodic reconciliations.
        """
        return pulumi.get(self, "reconciliation_interval_seconds")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.KafkaSpecEntityOperatorTopicOperatorResources']:
        """
        CPU and memory resources to reserve.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter(name="topicMetadataMaxAttempts")
    def topic_metadata_max_attempts(self) -> Optional[int]:
        """
        The number of attempts at getting topic metadata.
        """
        return pulumi.get(self, "topic_metadata_max_attempts")

    @property
    @pulumi.getter(name="watchedNamespace")
    def watched_namespace(self) -> Optional[str]:
        """
        The namespace the Topic Operator should watch.
        """
        return pulumi.get(self, "watched_namespace")

    @property
    @pulumi.getter(name="zookeeperSessionTimeoutSeconds")
    def zookeeper_session_timeout_seconds(self) -> Optional[int]:
        """
        Timeout for the ZooKeeper session.
        """
        return pulumi.get(self, "zookeeper_session_timeout_seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTopicOperatorJvmOptions(dict):
    """
    JVM Options for pods.
    """
    def __init__(__self__, *,
                 __xx: Optional[Mapping[str, Any]] = None,
                 __xms: Optional[str] = None,
                 __xmx: Optional[str] = None,
                 gc_logging_enabled: Optional[bool] = None,
                 java_system_properties: Optional[Sequence['outputs.KafkaSpecEntityOperatorTopicOperatorJvmOptionsJavaSystemProperties']] = None):
        """
        JVM Options for pods.
        :param Mapping[str, Any] __xx: A map of -XX options to the JVM.
        :param str __xms: -Xms option to to the JVM.
        :param str __xmx: -Xmx option to to the JVM.
        :param bool gc_logging_enabled: Specifies whether the Garbage Collection logging is enabled. The default is false.
        :param Sequence['KafkaSpecEntityOperatorTopicOperatorJvmOptionsJavaSystemPropertiesArgs'] java_system_properties: A map of additional system properties which will be passed using the `-D` option to the JVM.
        """
        if __xx is not None:
            pulumi.set(__self__, "__xx", __xx)
        if __xms is not None:
            pulumi.set(__self__, "__xms", __xms)
        if __xmx is not None:
            pulumi.set(__self__, "__xmx", __xmx)
        if gc_logging_enabled is not None:
            pulumi.set(__self__, "gc_logging_enabled", gc_logging_enabled)
        if java_system_properties is not None:
            pulumi.set(__self__, "java_system_properties", java_system_properties)

    @property
    @pulumi.getter(name="-XX")
    def __xx(self) -> Optional[Mapping[str, Any]]:
        """
        A map of -XX options to the JVM.
        """
        return pulumi.get(self, "__xx")

    @property
    @pulumi.getter(name="-Xms")
    def __xms(self) -> Optional[str]:
        """
        -Xms option to to the JVM.
        """
        return pulumi.get(self, "__xms")

    @property
    @pulumi.getter(name="-Xmx")
    def __xmx(self) -> Optional[str]:
        """
        -Xmx option to to the JVM.
        """
        return pulumi.get(self, "__xmx")

    @property
    @pulumi.getter(name="gcLoggingEnabled")
    def gc_logging_enabled(self) -> Optional[bool]:
        """
        Specifies whether the Garbage Collection logging is enabled. The default is false.
        """
        return pulumi.get(self, "gc_logging_enabled")

    @property
    @pulumi.getter(name="javaSystemProperties")
    def java_system_properties(self) -> Optional[Sequence['outputs.KafkaSpecEntityOperatorTopicOperatorJvmOptionsJavaSystemProperties']]:
        """
        A map of additional system properties which will be passed using the `-D` option to the JVM.
        """
        return pulumi.get(self, "java_system_properties")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTopicOperatorJvmOptionsJavaSystemProperties(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The system property name.
        :param str value: The system property value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The system property name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The system property value.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTopicOperatorLivenessProbe(dict):
    """
    Pod liveness checking.
    """
    def __init__(__self__, *,
                 failure_threshold: Optional[int] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 timeout_seconds: Optional[int] = None):
        """
        Pod liveness checking.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param int initial_delay_seconds: The initial delay before first the health is first checked.
        :param int period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param int timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTopicOperatorLogging(dict):
    """
    Logging configuration.
    """
    def __init__(__self__, *,
                 type: str,
                 loggers: Optional[Mapping[str, Any]] = None,
                 name: Optional[str] = None):
        """
        Logging configuration.
        :param str type: Logging type, must be either 'inline' or 'external'.
        :param Mapping[str, Any] loggers: A Map from logger name to logger level.
        :param str name: The name of the `ConfigMap` from which to get the logging configuration.
        """
        pulumi.set(__self__, "type", type)
        if loggers is not None:
            pulumi.set(__self__, "loggers", loggers)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Logging type, must be either 'inline' or 'external'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def loggers(self) -> Optional[Mapping[str, Any]]:
        """
        A Map from logger name to logger level.
        """
        return pulumi.get(self, "loggers")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the `ConfigMap` from which to get the logging configuration.
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTopicOperatorReadinessProbe(dict):
    """
    Pod readiness checking.
    """
    def __init__(__self__, *,
                 failure_threshold: Optional[int] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 timeout_seconds: Optional[int] = None):
        """
        Pod readiness checking.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param int initial_delay_seconds: The initial delay before first the health is first checked.
        :param int period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param int timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorTopicOperatorResources(dict):
    """
    CPU and memory resources to reserve.
    """
    def __init__(__self__, *,
                 limits: Optional[Mapping[str, Any]] = None,
                 requests: Optional[Mapping[str, Any]] = None):
        """
        CPU and memory resources to reserve.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "requests")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorUserOperator(dict):
    """
    Configuration of the User Operator.
    """
    def __init__(__self__, *,
                 image: Optional[str] = None,
                 jvm_options: Optional['outputs.KafkaSpecEntityOperatorUserOperatorJvmOptions'] = None,
                 liveness_probe: Optional['outputs.KafkaSpecEntityOperatorUserOperatorLivenessProbe'] = None,
                 logging: Optional['outputs.KafkaSpecEntityOperatorUserOperatorLogging'] = None,
                 readiness_probe: Optional['outputs.KafkaSpecEntityOperatorUserOperatorReadinessProbe'] = None,
                 reconciliation_interval_seconds: Optional[int] = None,
                 resources: Optional['outputs.KafkaSpecEntityOperatorUserOperatorResources'] = None,
                 watched_namespace: Optional[str] = None,
                 zookeeper_session_timeout_seconds: Optional[int] = None):
        """
        Configuration of the User Operator.
        :param str image: The image to use for the User Operator.
        :param 'KafkaSpecEntityOperatorUserOperatorJvmOptionsArgs' jvm_options: JVM Options for pods.
        :param 'KafkaSpecEntityOperatorUserOperatorLivenessProbeArgs' liveness_probe: Pod liveness checking.
        :param 'KafkaSpecEntityOperatorUserOperatorLoggingArgs' logging: Logging configuration.
        :param 'KafkaSpecEntityOperatorUserOperatorReadinessProbeArgs' readiness_probe: Pod readiness checking.
        :param int reconciliation_interval_seconds: Interval between periodic reconciliations.
        :param 'KafkaSpecEntityOperatorUserOperatorResourcesArgs' resources: CPU and memory resources to reserve.
        :param str watched_namespace: The namespace the User Operator should watch.
        :param int zookeeper_session_timeout_seconds: Timeout for the ZooKeeper session.
        """
        if image is not None:
            pulumi.set(__self__, "image", image)
        if jvm_options is not None:
            pulumi.set(__self__, "jvm_options", jvm_options)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if reconciliation_interval_seconds is not None:
            pulumi.set(__self__, "reconciliation_interval_seconds", reconciliation_interval_seconds)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if watched_namespace is not None:
            pulumi.set(__self__, "watched_namespace", watched_namespace)
        if zookeeper_session_timeout_seconds is not None:
            pulumi.set(__self__, "zookeeper_session_timeout_seconds", zookeeper_session_timeout_seconds)

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        The image to use for the User Operator.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="jvmOptions")
    def jvm_options(self) -> Optional['outputs.KafkaSpecEntityOperatorUserOperatorJvmOptions']:
        """
        JVM Options for pods.
        """
        return pulumi.get(self, "jvm_options")

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional['outputs.KafkaSpecEntityOperatorUserOperatorLivenessProbe']:
        """
        Pod liveness checking.
        """
        return pulumi.get(self, "liveness_probe")

    @property
    @pulumi.getter
    def logging(self) -> Optional['outputs.KafkaSpecEntityOperatorUserOperatorLogging']:
        """
        Logging configuration.
        """
        return pulumi.get(self, "logging")

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional['outputs.KafkaSpecEntityOperatorUserOperatorReadinessProbe']:
        """
        Pod readiness checking.
        """
        return pulumi.get(self, "readiness_probe")

    @property
    @pulumi.getter(name="reconciliationIntervalSeconds")
    def reconciliation_interval_seconds(self) -> Optional[int]:
        """
        Interval between periodic reconciliations.
        """
        return pulumi.get(self, "reconciliation_interval_seconds")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.KafkaSpecEntityOperatorUserOperatorResources']:
        """
        CPU and memory resources to reserve.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter(name="watchedNamespace")
    def watched_namespace(self) -> Optional[str]:
        """
        The namespace the User Operator should watch.
        """
        return pulumi.get(self, "watched_namespace")

    @property
    @pulumi.getter(name="zookeeperSessionTimeoutSeconds")
    def zookeeper_session_timeout_seconds(self) -> Optional[int]:
        """
        Timeout for the ZooKeeper session.
        """
        return pulumi.get(self, "zookeeper_session_timeout_seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorUserOperatorJvmOptions(dict):
    """
    JVM Options for pods.
    """
    def __init__(__self__, *,
                 __xx: Optional[Mapping[str, Any]] = None,
                 __xms: Optional[str] = None,
                 __xmx: Optional[str] = None,
                 gc_logging_enabled: Optional[bool] = None,
                 java_system_properties: Optional[Sequence['outputs.KafkaSpecEntityOperatorUserOperatorJvmOptionsJavaSystemProperties']] = None):
        """
        JVM Options for pods.
        :param Mapping[str, Any] __xx: A map of -XX options to the JVM.
        :param str __xms: -Xms option to to the JVM.
        :param str __xmx: -Xmx option to to the JVM.
        :param bool gc_logging_enabled: Specifies whether the Garbage Collection logging is enabled. The default is false.
        :param Sequence['KafkaSpecEntityOperatorUserOperatorJvmOptionsJavaSystemPropertiesArgs'] java_system_properties: A map of additional system properties which will be passed using the `-D` option to the JVM.
        """
        if __xx is not None:
            pulumi.set(__self__, "__xx", __xx)
        if __xms is not None:
            pulumi.set(__self__, "__xms", __xms)
        if __xmx is not None:
            pulumi.set(__self__, "__xmx", __xmx)
        if gc_logging_enabled is not None:
            pulumi.set(__self__, "gc_logging_enabled", gc_logging_enabled)
        if java_system_properties is not None:
            pulumi.set(__self__, "java_system_properties", java_system_properties)

    @property
    @pulumi.getter(name="-XX")
    def __xx(self) -> Optional[Mapping[str, Any]]:
        """
        A map of -XX options to the JVM.
        """
        return pulumi.get(self, "__xx")

    @property
    @pulumi.getter(name="-Xms")
    def __xms(self) -> Optional[str]:
        """
        -Xms option to to the JVM.
        """
        return pulumi.get(self, "__xms")

    @property
    @pulumi.getter(name="-Xmx")
    def __xmx(self) -> Optional[str]:
        """
        -Xmx option to to the JVM.
        """
        return pulumi.get(self, "__xmx")

    @property
    @pulumi.getter(name="gcLoggingEnabled")
    def gc_logging_enabled(self) -> Optional[bool]:
        """
        Specifies whether the Garbage Collection logging is enabled. The default is false.
        """
        return pulumi.get(self, "gc_logging_enabled")

    @property
    @pulumi.getter(name="javaSystemProperties")
    def java_system_properties(self) -> Optional[Sequence['outputs.KafkaSpecEntityOperatorUserOperatorJvmOptionsJavaSystemProperties']]:
        """
        A map of additional system properties which will be passed using the `-D` option to the JVM.
        """
        return pulumi.get(self, "java_system_properties")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorUserOperatorJvmOptionsJavaSystemProperties(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The system property name.
        :param str value: The system property value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The system property name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The system property value.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorUserOperatorLivenessProbe(dict):
    """
    Pod liveness checking.
    """
    def __init__(__self__, *,
                 failure_threshold: Optional[int] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 timeout_seconds: Optional[int] = None):
        """
        Pod liveness checking.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param int initial_delay_seconds: The initial delay before first the health is first checked.
        :param int period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param int timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorUserOperatorLogging(dict):
    """
    Logging configuration.
    """
    def __init__(__self__, *,
                 type: str,
                 loggers: Optional[Mapping[str, Any]] = None,
                 name: Optional[str] = None):
        """
        Logging configuration.
        :param str type: Logging type, must be either 'inline' or 'external'.
        :param Mapping[str, Any] loggers: A Map from logger name to logger level.
        :param str name: The name of the `ConfigMap` from which to get the logging configuration.
        """
        pulumi.set(__self__, "type", type)
        if loggers is not None:
            pulumi.set(__self__, "loggers", loggers)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Logging type, must be either 'inline' or 'external'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def loggers(self) -> Optional[Mapping[str, Any]]:
        """
        A Map from logger name to logger level.
        """
        return pulumi.get(self, "loggers")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the `ConfigMap` from which to get the logging configuration.
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorUserOperatorReadinessProbe(dict):
    """
    Pod readiness checking.
    """
    def __init__(__self__, *,
                 failure_threshold: Optional[int] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 timeout_seconds: Optional[int] = None):
        """
        Pod readiness checking.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param int initial_delay_seconds: The initial delay before first the health is first checked.
        :param int period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param int timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecEntityOperatorUserOperatorResources(dict):
    """
    CPU and memory resources to reserve.
    """
    def __init__(__self__, *,
                 limits: Optional[Mapping[str, Any]] = None,
                 requests: Optional[Mapping[str, Any]] = None):
        """
        CPU and memory resources to reserve.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "requests")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTrans(dict):
    """
    Configuration for JmxTrans. When the property is present a JmxTrans deployment is created for gathering JMX metrics from each Kafka broker. For more information see https://github.com/jmxtrans/jmxtrans[JmxTrans GitHub].
    """
    def __init__(__self__, *,
                 kafka_queries: Sequence['outputs.KafkaSpecJmxTransKafkaQueries'],
                 output_definitions: Sequence['outputs.KafkaSpecJmxTransOutputDefinitions'],
                 image: Optional[str] = None,
                 log_level: Optional[str] = None,
                 resources: Optional['outputs.KafkaSpecJmxTransResources'] = None,
                 template: Optional['outputs.KafkaSpecJmxTransTemplate'] = None):
        """
        Configuration for JmxTrans. When the property is present a JmxTrans deployment is created for gathering JMX metrics from each Kafka broker. For more information see https://github.com/jmxtrans/jmxtrans[JmxTrans GitHub].
        :param Sequence['KafkaSpecJmxTransKafkaQueriesArgs'] kafka_queries: Queries to send to the Kafka brokers to define what data should be read from each broker. For more information on these properties see, xref:type-JmxTransQueryTemplate-reference[`JmxTransQueryTemplate` schema reference].
        :param Sequence['KafkaSpecJmxTransOutputDefinitionsArgs'] output_definitions: Defines the output hosts that will be referenced later on. For more information on these properties see, xref:type-JmxTransOutputDefinitionTemplate-reference[`JmxTransOutputDefinitionTemplate` schema reference].
        :param str image: The image to use for the JmxTrans.
        :param str log_level: Sets the logging level of the JmxTrans deployment.For more information see, https://github.com/jmxtrans/jmxtrans-agent/wiki/Troubleshooting[JmxTrans Logging Level].
        :param 'KafkaSpecJmxTransResourcesArgs' resources: CPU and memory resources to reserve.
        :param 'KafkaSpecJmxTransTemplateArgs' template: Template for JmxTrans resources.
        """
        pulumi.set(__self__, "kafka_queries", kafka_queries)
        pulumi.set(__self__, "output_definitions", output_definitions)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @property
    @pulumi.getter(name="kafkaQueries")
    def kafka_queries(self) -> Sequence['outputs.KafkaSpecJmxTransKafkaQueries']:
        """
        Queries to send to the Kafka brokers to define what data should be read from each broker. For more information on these properties see, xref:type-JmxTransQueryTemplate-reference[`JmxTransQueryTemplate` schema reference].
        """
        return pulumi.get(self, "kafka_queries")

    @property
    @pulumi.getter(name="outputDefinitions")
    def output_definitions(self) -> Sequence['outputs.KafkaSpecJmxTransOutputDefinitions']:
        """
        Defines the output hosts that will be referenced later on. For more information on these properties see, xref:type-JmxTransOutputDefinitionTemplate-reference[`JmxTransOutputDefinitionTemplate` schema reference].
        """
        return pulumi.get(self, "output_definitions")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        The image to use for the JmxTrans.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[str]:
        """
        Sets the logging level of the JmxTrans deployment.For more information see, https://github.com/jmxtrans/jmxtrans-agent/wiki/Troubleshooting[JmxTrans Logging Level].
        """
        return pulumi.get(self, "log_level")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.KafkaSpecJmxTransResources']:
        """
        CPU and memory resources to reserve.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter
    def template(self) -> Optional['outputs.KafkaSpecJmxTransTemplate']:
        """
        Template for JmxTrans resources.
        """
        return pulumi.get(self, "template")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransKafkaQueries(dict):
    def __init__(__self__, *,
                 attributes: Sequence[str],
                 outputs: Sequence[str],
                 target_m_bean: str):
        """
        :param Sequence[str] attributes: Determine which attributes of the targeted MBean should be included.
        :param Sequence[str] outputs: List of the names of output definitions specified in the spec.kafka.jmxTrans.outputDefinitions that have defined where JMX metrics are pushed to, and in which data format.
        :param str target_m_bean: If using wildcards instead of a specific MBean then the data is gathered from multiple MBeans. Otherwise if specifying an MBean then data is gathered from that specified MBean.
        """
        pulumi.set(__self__, "attributes", attributes)
        pulumi.set(__self__, "outputs", outputs)
        pulumi.set(__self__, "target_m_bean", target_m_bean)

    @property
    @pulumi.getter
    def attributes(self) -> Sequence[str]:
        """
        Determine which attributes of the targeted MBean should be included.
        """
        return pulumi.get(self, "attributes")

    @property
    @pulumi.getter
    def outputs(self) -> Sequence[str]:
        """
        List of the names of output definitions specified in the spec.kafka.jmxTrans.outputDefinitions that have defined where JMX metrics are pushed to, and in which data format.
        """
        return pulumi.get(self, "outputs")

    @property
    @pulumi.getter(name="targetMBean")
    def target_m_bean(self) -> str:
        """
        If using wildcards instead of a specific MBean then the data is gathered from multiple MBeans. Otherwise if specifying an MBean then data is gathered from that specified MBean.
        """
        return pulumi.get(self, "target_m_bean")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransOutputDefinitions(dict):
    def __init__(__self__, *,
                 name: str,
                 output_type: str,
                 flush_delay_in_seconds: Optional[int] = None,
                 host: Optional[str] = None,
                 port: Optional[int] = None,
                 type_names: Optional[Sequence[str]] = None):
        """
        :param str name: Template for setting the name of the output definition. This is used to identify where to send the results of queries should be sent.
        :param str output_type: Template for setting the format of the data that will be pushed.For more information see https://github.com/jmxtrans/jmxtrans/wiki/OutputWriters[JmxTrans OutputWriters].
        :param int flush_delay_in_seconds: How many seconds the JmxTrans waits before pushing a new set of data out.
        :param str host: The DNS/hostname of the remote host that the data is pushed to.
        :param int port: The port of the remote host that the data is pushed to.
        :param Sequence[str] type_names: Template for filtering data to be included in response to a wildcard query. For more information see https://github.com/jmxtrans/jmxtrans/wiki/Queries[JmxTrans queries].
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "output_type", output_type)
        if flush_delay_in_seconds is not None:
            pulumi.set(__self__, "flush_delay_in_seconds", flush_delay_in_seconds)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if type_names is not None:
            pulumi.set(__self__, "type_names", type_names)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Template for setting the name of the output definition. This is used to identify where to send the results of queries should be sent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="outputType")
    def output_type(self) -> str:
        """
        Template for setting the format of the data that will be pushed.For more information see https://github.com/jmxtrans/jmxtrans/wiki/OutputWriters[JmxTrans OutputWriters].
        """
        return pulumi.get(self, "output_type")

    @property
    @pulumi.getter(name="flushDelayInSeconds")
    def flush_delay_in_seconds(self) -> Optional[int]:
        """
        How many seconds the JmxTrans waits before pushing a new set of data out.
        """
        return pulumi.get(self, "flush_delay_in_seconds")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The DNS/hostname of the remote host that the data is pushed to.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port of the remote host that the data is pushed to.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="typeNames")
    def type_names(self) -> Optional[Sequence[str]]:
        """
        Template for filtering data to be included in response to a wildcard query. For more information see https://github.com/jmxtrans/jmxtrans/wiki/Queries[JmxTrans queries].
        """
        return pulumi.get(self, "type_names")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransResources(dict):
    """
    CPU and memory resources to reserve.
    """
    def __init__(__self__, *,
                 limits: Optional[Mapping[str, Any]] = None,
                 requests: Optional[Mapping[str, Any]] = None):
        """
        CPU and memory resources to reserve.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "requests")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplate(dict):
    """
    Template for JmxTrans resources.
    """
    def __init__(__self__, *,
                 container: Optional['outputs.KafkaSpecJmxTransTemplateContainer'] = None,
                 deployment: Optional['outputs.KafkaSpecJmxTransTemplateDeployment'] = None,
                 pod: Optional['outputs.KafkaSpecJmxTransTemplatePod'] = None):
        """
        Template for JmxTrans resources.
        :param 'KafkaSpecJmxTransTemplateContainerArgs' container: Template for JmxTrans container.
        :param 'KafkaSpecJmxTransTemplateDeploymentArgs' deployment: Template for JmxTrans `Deployment`.
        :param 'KafkaSpecJmxTransTemplatePodArgs' pod: Template for JmxTrans `Pods`.
        """
        if container is not None:
            pulumi.set(__self__, "container", container)
        if deployment is not None:
            pulumi.set(__self__, "deployment", deployment)
        if pod is not None:
            pulumi.set(__self__, "pod", pod)

    @property
    @pulumi.getter
    def container(self) -> Optional['outputs.KafkaSpecJmxTransTemplateContainer']:
        """
        Template for JmxTrans container.
        """
        return pulumi.get(self, "container")

    @property
    @pulumi.getter
    def deployment(self) -> Optional['outputs.KafkaSpecJmxTransTemplateDeployment']:
        """
        Template for JmxTrans `Deployment`.
        """
        return pulumi.get(self, "deployment")

    @property
    @pulumi.getter
    def pod(self) -> Optional['outputs.KafkaSpecJmxTransTemplatePod']:
        """
        Template for JmxTrans `Pods`.
        """
        return pulumi.get(self, "pod")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplateContainer(dict):
    """
    Template for JmxTrans container.
    """
    def __init__(__self__, *,
                 env: Optional[Sequence['outputs.KafkaSpecJmxTransTemplateContainerEnv']] = None,
                 security_context: Optional['outputs.KafkaSpecJmxTransTemplateContainerSecurityContext'] = None):
        """
        Template for JmxTrans container.
        :param Sequence['KafkaSpecJmxTransTemplateContainerEnvArgs'] env: Environment variables which should be applied to the container.
        :param 'KafkaSpecJmxTransTemplateContainerSecurityContextArgs' security_context: Security context for the container.
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)

    @property
    @pulumi.getter
    def env(self) -> Optional[Sequence['outputs.KafkaSpecJmxTransTemplateContainerEnv']]:
        """
        Environment variables which should be applied to the container.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional['outputs.KafkaSpecJmxTransTemplateContainerSecurityContext']:
        """
        Security context for the container.
        """
        return pulumi.get(self, "security_context")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplateContainerEnv(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The environment variable key.
        :param str value: The environment variable value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The environment variable key.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The environment variable value.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplateContainerSecurityContext(dict):
    """
    Security context for the container.
    """
    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[bool] = None,
                 capabilities: Optional['outputs.KafkaSpecJmxTransTemplateContainerSecurityContextCapabilities'] = None,
                 privileged: Optional[bool] = None,
                 proc_mount: Optional[str] = None,
                 read_only_root_filesystem: Optional[bool] = None,
                 run_as_group: Optional[int] = None,
                 run_as_non_root: Optional[bool] = None,
                 run_as_user: Optional[int] = None,
                 se_linux_options: Optional['outputs.KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions'] = None,
                 windows_options: Optional['outputs.KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptions'] = None):
        """
        Security context for the container.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if proc_mount is not None:
            pulumi.set(__self__, "proc_mount", proc_mount)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[bool]:
        return pulumi.get(self, "allow_privilege_escalation")

    @property
    @pulumi.getter
    def capabilities(self) -> Optional['outputs.KafkaSpecJmxTransTemplateContainerSecurityContextCapabilities']:
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def privileged(self) -> Optional[bool]:
        return pulumi.get(self, "privileged")

    @property
    @pulumi.getter(name="procMount")
    def proc_mount(self) -> Optional[str]:
        return pulumi.get(self, "proc_mount")

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[bool]:
        return pulumi.get(self, "read_only_root_filesystem")

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[int]:
        return pulumi.get(self, "run_as_group")

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[bool]:
        return pulumi.get(self, "run_as_non_root")

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[int]:
        return pulumi.get(self, "run_as_user")

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional['outputs.KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions']:
        return pulumi.get(self, "se_linux_options")

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional['outputs.KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptions']:
        return pulumi.get(self, "windows_options")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplateContainerSecurityContextCapabilities(dict):
    def __init__(__self__, *,
                 add: Optional[Sequence[str]] = None,
                 drop: Optional[Sequence[str]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)

    @property
    @pulumi.getter
    def add(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def drop(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "drop")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions(dict):
    def __init__(__self__, *,
                 level: Optional[str] = None,
                 role: Optional[str] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        return pulumi.get(self, "user")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptions(dict):
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[str] = None,
                 gmsa_credential_spec_name: Optional[str] = None,
                 run_as_user_name: Optional[str] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec")

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[str]:
        return pulumi.get(self, "run_as_user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplateDeployment(dict):
    """
    Template for JmxTrans `Deployment`.
    """
    def __init__(__self__, *,
                 metadata: Optional['outputs.KafkaSpecJmxTransTemplateDeploymentMetadata'] = None):
        """
        Template for JmxTrans `Deployment`.
        :param 'KafkaSpecJmxTransTemplateDeploymentMetadataArgs' metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaSpecJmxTransTemplateDeploymentMetadata']:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplateDeploymentMetadata(dict):
    """
    Metadata applied to the resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata applied to the resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplatePod(dict):
    """
    Template for JmxTrans `Pods`.
    """
    def __init__(__self__, *,
                 affinity: Optional['outputs.KafkaSpecJmxTransTemplatePodAffinity'] = None,
                 host_aliases: Optional[Sequence['outputs.KafkaSpecJmxTransTemplatePodHostAliases']] = None,
                 image_pull_secrets: Optional[Sequence['outputs.KafkaSpecJmxTransTemplatePodImagePullSecrets']] = None,
                 metadata: Optional['outputs.KafkaSpecJmxTransTemplatePodMetadata'] = None,
                 priority_class_name: Optional[str] = None,
                 scheduler_name: Optional[str] = None,
                 security_context: Optional['outputs.KafkaSpecJmxTransTemplatePodSecurityContext'] = None,
                 termination_grace_period_seconds: Optional[int] = None,
                 tolerations: Optional[Sequence['outputs.KafkaSpecJmxTransTemplatePodTolerations']] = None):
        """
        Template for JmxTrans `Pods`.
        :param 'KafkaSpecJmxTransTemplatePodAffinityArgs' affinity: The pod's affinity rules.
        :param Sequence['KafkaSpecJmxTransTemplatePodHostAliasesArgs'] host_aliases: The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
        :param Sequence['KafkaSpecJmxTransTemplatePodImagePullSecretsArgs'] image_pull_secrets: List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
        :param 'KafkaSpecJmxTransTemplatePodMetadataArgs' metadata: Metadata applied to the resource.
        :param str priority_class_name: The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
        :param str scheduler_name: The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
        :param 'KafkaSpecJmxTransTemplatePodSecurityContextArgs' security_context: Configures pod-level security attributes and common container settings.
        :param int termination_grace_period_seconds: The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
        :param Sequence['KafkaSpecJmxTransTemplatePodTolerationsArgs'] tolerations: The pod's tolerations.
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if host_aliases is not None:
            pulumi.set(__self__, "host_aliases", host_aliases)
        if image_pull_secrets is not None:
            pulumi.set(__self__, "image_pull_secrets", image_pull_secrets)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if priority_class_name is not None:
            pulumi.set(__self__, "priority_class_name", priority_class_name)
        if scheduler_name is not None:
            pulumi.set(__self__, "scheduler_name", scheduler_name)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)

    @property
    @pulumi.getter
    def affinity(self) -> Optional['outputs.KafkaSpecJmxTransTemplatePodAffinity']:
        """
        The pod's affinity rules.
        """
        return pulumi.get(self, "affinity")

    @property
    @pulumi.getter(name="hostAliases")
    def host_aliases(self) -> Optional[Sequence['outputs.KafkaSpecJmxTransTemplatePodHostAliases']]:
        """
        The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
        """
        return pulumi.get(self, "host_aliases")

    @property
    @pulumi.getter(name="imagePullSecrets")
    def image_pull_secrets(self) -> Optional[Sequence['outputs.KafkaSpecJmxTransTemplatePodImagePullSecrets']]:
        """
        List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
        """
        return pulumi.get(self, "image_pull_secrets")

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaSpecJmxTransTemplatePodMetadata']:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter(name="priorityClassName")
    def priority_class_name(self) -> Optional[str]:
        """
        The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
        """
        return pulumi.get(self, "priority_class_name")

    @property
    @pulumi.getter(name="schedulerName")
    def scheduler_name(self) -> Optional[str]:
        """
        The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
        """
        return pulumi.get(self, "scheduler_name")

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional['outputs.KafkaSpecJmxTransTemplatePodSecurityContext']:
        """
        Configures pod-level security attributes and common container settings.
        """
        return pulumi.get(self, "security_context")

    @property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[int]:
        """
        The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
        """
        return pulumi.get(self, "termination_grace_period_seconds")

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[Sequence['outputs.KafkaSpecJmxTransTemplatePodTolerations']]:
        """
        The pod's tolerations.
        """
        return pulumi.get(self, "tolerations")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplatePodAffinity(dict):
    """
    The pod's affinity rules.
    """
    def __init__(__self__, *,
                 node_affinity: Optional['outputs.KafkaSpecJmxTransTemplatePodAffinityNodeAffinity'] = None,
                 pod_affinity: Optional['outputs.KafkaSpecJmxTransTemplatePodAffinityPodAffinity'] = None,
                 pod_anti_affinity: Optional['outputs.KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinity'] = None):
        """
        The pod's affinity rules.
        """
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional['outputs.KafkaSpecJmxTransTemplatePodAffinityNodeAffinity']:
        return pulumi.get(self, "node_affinity")

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional['outputs.KafkaSpecJmxTransTemplatePodAffinityPodAffinity']:
        return pulumi.get(self, "pod_affinity")

    @property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional['outputs.KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinity']:
        return pulumi.get(self, "pod_anti_affinity")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplatePodAffinityNodeAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional['outputs.KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution'] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional['outputs.KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution']:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 preference: Optional['outputs.KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference'] = None,
                 weight: Optional[int] = None):
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preference(self) -> Optional['outputs.KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference']:
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions']] = None,
                 match_fields: Optional[Sequence['outputs.KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields']] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields']]:
        return pulumi.get(self, "match_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 node_selector_terms: Optional[Sequence['outputs.KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms']] = None):
        if node_selector_terms is not None:
            pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> Optional[Sequence['outputs.KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms']]:
        return pulumi.get(self, "node_selector_terms")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions']] = None,
                 match_fields: Optional[Sequence['outputs.KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields']] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields']]:
        return pulumi.get(self, "match_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplatePodAffinityPodAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 pod_affinity_term: Optional['outputs.KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm'] = None,
                 weight: Optional[int] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional['outputs.KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm']:
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 pod_affinity_term: Optional['outputs.KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm'] = None,
                 weight: Optional[int] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional['outputs.KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm']:
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplatePodHostAliases(dict):
    def __init__(__self__, *,
                 hostnames: Optional[Sequence[str]] = None,
                 ip: Optional[str] = None):
        if hostnames is not None:
            pulumi.set(__self__, "hostnames", hostnames)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def hostnames(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "hostnames")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        return pulumi.get(self, "ip")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplatePodImagePullSecrets(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplatePodMetadata(dict):
    """
    Metadata applied to the resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata applied to the resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplatePodSecurityContext(dict):
    """
    Configures pod-level security attributes and common container settings.
    """
    def __init__(__self__, *,
                 fs_group: Optional[int] = None,
                 fs_group_change_policy: Optional[str] = None,
                 run_as_group: Optional[int] = None,
                 run_as_non_root: Optional[bool] = None,
                 run_as_user: Optional[int] = None,
                 se_linux_options: Optional['outputs.KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions'] = None,
                 supplemental_groups: Optional[Sequence[int]] = None,
                 sysctls: Optional[Sequence['outputs.KafkaSpecJmxTransTemplatePodSecurityContextSysctls']] = None,
                 windows_options: Optional['outputs.KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptions'] = None):
        """
        Configures pod-level security attributes and common container settings.
        """
        if fs_group is not None:
            pulumi.set(__self__, "fs_group", fs_group)
        if fs_group_change_policy is not None:
            pulumi.set(__self__, "fs_group_change_policy", fs_group_change_policy)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if supplemental_groups is not None:
            pulumi.set(__self__, "supplemental_groups", supplemental_groups)
        if sysctls is not None:
            pulumi.set(__self__, "sysctls", sysctls)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="fsGroup")
    def fs_group(self) -> Optional[int]:
        return pulumi.get(self, "fs_group")

    @property
    @pulumi.getter(name="fsGroupChangePolicy")
    def fs_group_change_policy(self) -> Optional[str]:
        return pulumi.get(self, "fs_group_change_policy")

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[int]:
        return pulumi.get(self, "run_as_group")

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[bool]:
        return pulumi.get(self, "run_as_non_root")

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[int]:
        return pulumi.get(self, "run_as_user")

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional['outputs.KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions']:
        return pulumi.get(self, "se_linux_options")

    @property
    @pulumi.getter(name="supplementalGroups")
    def supplemental_groups(self) -> Optional[Sequence[int]]:
        return pulumi.get(self, "supplemental_groups")

    @property
    @pulumi.getter
    def sysctls(self) -> Optional[Sequence['outputs.KafkaSpecJmxTransTemplatePodSecurityContextSysctls']]:
        return pulumi.get(self, "sysctls")

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional['outputs.KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptions']:
        return pulumi.get(self, "windows_options")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions(dict):
    def __init__(__self__, *,
                 level: Optional[str] = None,
                 role: Optional[str] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        return pulumi.get(self, "user")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplatePodSecurityContextSysctls(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptions(dict):
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[str] = None,
                 gmsa_credential_spec_name: Optional[str] = None,
                 run_as_user_name: Optional[str] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec")

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[str]:
        return pulumi.get(self, "run_as_user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecJmxTransTemplatePodTolerations(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 toleration_seconds: Optional[int] = None,
                 value: Optional[str] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if toleration_seconds is not None:
            pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> Optional[int]:
        return pulumi.get(self, "toleration_seconds")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafka(dict):
    """
    Configuration of the Kafka cluster.
    """
    def __init__(__self__, *,
                 listeners: Any,
                 replicas: int,
                 storage: 'outputs.KafkaSpecKafkaStorage',
                 affinity: Optional['outputs.KafkaSpecKafkaAffinity'] = None,
                 authorization: Optional['outputs.KafkaSpecKafkaAuthorization'] = None,
                 broker_rack_init_image: Optional[str] = None,
                 config: Optional[Mapping[str, Any]] = None,
                 image: Optional[str] = None,
                 jmx_options: Optional['outputs.KafkaSpecKafkaJmxOptions'] = None,
                 jvm_options: Optional['outputs.KafkaSpecKafkaJvmOptions'] = None,
                 liveness_probe: Optional['outputs.KafkaSpecKafkaLivenessProbe'] = None,
                 logging: Optional['outputs.KafkaSpecKafkaLogging'] = None,
                 metrics: Optional[Mapping[str, Any]] = None,
                 rack: Optional['outputs.KafkaSpecKafkaRack'] = None,
                 readiness_probe: Optional['outputs.KafkaSpecKafkaReadinessProbe'] = None,
                 resources: Optional['outputs.KafkaSpecKafkaResources'] = None,
                 template: Optional['outputs.KafkaSpecKafkaTemplate'] = None,
                 tls_sidecar: Optional['outputs.KafkaSpecKafkaTlsSidecar'] = None,
                 tolerations: Optional[Sequence['outputs.KafkaSpecKafkaTolerations']] = None,
                 version: Optional[str] = None):
        """
        Configuration of the Kafka cluster.
        :param int replicas: The number of pods in the cluster.
        :param 'KafkaSpecKafkaStorageArgs' storage: Storage configuration (disk). Cannot be updated.
        :param 'KafkaSpecKafkaAffinityArgs' affinity: The pod's affinity rules.
        :param 'KafkaSpecKafkaAuthorizationArgs' authorization: Authorization configuration for Kafka brokers.
        :param str broker_rack_init_image: The image of the init container used for initializing the `broker.rack`.
        :param Mapping[str, Any] config: Kafka broker config properties with the following prefixes cannot be set: listeners, advertised., broker., listener., host.name, port, inter.broker.listener.name, sasl., ssl., security., password., principal.builder.class, log.dir, zookeeper.connect, zookeeper.set.acl, zookeeper.ssl, zookeeper.clientCnxnSocket, authorizer., super.user, cruise.control.metrics.topic, cruise.control.metrics.reporter.bootstrap.servers (with the exception of: zookeeper.connection.timeout.ms, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols,cruise.control.metrics.topic.num.partitions, cruise.control.metrics.topic.replication.factor, cruise.control.metrics.topic.retention.ms,cruise.control.metrics.topic.auto.create.retries, cruise.control.metrics.topic.auto.create.timeout.ms).
        :param str image: The docker image for the pods. The default value depends on the configured `Kafka.spec.kafka.version`.
        :param 'KafkaSpecKafkaJmxOptionsArgs' jmx_options: JMX Options for Kafka brokers.
        :param 'KafkaSpecKafkaJvmOptionsArgs' jvm_options: JVM Options for pods.
        :param 'KafkaSpecKafkaLivenessProbeArgs' liveness_probe: Pod liveness checking.
        :param 'KafkaSpecKafkaLoggingArgs' logging: Logging configuration for Kafka.
        :param Mapping[str, Any] metrics: The Prometheus JMX Exporter configuration. See https://github.com/prometheus/jmx_exporter for details of the structure of this configuration.
        :param 'KafkaSpecKafkaRackArgs' rack: Configuration of the `broker.rack` broker config.
        :param 'KafkaSpecKafkaReadinessProbeArgs' readiness_probe: Pod readiness checking.
        :param 'KafkaSpecKafkaResourcesArgs' resources: CPU and memory resources to reserve.
        :param 'KafkaSpecKafkaTemplateArgs' template: Template for Kafka cluster resources. The template allows users to specify how are the `StatefulSet`, `Pods` and `Services` generated.
        :param 'KafkaSpecKafkaTlsSidecarArgs' tls_sidecar: TLS sidecar configuration.
        :param Sequence['KafkaSpecKafkaTolerationsArgs'] tolerations: The pod's tolerations.
        :param str version: The kafka broker version. Defaults to {DefaultKafkaVersion}. Consult the user documentation to understand the process required to upgrade or downgrade the version.
        """
        pulumi.set(__self__, "listeners", listeners)
        pulumi.set(__self__, "replicas", replicas)
        pulumi.set(__self__, "storage", storage)
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if authorization is not None:
            pulumi.set(__self__, "authorization", authorization)
        if broker_rack_init_image is not None:
            pulumi.set(__self__, "broker_rack_init_image", broker_rack_init_image)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if jmx_options is not None:
            pulumi.set(__self__, "jmx_options", jmx_options)
        if jvm_options is not None:
            pulumi.set(__self__, "jvm_options", jvm_options)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if rack is not None:
            pulumi.set(__self__, "rack", rack)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if template is not None:
            pulumi.set(__self__, "template", template)
        if tls_sidecar is not None:
            pulumi.set(__self__, "tls_sidecar", tls_sidecar)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def listeners(self) -> Any:
        return pulumi.get(self, "listeners")

    @property
    @pulumi.getter
    def replicas(self) -> int:
        """
        The number of pods in the cluster.
        """
        return pulumi.get(self, "replicas")

    @property
    @pulumi.getter
    def storage(self) -> 'outputs.KafkaSpecKafkaStorage':
        """
        Storage configuration (disk). Cannot be updated.
        """
        return pulumi.get(self, "storage")

    @property
    @pulumi.getter
    def affinity(self) -> Optional['outputs.KafkaSpecKafkaAffinity']:
        """
        The pod's affinity rules.
        """
        return pulumi.get(self, "affinity")

    @property
    @pulumi.getter
    def authorization(self) -> Optional['outputs.KafkaSpecKafkaAuthorization']:
        """
        Authorization configuration for Kafka brokers.
        """
        return pulumi.get(self, "authorization")

    @property
    @pulumi.getter(name="brokerRackInitImage")
    def broker_rack_init_image(self) -> Optional[str]:
        """
        The image of the init container used for initializing the `broker.rack`.
        """
        return pulumi.get(self, "broker_rack_init_image")

    @property
    @pulumi.getter
    def config(self) -> Optional[Mapping[str, Any]]:
        """
        Kafka broker config properties with the following prefixes cannot be set: listeners, advertised., broker., listener., host.name, port, inter.broker.listener.name, sasl., ssl., security., password., principal.builder.class, log.dir, zookeeper.connect, zookeeper.set.acl, zookeeper.ssl, zookeeper.clientCnxnSocket, authorizer., super.user, cruise.control.metrics.topic, cruise.control.metrics.reporter.bootstrap.servers (with the exception of: zookeeper.connection.timeout.ms, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols,cruise.control.metrics.topic.num.partitions, cruise.control.metrics.topic.replication.factor, cruise.control.metrics.topic.retention.ms,cruise.control.metrics.topic.auto.create.retries, cruise.control.metrics.topic.auto.create.timeout.ms).
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        The docker image for the pods. The default value depends on the configured `Kafka.spec.kafka.version`.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="jmxOptions")
    def jmx_options(self) -> Optional['outputs.KafkaSpecKafkaJmxOptions']:
        """
        JMX Options for Kafka brokers.
        """
        return pulumi.get(self, "jmx_options")

    @property
    @pulumi.getter(name="jvmOptions")
    def jvm_options(self) -> Optional['outputs.KafkaSpecKafkaJvmOptions']:
        """
        JVM Options for pods.
        """
        return pulumi.get(self, "jvm_options")

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional['outputs.KafkaSpecKafkaLivenessProbe']:
        """
        Pod liveness checking.
        """
        return pulumi.get(self, "liveness_probe")

    @property
    @pulumi.getter
    def logging(self) -> Optional['outputs.KafkaSpecKafkaLogging']:
        """
        Logging configuration for Kafka.
        """
        return pulumi.get(self, "logging")

    @property
    @pulumi.getter
    def metrics(self) -> Optional[Mapping[str, Any]]:
        """
        The Prometheus JMX Exporter configuration. See https://github.com/prometheus/jmx_exporter for details of the structure of this configuration.
        """
        return pulumi.get(self, "metrics")

    @property
    @pulumi.getter
    def rack(self) -> Optional['outputs.KafkaSpecKafkaRack']:
        """
        Configuration of the `broker.rack` broker config.
        """
        return pulumi.get(self, "rack")

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional['outputs.KafkaSpecKafkaReadinessProbe']:
        """
        Pod readiness checking.
        """
        return pulumi.get(self, "readiness_probe")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.KafkaSpecKafkaResources']:
        """
        CPU and memory resources to reserve.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter
    def template(self) -> Optional['outputs.KafkaSpecKafkaTemplate']:
        """
        Template for Kafka cluster resources. The template allows users to specify how are the `StatefulSet`, `Pods` and `Services` generated.
        """
        return pulumi.get(self, "template")

    @property
    @pulumi.getter(name="tlsSidecar")
    def tls_sidecar(self) -> Optional['outputs.KafkaSpecKafkaTlsSidecar']:
        """
        TLS sidecar configuration.
        """
        return pulumi.get(self, "tls_sidecar")

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[Sequence['outputs.KafkaSpecKafkaTolerations']]:
        """
        The pod's tolerations.
        """
        return pulumi.get(self, "tolerations")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        The kafka broker version. Defaults to {DefaultKafkaVersion}. Consult the user documentation to understand the process required to upgrade or downgrade the version.
        """
        return pulumi.get(self, "version")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaAffinity(dict):
    """
    The pod's affinity rules.
    """
    def __init__(__self__, *,
                 node_affinity: Optional['outputs.KafkaSpecKafkaAffinityNodeAffinity'] = None,
                 pod_affinity: Optional['outputs.KafkaSpecKafkaAffinityPodAffinity'] = None,
                 pod_anti_affinity: Optional['outputs.KafkaSpecKafkaAffinityPodAntiAffinity'] = None):
        """
        The pod's affinity rules.
        """
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional['outputs.KafkaSpecKafkaAffinityNodeAffinity']:
        return pulumi.get(self, "node_affinity")

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional['outputs.KafkaSpecKafkaAffinityPodAffinity']:
        return pulumi.get(self, "pod_affinity")

    @property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional['outputs.KafkaSpecKafkaAffinityPodAntiAffinity']:
        return pulumi.get(self, "pod_anti_affinity")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaAffinityNodeAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional['outputs.KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution'] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional['outputs.KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution']:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 preference: Optional['outputs.KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference'] = None,
                 weight: Optional[int] = None):
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preference(self) -> Optional['outputs.KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference']:
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions']] = None,
                 match_fields: Optional[Sequence['outputs.KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields']] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields']]:
        return pulumi.get(self, "match_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 node_selector_terms: Optional[Sequence['outputs.KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms']] = None):
        if node_selector_terms is not None:
            pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> Optional[Sequence['outputs.KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms']]:
        return pulumi.get(self, "node_selector_terms")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions']] = None,
                 match_fields: Optional[Sequence['outputs.KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields']] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields']]:
        return pulumi.get(self, "match_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaAffinityPodAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 pod_affinity_term: Optional['outputs.KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm'] = None,
                 weight: Optional[int] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional['outputs.KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm']:
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaAffinityPodAntiAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 pod_affinity_term: Optional['outputs.KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm'] = None,
                 weight: Optional[int] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional['outputs.KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm']:
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaAuthorization(dict):
    """
    Authorization configuration for Kafka brokers.
    """
    def __init__(__self__, *,
                 type: str,
                 allow_on_error: Optional[bool] = None,
                 client_id: Optional[str] = None,
                 delegate_to_kafka_acls: Optional[bool] = None,
                 disable_tls_hostname_verification: Optional[bool] = None,
                 expire_after_ms: Optional[int] = None,
                 grants_refresh_period_seconds: Optional[int] = None,
                 grants_refresh_pool_size: Optional[int] = None,
                 initial_cache_capacity: Optional[int] = None,
                 maximum_cache_size: Optional[int] = None,
                 super_users: Optional[Sequence[str]] = None,
                 tls_trusted_certificates: Optional[Sequence['outputs.KafkaSpecKafkaAuthorizationTlsTrustedCertificates']] = None,
                 token_endpoint_uri: Optional[str] = None,
                 url: Optional[str] = None):
        """
        Authorization configuration for Kafka brokers.
        :param str type: Authorization type. Currently, the supported types are `simple`, `keycloak`, and `opa`. `simple` authorization type uses Kafka's `kafka.security.authorizer.AclAuthorizer` class for authorization. `keycloak` authorization type uses Keycloak Authorization Services for authorization. `opa` authorization type uses Open Policy Agent based authorization.
        :param bool allow_on_error: Defines whether a Kafka client should be allowed or denied by default when the authorizer fails to query the Open Policy Agent, for example, when it is temporarily unavailable). Defaults to `false` - all actions will be denied.
        :param str client_id: OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        :param bool delegate_to_kafka_acls: Whether authorization decision should be delegated to the 'Simple' authorizer if DENIED by Keycloak Authorization Services policies. Default value is `false`.
        :param bool disable_tls_hostname_verification: Enable or disable TLS hostname verification. Default value is `false`.
        :param int expire_after_ms: The expiration of the records kept in the local cache to avoid querying the Open Policy Agent for every request. Defines how often the cached authorization decisions are reloaded from the Open Policy Agent server. In milliseconds. Defaults to `3600000`.
        :param int grants_refresh_period_seconds: The time between two consecutive grants refresh runs in seconds. The default value is 60.
        :param int grants_refresh_pool_size: The number of threads to use to refresh grants for active sessions. The more threads, the more parallelism, so the sooner the job completes. However, using more threads places a heavier load on the authorization server. The default value is 5.
        :param int initial_cache_capacity: Initial capacity of the local cache used by the authorizer to avoid querying the Open Policy Agent for every request Defaults to `5000`.
        :param int maximum_cache_size: Maximum capacity of the local cache used by the authorizer to avoid querying the Open Policy Agent for every request. Defaults to `50000`.
        :param Sequence[str] super_users: List of super users. Should contain list of user principals which should get unlimited access rights.
        :param Sequence['KafkaSpecKafkaAuthorizationTlsTrustedCertificatesArgs'] tls_trusted_certificates: Trusted certificates for TLS connection to the OAuth server.
        :param str token_endpoint_uri: Authorization server token endpoint URI.
        :param str url: The URL used to connect to the Open Policy Agent server. The URL has to include the policy which will be queried by the authorizer. This option is required.
        """
        pulumi.set(__self__, "type", type)
        if allow_on_error is not None:
            pulumi.set(__self__, "allow_on_error", allow_on_error)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if delegate_to_kafka_acls is not None:
            pulumi.set(__self__, "delegate_to_kafka_acls", delegate_to_kafka_acls)
        if disable_tls_hostname_verification is not None:
            pulumi.set(__self__, "disable_tls_hostname_verification", disable_tls_hostname_verification)
        if expire_after_ms is not None:
            pulumi.set(__self__, "expire_after_ms", expire_after_ms)
        if grants_refresh_period_seconds is not None:
            pulumi.set(__self__, "grants_refresh_period_seconds", grants_refresh_period_seconds)
        if grants_refresh_pool_size is not None:
            pulumi.set(__self__, "grants_refresh_pool_size", grants_refresh_pool_size)
        if initial_cache_capacity is not None:
            pulumi.set(__self__, "initial_cache_capacity", initial_cache_capacity)
        if maximum_cache_size is not None:
            pulumi.set(__self__, "maximum_cache_size", maximum_cache_size)
        if super_users is not None:
            pulumi.set(__self__, "super_users", super_users)
        if tls_trusted_certificates is not None:
            pulumi.set(__self__, "tls_trusted_certificates", tls_trusted_certificates)
        if token_endpoint_uri is not None:
            pulumi.set(__self__, "token_endpoint_uri", token_endpoint_uri)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Authorization type. Currently, the supported types are `simple`, `keycloak`, and `opa`. `simple` authorization type uses Kafka's `kafka.security.authorizer.AclAuthorizer` class for authorization. `keycloak` authorization type uses Keycloak Authorization Services for authorization. `opa` authorization type uses Open Policy Agent based authorization.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="allowOnError")
    def allow_on_error(self) -> Optional[bool]:
        """
        Defines whether a Kafka client should be allowed or denied by default when the authorizer fails to query the Open Policy Agent, for example, when it is temporarily unavailable). Defaults to `false` - all actions will be denied.
        """
        return pulumi.get(self, "allow_on_error")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="delegateToKafkaAcls")
    def delegate_to_kafka_acls(self) -> Optional[bool]:
        """
        Whether authorization decision should be delegated to the 'Simple' authorizer if DENIED by Keycloak Authorization Services policies. Default value is `false`.
        """
        return pulumi.get(self, "delegate_to_kafka_acls")

    @property
    @pulumi.getter(name="disableTlsHostnameVerification")
    def disable_tls_hostname_verification(self) -> Optional[bool]:
        """
        Enable or disable TLS hostname verification. Default value is `false`.
        """
        return pulumi.get(self, "disable_tls_hostname_verification")

    @property
    @pulumi.getter(name="expireAfterMs")
    def expire_after_ms(self) -> Optional[int]:
        """
        The expiration of the records kept in the local cache to avoid querying the Open Policy Agent for every request. Defines how often the cached authorization decisions are reloaded from the Open Policy Agent server. In milliseconds. Defaults to `3600000`.
        """
        return pulumi.get(self, "expire_after_ms")

    @property
    @pulumi.getter(name="grantsRefreshPeriodSeconds")
    def grants_refresh_period_seconds(self) -> Optional[int]:
        """
        The time between two consecutive grants refresh runs in seconds. The default value is 60.
        """
        return pulumi.get(self, "grants_refresh_period_seconds")

    @property
    @pulumi.getter(name="grantsRefreshPoolSize")
    def grants_refresh_pool_size(self) -> Optional[int]:
        """
        The number of threads to use to refresh grants for active sessions. The more threads, the more parallelism, so the sooner the job completes. However, using more threads places a heavier load on the authorization server. The default value is 5.
        """
        return pulumi.get(self, "grants_refresh_pool_size")

    @property
    @pulumi.getter(name="initialCacheCapacity")
    def initial_cache_capacity(self) -> Optional[int]:
        """
        Initial capacity of the local cache used by the authorizer to avoid querying the Open Policy Agent for every request Defaults to `5000`.
        """
        return pulumi.get(self, "initial_cache_capacity")

    @property
    @pulumi.getter(name="maximumCacheSize")
    def maximum_cache_size(self) -> Optional[int]:
        """
        Maximum capacity of the local cache used by the authorizer to avoid querying the Open Policy Agent for every request. Defaults to `50000`.
        """
        return pulumi.get(self, "maximum_cache_size")

    @property
    @pulumi.getter(name="superUsers")
    def super_users(self) -> Optional[Sequence[str]]:
        """
        List of super users. Should contain list of user principals which should get unlimited access rights.
        """
        return pulumi.get(self, "super_users")

    @property
    @pulumi.getter(name="tlsTrustedCertificates")
    def tls_trusted_certificates(self) -> Optional[Sequence['outputs.KafkaSpecKafkaAuthorizationTlsTrustedCertificates']]:
        """
        Trusted certificates for TLS connection to the OAuth server.
        """
        return pulumi.get(self, "tls_trusted_certificates")

    @property
    @pulumi.getter(name="tokenEndpointUri")
    def token_endpoint_uri(self) -> Optional[str]:
        """
        Authorization server token endpoint URI.
        """
        return pulumi.get(self, "token_endpoint_uri")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The URL used to connect to the Open Policy Agent server. The URL has to include the policy which will be queried by the authorizer. This option is required.
        """
        return pulumi.get(self, "url")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaAuthorizationTlsTrustedCertificates(dict):
    def __init__(__self__, *,
                 certificate: str,
                 secret_name: str):
        """
        :param str certificate: The name of the file certificate in the Secret.
        :param str secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> str:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporter(dict):
    """
    Configuration of the Kafka Exporter. Kafka Exporter can provide additional metrics, for example lag of consumer group at topic/partition.
    """
    def __init__(__self__, *,
                 enable_sarama_logging: Optional[bool] = None,
                 group_regex: Optional[str] = None,
                 image: Optional[str] = None,
                 liveness_probe: Optional['outputs.KafkaSpecKafkaExporterLivenessProbe'] = None,
                 logging: Optional[str] = None,
                 readiness_probe: Optional['outputs.KafkaSpecKafkaExporterReadinessProbe'] = None,
                 resources: Optional['outputs.KafkaSpecKafkaExporterResources'] = None,
                 template: Optional['outputs.KafkaSpecKafkaExporterTemplate'] = None,
                 topic_regex: Optional[str] = None):
        """
        Configuration of the Kafka Exporter. Kafka Exporter can provide additional metrics, for example lag of consumer group at topic/partition.
        :param bool enable_sarama_logging: Enable Sarama logging, a Go client library used by the Kafka Exporter.
        :param str group_regex: Regular expression to specify which consumer groups to collect. Default value is `.*`.
        :param str image: The docker image for the pods.
        :param 'KafkaSpecKafkaExporterLivenessProbeArgs' liveness_probe: Pod liveness check.
        :param str logging: Only log messages with the given severity or above. Valid levels: [`debug`, `info`, `warn`, `error`, `fatal`]. Default log level is `info`.
        :param 'KafkaSpecKafkaExporterReadinessProbeArgs' readiness_probe: Pod readiness check.
        :param 'KafkaSpecKafkaExporterResourcesArgs' resources: CPU and memory resources to reserve.
        :param 'KafkaSpecKafkaExporterTemplateArgs' template: Customization of deployment templates and pods.
        :param str topic_regex: Regular expression to specify which topics to collect. Default value is `.*`.
        """
        if enable_sarama_logging is not None:
            pulumi.set(__self__, "enable_sarama_logging", enable_sarama_logging)
        if group_regex is not None:
            pulumi.set(__self__, "group_regex", group_regex)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if template is not None:
            pulumi.set(__self__, "template", template)
        if topic_regex is not None:
            pulumi.set(__self__, "topic_regex", topic_regex)

    @property
    @pulumi.getter(name="enableSaramaLogging")
    def enable_sarama_logging(self) -> Optional[bool]:
        """
        Enable Sarama logging, a Go client library used by the Kafka Exporter.
        """
        return pulumi.get(self, "enable_sarama_logging")

    @property
    @pulumi.getter(name="groupRegex")
    def group_regex(self) -> Optional[str]:
        """
        Regular expression to specify which consumer groups to collect. Default value is `.*`.
        """
        return pulumi.get(self, "group_regex")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        The docker image for the pods.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional['outputs.KafkaSpecKafkaExporterLivenessProbe']:
        """
        Pod liveness check.
        """
        return pulumi.get(self, "liveness_probe")

    @property
    @pulumi.getter
    def logging(self) -> Optional[str]:
        """
        Only log messages with the given severity or above. Valid levels: [`debug`, `info`, `warn`, `error`, `fatal`]. Default log level is `info`.
        """
        return pulumi.get(self, "logging")

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional['outputs.KafkaSpecKafkaExporterReadinessProbe']:
        """
        Pod readiness check.
        """
        return pulumi.get(self, "readiness_probe")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.KafkaSpecKafkaExporterResources']:
        """
        CPU and memory resources to reserve.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter
    def template(self) -> Optional['outputs.KafkaSpecKafkaExporterTemplate']:
        """
        Customization of deployment templates and pods.
        """
        return pulumi.get(self, "template")

    @property
    @pulumi.getter(name="topicRegex")
    def topic_regex(self) -> Optional[str]:
        """
        Regular expression to specify which topics to collect. Default value is `.*`.
        """
        return pulumi.get(self, "topic_regex")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterLivenessProbe(dict):
    """
    Pod liveness check.
    """
    def __init__(__self__, *,
                 failure_threshold: Optional[int] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 timeout_seconds: Optional[int] = None):
        """
        Pod liveness check.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param int initial_delay_seconds: The initial delay before first the health is first checked.
        :param int period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param int timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterReadinessProbe(dict):
    """
    Pod readiness check.
    """
    def __init__(__self__, *,
                 failure_threshold: Optional[int] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 timeout_seconds: Optional[int] = None):
        """
        Pod readiness check.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param int initial_delay_seconds: The initial delay before first the health is first checked.
        :param int period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param int timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterResources(dict):
    """
    CPU and memory resources to reserve.
    """
    def __init__(__self__, *,
                 limits: Optional[Mapping[str, Any]] = None,
                 requests: Optional[Mapping[str, Any]] = None):
        """
        CPU and memory resources to reserve.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "requests")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplate(dict):
    """
    Customization of deployment templates and pods.
    """
    def __init__(__self__, *,
                 container: Optional['outputs.KafkaSpecKafkaExporterTemplateContainer'] = None,
                 deployment: Optional['outputs.KafkaSpecKafkaExporterTemplateDeployment'] = None,
                 pod: Optional['outputs.KafkaSpecKafkaExporterTemplatePod'] = None,
                 service: Optional['outputs.KafkaSpecKafkaExporterTemplateService'] = None):
        """
        Customization of deployment templates and pods.
        :param 'KafkaSpecKafkaExporterTemplateContainerArgs' container: Template for the Kafka Exporter container.
        :param 'KafkaSpecKafkaExporterTemplateDeploymentArgs' deployment: Template for Kafka Exporter `Deployment`.
        :param 'KafkaSpecKafkaExporterTemplatePodArgs' pod: Template for Kafka Exporter `Pods`.
        :param 'KafkaSpecKafkaExporterTemplateServiceArgs' service: Template for Kafka Exporter `Service`.
        """
        if container is not None:
            pulumi.set(__self__, "container", container)
        if deployment is not None:
            pulumi.set(__self__, "deployment", deployment)
        if pod is not None:
            pulumi.set(__self__, "pod", pod)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def container(self) -> Optional['outputs.KafkaSpecKafkaExporterTemplateContainer']:
        """
        Template for the Kafka Exporter container.
        """
        return pulumi.get(self, "container")

    @property
    @pulumi.getter
    def deployment(self) -> Optional['outputs.KafkaSpecKafkaExporterTemplateDeployment']:
        """
        Template for Kafka Exporter `Deployment`.
        """
        return pulumi.get(self, "deployment")

    @property
    @pulumi.getter
    def pod(self) -> Optional['outputs.KafkaSpecKafkaExporterTemplatePod']:
        """
        Template for Kafka Exporter `Pods`.
        """
        return pulumi.get(self, "pod")

    @property
    @pulumi.getter
    def service(self) -> Optional['outputs.KafkaSpecKafkaExporterTemplateService']:
        """
        Template for Kafka Exporter `Service`.
        """
        return pulumi.get(self, "service")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplateContainer(dict):
    """
    Template for the Kafka Exporter container.
    """
    def __init__(__self__, *,
                 env: Optional[Sequence['outputs.KafkaSpecKafkaExporterTemplateContainerEnv']] = None,
                 security_context: Optional['outputs.KafkaSpecKafkaExporterTemplateContainerSecurityContext'] = None):
        """
        Template for the Kafka Exporter container.
        :param Sequence['KafkaSpecKafkaExporterTemplateContainerEnvArgs'] env: Environment variables which should be applied to the container.
        :param 'KafkaSpecKafkaExporterTemplateContainerSecurityContextArgs' security_context: Security context for the container.
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)

    @property
    @pulumi.getter
    def env(self) -> Optional[Sequence['outputs.KafkaSpecKafkaExporterTemplateContainerEnv']]:
        """
        Environment variables which should be applied to the container.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional['outputs.KafkaSpecKafkaExporterTemplateContainerSecurityContext']:
        """
        Security context for the container.
        """
        return pulumi.get(self, "security_context")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplateContainerEnv(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The environment variable key.
        :param str value: The environment variable value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The environment variable key.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The environment variable value.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplateContainerSecurityContext(dict):
    """
    Security context for the container.
    """
    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[bool] = None,
                 capabilities: Optional['outputs.KafkaSpecKafkaExporterTemplateContainerSecurityContextCapabilities'] = None,
                 privileged: Optional[bool] = None,
                 proc_mount: Optional[str] = None,
                 read_only_root_filesystem: Optional[bool] = None,
                 run_as_group: Optional[int] = None,
                 run_as_non_root: Optional[bool] = None,
                 run_as_user: Optional[int] = None,
                 se_linux_options: Optional['outputs.KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions'] = None,
                 windows_options: Optional['outputs.KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptions'] = None):
        """
        Security context for the container.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if proc_mount is not None:
            pulumi.set(__self__, "proc_mount", proc_mount)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[bool]:
        return pulumi.get(self, "allow_privilege_escalation")

    @property
    @pulumi.getter
    def capabilities(self) -> Optional['outputs.KafkaSpecKafkaExporterTemplateContainerSecurityContextCapabilities']:
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def privileged(self) -> Optional[bool]:
        return pulumi.get(self, "privileged")

    @property
    @pulumi.getter(name="procMount")
    def proc_mount(self) -> Optional[str]:
        return pulumi.get(self, "proc_mount")

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[bool]:
        return pulumi.get(self, "read_only_root_filesystem")

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[int]:
        return pulumi.get(self, "run_as_group")

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[bool]:
        return pulumi.get(self, "run_as_non_root")

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[int]:
        return pulumi.get(self, "run_as_user")

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional['outputs.KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions']:
        return pulumi.get(self, "se_linux_options")

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional['outputs.KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptions']:
        return pulumi.get(self, "windows_options")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplateContainerSecurityContextCapabilities(dict):
    def __init__(__self__, *,
                 add: Optional[Sequence[str]] = None,
                 drop: Optional[Sequence[str]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)

    @property
    @pulumi.getter
    def add(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def drop(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "drop")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions(dict):
    def __init__(__self__, *,
                 level: Optional[str] = None,
                 role: Optional[str] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        return pulumi.get(self, "user")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptions(dict):
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[str] = None,
                 gmsa_credential_spec_name: Optional[str] = None,
                 run_as_user_name: Optional[str] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec")

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[str]:
        return pulumi.get(self, "run_as_user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplateDeployment(dict):
    """
    Template for Kafka Exporter `Deployment`.
    """
    def __init__(__self__, *,
                 metadata: Optional['outputs.KafkaSpecKafkaExporterTemplateDeploymentMetadata'] = None):
        """
        Template for Kafka Exporter `Deployment`.
        :param 'KafkaSpecKafkaExporterTemplateDeploymentMetadataArgs' metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaSpecKafkaExporterTemplateDeploymentMetadata']:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplateDeploymentMetadata(dict):
    """
    Metadata applied to the resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata applied to the resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplatePod(dict):
    """
    Template for Kafka Exporter `Pods`.
    """
    def __init__(__self__, *,
                 affinity: Optional['outputs.KafkaSpecKafkaExporterTemplatePodAffinity'] = None,
                 host_aliases: Optional[Sequence['outputs.KafkaSpecKafkaExporterTemplatePodHostAliases']] = None,
                 image_pull_secrets: Optional[Sequence['outputs.KafkaSpecKafkaExporterTemplatePodImagePullSecrets']] = None,
                 metadata: Optional['outputs.KafkaSpecKafkaExporterTemplatePodMetadata'] = None,
                 priority_class_name: Optional[str] = None,
                 scheduler_name: Optional[str] = None,
                 security_context: Optional['outputs.KafkaSpecKafkaExporterTemplatePodSecurityContext'] = None,
                 termination_grace_period_seconds: Optional[int] = None,
                 tolerations: Optional[Sequence['outputs.KafkaSpecKafkaExporterTemplatePodTolerations']] = None):
        """
        Template for Kafka Exporter `Pods`.
        :param 'KafkaSpecKafkaExporterTemplatePodAffinityArgs' affinity: The pod's affinity rules.
        :param Sequence['KafkaSpecKafkaExporterTemplatePodHostAliasesArgs'] host_aliases: The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
        :param Sequence['KafkaSpecKafkaExporterTemplatePodImagePullSecretsArgs'] image_pull_secrets: List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
        :param 'KafkaSpecKafkaExporterTemplatePodMetadataArgs' metadata: Metadata applied to the resource.
        :param str priority_class_name: The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
        :param str scheduler_name: The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
        :param 'KafkaSpecKafkaExporterTemplatePodSecurityContextArgs' security_context: Configures pod-level security attributes and common container settings.
        :param int termination_grace_period_seconds: The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
        :param Sequence['KafkaSpecKafkaExporterTemplatePodTolerationsArgs'] tolerations: The pod's tolerations.
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if host_aliases is not None:
            pulumi.set(__self__, "host_aliases", host_aliases)
        if image_pull_secrets is not None:
            pulumi.set(__self__, "image_pull_secrets", image_pull_secrets)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if priority_class_name is not None:
            pulumi.set(__self__, "priority_class_name", priority_class_name)
        if scheduler_name is not None:
            pulumi.set(__self__, "scheduler_name", scheduler_name)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)

    @property
    @pulumi.getter
    def affinity(self) -> Optional['outputs.KafkaSpecKafkaExporterTemplatePodAffinity']:
        """
        The pod's affinity rules.
        """
        return pulumi.get(self, "affinity")

    @property
    @pulumi.getter(name="hostAliases")
    def host_aliases(self) -> Optional[Sequence['outputs.KafkaSpecKafkaExporterTemplatePodHostAliases']]:
        """
        The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
        """
        return pulumi.get(self, "host_aliases")

    @property
    @pulumi.getter(name="imagePullSecrets")
    def image_pull_secrets(self) -> Optional[Sequence['outputs.KafkaSpecKafkaExporterTemplatePodImagePullSecrets']]:
        """
        List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
        """
        return pulumi.get(self, "image_pull_secrets")

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaSpecKafkaExporterTemplatePodMetadata']:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter(name="priorityClassName")
    def priority_class_name(self) -> Optional[str]:
        """
        The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
        """
        return pulumi.get(self, "priority_class_name")

    @property
    @pulumi.getter(name="schedulerName")
    def scheduler_name(self) -> Optional[str]:
        """
        The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
        """
        return pulumi.get(self, "scheduler_name")

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional['outputs.KafkaSpecKafkaExporterTemplatePodSecurityContext']:
        """
        Configures pod-level security attributes and common container settings.
        """
        return pulumi.get(self, "security_context")

    @property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[int]:
        """
        The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
        """
        return pulumi.get(self, "termination_grace_period_seconds")

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[Sequence['outputs.KafkaSpecKafkaExporterTemplatePodTolerations']]:
        """
        The pod's tolerations.
        """
        return pulumi.get(self, "tolerations")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplatePodAffinity(dict):
    """
    The pod's affinity rules.
    """
    def __init__(__self__, *,
                 node_affinity: Optional['outputs.KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinity'] = None,
                 pod_affinity: Optional['outputs.KafkaSpecKafkaExporterTemplatePodAffinityPodAffinity'] = None,
                 pod_anti_affinity: Optional['outputs.KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinity'] = None):
        """
        The pod's affinity rules.
        """
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional['outputs.KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinity']:
        return pulumi.get(self, "node_affinity")

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional['outputs.KafkaSpecKafkaExporterTemplatePodAffinityPodAffinity']:
        return pulumi.get(self, "pod_affinity")

    @property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional['outputs.KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinity']:
        return pulumi.get(self, "pod_anti_affinity")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional['outputs.KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution'] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional['outputs.KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution']:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 preference: Optional['outputs.KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference'] = None,
                 weight: Optional[int] = None):
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preference(self) -> Optional['outputs.KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference']:
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions']] = None,
                 match_fields: Optional[Sequence['outputs.KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields']] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields']]:
        return pulumi.get(self, "match_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 node_selector_terms: Optional[Sequence['outputs.KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms']] = None):
        if node_selector_terms is not None:
            pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> Optional[Sequence['outputs.KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms']]:
        return pulumi.get(self, "node_selector_terms")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions']] = None,
                 match_fields: Optional[Sequence['outputs.KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields']] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields']]:
        return pulumi.get(self, "match_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplatePodAffinityPodAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 pod_affinity_term: Optional['outputs.KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm'] = None,
                 weight: Optional[int] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional['outputs.KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm']:
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 pod_affinity_term: Optional['outputs.KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm'] = None,
                 weight: Optional[int] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional['outputs.KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm']:
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplatePodHostAliases(dict):
    def __init__(__self__, *,
                 hostnames: Optional[Sequence[str]] = None,
                 ip: Optional[str] = None):
        if hostnames is not None:
            pulumi.set(__self__, "hostnames", hostnames)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def hostnames(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "hostnames")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        return pulumi.get(self, "ip")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplatePodImagePullSecrets(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplatePodMetadata(dict):
    """
    Metadata applied to the resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata applied to the resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplatePodSecurityContext(dict):
    """
    Configures pod-level security attributes and common container settings.
    """
    def __init__(__self__, *,
                 fs_group: Optional[int] = None,
                 fs_group_change_policy: Optional[str] = None,
                 run_as_group: Optional[int] = None,
                 run_as_non_root: Optional[bool] = None,
                 run_as_user: Optional[int] = None,
                 se_linux_options: Optional['outputs.KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions'] = None,
                 supplemental_groups: Optional[Sequence[int]] = None,
                 sysctls: Optional[Sequence['outputs.KafkaSpecKafkaExporterTemplatePodSecurityContextSysctls']] = None,
                 windows_options: Optional['outputs.KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptions'] = None):
        """
        Configures pod-level security attributes and common container settings.
        """
        if fs_group is not None:
            pulumi.set(__self__, "fs_group", fs_group)
        if fs_group_change_policy is not None:
            pulumi.set(__self__, "fs_group_change_policy", fs_group_change_policy)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if supplemental_groups is not None:
            pulumi.set(__self__, "supplemental_groups", supplemental_groups)
        if sysctls is not None:
            pulumi.set(__self__, "sysctls", sysctls)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="fsGroup")
    def fs_group(self) -> Optional[int]:
        return pulumi.get(self, "fs_group")

    @property
    @pulumi.getter(name="fsGroupChangePolicy")
    def fs_group_change_policy(self) -> Optional[str]:
        return pulumi.get(self, "fs_group_change_policy")

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[int]:
        return pulumi.get(self, "run_as_group")

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[bool]:
        return pulumi.get(self, "run_as_non_root")

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[int]:
        return pulumi.get(self, "run_as_user")

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional['outputs.KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions']:
        return pulumi.get(self, "se_linux_options")

    @property
    @pulumi.getter(name="supplementalGroups")
    def supplemental_groups(self) -> Optional[Sequence[int]]:
        return pulumi.get(self, "supplemental_groups")

    @property
    @pulumi.getter
    def sysctls(self) -> Optional[Sequence['outputs.KafkaSpecKafkaExporterTemplatePodSecurityContextSysctls']]:
        return pulumi.get(self, "sysctls")

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional['outputs.KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptions']:
        return pulumi.get(self, "windows_options")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions(dict):
    def __init__(__self__, *,
                 level: Optional[str] = None,
                 role: Optional[str] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        return pulumi.get(self, "user")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplatePodSecurityContextSysctls(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptions(dict):
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[str] = None,
                 gmsa_credential_spec_name: Optional[str] = None,
                 run_as_user_name: Optional[str] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec")

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[str]:
        return pulumi.get(self, "run_as_user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplatePodTolerations(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 toleration_seconds: Optional[int] = None,
                 value: Optional[str] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if toleration_seconds is not None:
            pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> Optional[int]:
        return pulumi.get(self, "toleration_seconds")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplateService(dict):
    """
    Template for Kafka Exporter `Service`.
    """
    def __init__(__self__, *,
                 metadata: Optional['outputs.KafkaSpecKafkaExporterTemplateServiceMetadata'] = None):
        """
        Template for Kafka Exporter `Service`.
        :param 'KafkaSpecKafkaExporterTemplateServiceMetadataArgs' metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaSpecKafkaExporterTemplateServiceMetadata']:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaExporterTemplateServiceMetadata(dict):
    """
    Metadata applied to the resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata applied to the resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaJmxOptions(dict):
    """
    JMX Options for Kafka brokers.
    """
    def __init__(__self__, *,
                 authentication: Optional['outputs.KafkaSpecKafkaJmxOptionsAuthentication'] = None):
        """
        JMX Options for Kafka brokers.
        :param 'KafkaSpecKafkaJmxOptionsAuthenticationArgs' authentication: Authentication configuration for connecting to the Kafka JMX port.
        """
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)

    @property
    @pulumi.getter
    def authentication(self) -> Optional['outputs.KafkaSpecKafkaJmxOptionsAuthentication']:
        """
        Authentication configuration for connecting to the Kafka JMX port.
        """
        return pulumi.get(self, "authentication")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaJmxOptionsAuthentication(dict):
    """
    Authentication configuration for connecting to the Kafka JMX port.
    """
    def __init__(__self__, *,
                 type: str):
        """
        Authentication configuration for connecting to the Kafka JMX port.
        :param str type: Authentication type. Currently the only supported types are `password`.`password` type creates a username and protected port with no TLS.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Authentication type. Currently the only supported types are `password`.`password` type creates a username and protected port with no TLS.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaJvmOptions(dict):
    """
    JVM Options for pods.
    """
    def __init__(__self__, *,
                 __xx: Optional[Mapping[str, Any]] = None,
                 __xms: Optional[str] = None,
                 __xmx: Optional[str] = None,
                 gc_logging_enabled: Optional[bool] = None,
                 java_system_properties: Optional[Sequence['outputs.KafkaSpecKafkaJvmOptionsJavaSystemProperties']] = None):
        """
        JVM Options for pods.
        :param Mapping[str, Any] __xx: A map of -XX options to the JVM.
        :param str __xms: -Xms option to to the JVM.
        :param str __xmx: -Xmx option to to the JVM.
        :param bool gc_logging_enabled: Specifies whether the Garbage Collection logging is enabled. The default is false.
        :param Sequence['KafkaSpecKafkaJvmOptionsJavaSystemPropertiesArgs'] java_system_properties: A map of additional system properties which will be passed using the `-D` option to the JVM.
        """
        if __xx is not None:
            pulumi.set(__self__, "__xx", __xx)
        if __xms is not None:
            pulumi.set(__self__, "__xms", __xms)
        if __xmx is not None:
            pulumi.set(__self__, "__xmx", __xmx)
        if gc_logging_enabled is not None:
            pulumi.set(__self__, "gc_logging_enabled", gc_logging_enabled)
        if java_system_properties is not None:
            pulumi.set(__self__, "java_system_properties", java_system_properties)

    @property
    @pulumi.getter(name="-XX")
    def __xx(self) -> Optional[Mapping[str, Any]]:
        """
        A map of -XX options to the JVM.
        """
        return pulumi.get(self, "__xx")

    @property
    @pulumi.getter(name="-Xms")
    def __xms(self) -> Optional[str]:
        """
        -Xms option to to the JVM.
        """
        return pulumi.get(self, "__xms")

    @property
    @pulumi.getter(name="-Xmx")
    def __xmx(self) -> Optional[str]:
        """
        -Xmx option to to the JVM.
        """
        return pulumi.get(self, "__xmx")

    @property
    @pulumi.getter(name="gcLoggingEnabled")
    def gc_logging_enabled(self) -> Optional[bool]:
        """
        Specifies whether the Garbage Collection logging is enabled. The default is false.
        """
        return pulumi.get(self, "gc_logging_enabled")

    @property
    @pulumi.getter(name="javaSystemProperties")
    def java_system_properties(self) -> Optional[Sequence['outputs.KafkaSpecKafkaJvmOptionsJavaSystemProperties']]:
        """
        A map of additional system properties which will be passed using the `-D` option to the JVM.
        """
        return pulumi.get(self, "java_system_properties")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaJvmOptionsJavaSystemProperties(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The system property name.
        :param str value: The system property value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The system property name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The system property value.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf0(dict):
    def __init__(__self__, *,
                 name: str,
                 port: int,
                 tls: bool,
                 type: str,
                 authentication: Optional['outputs.KafkaSpecKafkaListenersOneOf0Authentication'] = None,
                 configuration: Optional['outputs.KafkaSpecKafkaListenersOneOf0Configuration'] = None,
                 network_policy_peers: Optional[Sequence['outputs.KafkaSpecKafkaListenersOneOf0NetworkPolicyPeers']] = None):
        """
        :param str name: Name of the listener. The name will be used to identify the listener and the related Kubernetes objects. The name has to be unique within given a Kafka cluster. The name can consist of lowercase characters and numbers and be up to 11 characters long.
        :param int port: Port number used by the listener inside Kafka. The port number has to be unique within a given Kafka cluster. Allowed port numbers are 9092 and higher with the exception of ports 9404 and 9999, which are already used for Prometheus and JMX. Depending on the listener type, the port number might not be the same as the port number that connects Kafka clients.
        :param bool tls: Enables TLS encryption on the listener. This is a required property.
        :param str type: Type of the listener. Currently the supported types are `internal`, `route`, `loadbalancer`, `nodeport` and `ingress`. 
               
               * `internal` type exposes Kafka internally only within the Kubernetes cluster.
               * `route` type uses OpenShift Routes to expose Kafka.
               * `loadbalancer` type uses LoadBalancer type services to expose Kafka.
               * `nodeport` type uses NodePort type services to expose Kafka.
               * `ingress` type uses Kubernetes Nginx Ingress to expose Kafka.
               .
        :param 'KafkaSpecKafkaListenersOneOf0AuthenticationArgs' authentication: Authentication configuration for this listener.
        :param 'KafkaSpecKafkaListenersOneOf0ConfigurationArgs' configuration: Additional listener configuration.
        :param Sequence['KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersArgs'] network_policy_peers: List of peers which should be able to connect to this listener. Peers in this list are combined using a logical OR operation. If this field is empty or missing, all connections will be allowed for this listener. If this field is present and contains at least one item, the listener only allows the traffic which matches at least one item in this list.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "tls", tls)
        pulumi.set(__self__, "type", type)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if network_policy_peers is not None:
            pulumi.set(__self__, "network_policy_peers", network_policy_peers)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the listener. The name will be used to identify the listener and the related Kubernetes objects. The name has to be unique within given a Kafka cluster. The name can consist of lowercase characters and numbers and be up to 11 characters long.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Port number used by the listener inside Kafka. The port number has to be unique within a given Kafka cluster. Allowed port numbers are 9092 and higher with the exception of ports 9404 and 9999, which are already used for Prometheus and JMX. Depending on the listener type, the port number might not be the same as the port number that connects Kafka clients.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def tls(self) -> bool:
        """
        Enables TLS encryption on the listener. This is a required property.
        """
        return pulumi.get(self, "tls")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the listener. Currently the supported types are `internal`, `route`, `loadbalancer`, `nodeport` and `ingress`. 

        * `internal` type exposes Kafka internally only within the Kubernetes cluster.
        * `route` type uses OpenShift Routes to expose Kafka.
        * `loadbalancer` type uses LoadBalancer type services to expose Kafka.
        * `nodeport` type uses NodePort type services to expose Kafka.
        * `ingress` type uses Kubernetes Nginx Ingress to expose Kafka.
        .
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def authentication(self) -> Optional['outputs.KafkaSpecKafkaListenersOneOf0Authentication']:
        """
        Authentication configuration for this listener.
        """
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.KafkaSpecKafkaListenersOneOf0Configuration']:
        """
        Additional listener configuration.
        """
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter(name="networkPolicyPeers")
    def network_policy_peers(self) -> Optional[Sequence['outputs.KafkaSpecKafkaListenersOneOf0NetworkPolicyPeers']]:
        """
        List of peers which should be able to connect to this listener. Peers in this list are combined using a logical OR operation. If this field is empty or missing, all connections will be allowed for this listener. If this field is present and contains at least one item, the listener only allows the traffic which matches at least one item in this list.
        """
        return pulumi.get(self, "network_policy_peers")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf0Authentication(dict):
    """
    Authentication configuration for this listener.
    """
    def __init__(__self__, *,
                 type: str,
                 access_token_is_jwt: Optional[bool] = None,
                 check_access_token_type: Optional[bool] = None,
                 check_issuer: Optional[bool] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional['outputs.KafkaSpecKafkaListenersOneOf0AuthenticationClientSecret'] = None,
                 disable_tls_hostname_verification: Optional[bool] = None,
                 enable_ecdsa: Optional[bool] = None,
                 fallback_user_name_claim: Optional[str] = None,
                 fallback_user_name_prefix: Optional[str] = None,
                 introspection_endpoint_uri: Optional[str] = None,
                 jwks_endpoint_uri: Optional[str] = None,
                 jwks_expiry_seconds: Optional[int] = None,
                 jwks_min_refresh_pause_seconds: Optional[int] = None,
                 jwks_refresh_seconds: Optional[int] = None,
                 max_seconds_without_reauthentication: Optional[int] = None,
                 tls_trusted_certificates: Optional[Sequence['outputs.KafkaSpecKafkaListenersOneOf0AuthenticationTlsTrustedCertificates']] = None,
                 user_info_endpoint_uri: Optional[str] = None,
                 user_name_claim: Optional[str] = None,
                 valid_issuer_uri: Optional[str] = None,
                 valid_token_type: Optional[str] = None):
        """
        Authentication configuration for this listener.
        :param str type: Authentication type. `oauth` type uses SASL OAUTHBEARER Authentication. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `tls` type uses TLS Client Authentication. `tls` type is supported only on TLS listeners.
        :param bool access_token_is_jwt: Configure whether the access token is treated as JWT. This must be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
        :param bool check_access_token_type: Configure whether the access token type check is performed or not. This should be set to `false` if the authorization server does not include 'typ' claim in JWT token. Defaults to `true`.
        :param bool check_issuer: Enable or disable issuer checking. By default issuer is checked using the value configured by `validIssuerUri`. Default value is `true`.
        :param str client_id: OAuth Client ID which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
        :param 'KafkaSpecKafkaListenersOneOf0AuthenticationClientSecretArgs' client_secret: Link to Kubernetes Secret containing the OAuth client secret which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
        :param bool disable_tls_hostname_verification: Enable or disable TLS hostname verification. Default value is `false`.
        :param bool enable_ecdsa: Enable or disable ECDSA support by installing BouncyCastle crypto provider. Default value is `false`.
        :param str fallback_user_name_claim: The fallback username claim to be used for the user id if the claim specified by `userNameClaim` is not present. This is useful when `client_credentials` authentication only results in the client id being provided in another claim. It only takes effect if `userNameClaim` is set.
        :param str fallback_user_name_prefix: The prefix to use with the value of `fallbackUserNameClaim` to construct the user id. This only takes effect if `fallbackUserNameClaim` is true, and the value is present for the claim. Mapping usernames and client ids into the same user id space is useful in preventing name collisions.
        :param str introspection_endpoint_uri: URI of the token introspection endpoint which can be used to validate opaque non-JWT tokens.
        :param str jwks_endpoint_uri: URI of the JWKS certificate endpoint, which can be used for local JWT validation.
        :param int jwks_expiry_seconds: Configures how often are the JWKS certificates considered valid. The expiry interval has to be at least 60 seconds longer then the refresh interval specified in `jwksRefreshSeconds`. Defaults to 360 seconds.
        :param int jwks_min_refresh_pause_seconds: The minimum pause between two consecutive refreshes. When an unknown signing key is encountered the refresh is scheduled immediately, but will always wait for this minimum pause. Defaults to 1 second.
        :param int jwks_refresh_seconds: Configures how often are the JWKS certificates refreshed. The refresh interval has to be at least 60 seconds shorter then the expiry interval specified in `jwksExpirySeconds`. Defaults to 300 seconds.
        :param int max_seconds_without_reauthentication: Maximum number of seconds the authenticated session remains valid without re-authentication. This enables Apache Kafka re-authentication feature, and causes sessions to expire when the access token expires. If the access token expires before max time or if max time is reached, the client has to re-authenticate, otherwise the server will drop the connection. Not set by default - the authenticated session does not expire when the access token expires.
        :param Sequence['KafkaSpecKafkaListenersOneOf0AuthenticationTlsTrustedCertificatesArgs'] tls_trusted_certificates: Trusted certificates for TLS connection to the OAuth server.
        :param str user_info_endpoint_uri: URI of the User Info Endpoint to use as a fallback to obtaining the user id when the Introspection Endpoint does not return information that can be used for the user id. 
        :param str user_name_claim: Name of the claim from the JWT authentication token, Introspection Endpoint response or User Info Endpoint response which will be used to extract the user id. Defaults to `sub`.
        :param str valid_issuer_uri: URI of the token issuer used for authentication.
        :param str valid_token_type: Valid value for the `token_type` attribute returned by the Introspection Endpoint. No default value, and not checked by default.
        """
        pulumi.set(__self__, "type", type)
        if access_token_is_jwt is not None:
            pulumi.set(__self__, "access_token_is_jwt", access_token_is_jwt)
        if check_access_token_type is not None:
            pulumi.set(__self__, "check_access_token_type", check_access_token_type)
        if check_issuer is not None:
            pulumi.set(__self__, "check_issuer", check_issuer)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if disable_tls_hostname_verification is not None:
            pulumi.set(__self__, "disable_tls_hostname_verification", disable_tls_hostname_verification)
        if enable_ecdsa is not None:
            pulumi.set(__self__, "enable_ecdsa", enable_ecdsa)
        if fallback_user_name_claim is not None:
            pulumi.set(__self__, "fallback_user_name_claim", fallback_user_name_claim)
        if fallback_user_name_prefix is not None:
            pulumi.set(__self__, "fallback_user_name_prefix", fallback_user_name_prefix)
        if introspection_endpoint_uri is not None:
            pulumi.set(__self__, "introspection_endpoint_uri", introspection_endpoint_uri)
        if jwks_endpoint_uri is not None:
            pulumi.set(__self__, "jwks_endpoint_uri", jwks_endpoint_uri)
        if jwks_expiry_seconds is not None:
            pulumi.set(__self__, "jwks_expiry_seconds", jwks_expiry_seconds)
        if jwks_min_refresh_pause_seconds is not None:
            pulumi.set(__self__, "jwks_min_refresh_pause_seconds", jwks_min_refresh_pause_seconds)
        if jwks_refresh_seconds is not None:
            pulumi.set(__self__, "jwks_refresh_seconds", jwks_refresh_seconds)
        if max_seconds_without_reauthentication is not None:
            pulumi.set(__self__, "max_seconds_without_reauthentication", max_seconds_without_reauthentication)
        if tls_trusted_certificates is not None:
            pulumi.set(__self__, "tls_trusted_certificates", tls_trusted_certificates)
        if user_info_endpoint_uri is not None:
            pulumi.set(__self__, "user_info_endpoint_uri", user_info_endpoint_uri)
        if user_name_claim is not None:
            pulumi.set(__self__, "user_name_claim", user_name_claim)
        if valid_issuer_uri is not None:
            pulumi.set(__self__, "valid_issuer_uri", valid_issuer_uri)
        if valid_token_type is not None:
            pulumi.set(__self__, "valid_token_type", valid_token_type)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Authentication type. `oauth` type uses SASL OAUTHBEARER Authentication. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `tls` type uses TLS Client Authentication. `tls` type is supported only on TLS listeners.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessTokenIsJwt")
    def access_token_is_jwt(self) -> Optional[bool]:
        """
        Configure whether the access token is treated as JWT. This must be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
        """
        return pulumi.get(self, "access_token_is_jwt")

    @property
    @pulumi.getter(name="checkAccessTokenType")
    def check_access_token_type(self) -> Optional[bool]:
        """
        Configure whether the access token type check is performed or not. This should be set to `false` if the authorization server does not include 'typ' claim in JWT token. Defaults to `true`.
        """
        return pulumi.get(self, "check_access_token_type")

    @property
    @pulumi.getter(name="checkIssuer")
    def check_issuer(self) -> Optional[bool]:
        """
        Enable or disable issuer checking. By default issuer is checked using the value configured by `validIssuerUri`. Default value is `true`.
        """
        return pulumi.get(self, "check_issuer")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        OAuth Client ID which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional['outputs.KafkaSpecKafkaListenersOneOf0AuthenticationClientSecret']:
        """
        Link to Kubernetes Secret containing the OAuth client secret which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="disableTlsHostnameVerification")
    def disable_tls_hostname_verification(self) -> Optional[bool]:
        """
        Enable or disable TLS hostname verification. Default value is `false`.
        """
        return pulumi.get(self, "disable_tls_hostname_verification")

    @property
    @pulumi.getter(name="enableECDSA")
    def enable_ecdsa(self) -> Optional[bool]:
        """
        Enable or disable ECDSA support by installing BouncyCastle crypto provider. Default value is `false`.
        """
        return pulumi.get(self, "enable_ecdsa")

    @property
    @pulumi.getter(name="fallbackUserNameClaim")
    def fallback_user_name_claim(self) -> Optional[str]:
        """
        The fallback username claim to be used for the user id if the claim specified by `userNameClaim` is not present. This is useful when `client_credentials` authentication only results in the client id being provided in another claim. It only takes effect if `userNameClaim` is set.
        """
        return pulumi.get(self, "fallback_user_name_claim")

    @property
    @pulumi.getter(name="fallbackUserNamePrefix")
    def fallback_user_name_prefix(self) -> Optional[str]:
        """
        The prefix to use with the value of `fallbackUserNameClaim` to construct the user id. This only takes effect if `fallbackUserNameClaim` is true, and the value is present for the claim. Mapping usernames and client ids into the same user id space is useful in preventing name collisions.
        """
        return pulumi.get(self, "fallback_user_name_prefix")

    @property
    @pulumi.getter(name="introspectionEndpointUri")
    def introspection_endpoint_uri(self) -> Optional[str]:
        """
        URI of the token introspection endpoint which can be used to validate opaque non-JWT tokens.
        """
        return pulumi.get(self, "introspection_endpoint_uri")

    @property
    @pulumi.getter(name="jwksEndpointUri")
    def jwks_endpoint_uri(self) -> Optional[str]:
        """
        URI of the JWKS certificate endpoint, which can be used for local JWT validation.
        """
        return pulumi.get(self, "jwks_endpoint_uri")

    @property
    @pulumi.getter(name="jwksExpirySeconds")
    def jwks_expiry_seconds(self) -> Optional[int]:
        """
        Configures how often are the JWKS certificates considered valid. The expiry interval has to be at least 60 seconds longer then the refresh interval specified in `jwksRefreshSeconds`. Defaults to 360 seconds.
        """
        return pulumi.get(self, "jwks_expiry_seconds")

    @property
    @pulumi.getter(name="jwksMinRefreshPauseSeconds")
    def jwks_min_refresh_pause_seconds(self) -> Optional[int]:
        """
        The minimum pause between two consecutive refreshes. When an unknown signing key is encountered the refresh is scheduled immediately, but will always wait for this minimum pause. Defaults to 1 second.
        """
        return pulumi.get(self, "jwks_min_refresh_pause_seconds")

    @property
    @pulumi.getter(name="jwksRefreshSeconds")
    def jwks_refresh_seconds(self) -> Optional[int]:
        """
        Configures how often are the JWKS certificates refreshed. The refresh interval has to be at least 60 seconds shorter then the expiry interval specified in `jwksExpirySeconds`. Defaults to 300 seconds.
        """
        return pulumi.get(self, "jwks_refresh_seconds")

    @property
    @pulumi.getter(name="maxSecondsWithoutReauthentication")
    def max_seconds_without_reauthentication(self) -> Optional[int]:
        """
        Maximum number of seconds the authenticated session remains valid without re-authentication. This enables Apache Kafka re-authentication feature, and causes sessions to expire when the access token expires. If the access token expires before max time or if max time is reached, the client has to re-authenticate, otherwise the server will drop the connection. Not set by default - the authenticated session does not expire when the access token expires.
        """
        return pulumi.get(self, "max_seconds_without_reauthentication")

    @property
    @pulumi.getter(name="tlsTrustedCertificates")
    def tls_trusted_certificates(self) -> Optional[Sequence['outputs.KafkaSpecKafkaListenersOneOf0AuthenticationTlsTrustedCertificates']]:
        """
        Trusted certificates for TLS connection to the OAuth server.
        """
        return pulumi.get(self, "tls_trusted_certificates")

    @property
    @pulumi.getter(name="userInfoEndpointUri")
    def user_info_endpoint_uri(self) -> Optional[str]:
        """
        URI of the User Info Endpoint to use as a fallback to obtaining the user id when the Introspection Endpoint does not return information that can be used for the user id. 
        """
        return pulumi.get(self, "user_info_endpoint_uri")

    @property
    @pulumi.getter(name="userNameClaim")
    def user_name_claim(self) -> Optional[str]:
        """
        Name of the claim from the JWT authentication token, Introspection Endpoint response or User Info Endpoint response which will be used to extract the user id. Defaults to `sub`.
        """
        return pulumi.get(self, "user_name_claim")

    @property
    @pulumi.getter(name="validIssuerUri")
    def valid_issuer_uri(self) -> Optional[str]:
        """
        URI of the token issuer used for authentication.
        """
        return pulumi.get(self, "valid_issuer_uri")

    @property
    @pulumi.getter(name="validTokenType")
    def valid_token_type(self) -> Optional[str]:
        """
        Valid value for the `token_type` attribute returned by the Introspection Endpoint. No default value, and not checked by default.
        """
        return pulumi.get(self, "valid_token_type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf0AuthenticationClientSecret(dict):
    """
    Link to Kubernetes Secret containing the OAuth client secret which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
    """
    def __init__(__self__, *,
                 key: str,
                 secret_name: str):
        """
        Link to Kubernetes Secret containing the OAuth client secret which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
        :param str key: The key under which the secret value is stored in the Kubernetes Secret.
        :param str secret_name: The name of the Kubernetes Secret containing the secret value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key under which the secret value is stored in the Kubernetes Secret.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Kubernetes Secret containing the secret value.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf0AuthenticationTlsTrustedCertificates(dict):
    def __init__(__self__, *,
                 certificate: str,
                 secret_name: str):
        """
        :param str certificate: The name of the file certificate in the Secret.
        :param str secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> str:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf0Configuration(dict):
    """
    Additional listener configuration.
    """
    def __init__(__self__, *,
                 bootstrap: Optional['outputs.KafkaSpecKafkaListenersOneOf0ConfigurationBootstrap'] = None,
                 broker_cert_chain_and_key: Optional['outputs.KafkaSpecKafkaListenersOneOf0ConfigurationBrokerCertChainAndKey'] = None,
                 brokers: Optional[Sequence['outputs.KafkaSpecKafkaListenersOneOf0ConfigurationBrokers']] = None,
                 class_: Optional[str] = None,
                 external_traffic_policy: Optional[str] = None,
                 load_balancer_source_ranges: Optional[Sequence[str]] = None,
                 preferred_node_port_address_type: Optional[str] = None,
                 use_service_dns_domain: Optional[bool] = None):
        """
        Additional listener configuration.
        :param 'KafkaSpecKafkaListenersOneOf0ConfigurationBootstrapArgs' bootstrap: Bootstrap configuration.
        :param 'KafkaSpecKafkaListenersOneOf0ConfigurationBrokerCertChainAndKeyArgs' broker_cert_chain_and_key: Reference to the `Secret` which holds the certificate and private key pair which will be used for this listener. The certificate can optionally contain the whole chain. This field can be used only with listeners with enabled TLS encryption.
        :param Sequence['KafkaSpecKafkaListenersOneOf0ConfigurationBrokersArgs'] brokers: Per-broker configurations.
        :param str class_: Configures the `Ingress` class that defines which `Ingress` controller will be used. If not set, the `Ingress` class is set to `nginx`. This field can be used only with `ingress` type listener.
        :param str external_traffic_policy: Specifies whether the service routes external traffic to node-local or cluster-wide endpoints. `Cluster` may cause a second hop to another node and obscures the client source IP. `Local` avoids a second hop for LoadBalancer and Nodeport type services and preserves the client source IP (when supported by the infrastructure). If unspecified, Kubernetes will use `Cluster` as the default.This field can be used only with `loadbalancer` or `nodeport` type listener.
        :param Sequence[str] load_balancer_source_ranges: A list of CIDR ranges (for example `10.0.0.0/8` or `130.211.204.1/32`) from which clients can connect to load balancer type listeners. If supported by the platform, traffic through the loadbalancer is restricted to the specified CIDR ranges. This field is applicable only for loadbalancer type services and is ignored if the cloud provider does not support the feature. For more information, see https://v1-17.docs.kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/. This field can be used only with `loadbalancer` type listener.
        :param str preferred_node_port_address_type: Defines which address type should be used as the node address. Available types are: `ExternalDNS`, `ExternalIP`, `InternalDNS`, `InternalIP` and `Hostname`. By default, the addresses will be used in the following order (the first one found will be used):
               * `ExternalDNS`
               * `ExternalIP`
               * `InternalDNS`
               * `InternalIP`
               * `Hostname`
               
               This field can be used to select the address type which will be used as the preferred type and checked first. In case no address will be found for this address type, the other types will be used in the default order.This field can be used only with `nodeport` type listener..
        :param bool use_service_dns_domain: Configures whether the Kubernetes service DNS domain should be used or not. If set to `true`, the generated addresses with contain the service DNS domain suffix (by default `.cluster.local`, can be configured using environment variable `KUBERNETES_SERVICE_DNS_DOMAIN`). Defaults to `false`.This field can be used only with `internal` type listener.
        """
        if bootstrap is not None:
            pulumi.set(__self__, "bootstrap", bootstrap)
        if broker_cert_chain_and_key is not None:
            pulumi.set(__self__, "broker_cert_chain_and_key", broker_cert_chain_and_key)
        if brokers is not None:
            pulumi.set(__self__, "brokers", brokers)
        if class_ is not None:
            pulumi.set(__self__, "class_", class_)
        if external_traffic_policy is not None:
            pulumi.set(__self__, "external_traffic_policy", external_traffic_policy)
        if load_balancer_source_ranges is not None:
            pulumi.set(__self__, "load_balancer_source_ranges", load_balancer_source_ranges)
        if preferred_node_port_address_type is not None:
            pulumi.set(__self__, "preferred_node_port_address_type", preferred_node_port_address_type)
        if use_service_dns_domain is not None:
            pulumi.set(__self__, "use_service_dns_domain", use_service_dns_domain)

    @property
    @pulumi.getter
    def bootstrap(self) -> Optional['outputs.KafkaSpecKafkaListenersOneOf0ConfigurationBootstrap']:
        """
        Bootstrap configuration.
        """
        return pulumi.get(self, "bootstrap")

    @property
    @pulumi.getter(name="brokerCertChainAndKey")
    def broker_cert_chain_and_key(self) -> Optional['outputs.KafkaSpecKafkaListenersOneOf0ConfigurationBrokerCertChainAndKey']:
        """
        Reference to the `Secret` which holds the certificate and private key pair which will be used for this listener. The certificate can optionally contain the whole chain. This field can be used only with listeners with enabled TLS encryption.
        """
        return pulumi.get(self, "broker_cert_chain_and_key")

    @property
    @pulumi.getter
    def brokers(self) -> Optional[Sequence['outputs.KafkaSpecKafkaListenersOneOf0ConfigurationBrokers']]:
        """
        Per-broker configurations.
        """
        return pulumi.get(self, "brokers")

    @property
    @pulumi.getter(name="class")
    def class_(self) -> Optional[str]:
        """
        Configures the `Ingress` class that defines which `Ingress` controller will be used. If not set, the `Ingress` class is set to `nginx`. This field can be used only with `ingress` type listener.
        """
        return pulumi.get(self, "class_")

    @property
    @pulumi.getter(name="externalTrafficPolicy")
    def external_traffic_policy(self) -> Optional[str]:
        """
        Specifies whether the service routes external traffic to node-local or cluster-wide endpoints. `Cluster` may cause a second hop to another node and obscures the client source IP. `Local` avoids a second hop for LoadBalancer and Nodeport type services and preserves the client source IP (when supported by the infrastructure). If unspecified, Kubernetes will use `Cluster` as the default.This field can be used only with `loadbalancer` or `nodeport` type listener.
        """
        return pulumi.get(self, "external_traffic_policy")

    @property
    @pulumi.getter(name="loadBalancerSourceRanges")
    def load_balancer_source_ranges(self) -> Optional[Sequence[str]]:
        """
        A list of CIDR ranges (for example `10.0.0.0/8` or `130.211.204.1/32`) from which clients can connect to load balancer type listeners. If supported by the platform, traffic through the loadbalancer is restricted to the specified CIDR ranges. This field is applicable only for loadbalancer type services and is ignored if the cloud provider does not support the feature. For more information, see https://v1-17.docs.kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/. This field can be used only with `loadbalancer` type listener.
        """
        return pulumi.get(self, "load_balancer_source_ranges")

    @property
    @pulumi.getter(name="preferredNodePortAddressType")
    def preferred_node_port_address_type(self) -> Optional[str]:
        """
        Defines which address type should be used as the node address. Available types are: `ExternalDNS`, `ExternalIP`, `InternalDNS`, `InternalIP` and `Hostname`. By default, the addresses will be used in the following order (the first one found will be used):
        * `ExternalDNS`
        * `ExternalIP`
        * `InternalDNS`
        * `InternalIP`
        * `Hostname`

        This field can be used to select the address type which will be used as the preferred type and checked first. In case no address will be found for this address type, the other types will be used in the default order.This field can be used only with `nodeport` type listener..
        """
        return pulumi.get(self, "preferred_node_port_address_type")

    @property
    @pulumi.getter(name="useServiceDnsDomain")
    def use_service_dns_domain(self) -> Optional[bool]:
        """
        Configures whether the Kubernetes service DNS domain should be used or not. If set to `true`, the generated addresses with contain the service DNS domain suffix (by default `.cluster.local`, can be configured using environment variable `KUBERNETES_SERVICE_DNS_DOMAIN`). Defaults to `false`.This field can be used only with `internal` type listener.
        """
        return pulumi.get(self, "use_service_dns_domain")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf0ConfigurationBootstrap(dict):
    """
    Bootstrap configuration.
    """
    def __init__(__self__, *,
                 alternative_names: Optional[Sequence[str]] = None,
                 annotations: Optional[Mapping[str, Any]] = None,
                 host: Optional[str] = None,
                 load_balancer_ip: Optional[str] = None,
                 node_port: Optional[int] = None):
        """
        Bootstrap configuration.
        :param Sequence[str] alternative_names: Additional alternative names for the bootstrap service. The alternative names will be added to the list of subject alternative names of the TLS certificates.
        :param Mapping[str, Any] annotations: Annotations that will be added to the `Ingress` or `Service` resource. You can use this field to configure DNS providers such as External DNS. This field can be used only with `loadbalancer`, `nodeport`, or `ingress` type listeners.
        :param str host: The bootstrap host. This field will be used in the Ingress resource or in the Route resource to specify the desired hostname. This field can be used only with `route` (optional) or `ingress` (required) type listeners.
        :param str load_balancer_ip: The loadbalancer is requested with the IP address specified in this field. This feature depends on whether the underlying cloud provider supports specifying the `loadBalancerIP` when a load balancer is created. This field is ignored if the cloud provider does not support the feature.This field can be used only with `loadbalancer` type listener.
        :param int node_port: Node port for the bootstrap service. This field can be used only with `nodeport` type listener.
        """
        if alternative_names is not None:
            pulumi.set(__self__, "alternative_names", alternative_names)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if load_balancer_ip is not None:
            pulumi.set(__self__, "load_balancer_ip", load_balancer_ip)
        if node_port is not None:
            pulumi.set(__self__, "node_port", node_port)

    @property
    @pulumi.getter(name="alternativeNames")
    def alternative_names(self) -> Optional[Sequence[str]]:
        """
        Additional alternative names for the bootstrap service. The alternative names will be added to the list of subject alternative names of the TLS certificates.
        """
        return pulumi.get(self, "alternative_names")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations that will be added to the `Ingress` or `Service` resource. You can use this field to configure DNS providers such as External DNS. This field can be used only with `loadbalancer`, `nodeport`, or `ingress` type listeners.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The bootstrap host. This field will be used in the Ingress resource or in the Route resource to specify the desired hostname. This field can be used only with `route` (optional) or `ingress` (required) type listeners.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="loadBalancerIP")
    def load_balancer_ip(self) -> Optional[str]:
        """
        The loadbalancer is requested with the IP address specified in this field. This feature depends on whether the underlying cloud provider supports specifying the `loadBalancerIP` when a load balancer is created. This field is ignored if the cloud provider does not support the feature.This field can be used only with `loadbalancer` type listener.
        """
        return pulumi.get(self, "load_balancer_ip")

    @property
    @pulumi.getter(name="nodePort")
    def node_port(self) -> Optional[int]:
        """
        Node port for the bootstrap service. This field can be used only with `nodeport` type listener.
        """
        return pulumi.get(self, "node_port")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf0ConfigurationBrokerCertChainAndKey(dict):
    """
    Reference to the `Secret` which holds the certificate and private key pair which will be used for this listener. The certificate can optionally contain the whole chain. This field can be used only with listeners with enabled TLS encryption.
    """
    def __init__(__self__, *,
                 certificate: str,
                 key: str,
                 secret_name: str):
        """
        Reference to the `Secret` which holds the certificate and private key pair which will be used for this listener. The certificate can optionally contain the whole chain. This field can be used only with listeners with enabled TLS encryption.
        :param str certificate: The name of the file certificate in the Secret.
        :param str key: The name of the private key in the Secret.
        :param str secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> str:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The name of the private key in the Secret.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf0ConfigurationBrokers(dict):
    def __init__(__self__, *,
                 broker: int,
                 advertised_host: Optional[str] = None,
                 advertised_port: Optional[int] = None,
                 annotations: Optional[Mapping[str, Any]] = None,
                 host: Optional[str] = None,
                 load_balancer_ip: Optional[str] = None,
                 node_port: Optional[int] = None):
        """
        :param int broker: ID of the kafka broker (broker identifier). Broker IDs start from 0 and correspond to the number of broker replicas.
        :param str advertised_host: The host name which will be used in the brokers' `advertised.brokers`.
        :param int advertised_port: The port number which will be used in the brokers' `advertised.brokers`.
        :param Mapping[str, Any] annotations: Annotations that will be added to the `Ingress` or `Service` resource. You can use this field to configure DNS providers such as External DNS. This field can be used only with `loadbalancer`, `nodeport`, or `ingress` type listeners.
        :param str host: The broker host. This field will be used in the Ingress resource or in the Route resource to specify the desired hostname. This field can be used only with `route` (optional) or `ingress` (required) type listeners.
        :param str load_balancer_ip: The loadbalancer is requested with the IP address specified in this field. This feature depends on whether the underlying cloud provider supports specifying the `loadBalancerIP` when a load balancer is created. This field is ignored if the cloud provider does not support the feature.This field can be used only with `loadbalancer` type listener.
        :param int node_port: Node port for the per-broker service. This field can be used only with `nodeport` type listener.
        """
        pulumi.set(__self__, "broker", broker)
        if advertised_host is not None:
            pulumi.set(__self__, "advertised_host", advertised_host)
        if advertised_port is not None:
            pulumi.set(__self__, "advertised_port", advertised_port)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if load_balancer_ip is not None:
            pulumi.set(__self__, "load_balancer_ip", load_balancer_ip)
        if node_port is not None:
            pulumi.set(__self__, "node_port", node_port)

    @property
    @pulumi.getter
    def broker(self) -> int:
        """
        ID of the kafka broker (broker identifier). Broker IDs start from 0 and correspond to the number of broker replicas.
        """
        return pulumi.get(self, "broker")

    @property
    @pulumi.getter(name="advertisedHost")
    def advertised_host(self) -> Optional[str]:
        """
        The host name which will be used in the brokers' `advertised.brokers`.
        """
        return pulumi.get(self, "advertised_host")

    @property
    @pulumi.getter(name="advertisedPort")
    def advertised_port(self) -> Optional[int]:
        """
        The port number which will be used in the brokers' `advertised.brokers`.
        """
        return pulumi.get(self, "advertised_port")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations that will be added to the `Ingress` or `Service` resource. You can use this field to configure DNS providers such as External DNS. This field can be used only with `loadbalancer`, `nodeport`, or `ingress` type listeners.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The broker host. This field will be used in the Ingress resource or in the Route resource to specify the desired hostname. This field can be used only with `route` (optional) or `ingress` (required) type listeners.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="loadBalancerIP")
    def load_balancer_ip(self) -> Optional[str]:
        """
        The loadbalancer is requested with the IP address specified in this field. This feature depends on whether the underlying cloud provider supports specifying the `loadBalancerIP` when a load balancer is created. This field is ignored if the cloud provider does not support the feature.This field can be used only with `loadbalancer` type listener.
        """
        return pulumi.get(self, "load_balancer_ip")

    @property
    @pulumi.getter(name="nodePort")
    def node_port(self) -> Optional[int]:
        """
        Node port for the per-broker service. This field can be used only with `nodeport` type listener.
        """
        return pulumi.get(self, "node_port")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf0NetworkPolicyPeers(dict):
    def __init__(__self__, *,
                 ip_block: Optional['outputs.KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersIpBlock'] = None,
                 namespace_selector: Optional['outputs.KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersNamespaceSelector'] = None,
                 pod_selector: Optional['outputs.KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersPodSelector'] = None):
        if ip_block is not None:
            pulumi.set(__self__, "ip_block", ip_block)
        if namespace_selector is not None:
            pulumi.set(__self__, "namespace_selector", namespace_selector)
        if pod_selector is not None:
            pulumi.set(__self__, "pod_selector", pod_selector)

    @property
    @pulumi.getter(name="ipBlock")
    def ip_block(self) -> Optional['outputs.KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersIpBlock']:
        return pulumi.get(self, "ip_block")

    @property
    @pulumi.getter(name="namespaceSelector")
    def namespace_selector(self) -> Optional['outputs.KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersNamespaceSelector']:
        return pulumi.get(self, "namespace_selector")

    @property
    @pulumi.getter(name="podSelector")
    def pod_selector(self) -> Optional['outputs.KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersPodSelector']:
        return pulumi.get(self, "pod_selector")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersIpBlock(dict):
    def __init__(__self__, *,
                 cidr: Optional[str] = None,
                 except_: Optional[Sequence[str]] = None):
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if except_ is not None:
            pulumi.set(__self__, "except_", except_)

    @property
    @pulumi.getter
    def cidr(self) -> Optional[str]:
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter(name="except")
    def except_(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "except_")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersNamespaceSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersNamespaceSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersNamespaceSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersNamespaceSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersPodSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersPodSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersPodSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf0NetworkPolicyPeersPodSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf1(dict):
    def __init__(__self__, *,
                 external: Optional['outputs.KafkaSpecKafkaListenersOneOf1External'] = None,
                 plain: Optional['outputs.KafkaSpecKafkaListenersOneOf1Plain'] = None,
                 tls: Optional['outputs.KafkaSpecKafkaListenersOneOf1Tls'] = None):
        """
        :param 'KafkaSpecKafkaListenersOneOf1ExternalArgs' external: Configures external listener on port 9094.
        :param 'KafkaSpecKafkaListenersOneOf1PlainArgs' plain: Configures plain listener on port 9092.
        :param 'KafkaSpecKafkaListenersOneOf1TlsArgs' tls: Configures TLS listener on port 9093.
        """
        if external is not None:
            pulumi.set(__self__, "external", external)
        if plain is not None:
            pulumi.set(__self__, "plain", plain)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter
    def external(self) -> Optional['outputs.KafkaSpecKafkaListenersOneOf1External']:
        """
        Configures external listener on port 9094.
        """
        return pulumi.get(self, "external")

    @property
    @pulumi.getter
    def plain(self) -> Optional['outputs.KafkaSpecKafkaListenersOneOf1Plain']:
        """
        Configures plain listener on port 9092.
        """
        return pulumi.get(self, "plain")

    @property
    @pulumi.getter
    def tls(self) -> Optional['outputs.KafkaSpecKafkaListenersOneOf1Tls']:
        """
        Configures TLS listener on port 9093.
        """
        return pulumi.get(self, "tls")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf1External(dict):
    """
    Configures external listener on port 9094.
    """
    def __init__(__self__, *,
                 type: str,
                 authentication: Optional['outputs.KafkaSpecKafkaListenersOneOf1ExternalAuthentication'] = None,
                 class_: Optional[str] = None,
                 configuration: Optional['outputs.KafkaSpecKafkaListenersOneOf1ExternalConfiguration'] = None,
                 network_policy_peers: Optional[Sequence['outputs.KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeers']] = None,
                 overrides: Optional['outputs.KafkaSpecKafkaListenersOneOf1ExternalOverrides'] = None,
                 tls: Optional[bool] = None):
        """
        Configures external listener on port 9094.
        :param str type: Type of the external listener. Currently the supported types are `route`, `loadbalancer`, and `nodeport`. 
               
               * `route` type uses OpenShift Routes to expose Kafka.* `loadbalancer` type uses LoadBalancer type services to expose Kafka.* `nodeport` type uses NodePort type services to expose Kafka..
        :param 'KafkaSpecKafkaListenersOneOf1ExternalAuthenticationArgs' authentication: Authentication configuration for Kafka brokers.
        :param str class_: Configures the `Ingress` class that defines which `Ingress` controller will be used. If not set, the `Ingress` class is set to `nginx`.
        :param 'KafkaSpecKafkaListenersOneOf1ExternalConfigurationArgs' configuration: External listener configuration.
        :param Sequence['KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersArgs'] network_policy_peers: List of peers which should be able to connect to this listener. Peers in this list are combined using a logical OR operation. If this field is empty or missing, all connections will be allowed for this listener. If this field is present and contains at least one item, the listener only allows the traffic which matches at least one item in this list.
        :param 'KafkaSpecKafkaListenersOneOf1ExternalOverridesArgs' overrides: Overrides for external bootstrap and broker services and externally advertised addresses.
        :param bool tls: Enables TLS encryption on the listener. By default set to `true` for enabled TLS encryption.
        """
        pulumi.set(__self__, "type", type)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if class_ is not None:
            pulumi.set(__self__, "class_", class_)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if network_policy_peers is not None:
            pulumi.set(__self__, "network_policy_peers", network_policy_peers)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the external listener. Currently the supported types are `route`, `loadbalancer`, and `nodeport`. 

        * `route` type uses OpenShift Routes to expose Kafka.* `loadbalancer` type uses LoadBalancer type services to expose Kafka.* `nodeport` type uses NodePort type services to expose Kafka..
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def authentication(self) -> Optional['outputs.KafkaSpecKafkaListenersOneOf1ExternalAuthentication']:
        """
        Authentication configuration for Kafka brokers.
        """
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter(name="class")
    def class_(self) -> Optional[str]:
        """
        Configures the `Ingress` class that defines which `Ingress` controller will be used. If not set, the `Ingress` class is set to `nginx`.
        """
        return pulumi.get(self, "class_")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.KafkaSpecKafkaListenersOneOf1ExternalConfiguration']:
        """
        External listener configuration.
        """
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter(name="networkPolicyPeers")
    def network_policy_peers(self) -> Optional[Sequence['outputs.KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeers']]:
        """
        List of peers which should be able to connect to this listener. Peers in this list are combined using a logical OR operation. If this field is empty or missing, all connections will be allowed for this listener. If this field is present and contains at least one item, the listener only allows the traffic which matches at least one item in this list.
        """
        return pulumi.get(self, "network_policy_peers")

    @property
    @pulumi.getter
    def overrides(self) -> Optional['outputs.KafkaSpecKafkaListenersOneOf1ExternalOverrides']:
        """
        Overrides for external bootstrap and broker services and externally advertised addresses.
        """
        return pulumi.get(self, "overrides")

    @property
    @pulumi.getter
    def tls(self) -> Optional[bool]:
        """
        Enables TLS encryption on the listener. By default set to `true` for enabled TLS encryption.
        """
        return pulumi.get(self, "tls")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf1ExternalAuthentication(dict):
    """
    Authentication configuration for Kafka brokers.
    """
    def __init__(__self__, *,
                 type: str,
                 access_token_is_jwt: Optional[bool] = None,
                 check_access_token_type: Optional[bool] = None,
                 check_issuer: Optional[bool] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional['outputs.KafkaSpecKafkaListenersOneOf1ExternalAuthenticationClientSecret'] = None,
                 disable_tls_hostname_verification: Optional[bool] = None,
                 enable_ecdsa: Optional[bool] = None,
                 fallback_user_name_claim: Optional[str] = None,
                 fallback_user_name_prefix: Optional[str] = None,
                 introspection_endpoint_uri: Optional[str] = None,
                 jwks_endpoint_uri: Optional[str] = None,
                 jwks_expiry_seconds: Optional[int] = None,
                 jwks_min_refresh_pause_seconds: Optional[int] = None,
                 jwks_refresh_seconds: Optional[int] = None,
                 max_seconds_without_reauthentication: Optional[int] = None,
                 tls_trusted_certificates: Optional[Sequence['outputs.KafkaSpecKafkaListenersOneOf1ExternalAuthenticationTlsTrustedCertificates']] = None,
                 user_info_endpoint_uri: Optional[str] = None,
                 user_name_claim: Optional[str] = None,
                 valid_issuer_uri: Optional[str] = None,
                 valid_token_type: Optional[str] = None):
        """
        Authentication configuration for Kafka brokers.
        :param str type: Authentication type. `oauth` type uses SASL OAUTHBEARER Authentication. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `tls` type uses TLS Client Authentication. `tls` type is supported only on TLS listeners.
        :param bool access_token_is_jwt: Configure whether the access token is treated as JWT. This must be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
        :param bool check_access_token_type: Configure whether the access token type check is performed or not. This should be set to `false` if the authorization server does not include 'typ' claim in JWT token. Defaults to `true`.
        :param bool check_issuer: Enable or disable issuer checking. By default issuer is checked using the value configured by `validIssuerUri`. Default value is `true`.
        :param str client_id: OAuth Client ID which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
        :param 'KafkaSpecKafkaListenersOneOf1ExternalAuthenticationClientSecretArgs' client_secret: Link to Kubernetes Secret containing the OAuth client secret which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
        :param bool disable_tls_hostname_verification: Enable or disable TLS hostname verification. Default value is `false`.
        :param bool enable_ecdsa: Enable or disable ECDSA support by installing BouncyCastle crypto provider. Default value is `false`.
        :param str fallback_user_name_claim: The fallback username claim to be used for the user id if the claim specified by `userNameClaim` is not present. This is useful when `client_credentials` authentication only results in the client id being provided in another claim. It only takes effect if `userNameClaim` is set.
        :param str fallback_user_name_prefix: The prefix to use with the value of `fallbackUserNameClaim` to construct the user id. This only takes effect if `fallbackUserNameClaim` is true, and the value is present for the claim. Mapping usernames and client ids into the same user id space is useful in preventing name collisions.
        :param str introspection_endpoint_uri: URI of the token introspection endpoint which can be used to validate opaque non-JWT tokens.
        :param str jwks_endpoint_uri: URI of the JWKS certificate endpoint, which can be used for local JWT validation.
        :param int jwks_expiry_seconds: Configures how often are the JWKS certificates considered valid. The expiry interval has to be at least 60 seconds longer then the refresh interval specified in `jwksRefreshSeconds`. Defaults to 360 seconds.
        :param int jwks_min_refresh_pause_seconds: The minimum pause between two consecutive refreshes. When an unknown signing key is encountered the refresh is scheduled immediately, but will always wait for this minimum pause. Defaults to 1 second.
        :param int jwks_refresh_seconds: Configures how often are the JWKS certificates refreshed. The refresh interval has to be at least 60 seconds shorter then the expiry interval specified in `jwksExpirySeconds`. Defaults to 300 seconds.
        :param int max_seconds_without_reauthentication: Maximum number of seconds the authenticated session remains valid without re-authentication. This enables Apache Kafka re-authentication feature, and causes sessions to expire when the access token expires. If the access token expires before max time or if max time is reached, the client has to re-authenticate, otherwise the server will drop the connection. Not set by default - the authenticated session does not expire when the access token expires.
        :param Sequence['KafkaSpecKafkaListenersOneOf1ExternalAuthenticationTlsTrustedCertificatesArgs'] tls_trusted_certificates: Trusted certificates for TLS connection to the OAuth server.
        :param str user_info_endpoint_uri: URI of the User Info Endpoint to use as a fallback to obtaining the user id when the Introspection Endpoint does not return information that can be used for the user id. 
        :param str user_name_claim: Name of the claim from the JWT authentication token, Introspection Endpoint response or User Info Endpoint response which will be used to extract the user id. Defaults to `sub`.
        :param str valid_issuer_uri: URI of the token issuer used for authentication.
        :param str valid_token_type: Valid value for the `token_type` attribute returned by the Introspection Endpoint. No default value, and not checked by default.
        """
        pulumi.set(__self__, "type", type)
        if access_token_is_jwt is not None:
            pulumi.set(__self__, "access_token_is_jwt", access_token_is_jwt)
        if check_access_token_type is not None:
            pulumi.set(__self__, "check_access_token_type", check_access_token_type)
        if check_issuer is not None:
            pulumi.set(__self__, "check_issuer", check_issuer)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if disable_tls_hostname_verification is not None:
            pulumi.set(__self__, "disable_tls_hostname_verification", disable_tls_hostname_verification)
        if enable_ecdsa is not None:
            pulumi.set(__self__, "enable_ecdsa", enable_ecdsa)
        if fallback_user_name_claim is not None:
            pulumi.set(__self__, "fallback_user_name_claim", fallback_user_name_claim)
        if fallback_user_name_prefix is not None:
            pulumi.set(__self__, "fallback_user_name_prefix", fallback_user_name_prefix)
        if introspection_endpoint_uri is not None:
            pulumi.set(__self__, "introspection_endpoint_uri", introspection_endpoint_uri)
        if jwks_endpoint_uri is not None:
            pulumi.set(__self__, "jwks_endpoint_uri", jwks_endpoint_uri)
        if jwks_expiry_seconds is not None:
            pulumi.set(__self__, "jwks_expiry_seconds", jwks_expiry_seconds)
        if jwks_min_refresh_pause_seconds is not None:
            pulumi.set(__self__, "jwks_min_refresh_pause_seconds", jwks_min_refresh_pause_seconds)
        if jwks_refresh_seconds is not None:
            pulumi.set(__self__, "jwks_refresh_seconds", jwks_refresh_seconds)
        if max_seconds_without_reauthentication is not None:
            pulumi.set(__self__, "max_seconds_without_reauthentication", max_seconds_without_reauthentication)
        if tls_trusted_certificates is not None:
            pulumi.set(__self__, "tls_trusted_certificates", tls_trusted_certificates)
        if user_info_endpoint_uri is not None:
            pulumi.set(__self__, "user_info_endpoint_uri", user_info_endpoint_uri)
        if user_name_claim is not None:
            pulumi.set(__self__, "user_name_claim", user_name_claim)
        if valid_issuer_uri is not None:
            pulumi.set(__self__, "valid_issuer_uri", valid_issuer_uri)
        if valid_token_type is not None:
            pulumi.set(__self__, "valid_token_type", valid_token_type)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Authentication type. `oauth` type uses SASL OAUTHBEARER Authentication. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `tls` type uses TLS Client Authentication. `tls` type is supported only on TLS listeners.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessTokenIsJwt")
    def access_token_is_jwt(self) -> Optional[bool]:
        """
        Configure whether the access token is treated as JWT. This must be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
        """
        return pulumi.get(self, "access_token_is_jwt")

    @property
    @pulumi.getter(name="checkAccessTokenType")
    def check_access_token_type(self) -> Optional[bool]:
        """
        Configure whether the access token type check is performed or not. This should be set to `false` if the authorization server does not include 'typ' claim in JWT token. Defaults to `true`.
        """
        return pulumi.get(self, "check_access_token_type")

    @property
    @pulumi.getter(name="checkIssuer")
    def check_issuer(self) -> Optional[bool]:
        """
        Enable or disable issuer checking. By default issuer is checked using the value configured by `validIssuerUri`. Default value is `true`.
        """
        return pulumi.get(self, "check_issuer")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        OAuth Client ID which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional['outputs.KafkaSpecKafkaListenersOneOf1ExternalAuthenticationClientSecret']:
        """
        Link to Kubernetes Secret containing the OAuth client secret which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="disableTlsHostnameVerification")
    def disable_tls_hostname_verification(self) -> Optional[bool]:
        """
        Enable or disable TLS hostname verification. Default value is `false`.
        """
        return pulumi.get(self, "disable_tls_hostname_verification")

    @property
    @pulumi.getter(name="enableECDSA")
    def enable_ecdsa(self) -> Optional[bool]:
        """
        Enable or disable ECDSA support by installing BouncyCastle crypto provider. Default value is `false`.
        """
        return pulumi.get(self, "enable_ecdsa")

    @property
    @pulumi.getter(name="fallbackUserNameClaim")
    def fallback_user_name_claim(self) -> Optional[str]:
        """
        The fallback username claim to be used for the user id if the claim specified by `userNameClaim` is not present. This is useful when `client_credentials` authentication only results in the client id being provided in another claim. It only takes effect if `userNameClaim` is set.
        """
        return pulumi.get(self, "fallback_user_name_claim")

    @property
    @pulumi.getter(name="fallbackUserNamePrefix")
    def fallback_user_name_prefix(self) -> Optional[str]:
        """
        The prefix to use with the value of `fallbackUserNameClaim` to construct the user id. This only takes effect if `fallbackUserNameClaim` is true, and the value is present for the claim. Mapping usernames and client ids into the same user id space is useful in preventing name collisions.
        """
        return pulumi.get(self, "fallback_user_name_prefix")

    @property
    @pulumi.getter(name="introspectionEndpointUri")
    def introspection_endpoint_uri(self) -> Optional[str]:
        """
        URI of the token introspection endpoint which can be used to validate opaque non-JWT tokens.
        """
        return pulumi.get(self, "introspection_endpoint_uri")

    @property
    @pulumi.getter(name="jwksEndpointUri")
    def jwks_endpoint_uri(self) -> Optional[str]:
        """
        URI of the JWKS certificate endpoint, which can be used for local JWT validation.
        """
        return pulumi.get(self, "jwks_endpoint_uri")

    @property
    @pulumi.getter(name="jwksExpirySeconds")
    def jwks_expiry_seconds(self) -> Optional[int]:
        """
        Configures how often are the JWKS certificates considered valid. The expiry interval has to be at least 60 seconds longer then the refresh interval specified in `jwksRefreshSeconds`. Defaults to 360 seconds.
        """
        return pulumi.get(self, "jwks_expiry_seconds")

    @property
    @pulumi.getter(name="jwksMinRefreshPauseSeconds")
    def jwks_min_refresh_pause_seconds(self) -> Optional[int]:
        """
        The minimum pause between two consecutive refreshes. When an unknown signing key is encountered the refresh is scheduled immediately, but will always wait for this minimum pause. Defaults to 1 second.
        """
        return pulumi.get(self, "jwks_min_refresh_pause_seconds")

    @property
    @pulumi.getter(name="jwksRefreshSeconds")
    def jwks_refresh_seconds(self) -> Optional[int]:
        """
        Configures how often are the JWKS certificates refreshed. The refresh interval has to be at least 60 seconds shorter then the expiry interval specified in `jwksExpirySeconds`. Defaults to 300 seconds.
        """
        return pulumi.get(self, "jwks_refresh_seconds")

    @property
    @pulumi.getter(name="maxSecondsWithoutReauthentication")
    def max_seconds_without_reauthentication(self) -> Optional[int]:
        """
        Maximum number of seconds the authenticated session remains valid without re-authentication. This enables Apache Kafka re-authentication feature, and causes sessions to expire when the access token expires. If the access token expires before max time or if max time is reached, the client has to re-authenticate, otherwise the server will drop the connection. Not set by default - the authenticated session does not expire when the access token expires.
        """
        return pulumi.get(self, "max_seconds_without_reauthentication")

    @property
    @pulumi.getter(name="tlsTrustedCertificates")
    def tls_trusted_certificates(self) -> Optional[Sequence['outputs.KafkaSpecKafkaListenersOneOf1ExternalAuthenticationTlsTrustedCertificates']]:
        """
        Trusted certificates for TLS connection to the OAuth server.
        """
        return pulumi.get(self, "tls_trusted_certificates")

    @property
    @pulumi.getter(name="userInfoEndpointUri")
    def user_info_endpoint_uri(self) -> Optional[str]:
        """
        URI of the User Info Endpoint to use as a fallback to obtaining the user id when the Introspection Endpoint does not return information that can be used for the user id. 
        """
        return pulumi.get(self, "user_info_endpoint_uri")

    @property
    @pulumi.getter(name="userNameClaim")
    def user_name_claim(self) -> Optional[str]:
        """
        Name of the claim from the JWT authentication token, Introspection Endpoint response or User Info Endpoint response which will be used to extract the user id. Defaults to `sub`.
        """
        return pulumi.get(self, "user_name_claim")

    @property
    @pulumi.getter(name="validIssuerUri")
    def valid_issuer_uri(self) -> Optional[str]:
        """
        URI of the token issuer used for authentication.
        """
        return pulumi.get(self, "valid_issuer_uri")

    @property
    @pulumi.getter(name="validTokenType")
    def valid_token_type(self) -> Optional[str]:
        """
        Valid value for the `token_type` attribute returned by the Introspection Endpoint. No default value, and not checked by default.
        """
        return pulumi.get(self, "valid_token_type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf1ExternalAuthenticationClientSecret(dict):
    """
    Link to Kubernetes Secret containing the OAuth client secret which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
    """
    def __init__(__self__, *,
                 key: str,
                 secret_name: str):
        """
        Link to Kubernetes Secret containing the OAuth client secret which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
        :param str key: The key under which the secret value is stored in the Kubernetes Secret.
        :param str secret_name: The name of the Kubernetes Secret containing the secret value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key under which the secret value is stored in the Kubernetes Secret.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Kubernetes Secret containing the secret value.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf1ExternalAuthenticationTlsTrustedCertificates(dict):
    def __init__(__self__, *,
                 certificate: str,
                 secret_name: str):
        """
        :param str certificate: The name of the file certificate in the Secret.
        :param str secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> str:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf1ExternalConfiguration(dict):
    """
    External listener configuration.
    """
    def __init__(__self__, *,
                 bootstrap: Optional['outputs.KafkaSpecKafkaListenersOneOf1ExternalConfigurationBootstrap'] = None,
                 broker_cert_chain_and_key: Optional['outputs.KafkaSpecKafkaListenersOneOf1ExternalConfigurationBrokerCertChainAndKey'] = None,
                 brokers: Optional[Sequence['outputs.KafkaSpecKafkaListenersOneOf1ExternalConfigurationBrokers']] = None):
        """
        External listener configuration.
        :param 'KafkaSpecKafkaListenersOneOf1ExternalConfigurationBootstrapArgs' bootstrap: External bootstrap ingress configuration.
        :param 'KafkaSpecKafkaListenersOneOf1ExternalConfigurationBrokerCertChainAndKeyArgs' broker_cert_chain_and_key: Reference to the `Secret` which holds the certificate and private key pair. The certificate can optionally contain the whole chain.
        :param Sequence['KafkaSpecKafkaListenersOneOf1ExternalConfigurationBrokersArgs'] brokers: External broker ingress configuration.
        """
        if bootstrap is not None:
            pulumi.set(__self__, "bootstrap", bootstrap)
        if broker_cert_chain_and_key is not None:
            pulumi.set(__self__, "broker_cert_chain_and_key", broker_cert_chain_and_key)
        if brokers is not None:
            pulumi.set(__self__, "brokers", brokers)

    @property
    @pulumi.getter
    def bootstrap(self) -> Optional['outputs.KafkaSpecKafkaListenersOneOf1ExternalConfigurationBootstrap']:
        """
        External bootstrap ingress configuration.
        """
        return pulumi.get(self, "bootstrap")

    @property
    @pulumi.getter(name="brokerCertChainAndKey")
    def broker_cert_chain_and_key(self) -> Optional['outputs.KafkaSpecKafkaListenersOneOf1ExternalConfigurationBrokerCertChainAndKey']:
        """
        Reference to the `Secret` which holds the certificate and private key pair. The certificate can optionally contain the whole chain.
        """
        return pulumi.get(self, "broker_cert_chain_and_key")

    @property
    @pulumi.getter
    def brokers(self) -> Optional[Sequence['outputs.KafkaSpecKafkaListenersOneOf1ExternalConfigurationBrokers']]:
        """
        External broker ingress configuration.
        """
        return pulumi.get(self, "brokers")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf1ExternalConfigurationBootstrap(dict):
    """
    External bootstrap ingress configuration.
    """
    def __init__(__self__, *,
                 host: str,
                 address: Optional[str] = None,
                 dns_annotations: Optional[Mapping[str, Any]] = None):
        """
        External bootstrap ingress configuration.
        :param str host: Host for the bootstrap route. This field will be used in the Ingress resource.
        :param str address: Additional address name for the bootstrap service. The address will be added to the list of subject alternative names of the TLS certificates.
        :param Mapping[str, Any] dns_annotations: Annotations that will be added to the `Ingress` resource. You can use this field to configure DNS providers such as External DNS.
        """
        pulumi.set(__self__, "host", host)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if dns_annotations is not None:
            pulumi.set(__self__, "dns_annotations", dns_annotations)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        Host for the bootstrap route. This field will be used in the Ingress resource.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        Additional address name for the bootstrap service. The address will be added to the list of subject alternative names of the TLS certificates.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="dnsAnnotations")
    def dns_annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations that will be added to the `Ingress` resource. You can use this field to configure DNS providers such as External DNS.
        """
        return pulumi.get(self, "dns_annotations")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf1ExternalConfigurationBrokerCertChainAndKey(dict):
    """
    Reference to the `Secret` which holds the certificate and private key pair. The certificate can optionally contain the whole chain.
    """
    def __init__(__self__, *,
                 certificate: str,
                 key: str,
                 secret_name: str):
        """
        Reference to the `Secret` which holds the certificate and private key pair. The certificate can optionally contain the whole chain.
        :param str certificate: The name of the file certificate in the Secret.
        :param str key: The name of the private key in the Secret.
        :param str secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> str:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The name of the private key in the Secret.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf1ExternalConfigurationBrokers(dict):
    def __init__(__self__, *,
                 host: str,
                 advertised_host: Optional[str] = None,
                 advertised_port: Optional[int] = None,
                 broker: Optional[int] = None,
                 dns_annotations: Optional[Mapping[str, Any]] = None):
        """
        :param str host: Host for the broker ingress. This field will be used in the Ingress resource.
        :param str advertised_host: The host name which will be used in the brokers' `advertised.brokers`.
        :param int advertised_port: The port number which will be used in the brokers' `advertised.brokers`.
        :param int broker: Id of the kafka broker (broker identifier).
        :param Mapping[str, Any] dns_annotations: Annotations that will be added to the `Ingress` resources for individual brokers. You can use this field to configure DNS providers such as External DNS.
        """
        pulumi.set(__self__, "host", host)
        if advertised_host is not None:
            pulumi.set(__self__, "advertised_host", advertised_host)
        if advertised_port is not None:
            pulumi.set(__self__, "advertised_port", advertised_port)
        if broker is not None:
            pulumi.set(__self__, "broker", broker)
        if dns_annotations is not None:
            pulumi.set(__self__, "dns_annotations", dns_annotations)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        Host for the broker ingress. This field will be used in the Ingress resource.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="advertisedHost")
    def advertised_host(self) -> Optional[str]:
        """
        The host name which will be used in the brokers' `advertised.brokers`.
        """
        return pulumi.get(self, "advertised_host")

    @property
    @pulumi.getter(name="advertisedPort")
    def advertised_port(self) -> Optional[int]:
        """
        The port number which will be used in the brokers' `advertised.brokers`.
        """
        return pulumi.get(self, "advertised_port")

    @property
    @pulumi.getter
    def broker(self) -> Optional[int]:
        """
        Id of the kafka broker (broker identifier).
        """
        return pulumi.get(self, "broker")

    @property
    @pulumi.getter(name="dnsAnnotations")
    def dns_annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations that will be added to the `Ingress` resources for individual brokers. You can use this field to configure DNS providers such as External DNS.
        """
        return pulumi.get(self, "dns_annotations")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeers(dict):
    def __init__(__self__, *,
                 ip_block: Optional['outputs.KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersIpBlock'] = None,
                 namespace_selector: Optional['outputs.KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersNamespaceSelector'] = None,
                 pod_selector: Optional['outputs.KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersPodSelector'] = None):
        if ip_block is not None:
            pulumi.set(__self__, "ip_block", ip_block)
        if namespace_selector is not None:
            pulumi.set(__self__, "namespace_selector", namespace_selector)
        if pod_selector is not None:
            pulumi.set(__self__, "pod_selector", pod_selector)

    @property
    @pulumi.getter(name="ipBlock")
    def ip_block(self) -> Optional['outputs.KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersIpBlock']:
        return pulumi.get(self, "ip_block")

    @property
    @pulumi.getter(name="namespaceSelector")
    def namespace_selector(self) -> Optional['outputs.KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersNamespaceSelector']:
        return pulumi.get(self, "namespace_selector")

    @property
    @pulumi.getter(name="podSelector")
    def pod_selector(self) -> Optional['outputs.KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersPodSelector']:
        return pulumi.get(self, "pod_selector")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersIpBlock(dict):
    def __init__(__self__, *,
                 cidr: Optional[str] = None,
                 except_: Optional[Sequence[str]] = None):
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if except_ is not None:
            pulumi.set(__self__, "except_", except_)

    @property
    @pulumi.getter
    def cidr(self) -> Optional[str]:
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter(name="except")
    def except_(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "except_")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersNamespaceSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersNamespaceSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersNamespaceSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersNamespaceSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersPodSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersPodSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersPodSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf1ExternalNetworkPolicyPeersPodSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf1ExternalOverrides(dict):
    """
    Overrides for external bootstrap and broker services and externally advertised addresses.
    """
    def __init__(__self__, *,
                 bootstrap: Optional['outputs.KafkaSpecKafkaListenersOneOf1ExternalOverridesBootstrap'] = None,
                 brokers: Optional[Sequence['outputs.KafkaSpecKafkaListenersOneOf1ExternalOverridesBrokers']] = None):
        """
        Overrides for external bootstrap and broker services and externally advertised addresses.
        :param 'KafkaSpecKafkaListenersOneOf1ExternalOverridesBootstrapArgs' bootstrap: External bootstrap service configuration.
        :param Sequence['KafkaSpecKafkaListenersOneOf1ExternalOverridesBrokersArgs'] brokers: External broker services configuration.
        """
        if bootstrap is not None:
            pulumi.set(__self__, "bootstrap", bootstrap)
        if brokers is not None:
            pulumi.set(__self__, "brokers", brokers)

    @property
    @pulumi.getter
    def bootstrap(self) -> Optional['outputs.KafkaSpecKafkaListenersOneOf1ExternalOverridesBootstrap']:
        """
        External bootstrap service configuration.
        """
        return pulumi.get(self, "bootstrap")

    @property
    @pulumi.getter
    def brokers(self) -> Optional[Sequence['outputs.KafkaSpecKafkaListenersOneOf1ExternalOverridesBrokers']]:
        """
        External broker services configuration.
        """
        return pulumi.get(self, "brokers")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf1ExternalOverridesBootstrap(dict):
    """
    External bootstrap service configuration.
    """
    def __init__(__self__, *,
                 address: Optional[str] = None,
                 dns_annotations: Optional[Mapping[str, Any]] = None,
                 node_port: Optional[int] = None):
        """
        External bootstrap service configuration.
        :param str address: Additional address name for the bootstrap service. The address will be added to the list of subject alternative names of the TLS certificates.
        :param Mapping[str, Any] dns_annotations: Annotations that will be added to the `Service` resource. You can use this field to configure DNS providers such as External DNS.
        :param int node_port: Node port for the bootstrap service.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if dns_annotations is not None:
            pulumi.set(__self__, "dns_annotations", dns_annotations)
        if node_port is not None:
            pulumi.set(__self__, "node_port", node_port)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        Additional address name for the bootstrap service. The address will be added to the list of subject alternative names of the TLS certificates.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="dnsAnnotations")
    def dns_annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations that will be added to the `Service` resource. You can use this field to configure DNS providers such as External DNS.
        """
        return pulumi.get(self, "dns_annotations")

    @property
    @pulumi.getter(name="nodePort")
    def node_port(self) -> Optional[int]:
        """
        Node port for the bootstrap service.
        """
        return pulumi.get(self, "node_port")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf1ExternalOverridesBrokers(dict):
    def __init__(__self__, *,
                 advertised_host: Optional[str] = None,
                 advertised_port: Optional[int] = None,
                 broker: Optional[int] = None,
                 dns_annotations: Optional[Mapping[str, Any]] = None,
                 node_port: Optional[int] = None):
        """
        :param str advertised_host: The host name which will be used in the brokers' `advertised.brokers`.
        :param int advertised_port: The port number which will be used in the brokers' `advertised.brokers`.
        :param int broker: Id of the kafka broker (broker identifier).
        :param Mapping[str, Any] dns_annotations: Annotations that will be added to the `Service` resources for individual brokers. You can use this field to configure DNS providers such as External DNS.
        :param int node_port: Node port for the broker service.
        """
        if advertised_host is not None:
            pulumi.set(__self__, "advertised_host", advertised_host)
        if advertised_port is not None:
            pulumi.set(__self__, "advertised_port", advertised_port)
        if broker is not None:
            pulumi.set(__self__, "broker", broker)
        if dns_annotations is not None:
            pulumi.set(__self__, "dns_annotations", dns_annotations)
        if node_port is not None:
            pulumi.set(__self__, "node_port", node_port)

    @property
    @pulumi.getter(name="advertisedHost")
    def advertised_host(self) -> Optional[str]:
        """
        The host name which will be used in the brokers' `advertised.brokers`.
        """
        return pulumi.get(self, "advertised_host")

    @property
    @pulumi.getter(name="advertisedPort")
    def advertised_port(self) -> Optional[int]:
        """
        The port number which will be used in the brokers' `advertised.brokers`.
        """
        return pulumi.get(self, "advertised_port")

    @property
    @pulumi.getter
    def broker(self) -> Optional[int]:
        """
        Id of the kafka broker (broker identifier).
        """
        return pulumi.get(self, "broker")

    @property
    @pulumi.getter(name="dnsAnnotations")
    def dns_annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations that will be added to the `Service` resources for individual brokers. You can use this field to configure DNS providers such as External DNS.
        """
        return pulumi.get(self, "dns_annotations")

    @property
    @pulumi.getter(name="nodePort")
    def node_port(self) -> Optional[int]:
        """
        Node port for the broker service.
        """
        return pulumi.get(self, "node_port")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf1Plain(dict):
    """
    Configures plain listener on port 9092.
    """
    def __init__(__self__, *,
                 authentication: Optional['outputs.KafkaSpecKafkaListenersOneOf1PlainAuthentication'] = None,
                 network_policy_peers: Optional[Sequence['outputs.KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeers']] = None):
        """
        Configures plain listener on port 9092.
        :param 'KafkaSpecKafkaListenersOneOf1PlainAuthenticationArgs' authentication: Authentication configuration for this listener. Since this listener does not use TLS transport you cannot configure an authentication with `type: tls`.
        :param Sequence['KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersArgs'] network_policy_peers: List of peers which should be able to connect to this listener. Peers in this list are combined using a logical OR operation. If this field is empty or missing, all connections will be allowed for this listener. If this field is present and contains at least one item, the listener only allows the traffic which matches at least one item in this list.
        """
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if network_policy_peers is not None:
            pulumi.set(__self__, "network_policy_peers", network_policy_peers)

    @property
    @pulumi.getter
    def authentication(self) -> Optional['outputs.KafkaSpecKafkaListenersOneOf1PlainAuthentication']:
        """
        Authentication configuration for this listener. Since this listener does not use TLS transport you cannot configure an authentication with `type: tls`.
        """
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter(name="networkPolicyPeers")
    def network_policy_peers(self) -> Optional[Sequence['outputs.KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeers']]:
        """
        List of peers which should be able to connect to this listener. Peers in this list are combined using a logical OR operation. If this field is empty or missing, all connections will be allowed for this listener. If this field is present and contains at least one item, the listener only allows the traffic which matches at least one item in this list.
        """
        return pulumi.get(self, "network_policy_peers")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf1PlainAuthentication(dict):
    """
    Authentication configuration for this listener. Since this listener does not use TLS transport you cannot configure an authentication with `type: tls`.
    """
    def __init__(__self__, *,
                 type: str,
                 access_token_is_jwt: Optional[bool] = None,
                 check_access_token_type: Optional[bool] = None,
                 check_issuer: Optional[bool] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional['outputs.KafkaSpecKafkaListenersOneOf1PlainAuthenticationClientSecret'] = None,
                 disable_tls_hostname_verification: Optional[bool] = None,
                 enable_ecdsa: Optional[bool] = None,
                 fallback_user_name_claim: Optional[str] = None,
                 fallback_user_name_prefix: Optional[str] = None,
                 introspection_endpoint_uri: Optional[str] = None,
                 jwks_endpoint_uri: Optional[str] = None,
                 jwks_expiry_seconds: Optional[int] = None,
                 jwks_min_refresh_pause_seconds: Optional[int] = None,
                 jwks_refresh_seconds: Optional[int] = None,
                 max_seconds_without_reauthentication: Optional[int] = None,
                 tls_trusted_certificates: Optional[Sequence['outputs.KafkaSpecKafkaListenersOneOf1PlainAuthenticationTlsTrustedCertificates']] = None,
                 user_info_endpoint_uri: Optional[str] = None,
                 user_name_claim: Optional[str] = None,
                 valid_issuer_uri: Optional[str] = None,
                 valid_token_type: Optional[str] = None):
        """
        Authentication configuration for this listener. Since this listener does not use TLS transport you cannot configure an authentication with `type: tls`.
        :param str type: Authentication type. `oauth` type uses SASL OAUTHBEARER Authentication. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `tls` type uses TLS Client Authentication. `tls` type is supported only on TLS listeners.
        :param bool access_token_is_jwt: Configure whether the access token is treated as JWT. This must be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
        :param bool check_access_token_type: Configure whether the access token type check is performed or not. This should be set to `false` if the authorization server does not include 'typ' claim in JWT token. Defaults to `true`.
        :param bool check_issuer: Enable or disable issuer checking. By default issuer is checked using the value configured by `validIssuerUri`. Default value is `true`.
        :param str client_id: OAuth Client ID which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
        :param 'KafkaSpecKafkaListenersOneOf1PlainAuthenticationClientSecretArgs' client_secret: Link to Kubernetes Secret containing the OAuth client secret which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
        :param bool disable_tls_hostname_verification: Enable or disable TLS hostname verification. Default value is `false`.
        :param bool enable_ecdsa: Enable or disable ECDSA support by installing BouncyCastle crypto provider. Default value is `false`.
        :param str fallback_user_name_claim: The fallback username claim to be used for the user id if the claim specified by `userNameClaim` is not present. This is useful when `client_credentials` authentication only results in the client id being provided in another claim. It only takes effect if `userNameClaim` is set.
        :param str fallback_user_name_prefix: The prefix to use with the value of `fallbackUserNameClaim` to construct the user id. This only takes effect if `fallbackUserNameClaim` is true, and the value is present for the claim. Mapping usernames and client ids into the same user id space is useful in preventing name collisions.
        :param str introspection_endpoint_uri: URI of the token introspection endpoint which can be used to validate opaque non-JWT tokens.
        :param str jwks_endpoint_uri: URI of the JWKS certificate endpoint, which can be used for local JWT validation.
        :param int jwks_expiry_seconds: Configures how often are the JWKS certificates considered valid. The expiry interval has to be at least 60 seconds longer then the refresh interval specified in `jwksRefreshSeconds`. Defaults to 360 seconds.
        :param int jwks_min_refresh_pause_seconds: The minimum pause between two consecutive refreshes. When an unknown signing key is encountered the refresh is scheduled immediately, but will always wait for this minimum pause. Defaults to 1 second.
        :param int jwks_refresh_seconds: Configures how often are the JWKS certificates refreshed. The refresh interval has to be at least 60 seconds shorter then the expiry interval specified in `jwksExpirySeconds`. Defaults to 300 seconds.
        :param int max_seconds_without_reauthentication: Maximum number of seconds the authenticated session remains valid without re-authentication. This enables Apache Kafka re-authentication feature, and causes sessions to expire when the access token expires. If the access token expires before max time or if max time is reached, the client has to re-authenticate, otherwise the server will drop the connection. Not set by default - the authenticated session does not expire when the access token expires.
        :param Sequence['KafkaSpecKafkaListenersOneOf1PlainAuthenticationTlsTrustedCertificatesArgs'] tls_trusted_certificates: Trusted certificates for TLS connection to the OAuth server.
        :param str user_info_endpoint_uri: URI of the User Info Endpoint to use as a fallback to obtaining the user id when the Introspection Endpoint does not return information that can be used for the user id. 
        :param str user_name_claim: Name of the claim from the JWT authentication token, Introspection Endpoint response or User Info Endpoint response which will be used to extract the user id. Defaults to `sub`.
        :param str valid_issuer_uri: URI of the token issuer used for authentication.
        :param str valid_token_type: Valid value for the `token_type` attribute returned by the Introspection Endpoint. No default value, and not checked by default.
        """
        pulumi.set(__self__, "type", type)
        if access_token_is_jwt is not None:
            pulumi.set(__self__, "access_token_is_jwt", access_token_is_jwt)
        if check_access_token_type is not None:
            pulumi.set(__self__, "check_access_token_type", check_access_token_type)
        if check_issuer is not None:
            pulumi.set(__self__, "check_issuer", check_issuer)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if disable_tls_hostname_verification is not None:
            pulumi.set(__self__, "disable_tls_hostname_verification", disable_tls_hostname_verification)
        if enable_ecdsa is not None:
            pulumi.set(__self__, "enable_ecdsa", enable_ecdsa)
        if fallback_user_name_claim is not None:
            pulumi.set(__self__, "fallback_user_name_claim", fallback_user_name_claim)
        if fallback_user_name_prefix is not None:
            pulumi.set(__self__, "fallback_user_name_prefix", fallback_user_name_prefix)
        if introspection_endpoint_uri is not None:
            pulumi.set(__self__, "introspection_endpoint_uri", introspection_endpoint_uri)
        if jwks_endpoint_uri is not None:
            pulumi.set(__self__, "jwks_endpoint_uri", jwks_endpoint_uri)
        if jwks_expiry_seconds is not None:
            pulumi.set(__self__, "jwks_expiry_seconds", jwks_expiry_seconds)
        if jwks_min_refresh_pause_seconds is not None:
            pulumi.set(__self__, "jwks_min_refresh_pause_seconds", jwks_min_refresh_pause_seconds)
        if jwks_refresh_seconds is not None:
            pulumi.set(__self__, "jwks_refresh_seconds", jwks_refresh_seconds)
        if max_seconds_without_reauthentication is not None:
            pulumi.set(__self__, "max_seconds_without_reauthentication", max_seconds_without_reauthentication)
        if tls_trusted_certificates is not None:
            pulumi.set(__self__, "tls_trusted_certificates", tls_trusted_certificates)
        if user_info_endpoint_uri is not None:
            pulumi.set(__self__, "user_info_endpoint_uri", user_info_endpoint_uri)
        if user_name_claim is not None:
            pulumi.set(__self__, "user_name_claim", user_name_claim)
        if valid_issuer_uri is not None:
            pulumi.set(__self__, "valid_issuer_uri", valid_issuer_uri)
        if valid_token_type is not None:
            pulumi.set(__self__, "valid_token_type", valid_token_type)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Authentication type. `oauth` type uses SASL OAUTHBEARER Authentication. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `tls` type uses TLS Client Authentication. `tls` type is supported only on TLS listeners.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessTokenIsJwt")
    def access_token_is_jwt(self) -> Optional[bool]:
        """
        Configure whether the access token is treated as JWT. This must be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
        """
        return pulumi.get(self, "access_token_is_jwt")

    @property
    @pulumi.getter(name="checkAccessTokenType")
    def check_access_token_type(self) -> Optional[bool]:
        """
        Configure whether the access token type check is performed or not. This should be set to `false` if the authorization server does not include 'typ' claim in JWT token. Defaults to `true`.
        """
        return pulumi.get(self, "check_access_token_type")

    @property
    @pulumi.getter(name="checkIssuer")
    def check_issuer(self) -> Optional[bool]:
        """
        Enable or disable issuer checking. By default issuer is checked using the value configured by `validIssuerUri`. Default value is `true`.
        """
        return pulumi.get(self, "check_issuer")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        OAuth Client ID which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional['outputs.KafkaSpecKafkaListenersOneOf1PlainAuthenticationClientSecret']:
        """
        Link to Kubernetes Secret containing the OAuth client secret which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="disableTlsHostnameVerification")
    def disable_tls_hostname_verification(self) -> Optional[bool]:
        """
        Enable or disable TLS hostname verification. Default value is `false`.
        """
        return pulumi.get(self, "disable_tls_hostname_verification")

    @property
    @pulumi.getter(name="enableECDSA")
    def enable_ecdsa(self) -> Optional[bool]:
        """
        Enable or disable ECDSA support by installing BouncyCastle crypto provider. Default value is `false`.
        """
        return pulumi.get(self, "enable_ecdsa")

    @property
    @pulumi.getter(name="fallbackUserNameClaim")
    def fallback_user_name_claim(self) -> Optional[str]:
        """
        The fallback username claim to be used for the user id if the claim specified by `userNameClaim` is not present. This is useful when `client_credentials` authentication only results in the client id being provided in another claim. It only takes effect if `userNameClaim` is set.
        """
        return pulumi.get(self, "fallback_user_name_claim")

    @property
    @pulumi.getter(name="fallbackUserNamePrefix")
    def fallback_user_name_prefix(self) -> Optional[str]:
        """
        The prefix to use with the value of `fallbackUserNameClaim` to construct the user id. This only takes effect if `fallbackUserNameClaim` is true, and the value is present for the claim. Mapping usernames and client ids into the same user id space is useful in preventing name collisions.
        """
        return pulumi.get(self, "fallback_user_name_prefix")

    @property
    @pulumi.getter(name="introspectionEndpointUri")
    def introspection_endpoint_uri(self) -> Optional[str]:
        """
        URI of the token introspection endpoint which can be used to validate opaque non-JWT tokens.
        """
        return pulumi.get(self, "introspection_endpoint_uri")

    @property
    @pulumi.getter(name="jwksEndpointUri")
    def jwks_endpoint_uri(self) -> Optional[str]:
        """
        URI of the JWKS certificate endpoint, which can be used for local JWT validation.
        """
        return pulumi.get(self, "jwks_endpoint_uri")

    @property
    @pulumi.getter(name="jwksExpirySeconds")
    def jwks_expiry_seconds(self) -> Optional[int]:
        """
        Configures how often are the JWKS certificates considered valid. The expiry interval has to be at least 60 seconds longer then the refresh interval specified in `jwksRefreshSeconds`. Defaults to 360 seconds.
        """
        return pulumi.get(self, "jwks_expiry_seconds")

    @property
    @pulumi.getter(name="jwksMinRefreshPauseSeconds")
    def jwks_min_refresh_pause_seconds(self) -> Optional[int]:
        """
        The minimum pause between two consecutive refreshes. When an unknown signing key is encountered the refresh is scheduled immediately, but will always wait for this minimum pause. Defaults to 1 second.
        """
        return pulumi.get(self, "jwks_min_refresh_pause_seconds")

    @property
    @pulumi.getter(name="jwksRefreshSeconds")
    def jwks_refresh_seconds(self) -> Optional[int]:
        """
        Configures how often are the JWKS certificates refreshed. The refresh interval has to be at least 60 seconds shorter then the expiry interval specified in `jwksExpirySeconds`. Defaults to 300 seconds.
        """
        return pulumi.get(self, "jwks_refresh_seconds")

    @property
    @pulumi.getter(name="maxSecondsWithoutReauthentication")
    def max_seconds_without_reauthentication(self) -> Optional[int]:
        """
        Maximum number of seconds the authenticated session remains valid without re-authentication. This enables Apache Kafka re-authentication feature, and causes sessions to expire when the access token expires. If the access token expires before max time or if max time is reached, the client has to re-authenticate, otherwise the server will drop the connection. Not set by default - the authenticated session does not expire when the access token expires.
        """
        return pulumi.get(self, "max_seconds_without_reauthentication")

    @property
    @pulumi.getter(name="tlsTrustedCertificates")
    def tls_trusted_certificates(self) -> Optional[Sequence['outputs.KafkaSpecKafkaListenersOneOf1PlainAuthenticationTlsTrustedCertificates']]:
        """
        Trusted certificates for TLS connection to the OAuth server.
        """
        return pulumi.get(self, "tls_trusted_certificates")

    @property
    @pulumi.getter(name="userInfoEndpointUri")
    def user_info_endpoint_uri(self) -> Optional[str]:
        """
        URI of the User Info Endpoint to use as a fallback to obtaining the user id when the Introspection Endpoint does not return information that can be used for the user id. 
        """
        return pulumi.get(self, "user_info_endpoint_uri")

    @property
    @pulumi.getter(name="userNameClaim")
    def user_name_claim(self) -> Optional[str]:
        """
        Name of the claim from the JWT authentication token, Introspection Endpoint response or User Info Endpoint response which will be used to extract the user id. Defaults to `sub`.
        """
        return pulumi.get(self, "user_name_claim")

    @property
    @pulumi.getter(name="validIssuerUri")
    def valid_issuer_uri(self) -> Optional[str]:
        """
        URI of the token issuer used for authentication.
        """
        return pulumi.get(self, "valid_issuer_uri")

    @property
    @pulumi.getter(name="validTokenType")
    def valid_token_type(self) -> Optional[str]:
        """
        Valid value for the `token_type` attribute returned by the Introspection Endpoint. No default value, and not checked by default.
        """
        return pulumi.get(self, "valid_token_type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf1PlainAuthenticationClientSecret(dict):
    """
    Link to Kubernetes Secret containing the OAuth client secret which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
    """
    def __init__(__self__, *,
                 key: str,
                 secret_name: str):
        """
        Link to Kubernetes Secret containing the OAuth client secret which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
        :param str key: The key under which the secret value is stored in the Kubernetes Secret.
        :param str secret_name: The name of the Kubernetes Secret containing the secret value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key under which the secret value is stored in the Kubernetes Secret.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Kubernetes Secret containing the secret value.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf1PlainAuthenticationTlsTrustedCertificates(dict):
    def __init__(__self__, *,
                 certificate: str,
                 secret_name: str):
        """
        :param str certificate: The name of the file certificate in the Secret.
        :param str secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> str:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeers(dict):
    def __init__(__self__, *,
                 ip_block: Optional['outputs.KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersIpBlock'] = None,
                 namespace_selector: Optional['outputs.KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersNamespaceSelector'] = None,
                 pod_selector: Optional['outputs.KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersPodSelector'] = None):
        if ip_block is not None:
            pulumi.set(__self__, "ip_block", ip_block)
        if namespace_selector is not None:
            pulumi.set(__self__, "namespace_selector", namespace_selector)
        if pod_selector is not None:
            pulumi.set(__self__, "pod_selector", pod_selector)

    @property
    @pulumi.getter(name="ipBlock")
    def ip_block(self) -> Optional['outputs.KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersIpBlock']:
        return pulumi.get(self, "ip_block")

    @property
    @pulumi.getter(name="namespaceSelector")
    def namespace_selector(self) -> Optional['outputs.KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersNamespaceSelector']:
        return pulumi.get(self, "namespace_selector")

    @property
    @pulumi.getter(name="podSelector")
    def pod_selector(self) -> Optional['outputs.KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersPodSelector']:
        return pulumi.get(self, "pod_selector")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersIpBlock(dict):
    def __init__(__self__, *,
                 cidr: Optional[str] = None,
                 except_: Optional[Sequence[str]] = None):
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if except_ is not None:
            pulumi.set(__self__, "except_", except_)

    @property
    @pulumi.getter
    def cidr(self) -> Optional[str]:
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter(name="except")
    def except_(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "except_")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersNamespaceSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersNamespaceSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersNamespaceSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersNamespaceSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersPodSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersPodSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersPodSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf1PlainNetworkPolicyPeersPodSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf1Tls(dict):
    """
    Configures TLS listener on port 9093.
    """
    def __init__(__self__, *,
                 authentication: Optional['outputs.KafkaSpecKafkaListenersOneOf1TlsAuthentication'] = None,
                 configuration: Optional['outputs.KafkaSpecKafkaListenersOneOf1TlsConfiguration'] = None,
                 network_policy_peers: Optional[Sequence['outputs.KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeers']] = None):
        """
        Configures TLS listener on port 9093.
        :param 'KafkaSpecKafkaListenersOneOf1TlsAuthenticationArgs' authentication: Authentication configuration for this listener.
        :param 'KafkaSpecKafkaListenersOneOf1TlsConfigurationArgs' configuration: Configuration of TLS listener.
        :param Sequence['KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersArgs'] network_policy_peers: List of peers which should be able to connect to this listener. Peers in this list are combined using a logical OR operation. If this field is empty or missing, all connections will be allowed for this listener. If this field is present and contains at least one item, the listener only allows the traffic which matches at least one item in this list.
        """
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if network_policy_peers is not None:
            pulumi.set(__self__, "network_policy_peers", network_policy_peers)

    @property
    @pulumi.getter
    def authentication(self) -> Optional['outputs.KafkaSpecKafkaListenersOneOf1TlsAuthentication']:
        """
        Authentication configuration for this listener.
        """
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.KafkaSpecKafkaListenersOneOf1TlsConfiguration']:
        """
        Configuration of TLS listener.
        """
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter(name="networkPolicyPeers")
    def network_policy_peers(self) -> Optional[Sequence['outputs.KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeers']]:
        """
        List of peers which should be able to connect to this listener. Peers in this list are combined using a logical OR operation. If this field is empty or missing, all connections will be allowed for this listener. If this field is present and contains at least one item, the listener only allows the traffic which matches at least one item in this list.
        """
        return pulumi.get(self, "network_policy_peers")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf1TlsAuthentication(dict):
    """
    Authentication configuration for this listener.
    """
    def __init__(__self__, *,
                 type: str,
                 access_token_is_jwt: Optional[bool] = None,
                 check_access_token_type: Optional[bool] = None,
                 check_issuer: Optional[bool] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional['outputs.KafkaSpecKafkaListenersOneOf1TlsAuthenticationClientSecret'] = None,
                 disable_tls_hostname_verification: Optional[bool] = None,
                 enable_ecdsa: Optional[bool] = None,
                 fallback_user_name_claim: Optional[str] = None,
                 fallback_user_name_prefix: Optional[str] = None,
                 introspection_endpoint_uri: Optional[str] = None,
                 jwks_endpoint_uri: Optional[str] = None,
                 jwks_expiry_seconds: Optional[int] = None,
                 jwks_min_refresh_pause_seconds: Optional[int] = None,
                 jwks_refresh_seconds: Optional[int] = None,
                 max_seconds_without_reauthentication: Optional[int] = None,
                 tls_trusted_certificates: Optional[Sequence['outputs.KafkaSpecKafkaListenersOneOf1TlsAuthenticationTlsTrustedCertificates']] = None,
                 user_info_endpoint_uri: Optional[str] = None,
                 user_name_claim: Optional[str] = None,
                 valid_issuer_uri: Optional[str] = None,
                 valid_token_type: Optional[str] = None):
        """
        Authentication configuration for this listener.
        :param str type: Authentication type. `oauth` type uses SASL OAUTHBEARER Authentication. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `tls` type uses TLS Client Authentication. `tls` type is supported only on TLS listeners.
        :param bool access_token_is_jwt: Configure whether the access token is treated as JWT. This must be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
        :param bool check_access_token_type: Configure whether the access token type check is performed or not. This should be set to `false` if the authorization server does not include 'typ' claim in JWT token. Defaults to `true`.
        :param bool check_issuer: Enable or disable issuer checking. By default issuer is checked using the value configured by `validIssuerUri`. Default value is `true`.
        :param str client_id: OAuth Client ID which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
        :param 'KafkaSpecKafkaListenersOneOf1TlsAuthenticationClientSecretArgs' client_secret: Link to Kubernetes Secret containing the OAuth client secret which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
        :param bool disable_tls_hostname_verification: Enable or disable TLS hostname verification. Default value is `false`.
        :param bool enable_ecdsa: Enable or disable ECDSA support by installing BouncyCastle crypto provider. Default value is `false`.
        :param str fallback_user_name_claim: The fallback username claim to be used for the user id if the claim specified by `userNameClaim` is not present. This is useful when `client_credentials` authentication only results in the client id being provided in another claim. It only takes effect if `userNameClaim` is set.
        :param str fallback_user_name_prefix: The prefix to use with the value of `fallbackUserNameClaim` to construct the user id. This only takes effect if `fallbackUserNameClaim` is true, and the value is present for the claim. Mapping usernames and client ids into the same user id space is useful in preventing name collisions.
        :param str introspection_endpoint_uri: URI of the token introspection endpoint which can be used to validate opaque non-JWT tokens.
        :param str jwks_endpoint_uri: URI of the JWKS certificate endpoint, which can be used for local JWT validation.
        :param int jwks_expiry_seconds: Configures how often are the JWKS certificates considered valid. The expiry interval has to be at least 60 seconds longer then the refresh interval specified in `jwksRefreshSeconds`. Defaults to 360 seconds.
        :param int jwks_min_refresh_pause_seconds: The minimum pause between two consecutive refreshes. When an unknown signing key is encountered the refresh is scheduled immediately, but will always wait for this minimum pause. Defaults to 1 second.
        :param int jwks_refresh_seconds: Configures how often are the JWKS certificates refreshed. The refresh interval has to be at least 60 seconds shorter then the expiry interval specified in `jwksExpirySeconds`. Defaults to 300 seconds.
        :param int max_seconds_without_reauthentication: Maximum number of seconds the authenticated session remains valid without re-authentication. This enables Apache Kafka re-authentication feature, and causes sessions to expire when the access token expires. If the access token expires before max time or if max time is reached, the client has to re-authenticate, otherwise the server will drop the connection. Not set by default - the authenticated session does not expire when the access token expires.
        :param Sequence['KafkaSpecKafkaListenersOneOf1TlsAuthenticationTlsTrustedCertificatesArgs'] tls_trusted_certificates: Trusted certificates for TLS connection to the OAuth server.
        :param str user_info_endpoint_uri: URI of the User Info Endpoint to use as a fallback to obtaining the user id when the Introspection Endpoint does not return information that can be used for the user id. 
        :param str user_name_claim: Name of the claim from the JWT authentication token, Introspection Endpoint response or User Info Endpoint response which will be used to extract the user id. Defaults to `sub`.
        :param str valid_issuer_uri: URI of the token issuer used for authentication.
        :param str valid_token_type: Valid value for the `token_type` attribute returned by the Introspection Endpoint. No default value, and not checked by default.
        """
        pulumi.set(__self__, "type", type)
        if access_token_is_jwt is not None:
            pulumi.set(__self__, "access_token_is_jwt", access_token_is_jwt)
        if check_access_token_type is not None:
            pulumi.set(__self__, "check_access_token_type", check_access_token_type)
        if check_issuer is not None:
            pulumi.set(__self__, "check_issuer", check_issuer)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if disable_tls_hostname_verification is not None:
            pulumi.set(__self__, "disable_tls_hostname_verification", disable_tls_hostname_verification)
        if enable_ecdsa is not None:
            pulumi.set(__self__, "enable_ecdsa", enable_ecdsa)
        if fallback_user_name_claim is not None:
            pulumi.set(__self__, "fallback_user_name_claim", fallback_user_name_claim)
        if fallback_user_name_prefix is not None:
            pulumi.set(__self__, "fallback_user_name_prefix", fallback_user_name_prefix)
        if introspection_endpoint_uri is not None:
            pulumi.set(__self__, "introspection_endpoint_uri", introspection_endpoint_uri)
        if jwks_endpoint_uri is not None:
            pulumi.set(__self__, "jwks_endpoint_uri", jwks_endpoint_uri)
        if jwks_expiry_seconds is not None:
            pulumi.set(__self__, "jwks_expiry_seconds", jwks_expiry_seconds)
        if jwks_min_refresh_pause_seconds is not None:
            pulumi.set(__self__, "jwks_min_refresh_pause_seconds", jwks_min_refresh_pause_seconds)
        if jwks_refresh_seconds is not None:
            pulumi.set(__self__, "jwks_refresh_seconds", jwks_refresh_seconds)
        if max_seconds_without_reauthentication is not None:
            pulumi.set(__self__, "max_seconds_without_reauthentication", max_seconds_without_reauthentication)
        if tls_trusted_certificates is not None:
            pulumi.set(__self__, "tls_trusted_certificates", tls_trusted_certificates)
        if user_info_endpoint_uri is not None:
            pulumi.set(__self__, "user_info_endpoint_uri", user_info_endpoint_uri)
        if user_name_claim is not None:
            pulumi.set(__self__, "user_name_claim", user_name_claim)
        if valid_issuer_uri is not None:
            pulumi.set(__self__, "valid_issuer_uri", valid_issuer_uri)
        if valid_token_type is not None:
            pulumi.set(__self__, "valid_token_type", valid_token_type)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Authentication type. `oauth` type uses SASL OAUTHBEARER Authentication. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `tls` type uses TLS Client Authentication. `tls` type is supported only on TLS listeners.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessTokenIsJwt")
    def access_token_is_jwt(self) -> Optional[bool]:
        """
        Configure whether the access token is treated as JWT. This must be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
        """
        return pulumi.get(self, "access_token_is_jwt")

    @property
    @pulumi.getter(name="checkAccessTokenType")
    def check_access_token_type(self) -> Optional[bool]:
        """
        Configure whether the access token type check is performed or not. This should be set to `false` if the authorization server does not include 'typ' claim in JWT token. Defaults to `true`.
        """
        return pulumi.get(self, "check_access_token_type")

    @property
    @pulumi.getter(name="checkIssuer")
    def check_issuer(self) -> Optional[bool]:
        """
        Enable or disable issuer checking. By default issuer is checked using the value configured by `validIssuerUri`. Default value is `true`.
        """
        return pulumi.get(self, "check_issuer")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        OAuth Client ID which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional['outputs.KafkaSpecKafkaListenersOneOf1TlsAuthenticationClientSecret']:
        """
        Link to Kubernetes Secret containing the OAuth client secret which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="disableTlsHostnameVerification")
    def disable_tls_hostname_verification(self) -> Optional[bool]:
        """
        Enable or disable TLS hostname verification. Default value is `false`.
        """
        return pulumi.get(self, "disable_tls_hostname_verification")

    @property
    @pulumi.getter(name="enableECDSA")
    def enable_ecdsa(self) -> Optional[bool]:
        """
        Enable or disable ECDSA support by installing BouncyCastle crypto provider. Default value is `false`.
        """
        return pulumi.get(self, "enable_ecdsa")

    @property
    @pulumi.getter(name="fallbackUserNameClaim")
    def fallback_user_name_claim(self) -> Optional[str]:
        """
        The fallback username claim to be used for the user id if the claim specified by `userNameClaim` is not present. This is useful when `client_credentials` authentication only results in the client id being provided in another claim. It only takes effect if `userNameClaim` is set.
        """
        return pulumi.get(self, "fallback_user_name_claim")

    @property
    @pulumi.getter(name="fallbackUserNamePrefix")
    def fallback_user_name_prefix(self) -> Optional[str]:
        """
        The prefix to use with the value of `fallbackUserNameClaim` to construct the user id. This only takes effect if `fallbackUserNameClaim` is true, and the value is present for the claim. Mapping usernames and client ids into the same user id space is useful in preventing name collisions.
        """
        return pulumi.get(self, "fallback_user_name_prefix")

    @property
    @pulumi.getter(name="introspectionEndpointUri")
    def introspection_endpoint_uri(self) -> Optional[str]:
        """
        URI of the token introspection endpoint which can be used to validate opaque non-JWT tokens.
        """
        return pulumi.get(self, "introspection_endpoint_uri")

    @property
    @pulumi.getter(name="jwksEndpointUri")
    def jwks_endpoint_uri(self) -> Optional[str]:
        """
        URI of the JWKS certificate endpoint, which can be used for local JWT validation.
        """
        return pulumi.get(self, "jwks_endpoint_uri")

    @property
    @pulumi.getter(name="jwksExpirySeconds")
    def jwks_expiry_seconds(self) -> Optional[int]:
        """
        Configures how often are the JWKS certificates considered valid. The expiry interval has to be at least 60 seconds longer then the refresh interval specified in `jwksRefreshSeconds`. Defaults to 360 seconds.
        """
        return pulumi.get(self, "jwks_expiry_seconds")

    @property
    @pulumi.getter(name="jwksMinRefreshPauseSeconds")
    def jwks_min_refresh_pause_seconds(self) -> Optional[int]:
        """
        The minimum pause between two consecutive refreshes. When an unknown signing key is encountered the refresh is scheduled immediately, but will always wait for this minimum pause. Defaults to 1 second.
        """
        return pulumi.get(self, "jwks_min_refresh_pause_seconds")

    @property
    @pulumi.getter(name="jwksRefreshSeconds")
    def jwks_refresh_seconds(self) -> Optional[int]:
        """
        Configures how often are the JWKS certificates refreshed. The refresh interval has to be at least 60 seconds shorter then the expiry interval specified in `jwksExpirySeconds`. Defaults to 300 seconds.
        """
        return pulumi.get(self, "jwks_refresh_seconds")

    @property
    @pulumi.getter(name="maxSecondsWithoutReauthentication")
    def max_seconds_without_reauthentication(self) -> Optional[int]:
        """
        Maximum number of seconds the authenticated session remains valid without re-authentication. This enables Apache Kafka re-authentication feature, and causes sessions to expire when the access token expires. If the access token expires before max time or if max time is reached, the client has to re-authenticate, otherwise the server will drop the connection. Not set by default - the authenticated session does not expire when the access token expires.
        """
        return pulumi.get(self, "max_seconds_without_reauthentication")

    @property
    @pulumi.getter(name="tlsTrustedCertificates")
    def tls_trusted_certificates(self) -> Optional[Sequence['outputs.KafkaSpecKafkaListenersOneOf1TlsAuthenticationTlsTrustedCertificates']]:
        """
        Trusted certificates for TLS connection to the OAuth server.
        """
        return pulumi.get(self, "tls_trusted_certificates")

    @property
    @pulumi.getter(name="userInfoEndpointUri")
    def user_info_endpoint_uri(self) -> Optional[str]:
        """
        URI of the User Info Endpoint to use as a fallback to obtaining the user id when the Introspection Endpoint does not return information that can be used for the user id. 
        """
        return pulumi.get(self, "user_info_endpoint_uri")

    @property
    @pulumi.getter(name="userNameClaim")
    def user_name_claim(self) -> Optional[str]:
        """
        Name of the claim from the JWT authentication token, Introspection Endpoint response or User Info Endpoint response which will be used to extract the user id. Defaults to `sub`.
        """
        return pulumi.get(self, "user_name_claim")

    @property
    @pulumi.getter(name="validIssuerUri")
    def valid_issuer_uri(self) -> Optional[str]:
        """
        URI of the token issuer used for authentication.
        """
        return pulumi.get(self, "valid_issuer_uri")

    @property
    @pulumi.getter(name="validTokenType")
    def valid_token_type(self) -> Optional[str]:
        """
        Valid value for the `token_type` attribute returned by the Introspection Endpoint. No default value, and not checked by default.
        """
        return pulumi.get(self, "valid_token_type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf1TlsAuthenticationClientSecret(dict):
    """
    Link to Kubernetes Secret containing the OAuth client secret which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
    """
    def __init__(__self__, *,
                 key: str,
                 secret_name: str):
        """
        Link to Kubernetes Secret containing the OAuth client secret which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
        :param str key: The key under which the secret value is stored in the Kubernetes Secret.
        :param str secret_name: The name of the Kubernetes Secret containing the secret value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key under which the secret value is stored in the Kubernetes Secret.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Kubernetes Secret containing the secret value.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf1TlsAuthenticationTlsTrustedCertificates(dict):
    def __init__(__self__, *,
                 certificate: str,
                 secret_name: str):
        """
        :param str certificate: The name of the file certificate in the Secret.
        :param str secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> str:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf1TlsConfiguration(dict):
    """
    Configuration of TLS listener.
    """
    def __init__(__self__, *,
                 broker_cert_chain_and_key: Optional['outputs.KafkaSpecKafkaListenersOneOf1TlsConfigurationBrokerCertChainAndKey'] = None):
        """
        Configuration of TLS listener.
        :param 'KafkaSpecKafkaListenersOneOf1TlsConfigurationBrokerCertChainAndKeyArgs' broker_cert_chain_and_key: Reference to the `Secret` which holds the certificate and private key pair. The certificate can optionally contain the whole chain.
        """
        if broker_cert_chain_and_key is not None:
            pulumi.set(__self__, "broker_cert_chain_and_key", broker_cert_chain_and_key)

    @property
    @pulumi.getter(name="brokerCertChainAndKey")
    def broker_cert_chain_and_key(self) -> Optional['outputs.KafkaSpecKafkaListenersOneOf1TlsConfigurationBrokerCertChainAndKey']:
        """
        Reference to the `Secret` which holds the certificate and private key pair. The certificate can optionally contain the whole chain.
        """
        return pulumi.get(self, "broker_cert_chain_and_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf1TlsConfigurationBrokerCertChainAndKey(dict):
    """
    Reference to the `Secret` which holds the certificate and private key pair. The certificate can optionally contain the whole chain.
    """
    def __init__(__self__, *,
                 certificate: str,
                 key: str,
                 secret_name: str):
        """
        Reference to the `Secret` which holds the certificate and private key pair. The certificate can optionally contain the whole chain.
        :param str certificate: The name of the file certificate in the Secret.
        :param str key: The name of the private key in the Secret.
        :param str secret_name: The name of the Secret containing the certificate.
        """
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter
    def certificate(self) -> str:
        """
        The name of the file certificate in the Secret.
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The name of the private key in the Secret.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of the Secret containing the certificate.
        """
        return pulumi.get(self, "secret_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeers(dict):
    def __init__(__self__, *,
                 ip_block: Optional['outputs.KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersIpBlock'] = None,
                 namespace_selector: Optional['outputs.KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersNamespaceSelector'] = None,
                 pod_selector: Optional['outputs.KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersPodSelector'] = None):
        if ip_block is not None:
            pulumi.set(__self__, "ip_block", ip_block)
        if namespace_selector is not None:
            pulumi.set(__self__, "namespace_selector", namespace_selector)
        if pod_selector is not None:
            pulumi.set(__self__, "pod_selector", pod_selector)

    @property
    @pulumi.getter(name="ipBlock")
    def ip_block(self) -> Optional['outputs.KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersIpBlock']:
        return pulumi.get(self, "ip_block")

    @property
    @pulumi.getter(name="namespaceSelector")
    def namespace_selector(self) -> Optional['outputs.KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersNamespaceSelector']:
        return pulumi.get(self, "namespace_selector")

    @property
    @pulumi.getter(name="podSelector")
    def pod_selector(self) -> Optional['outputs.KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersPodSelector']:
        return pulumi.get(self, "pod_selector")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersIpBlock(dict):
    def __init__(__self__, *,
                 cidr: Optional[str] = None,
                 except_: Optional[Sequence[str]] = None):
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if except_ is not None:
            pulumi.set(__self__, "except_", except_)

    @property
    @pulumi.getter
    def cidr(self) -> Optional[str]:
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter(name="except")
    def except_(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "except_")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersNamespaceSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersNamespaceSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersNamespaceSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersNamespaceSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersPodSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersPodSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersPodSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaListenersOneOf1TlsNetworkPolicyPeersPodSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaLivenessProbe(dict):
    """
    Pod liveness checking.
    """
    def __init__(__self__, *,
                 failure_threshold: Optional[int] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 timeout_seconds: Optional[int] = None):
        """
        Pod liveness checking.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param int initial_delay_seconds: The initial delay before first the health is first checked.
        :param int period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param int timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaLogging(dict):
    """
    Logging configuration for Kafka.
    """
    def __init__(__self__, *,
                 type: str,
                 loggers: Optional[Mapping[str, Any]] = None,
                 name: Optional[str] = None):
        """
        Logging configuration for Kafka.
        :param str type: Logging type, must be either 'inline' or 'external'.
        :param Mapping[str, Any] loggers: A Map from logger name to logger level.
        :param str name: The name of the `ConfigMap` from which to get the logging configuration.
        """
        pulumi.set(__self__, "type", type)
        if loggers is not None:
            pulumi.set(__self__, "loggers", loggers)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Logging type, must be either 'inline' or 'external'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def loggers(self) -> Optional[Mapping[str, Any]]:
        """
        A Map from logger name to logger level.
        """
        return pulumi.get(self, "loggers")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the `ConfigMap` from which to get the logging configuration.
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaRack(dict):
    """
    Configuration of the `broker.rack` broker config.
    """
    def __init__(__self__, *,
                 topology_key: str):
        """
        Configuration of the `broker.rack` broker config.
        :param str topology_key: A key that matches labels assigned to the Kubernetes cluster nodes. The value of the label is used to set the broker's `broker.rack` config.
        """
        pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> str:
        """
        A key that matches labels assigned to the Kubernetes cluster nodes. The value of the label is used to set the broker's `broker.rack` config.
        """
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaReadinessProbe(dict):
    """
    Pod readiness checking.
    """
    def __init__(__self__, *,
                 failure_threshold: Optional[int] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 timeout_seconds: Optional[int] = None):
        """
        Pod readiness checking.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param int initial_delay_seconds: The initial delay before first the health is first checked.
        :param int period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param int timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaResources(dict):
    """
    CPU and memory resources to reserve.
    """
    def __init__(__self__, *,
                 limits: Optional[Mapping[str, Any]] = None,
                 requests: Optional[Mapping[str, Any]] = None):
        """
        CPU and memory resources to reserve.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "requests")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaStorage(dict):
    """
    Storage configuration (disk). Cannot be updated.
    """
    def __init__(__self__, *,
                 type: str,
                 class_: Optional[str] = None,
                 delete_claim: Optional[bool] = None,
                 id: Optional[int] = None,
                 overrides: Optional[Sequence['outputs.KafkaSpecKafkaStorageOverrides']] = None,
                 selector: Optional[Mapping[str, Any]] = None,
                 size: Optional[str] = None,
                 size_limit: Optional[str] = None,
                 volumes: Optional[Sequence['outputs.KafkaSpecKafkaStorageVolumes']] = None):
        """
        Storage configuration (disk). Cannot be updated.
        :param str type: Storage type, must be either 'ephemeral', 'persistent-claim', or 'jbod'.
        :param str class_: The storage class to use for dynamic volume allocation.
        :param bool delete_claim: Specifies if the persistent volume claim has to be deleted when the cluster is un-deployed.
        :param int id: Storage identification number. It is mandatory only for storage volumes defined in a storage of type 'jbod'.
        :param Sequence['KafkaSpecKafkaStorageOverridesArgs'] overrides: Overrides for individual brokers. The `overrides` field allows to specify a different configuration for different brokers.
        :param Mapping[str, Any] selector: Specifies a specific persistent volume to use. It contains key:value pairs representing labels for selecting such a volume.
        :param str size: When type=persistent-claim, defines the size of the persistent volume claim (i.e 1Gi). Mandatory when type=persistent-claim.
        :param str size_limit: When type=ephemeral, defines the total amount of local storage required for this EmptyDir volume (for example 1Gi).
        :param Sequence['KafkaSpecKafkaStorageVolumesArgs'] volumes: List of volumes as Storage objects representing the JBOD disks array.
        """
        pulumi.set(__self__, "type", type)
        if class_ is not None:
            pulumi.set(__self__, "class_", class_)
        if delete_claim is not None:
            pulumi.set(__self__, "delete_claim", delete_claim)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if size_limit is not None:
            pulumi.set(__self__, "size_limit", size_limit)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Storage type, must be either 'ephemeral', 'persistent-claim', or 'jbod'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="class")
    def class_(self) -> Optional[str]:
        """
        The storage class to use for dynamic volume allocation.
        """
        return pulumi.get(self, "class_")

    @property
    @pulumi.getter(name="deleteClaim")
    def delete_claim(self) -> Optional[bool]:
        """
        Specifies if the persistent volume claim has to be deleted when the cluster is un-deployed.
        """
        return pulumi.get(self, "delete_claim")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Storage identification number. It is mandatory only for storage volumes defined in a storage of type 'jbod'.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def overrides(self) -> Optional[Sequence['outputs.KafkaSpecKafkaStorageOverrides']]:
        """
        Overrides for individual brokers. The `overrides` field allows to specify a different configuration for different brokers.
        """
        return pulumi.get(self, "overrides")

    @property
    @pulumi.getter
    def selector(self) -> Optional[Mapping[str, Any]]:
        """
        Specifies a specific persistent volume to use. It contains key:value pairs representing labels for selecting such a volume.
        """
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter
    def size(self) -> Optional[str]:
        """
        When type=persistent-claim, defines the size of the persistent volume claim (i.e 1Gi). Mandatory when type=persistent-claim.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="sizeLimit")
    def size_limit(self) -> Optional[str]:
        """
        When type=ephemeral, defines the total amount of local storage required for this EmptyDir volume (for example 1Gi).
        """
        return pulumi.get(self, "size_limit")

    @property
    @pulumi.getter
    def volumes(self) -> Optional[Sequence['outputs.KafkaSpecKafkaStorageVolumes']]:
        """
        List of volumes as Storage objects representing the JBOD disks array.
        """
        return pulumi.get(self, "volumes")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaStorageOverrides(dict):
    def __init__(__self__, *,
                 broker: Optional[int] = None,
                 class_: Optional[str] = None):
        """
        :param int broker: Id of the kafka broker (broker identifier).
        :param str class_: The storage class to use for dynamic volume allocation for this broker.
        """
        if broker is not None:
            pulumi.set(__self__, "broker", broker)
        if class_ is not None:
            pulumi.set(__self__, "class_", class_)

    @property
    @pulumi.getter
    def broker(self) -> Optional[int]:
        """
        Id of the kafka broker (broker identifier).
        """
        return pulumi.get(self, "broker")

    @property
    @pulumi.getter(name="class")
    def class_(self) -> Optional[str]:
        """
        The storage class to use for dynamic volume allocation for this broker.
        """
        return pulumi.get(self, "class_")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaStorageVolumes(dict):
    def __init__(__self__, *,
                 type: str,
                 class_: Optional[str] = None,
                 delete_claim: Optional[bool] = None,
                 id: Optional[int] = None,
                 overrides: Optional[Sequence['outputs.KafkaSpecKafkaStorageVolumesOverrides']] = None,
                 selector: Optional[Mapping[str, Any]] = None,
                 size: Optional[str] = None,
                 size_limit: Optional[str] = None):
        """
        :param str type: Storage type, must be either 'ephemeral' or 'persistent-claim'.
        :param str class_: The storage class to use for dynamic volume allocation.
        :param bool delete_claim: Specifies if the persistent volume claim has to be deleted when the cluster is un-deployed.
        :param int id: Storage identification number. It is mandatory only for storage volumes defined in a storage of type 'jbod'.
        :param Sequence['KafkaSpecKafkaStorageVolumesOverridesArgs'] overrides: Overrides for individual brokers. The `overrides` field allows to specify a different configuration for different brokers.
        :param Mapping[str, Any] selector: Specifies a specific persistent volume to use. It contains key:value pairs representing labels for selecting such a volume.
        :param str size: When type=persistent-claim, defines the size of the persistent volume claim (i.e 1Gi). Mandatory when type=persistent-claim.
        :param str size_limit: When type=ephemeral, defines the total amount of local storage required for this EmptyDir volume (for example 1Gi).
        """
        pulumi.set(__self__, "type", type)
        if class_ is not None:
            pulumi.set(__self__, "class_", class_)
        if delete_claim is not None:
            pulumi.set(__self__, "delete_claim", delete_claim)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if size_limit is not None:
            pulumi.set(__self__, "size_limit", size_limit)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Storage type, must be either 'ephemeral' or 'persistent-claim'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="class")
    def class_(self) -> Optional[str]:
        """
        The storage class to use for dynamic volume allocation.
        """
        return pulumi.get(self, "class_")

    @property
    @pulumi.getter(name="deleteClaim")
    def delete_claim(self) -> Optional[bool]:
        """
        Specifies if the persistent volume claim has to be deleted when the cluster is un-deployed.
        """
        return pulumi.get(self, "delete_claim")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Storage identification number. It is mandatory only for storage volumes defined in a storage of type 'jbod'.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def overrides(self) -> Optional[Sequence['outputs.KafkaSpecKafkaStorageVolumesOverrides']]:
        """
        Overrides for individual brokers. The `overrides` field allows to specify a different configuration for different brokers.
        """
        return pulumi.get(self, "overrides")

    @property
    @pulumi.getter
    def selector(self) -> Optional[Mapping[str, Any]]:
        """
        Specifies a specific persistent volume to use. It contains key:value pairs representing labels for selecting such a volume.
        """
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter
    def size(self) -> Optional[str]:
        """
        When type=persistent-claim, defines the size of the persistent volume claim (i.e 1Gi). Mandatory when type=persistent-claim.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="sizeLimit")
    def size_limit(self) -> Optional[str]:
        """
        When type=ephemeral, defines the total amount of local storage required for this EmptyDir volume (for example 1Gi).
        """
        return pulumi.get(self, "size_limit")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaStorageVolumesOverrides(dict):
    def __init__(__self__, *,
                 broker: Optional[int] = None,
                 class_: Optional[str] = None):
        """
        :param int broker: Id of the kafka broker (broker identifier).
        :param str class_: The storage class to use for dynamic volume allocation for this broker.
        """
        if broker is not None:
            pulumi.set(__self__, "broker", broker)
        if class_ is not None:
            pulumi.set(__self__, "class_", class_)

    @property
    @pulumi.getter
    def broker(self) -> Optional[int]:
        """
        Id of the kafka broker (broker identifier).
        """
        return pulumi.get(self, "broker")

    @property
    @pulumi.getter(name="class")
    def class_(self) -> Optional[str]:
        """
        The storage class to use for dynamic volume allocation for this broker.
        """
        return pulumi.get(self, "class_")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplate(dict):
    """
    Template for Kafka cluster resources. The template allows users to specify how are the `StatefulSet`, `Pods` and `Services` generated.
    """
    def __init__(__self__, *,
                 bootstrap_service: Optional['outputs.KafkaSpecKafkaTemplateBootstrapService'] = None,
                 brokers_service: Optional['outputs.KafkaSpecKafkaTemplateBrokersService'] = None,
                 external_bootstrap_ingress: Optional['outputs.KafkaSpecKafkaTemplateExternalBootstrapIngress'] = None,
                 external_bootstrap_route: Optional['outputs.KafkaSpecKafkaTemplateExternalBootstrapRoute'] = None,
                 external_bootstrap_service: Optional['outputs.KafkaSpecKafkaTemplateExternalBootstrapService'] = None,
                 init_container: Optional['outputs.KafkaSpecKafkaTemplateInitContainer'] = None,
                 kafka_container: Optional['outputs.KafkaSpecKafkaTemplateKafkaContainer'] = None,
                 per_pod_ingress: Optional['outputs.KafkaSpecKafkaTemplatePerPodIngress'] = None,
                 per_pod_route: Optional['outputs.KafkaSpecKafkaTemplatePerPodRoute'] = None,
                 per_pod_service: Optional['outputs.KafkaSpecKafkaTemplatePerPodService'] = None,
                 persistent_volume_claim: Optional['outputs.KafkaSpecKafkaTemplatePersistentVolumeClaim'] = None,
                 pod: Optional['outputs.KafkaSpecKafkaTemplatePod'] = None,
                 pod_disruption_budget: Optional['outputs.KafkaSpecKafkaTemplatePodDisruptionBudget'] = None,
                 statefulset: Optional['outputs.KafkaSpecKafkaTemplateStatefulset'] = None,
                 tls_sidecar_container: Optional['outputs.KafkaSpecKafkaTemplateTlsSidecarContainer'] = None):
        """
        Template for Kafka cluster resources. The template allows users to specify how are the `StatefulSet`, `Pods` and `Services` generated.
        :param 'KafkaSpecKafkaTemplateBootstrapServiceArgs' bootstrap_service: Template for Kafka bootstrap `Service`.
        :param 'KafkaSpecKafkaTemplateBrokersServiceArgs' brokers_service: Template for Kafka broker `Service`.
        :param 'KafkaSpecKafkaTemplateExternalBootstrapIngressArgs' external_bootstrap_ingress: Template for Kafka external bootstrap `Ingress`.
        :param 'KafkaSpecKafkaTemplateExternalBootstrapRouteArgs' external_bootstrap_route: Template for Kafka external bootstrap `Route`.
        :param 'KafkaSpecKafkaTemplateExternalBootstrapServiceArgs' external_bootstrap_service: Template for Kafka external bootstrap `Service`.
        :param 'KafkaSpecKafkaTemplateInitContainerArgs' init_container: Template for the Kafka init container.
        :param 'KafkaSpecKafkaTemplateKafkaContainerArgs' kafka_container: Template for the Kafka broker container.
        :param 'KafkaSpecKafkaTemplatePerPodIngressArgs' per_pod_ingress: Template for Kafka per-pod `Ingress` used for access from outside of Kubernetes.
        :param 'KafkaSpecKafkaTemplatePerPodRouteArgs' per_pod_route: Template for Kafka per-pod `Routes` used for access from outside of OpenShift.
        :param 'KafkaSpecKafkaTemplatePerPodServiceArgs' per_pod_service: Template for Kafka per-pod `Services` used for access from outside of Kubernetes.
        :param 'KafkaSpecKafkaTemplatePersistentVolumeClaimArgs' persistent_volume_claim: Template for all Kafka `PersistentVolumeClaims`.
        :param 'KafkaSpecKafkaTemplatePodArgs' pod: Template for Kafka `Pods`.
        :param 'KafkaSpecKafkaTemplatePodDisruptionBudgetArgs' pod_disruption_budget: Template for Kafka `PodDisruptionBudget`.
        :param 'KafkaSpecKafkaTemplateStatefulsetArgs' statefulset: Template for Kafka `StatefulSet`.
        :param 'KafkaSpecKafkaTemplateTlsSidecarContainerArgs' tls_sidecar_container: Template for the Kafka broker TLS sidecar container.
        """
        if bootstrap_service is not None:
            pulumi.set(__self__, "bootstrap_service", bootstrap_service)
        if brokers_service is not None:
            pulumi.set(__self__, "brokers_service", brokers_service)
        if external_bootstrap_ingress is not None:
            pulumi.set(__self__, "external_bootstrap_ingress", external_bootstrap_ingress)
        if external_bootstrap_route is not None:
            pulumi.set(__self__, "external_bootstrap_route", external_bootstrap_route)
        if external_bootstrap_service is not None:
            pulumi.set(__self__, "external_bootstrap_service", external_bootstrap_service)
        if init_container is not None:
            pulumi.set(__self__, "init_container", init_container)
        if kafka_container is not None:
            pulumi.set(__self__, "kafka_container", kafka_container)
        if per_pod_ingress is not None:
            pulumi.set(__self__, "per_pod_ingress", per_pod_ingress)
        if per_pod_route is not None:
            pulumi.set(__self__, "per_pod_route", per_pod_route)
        if per_pod_service is not None:
            pulumi.set(__self__, "per_pod_service", per_pod_service)
        if persistent_volume_claim is not None:
            pulumi.set(__self__, "persistent_volume_claim", persistent_volume_claim)
        if pod is not None:
            pulumi.set(__self__, "pod", pod)
        if pod_disruption_budget is not None:
            pulumi.set(__self__, "pod_disruption_budget", pod_disruption_budget)
        if statefulset is not None:
            pulumi.set(__self__, "statefulset", statefulset)
        if tls_sidecar_container is not None:
            pulumi.set(__self__, "tls_sidecar_container", tls_sidecar_container)

    @property
    @pulumi.getter(name="bootstrapService")
    def bootstrap_service(self) -> Optional['outputs.KafkaSpecKafkaTemplateBootstrapService']:
        """
        Template for Kafka bootstrap `Service`.
        """
        return pulumi.get(self, "bootstrap_service")

    @property
    @pulumi.getter(name="brokersService")
    def brokers_service(self) -> Optional['outputs.KafkaSpecKafkaTemplateBrokersService']:
        """
        Template for Kafka broker `Service`.
        """
        return pulumi.get(self, "brokers_service")

    @property
    @pulumi.getter(name="externalBootstrapIngress")
    def external_bootstrap_ingress(self) -> Optional['outputs.KafkaSpecKafkaTemplateExternalBootstrapIngress']:
        """
        Template for Kafka external bootstrap `Ingress`.
        """
        return pulumi.get(self, "external_bootstrap_ingress")

    @property
    @pulumi.getter(name="externalBootstrapRoute")
    def external_bootstrap_route(self) -> Optional['outputs.KafkaSpecKafkaTemplateExternalBootstrapRoute']:
        """
        Template for Kafka external bootstrap `Route`.
        """
        return pulumi.get(self, "external_bootstrap_route")

    @property
    @pulumi.getter(name="externalBootstrapService")
    def external_bootstrap_service(self) -> Optional['outputs.KafkaSpecKafkaTemplateExternalBootstrapService']:
        """
        Template for Kafka external bootstrap `Service`.
        """
        return pulumi.get(self, "external_bootstrap_service")

    @property
    @pulumi.getter(name="initContainer")
    def init_container(self) -> Optional['outputs.KafkaSpecKafkaTemplateInitContainer']:
        """
        Template for the Kafka init container.
        """
        return pulumi.get(self, "init_container")

    @property
    @pulumi.getter(name="kafkaContainer")
    def kafka_container(self) -> Optional['outputs.KafkaSpecKafkaTemplateKafkaContainer']:
        """
        Template for the Kafka broker container.
        """
        return pulumi.get(self, "kafka_container")

    @property
    @pulumi.getter(name="perPodIngress")
    def per_pod_ingress(self) -> Optional['outputs.KafkaSpecKafkaTemplatePerPodIngress']:
        """
        Template for Kafka per-pod `Ingress` used for access from outside of Kubernetes.
        """
        return pulumi.get(self, "per_pod_ingress")

    @property
    @pulumi.getter(name="perPodRoute")
    def per_pod_route(self) -> Optional['outputs.KafkaSpecKafkaTemplatePerPodRoute']:
        """
        Template for Kafka per-pod `Routes` used for access from outside of OpenShift.
        """
        return pulumi.get(self, "per_pod_route")

    @property
    @pulumi.getter(name="perPodService")
    def per_pod_service(self) -> Optional['outputs.KafkaSpecKafkaTemplatePerPodService']:
        """
        Template for Kafka per-pod `Services` used for access from outside of Kubernetes.
        """
        return pulumi.get(self, "per_pod_service")

    @property
    @pulumi.getter(name="persistentVolumeClaim")
    def persistent_volume_claim(self) -> Optional['outputs.KafkaSpecKafkaTemplatePersistentVolumeClaim']:
        """
        Template for all Kafka `PersistentVolumeClaims`.
        """
        return pulumi.get(self, "persistent_volume_claim")

    @property
    @pulumi.getter
    def pod(self) -> Optional['outputs.KafkaSpecKafkaTemplatePod']:
        """
        Template for Kafka `Pods`.
        """
        return pulumi.get(self, "pod")

    @property
    @pulumi.getter(name="podDisruptionBudget")
    def pod_disruption_budget(self) -> Optional['outputs.KafkaSpecKafkaTemplatePodDisruptionBudget']:
        """
        Template for Kafka `PodDisruptionBudget`.
        """
        return pulumi.get(self, "pod_disruption_budget")

    @property
    @pulumi.getter
    def statefulset(self) -> Optional['outputs.KafkaSpecKafkaTemplateStatefulset']:
        """
        Template for Kafka `StatefulSet`.
        """
        return pulumi.get(self, "statefulset")

    @property
    @pulumi.getter(name="tlsSidecarContainer")
    def tls_sidecar_container(self) -> Optional['outputs.KafkaSpecKafkaTemplateTlsSidecarContainer']:
        """
        Template for the Kafka broker TLS sidecar container.
        """
        return pulumi.get(self, "tls_sidecar_container")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplateBootstrapService(dict):
    """
    Template for Kafka bootstrap `Service`.
    """
    def __init__(__self__, *,
                 metadata: Optional['outputs.KafkaSpecKafkaTemplateBootstrapServiceMetadata'] = None):
        """
        Template for Kafka bootstrap `Service`.
        :param 'KafkaSpecKafkaTemplateBootstrapServiceMetadataArgs' metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaSpecKafkaTemplateBootstrapServiceMetadata']:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplateBootstrapServiceMetadata(dict):
    """
    Metadata applied to the resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata applied to the resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplateBrokersService(dict):
    """
    Template for Kafka broker `Service`.
    """
    def __init__(__self__, *,
                 metadata: Optional['outputs.KafkaSpecKafkaTemplateBrokersServiceMetadata'] = None):
        """
        Template for Kafka broker `Service`.
        :param 'KafkaSpecKafkaTemplateBrokersServiceMetadataArgs' metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaSpecKafkaTemplateBrokersServiceMetadata']:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplateBrokersServiceMetadata(dict):
    """
    Metadata applied to the resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata applied to the resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplateExternalBootstrapIngress(dict):
    """
    Template for Kafka external bootstrap `Ingress`.
    """
    def __init__(__self__, *,
                 metadata: Optional['outputs.KafkaSpecKafkaTemplateExternalBootstrapIngressMetadata'] = None):
        """
        Template for Kafka external bootstrap `Ingress`.
        :param 'KafkaSpecKafkaTemplateExternalBootstrapIngressMetadataArgs' metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaSpecKafkaTemplateExternalBootstrapIngressMetadata']:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplateExternalBootstrapIngressMetadata(dict):
    """
    Metadata applied to the resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata applied to the resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplateExternalBootstrapRoute(dict):
    """
    Template for Kafka external bootstrap `Route`.
    """
    def __init__(__self__, *,
                 metadata: Optional['outputs.KafkaSpecKafkaTemplateExternalBootstrapRouteMetadata'] = None):
        """
        Template for Kafka external bootstrap `Route`.
        :param 'KafkaSpecKafkaTemplateExternalBootstrapRouteMetadataArgs' metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaSpecKafkaTemplateExternalBootstrapRouteMetadata']:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplateExternalBootstrapRouteMetadata(dict):
    """
    Metadata applied to the resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata applied to the resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplateExternalBootstrapService(dict):
    """
    Template for Kafka external bootstrap `Service`.
    """
    def __init__(__self__, *,
                 external_traffic_policy: Optional[str] = None,
                 load_balancer_source_ranges: Optional[Sequence[str]] = None,
                 metadata: Optional['outputs.KafkaSpecKafkaTemplateExternalBootstrapServiceMetadata'] = None):
        """
        Template for Kafka external bootstrap `Service`.
        :param str external_traffic_policy: Specifies whether the service routes external traffic to node-local or cluster-wide endpoints. `Cluster` may cause a second hop to another node and obscures the client source IP. `Local` avoids a second hop for LoadBalancer and Nodeport type services and preserves the client source IP (when supported by the infrastructure). If unspecified, Kubernetes will use `Cluster` as the default.
        :param Sequence[str] load_balancer_source_ranges: A list of CIDR ranges (for example `10.0.0.0/8` or `130.211.204.1/32`) from which clients can connect to load balancer type listeners. If supported by the platform, traffic through the loadbalancer is restricted to the specified CIDR ranges. This field is applicable only for loadbalancer type services and is ignored if the cloud provider does not support the feature. For more information, see https://v1-17.docs.kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/. 
        :param 'KafkaSpecKafkaTemplateExternalBootstrapServiceMetadataArgs' metadata: Metadata applied to the resource.
        """
        if external_traffic_policy is not None:
            pulumi.set(__self__, "external_traffic_policy", external_traffic_policy)
        if load_balancer_source_ranges is not None:
            pulumi.set(__self__, "load_balancer_source_ranges", load_balancer_source_ranges)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter(name="externalTrafficPolicy")
    def external_traffic_policy(self) -> Optional[str]:
        """
        Specifies whether the service routes external traffic to node-local or cluster-wide endpoints. `Cluster` may cause a second hop to another node and obscures the client source IP. `Local` avoids a second hop for LoadBalancer and Nodeport type services and preserves the client source IP (when supported by the infrastructure). If unspecified, Kubernetes will use `Cluster` as the default.
        """
        return pulumi.get(self, "external_traffic_policy")

    @property
    @pulumi.getter(name="loadBalancerSourceRanges")
    def load_balancer_source_ranges(self) -> Optional[Sequence[str]]:
        """
        A list of CIDR ranges (for example `10.0.0.0/8` or `130.211.204.1/32`) from which clients can connect to load balancer type listeners. If supported by the platform, traffic through the loadbalancer is restricted to the specified CIDR ranges. This field is applicable only for loadbalancer type services and is ignored if the cloud provider does not support the feature. For more information, see https://v1-17.docs.kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/. 
        """
        return pulumi.get(self, "load_balancer_source_ranges")

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaSpecKafkaTemplateExternalBootstrapServiceMetadata']:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplateExternalBootstrapServiceMetadata(dict):
    """
    Metadata applied to the resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata applied to the resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplateInitContainer(dict):
    """
    Template for the Kafka init container.
    """
    def __init__(__self__, *,
                 env: Optional[Sequence['outputs.KafkaSpecKafkaTemplateInitContainerEnv']] = None,
                 security_context: Optional['outputs.KafkaSpecKafkaTemplateInitContainerSecurityContext'] = None):
        """
        Template for the Kafka init container.
        :param Sequence['KafkaSpecKafkaTemplateInitContainerEnvArgs'] env: Environment variables which should be applied to the container.
        :param 'KafkaSpecKafkaTemplateInitContainerSecurityContextArgs' security_context: Security context for the container.
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)

    @property
    @pulumi.getter
    def env(self) -> Optional[Sequence['outputs.KafkaSpecKafkaTemplateInitContainerEnv']]:
        """
        Environment variables which should be applied to the container.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional['outputs.KafkaSpecKafkaTemplateInitContainerSecurityContext']:
        """
        Security context for the container.
        """
        return pulumi.get(self, "security_context")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplateInitContainerEnv(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The environment variable key.
        :param str value: The environment variable value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The environment variable key.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The environment variable value.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplateInitContainerSecurityContext(dict):
    """
    Security context for the container.
    """
    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[bool] = None,
                 capabilities: Optional['outputs.KafkaSpecKafkaTemplateInitContainerSecurityContextCapabilities'] = None,
                 privileged: Optional[bool] = None,
                 proc_mount: Optional[str] = None,
                 read_only_root_filesystem: Optional[bool] = None,
                 run_as_group: Optional[int] = None,
                 run_as_non_root: Optional[bool] = None,
                 run_as_user: Optional[int] = None,
                 se_linux_options: Optional['outputs.KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions'] = None,
                 windows_options: Optional['outputs.KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptions'] = None):
        """
        Security context for the container.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if proc_mount is not None:
            pulumi.set(__self__, "proc_mount", proc_mount)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[bool]:
        return pulumi.get(self, "allow_privilege_escalation")

    @property
    @pulumi.getter
    def capabilities(self) -> Optional['outputs.KafkaSpecKafkaTemplateInitContainerSecurityContextCapabilities']:
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def privileged(self) -> Optional[bool]:
        return pulumi.get(self, "privileged")

    @property
    @pulumi.getter(name="procMount")
    def proc_mount(self) -> Optional[str]:
        return pulumi.get(self, "proc_mount")

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[bool]:
        return pulumi.get(self, "read_only_root_filesystem")

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[int]:
        return pulumi.get(self, "run_as_group")

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[bool]:
        return pulumi.get(self, "run_as_non_root")

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[int]:
        return pulumi.get(self, "run_as_user")

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional['outputs.KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions']:
        return pulumi.get(self, "se_linux_options")

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional['outputs.KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptions']:
        return pulumi.get(self, "windows_options")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplateInitContainerSecurityContextCapabilities(dict):
    def __init__(__self__, *,
                 add: Optional[Sequence[str]] = None,
                 drop: Optional[Sequence[str]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)

    @property
    @pulumi.getter
    def add(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def drop(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "drop")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions(dict):
    def __init__(__self__, *,
                 level: Optional[str] = None,
                 role: Optional[str] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        return pulumi.get(self, "user")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptions(dict):
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[str] = None,
                 gmsa_credential_spec_name: Optional[str] = None,
                 run_as_user_name: Optional[str] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec")

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[str]:
        return pulumi.get(self, "run_as_user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplateKafkaContainer(dict):
    """
    Template for the Kafka broker container.
    """
    def __init__(__self__, *,
                 env: Optional[Sequence['outputs.KafkaSpecKafkaTemplateKafkaContainerEnv']] = None,
                 security_context: Optional['outputs.KafkaSpecKafkaTemplateKafkaContainerSecurityContext'] = None):
        """
        Template for the Kafka broker container.
        :param Sequence['KafkaSpecKafkaTemplateKafkaContainerEnvArgs'] env: Environment variables which should be applied to the container.
        :param 'KafkaSpecKafkaTemplateKafkaContainerSecurityContextArgs' security_context: Security context for the container.
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)

    @property
    @pulumi.getter
    def env(self) -> Optional[Sequence['outputs.KafkaSpecKafkaTemplateKafkaContainerEnv']]:
        """
        Environment variables which should be applied to the container.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional['outputs.KafkaSpecKafkaTemplateKafkaContainerSecurityContext']:
        """
        Security context for the container.
        """
        return pulumi.get(self, "security_context")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplateKafkaContainerEnv(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The environment variable key.
        :param str value: The environment variable value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The environment variable key.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The environment variable value.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplateKafkaContainerSecurityContext(dict):
    """
    Security context for the container.
    """
    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[bool] = None,
                 capabilities: Optional['outputs.KafkaSpecKafkaTemplateKafkaContainerSecurityContextCapabilities'] = None,
                 privileged: Optional[bool] = None,
                 proc_mount: Optional[str] = None,
                 read_only_root_filesystem: Optional[bool] = None,
                 run_as_group: Optional[int] = None,
                 run_as_non_root: Optional[bool] = None,
                 run_as_user: Optional[int] = None,
                 se_linux_options: Optional['outputs.KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions'] = None,
                 windows_options: Optional['outputs.KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptions'] = None):
        """
        Security context for the container.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if proc_mount is not None:
            pulumi.set(__self__, "proc_mount", proc_mount)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[bool]:
        return pulumi.get(self, "allow_privilege_escalation")

    @property
    @pulumi.getter
    def capabilities(self) -> Optional['outputs.KafkaSpecKafkaTemplateKafkaContainerSecurityContextCapabilities']:
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def privileged(self) -> Optional[bool]:
        return pulumi.get(self, "privileged")

    @property
    @pulumi.getter(name="procMount")
    def proc_mount(self) -> Optional[str]:
        return pulumi.get(self, "proc_mount")

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[bool]:
        return pulumi.get(self, "read_only_root_filesystem")

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[int]:
        return pulumi.get(self, "run_as_group")

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[bool]:
        return pulumi.get(self, "run_as_non_root")

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[int]:
        return pulumi.get(self, "run_as_user")

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional['outputs.KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions']:
        return pulumi.get(self, "se_linux_options")

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional['outputs.KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptions']:
        return pulumi.get(self, "windows_options")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplateKafkaContainerSecurityContextCapabilities(dict):
    def __init__(__self__, *,
                 add: Optional[Sequence[str]] = None,
                 drop: Optional[Sequence[str]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)

    @property
    @pulumi.getter
    def add(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def drop(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "drop")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions(dict):
    def __init__(__self__, *,
                 level: Optional[str] = None,
                 role: Optional[str] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        return pulumi.get(self, "user")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptions(dict):
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[str] = None,
                 gmsa_credential_spec_name: Optional[str] = None,
                 run_as_user_name: Optional[str] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec")

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[str]:
        return pulumi.get(self, "run_as_user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePerPodIngress(dict):
    """
    Template for Kafka per-pod `Ingress` used for access from outside of Kubernetes.
    """
    def __init__(__self__, *,
                 metadata: Optional['outputs.KafkaSpecKafkaTemplatePerPodIngressMetadata'] = None):
        """
        Template for Kafka per-pod `Ingress` used for access from outside of Kubernetes.
        :param 'KafkaSpecKafkaTemplatePerPodIngressMetadataArgs' metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaSpecKafkaTemplatePerPodIngressMetadata']:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePerPodIngressMetadata(dict):
    """
    Metadata applied to the resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata applied to the resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePerPodRoute(dict):
    """
    Template for Kafka per-pod `Routes` used for access from outside of OpenShift.
    """
    def __init__(__self__, *,
                 metadata: Optional['outputs.KafkaSpecKafkaTemplatePerPodRouteMetadata'] = None):
        """
        Template for Kafka per-pod `Routes` used for access from outside of OpenShift.
        :param 'KafkaSpecKafkaTemplatePerPodRouteMetadataArgs' metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaSpecKafkaTemplatePerPodRouteMetadata']:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePerPodRouteMetadata(dict):
    """
    Metadata applied to the resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata applied to the resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePerPodService(dict):
    """
    Template for Kafka per-pod `Services` used for access from outside of Kubernetes.
    """
    def __init__(__self__, *,
                 external_traffic_policy: Optional[str] = None,
                 load_balancer_source_ranges: Optional[Sequence[str]] = None,
                 metadata: Optional['outputs.KafkaSpecKafkaTemplatePerPodServiceMetadata'] = None):
        """
        Template for Kafka per-pod `Services` used for access from outside of Kubernetes.
        :param str external_traffic_policy: Specifies whether the service routes external traffic to node-local or cluster-wide endpoints. `Cluster` may cause a second hop to another node and obscures the client source IP. `Local` avoids a second hop for LoadBalancer and Nodeport type services and preserves the client source IP (when supported by the infrastructure). If unspecified, Kubernetes will use `Cluster` as the default.
        :param Sequence[str] load_balancer_source_ranges: A list of CIDR ranges (for example `10.0.0.0/8` or `130.211.204.1/32`) from which clients can connect to load balancer type listeners. If supported by the platform, traffic through the loadbalancer is restricted to the specified CIDR ranges. This field is applicable only for loadbalancer type services and is ignored if the cloud provider does not support the feature. For more information, see https://v1-17.docs.kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/. 
        :param 'KafkaSpecKafkaTemplatePerPodServiceMetadataArgs' metadata: Metadata applied to the resource.
        """
        if external_traffic_policy is not None:
            pulumi.set(__self__, "external_traffic_policy", external_traffic_policy)
        if load_balancer_source_ranges is not None:
            pulumi.set(__self__, "load_balancer_source_ranges", load_balancer_source_ranges)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter(name="externalTrafficPolicy")
    def external_traffic_policy(self) -> Optional[str]:
        """
        Specifies whether the service routes external traffic to node-local or cluster-wide endpoints. `Cluster` may cause a second hop to another node and obscures the client source IP. `Local` avoids a second hop for LoadBalancer and Nodeport type services and preserves the client source IP (when supported by the infrastructure). If unspecified, Kubernetes will use `Cluster` as the default.
        """
        return pulumi.get(self, "external_traffic_policy")

    @property
    @pulumi.getter(name="loadBalancerSourceRanges")
    def load_balancer_source_ranges(self) -> Optional[Sequence[str]]:
        """
        A list of CIDR ranges (for example `10.0.0.0/8` or `130.211.204.1/32`) from which clients can connect to load balancer type listeners. If supported by the platform, traffic through the loadbalancer is restricted to the specified CIDR ranges. This field is applicable only for loadbalancer type services and is ignored if the cloud provider does not support the feature. For more information, see https://v1-17.docs.kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/. 
        """
        return pulumi.get(self, "load_balancer_source_ranges")

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaSpecKafkaTemplatePerPodServiceMetadata']:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePerPodServiceMetadata(dict):
    """
    Metadata applied to the resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata applied to the resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePersistentVolumeClaim(dict):
    """
    Template for all Kafka `PersistentVolumeClaims`.
    """
    def __init__(__self__, *,
                 metadata: Optional['outputs.KafkaSpecKafkaTemplatePersistentVolumeClaimMetadata'] = None):
        """
        Template for all Kafka `PersistentVolumeClaims`.
        :param 'KafkaSpecKafkaTemplatePersistentVolumeClaimMetadataArgs' metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaSpecKafkaTemplatePersistentVolumeClaimMetadata']:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePersistentVolumeClaimMetadata(dict):
    """
    Metadata applied to the resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata applied to the resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePod(dict):
    """
    Template for Kafka `Pods`.
    """
    def __init__(__self__, *,
                 affinity: Optional['outputs.KafkaSpecKafkaTemplatePodAffinity'] = None,
                 host_aliases: Optional[Sequence['outputs.KafkaSpecKafkaTemplatePodHostAliases']] = None,
                 image_pull_secrets: Optional[Sequence['outputs.KafkaSpecKafkaTemplatePodImagePullSecrets']] = None,
                 metadata: Optional['outputs.KafkaSpecKafkaTemplatePodMetadata'] = None,
                 priority_class_name: Optional[str] = None,
                 scheduler_name: Optional[str] = None,
                 security_context: Optional['outputs.KafkaSpecKafkaTemplatePodSecurityContext'] = None,
                 termination_grace_period_seconds: Optional[int] = None,
                 tolerations: Optional[Sequence['outputs.KafkaSpecKafkaTemplatePodTolerations']] = None):
        """
        Template for Kafka `Pods`.
        :param 'KafkaSpecKafkaTemplatePodAffinityArgs' affinity: The pod's affinity rules.
        :param Sequence['KafkaSpecKafkaTemplatePodHostAliasesArgs'] host_aliases: The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
        :param Sequence['KafkaSpecKafkaTemplatePodImagePullSecretsArgs'] image_pull_secrets: List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
        :param 'KafkaSpecKafkaTemplatePodMetadataArgs' metadata: Metadata applied to the resource.
        :param str priority_class_name: The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
        :param str scheduler_name: The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
        :param 'KafkaSpecKafkaTemplatePodSecurityContextArgs' security_context: Configures pod-level security attributes and common container settings.
        :param int termination_grace_period_seconds: The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
        :param Sequence['KafkaSpecKafkaTemplatePodTolerationsArgs'] tolerations: The pod's tolerations.
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if host_aliases is not None:
            pulumi.set(__self__, "host_aliases", host_aliases)
        if image_pull_secrets is not None:
            pulumi.set(__self__, "image_pull_secrets", image_pull_secrets)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if priority_class_name is not None:
            pulumi.set(__self__, "priority_class_name", priority_class_name)
        if scheduler_name is not None:
            pulumi.set(__self__, "scheduler_name", scheduler_name)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)

    @property
    @pulumi.getter
    def affinity(self) -> Optional['outputs.KafkaSpecKafkaTemplatePodAffinity']:
        """
        The pod's affinity rules.
        """
        return pulumi.get(self, "affinity")

    @property
    @pulumi.getter(name="hostAliases")
    def host_aliases(self) -> Optional[Sequence['outputs.KafkaSpecKafkaTemplatePodHostAliases']]:
        """
        The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
        """
        return pulumi.get(self, "host_aliases")

    @property
    @pulumi.getter(name="imagePullSecrets")
    def image_pull_secrets(self) -> Optional[Sequence['outputs.KafkaSpecKafkaTemplatePodImagePullSecrets']]:
        """
        List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
        """
        return pulumi.get(self, "image_pull_secrets")

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaSpecKafkaTemplatePodMetadata']:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter(name="priorityClassName")
    def priority_class_name(self) -> Optional[str]:
        """
        The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
        """
        return pulumi.get(self, "priority_class_name")

    @property
    @pulumi.getter(name="schedulerName")
    def scheduler_name(self) -> Optional[str]:
        """
        The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
        """
        return pulumi.get(self, "scheduler_name")

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional['outputs.KafkaSpecKafkaTemplatePodSecurityContext']:
        """
        Configures pod-level security attributes and common container settings.
        """
        return pulumi.get(self, "security_context")

    @property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[int]:
        """
        The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
        """
        return pulumi.get(self, "termination_grace_period_seconds")

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[Sequence['outputs.KafkaSpecKafkaTemplatePodTolerations']]:
        """
        The pod's tolerations.
        """
        return pulumi.get(self, "tolerations")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePodAffinity(dict):
    """
    The pod's affinity rules.
    """
    def __init__(__self__, *,
                 node_affinity: Optional['outputs.KafkaSpecKafkaTemplatePodAffinityNodeAffinity'] = None,
                 pod_affinity: Optional['outputs.KafkaSpecKafkaTemplatePodAffinityPodAffinity'] = None,
                 pod_anti_affinity: Optional['outputs.KafkaSpecKafkaTemplatePodAffinityPodAntiAffinity'] = None):
        """
        The pod's affinity rules.
        """
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional['outputs.KafkaSpecKafkaTemplatePodAffinityNodeAffinity']:
        return pulumi.get(self, "node_affinity")

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional['outputs.KafkaSpecKafkaTemplatePodAffinityPodAffinity']:
        return pulumi.get(self, "pod_affinity")

    @property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional['outputs.KafkaSpecKafkaTemplatePodAffinityPodAntiAffinity']:
        return pulumi.get(self, "pod_anti_affinity")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePodAffinityNodeAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional['outputs.KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution'] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional['outputs.KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution']:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 preference: Optional['outputs.KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference'] = None,
                 weight: Optional[int] = None):
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preference(self) -> Optional['outputs.KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference']:
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions']] = None,
                 match_fields: Optional[Sequence['outputs.KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields']] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields']]:
        return pulumi.get(self, "match_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 node_selector_terms: Optional[Sequence['outputs.KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms']] = None):
        if node_selector_terms is not None:
            pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> Optional[Sequence['outputs.KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms']]:
        return pulumi.get(self, "node_selector_terms")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions']] = None,
                 match_fields: Optional[Sequence['outputs.KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields']] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields']]:
        return pulumi.get(self, "match_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePodAffinityPodAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 pod_affinity_term: Optional['outputs.KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm'] = None,
                 weight: Optional[int] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional['outputs.KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm']:
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePodAffinityPodAntiAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 pod_affinity_term: Optional['outputs.KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm'] = None,
                 weight: Optional[int] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional['outputs.KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm']:
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePodDisruptionBudget(dict):
    """
    Template for Kafka `PodDisruptionBudget`.
    """
    def __init__(__self__, *,
                 max_unavailable: Optional[int] = None,
                 metadata: Optional['outputs.KafkaSpecKafkaTemplatePodDisruptionBudgetMetadata'] = None):
        """
        Template for Kafka `PodDisruptionBudget`.
        :param int max_unavailable: Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
        :param 'KafkaSpecKafkaTemplatePodDisruptionBudgetMetadataArgs' metadata: Metadata to apply to the `PodDistruptionBugetTemplate` resource.
        """
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[int]:
        """
        Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
        """
        return pulumi.get(self, "max_unavailable")

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaSpecKafkaTemplatePodDisruptionBudgetMetadata']:
        """
        Metadata to apply to the `PodDistruptionBugetTemplate` resource.
        """
        return pulumi.get(self, "metadata")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePodDisruptionBudgetMetadata(dict):
    """
    Metadata to apply to the `PodDistruptionBugetTemplate` resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata to apply to the `PodDistruptionBugetTemplate` resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePodHostAliases(dict):
    def __init__(__self__, *,
                 hostnames: Optional[Sequence[str]] = None,
                 ip: Optional[str] = None):
        if hostnames is not None:
            pulumi.set(__self__, "hostnames", hostnames)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def hostnames(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "hostnames")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        return pulumi.get(self, "ip")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePodImagePullSecrets(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePodMetadata(dict):
    """
    Metadata applied to the resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata applied to the resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePodSecurityContext(dict):
    """
    Configures pod-level security attributes and common container settings.
    """
    def __init__(__self__, *,
                 fs_group: Optional[int] = None,
                 fs_group_change_policy: Optional[str] = None,
                 run_as_group: Optional[int] = None,
                 run_as_non_root: Optional[bool] = None,
                 run_as_user: Optional[int] = None,
                 se_linux_options: Optional['outputs.KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions'] = None,
                 supplemental_groups: Optional[Sequence[int]] = None,
                 sysctls: Optional[Sequence['outputs.KafkaSpecKafkaTemplatePodSecurityContextSysctls']] = None,
                 windows_options: Optional['outputs.KafkaSpecKafkaTemplatePodSecurityContextWindowsOptions'] = None):
        """
        Configures pod-level security attributes and common container settings.
        """
        if fs_group is not None:
            pulumi.set(__self__, "fs_group", fs_group)
        if fs_group_change_policy is not None:
            pulumi.set(__self__, "fs_group_change_policy", fs_group_change_policy)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if supplemental_groups is not None:
            pulumi.set(__self__, "supplemental_groups", supplemental_groups)
        if sysctls is not None:
            pulumi.set(__self__, "sysctls", sysctls)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="fsGroup")
    def fs_group(self) -> Optional[int]:
        return pulumi.get(self, "fs_group")

    @property
    @pulumi.getter(name="fsGroupChangePolicy")
    def fs_group_change_policy(self) -> Optional[str]:
        return pulumi.get(self, "fs_group_change_policy")

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[int]:
        return pulumi.get(self, "run_as_group")

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[bool]:
        return pulumi.get(self, "run_as_non_root")

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[int]:
        return pulumi.get(self, "run_as_user")

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional['outputs.KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions']:
        return pulumi.get(self, "se_linux_options")

    @property
    @pulumi.getter(name="supplementalGroups")
    def supplemental_groups(self) -> Optional[Sequence[int]]:
        return pulumi.get(self, "supplemental_groups")

    @property
    @pulumi.getter
    def sysctls(self) -> Optional[Sequence['outputs.KafkaSpecKafkaTemplatePodSecurityContextSysctls']]:
        return pulumi.get(self, "sysctls")

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional['outputs.KafkaSpecKafkaTemplatePodSecurityContextWindowsOptions']:
        return pulumi.get(self, "windows_options")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions(dict):
    def __init__(__self__, *,
                 level: Optional[str] = None,
                 role: Optional[str] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        return pulumi.get(self, "user")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePodSecurityContextSysctls(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePodSecurityContextWindowsOptions(dict):
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[str] = None,
                 gmsa_credential_spec_name: Optional[str] = None,
                 run_as_user_name: Optional[str] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec")

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[str]:
        return pulumi.get(self, "run_as_user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplatePodTolerations(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 toleration_seconds: Optional[int] = None,
                 value: Optional[str] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if toleration_seconds is not None:
            pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> Optional[int]:
        return pulumi.get(self, "toleration_seconds")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplateStatefulset(dict):
    """
    Template for Kafka `StatefulSet`.
    """
    def __init__(__self__, *,
                 metadata: Optional['outputs.KafkaSpecKafkaTemplateStatefulsetMetadata'] = None,
                 pod_management_policy: Optional[str] = None):
        """
        Template for Kafka `StatefulSet`.
        :param 'KafkaSpecKafkaTemplateStatefulsetMetadataArgs' metadata: Metadata applied to the resource.
        :param str pod_management_policy: PodManagementPolicy which will be used for this StatefulSet. Valid values are `Parallel` and `OrderedReady`. Defaults to `Parallel`.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if pod_management_policy is not None:
            pulumi.set(__self__, "pod_management_policy", pod_management_policy)

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaSpecKafkaTemplateStatefulsetMetadata']:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter(name="podManagementPolicy")
    def pod_management_policy(self) -> Optional[str]:
        """
        PodManagementPolicy which will be used for this StatefulSet. Valid values are `Parallel` and `OrderedReady`. Defaults to `Parallel`.
        """
        return pulumi.get(self, "pod_management_policy")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplateStatefulsetMetadata(dict):
    """
    Metadata applied to the resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata applied to the resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplateTlsSidecarContainer(dict):
    """
    Template for the Kafka broker TLS sidecar container.
    """
    def __init__(__self__, *,
                 env: Optional[Sequence['outputs.KafkaSpecKafkaTemplateTlsSidecarContainerEnv']] = None,
                 security_context: Optional['outputs.KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContext'] = None):
        """
        Template for the Kafka broker TLS sidecar container.
        :param Sequence['KafkaSpecKafkaTemplateTlsSidecarContainerEnvArgs'] env: Environment variables which should be applied to the container.
        :param 'KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextArgs' security_context: Security context for the container.
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)

    @property
    @pulumi.getter
    def env(self) -> Optional[Sequence['outputs.KafkaSpecKafkaTemplateTlsSidecarContainerEnv']]:
        """
        Environment variables which should be applied to the container.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional['outputs.KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContext']:
        """
        Security context for the container.
        """
        return pulumi.get(self, "security_context")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplateTlsSidecarContainerEnv(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The environment variable key.
        :param str value: The environment variable value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The environment variable key.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The environment variable value.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContext(dict):
    """
    Security context for the container.
    """
    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[bool] = None,
                 capabilities: Optional['outputs.KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextCapabilities'] = None,
                 privileged: Optional[bool] = None,
                 proc_mount: Optional[str] = None,
                 read_only_root_filesystem: Optional[bool] = None,
                 run_as_group: Optional[int] = None,
                 run_as_non_root: Optional[bool] = None,
                 run_as_user: Optional[int] = None,
                 se_linux_options: Optional['outputs.KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextSeLinuxOptions'] = None,
                 windows_options: Optional['outputs.KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextWindowsOptions'] = None):
        """
        Security context for the container.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if proc_mount is not None:
            pulumi.set(__self__, "proc_mount", proc_mount)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[bool]:
        return pulumi.get(self, "allow_privilege_escalation")

    @property
    @pulumi.getter
    def capabilities(self) -> Optional['outputs.KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextCapabilities']:
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def privileged(self) -> Optional[bool]:
        return pulumi.get(self, "privileged")

    @property
    @pulumi.getter(name="procMount")
    def proc_mount(self) -> Optional[str]:
        return pulumi.get(self, "proc_mount")

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[bool]:
        return pulumi.get(self, "read_only_root_filesystem")

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[int]:
        return pulumi.get(self, "run_as_group")

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[bool]:
        return pulumi.get(self, "run_as_non_root")

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[int]:
        return pulumi.get(self, "run_as_user")

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional['outputs.KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextSeLinuxOptions']:
        return pulumi.get(self, "se_linux_options")

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional['outputs.KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextWindowsOptions']:
        return pulumi.get(self, "windows_options")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextCapabilities(dict):
    def __init__(__self__, *,
                 add: Optional[Sequence[str]] = None,
                 drop: Optional[Sequence[str]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)

    @property
    @pulumi.getter
    def add(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def drop(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "drop")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextSeLinuxOptions(dict):
    def __init__(__self__, *,
                 level: Optional[str] = None,
                 role: Optional[str] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        return pulumi.get(self, "user")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextWindowsOptions(dict):
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[str] = None,
                 gmsa_credential_spec_name: Optional[str] = None,
                 run_as_user_name: Optional[str] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec")

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[str]:
        return pulumi.get(self, "run_as_user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTlsSidecar(dict):
    """
    TLS sidecar configuration.
    """
    def __init__(__self__, *,
                 image: Optional[str] = None,
                 liveness_probe: Optional['outputs.KafkaSpecKafkaTlsSidecarLivenessProbe'] = None,
                 log_level: Optional[str] = None,
                 readiness_probe: Optional['outputs.KafkaSpecKafkaTlsSidecarReadinessProbe'] = None,
                 resources: Optional['outputs.KafkaSpecKafkaTlsSidecarResources'] = None):
        """
        TLS sidecar configuration.
        :param str image: The docker image for the container.
        :param 'KafkaSpecKafkaTlsSidecarLivenessProbeArgs' liveness_probe: Pod liveness checking.
        :param str log_level: The log level for the TLS sidecar. Default value is `notice`.
        :param 'KafkaSpecKafkaTlsSidecarReadinessProbeArgs' readiness_probe: Pod readiness checking.
        :param 'KafkaSpecKafkaTlsSidecarResourcesArgs' resources: CPU and memory resources to reserve.
        """
        if image is not None:
            pulumi.set(__self__, "image", image)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        The docker image for the container.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional['outputs.KafkaSpecKafkaTlsSidecarLivenessProbe']:
        """
        Pod liveness checking.
        """
        return pulumi.get(self, "liveness_probe")

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[str]:
        """
        The log level for the TLS sidecar. Default value is `notice`.
        """
        return pulumi.get(self, "log_level")

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional['outputs.KafkaSpecKafkaTlsSidecarReadinessProbe']:
        """
        Pod readiness checking.
        """
        return pulumi.get(self, "readiness_probe")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.KafkaSpecKafkaTlsSidecarResources']:
        """
        CPU and memory resources to reserve.
        """
        return pulumi.get(self, "resources")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTlsSidecarLivenessProbe(dict):
    """
    Pod liveness checking.
    """
    def __init__(__self__, *,
                 failure_threshold: Optional[int] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 timeout_seconds: Optional[int] = None):
        """
        Pod liveness checking.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param int initial_delay_seconds: The initial delay before first the health is first checked.
        :param int period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param int timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTlsSidecarReadinessProbe(dict):
    """
    Pod readiness checking.
    """
    def __init__(__self__, *,
                 failure_threshold: Optional[int] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 timeout_seconds: Optional[int] = None):
        """
        Pod readiness checking.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param int initial_delay_seconds: The initial delay before first the health is first checked.
        :param int period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param int timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTlsSidecarResources(dict):
    """
    CPU and memory resources to reserve.
    """
    def __init__(__self__, *,
                 limits: Optional[Mapping[str, Any]] = None,
                 requests: Optional[Mapping[str, Any]] = None):
        """
        CPU and memory resources to reserve.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "requests")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecKafkaTolerations(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 toleration_seconds: Optional[int] = None,
                 value: Optional[str] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if toleration_seconds is not None:
            pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> Optional[int]:
        return pulumi.get(self, "toleration_seconds")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecTopicOperator(dict):
    """
    Configuration of the Topic Operator.
    """
    def __init__(__self__, *,
                 affinity: Optional['outputs.KafkaSpecTopicOperatorAffinity'] = None,
                 image: Optional[str] = None,
                 jvm_options: Optional['outputs.KafkaSpecTopicOperatorJvmOptions'] = None,
                 liveness_probe: Optional['outputs.KafkaSpecTopicOperatorLivenessProbe'] = None,
                 logging: Optional['outputs.KafkaSpecTopicOperatorLogging'] = None,
                 readiness_probe: Optional['outputs.KafkaSpecTopicOperatorReadinessProbe'] = None,
                 reconciliation_interval_seconds: Optional[int] = None,
                 resources: Optional['outputs.KafkaSpecTopicOperatorResources'] = None,
                 tls_sidecar: Optional['outputs.KafkaSpecTopicOperatorTlsSidecar'] = None,
                 topic_metadata_max_attempts: Optional[int] = None,
                 watched_namespace: Optional[str] = None,
                 zookeeper_session_timeout_seconds: Optional[int] = None):
        """
        Configuration of the Topic Operator.
        :param 'KafkaSpecTopicOperatorAffinityArgs' affinity: Pod affinity rules.
        :param str image: The image to use for the Topic Operator.
        :param 'KafkaSpecTopicOperatorJvmOptionsArgs' jvm_options: JVM Options for pods.
        :param 'KafkaSpecTopicOperatorLivenessProbeArgs' liveness_probe: Pod liveness checking.
        :param 'KafkaSpecTopicOperatorLoggingArgs' logging: Logging configuration.
        :param 'KafkaSpecTopicOperatorReadinessProbeArgs' readiness_probe: Pod readiness checking.
        :param int reconciliation_interval_seconds: Interval between periodic reconciliations.
        :param 'KafkaSpecTopicOperatorResourcesArgs' resources: CPU and memory resources to reserve.
        :param 'KafkaSpecTopicOperatorTlsSidecarArgs' tls_sidecar: TLS sidecar configuration.
        :param int topic_metadata_max_attempts: The number of attempts at getting topic metadata.
        :param str watched_namespace: The namespace the Topic Operator should watch.
        :param int zookeeper_session_timeout_seconds: Timeout for the ZooKeeper session.
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if jvm_options is not None:
            pulumi.set(__self__, "jvm_options", jvm_options)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if reconciliation_interval_seconds is not None:
            pulumi.set(__self__, "reconciliation_interval_seconds", reconciliation_interval_seconds)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if tls_sidecar is not None:
            pulumi.set(__self__, "tls_sidecar", tls_sidecar)
        if topic_metadata_max_attempts is not None:
            pulumi.set(__self__, "topic_metadata_max_attempts", topic_metadata_max_attempts)
        if watched_namespace is not None:
            pulumi.set(__self__, "watched_namespace", watched_namespace)
        if zookeeper_session_timeout_seconds is not None:
            pulumi.set(__self__, "zookeeper_session_timeout_seconds", zookeeper_session_timeout_seconds)

    @property
    @pulumi.getter
    def affinity(self) -> Optional['outputs.KafkaSpecTopicOperatorAffinity']:
        """
        Pod affinity rules.
        """
        return pulumi.get(self, "affinity")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        The image to use for the Topic Operator.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="jvmOptions")
    def jvm_options(self) -> Optional['outputs.KafkaSpecTopicOperatorJvmOptions']:
        """
        JVM Options for pods.
        """
        return pulumi.get(self, "jvm_options")

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional['outputs.KafkaSpecTopicOperatorLivenessProbe']:
        """
        Pod liveness checking.
        """
        return pulumi.get(self, "liveness_probe")

    @property
    @pulumi.getter
    def logging(self) -> Optional['outputs.KafkaSpecTopicOperatorLogging']:
        """
        Logging configuration.
        """
        return pulumi.get(self, "logging")

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional['outputs.KafkaSpecTopicOperatorReadinessProbe']:
        """
        Pod readiness checking.
        """
        return pulumi.get(self, "readiness_probe")

    @property
    @pulumi.getter(name="reconciliationIntervalSeconds")
    def reconciliation_interval_seconds(self) -> Optional[int]:
        """
        Interval between periodic reconciliations.
        """
        return pulumi.get(self, "reconciliation_interval_seconds")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.KafkaSpecTopicOperatorResources']:
        """
        CPU and memory resources to reserve.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter(name="tlsSidecar")
    def tls_sidecar(self) -> Optional['outputs.KafkaSpecTopicOperatorTlsSidecar']:
        """
        TLS sidecar configuration.
        """
        return pulumi.get(self, "tls_sidecar")

    @property
    @pulumi.getter(name="topicMetadataMaxAttempts")
    def topic_metadata_max_attempts(self) -> Optional[int]:
        """
        The number of attempts at getting topic metadata.
        """
        return pulumi.get(self, "topic_metadata_max_attempts")

    @property
    @pulumi.getter(name="watchedNamespace")
    def watched_namespace(self) -> Optional[str]:
        """
        The namespace the Topic Operator should watch.
        """
        return pulumi.get(self, "watched_namespace")

    @property
    @pulumi.getter(name="zookeeperSessionTimeoutSeconds")
    def zookeeper_session_timeout_seconds(self) -> Optional[int]:
        """
        Timeout for the ZooKeeper session.
        """
        return pulumi.get(self, "zookeeper_session_timeout_seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecTopicOperatorAffinity(dict):
    """
    Pod affinity rules.
    """
    def __init__(__self__, *,
                 node_affinity: Optional['outputs.KafkaSpecTopicOperatorAffinityNodeAffinity'] = None,
                 pod_affinity: Optional['outputs.KafkaSpecTopicOperatorAffinityPodAffinity'] = None,
                 pod_anti_affinity: Optional['outputs.KafkaSpecTopicOperatorAffinityPodAntiAffinity'] = None):
        """
        Pod affinity rules.
        """
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional['outputs.KafkaSpecTopicOperatorAffinityNodeAffinity']:
        return pulumi.get(self, "node_affinity")

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional['outputs.KafkaSpecTopicOperatorAffinityPodAffinity']:
        return pulumi.get(self, "pod_affinity")

    @property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional['outputs.KafkaSpecTopicOperatorAffinityPodAntiAffinity']:
        return pulumi.get(self, "pod_anti_affinity")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecTopicOperatorAffinityNodeAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional['outputs.KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution'] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional['outputs.KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution']:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 preference: Optional['outputs.KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference'] = None,
                 weight: Optional[int] = None):
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preference(self) -> Optional['outputs.KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference']:
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions']] = None,
                 match_fields: Optional[Sequence['outputs.KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields']] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields']]:
        return pulumi.get(self, "match_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 node_selector_terms: Optional[Sequence['outputs.KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms']] = None):
        if node_selector_terms is not None:
            pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> Optional[Sequence['outputs.KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms']]:
        return pulumi.get(self, "node_selector_terms")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions']] = None,
                 match_fields: Optional[Sequence['outputs.KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields']] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields']]:
        return pulumi.get(self, "match_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecTopicOperatorAffinityPodAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 pod_affinity_term: Optional['outputs.KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm'] = None,
                 weight: Optional[int] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional['outputs.KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm']:
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecTopicOperatorAffinityPodAntiAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 pod_affinity_term: Optional['outputs.KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm'] = None,
                 weight: Optional[int] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional['outputs.KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm']:
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecTopicOperatorJvmOptions(dict):
    """
    JVM Options for pods.
    """
    def __init__(__self__, *,
                 __xx: Optional[Mapping[str, Any]] = None,
                 __xms: Optional[str] = None,
                 __xmx: Optional[str] = None,
                 gc_logging_enabled: Optional[bool] = None,
                 java_system_properties: Optional[Sequence['outputs.KafkaSpecTopicOperatorJvmOptionsJavaSystemProperties']] = None):
        """
        JVM Options for pods.
        :param Mapping[str, Any] __xx: A map of -XX options to the JVM.
        :param str __xms: -Xms option to to the JVM.
        :param str __xmx: -Xmx option to to the JVM.
        :param bool gc_logging_enabled: Specifies whether the Garbage Collection logging is enabled. The default is false.
        :param Sequence['KafkaSpecTopicOperatorJvmOptionsJavaSystemPropertiesArgs'] java_system_properties: A map of additional system properties which will be passed using the `-D` option to the JVM.
        """
        if __xx is not None:
            pulumi.set(__self__, "__xx", __xx)
        if __xms is not None:
            pulumi.set(__self__, "__xms", __xms)
        if __xmx is not None:
            pulumi.set(__self__, "__xmx", __xmx)
        if gc_logging_enabled is not None:
            pulumi.set(__self__, "gc_logging_enabled", gc_logging_enabled)
        if java_system_properties is not None:
            pulumi.set(__self__, "java_system_properties", java_system_properties)

    @property
    @pulumi.getter(name="-XX")
    def __xx(self) -> Optional[Mapping[str, Any]]:
        """
        A map of -XX options to the JVM.
        """
        return pulumi.get(self, "__xx")

    @property
    @pulumi.getter(name="-Xms")
    def __xms(self) -> Optional[str]:
        """
        -Xms option to to the JVM.
        """
        return pulumi.get(self, "__xms")

    @property
    @pulumi.getter(name="-Xmx")
    def __xmx(self) -> Optional[str]:
        """
        -Xmx option to to the JVM.
        """
        return pulumi.get(self, "__xmx")

    @property
    @pulumi.getter(name="gcLoggingEnabled")
    def gc_logging_enabled(self) -> Optional[bool]:
        """
        Specifies whether the Garbage Collection logging is enabled. The default is false.
        """
        return pulumi.get(self, "gc_logging_enabled")

    @property
    @pulumi.getter(name="javaSystemProperties")
    def java_system_properties(self) -> Optional[Sequence['outputs.KafkaSpecTopicOperatorJvmOptionsJavaSystemProperties']]:
        """
        A map of additional system properties which will be passed using the `-D` option to the JVM.
        """
        return pulumi.get(self, "java_system_properties")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecTopicOperatorJvmOptionsJavaSystemProperties(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The system property name.
        :param str value: The system property value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The system property name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The system property value.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecTopicOperatorLivenessProbe(dict):
    """
    Pod liveness checking.
    """
    def __init__(__self__, *,
                 failure_threshold: Optional[int] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 timeout_seconds: Optional[int] = None):
        """
        Pod liveness checking.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param int initial_delay_seconds: The initial delay before first the health is first checked.
        :param int period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param int timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecTopicOperatorLogging(dict):
    """
    Logging configuration.
    """
    def __init__(__self__, *,
                 type: str,
                 loggers: Optional[Mapping[str, Any]] = None,
                 name: Optional[str] = None):
        """
        Logging configuration.
        :param str type: Logging type, must be either 'inline' or 'external'.
        :param Mapping[str, Any] loggers: A Map from logger name to logger level.
        :param str name: The name of the `ConfigMap` from which to get the logging configuration.
        """
        pulumi.set(__self__, "type", type)
        if loggers is not None:
            pulumi.set(__self__, "loggers", loggers)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Logging type, must be either 'inline' or 'external'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def loggers(self) -> Optional[Mapping[str, Any]]:
        """
        A Map from logger name to logger level.
        """
        return pulumi.get(self, "loggers")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the `ConfigMap` from which to get the logging configuration.
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecTopicOperatorReadinessProbe(dict):
    """
    Pod readiness checking.
    """
    def __init__(__self__, *,
                 failure_threshold: Optional[int] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 timeout_seconds: Optional[int] = None):
        """
        Pod readiness checking.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param int initial_delay_seconds: The initial delay before first the health is first checked.
        :param int period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param int timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecTopicOperatorResources(dict):
    """
    CPU and memory resources to reserve.
    """
    def __init__(__self__, *,
                 limits: Optional[Mapping[str, Any]] = None,
                 requests: Optional[Mapping[str, Any]] = None):
        """
        CPU and memory resources to reserve.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "requests")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecTopicOperatorTlsSidecar(dict):
    """
    TLS sidecar configuration.
    """
    def __init__(__self__, *,
                 image: Optional[str] = None,
                 liveness_probe: Optional['outputs.KafkaSpecTopicOperatorTlsSidecarLivenessProbe'] = None,
                 log_level: Optional[str] = None,
                 readiness_probe: Optional['outputs.KafkaSpecTopicOperatorTlsSidecarReadinessProbe'] = None,
                 resources: Optional['outputs.KafkaSpecTopicOperatorTlsSidecarResources'] = None):
        """
        TLS sidecar configuration.
        :param str image: The docker image for the container.
        :param 'KafkaSpecTopicOperatorTlsSidecarLivenessProbeArgs' liveness_probe: Pod liveness checking.
        :param str log_level: The log level for the TLS sidecar. Default value is `notice`.
        :param 'KafkaSpecTopicOperatorTlsSidecarReadinessProbeArgs' readiness_probe: Pod readiness checking.
        :param 'KafkaSpecTopicOperatorTlsSidecarResourcesArgs' resources: CPU and memory resources to reserve.
        """
        if image is not None:
            pulumi.set(__self__, "image", image)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        The docker image for the container.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional['outputs.KafkaSpecTopicOperatorTlsSidecarLivenessProbe']:
        """
        Pod liveness checking.
        """
        return pulumi.get(self, "liveness_probe")

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[str]:
        """
        The log level for the TLS sidecar. Default value is `notice`.
        """
        return pulumi.get(self, "log_level")

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional['outputs.KafkaSpecTopicOperatorTlsSidecarReadinessProbe']:
        """
        Pod readiness checking.
        """
        return pulumi.get(self, "readiness_probe")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.KafkaSpecTopicOperatorTlsSidecarResources']:
        """
        CPU and memory resources to reserve.
        """
        return pulumi.get(self, "resources")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecTopicOperatorTlsSidecarLivenessProbe(dict):
    """
    Pod liveness checking.
    """
    def __init__(__self__, *,
                 failure_threshold: Optional[int] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 timeout_seconds: Optional[int] = None):
        """
        Pod liveness checking.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param int initial_delay_seconds: The initial delay before first the health is first checked.
        :param int period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param int timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecTopicOperatorTlsSidecarReadinessProbe(dict):
    """
    Pod readiness checking.
    """
    def __init__(__self__, *,
                 failure_threshold: Optional[int] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 timeout_seconds: Optional[int] = None):
        """
        Pod readiness checking.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param int initial_delay_seconds: The initial delay before first the health is first checked.
        :param int period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param int timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecTopicOperatorTlsSidecarResources(dict):
    """
    CPU and memory resources to reserve.
    """
    def __init__(__self__, *,
                 limits: Optional[Mapping[str, Any]] = None,
                 requests: Optional[Mapping[str, Any]] = None):
        """
        CPU and memory resources to reserve.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "requests")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeper(dict):
    """
    Configuration of the ZooKeeper cluster.
    """
    def __init__(__self__, *,
                 replicas: int,
                 storage: 'outputs.KafkaSpecZookeeperStorage',
                 affinity: Optional['outputs.KafkaSpecZookeeperAffinity'] = None,
                 config: Optional[Mapping[str, Any]] = None,
                 image: Optional[str] = None,
                 jvm_options: Optional['outputs.KafkaSpecZookeeperJvmOptions'] = None,
                 liveness_probe: Optional['outputs.KafkaSpecZookeeperLivenessProbe'] = None,
                 logging: Optional['outputs.KafkaSpecZookeeperLogging'] = None,
                 metrics: Optional[Mapping[str, Any]] = None,
                 readiness_probe: Optional['outputs.KafkaSpecZookeeperReadinessProbe'] = None,
                 resources: Optional['outputs.KafkaSpecZookeeperResources'] = None,
                 template: Optional['outputs.KafkaSpecZookeeperTemplate'] = None,
                 tls_sidecar: Optional['outputs.KafkaSpecZookeeperTlsSidecar'] = None,
                 tolerations: Optional[Sequence['outputs.KafkaSpecZookeeperTolerations']] = None):
        """
        Configuration of the ZooKeeper cluster.
        :param int replicas: The number of pods in the cluster.
        :param 'KafkaSpecZookeeperStorageArgs' storage: Storage configuration (disk). Cannot be updated.
        :param 'KafkaSpecZookeeperAffinityArgs' affinity: The pod's affinity rules.
        :param Mapping[str, Any] config: The ZooKeeper broker config. Properties with the following prefixes cannot be set: server., dataDir, dataLogDir, clientPort, authProvider, quorum.auth, requireClientAuthScheme, snapshot.trust.empty, standaloneEnabled, reconfigEnabled, 4lw.commands.whitelist, secureClientPort, ssl., serverCnxnFactory, sslQuorum (with the exception of: ssl.protocol, ssl.quorum.protocol, ssl.enabledProtocols, ssl.quorum.enabledProtocols, ssl.ciphersuites, ssl.quorum.ciphersuites, ssl.hostnameVerification, ssl.quorum.hostnameVerification).
        :param str image: The docker image for the pods.
        :param 'KafkaSpecZookeeperJvmOptionsArgs' jvm_options: JVM Options for pods.
        :param 'KafkaSpecZookeeperLivenessProbeArgs' liveness_probe: Pod liveness checking.
        :param 'KafkaSpecZookeeperLoggingArgs' logging: Logging configuration for ZooKeeper.
        :param Mapping[str, Any] metrics: The Prometheus JMX Exporter configuration. See https://github.com/prometheus/jmx_exporter for details of the structure of this configuration.
        :param 'KafkaSpecZookeeperReadinessProbeArgs' readiness_probe: Pod readiness checking.
        :param 'KafkaSpecZookeeperResourcesArgs' resources: CPU and memory resources to reserve.
        :param 'KafkaSpecZookeeperTemplateArgs' template: Template for ZooKeeper cluster resources. The template allows users to specify how are the `StatefulSet`, `Pods` and `Services` generated.
        :param 'KafkaSpecZookeeperTlsSidecarArgs' tls_sidecar: TLS sidecar configuration. The TLS sidecar is not used anymore and this option will be ignored.
        :param Sequence['KafkaSpecZookeeperTolerationsArgs'] tolerations: The pod's tolerations.
        """
        pulumi.set(__self__, "replicas", replicas)
        pulumi.set(__self__, "storage", storage)
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if jvm_options is not None:
            pulumi.set(__self__, "jvm_options", jvm_options)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if template is not None:
            pulumi.set(__self__, "template", template)
        if tls_sidecar is not None:
            pulumi.set(__self__, "tls_sidecar", tls_sidecar)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)

    @property
    @pulumi.getter
    def replicas(self) -> int:
        """
        The number of pods in the cluster.
        """
        return pulumi.get(self, "replicas")

    @property
    @pulumi.getter
    def storage(self) -> 'outputs.KafkaSpecZookeeperStorage':
        """
        Storage configuration (disk). Cannot be updated.
        """
        return pulumi.get(self, "storage")

    @property
    @pulumi.getter
    def affinity(self) -> Optional['outputs.KafkaSpecZookeeperAffinity']:
        """
        The pod's affinity rules.
        """
        return pulumi.get(self, "affinity")

    @property
    @pulumi.getter
    def config(self) -> Optional[Mapping[str, Any]]:
        """
        The ZooKeeper broker config. Properties with the following prefixes cannot be set: server., dataDir, dataLogDir, clientPort, authProvider, quorum.auth, requireClientAuthScheme, snapshot.trust.empty, standaloneEnabled, reconfigEnabled, 4lw.commands.whitelist, secureClientPort, ssl., serverCnxnFactory, sslQuorum (with the exception of: ssl.protocol, ssl.quorum.protocol, ssl.enabledProtocols, ssl.quorum.enabledProtocols, ssl.ciphersuites, ssl.quorum.ciphersuites, ssl.hostnameVerification, ssl.quorum.hostnameVerification).
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        The docker image for the pods.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="jvmOptions")
    def jvm_options(self) -> Optional['outputs.KafkaSpecZookeeperJvmOptions']:
        """
        JVM Options for pods.
        """
        return pulumi.get(self, "jvm_options")

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional['outputs.KafkaSpecZookeeperLivenessProbe']:
        """
        Pod liveness checking.
        """
        return pulumi.get(self, "liveness_probe")

    @property
    @pulumi.getter
    def logging(self) -> Optional['outputs.KafkaSpecZookeeperLogging']:
        """
        Logging configuration for ZooKeeper.
        """
        return pulumi.get(self, "logging")

    @property
    @pulumi.getter
    def metrics(self) -> Optional[Mapping[str, Any]]:
        """
        The Prometheus JMX Exporter configuration. See https://github.com/prometheus/jmx_exporter for details of the structure of this configuration.
        """
        return pulumi.get(self, "metrics")

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional['outputs.KafkaSpecZookeeperReadinessProbe']:
        """
        Pod readiness checking.
        """
        return pulumi.get(self, "readiness_probe")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.KafkaSpecZookeeperResources']:
        """
        CPU and memory resources to reserve.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter
    def template(self) -> Optional['outputs.KafkaSpecZookeeperTemplate']:
        """
        Template for ZooKeeper cluster resources. The template allows users to specify how are the `StatefulSet`, `Pods` and `Services` generated.
        """
        return pulumi.get(self, "template")

    @property
    @pulumi.getter(name="tlsSidecar")
    def tls_sidecar(self) -> Optional['outputs.KafkaSpecZookeeperTlsSidecar']:
        """
        TLS sidecar configuration. The TLS sidecar is not used anymore and this option will be ignored.
        """
        return pulumi.get(self, "tls_sidecar")

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[Sequence['outputs.KafkaSpecZookeeperTolerations']]:
        """
        The pod's tolerations.
        """
        return pulumi.get(self, "tolerations")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperAffinity(dict):
    """
    The pod's affinity rules.
    """
    def __init__(__self__, *,
                 node_affinity: Optional['outputs.KafkaSpecZookeeperAffinityNodeAffinity'] = None,
                 pod_affinity: Optional['outputs.KafkaSpecZookeeperAffinityPodAffinity'] = None,
                 pod_anti_affinity: Optional['outputs.KafkaSpecZookeeperAffinityPodAntiAffinity'] = None):
        """
        The pod's affinity rules.
        """
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional['outputs.KafkaSpecZookeeperAffinityNodeAffinity']:
        return pulumi.get(self, "node_affinity")

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional['outputs.KafkaSpecZookeeperAffinityPodAffinity']:
        return pulumi.get(self, "pod_affinity")

    @property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional['outputs.KafkaSpecZookeeperAffinityPodAntiAffinity']:
        return pulumi.get(self, "pod_anti_affinity")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperAffinityNodeAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional['outputs.KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution'] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional['outputs.KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution']:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 preference: Optional['outputs.KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference'] = None,
                 weight: Optional[int] = None):
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preference(self) -> Optional['outputs.KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference']:
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions']] = None,
                 match_fields: Optional[Sequence['outputs.KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields']] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields']]:
        return pulumi.get(self, "match_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 node_selector_terms: Optional[Sequence['outputs.KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms']] = None):
        if node_selector_terms is not None:
            pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> Optional[Sequence['outputs.KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms']]:
        return pulumi.get(self, "node_selector_terms")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions']] = None,
                 match_fields: Optional[Sequence['outputs.KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields']] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields']]:
        return pulumi.get(self, "match_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperAffinityPodAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 pod_affinity_term: Optional['outputs.KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm'] = None,
                 weight: Optional[int] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional['outputs.KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm']:
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperAffinityPodAntiAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 pod_affinity_term: Optional['outputs.KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm'] = None,
                 weight: Optional[int] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional['outputs.KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm']:
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperJvmOptions(dict):
    """
    JVM Options for pods.
    """
    def __init__(__self__, *,
                 __xx: Optional[Mapping[str, Any]] = None,
                 __xms: Optional[str] = None,
                 __xmx: Optional[str] = None,
                 gc_logging_enabled: Optional[bool] = None,
                 java_system_properties: Optional[Sequence['outputs.KafkaSpecZookeeperJvmOptionsJavaSystemProperties']] = None):
        """
        JVM Options for pods.
        :param Mapping[str, Any] __xx: A map of -XX options to the JVM.
        :param str __xms: -Xms option to to the JVM.
        :param str __xmx: -Xmx option to to the JVM.
        :param bool gc_logging_enabled: Specifies whether the Garbage Collection logging is enabled. The default is false.
        :param Sequence['KafkaSpecZookeeperJvmOptionsJavaSystemPropertiesArgs'] java_system_properties: A map of additional system properties which will be passed using the `-D` option to the JVM.
        """
        if __xx is not None:
            pulumi.set(__self__, "__xx", __xx)
        if __xms is not None:
            pulumi.set(__self__, "__xms", __xms)
        if __xmx is not None:
            pulumi.set(__self__, "__xmx", __xmx)
        if gc_logging_enabled is not None:
            pulumi.set(__self__, "gc_logging_enabled", gc_logging_enabled)
        if java_system_properties is not None:
            pulumi.set(__self__, "java_system_properties", java_system_properties)

    @property
    @pulumi.getter(name="-XX")
    def __xx(self) -> Optional[Mapping[str, Any]]:
        """
        A map of -XX options to the JVM.
        """
        return pulumi.get(self, "__xx")

    @property
    @pulumi.getter(name="-Xms")
    def __xms(self) -> Optional[str]:
        """
        -Xms option to to the JVM.
        """
        return pulumi.get(self, "__xms")

    @property
    @pulumi.getter(name="-Xmx")
    def __xmx(self) -> Optional[str]:
        """
        -Xmx option to to the JVM.
        """
        return pulumi.get(self, "__xmx")

    @property
    @pulumi.getter(name="gcLoggingEnabled")
    def gc_logging_enabled(self) -> Optional[bool]:
        """
        Specifies whether the Garbage Collection logging is enabled. The default is false.
        """
        return pulumi.get(self, "gc_logging_enabled")

    @property
    @pulumi.getter(name="javaSystemProperties")
    def java_system_properties(self) -> Optional[Sequence['outputs.KafkaSpecZookeeperJvmOptionsJavaSystemProperties']]:
        """
        A map of additional system properties which will be passed using the `-D` option to the JVM.
        """
        return pulumi.get(self, "java_system_properties")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperJvmOptionsJavaSystemProperties(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The system property name.
        :param str value: The system property value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The system property name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The system property value.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperLivenessProbe(dict):
    """
    Pod liveness checking.
    """
    def __init__(__self__, *,
                 failure_threshold: Optional[int] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 timeout_seconds: Optional[int] = None):
        """
        Pod liveness checking.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param int initial_delay_seconds: The initial delay before first the health is first checked.
        :param int period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param int timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperLogging(dict):
    """
    Logging configuration for ZooKeeper.
    """
    def __init__(__self__, *,
                 type: str,
                 loggers: Optional[Mapping[str, Any]] = None,
                 name: Optional[str] = None):
        """
        Logging configuration for ZooKeeper.
        :param str type: Logging type, must be either 'inline' or 'external'.
        :param Mapping[str, Any] loggers: A Map from logger name to logger level.
        :param str name: The name of the `ConfigMap` from which to get the logging configuration.
        """
        pulumi.set(__self__, "type", type)
        if loggers is not None:
            pulumi.set(__self__, "loggers", loggers)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Logging type, must be either 'inline' or 'external'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def loggers(self) -> Optional[Mapping[str, Any]]:
        """
        A Map from logger name to logger level.
        """
        return pulumi.get(self, "loggers")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the `ConfigMap` from which to get the logging configuration.
        """
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperReadinessProbe(dict):
    """
    Pod readiness checking.
    """
    def __init__(__self__, *,
                 failure_threshold: Optional[int] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 timeout_seconds: Optional[int] = None):
        """
        Pod readiness checking.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param int initial_delay_seconds: The initial delay before first the health is first checked.
        :param int period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param int timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperResources(dict):
    """
    CPU and memory resources to reserve.
    """
    def __init__(__self__, *,
                 limits: Optional[Mapping[str, Any]] = None,
                 requests: Optional[Mapping[str, Any]] = None):
        """
        CPU and memory resources to reserve.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "requests")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperStorage(dict):
    """
    Storage configuration (disk). Cannot be updated.
    """
    def __init__(__self__, *,
                 type: str,
                 class_: Optional[str] = None,
                 delete_claim: Optional[bool] = None,
                 id: Optional[int] = None,
                 overrides: Optional[Sequence['outputs.KafkaSpecZookeeperStorageOverrides']] = None,
                 selector: Optional[Mapping[str, Any]] = None,
                 size: Optional[str] = None,
                 size_limit: Optional[str] = None):
        """
        Storage configuration (disk). Cannot be updated.
        :param str type: Storage type, must be either 'ephemeral' or 'persistent-claim'.
        :param str class_: The storage class to use for dynamic volume allocation.
        :param bool delete_claim: Specifies if the persistent volume claim has to be deleted when the cluster is un-deployed.
        :param int id: Storage identification number. It is mandatory only for storage volumes defined in a storage of type 'jbod'.
        :param Sequence['KafkaSpecZookeeperStorageOverridesArgs'] overrides: Overrides for individual brokers. The `overrides` field allows to specify a different configuration for different brokers.
        :param Mapping[str, Any] selector: Specifies a specific persistent volume to use. It contains key:value pairs representing labels for selecting such a volume.
        :param str size: When type=persistent-claim, defines the size of the persistent volume claim (i.e 1Gi). Mandatory when type=persistent-claim.
        :param str size_limit: When type=ephemeral, defines the total amount of local storage required for this EmptyDir volume (for example 1Gi).
        """
        pulumi.set(__self__, "type", type)
        if class_ is not None:
            pulumi.set(__self__, "class_", class_)
        if delete_claim is not None:
            pulumi.set(__self__, "delete_claim", delete_claim)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if size_limit is not None:
            pulumi.set(__self__, "size_limit", size_limit)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Storage type, must be either 'ephemeral' or 'persistent-claim'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="class")
    def class_(self) -> Optional[str]:
        """
        The storage class to use for dynamic volume allocation.
        """
        return pulumi.get(self, "class_")

    @property
    @pulumi.getter(name="deleteClaim")
    def delete_claim(self) -> Optional[bool]:
        """
        Specifies if the persistent volume claim has to be deleted when the cluster is un-deployed.
        """
        return pulumi.get(self, "delete_claim")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Storage identification number. It is mandatory only for storage volumes defined in a storage of type 'jbod'.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def overrides(self) -> Optional[Sequence['outputs.KafkaSpecZookeeperStorageOverrides']]:
        """
        Overrides for individual brokers. The `overrides` field allows to specify a different configuration for different brokers.
        """
        return pulumi.get(self, "overrides")

    @property
    @pulumi.getter
    def selector(self) -> Optional[Mapping[str, Any]]:
        """
        Specifies a specific persistent volume to use. It contains key:value pairs representing labels for selecting such a volume.
        """
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter
    def size(self) -> Optional[str]:
        """
        When type=persistent-claim, defines the size of the persistent volume claim (i.e 1Gi). Mandatory when type=persistent-claim.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="sizeLimit")
    def size_limit(self) -> Optional[str]:
        """
        When type=ephemeral, defines the total amount of local storage required for this EmptyDir volume (for example 1Gi).
        """
        return pulumi.get(self, "size_limit")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperStorageOverrides(dict):
    def __init__(__self__, *,
                 broker: Optional[int] = None,
                 class_: Optional[str] = None):
        """
        :param int broker: Id of the kafka broker (broker identifier).
        :param str class_: The storage class to use for dynamic volume allocation for this broker.
        """
        if broker is not None:
            pulumi.set(__self__, "broker", broker)
        if class_ is not None:
            pulumi.set(__self__, "class_", class_)

    @property
    @pulumi.getter
    def broker(self) -> Optional[int]:
        """
        Id of the kafka broker (broker identifier).
        """
        return pulumi.get(self, "broker")

    @property
    @pulumi.getter(name="class")
    def class_(self) -> Optional[str]:
        """
        The storage class to use for dynamic volume allocation for this broker.
        """
        return pulumi.get(self, "class_")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplate(dict):
    """
    Template for ZooKeeper cluster resources. The template allows users to specify how are the `StatefulSet`, `Pods` and `Services` generated.
    """
    def __init__(__self__, *,
                 client_service: Optional['outputs.KafkaSpecZookeeperTemplateClientService'] = None,
                 nodes_service: Optional['outputs.KafkaSpecZookeeperTemplateNodesService'] = None,
                 persistent_volume_claim: Optional['outputs.KafkaSpecZookeeperTemplatePersistentVolumeClaim'] = None,
                 pod: Optional['outputs.KafkaSpecZookeeperTemplatePod'] = None,
                 pod_disruption_budget: Optional['outputs.KafkaSpecZookeeperTemplatePodDisruptionBudget'] = None,
                 statefulset: Optional['outputs.KafkaSpecZookeeperTemplateStatefulset'] = None,
                 tls_sidecar_container: Optional['outputs.KafkaSpecZookeeperTemplateTlsSidecarContainer'] = None,
                 zookeeper_container: Optional['outputs.KafkaSpecZookeeperTemplateZookeeperContainer'] = None):
        """
        Template for ZooKeeper cluster resources. The template allows users to specify how are the `StatefulSet`, `Pods` and `Services` generated.
        :param 'KafkaSpecZookeeperTemplateClientServiceArgs' client_service: Template for ZooKeeper client `Service`.
        :param 'KafkaSpecZookeeperTemplateNodesServiceArgs' nodes_service: Template for ZooKeeper nodes `Service`.
        :param 'KafkaSpecZookeeperTemplatePersistentVolumeClaimArgs' persistent_volume_claim: Template for all ZooKeeper `PersistentVolumeClaims`.
        :param 'KafkaSpecZookeeperTemplatePodArgs' pod: Template for ZooKeeper `Pods`.
        :param 'KafkaSpecZookeeperTemplatePodDisruptionBudgetArgs' pod_disruption_budget: Template for ZooKeeper `PodDisruptionBudget`.
        :param 'KafkaSpecZookeeperTemplateStatefulsetArgs' statefulset: Template for ZooKeeper `StatefulSet`.
        :param 'KafkaSpecZookeeperTemplateTlsSidecarContainerArgs' tls_sidecar_container: Template for the Zookeeper server TLS sidecar container. The TLS sidecar is not used anymore and this option will be ignored.
        :param 'KafkaSpecZookeeperTemplateZookeeperContainerArgs' zookeeper_container: Template for the ZooKeeper container.
        """
        if client_service is not None:
            pulumi.set(__self__, "client_service", client_service)
        if nodes_service is not None:
            pulumi.set(__self__, "nodes_service", nodes_service)
        if persistent_volume_claim is not None:
            pulumi.set(__self__, "persistent_volume_claim", persistent_volume_claim)
        if pod is not None:
            pulumi.set(__self__, "pod", pod)
        if pod_disruption_budget is not None:
            pulumi.set(__self__, "pod_disruption_budget", pod_disruption_budget)
        if statefulset is not None:
            pulumi.set(__self__, "statefulset", statefulset)
        if tls_sidecar_container is not None:
            pulumi.set(__self__, "tls_sidecar_container", tls_sidecar_container)
        if zookeeper_container is not None:
            pulumi.set(__self__, "zookeeper_container", zookeeper_container)

    @property
    @pulumi.getter(name="clientService")
    def client_service(self) -> Optional['outputs.KafkaSpecZookeeperTemplateClientService']:
        """
        Template for ZooKeeper client `Service`.
        """
        return pulumi.get(self, "client_service")

    @property
    @pulumi.getter(name="nodesService")
    def nodes_service(self) -> Optional['outputs.KafkaSpecZookeeperTemplateNodesService']:
        """
        Template for ZooKeeper nodes `Service`.
        """
        return pulumi.get(self, "nodes_service")

    @property
    @pulumi.getter(name="persistentVolumeClaim")
    def persistent_volume_claim(self) -> Optional['outputs.KafkaSpecZookeeperTemplatePersistentVolumeClaim']:
        """
        Template for all ZooKeeper `PersistentVolumeClaims`.
        """
        return pulumi.get(self, "persistent_volume_claim")

    @property
    @pulumi.getter
    def pod(self) -> Optional['outputs.KafkaSpecZookeeperTemplatePod']:
        """
        Template for ZooKeeper `Pods`.
        """
        return pulumi.get(self, "pod")

    @property
    @pulumi.getter(name="podDisruptionBudget")
    def pod_disruption_budget(self) -> Optional['outputs.KafkaSpecZookeeperTemplatePodDisruptionBudget']:
        """
        Template for ZooKeeper `PodDisruptionBudget`.
        """
        return pulumi.get(self, "pod_disruption_budget")

    @property
    @pulumi.getter
    def statefulset(self) -> Optional['outputs.KafkaSpecZookeeperTemplateStatefulset']:
        """
        Template for ZooKeeper `StatefulSet`.
        """
        return pulumi.get(self, "statefulset")

    @property
    @pulumi.getter(name="tlsSidecarContainer")
    def tls_sidecar_container(self) -> Optional['outputs.KafkaSpecZookeeperTemplateTlsSidecarContainer']:
        """
        Template for the Zookeeper server TLS sidecar container. The TLS sidecar is not used anymore and this option will be ignored.
        """
        return pulumi.get(self, "tls_sidecar_container")

    @property
    @pulumi.getter(name="zookeeperContainer")
    def zookeeper_container(self) -> Optional['outputs.KafkaSpecZookeeperTemplateZookeeperContainer']:
        """
        Template for the ZooKeeper container.
        """
        return pulumi.get(self, "zookeeper_container")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplateClientService(dict):
    """
    Template for ZooKeeper client `Service`.
    """
    def __init__(__self__, *,
                 metadata: Optional['outputs.KafkaSpecZookeeperTemplateClientServiceMetadata'] = None):
        """
        Template for ZooKeeper client `Service`.
        :param 'KafkaSpecZookeeperTemplateClientServiceMetadataArgs' metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaSpecZookeeperTemplateClientServiceMetadata']:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplateClientServiceMetadata(dict):
    """
    Metadata applied to the resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata applied to the resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplateNodesService(dict):
    """
    Template for ZooKeeper nodes `Service`.
    """
    def __init__(__self__, *,
                 metadata: Optional['outputs.KafkaSpecZookeeperTemplateNodesServiceMetadata'] = None):
        """
        Template for ZooKeeper nodes `Service`.
        :param 'KafkaSpecZookeeperTemplateNodesServiceMetadataArgs' metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaSpecZookeeperTemplateNodesServiceMetadata']:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplateNodesServiceMetadata(dict):
    """
    Metadata applied to the resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata applied to the resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplatePersistentVolumeClaim(dict):
    """
    Template for all ZooKeeper `PersistentVolumeClaims`.
    """
    def __init__(__self__, *,
                 metadata: Optional['outputs.KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadata'] = None):
        """
        Template for all ZooKeeper `PersistentVolumeClaims`.
        :param 'KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadataArgs' metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadata']:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadata(dict):
    """
    Metadata applied to the resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata applied to the resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplatePod(dict):
    """
    Template for ZooKeeper `Pods`.
    """
    def __init__(__self__, *,
                 affinity: Optional['outputs.KafkaSpecZookeeperTemplatePodAffinity'] = None,
                 host_aliases: Optional[Sequence['outputs.KafkaSpecZookeeperTemplatePodHostAliases']] = None,
                 image_pull_secrets: Optional[Sequence['outputs.KafkaSpecZookeeperTemplatePodImagePullSecrets']] = None,
                 metadata: Optional['outputs.KafkaSpecZookeeperTemplatePodMetadata'] = None,
                 priority_class_name: Optional[str] = None,
                 scheduler_name: Optional[str] = None,
                 security_context: Optional['outputs.KafkaSpecZookeeperTemplatePodSecurityContext'] = None,
                 termination_grace_period_seconds: Optional[int] = None,
                 tolerations: Optional[Sequence['outputs.KafkaSpecZookeeperTemplatePodTolerations']] = None):
        """
        Template for ZooKeeper `Pods`.
        :param 'KafkaSpecZookeeperTemplatePodAffinityArgs' affinity: The pod's affinity rules.
        :param Sequence['KafkaSpecZookeeperTemplatePodHostAliasesArgs'] host_aliases: The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
        :param Sequence['KafkaSpecZookeeperTemplatePodImagePullSecretsArgs'] image_pull_secrets: List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
        :param 'KafkaSpecZookeeperTemplatePodMetadataArgs' metadata: Metadata applied to the resource.
        :param str priority_class_name: The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
        :param str scheduler_name: The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
        :param 'KafkaSpecZookeeperTemplatePodSecurityContextArgs' security_context: Configures pod-level security attributes and common container settings.
        :param int termination_grace_period_seconds: The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
        :param Sequence['KafkaSpecZookeeperTemplatePodTolerationsArgs'] tolerations: The pod's tolerations.
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if host_aliases is not None:
            pulumi.set(__self__, "host_aliases", host_aliases)
        if image_pull_secrets is not None:
            pulumi.set(__self__, "image_pull_secrets", image_pull_secrets)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if priority_class_name is not None:
            pulumi.set(__self__, "priority_class_name", priority_class_name)
        if scheduler_name is not None:
            pulumi.set(__self__, "scheduler_name", scheduler_name)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)

    @property
    @pulumi.getter
    def affinity(self) -> Optional['outputs.KafkaSpecZookeeperTemplatePodAffinity']:
        """
        The pod's affinity rules.
        """
        return pulumi.get(self, "affinity")

    @property
    @pulumi.getter(name="hostAliases")
    def host_aliases(self) -> Optional[Sequence['outputs.KafkaSpecZookeeperTemplatePodHostAliases']]:
        """
        The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
        """
        return pulumi.get(self, "host_aliases")

    @property
    @pulumi.getter(name="imagePullSecrets")
    def image_pull_secrets(self) -> Optional[Sequence['outputs.KafkaSpecZookeeperTemplatePodImagePullSecrets']]:
        """
        List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
        """
        return pulumi.get(self, "image_pull_secrets")

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaSpecZookeeperTemplatePodMetadata']:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter(name="priorityClassName")
    def priority_class_name(self) -> Optional[str]:
        """
        The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
        """
        return pulumi.get(self, "priority_class_name")

    @property
    @pulumi.getter(name="schedulerName")
    def scheduler_name(self) -> Optional[str]:
        """
        The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
        """
        return pulumi.get(self, "scheduler_name")

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional['outputs.KafkaSpecZookeeperTemplatePodSecurityContext']:
        """
        Configures pod-level security attributes and common container settings.
        """
        return pulumi.get(self, "security_context")

    @property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[int]:
        """
        The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
        """
        return pulumi.get(self, "termination_grace_period_seconds")

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[Sequence['outputs.KafkaSpecZookeeperTemplatePodTolerations']]:
        """
        The pod's tolerations.
        """
        return pulumi.get(self, "tolerations")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplatePodAffinity(dict):
    """
    The pod's affinity rules.
    """
    def __init__(__self__, *,
                 node_affinity: Optional['outputs.KafkaSpecZookeeperTemplatePodAffinityNodeAffinity'] = None,
                 pod_affinity: Optional['outputs.KafkaSpecZookeeperTemplatePodAffinityPodAffinity'] = None,
                 pod_anti_affinity: Optional['outputs.KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinity'] = None):
        """
        The pod's affinity rules.
        """
        if node_affinity is not None:
            pulumi.set(__self__, "node_affinity", node_affinity)
        if pod_affinity is not None:
            pulumi.set(__self__, "pod_affinity", pod_affinity)
        if pod_anti_affinity is not None:
            pulumi.set(__self__, "pod_anti_affinity", pod_anti_affinity)

    @property
    @pulumi.getter(name="nodeAffinity")
    def node_affinity(self) -> Optional['outputs.KafkaSpecZookeeperTemplatePodAffinityNodeAffinity']:
        return pulumi.get(self, "node_affinity")

    @property
    @pulumi.getter(name="podAffinity")
    def pod_affinity(self) -> Optional['outputs.KafkaSpecZookeeperTemplatePodAffinityPodAffinity']:
        return pulumi.get(self, "pod_affinity")

    @property
    @pulumi.getter(name="podAntiAffinity")
    def pod_anti_affinity(self) -> Optional['outputs.KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinity']:
        return pulumi.get(self, "pod_anti_affinity")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplatePodAffinityNodeAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional['outputs.KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution'] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional['outputs.KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution']:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 preference: Optional['outputs.KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference'] = None,
                 weight: Optional[int] = None):
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def preference(self) -> Optional['outputs.KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference']:
        return pulumi.get(self, "preference")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions']] = None,
                 match_fields: Optional[Sequence['outputs.KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields']] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields']]:
        return pulumi.get(self, "match_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 node_selector_terms: Optional[Sequence['outputs.KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms']] = None):
        if node_selector_terms is not None:
            pulumi.set(__self__, "node_selector_terms", node_selector_terms)

    @property
    @pulumi.getter(name="nodeSelectorTerms")
    def node_selector_terms(self) -> Optional[Sequence['outputs.KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms']]:
        return pulumi.get(self, "node_selector_terms")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions']] = None,
                 match_fields: Optional[Sequence['outputs.KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields']] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_fields is not None:
            pulumi.set(__self__, "match_fields", match_fields)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchFields")
    def match_fields(self) -> Optional[Sequence['outputs.KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields']]:
        return pulumi.get(self, "match_fields")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplatePodAffinityPodAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 pod_affinity_term: Optional['outputs.KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm'] = None,
                 weight: Optional[int] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional['outputs.KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm']:
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinity(dict):
    def __init__(__self__, *,
                 preferred_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']] = None,
                 required_during_scheduling_ignored_during_execution: Optional[Sequence['outputs.KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']] = None):
        if preferred_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "preferred_during_scheduling_ignored_during_execution", preferred_during_scheduling_ignored_during_execution)
        if required_during_scheduling_ignored_during_execution is not None:
            pulumi.set(__self__, "required_during_scheduling_ignored_during_execution", required_during_scheduling_ignored_during_execution)

    @property
    @pulumi.getter(name="preferredDuringSchedulingIgnoredDuringExecution")
    def preferred_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "preferred_during_scheduling_ignored_during_execution")

    @property
    @pulumi.getter(name="requiredDuringSchedulingIgnoredDuringExecution")
    def required_during_scheduling_ignored_during_execution(self) -> Optional[Sequence['outputs.KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution']]:
        return pulumi.get(self, "required_during_scheduling_ignored_during_execution")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 pod_affinity_term: Optional['outputs.KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm'] = None,
                 weight: Optional[int] = None):
        if pod_affinity_term is not None:
            pulumi.set(__self__, "pod_affinity_term", pod_affinity_term)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="podAffinityTerm")
    def pod_affinity_term(self) -> Optional['outputs.KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm']:
        return pulumi.get(self, "pod_affinity_term")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(dict):
    def __init__(__self__, *,
                 label_selector: Optional['outputs.KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector'] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 topology_key: Optional[str] = None):
        if label_selector is not None:
            pulumi.set(__self__, "label_selector", label_selector)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if topology_key is not None:
            pulumi.set(__self__, "topology_key", topology_key)

    @property
    @pulumi.getter(name="labelSelector")
    def label_selector(self) -> Optional['outputs.KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector']:
        return pulumi.get(self, "label_selector")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter(name="topologyKey")
    def topology_key(self) -> Optional[str]:
        return pulumi.get(self, "topology_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']] = None,
                 match_labels: Optional[Mapping[str, Any]] = None):
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions']]:
        return pulumi.get(self, "match_expressions")

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "match_labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplatePodDisruptionBudget(dict):
    """
    Template for ZooKeeper `PodDisruptionBudget`.
    """
    def __init__(__self__, *,
                 max_unavailable: Optional[int] = None,
                 metadata: Optional['outputs.KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadata'] = None):
        """
        Template for ZooKeeper `PodDisruptionBudget`.
        :param int max_unavailable: Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
        :param 'KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadataArgs' metadata: Metadata to apply to the `PodDistruptionBugetTemplate` resource.
        """
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[int]:
        """
        Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
        """
        return pulumi.get(self, "max_unavailable")

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadata']:
        """
        Metadata to apply to the `PodDistruptionBugetTemplate` resource.
        """
        return pulumi.get(self, "metadata")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadata(dict):
    """
    Metadata to apply to the `PodDistruptionBugetTemplate` resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata to apply to the `PodDistruptionBugetTemplate` resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplatePodHostAliases(dict):
    def __init__(__self__, *,
                 hostnames: Optional[Sequence[str]] = None,
                 ip: Optional[str] = None):
        if hostnames is not None:
            pulumi.set(__self__, "hostnames", hostnames)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def hostnames(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "hostnames")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        return pulumi.get(self, "ip")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplatePodImagePullSecrets(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplatePodMetadata(dict):
    """
    Metadata applied to the resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata applied to the resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplatePodSecurityContext(dict):
    """
    Configures pod-level security attributes and common container settings.
    """
    def __init__(__self__, *,
                 fs_group: Optional[int] = None,
                 fs_group_change_policy: Optional[str] = None,
                 run_as_group: Optional[int] = None,
                 run_as_non_root: Optional[bool] = None,
                 run_as_user: Optional[int] = None,
                 se_linux_options: Optional['outputs.KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions'] = None,
                 supplemental_groups: Optional[Sequence[int]] = None,
                 sysctls: Optional[Sequence['outputs.KafkaSpecZookeeperTemplatePodSecurityContextSysctls']] = None,
                 windows_options: Optional['outputs.KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptions'] = None):
        """
        Configures pod-level security attributes and common container settings.
        """
        if fs_group is not None:
            pulumi.set(__self__, "fs_group", fs_group)
        if fs_group_change_policy is not None:
            pulumi.set(__self__, "fs_group_change_policy", fs_group_change_policy)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if supplemental_groups is not None:
            pulumi.set(__self__, "supplemental_groups", supplemental_groups)
        if sysctls is not None:
            pulumi.set(__self__, "sysctls", sysctls)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="fsGroup")
    def fs_group(self) -> Optional[int]:
        return pulumi.get(self, "fs_group")

    @property
    @pulumi.getter(name="fsGroupChangePolicy")
    def fs_group_change_policy(self) -> Optional[str]:
        return pulumi.get(self, "fs_group_change_policy")

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[int]:
        return pulumi.get(self, "run_as_group")

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[bool]:
        return pulumi.get(self, "run_as_non_root")

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[int]:
        return pulumi.get(self, "run_as_user")

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional['outputs.KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions']:
        return pulumi.get(self, "se_linux_options")

    @property
    @pulumi.getter(name="supplementalGroups")
    def supplemental_groups(self) -> Optional[Sequence[int]]:
        return pulumi.get(self, "supplemental_groups")

    @property
    @pulumi.getter
    def sysctls(self) -> Optional[Sequence['outputs.KafkaSpecZookeeperTemplatePodSecurityContextSysctls']]:
        return pulumi.get(self, "sysctls")

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional['outputs.KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptions']:
        return pulumi.get(self, "windows_options")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions(dict):
    def __init__(__self__, *,
                 level: Optional[str] = None,
                 role: Optional[str] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        return pulumi.get(self, "user")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplatePodSecurityContextSysctls(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptions(dict):
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[str] = None,
                 gmsa_credential_spec_name: Optional[str] = None,
                 run_as_user_name: Optional[str] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec")

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[str]:
        return pulumi.get(self, "run_as_user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplatePodTolerations(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 toleration_seconds: Optional[int] = None,
                 value: Optional[str] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if toleration_seconds is not None:
            pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> Optional[int]:
        return pulumi.get(self, "toleration_seconds")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplateStatefulset(dict):
    """
    Template for ZooKeeper `StatefulSet`.
    """
    def __init__(__self__, *,
                 metadata: Optional['outputs.KafkaSpecZookeeperTemplateStatefulsetMetadata'] = None,
                 pod_management_policy: Optional[str] = None):
        """
        Template for ZooKeeper `StatefulSet`.
        :param 'KafkaSpecZookeeperTemplateStatefulsetMetadataArgs' metadata: Metadata applied to the resource.
        :param str pod_management_policy: PodManagementPolicy which will be used for this StatefulSet. Valid values are `Parallel` and `OrderedReady`. Defaults to `Parallel`.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if pod_management_policy is not None:
            pulumi.set(__self__, "pod_management_policy", pod_management_policy)

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaSpecZookeeperTemplateStatefulsetMetadata']:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter(name="podManagementPolicy")
    def pod_management_policy(self) -> Optional[str]:
        """
        PodManagementPolicy which will be used for this StatefulSet. Valid values are `Parallel` and `OrderedReady`. Defaults to `Parallel`.
        """
        return pulumi.get(self, "pod_management_policy")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplateStatefulsetMetadata(dict):
    """
    Metadata applied to the resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata applied to the resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplateTlsSidecarContainer(dict):
    """
    Template for the Zookeeper server TLS sidecar container. The TLS sidecar is not used anymore and this option will be ignored.
    """
    def __init__(__self__, *,
                 env: Optional[Sequence['outputs.KafkaSpecZookeeperTemplateTlsSidecarContainerEnv']] = None,
                 security_context: Optional['outputs.KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContext'] = None):
        """
        Template for the Zookeeper server TLS sidecar container. The TLS sidecar is not used anymore and this option will be ignored.
        :param Sequence['KafkaSpecZookeeperTemplateTlsSidecarContainerEnvArgs'] env: Environment variables which should be applied to the container.
        :param 'KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextArgs' security_context: Security context for the container.
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)

    @property
    @pulumi.getter
    def env(self) -> Optional[Sequence['outputs.KafkaSpecZookeeperTemplateTlsSidecarContainerEnv']]:
        """
        Environment variables which should be applied to the container.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional['outputs.KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContext']:
        """
        Security context for the container.
        """
        return pulumi.get(self, "security_context")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplateTlsSidecarContainerEnv(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The environment variable key.
        :param str value: The environment variable value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The environment variable key.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The environment variable value.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContext(dict):
    """
    Security context for the container.
    """
    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[bool] = None,
                 capabilities: Optional['outputs.KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextCapabilities'] = None,
                 privileged: Optional[bool] = None,
                 proc_mount: Optional[str] = None,
                 read_only_root_filesystem: Optional[bool] = None,
                 run_as_group: Optional[int] = None,
                 run_as_non_root: Optional[bool] = None,
                 run_as_user: Optional[int] = None,
                 se_linux_options: Optional['outputs.KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextSeLinuxOptions'] = None,
                 windows_options: Optional['outputs.KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextWindowsOptions'] = None):
        """
        Security context for the container.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if proc_mount is not None:
            pulumi.set(__self__, "proc_mount", proc_mount)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[bool]:
        return pulumi.get(self, "allow_privilege_escalation")

    @property
    @pulumi.getter
    def capabilities(self) -> Optional['outputs.KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextCapabilities']:
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def privileged(self) -> Optional[bool]:
        return pulumi.get(self, "privileged")

    @property
    @pulumi.getter(name="procMount")
    def proc_mount(self) -> Optional[str]:
        return pulumi.get(self, "proc_mount")

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[bool]:
        return pulumi.get(self, "read_only_root_filesystem")

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[int]:
        return pulumi.get(self, "run_as_group")

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[bool]:
        return pulumi.get(self, "run_as_non_root")

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[int]:
        return pulumi.get(self, "run_as_user")

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional['outputs.KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextSeLinuxOptions']:
        return pulumi.get(self, "se_linux_options")

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional['outputs.KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextWindowsOptions']:
        return pulumi.get(self, "windows_options")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextCapabilities(dict):
    def __init__(__self__, *,
                 add: Optional[Sequence[str]] = None,
                 drop: Optional[Sequence[str]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)

    @property
    @pulumi.getter
    def add(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def drop(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "drop")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextSeLinuxOptions(dict):
    def __init__(__self__, *,
                 level: Optional[str] = None,
                 role: Optional[str] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        return pulumi.get(self, "user")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextWindowsOptions(dict):
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[str] = None,
                 gmsa_credential_spec_name: Optional[str] = None,
                 run_as_user_name: Optional[str] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec")

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[str]:
        return pulumi.get(self, "run_as_user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplateZookeeperContainer(dict):
    """
    Template for the ZooKeeper container.
    """
    def __init__(__self__, *,
                 env: Optional[Sequence['outputs.KafkaSpecZookeeperTemplateZookeeperContainerEnv']] = None,
                 security_context: Optional['outputs.KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext'] = None):
        """
        Template for the ZooKeeper container.
        :param Sequence['KafkaSpecZookeeperTemplateZookeeperContainerEnvArgs'] env: Environment variables which should be applied to the container.
        :param 'KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextArgs' security_context: Security context for the container.
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if security_context is not None:
            pulumi.set(__self__, "security_context", security_context)

    @property
    @pulumi.getter
    def env(self) -> Optional[Sequence['outputs.KafkaSpecZookeeperTemplateZookeeperContainerEnv']]:
        """
        Environment variables which should be applied to the container.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter(name="securityContext")
    def security_context(self) -> Optional['outputs.KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext']:
        """
        Security context for the container.
        """
        return pulumi.get(self, "security_context")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplateZookeeperContainerEnv(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The environment variable key.
        :param str value: The environment variable value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The environment variable key.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The environment variable value.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext(dict):
    """
    Security context for the container.
    """
    def __init__(__self__, *,
                 allow_privilege_escalation: Optional[bool] = None,
                 capabilities: Optional['outputs.KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextCapabilities'] = None,
                 privileged: Optional[bool] = None,
                 proc_mount: Optional[str] = None,
                 read_only_root_filesystem: Optional[bool] = None,
                 run_as_group: Optional[int] = None,
                 run_as_non_root: Optional[bool] = None,
                 run_as_user: Optional[int] = None,
                 se_linux_options: Optional['outputs.KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions'] = None,
                 windows_options: Optional['outputs.KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptions'] = None):
        """
        Security context for the container.
        """
        if allow_privilege_escalation is not None:
            pulumi.set(__self__, "allow_privilege_escalation", allow_privilege_escalation)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if privileged is not None:
            pulumi.set(__self__, "privileged", privileged)
        if proc_mount is not None:
            pulumi.set(__self__, "proc_mount", proc_mount)
        if read_only_root_filesystem is not None:
            pulumi.set(__self__, "read_only_root_filesystem", read_only_root_filesystem)
        if run_as_group is not None:
            pulumi.set(__self__, "run_as_group", run_as_group)
        if run_as_non_root is not None:
            pulumi.set(__self__, "run_as_non_root", run_as_non_root)
        if run_as_user is not None:
            pulumi.set(__self__, "run_as_user", run_as_user)
        if se_linux_options is not None:
            pulumi.set(__self__, "se_linux_options", se_linux_options)
        if windows_options is not None:
            pulumi.set(__self__, "windows_options", windows_options)

    @property
    @pulumi.getter(name="allowPrivilegeEscalation")
    def allow_privilege_escalation(self) -> Optional[bool]:
        return pulumi.get(self, "allow_privilege_escalation")

    @property
    @pulumi.getter
    def capabilities(self) -> Optional['outputs.KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextCapabilities']:
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def privileged(self) -> Optional[bool]:
        return pulumi.get(self, "privileged")

    @property
    @pulumi.getter(name="procMount")
    def proc_mount(self) -> Optional[str]:
        return pulumi.get(self, "proc_mount")

    @property
    @pulumi.getter(name="readOnlyRootFilesystem")
    def read_only_root_filesystem(self) -> Optional[bool]:
        return pulumi.get(self, "read_only_root_filesystem")

    @property
    @pulumi.getter(name="runAsGroup")
    def run_as_group(self) -> Optional[int]:
        return pulumi.get(self, "run_as_group")

    @property
    @pulumi.getter(name="runAsNonRoot")
    def run_as_non_root(self) -> Optional[bool]:
        return pulumi.get(self, "run_as_non_root")

    @property
    @pulumi.getter(name="runAsUser")
    def run_as_user(self) -> Optional[int]:
        return pulumi.get(self, "run_as_user")

    @property
    @pulumi.getter(name="seLinuxOptions")
    def se_linux_options(self) -> Optional['outputs.KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions']:
        return pulumi.get(self, "se_linux_options")

    @property
    @pulumi.getter(name="windowsOptions")
    def windows_options(self) -> Optional['outputs.KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptions']:
        return pulumi.get(self, "windows_options")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextCapabilities(dict):
    def __init__(__self__, *,
                 add: Optional[Sequence[str]] = None,
                 drop: Optional[Sequence[str]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if drop is not None:
            pulumi.set(__self__, "drop", drop)

    @property
    @pulumi.getter
    def add(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def drop(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "drop")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions(dict):
    def __init__(__self__, *,
                 level: Optional[str] = None,
                 role: Optional[str] = None,
                 type: Optional[str] = None,
                 user: Optional[str] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        return pulumi.get(self, "user")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptions(dict):
    def __init__(__self__, *,
                 gmsa_credential_spec: Optional[str] = None,
                 gmsa_credential_spec_name: Optional[str] = None,
                 run_as_user_name: Optional[str] = None):
        if gmsa_credential_spec is not None:
            pulumi.set(__self__, "gmsa_credential_spec", gmsa_credential_spec)
        if gmsa_credential_spec_name is not None:
            pulumi.set(__self__, "gmsa_credential_spec_name", gmsa_credential_spec_name)
        if run_as_user_name is not None:
            pulumi.set(__self__, "run_as_user_name", run_as_user_name)

    @property
    @pulumi.getter(name="gmsaCredentialSpec")
    def gmsa_credential_spec(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec")

    @property
    @pulumi.getter(name="gmsaCredentialSpecName")
    def gmsa_credential_spec_name(self) -> Optional[str]:
        return pulumi.get(self, "gmsa_credential_spec_name")

    @property
    @pulumi.getter(name="runAsUserName")
    def run_as_user_name(self) -> Optional[str]:
        return pulumi.get(self, "run_as_user_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTlsSidecar(dict):
    """
    TLS sidecar configuration. The TLS sidecar is not used anymore and this option will be ignored.
    """
    def __init__(__self__, *,
                 image: Optional[str] = None,
                 liveness_probe: Optional['outputs.KafkaSpecZookeeperTlsSidecarLivenessProbe'] = None,
                 log_level: Optional[str] = None,
                 readiness_probe: Optional['outputs.KafkaSpecZookeeperTlsSidecarReadinessProbe'] = None,
                 resources: Optional['outputs.KafkaSpecZookeeperTlsSidecarResources'] = None):
        """
        TLS sidecar configuration. The TLS sidecar is not used anymore and this option will be ignored.
        :param str image: The docker image for the container.
        :param 'KafkaSpecZookeeperTlsSidecarLivenessProbeArgs' liveness_probe: Pod liveness checking.
        :param str log_level: The log level for the TLS sidecar. Default value is `notice`.
        :param 'KafkaSpecZookeeperTlsSidecarReadinessProbeArgs' readiness_probe: Pod readiness checking.
        :param 'KafkaSpecZookeeperTlsSidecarResourcesArgs' resources: CPU and memory resources to reserve.
        """
        if image is not None:
            pulumi.set(__self__, "image", image)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        The docker image for the container.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional['outputs.KafkaSpecZookeeperTlsSidecarLivenessProbe']:
        """
        Pod liveness checking.
        """
        return pulumi.get(self, "liveness_probe")

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[str]:
        """
        The log level for the TLS sidecar. Default value is `notice`.
        """
        return pulumi.get(self, "log_level")

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional['outputs.KafkaSpecZookeeperTlsSidecarReadinessProbe']:
        """
        Pod readiness checking.
        """
        return pulumi.get(self, "readiness_probe")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.KafkaSpecZookeeperTlsSidecarResources']:
        """
        CPU and memory resources to reserve.
        """
        return pulumi.get(self, "resources")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTlsSidecarLivenessProbe(dict):
    """
    Pod liveness checking.
    """
    def __init__(__self__, *,
                 failure_threshold: Optional[int] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 timeout_seconds: Optional[int] = None):
        """
        Pod liveness checking.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param int initial_delay_seconds: The initial delay before first the health is first checked.
        :param int period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param int timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTlsSidecarReadinessProbe(dict):
    """
    Pod readiness checking.
    """
    def __init__(__self__, *,
                 failure_threshold: Optional[int] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 timeout_seconds: Optional[int] = None):
        """
        Pod readiness checking.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        :param int initial_delay_seconds: The initial delay before first the health is first checked.
        :param int period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        :param int timeout_seconds: The timeout for each attempted health check.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        The initial delay before first the health is first checked.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        The timeout for each attempted health check.
        """
        return pulumi.get(self, "timeout_seconds")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTlsSidecarResources(dict):
    """
    CPU and memory resources to reserve.
    """
    def __init__(__self__, *,
                 limits: Optional[Mapping[str, Any]] = None,
                 requests: Optional[Mapping[str, Any]] = None):
        """
        CPU and memory resources to reserve.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "requests")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaSpecZookeeperTolerations(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 operator: Optional[str] = None,
                 toleration_seconds: Optional[int] = None,
                 value: Optional[str] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if toleration_seconds is not None:
            pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> Optional[int]:
        return pulumi.get(self, "toleration_seconds")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaStatus(dict):
    """
    The status of the Kafka and ZooKeeper clusters, and Topic Operator.
    """
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.KafkaStatusConditions']] = None,
                 listeners: Optional[Sequence['outputs.KafkaStatusListeners']] = None,
                 observed_generation: Optional[int] = None):
        """
        The status of the Kafka and ZooKeeper clusters, and Topic Operator.
        :param Sequence['KafkaStatusConditionsArgs'] conditions: List of status conditions.
        :param Sequence['KafkaStatusListenersArgs'] listeners: Addresses of the internal and external listeners.
        :param int observed_generation: The generation of the CRD that was last reconciled by the operator.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if listeners is not None:
            pulumi.set(__self__, "listeners", listeners)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.KafkaStatusConditions']]:
        """
        List of status conditions.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def listeners(self) -> Optional[Sequence['outputs.KafkaStatusListeners']]:
        """
        Addresses of the internal and external listeners.
        """
        return pulumi.get(self, "listeners")

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[int]:
        """
        The generation of the CRD that was last reconciled by the operator.
        """
        return pulumi.get(self, "observed_generation")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaStatusConditions(dict):
    def __init__(__self__, *,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None,
                 status: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str last_transition_time: Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
        :param str message: Human-readable message indicating details about the condition's last transition.
        :param str reason: The reason for the condition's last transition (a single word in CamelCase).
        :param str status: The status of the condition, either True, False or Unknown.
        :param str type: The unique identifier of a condition, used to distinguish between other conditions in the resource.
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Human-readable message indicating details about the condition's last transition.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        The reason for the condition's last transition (a single word in CamelCase).
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The status of the condition, either True, False or Unknown.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The unique identifier of a condition, used to distinguish between other conditions in the resource.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaStatusListeners(dict):
    def __init__(__self__, *,
                 addresses: Optional[Sequence['outputs.KafkaStatusListenersAddresses']] = None,
                 bootstrap_servers: Optional[str] = None,
                 certificates: Optional[Sequence[str]] = None,
                 type: Optional[str] = None):
        """
        :param Sequence['KafkaStatusListenersAddressesArgs'] addresses: A list of the addresses for this listener.
        :param str bootstrap_servers: A comma-separated list of `host:port` pairs for connecting to the Kafka cluster using this listener.
        :param Sequence[str] certificates: A list of TLS certificates which can be used to verify the identity of the server when connecting to the given listener. Set only for `tls` and `external` listeners.
        :param str type: The type of the listener. Can be one of the following three types: `plain`, `tls`, and `external`.
        """
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)
        if bootstrap_servers is not None:
            pulumi.set(__self__, "bootstrap_servers", bootstrap_servers)
        if certificates is not None:
            pulumi.set(__self__, "certificates", certificates)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def addresses(self) -> Optional[Sequence['outputs.KafkaStatusListenersAddresses']]:
        """
        A list of the addresses for this listener.
        """
        return pulumi.get(self, "addresses")

    @property
    @pulumi.getter(name="bootstrapServers")
    def bootstrap_servers(self) -> Optional[str]:
        """
        A comma-separated list of `host:port` pairs for connecting to the Kafka cluster using this listener.
        """
        return pulumi.get(self, "bootstrap_servers")

    @property
    @pulumi.getter
    def certificates(self) -> Optional[Sequence[str]]:
        """
        A list of TLS certificates which can be used to verify the identity of the server when connecting to the given listener. Set only for `tls` and `external` listeners.
        """
        return pulumi.get(self, "certificates")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of the listener. Can be one of the following three types: `plain`, `tls`, and `external`.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaStatusListenersAddresses(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 port: Optional[int] = None):
        """
        :param str host: The DNS name or IP address of the Kafka bootstrap service.
        :param int port: The port of the Kafka bootstrap service.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The DNS name or IP address of the Kafka bootstrap service.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port of the Kafka bootstrap service.
        """
        return pulumi.get(self, "port")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaTopicSpec(dict):
    """
    The specification of the topic.
    """
    def __init__(__self__, *,
                 partitions: int,
                 replicas: int,
                 config: Optional[Mapping[str, Any]] = None,
                 topic_name: Optional[str] = None):
        """
        The specification of the topic.
        :param int partitions: The number of partitions the topic should have. This cannot be decreased after topic creation. It can be increased after topic creation, but it is important to understand the consequences that has, especially for topics with semantic partitioning.
        :param int replicas: The number of replicas the topic should have.
        :param Mapping[str, Any] config: The topic configuration.
        :param str topic_name: The name of the topic. When absent this will default to the metadata.name of the topic. It is recommended to not set this unless the topic name is not a valid Kubernetes resource name.
        """
        pulumi.set(__self__, "partitions", partitions)
        pulumi.set(__self__, "replicas", replicas)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if topic_name is not None:
            pulumi.set(__self__, "topic_name", topic_name)

    @property
    @pulumi.getter
    def partitions(self) -> int:
        """
        The number of partitions the topic should have. This cannot be decreased after topic creation. It can be increased after topic creation, but it is important to understand the consequences that has, especially for topics with semantic partitioning.
        """
        return pulumi.get(self, "partitions")

    @property
    @pulumi.getter
    def replicas(self) -> int:
        """
        The number of replicas the topic should have.
        """
        return pulumi.get(self, "replicas")

    @property
    @pulumi.getter
    def config(self) -> Optional[Mapping[str, Any]]:
        """
        The topic configuration.
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> Optional[str]:
        """
        The name of the topic. When absent this will default to the metadata.name of the topic. It is recommended to not set this unless the topic name is not a valid Kubernetes resource name.
        """
        return pulumi.get(self, "topic_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaTopicStatus(dict):
    """
    The status of the topic.
    """
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.KafkaTopicStatusConditions']] = None,
                 observed_generation: Optional[int] = None):
        """
        The status of the topic.
        :param Sequence['KafkaTopicStatusConditionsArgs'] conditions: List of status conditions.
        :param int observed_generation: The generation of the CRD that was last reconciled by the operator.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.KafkaTopicStatusConditions']]:
        """
        List of status conditions.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[int]:
        """
        The generation of the CRD that was last reconciled by the operator.
        """
        return pulumi.get(self, "observed_generation")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaTopicStatusConditions(dict):
    def __init__(__self__, *,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None,
                 status: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str last_transition_time: Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
        :param str message: Human-readable message indicating details about the condition's last transition.
        :param str reason: The reason for the condition's last transition (a single word in CamelCase).
        :param str status: The status of the condition, either True, False or Unknown.
        :param str type: The unique identifier of a condition, used to distinguish between other conditions in the resource.
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Human-readable message indicating details about the condition's last transition.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        The reason for the condition's last transition (a single word in CamelCase).
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The status of the condition, either True, False or Unknown.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The unique identifier of a condition, used to distinguish between other conditions in the resource.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaUserSpec(dict):
    """
    The specification of the user.
    """
    def __init__(__self__, *,
                 authentication: Optional['outputs.KafkaUserSpecAuthentication'] = None,
                 authorization: Optional['outputs.KafkaUserSpecAuthorization'] = None,
                 quotas: Optional['outputs.KafkaUserSpecQuotas'] = None,
                 template: Optional['outputs.KafkaUserSpecTemplate'] = None):
        """
        The specification of the user.
        :param 'KafkaUserSpecAuthenticationArgs' authentication: Authentication mechanism enabled for this Kafka user.
        :param 'KafkaUserSpecAuthorizationArgs' authorization: Authorization rules for this Kafka user.
        :param 'KafkaUserSpecQuotasArgs' quotas: Quotas on requests to control the broker resources used by clients. Network bandwidth and request rate quotas can be enforced.Kafka documentation for Kafka User quotas can be found at http://kafka.apache.org/documentation/#design_quotas.
        :param 'KafkaUserSpecTemplateArgs' template: Template to specify how Kafka User `Secrets` are generated.
        """
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if authorization is not None:
            pulumi.set(__self__, "authorization", authorization)
        if quotas is not None:
            pulumi.set(__self__, "quotas", quotas)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @property
    @pulumi.getter
    def authentication(self) -> Optional['outputs.KafkaUserSpecAuthentication']:
        """
        Authentication mechanism enabled for this Kafka user.
        """
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter
    def authorization(self) -> Optional['outputs.KafkaUserSpecAuthorization']:
        """
        Authorization rules for this Kafka user.
        """
        return pulumi.get(self, "authorization")

    @property
    @pulumi.getter
    def quotas(self) -> Optional['outputs.KafkaUserSpecQuotas']:
        """
        Quotas on requests to control the broker resources used by clients. Network bandwidth and request rate quotas can be enforced.Kafka documentation for Kafka User quotas can be found at http://kafka.apache.org/documentation/#design_quotas.
        """
        return pulumi.get(self, "quotas")

    @property
    @pulumi.getter
    def template(self) -> Optional['outputs.KafkaUserSpecTemplate']:
        """
        Template to specify how Kafka User `Secrets` are generated.
        """
        return pulumi.get(self, "template")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaUserSpecAuthentication(dict):
    """
    Authentication mechanism enabled for this Kafka user.
    """
    def __init__(__self__, *,
                 type: str):
        """
        Authentication mechanism enabled for this Kafka user.
        :param str type: Authentication type.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Authentication type.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaUserSpecAuthorization(dict):
    """
    Authorization rules for this Kafka user.
    """
    def __init__(__self__, *,
                 acls: Sequence['outputs.KafkaUserSpecAuthorizationAcls'],
                 type: str):
        """
        Authorization rules for this Kafka user.
        :param Sequence['KafkaUserSpecAuthorizationAclsArgs'] acls: List of ACL rules which should be applied to this user.
        :param str type: Authorization type. Currently the only supported type is `simple`. `simple` authorization type uses Kafka's `kafka.security.authorizer.AclAuthorizer` class for authorization.
        """
        pulumi.set(__self__, "acls", acls)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def acls(self) -> Sequence['outputs.KafkaUserSpecAuthorizationAcls']:
        """
        List of ACL rules which should be applied to this user.
        """
        return pulumi.get(self, "acls")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Authorization type. Currently the only supported type is `simple`. `simple` authorization type uses Kafka's `kafka.security.authorizer.AclAuthorizer` class for authorization.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaUserSpecAuthorizationAcls(dict):
    def __init__(__self__, *,
                 operation: str,
                 resource: 'outputs.KafkaUserSpecAuthorizationAclsResource',
                 host: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str operation: Operation which will be allowed or denied. Supported operations are: Read, Write, Create, Delete, Alter, Describe, ClusterAction, AlterConfigs, DescribeConfigs, IdempotentWrite and All.
        :param 'KafkaUserSpecAuthorizationAclsResourceArgs' resource: Indicates the resource for which given ACL rule applies.
        :param str host: The host from which the action described in the ACL rule is allowed or denied.
        :param str type: The type of the rule. Currently the only supported type is `allow`. ACL rules with type `allow` are used to allow user to execute the specified operations. Default value is `allow`.
        """
        pulumi.set(__self__, "operation", operation)
        pulumi.set(__self__, "resource", resource)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def operation(self) -> str:
        """
        Operation which will be allowed or denied. Supported operations are: Read, Write, Create, Delete, Alter, Describe, ClusterAction, AlterConfigs, DescribeConfigs, IdempotentWrite and All.
        """
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter
    def resource(self) -> 'outputs.KafkaUserSpecAuthorizationAclsResource':
        """
        Indicates the resource for which given ACL rule applies.
        """
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The host from which the action described in the ACL rule is allowed or denied.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of the rule. Currently the only supported type is `allow`. ACL rules with type `allow` are used to allow user to execute the specified operations. Default value is `allow`.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaUserSpecAuthorizationAclsResource(dict):
    """
    Indicates the resource for which given ACL rule applies.
    """
    def __init__(__self__, *,
                 type: str,
                 name: Optional[str] = None,
                 pattern_type: Optional[str] = None):
        """
        Indicates the resource for which given ACL rule applies.
        :param str type: Resource type. The available resource types are `topic`, `group`, `cluster`, and `transactionalId`.
        :param str name: Name of resource for which given ACL rule applies. Can be combined with `patternType` field to use prefix pattern.
        :param str pattern_type: Describes the pattern used in the resource field. The supported types are `literal` and `prefix`. With `literal` pattern type, the resource field will be used as a definition of a full name. With `prefix` pattern type, the resource name will be used only as a prefix. Default value is `literal`.
        """
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if pattern_type is not None:
            pulumi.set(__self__, "pattern_type", pattern_type)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Resource type. The available resource types are `topic`, `group`, `cluster`, and `transactionalId`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of resource for which given ACL rule applies. Can be combined with `patternType` field to use prefix pattern.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="patternType")
    def pattern_type(self) -> Optional[str]:
        """
        Describes the pattern used in the resource field. The supported types are `literal` and `prefix`. With `literal` pattern type, the resource field will be used as a definition of a full name. With `prefix` pattern type, the resource name will be used only as a prefix. Default value is `literal`.
        """
        return pulumi.get(self, "pattern_type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaUserSpecQuotas(dict):
    """
    Quotas on requests to control the broker resources used by clients. Network bandwidth and request rate quotas can be enforced.Kafka documentation for Kafka User quotas can be found at http://kafka.apache.org/documentation/#design_quotas.
    """
    def __init__(__self__, *,
                 consumer_byte_rate: Optional[int] = None,
                 producer_byte_rate: Optional[int] = None,
                 request_percentage: Optional[int] = None):
        """
        Quotas on requests to control the broker resources used by clients. Network bandwidth and request rate quotas can be enforced.Kafka documentation for Kafka User quotas can be found at http://kafka.apache.org/documentation/#design_quotas.
        :param int consumer_byte_rate: A quota on the maximum bytes per-second that each client group can fetch from a broker before the clients in the group are throttled. Defined on a per-broker basis.
        :param int producer_byte_rate: A quota on the maximum bytes per-second that each client group can publish to a broker before the clients in the group are throttled. Defined on a per-broker basis.
        :param int request_percentage: A quota on the maximum CPU utilization of each client group as a percentage of network and I/O threads.
        """
        if consumer_byte_rate is not None:
            pulumi.set(__self__, "consumer_byte_rate", consumer_byte_rate)
        if producer_byte_rate is not None:
            pulumi.set(__self__, "producer_byte_rate", producer_byte_rate)
        if request_percentage is not None:
            pulumi.set(__self__, "request_percentage", request_percentage)

    @property
    @pulumi.getter(name="consumerByteRate")
    def consumer_byte_rate(self) -> Optional[int]:
        """
        A quota on the maximum bytes per-second that each client group can fetch from a broker before the clients in the group are throttled. Defined on a per-broker basis.
        """
        return pulumi.get(self, "consumer_byte_rate")

    @property
    @pulumi.getter(name="producerByteRate")
    def producer_byte_rate(self) -> Optional[int]:
        """
        A quota on the maximum bytes per-second that each client group can publish to a broker before the clients in the group are throttled. Defined on a per-broker basis.
        """
        return pulumi.get(self, "producer_byte_rate")

    @property
    @pulumi.getter(name="requestPercentage")
    def request_percentage(self) -> Optional[int]:
        """
        A quota on the maximum CPU utilization of each client group as a percentage of network and I/O threads.
        """
        return pulumi.get(self, "request_percentage")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaUserSpecTemplate(dict):
    """
    Template to specify how Kafka User `Secrets` are generated.
    """
    def __init__(__self__, *,
                 secret: Optional['outputs.KafkaUserSpecTemplateSecret'] = None):
        """
        Template to specify how Kafka User `Secrets` are generated.
        :param 'KafkaUserSpecTemplateSecretArgs' secret: Template for KafkaUser resources. The template allows users to specify how the `Secret` with password or TLS certificates is generated.
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @property
    @pulumi.getter
    def secret(self) -> Optional['outputs.KafkaUserSpecTemplateSecret']:
        """
        Template for KafkaUser resources. The template allows users to specify how the `Secret` with password or TLS certificates is generated.
        """
        return pulumi.get(self, "secret")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaUserSpecTemplateSecret(dict):
    """
    Template for KafkaUser resources. The template allows users to specify how the `Secret` with password or TLS certificates is generated.
    """
    def __init__(__self__, *,
                 metadata: Optional['outputs.KafkaUserSpecTemplateSecretMetadata'] = None):
        """
        Template for KafkaUser resources. The template allows users to specify how the `Secret` with password or TLS certificates is generated.
        :param 'KafkaUserSpecTemplateSecretMetadataArgs' metadata: Metadata applied to the resource.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.KafkaUserSpecTemplateSecretMetadata']:
        """
        Metadata applied to the resource.
        """
        return pulumi.get(self, "metadata")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaUserSpecTemplateSecretMetadata(dict):
    """
    Metadata applied to the resource.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, Any]] = None,
                 labels: Optional[Mapping[str, Any]] = None):
        """
        Metadata applied to the resource.
        :param Mapping[str, Any] annotations: Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        :param Mapping[str, Any] labels: Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, Any]]:
        """
        Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, Any]]:
        """
        Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
        """
        return pulumi.get(self, "labels")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaUserStatus(dict):
    """
    The status of the Kafka User.
    """
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.KafkaUserStatusConditions']] = None,
                 observed_generation: Optional[int] = None,
                 secret: Optional[str] = None,
                 username: Optional[str] = None):
        """
        The status of the Kafka User.
        :param Sequence['KafkaUserStatusConditionsArgs'] conditions: List of status conditions.
        :param int observed_generation: The generation of the CRD that was last reconciled by the operator.
        :param str secret: The name of `Secret` where the credentials are stored.
        :param str username: Username.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.KafkaUserStatusConditions']]:
        """
        List of status conditions.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[int]:
        """
        The generation of the CRD that was last reconciled by the operator.
        """
        return pulumi.get(self, "observed_generation")

    @property
    @pulumi.getter
    def secret(self) -> Optional[str]:
        """
        The name of `Secret` where the credentials are stored.
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username.
        """
        return pulumi.get(self, "username")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class KafkaUserStatusConditions(dict):
    def __init__(__self__, *,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None,
                 status: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str last_transition_time: Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
        :param str message: Human-readable message indicating details about the condition's last transition.
        :param str reason: The reason for the condition's last transition (a single word in CamelCase).
        :param str status: The status of the condition, either True, False or Unknown.
        :param str type: The unique identifier of a condition, used to distinguish between other conditions in the resource.
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        Last time the condition of a type changed from one status to another. The required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Human-readable message indicating details about the condition's last transition.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        The reason for the condition's last transition (a single word in CamelCase).
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The status of the condition, either True, False or Unknown.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The unique identifier of a condition, used to distinguish between other conditions in the resource.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


