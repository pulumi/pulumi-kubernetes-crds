// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Kubernetes.Types.Outputs.Kafka.V1Alpha1
{

    [OutputType]
    public sealed class KafkaBridgeSpecAuthentication
    {
        /// <summary>
        /// Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
        /// </summary>
        public readonly Pulumi.Kubernetes.Types.Outputs.Kafka.V1Alpha1.KafkaBridgeSpecAuthenticationAccessToken AccessToken;
        /// <summary>
        /// Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
        /// </summary>
        public readonly bool AccessTokenIsJwt;
        /// <summary>
        /// Reference to the `Secret` which holds the certificate and private key pair.
        /// </summary>
        public readonly Pulumi.Kubernetes.Types.Outputs.Kafka.V1Alpha1.KafkaBridgeSpecAuthenticationCertificateAndKey CertificateAndKey;
        /// <summary>
        /// OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        /// </summary>
        public readonly string ClientId;
        /// <summary>
        /// Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
        /// </summary>
        public readonly Pulumi.Kubernetes.Types.Outputs.Kafka.V1Alpha1.KafkaBridgeSpecAuthenticationClientSecret ClientSecret;
        /// <summary>
        /// Enable or disable TLS hostname verification. Default value is `false`.
        /// </summary>
        public readonly bool DisableTlsHostnameVerification;
        /// <summary>
        /// Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.
        /// </summary>
        public readonly int MaxTokenExpirySeconds;
        /// <summary>
        /// Reference to the `Secret` which holds the password.
        /// </summary>
        public readonly Pulumi.Kubernetes.Types.Outputs.Kafka.V1Alpha1.KafkaBridgeSpecAuthenticationPasswordSecret PasswordSecret;
        /// <summary>
        /// Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
        /// </summary>
        public readonly Pulumi.Kubernetes.Types.Outputs.Kafka.V1Alpha1.KafkaBridgeSpecAuthenticationRefreshToken RefreshToken;
        /// <summary>
        /// OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.
        /// </summary>
        public readonly string Scope;
        /// <summary>
        /// Trusted certificates for TLS connection to the OAuth server.
        /// </summary>
        public readonly ImmutableArray<Pulumi.Kubernetes.Types.Outputs.Kafka.V1Alpha1.KafkaBridgeSpecAuthenticationTlsTrustedCertificates> TlsTrustedCertificates;
        /// <summary>
        /// Authorization server token endpoint URI.
        /// </summary>
        public readonly string TokenEndpointUri;
        /// <summary>
        /// Authentication type. Currently the only supported types are `tls`, `scram-sha-512`, and `plain`. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
        /// </summary>
        public readonly string Type;
        /// <summary>
        /// Username used for the authentication.
        /// </summary>
        public readonly string Username;

        [OutputConstructor]
        private KafkaBridgeSpecAuthentication(
            Pulumi.Kubernetes.Types.Outputs.Kafka.V1Alpha1.KafkaBridgeSpecAuthenticationAccessToken accessToken,

            bool accessTokenIsJwt,

            Pulumi.Kubernetes.Types.Outputs.Kafka.V1Alpha1.KafkaBridgeSpecAuthenticationCertificateAndKey certificateAndKey,

            string clientId,

            Pulumi.Kubernetes.Types.Outputs.Kafka.V1Alpha1.KafkaBridgeSpecAuthenticationClientSecret clientSecret,

            bool disableTlsHostnameVerification,

            int maxTokenExpirySeconds,

            Pulumi.Kubernetes.Types.Outputs.Kafka.V1Alpha1.KafkaBridgeSpecAuthenticationPasswordSecret passwordSecret,

            Pulumi.Kubernetes.Types.Outputs.Kafka.V1Alpha1.KafkaBridgeSpecAuthenticationRefreshToken refreshToken,

            string scope,

            ImmutableArray<Pulumi.Kubernetes.Types.Outputs.Kafka.V1Alpha1.KafkaBridgeSpecAuthenticationTlsTrustedCertificates> tlsTrustedCertificates,

            string tokenEndpointUri,

            string type,

            string username)
        {
            AccessToken = accessToken;
            AccessTokenIsJwt = accessTokenIsJwt;
            CertificateAndKey = certificateAndKey;
            ClientId = clientId;
            ClientSecret = clientSecret;
            DisableTlsHostnameVerification = disableTlsHostnameVerification;
            MaxTokenExpirySeconds = maxTokenExpirySeconds;
            PasswordSecret = passwordSecret;
            RefreshToken = refreshToken;
            Scope = scope;
            TlsTrustedCertificates = tlsTrustedCertificates;
            TokenEndpointUri = tokenEndpointUri;
            Type = type;
            Username = username;
        }
    }
}
